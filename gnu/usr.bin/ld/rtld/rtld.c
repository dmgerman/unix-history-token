begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993 Paul Kranenburg  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Paul Kranenburg.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *	$Id: rtld.c,v 1.24.4.1 1995/08/25 07:08:26 davidg Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_COPY
end_ifndef

begin_define
define|#
directive|define
name|MAP_COPY
value|MAP_PRIVATE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_ANON
end_ifndef

begin_define
define|#
directive|define
name|MAP_ANON
value|0
end_define

begin_define
define|#
directive|define
name|anon_open
parameter_list|()
value|do {					\ 	if ((anon_fd = open("/dev/zero", O_RDWR, 0)) == -1)	\ 		err("open: %s", "/dev/zero");			\ } while (0)
end_define

begin_define
define|#
directive|define
name|anon_close
parameter_list|()
value|do {	\ 	(void)close(anon_fd);	\ 	anon_fd = -1;		\ } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|anon_open
parameter_list|()
end_define

begin_define
define|#
directive|define
name|anon_close
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Loader private data, hung off<so_map>->som_spd  */
end_comment

begin_struct
struct|struct
name|somap_private
block|{
name|int
name|spd_version
decl_stmt|;
name|struct
name|so_map
modifier|*
name|spd_parent
decl_stmt|;
name|int
name|spd_refcount
decl_stmt|;
name|int
name|spd_flags
decl_stmt|;
define|#
directive|define
name|RTLD_MAIN
value|1
define|#
directive|define
name|RTLD_RTLD
value|2
define|#
directive|define
name|RTLD_DL
value|4
define|#
directive|define
name|RTLD_INIT
value|8
name|unsigned
name|long
name|a_text
decl_stmt|;
comment|/* text size, if known     */
name|unsigned
name|long
name|a_data
decl_stmt|;
comment|/* initialized data size   */
name|unsigned
name|long
name|a_bss
decl_stmt|;
comment|/* uninitialized data size */
ifdef|#
directive|ifdef
name|SUN_COMPAT
name|long
name|spd_offset
decl_stmt|;
comment|/* Correction for Sun main programs */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|LM_PRIVATE
parameter_list|(
name|smp
parameter_list|)
value|((struct somap_private *)(smp)->som_spd)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SUN_COMPAT
end_ifdef

begin_define
define|#
directive|define
name|LM_OFFSET
parameter_list|(
name|smp
parameter_list|)
value|(LM_PRIVATE(smp)->spd_offset)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LM_OFFSET
parameter_list|(
name|smp
parameter_list|)
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Base address for section_dispatch_table entries */
end_comment

begin_define
define|#
directive|define
name|LM_LDBASE
parameter_list|(
name|smp
parameter_list|)
value|(smp->som_addr + LM_OFFSET(smp))
end_define

begin_comment
comment|/* Start of text segment */
end_comment

begin_define
define|#
directive|define
name|LM_TXTADDR
parameter_list|(
name|smp
parameter_list|)
value|(smp->som_addr == (caddr_t)0 ? PAGSIZ : 0)
end_define

begin_comment
comment|/* Start of run-time relocation_info */
end_comment

begin_define
define|#
directive|define
name|LM_REL
parameter_list|(
name|smp
parameter_list|)
value|((struct relocation_info *) \ 	(smp->som_addr + LM_OFFSET(smp) + LD_REL((smp)->som_dynamic)))
end_define

begin_comment
comment|/* Start of symbols */
end_comment

begin_define
define|#
directive|define
name|LM_SYMBOL
parameter_list|(
name|smp
parameter_list|,
name|i
parameter_list|)
value|((struct nzlist *) \ 	(smp->som_addr + LM_OFFSET(smp) + LD_SYMBOL((smp)->som_dynamic) + \ 		i * (LD_VERSION_NZLIST_P(smp->som_dynamic->d_version) ? \ 			sizeof(struct nzlist) : sizeof(struct nlist))))
end_define

begin_comment
comment|/* Start of hash table */
end_comment

begin_define
define|#
directive|define
name|LM_HASH
parameter_list|(
name|smp
parameter_list|)
value|((struct rrs_hash *) \ 	((smp)->som_addr + LM_OFFSET(smp) + LD_HASH((smp)->som_dynamic)))
end_define

begin_comment
comment|/* Start of strings */
end_comment

begin_define
define|#
directive|define
name|LM_STRINGS
parameter_list|(
name|smp
parameter_list|)
value|((char *) \ 	((smp)->som_addr + LM_OFFSET(smp) + LD_STRINGS((smp)->som_dynamic)))
end_define

begin_comment
comment|/* End of text */
end_comment

begin_define
define|#
directive|define
name|LM_ETEXT
parameter_list|(
name|smp
parameter_list|)
value|((char *) \ 	((smp)->som_addr + LM_TXTADDR(smp) + LD_TEXTSZ((smp)->som_dynamic)))
end_define

begin_comment
comment|/* Needed shared objects */
end_comment

begin_define
define|#
directive|define
name|LM_NEED
parameter_list|(
name|smp
parameter_list|)
value|((struct sod *) \ 	((smp)->som_addr + LM_TXTADDR(smp) + LD_NEED((smp)->som_dynamic)))
end_define

begin_comment
comment|/* PLT is in data segment, so don't use LM_OFFSET here */
end_comment

begin_define
define|#
directive|define
name|LM_PLT
parameter_list|(
name|smp
parameter_list|)
value|((jmpslot_t *) \ 	((smp)->som_addr + LD_PLT((smp)->som_dynamic)))
end_define

begin_comment
comment|/* Parent of link map */
end_comment

begin_define
define|#
directive|define
name|LM_PARENT
parameter_list|(
name|smp
parameter_list|)
value|(LM_PRIVATE(smp)->spd_parent)
end_define

begin_decl_stmt
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|__progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uid_t
name|uid
decl_stmt|,
name|euid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gid_t
name|gid
decl_stmt|,
name|egid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|careful
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|__main_progname
index|[]
init|=
literal|"main"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|main_progname
init|=
name|__main_progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|us
index|[]
init|=
literal|"/usr/libexec/ld.so"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|anon_fd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|so_map
modifier|*
name|link_map_head
decl_stmt|,
modifier|*
name|main_map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|so_map
modifier|*
modifier|*
name|link_map_tail
init|=
operator|&
name|link_map_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rt_symbol
modifier|*
name|rt_symbol_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|__dlopen
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|__dlclose
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|__dlsym
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|__dlerror
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|__dlexit
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ld_entry
name|ld_entry
init|=
block|{
name|__dlopen
block|,
name|__dlclose
block|,
name|__dlsym
block|,
name|__dlerror
block|,
name|__dlexit
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|xprintf
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|load_objects
name|__P
argument_list|(
operator|(
expr|struct
name|crt_ldso
operator|*
operator|,
expr|struct
name|_dynamic
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|so_map
modifier|*
name|map_object
name|__P
argument_list|(
operator|(
expr|struct
name|sod
operator|*
operator|,
expr|struct
name|so_map
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unmap_object
name|__P
argument_list|(
operator|(
expr|struct
name|so_map
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|so_map
modifier|*
name|load_object
name|__P
argument_list|(
operator|(
expr|struct
name|sod
operator|*
operator|,
expr|struct
name|so_map
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unload_object
name|__P
argument_list|(
operator|(
expr|struct
name|so_map
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|so_map
modifier|*
name|alloc_link_map
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|sod
operator|*
operator|,
expr|struct
name|so_map
operator|*
operator|,
name|caddr_t
operator|,
expr|struct
name|_dynamic
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|check_text_reloc
name|__P
argument_list|(
operator|(
expr|struct
name|relocation_info
operator|*
operator|,
expr|struct
name|so_map
operator|*
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reloc_map
name|__P
argument_list|(
operator|(
expr|struct
name|so_map
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reloc_copy
name|__P
argument_list|(
operator|(
expr|struct
name|so_map
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_map
name|__P
argument_list|(
operator|(
expr|struct
name|so_map
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|call_map
name|__P
argument_list|(
operator|(
expr|struct
name|so_map
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rtfindlib
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|binder_entry
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|binder
name|__P
argument_list|(
operator|(
name|jmpslot_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|nzlist
modifier|*
name|lookup
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|so_map
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|struct
name|rt_symbol
modifier|*
name|lookup_rts
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|rt_symbol
modifier|*
name|enter_rts
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|long
operator|,
name|int
operator|,
name|caddr_t
operator|,
name|long
operator|,
expr|struct
name|so_map
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|generror
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maphints
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unmaphints
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dl_cascade
name|__P
argument_list|(
operator|(
expr|struct
name|so_map
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|int
name|strcmp
parameter_list|(
specifier|register
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
specifier|register
specifier|const
name|char
modifier|*
name|s2
parameter_list|)
block|{
while|while
condition|(
operator|*
name|s1
operator|==
operator|*
name|s2
operator|++
condition|)
if|if
condition|(
operator|*
name|s1
operator|++
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s1
operator|-
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|--
name|s2
operator|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"md-static-funcs.c"
end_include

begin_comment
comment|/*  * Called from assembler stub that has set up crtp (passed from crt0)  * and dp (our __DYNAMIC).  */
end_comment

begin_function
name|int
name|rtld
parameter_list|(
name|version
parameter_list|,
name|crtp
parameter_list|,
name|dp
parameter_list|)
name|int
name|version
decl_stmt|;
name|struct
name|crt_ldso
modifier|*
name|crtp
decl_stmt|;
name|struct
name|_dynamic
modifier|*
name|dp
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|nreloc
decl_stmt|;
comment|/* # of ld.so relocations */
name|struct
name|relocation_info
modifier|*
name|reloc
decl_stmt|;
name|struct
name|so_debug
modifier|*
name|ddp
decl_stmt|;
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
comment|/* Check version */
if|if
condition|(
name|version
operator|!=
name|CRT_VERSION_BSD_2
operator|&&
name|version
operator|!=
name|CRT_VERSION_BSD_3
operator|&&
name|version
operator|!=
name|CRT_VERSION_SUN
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Fixup __DYNAMIC structure */
operator|(
name|long
operator|)
name|dp
operator|->
name|d_un
operator|.
name|d_sdt
operator|+=
name|crtp
operator|->
name|crt_ba
expr_stmt|;
comment|/* Divide by hand to avoid possible use of library division routine */
for|for
control|(
name|nreloc
operator|=
literal|0
operator|,
name|n
operator|=
name|LD_RELSZ
argument_list|(
name|dp
argument_list|)
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
control|)
name|nreloc
operator|++
expr_stmt|;
comment|/* Relocate ourselves */
for|for
control|(
name|reloc
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
operator|(
name|LD_REL
argument_list|(
name|dp
argument_list|)
operator|+
name|crtp
operator|->
name|crt_ba
operator|)
init|;
name|nreloc
condition|;
name|nreloc
operator|--
operator|,
name|reloc
operator|++
control|)
block|{
specifier|register
name|long
name|addr
init|=
name|reloc
operator|->
name|r_address
operator|+
name|crtp
operator|->
name|crt_ba
decl_stmt|;
name|md_relocate_simple
argument_list|(
name|reloc
argument_list|,
name|crtp
operator|->
name|crt_ba
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|__progname
operator|=
literal|"ld.so"
expr_stmt|;
if|if
condition|(
name|version
operator|>=
name|CRT_VERSION_BSD_3
condition|)
name|main_progname
operator|=
name|crtp
operator|->
name|crt_prog
expr_stmt|;
comment|/* Setup out (private) environ variable */
name|environ
operator|=
name|crtp
operator|->
name|crt_ep
expr_stmt|;
comment|/* Get user and group identifiers */
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|euid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
name|gid
operator|=
name|getgid
argument_list|()
expr_stmt|;
name|egid
operator|=
name|getegid
argument_list|()
expr_stmt|;
name|careful
operator|=
operator|(
name|uid
operator|!=
name|euid
operator|)
operator|||
operator|(
name|gid
operator|!=
name|egid
operator|)
expr_stmt|;
if|if
condition|(
name|careful
condition|)
block|{
name|unsetenv
argument_list|(
literal|"LD_LIBRARY_PATH"
argument_list|)
expr_stmt|;
name|unsetenv
argument_list|(
literal|"LD_PRELOAD"
argument_list|)
expr_stmt|;
block|}
comment|/* Setup directory search */
name|add_search_path
argument_list|(
name|getenv
argument_list|(
literal|"LD_LIBRARY_PATH"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"LD_NOSTD_PATH"
argument_list|)
operator|==
name|NULL
condition|)
name|std_search_path
argument_list|()
expr_stmt|;
name|anon_open
argument_list|()
expr_stmt|;
comment|/* Load required objects into the process address space */
name|load_objects
argument_list|(
name|crtp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
comment|/* Fill in some fields in main's __DYNAMIC structure */
name|crtp
operator|->
name|crt_dp
operator|->
name|d_entry
operator|=
operator|&
name|ld_entry
expr_stmt|;
name|crtp
operator|->
name|crt_dp
operator|->
name|d_un
operator|.
name|d_sdt
operator|->
name|sdt_loaded
operator|=
name|link_map_head
operator|->
name|som_next
expr_stmt|;
comment|/* Relocate all loaded objects according to their RRS segments */
for|for
control|(
name|smp
operator|=
name|link_map_head
init|;
name|smp
condition|;
name|smp
operator|=
name|smp
operator|->
name|som_next
control|)
block|{
if|if
condition|(
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_flags
operator|&
name|RTLD_RTLD
condition|)
continue|continue;
if|if
condition|(
name|reloc_map
argument_list|(
name|smp
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* Copy any relocated initialized data. */
for|for
control|(
name|smp
operator|=
name|link_map_head
init|;
name|smp
condition|;
name|smp
operator|=
name|smp
operator|->
name|som_next
control|)
block|{
if|if
condition|(
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_flags
operator|&
name|RTLD_RTLD
condition|)
continue|continue;
name|reloc_copy
argument_list|(
name|smp
argument_list|)
expr_stmt|;
block|}
comment|/* Call any object initialization routines. */
for|for
control|(
name|smp
operator|=
name|link_map_head
init|;
name|smp
condition|;
name|smp
operator|=
name|smp
operator|->
name|som_next
control|)
block|{
if|if
condition|(
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_flags
operator|&
name|RTLD_RTLD
condition|)
continue|continue;
name|init_map
argument_list|(
name|smp
argument_list|,
literal|".init"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ddp
operator|=
name|crtp
operator|->
name|crt_dp
operator|->
name|d_debug
expr_stmt|;
name|ddp
operator|->
name|dd_cc
operator|=
name|rt_symbol_head
expr_stmt|;
if|if
condition|(
name|ddp
operator|->
name|dd_in_debugger
condition|)
block|{
name|caddr_t
name|addr
init|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|long
operator|)
name|crtp
operator|->
name|crt_bp
operator|&
operator|(
operator|~
operator|(
name|PAGSIZ
operator|-
literal|1
operator|)
operator|)
argument_list|)
decl_stmt|;
comment|/* Set breakpoint for the benefit of debuggers */
if|if
condition|(
name|mprotect
argument_list|(
name|addr
argument_list|,
name|PAGSIZ
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
operator||
name|PROT_EXEC
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"Cannot set breakpoint (%s)"
argument_list|,
name|main_progname
argument_list|)
expr_stmt|;
block|}
name|md_set_breakpoint
argument_list|(
operator|(
name|long
operator|)
name|crtp
operator|->
name|crt_bp
argument_list|,
operator|(
name|long
operator|*
operator|)
operator|&
name|ddp
operator|->
name|dd_bpt_shadow
argument_list|)
expr_stmt|;
if|if
condition|(
name|mprotect
argument_list|(
name|addr
argument_list|,
name|PAGSIZ
argument_list|,
name|PROT_READ
operator||
name|PROT_EXEC
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"Cannot re-protect breakpoint (%s)"
argument_list|,
name|main_progname
argument_list|)
expr_stmt|;
block|}
name|ddp
operator|->
name|dd_bpt_addr
operator|=
name|crtp
operator|->
name|crt_bp
expr_stmt|;
if|if
condition|(
name|link_map_head
condition|)
name|ddp
operator|->
name|dd_sym_loaded
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Close the hints file */
name|unmaphints
argument_list|()
expr_stmt|;
comment|/* Close our file descriptor */
operator|(
name|void
operator|)
name|close
argument_list|(
name|crtp
operator|->
name|crt_ldfd
argument_list|)
expr_stmt|;
name|anon_close
argument_list|()
expr_stmt|;
return|return
name|LDSO_VERSION_HAS_DLEXIT
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|load_objects
parameter_list|(
name|crtp
parameter_list|,
name|dp
parameter_list|)
name|struct
name|crt_ldso
modifier|*
name|crtp
decl_stmt|;
name|struct
name|_dynamic
modifier|*
name|dp
decl_stmt|;
block|{
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
name|int
name|tracing
init|=
operator|(
name|int
operator|)
name|getenv
argument_list|(
literal|"LD_TRACE_LOADED_OBJECTS"
argument_list|)
decl_stmt|;
comment|/* Handle LD_PRELOAD's here */
comment|/* Make an entry for the main program */
name|smp
operator|=
name|alloc_link_map
argument_list|(
name|main_progname
argument_list|,
operator|(
expr|struct
name|sod
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|so_map
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|crtp
operator|->
name|crt_dp
argument_list|)
expr_stmt|;
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_refcount
operator|++
expr_stmt|;
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_flags
operator||=
name|RTLD_MAIN
expr_stmt|;
comment|/* Make an entry for ourselves */
name|smp
operator|=
name|alloc_link_map
argument_list|(
name|us
argument_list|,
operator|(
expr|struct
name|sod
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|so_map
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
name|crtp
operator|->
name|crt_ba
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_refcount
operator|++
expr_stmt|;
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_flags
operator||=
name|RTLD_RTLD
expr_stmt|;
for|for
control|(
name|smp
operator|=
name|link_map_head
init|;
name|smp
condition|;
name|smp
operator|=
name|smp
operator|->
name|som_next
control|)
block|{
name|struct
name|sod
modifier|*
name|sodp
decl_stmt|;
name|long
name|next
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_flags
operator|&
name|RTLD_RTLD
condition|)
continue|continue;
if|if
condition|(
name|smp
operator|->
name|som_dynamic
condition|)
name|next
operator|=
name|LD_NEED
argument_list|(
name|smp
operator|->
name|som_dynamic
argument_list|)
expr_stmt|;
while|while
condition|(
name|next
condition|)
block|{
name|struct
name|so_map
modifier|*
name|newmap
decl_stmt|;
name|sodp
operator|=
operator|(
expr|struct
name|sod
operator|*
operator|)
operator|(
name|LM_LDBASE
argument_list|(
name|smp
argument_list|)
operator|+
name|next
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|newmap
operator|=
name|map_object
argument_list|(
name|sodp
argument_list|,
name|smp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|tracing
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %s"
argument_list|,
name|main_progname
argument_list|,
name|__dlerror
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|newmap
operator|=
name|alloc_link_map
argument_list|(
name|NULL
argument_list|,
name|sodp
argument_list|,
name|smp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|LM_PRIVATE
argument_list|(
name|newmap
argument_list|)
operator|->
name|spd_refcount
operator|++
expr_stmt|;
name|next
operator|=
name|sodp
operator|->
name|sod_next
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|tracing
condition|)
return|return;
for|for
control|(
name|smp
operator|=
name|link_map_head
init|;
name|smp
condition|;
name|smp
operator|=
name|smp
operator|->
name|som_next
control|)
block|{
name|struct
name|sod
modifier|*
name|sodp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|path
decl_stmt|;
if|if
condition|(
operator|(
name|sodp
operator|=
name|smp
operator|->
name|som_sod
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|name
operator|=
name|sodp
operator|->
name|sod_name
operator|+
name|LM_LDBASE
argument_list|(
name|LM_PARENT
argument_list|(
name|smp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|path
operator|=
name|smp
operator|->
name|som_path
operator|)
operator|==
name|NULL
condition|)
name|path
operator|=
literal|"not found"
expr_stmt|;
if|if
condition|(
name|sodp
operator|->
name|sod_library
condition|)
name|printf
argument_list|(
literal|"\t-l%s.%d => %s (%p)\n"
argument_list|,
name|name
argument_list|,
name|sodp
operator|->
name|sod_major
argument_list|,
name|path
argument_list|,
name|smp
operator|->
name|som_addr
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\t%s => %s (%p)\n"
argument_list|,
name|name
argument_list|,
name|path
argument_list|,
name|smp
operator|->
name|som_addr
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new link map for shared object NAME loaded at ADDR as a  * result of the presence of link object LOP in the link map PARENT.  */
end_comment

begin_function
specifier|static
name|struct
name|so_map
modifier|*
name|alloc_link_map
parameter_list|(
name|path
parameter_list|,
name|sodp
parameter_list|,
name|parent
parameter_list|,
name|addr
parameter_list|,
name|dp
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|struct
name|sod
modifier|*
name|sodp
decl_stmt|;
name|struct
name|so_map
modifier|*
name|parent
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|struct
name|_dynamic
modifier|*
name|dp
decl_stmt|;
block|{
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
name|struct
name|somap_private
modifier|*
name|smpp
decl_stmt|;
name|size_t
name|smp_size
decl_stmt|;
comment|/*          * Allocate so_map and private area with a single malloc.  Round          * up the size of so_map so the private area is aligned.          */
name|smp_size
operator|=
operator|(
operator|(
operator|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|so_map
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|)
expr_stmt|;
name|smp
operator|=
operator|(
expr|struct
name|so_map
operator|*
operator|)
name|xmalloc
argument_list|(
name|smp_size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|somap_private
argument_list|)
argument_list|)
expr_stmt|;
name|smpp
operator|=
operator|(
expr|struct
name|somap_private
operator|*
operator|)
operator|(
operator|(
operator|(
name|caddr_t
operator|)
name|smp
operator|)
operator|+
name|smp_size
operator|)
expr_stmt|;
name|smp
operator|->
name|som_next
operator|=
name|NULL
expr_stmt|;
operator|*
name|link_map_tail
operator|=
name|smp
expr_stmt|;
name|link_map_tail
operator|=
operator|&
name|smp
operator|->
name|som_next
expr_stmt|;
name|smp
operator|->
name|som_addr
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
name|smp
operator|->
name|som_path
operator|=
name|NULL
expr_stmt|;
else|else
name|smp
operator|->
name|som_path
operator|=
name|strdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|smp
operator|->
name|som_sod
operator|=
name|sodp
expr_stmt|;
name|smp
operator|->
name|som_dynamic
operator|=
name|dp
expr_stmt|;
name|smp
operator|->
name|som_spd
operator|=
operator|(
name|caddr_t
operator|)
name|smpp
expr_stmt|;
comment|/*XXX*/
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
name|main_map
operator|=
name|smp
expr_stmt|;
name|smpp
operator|->
name|spd_refcount
operator|=
literal|0
expr_stmt|;
name|smpp
operator|->
name|spd_flags
operator|=
literal|0
expr_stmt|;
name|smpp
operator|->
name|spd_parent
operator|=
name|parent
expr_stmt|;
name|smpp
operator|->
name|a_text
operator|=
literal|0
expr_stmt|;
name|smpp
operator|->
name|a_data
operator|=
literal|0
expr_stmt|;
name|smpp
operator|->
name|a_bss
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SUN_COMPAT
name|smpp
operator|->
name|spd_offset
operator|=
operator|(
name|addr
operator|==
literal|0
operator|&&
name|dp
operator|&&
name|dp
operator|->
name|d_version
operator|==
name|LD_VERSION_SUN
operator|)
condition|?
name|PAGSIZ
else|:
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
name|smp
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|so_map
modifier|*
name|find_object
parameter_list|(
name|sodp
parameter_list|,
name|smp
parameter_list|)
name|struct
name|sod
modifier|*
name|sodp
decl_stmt|;
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
block|{
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|sodp
operator|->
name|sod_name
operator|+
name|LM_LDBASE
argument_list|(
name|smp
argument_list|)
operator|)
decl_stmt|;
name|int
name|usehints
init|=
literal|0
decl_stmt|;
name|struct
name|so_map
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|sodp
operator|->
name|sod_library
condition|)
block|{
name|usehints
operator|=
literal|1
expr_stmt|;
name|again
label|:
name|path
operator|=
name|rtfindlib
argument_list|(
name|name
argument_list|,
name|sodp
operator|->
name|sod_major
argument_list|,
name|sodp
operator|->
name|sod_minor
argument_list|,
operator|&
name|usehints
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|generror
argument_list|(
literal|"Can't find shared library \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|careful
operator|&&
operator|*
name|name
operator|!=
literal|'/'
condition|)
block|{
name|generror
argument_list|(
literal|"Shared library path must start with \"/\" for \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|path
operator|=
name|name
expr_stmt|;
block|}
comment|/* Check if already loaded */
for|for
control|(
name|p
operator|=
name|link_map_head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|som_next
control|)
if|if
condition|(
name|p
operator|->
name|som_path
operator|&&
name|strcmp
argument_list|(
name|p
operator|->
name|som_path
argument_list|,
name|path
argument_list|)
operator|==
literal|0
condition|)
break|break;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * Map object identified by link object sodp which was found in link  * map smp.  Returns a pointer to the link map for the requested object.  *  * On failure, it sets an error message that can be retrieved by __dlerror,  * and returns NULL.  */
end_comment

begin_function
specifier|static
name|struct
name|so_map
modifier|*
name|map_object
parameter_list|(
name|sodp
parameter_list|,
name|smp
parameter_list|)
name|struct
name|sod
modifier|*
name|sodp
decl_stmt|;
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
block|{
name|struct
name|_dynamic
modifier|*
name|dp
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|sodp
operator|->
name|sod_name
operator|+
name|LM_LDBASE
argument_list|(
name|smp
argument_list|)
operator|)
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|struct
name|exec
name|hdr
decl_stmt|;
name|int
name|usehints
init|=
literal|0
decl_stmt|;
name|struct
name|so_map
modifier|*
name|p
decl_stmt|;
name|struct
name|somap_private
modifier|*
name|smpp
decl_stmt|;
if|if
condition|(
name|sodp
operator|->
name|sod_library
condition|)
block|{
name|usehints
operator|=
literal|1
expr_stmt|;
name|again
label|:
name|path
operator|=
name|rtfindlib
argument_list|(
name|name
argument_list|,
name|sodp
operator|->
name|sod_major
argument_list|,
name|sodp
operator|->
name|sod_minor
argument_list|,
operator|&
name|usehints
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|generror
argument_list|(
literal|"Can't find shared library"
literal|" \"lib%s.so.%d.%d\""
argument_list|,
name|name
argument_list|,
name|sodp
operator|->
name|sod_major
argument_list|,
name|sodp
operator|->
name|sod_minor
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|careful
operator|&&
operator|*
name|name
operator|!=
literal|'/'
condition|)
block|{
name|generror
argument_list|(
literal|"Shared library path must start with \"/\" for \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|path
operator|=
name|name
expr_stmt|;
block|}
comment|/* Check if already loaded */
for|for
control|(
name|p
operator|=
name|link_map_head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|som_next
control|)
if|if
condition|(
name|p
operator|->
name|som_path
operator|&&
name|strcmp
argument_list|(
name|p
operator|->
name|som_path
argument_list|,
name|path
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
return|return
name|p
return|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|usehints
condition|)
block|{
name|usehints
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|generror
argument_list|(
literal|"open failed for \"%s\" : %s"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|generror
argument_list|(
literal|"header read failed for \"%s\""
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|N_BADMAG
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|generror
argument_list|(
literal|"bad magic number in \"%s\""
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|addr
operator|=
name|mmap
argument_list|(
literal|0
argument_list|,
name|hdr
operator|.
name|a_text
operator|+
name|hdr
operator|.
name|a_data
operator|+
name|hdr
operator|.
name|a_bss
argument_list|,
name|PROT_READ
operator||
name|PROT_EXEC
argument_list|,
name|MAP_COPY
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|(
name|caddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|generror
argument_list|(
literal|"mmap failed for \"%s\" : %s"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|mprotect
argument_list|(
name|addr
operator|+
name|hdr
operator|.
name|a_text
argument_list|,
name|hdr
operator|.
name|a_data
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
operator||
name|PROT_EXEC
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|generror
argument_list|(
literal|"mprotect failed for \"%s\" : %s"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|mmap
argument_list|(
name|addr
operator|+
name|hdr
operator|.
name|a_text
operator|+
name|hdr
operator|.
name|a_data
argument_list|,
name|hdr
operator|.
name|a_bss
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
operator||
name|PROT_EXEC
argument_list|,
name|MAP_ANON
operator||
name|MAP_COPY
operator||
name|MAP_FIXED
argument_list|,
name|anon_fd
argument_list|,
literal|0
argument_list|)
operator|==
operator|(
name|caddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|generror
argument_list|(
literal|"mmap failed for \"%s\" : %s"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Assume _DYNAMIC is the first data item */
name|dp
operator|=
operator|(
expr|struct
name|_dynamic
operator|*
operator|)
operator|(
name|addr
operator|+
name|hdr
operator|.
name|a_text
operator|)
expr_stmt|;
comment|/* Fixup __DYNAMIC structure */
operator|(
name|long
operator|)
name|dp
operator|->
name|d_un
operator|.
name|d_sdt
operator|+=
operator|(
name|long
operator|)
name|addr
expr_stmt|;
name|p
operator|=
name|alloc_link_map
argument_list|(
name|path
argument_list|,
name|sodp
argument_list|,
name|smp
argument_list|,
name|addr
argument_list|,
name|dp
argument_list|)
expr_stmt|;
comment|/* save segment sizes for unmap. */
name|smpp
operator|=
name|LM_PRIVATE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|smpp
operator|->
name|a_text
operator|=
name|hdr
operator|.
name|a_text
expr_stmt|;
name|smpp
operator|->
name|a_data
operator|=
name|hdr
operator|.
name|a_data
expr_stmt|;
name|smpp
operator|->
name|a_bss
operator|=
name|hdr
operator|.
name|a_bss
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * Unmap an object that is nolonger in use.  */
end_comment

begin_function
specifier|static
name|int
name|unmap_object
parameter_list|(
name|smp
parameter_list|)
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
block|{
name|struct
name|so_map
modifier|*
name|prev
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|somap_private
modifier|*
name|smpp
decl_stmt|;
comment|/* Find the object in the list and unlink it */
for|for
control|(
name|prev
operator|=
name|NULL
operator|,
name|p
operator|=
name|link_map_head
init|;
name|p
operator|!=
name|smp
condition|;
name|prev
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|som_next
control|)
continue|continue;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
name|link_map_head
operator|=
name|smp
operator|->
name|som_next
expr_stmt|;
if|if
condition|(
name|smp
operator|->
name|som_next
operator|==
name|NULL
condition|)
name|link_map_tail
operator|=
operator|&
name|link_map_head
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|->
name|som_next
operator|=
name|smp
operator|->
name|som_next
expr_stmt|;
if|if
condition|(
name|smp
operator|->
name|som_next
operator|==
name|NULL
condition|)
name|link_map_tail
operator|=
operator|&
name|prev
operator|->
name|som_next
expr_stmt|;
block|}
comment|/* Unmap the sections we have mapped */
name|smpp
operator|=
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
expr_stmt|;
if|if
condition|(
name|munmap
argument_list|(
name|smp
operator|->
name|som_addr
argument_list|,
name|smpp
operator|->
name|a_text
operator|+
name|smpp
operator|->
name|a_data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|generror
argument_list|(
literal|"munmap failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|smpp
operator|->
name|a_bss
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|munmap
argument_list|(
name|smp
operator|->
name|som_addr
operator|+
name|smpp
operator|->
name|a_text
operator|+
name|smpp
operator|->
name|a_data
argument_list|,
name|smpp
operator|->
name|a_bss
argument_list|)
operator|<
literal|0
condition|)
block|{
name|generror
argument_list|(
literal|"munmap failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|smp
operator|->
name|som_path
condition|)
name|free
argument_list|(
name|smp
operator|->
name|som_path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|smp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|check_text_reloc
parameter_list|(
name|r
parameter_list|,
name|smp
parameter_list|,
name|addr
parameter_list|)
name|struct
name|relocation_info
modifier|*
name|r
decl_stmt|;
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
block|{
name|char
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|addr
operator|>=
name|LM_ETEXT
argument_list|(
name|smp
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
condition|)
name|sym
operator|=
name|LM_STRINGS
argument_list|(
name|smp
argument_list|)
operator|+
name|LM_SYMBOL
argument_list|(
name|smp
argument_list|,
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
argument_list|)
operator|->
name|nz_strx
expr_stmt|;
else|else
name|sym
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"LD_SUPPRESS_WARNINGS"
argument_list|)
operator|==
name|NULL
operator|&&
name|getenv
argument_list|(
literal|"LD_WARN_NON_PURE_CODE"
argument_list|)
operator|!=
name|NULL
condition|)
name|warnx
argument_list|(
literal|"warning: non pure code in %s at %x (%s)"
argument_list|,
name|smp
operator|->
name|som_path
argument_list|,
name|r
operator|->
name|r_address
argument_list|,
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|smp
operator|->
name|som_write
operator|==
literal|0
operator|&&
name|mprotect
argument_list|(
name|smp
operator|->
name|som_addr
operator|+
name|LM_TXTADDR
argument_list|(
name|smp
argument_list|)
argument_list|,
name|LD_TEXTSZ
argument_list|(
name|smp
operator|->
name|som_dynamic
argument_list|)
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
operator||
name|PROT_EXEC
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|generror
argument_list|(
literal|"mprotect failed for \"%s\" : %s"
argument_list|,
name|smp
operator|->
name|som_path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|smp
operator|->
name|som_write
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|reloc_map
parameter_list|(
name|smp
parameter_list|)
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
block|{
name|struct
name|_dynamic
modifier|*
name|dp
init|=
name|smp
operator|->
name|som_dynamic
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|r
init|=
name|LM_REL
argument_list|(
name|smp
argument_list|)
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|rend
init|=
name|r
operator|+
name|LD_RELSZ
argument_list|(
name|dp
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
decl_stmt|;
name|long
name|symbolbase
init|=
operator|(
name|long
operator|)
name|LM_SYMBOL
argument_list|(
name|smp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|char
modifier|*
name|stringbase
init|=
name|LM_STRINGS
argument_list|(
name|smp
argument_list|)
decl_stmt|;
name|int
name|symsize
init|=
name|LD_VERSION_NZLIST_P
argument_list|(
name|dp
operator|->
name|d_version
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
expr|struct
name|nzlist
argument_list|)
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
decl_stmt|;
if|if
condition|(
name|LD_PLTSZ
argument_list|(
name|dp
argument_list|)
condition|)
name|md_fix_jmpslot
argument_list|(
name|LM_PLT
argument_list|(
name|smp
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|LM_PLT
argument_list|(
name|smp
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|binder_entry
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|r
operator|<
name|rend
condition|;
name|r
operator|++
control|)
block|{
name|char
modifier|*
name|sym
decl_stmt|;
name|caddr_t
name|addr
init|=
name|smp
operator|->
name|som_addr
operator|+
name|r
operator|->
name|r_address
decl_stmt|;
if|if
condition|(
name|check_text_reloc
argument_list|(
name|r
argument_list|,
name|smp
argument_list|,
name|addr
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|struct
name|so_map
modifier|*
name|src_map
init|=
name|NULL
decl_stmt|;
name|struct
name|nzlist
modifier|*
name|p
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|long
name|relocation
init|=
name|md_get_addend
argument_list|(
name|r
argument_list|,
name|addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|RELOC_LAZY_P
argument_list|(
name|r
argument_list|)
condition|)
continue|continue;
name|p
operator|=
operator|(
expr|struct
name|nzlist
operator|*
operator|)
operator|(
name|symbolbase
operator|+
name|symsize
operator|*
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|nz_type
operator|==
operator|(
name|N_SETV
operator|+
name|N_EXT
operator|)
condition|)
name|src_map
operator|=
name|smp
expr_stmt|;
name|sym
operator|=
name|stringbase
operator|+
name|p
operator|->
name|nz_strx
expr_stmt|;
name|np
operator|=
name|lookup
argument_list|(
name|sym
argument_list|,
operator|&
name|src_map
argument_list|,
literal|0
comment|/*XXX-jumpslots!*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
name|generror
argument_list|(
literal|"Undefined symbol \"%s\" in %s:%s"
argument_list|,
name|sym
argument_list|,
name|main_progname
argument_list|,
name|smp
operator|->
name|som_path
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 			 * Found symbol definition. 			 * If it's in a link map, adjust value 			 * according to the load address of that map. 			 * Otherwise it's a run-time allocated common 			 * whose value is already up-to-date. 			 */
name|relocation
operator|+=
name|np
operator|->
name|nz_value
expr_stmt|;
if|if
condition|(
name|src_map
condition|)
name|relocation
operator|+=
operator|(
name|long
operator|)
name|src_map
operator|->
name|som_addr
expr_stmt|;
if|if
condition|(
name|RELOC_PCREL_P
argument_list|(
name|r
argument_list|)
condition|)
name|relocation
operator|-=
operator|(
name|long
operator|)
name|smp
operator|->
name|som_addr
expr_stmt|;
if|if
condition|(
name|RELOC_COPY_P
argument_list|(
name|r
argument_list|)
operator|&&
name|src_map
condition|)
block|{
operator|(
name|void
operator|)
name|enter_rts
argument_list|(
name|sym
argument_list|,
operator|(
name|long
operator|)
name|addr
argument_list|,
name|N_DATA
operator|+
name|N_EXT
argument_list|,
name|src_map
operator|->
name|som_addr
operator|+
name|np
operator|->
name|nz_value
argument_list|,
name|np
operator|->
name|nz_size
argument_list|,
name|src_map
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|md_relocate
argument_list|(
name|r
argument_list|,
name|relocation
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|md_relocate
argument_list|(
name|r
argument_list|,
ifdef|#
directive|ifdef
name|SUN_COMPAT
name|md_get_rt_segment_addend
argument_list|(
argument|r
argument_list|,
argument|addr
argument_list|)
else|#
directive|else
name|md_get_addend
argument_list|(
name|r
argument_list|,
name|addr
argument_list|)
endif|#
directive|endif
operator|+
operator|(
name|long
operator|)
name|smp
operator|->
name|som_addr
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|smp
operator|->
name|som_write
condition|)
block|{
if|if
condition|(
name|mprotect
argument_list|(
name|smp
operator|->
name|som_addr
operator|+
name|LM_TXTADDR
argument_list|(
name|smp
argument_list|)
argument_list|,
name|LD_TEXTSZ
argument_list|(
name|smp
operator|->
name|som_dynamic
argument_list|)
argument_list|,
name|PROT_READ
operator||
name|PROT_EXEC
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|generror
argument_list|(
literal|"mprotect failed for \"%s\" : %s"
argument_list|,
name|smp
operator|->
name|som_path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|smp
operator|->
name|som_write
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|reloc_copy
parameter_list|(
name|smp
parameter_list|)
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
block|{
name|struct
name|rt_symbol
modifier|*
name|rtsp
decl_stmt|;
for|for
control|(
name|rtsp
operator|=
name|rt_symbol_head
init|;
name|rtsp
condition|;
name|rtsp
operator|=
name|rtsp
operator|->
name|rt_next
control|)
if|if
condition|(
operator|(
name|rtsp
operator|->
name|rt_smp
operator|==
name|NULL
operator|||
name|rtsp
operator|->
name|rt_smp
operator|==
name|smp
operator|)
operator|&&
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_type
operator|==
name|N_DATA
operator|+
name|N_EXT
condition|)
block|{
name|bcopy
argument_list|(
name|rtsp
operator|->
name|rt_srcaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_value
argument_list|,
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|init_map
parameter_list|(
name|smp
parameter_list|,
name|sym
parameter_list|,
name|dependants
parameter_list|)
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
name|char
modifier|*
name|sym
decl_stmt|;
name|int
name|dependants
decl_stmt|;
block|{
name|struct
name|so_map
modifier|*
name|src_map
init|=
name|smp
decl_stmt|;
name|struct
name|nzlist
modifier|*
name|np
decl_stmt|;
if|if
condition|(
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_flags
operator|&
name|RTLD_INIT
condition|)
return|return;
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_flags
operator||=
name|RTLD_INIT
expr_stmt|;
if|if
condition|(
name|dependants
condition|)
block|{
name|struct
name|sod
modifier|*
name|sodp
decl_stmt|;
name|struct
name|so_map
modifier|*
name|smp2
decl_stmt|;
name|long
name|next
decl_stmt|;
name|next
operator|=
name|LD_NEED
argument_list|(
name|smp
operator|->
name|som_dynamic
argument_list|)
expr_stmt|;
while|while
condition|(
name|next
condition|)
block|{
name|sodp
operator|=
operator|(
expr|struct
name|sod
operator|*
operator|)
operator|(
name|LM_LDBASE
argument_list|(
name|smp
argument_list|)
operator|+
name|next
operator|)
expr_stmt|;
name|smp2
operator|=
name|find_object
argument_list|(
name|sodp
argument_list|,
name|smp
argument_list|)
expr_stmt|;
if|if
condition|(
name|smp2
condition|)
name|init_map
argument_list|(
name|smp2
argument_list|,
name|sym
argument_list|,
name|dependants
argument_list|)
expr_stmt|;
name|next
operator|=
name|sodp
operator|->
name|sod_next
expr_stmt|;
block|}
block|}
name|np
operator|=
name|lookup
argument_list|(
name|sym
argument_list|,
operator|&
name|src_map
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
condition|)
operator|(
operator|*
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
operator|(
name|src_map
operator|->
name|som_addr
operator|+
name|np
operator|->
name|nz_value
operator|)
operator|)
operator|(
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|call_map
parameter_list|(
name|smp
parameter_list|,
name|sym
parameter_list|)
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
name|char
modifier|*
name|sym
decl_stmt|;
block|{
name|struct
name|so_map
modifier|*
name|src_map
init|=
name|smp
decl_stmt|;
name|struct
name|nzlist
modifier|*
name|np
decl_stmt|;
name|np
operator|=
name|lookup
argument_list|(
name|sym
argument_list|,
operator|&
name|src_map
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
condition|)
operator|(
operator|*
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
operator|(
name|src_map
operator|->
name|som_addr
operator|+
name|np
operator|->
name|nz_value
operator|)
operator|)
operator|(
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Load an object with all its dependant objects, recording the type of the  * object and optionally calling its init function.  */
end_comment

begin_function
specifier|static
name|struct
name|so_map
modifier|*
name|load_object
parameter_list|(
name|sodp
parameter_list|,
name|parent
parameter_list|,
name|type
parameter_list|,
name|init
parameter_list|)
name|struct
name|sod
modifier|*
name|sodp
decl_stmt|;
name|struct
name|so_map
modifier|*
name|parent
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|init
decl_stmt|;
block|{
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
comment|/*      * Find or map the object.      */
name|smp
operator|=
name|map_object
argument_list|(
name|sodp
argument_list|,
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|smp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/*      * The first time the object is mapped, load it's dependant objects and      * relocate it.      */
if|if
condition|(
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_refcount
operator|++
operator|==
literal|0
condition|)
block|{
name|struct
name|sod
modifier|*
name|sodp
decl_stmt|;
name|struct
name|so_map
modifier|*
name|smp2
decl_stmt|;
name|long
name|next
decl_stmt|;
name|next
operator|=
name|LD_NEED
argument_list|(
name|smp
operator|->
name|som_dynamic
argument_list|)
expr_stmt|;
comment|/* 	 * Load dependant objects but defer initialisation until later. 	 * When all the dependants (and sub dependants, etc.) have been 	 * loaded and relocated, it is safe to call the init functions, 	 * using a recursive call to init_map.  This ensures that if init 	 * code in the dependants calls code in the parent, it will work 	 * as expected. 	 */
while|while
condition|(
name|next
condition|)
block|{
name|sodp
operator|=
operator|(
expr|struct
name|sod
operator|*
operator|)
operator|(
name|LM_LDBASE
argument_list|(
name|smp
argument_list|)
operator|+
name|next
operator|)
expr_stmt|;
comment|/* 	     * Dependant objects (of both dlopen and main) don't get a 	     * specific type. 	     */
if|if
condition|(
operator|(
name|smp2
operator|=
name|load_object
argument_list|(
name|sodp
argument_list|,
name|smp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|xprintf
argument_list|(
literal|"ld.so: map_object failed on cascaded %s %s (%d.%d): %s\n"
argument_list|,
name|smp
operator|->
name|sod_library
condition|?
literal|"library"
else|:
literal|"file"
argument_list|,
name|smp
operator|->
name|sod_name
argument_list|,
name|smp
operator|->
name|sod_major
argument_list|,
name|smp
operator|->
name|sod_minor
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|unload_object
argument_list|(
name|smp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|next
operator|=
name|sodp
operator|->
name|sod_next
expr_stmt|;
block|}
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_flags
operator||=
name|type
expr_stmt|;
if|if
condition|(
name|reloc_map
argument_list|(
name|smp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|unload_object
argument_list|(
name|smp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|reloc_copy
argument_list|(
name|smp
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
block|{
name|init_map
argument_list|(
name|smp
argument_list|,
literal|".init"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|smp
return|;
block|}
end_function

begin_comment
comment|/*  * Unload an object, recursively unloading dependant objects.  */
end_comment

begin_function
specifier|static
name|int
name|unload_object
parameter_list|(
name|smp
parameter_list|)
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
block|{
name|struct
name|so_map
modifier|*
name|smp2
decl_stmt|;
name|struct
name|sod
modifier|*
name|sodp
decl_stmt|;
name|long
name|next
decl_stmt|;
if|if
condition|(
operator|--
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_refcount
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/*      * Call destructors for the object (before unloading its dependants      * since destructors may use them.  Only call destructors if constructors      * have been called.      */
if|if
condition|(
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_flags
operator|&
name|RTLD_INIT
condition|)
name|call_map
argument_list|(
name|smp
argument_list|,
literal|".fini"
argument_list|)
expr_stmt|;
comment|/*      * Unmap any dependant objects first.      */
name|next
operator|=
name|LD_NEED
argument_list|(
name|smp
operator|->
name|som_dynamic
argument_list|)
expr_stmt|;
while|while
condition|(
name|next
condition|)
block|{
name|sodp
operator|=
operator|(
expr|struct
name|sod
operator|*
operator|)
operator|(
name|LM_LDBASE
argument_list|(
name|smp
argument_list|)
operator|+
name|next
operator|)
expr_stmt|;
name|smp2
operator|=
name|find_object
argument_list|(
name|sodp
argument_list|,
name|smp
argument_list|)
expr_stmt|;
if|if
condition|(
name|smp2
condition|)
name|unload_object
argument_list|(
name|smp2
argument_list|)
expr_stmt|;
name|next
operator|=
name|sodp
operator|->
name|sod_next
expr_stmt|;
block|}
comment|/*      * Remove from address space.      */
if|if
condition|(
name|unmap_object
argument_list|(
name|smp
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Run-time common symbol table.  */
end_comment

begin_define
define|#
directive|define
name|RTC_TABSIZE
value|57
end_define

begin_decl_stmt
specifier|static
name|struct
name|rt_symbol
modifier|*
name|rt_symtab
index|[
name|RTC_TABSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Compute hash value for run-time symbol table  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|hash_string
parameter_list|(
name|key
parameter_list|)
name|char
modifier|*
name|key
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
name|cp
operator|=
name|key
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|k
operator|=
operator|(
operator|(
operator|(
name|k
operator|<<
literal|1
operator|)
operator|+
operator|(
name|k
operator|>>
literal|14
operator|)
operator|)
operator|^
operator|(
operator|*
name|cp
operator|++
operator|)
operator|)
operator|&
literal|0x3fff
expr_stmt|;
return|return
name|k
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup KEY in the run-time common symbol table.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|rt_symbol
modifier|*
name|lookup_rts
parameter_list|(
name|key
parameter_list|)
name|char
modifier|*
name|key
decl_stmt|;
block|{
specifier|register
name|int
name|hashval
decl_stmt|;
specifier|register
name|struct
name|rt_symbol
modifier|*
name|rtsp
decl_stmt|;
comment|/* Determine which bucket.  */
name|hashval
operator|=
name|hash_string
argument_list|(
name|key
argument_list|)
operator|%
name|RTC_TABSIZE
expr_stmt|;
comment|/* Search the bucket.  */
for|for
control|(
name|rtsp
operator|=
name|rt_symtab
index|[
name|hashval
index|]
init|;
name|rtsp
condition|;
name|rtsp
operator|=
name|rtsp
operator|->
name|rt_link
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|rtsp
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|rt_symbol
modifier|*
name|enter_rts
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|,
name|type
parameter_list|,
name|srcaddr
parameter_list|,
name|size
parameter_list|,
name|smp
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|long
name|value
decl_stmt|;
name|int
name|type
decl_stmt|;
name|caddr_t
name|srcaddr
decl_stmt|;
name|long
name|size
decl_stmt|;
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
block|{
specifier|register
name|int
name|hashval
decl_stmt|;
specifier|register
name|struct
name|rt_symbol
modifier|*
name|rtsp
decl_stmt|,
modifier|*
modifier|*
name|rpp
decl_stmt|;
comment|/* Determine which bucket */
name|hashval
operator|=
name|hash_string
argument_list|(
name|name
argument_list|)
operator|%
name|RTC_TABSIZE
expr_stmt|;
comment|/* Find end of bucket */
for|for
control|(
name|rpp
operator|=
operator|&
name|rt_symtab
index|[
name|hashval
index|]
init|;
operator|*
name|rpp
condition|;
name|rpp
operator|=
operator|&
operator|(
operator|*
name|rpp
operator|)
operator|->
name|rt_link
control|)
continue|continue;
comment|/* Allocate new common symbol */
name|rtsp
operator|=
operator|(
expr|struct
name|rt_symbol
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rt_symbol
argument_list|)
argument_list|)
expr_stmt|;
name|rtsp
operator|->
name|rt_sp
operator|=
operator|(
expr|struct
name|nzlist
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nzlist
argument_list|)
argument_list|)
expr_stmt|;
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_value
operator|=
name|value
expr_stmt|;
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_type
operator|=
name|type
expr_stmt|;
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_size
operator|=
name|size
expr_stmt|;
name|rtsp
operator|->
name|rt_srcaddr
operator|=
name|srcaddr
expr_stmt|;
name|rtsp
operator|->
name|rt_smp
operator|=
name|smp
expr_stmt|;
name|rtsp
operator|->
name|rt_link
operator|=
name|NULL
expr_stmt|;
comment|/* Link onto linear list as well */
name|rtsp
operator|->
name|rt_next
operator|=
name|rt_symbol_head
expr_stmt|;
name|rt_symbol_head
operator|=
name|rtsp
expr_stmt|;
operator|*
name|rpp
operator|=
name|rtsp
expr_stmt|;
return|return
name|rtsp
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup NAME in the link maps. The link map producing a definition  * is returned in SRC_MAP. If SRC_MAP is not NULL on entry the search is  * confined to that map. If STRONG is set, the symbol returned must  * have a proper type (used by binder()).  */
end_comment

begin_function
specifier|static
name|struct
name|nzlist
modifier|*
name|lookup
parameter_list|(
name|name
parameter_list|,
name|src_map
parameter_list|,
name|strong
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|so_map
modifier|*
modifier|*
name|src_map
decl_stmt|;
comment|/* IN/OUT */
name|int
name|strong
decl_stmt|;
block|{
name|long
name|common_size
init|=
literal|0
decl_stmt|;
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
name|struct
name|rt_symbol
modifier|*
name|rtsp
decl_stmt|;
if|if
condition|(
operator|(
name|rtsp
operator|=
name|lookup_rts
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|rtsp
operator|->
name|rt_sp
return|;
comment|/* 	 * Search all maps for a definition of NAME 	 */
for|for
control|(
name|smp
operator|=
name|link_map_head
init|;
name|smp
condition|;
name|smp
operator|=
name|smp
operator|->
name|som_next
control|)
block|{
name|int
name|buckets
decl_stmt|;
name|long
name|hashval
decl_stmt|;
name|struct
name|rrs_hash
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|nzlist
modifier|*
name|np
decl_stmt|;
comment|/* Some local caching */
name|long
name|symbolbase
decl_stmt|;
name|struct
name|rrs_hash
modifier|*
name|hashbase
decl_stmt|;
name|char
modifier|*
name|stringbase
decl_stmt|;
name|int
name|symsize
decl_stmt|;
if|if
condition|(
operator|*
name|src_map
operator|&&
name|smp
operator|!=
operator|*
name|src_map
condition|)
continue|continue;
if|if
condition|(
operator|(
name|buckets
operator|=
name|LD_BUCKETS
argument_list|(
name|smp
operator|->
name|som_dynamic
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_flags
operator|&
name|RTLD_RTLD
condition|)
continue|continue;
name|restart
label|:
comment|/* 		 * Compute bucket in which the symbol might be found. 		 */
for|for
control|(
name|hashval
operator|=
literal|0
operator|,
name|cp
operator|=
name|name
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
name|hashval
operator|=
operator|(
name|hashval
operator|<<
literal|1
operator|)
operator|+
operator|*
name|cp
expr_stmt|;
name|hashval
operator|=
operator|(
name|hashval
operator|&
literal|0x7fffffff
operator|)
operator|%
name|buckets
expr_stmt|;
name|hashbase
operator|=
name|LM_HASH
argument_list|(
name|smp
argument_list|)
expr_stmt|;
name|hp
operator|=
name|hashbase
operator|+
name|hashval
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|rh_symbolnum
operator|==
operator|-
literal|1
condition|)
comment|/* Nothing in this bucket */
continue|continue;
name|symbolbase
operator|=
operator|(
name|long
operator|)
name|LM_SYMBOL
argument_list|(
name|smp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stringbase
operator|=
name|LM_STRINGS
argument_list|(
name|smp
argument_list|)
expr_stmt|;
name|symsize
operator|=
name|LD_VERSION_NZLIST_P
argument_list|(
name|smp
operator|->
name|som_dynamic
operator|->
name|d_version
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
expr|struct
name|nzlist
argument_list|)
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
expr_stmt|;
while|while
condition|(
name|hp
condition|)
block|{
name|np
operator|=
operator|(
expr|struct
name|nzlist
operator|*
operator|)
operator|(
name|symbolbase
operator|+
name|hp
operator|->
name|rh_symbolnum
operator|*
name|symsize
operator|)
expr_stmt|;
name|cp
operator|=
name|stringbase
operator|+
name|np
operator|->
name|nz_strx
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|hp
operator|->
name|rh_next
operator|==
literal|0
condition|)
name|hp
operator|=
name|NULL
expr_stmt|;
else|else
name|hp
operator|=
name|hashbase
operator|+
name|hp
operator|->
name|rh_next
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
comment|/* Nothing in this bucket */
continue|continue;
comment|/* 		 * We have a symbol with the name we're looking for. 		 */
if|if
condition|(
name|np
operator|->
name|nz_type
operator|==
name|N_INDR
operator|+
name|N_EXT
condition|)
block|{
comment|/* 			 * Next symbol gives the aliased name. Restart 			 * search with new name and confine to this map. 			 */
name|name
operator|=
name|stringbase
operator|+
operator|(
operator|++
name|np
operator|)
operator|->
name|nz_strx
expr_stmt|;
operator|*
name|src_map
operator|=
name|smp
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
if|if
condition|(
name|np
operator|->
name|nz_value
operator|==
literal|0
condition|)
comment|/* It's not a definition */
continue|continue;
if|if
condition|(
name|np
operator|->
name|nz_type
operator|==
name|N_UNDF
operator|+
name|N_EXT
operator|&&
name|np
operator|->
name|nz_value
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|nz_other
operator|==
name|AUX_FUNC
condition|)
block|{
comment|/* It's a weak function definition */
if|if
condition|(
name|strong
condition|)
continue|continue;
block|}
else|else
block|{
comment|/* It's a common, note value and continue search */
if|if
condition|(
name|common_size
operator|<
name|np
operator|->
name|nz_value
condition|)
name|common_size
operator|=
name|np
operator|->
name|nz_value
expr_stmt|;
continue|continue;
block|}
block|}
operator|*
name|src_map
operator|=
name|smp
expr_stmt|;
return|return
name|np
return|;
block|}
if|if
condition|(
name|common_size
operator|==
literal|0
condition|)
comment|/* Not found */
return|return
name|NULL
return|;
comment|/* 	 * It's a common, enter into run-time common symbol table. 	 */
name|rtsp
operator|=
name|enter_rts
argument_list|(
name|name
argument_list|,
operator|(
name|long
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
name|common_size
argument_list|)
argument_list|,
name|N_UNDF
operator|+
name|N_EXT
argument_list|,
literal|0
argument_list|,
name|common_size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
name|xprintf
argument_list|(
literal|"Allocating common: %s size %d at %#x\n"
argument_list|,
name|name
argument_list|,
name|common_size
argument_list|,
name|rtsp
operator|->
name|rt_sp
operator|->
name|nz_value
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|rtsp
operator|->
name|rt_sp
return|;
block|}
end_function

begin_comment
comment|/*  * This routine is called from the jumptable to resolve  * procedure calls to shared objects.  */
end_comment

begin_function
name|long
name|binder
parameter_list|(
name|jsp
parameter_list|)
name|jmpslot_t
modifier|*
name|jsp
decl_stmt|;
block|{
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|,
modifier|*
name|src_map
init|=
name|NULL
decl_stmt|;
name|long
name|addr
decl_stmt|;
name|char
modifier|*
name|sym
decl_stmt|;
name|struct
name|nzlist
modifier|*
name|np
decl_stmt|;
name|int
name|index
decl_stmt|;
comment|/* 	 * Find the PLT map that contains JSP. 	 */
for|for
control|(
name|smp
operator|=
name|link_map_head
init|;
name|smp
condition|;
name|smp
operator|=
name|smp
operator|->
name|som_next
control|)
block|{
if|if
condition|(
name|LM_PLT
argument_list|(
name|smp
argument_list|)
operator|<
name|jsp
operator|&&
name|jsp
operator|<
name|LM_PLT
argument_list|(
name|smp
argument_list|)
operator|+
name|LD_PLTSZ
argument_list|(
name|smp
operator|->
name|som_dynamic
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|jsp
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|smp
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Call to binder from unknown location: %#x\n"
argument_list|,
name|jsp
argument_list|)
expr_stmt|;
name|index
operator|=
name|jsp
operator|->
name|reloc_index
operator|&
name|JMPSLOT_RELOC_MASK
expr_stmt|;
comment|/* Get the local symbol this jmpslot refers to */
name|sym
operator|=
name|LM_STRINGS
argument_list|(
name|smp
argument_list|)
operator|+
name|LM_SYMBOL
argument_list|(
name|smp
argument_list|,
name|RELOC_SYMBOL
argument_list|(
operator|&
name|LM_REL
argument_list|(
name|smp
argument_list|)
index|[
name|index
index|]
argument_list|)
argument_list|)
operator|->
name|nz_strx
expr_stmt|;
name|np
operator|=
name|lookup
argument_list|(
name|sym
argument_list|,
operator|&
name|src_map
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Undefined symbol \"%s\" called from %s:%s at %#x"
argument_list|,
name|sym
argument_list|,
name|main_progname
argument_list|,
name|smp
operator|->
name|som_path
argument_list|,
name|jsp
argument_list|)
expr_stmt|;
comment|/* Fixup jmpslot so future calls transfer directly to target */
name|addr
operator|=
name|np
operator|->
name|nz_value
expr_stmt|;
if|if
condition|(
name|src_map
condition|)
name|addr
operator|+=
operator|(
name|long
operator|)
name|src_map
operator|->
name|som_addr
expr_stmt|;
name|md_fix_jmpslot
argument_list|(
name|jsp
argument_list|,
operator|(
name|long
operator|)
name|jsp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
name|xprintf
argument_list|(
literal|" BINDER: %s located at = %#x in %s\n"
argument_list|,
name|sym
argument_list|,
name|addr
argument_list|,
name|src_map
operator|->
name|som_path
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|addr
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|hfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|hsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hints_header
modifier|*
name|hheader
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hints_bucket
modifier|*
name|hbuckets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|hstrtab
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HINTS_VALID
value|(hheader != NULL&& hheader != (struct hints_header *)-1)
end_define

begin_decl_stmt
specifier|static
name|void
name|maphints
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
block|{
name|caddr_t
name|addr
decl_stmt|;
if|if
condition|(
operator|(
name|hfd
operator|=
name|open
argument_list|(
name|_PATH_LD_HINTS
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|hheader
operator|=
operator|(
expr|struct
name|hints_header
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
return|return;
block|}
name|hsize
operator|=
name|PAGSIZ
expr_stmt|;
name|addr
operator|=
name|mmap
argument_list|(
literal|0
argument_list|,
name|hsize
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_COPY
argument_list|,
name|hfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
operator|(
name|caddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|hfd
argument_list|)
expr_stmt|;
name|hheader
operator|=
operator|(
expr|struct
name|hints_header
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
return|return;
block|}
name|hheader
operator|=
operator|(
expr|struct
name|hints_header
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|HH_BADMAG
argument_list|(
operator|*
name|hheader
argument_list|)
condition|)
block|{
name|munmap
argument_list|(
name|addr
argument_list|,
name|hsize
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|hfd
argument_list|)
expr_stmt|;
name|hheader
operator|=
operator|(
expr|struct
name|hints_header
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hheader
operator|->
name|hh_version
operator|!=
name|LD_HINTS_VERSION_1
condition|)
block|{
name|munmap
argument_list|(
name|addr
argument_list|,
name|hsize
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|hfd
argument_list|)
expr_stmt|;
name|hheader
operator|=
operator|(
expr|struct
name|hints_header
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hheader
operator|->
name|hh_ehints
operator|>
name|hsize
condition|)
block|{
if|if
condition|(
name|mmap
argument_list|(
name|addr
operator|+
name|hsize
argument_list|,
name|hheader
operator|->
name|hh_ehints
operator|-
name|hsize
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_COPY
operator||
name|MAP_FIXED
argument_list|,
name|hfd
argument_list|,
name|hsize
argument_list|)
operator|!=
call|(
name|caddr_t
call|)
argument_list|(
name|addr
operator|+
name|hsize
argument_list|)
condition|)
block|{
name|munmap
argument_list|(
operator|(
name|caddr_t
operator|)
name|hheader
argument_list|,
name|hsize
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|hfd
argument_list|)
expr_stmt|;
name|hheader
operator|=
operator|(
expr|struct
name|hints_header
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
return|return;
block|}
block|}
name|hbuckets
operator|=
operator|(
expr|struct
name|hints_bucket
operator|*
operator|)
operator|(
name|addr
operator|+
name|hheader
operator|->
name|hh_hashtab
operator|)
expr_stmt|;
name|hstrtab
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|addr
operator|+
name|hheader
operator|->
name|hh_strtab
operator|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|unmaphints
parameter_list|()
block|{
if|if
condition|(
name|HINTS_VALID
condition|)
block|{
name|munmap
argument_list|(
operator|(
name|caddr_t
operator|)
name|hheader
argument_list|,
name|hsize
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|hfd
argument_list|)
expr_stmt|;
name|hheader
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|hinthash
parameter_list|(
name|cp
parameter_list|,
name|vmajor
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|vmajor
decl_stmt|;
block|{
name|int
name|k
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|k
operator|=
operator|(
operator|(
operator|(
name|k
operator|<<
literal|1
operator|)
operator|+
operator|(
name|k
operator|>>
literal|14
operator|)
operator|)
operator|^
operator|(
operator|*
name|cp
operator|++
operator|)
operator|)
operator|&
literal|0x3fff
expr_stmt|;
name|k
operator|=
operator|(
operator|(
operator|(
name|k
operator|<<
literal|1
operator|)
operator|+
operator|(
name|k
operator|>>
literal|14
operator|)
operator|)
operator|^
operator|(
name|vmajor
operator|*
literal|257
operator|)
operator|)
operator|&
literal|0x3fff
expr_stmt|;
return|return
name|k
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|major
end_undef

begin_undef
undef|#
directive|undef
name|minor
end_undef

begin_function
specifier|static
name|char
modifier|*
name|findhint
parameter_list|(
name|name
parameter_list|,
name|major
parameter_list|,
name|minor
parameter_list|,
name|preferred_path
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|major
decl_stmt|,
name|minor
decl_stmt|;
name|char
modifier|*
name|preferred_path
decl_stmt|;
block|{
name|struct
name|hints_bucket
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|hbuckets
operator|+
operator|(
name|hinthash
argument_list|(
name|name
argument_list|,
name|major
argument_list|)
operator|%
name|hheader
operator|->
name|hh_nbucket
operator|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Sanity check */
if|if
condition|(
name|bp
operator|->
name|hi_namex
operator|>=
name|hheader
operator|->
name|hh_strtab_sz
condition|)
block|{
name|warnx
argument_list|(
literal|"Bad name index: %#x\n"
argument_list|,
name|bp
operator|->
name|hi_namex
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bp
operator|->
name|hi_pathx
operator|>=
name|hheader
operator|->
name|hh_strtab_sz
condition|)
block|{
name|warnx
argument_list|(
literal|"Bad path index: %#x\n"
argument_list|,
name|bp
operator|->
name|hi_pathx
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|hstrtab
operator|+
name|bp
operator|->
name|hi_namex
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* It's `name', check version numbers */
if|if
condition|(
name|bp
operator|->
name|hi_major
operator|==
name|major
operator|&&
operator|(
name|bp
operator|->
name|hi_ndewey
operator|<
literal|2
operator|||
name|bp
operator|->
name|hi_minor
operator|>=
name|minor
operator|)
condition|)
block|{
if|if
condition|(
name|preferred_path
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|preferred_path
argument_list|,
name|hstrtab
operator|+
name|bp
operator|->
name|hi_pathx
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|hstrtab
operator|+
name|bp
operator|->
name|hi_pathx
return|;
block|}
block|}
block|}
if|if
condition|(
name|bp
operator|->
name|hi_next
operator|==
operator|-
literal|1
condition|)
break|break;
comment|/* Move on to next in bucket */
name|bp
operator|=
operator|&
name|hbuckets
index|[
name|bp
operator|->
name|hi_next
index|]
expr_stmt|;
block|}
comment|/* No hints available for name */
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|rtfindlib
parameter_list|(
name|name
parameter_list|,
name|major
parameter_list|,
name|minor
parameter_list|,
name|usehints
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|major
decl_stmt|,
name|minor
decl_stmt|;
name|int
modifier|*
name|usehints
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ld_path
init|=
name|getenv
argument_list|(
literal|"LD_LIBRARY_PATH"
argument_list|)
decl_stmt|;
name|int
name|realminor
decl_stmt|;
if|if
condition|(
name|hheader
operator|==
name|NULL
condition|)
name|maphints
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|HINTS_VALID
operator|||
operator|!
operator|(
operator|*
name|usehints
operator|)
condition|)
goto|goto
name|lose
goto|;
if|if
condition|(
name|ld_path
operator|!=
name|NULL
condition|)
block|{
comment|/* Prefer paths from LD_LIBRARY_PATH */
while|while
condition|(
operator|(
name|cp
operator|=
name|strsep
argument_list|(
operator|&
name|ld_path
argument_list|,
literal|":"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|=
name|findhint
argument_list|(
name|name
argument_list|,
name|major
argument_list|,
name|minor
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld_path
condition|)
operator|*
operator|(
name|ld_path
operator|-
literal|1
operator|)
operator|=
literal|':'
expr_stmt|;
if|if
condition|(
name|cp
condition|)
return|return
name|cp
return|;
block|}
comment|/* Not found in hints, try directory search */
name|realminor
operator|=
operator|-
literal|1
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|findshlib
argument_list|(
name|name
argument_list|,
operator|&
name|major
argument_list|,
operator|&
name|realminor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|&&
name|realminor
operator|>=
name|minor
condition|)
return|return
name|cp
return|;
block|}
comment|/* No LD_LIBRARY_PATH or lib not found in there; check default */
name|cp
operator|=
name|findhint
argument_list|(
name|name
argument_list|,
name|major
argument_list|,
name|minor
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
return|return
name|cp
return|;
name|lose
label|:
comment|/* No hints available for name */
operator|*
name|usehints
operator|=
literal|0
expr_stmt|;
name|realminor
operator|=
operator|-
literal|1
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|findshlib
argument_list|(
name|name
argument_list|,
operator|&
name|major
argument_list|,
operator|&
name|realminor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
if|if
condition|(
name|realminor
operator|<
name|minor
operator|&&
name|getenv
argument_list|(
literal|"LD_SUPPRESS_WARNINGS"
argument_list|)
operator|==
name|NULL
condition|)
name|warnx
argument_list|(
literal|"warning: lib%s.so.%d.%d: "
literal|"minor version< %d expected, using it anyway"
argument_list|,
name|name
argument_list|,
name|major
argument_list|,
name|realminor
argument_list|,
name|minor
argument_list|)
expr_stmt|;
return|return
name|cp
return|;
block|}
name|generror
argument_list|(
literal|"Can't find shared library \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|somap_private
name|dlmap_private
init|=
block|{
literal|0
block|,
operator|(
expr|struct
name|so_map
operator|*
operator|)
literal|0
block|,
literal|0
block|,
ifdef|#
directive|ifdef
name|SUN_COMPAT
literal|0
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|so_map
name|dlmap
init|=
block|{
operator|(
name|caddr_t
operator|)
literal|0
block|,
literal|"internal"
block|,
operator|(
expr|struct
name|so_map
operator|*
operator|)
literal|0
block|,
operator|(
expr|struct
name|sod
operator|*
operator|)
literal|0
block|,
operator|(
name|caddr_t
operator|)
literal|0
block|,
operator|(
name|u_int
operator|)
literal|0
block|,
operator|(
expr|struct
name|_dynamic
operator|*
operator|)
literal|0
block|,
operator|(
name|caddr_t
operator|)
operator|&
name|dlmap_private
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Buffer for error messages and a pointer that is set to point to the buffer  * when a error occurs.  It acts as a last error flag, being set to NULL  * after an error is returned.  */
end_comment

begin_define
define|#
directive|define
name|DLERROR_BUF_SIZE
value|512
end_define

begin_decl_stmt
specifier|static
name|char
name|dlerror_buf
index|[
name|DLERROR_BUF_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dlerror_msg
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
modifier|*
name|__dlopen
parameter_list|(
name|name
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|struct
name|sod
modifier|*
name|sodp
decl_stmt|;
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
comment|/* 	 * A NULL argument returns the current set of mapped objects. 	 */
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|LM_PRIVATE
argument_list|(
name|link_map_head
argument_list|)
operator|->
name|spd_refcount
operator|++
expr_stmt|;
return|return
name|link_map_head
return|;
block|}
if|if
condition|(
operator|(
name|sodp
operator|=
operator|(
expr|struct
name|sod
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sod
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|generror
argument_list|(
literal|"malloc failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sodp
operator|->
name|sod_name
operator|=
operator|(
name|long
operator|)
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|sodp
operator|->
name|sod_library
operator|=
literal|0
expr_stmt|;
name|sodp
operator|->
name|sod_major
operator|=
name|sodp
operator|->
name|sod_minor
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|smp
operator|=
name|load_object
argument_list|(
name|sodp
argument_list|,
operator|&
name|dlmap
argument_list|,
name|RTLD_DL
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|xprintf
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|name
argument_list|,
name|dlerror_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
comment|/* 	 * If this was newly loaded, call the _init() function in the  	 * object as per manpage. 	 */
if|if
condition|(
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_refcount
operator|==
literal|1
condition|)
name|call_map
argument_list|(
name|smp
argument_list|,
literal|"__init"
argument_list|)
expr_stmt|;
return|return
name|smp
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__dlclose
parameter_list|(
name|fd
parameter_list|)
name|void
modifier|*
name|fd
decl_stmt|;
block|{
name|struct
name|so_map
modifier|*
name|smp
init|=
operator|(
expr|struct
name|so_map
operator|*
operator|)
name|fd
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|xprintf
argument_list|(
literal|"dlclose(%s): refcount = %d\n"
argument_list|,
name|smp
operator|->
name|som_path
argument_list|,
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_refcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|smp
operator|==
name|NULL
condition|)
block|{
name|generror
argument_list|(
literal|"NULL argument to dlclose"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_refcount
operator|>
literal|1
condition|)
block|{
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_refcount
operator|--
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Call the function _fini() in the object as per manpage. 	 */
name|call_map
argument_list|(
name|smp
argument_list|,
literal|"__fini"
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|smp
operator|->
name|som_sod
operator|->
name|sod_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|smp
operator|->
name|som_sod
argument_list|)
expr_stmt|;
if|if
condition|(
name|unload_object
argument_list|(
name|smp
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|__dlsym
parameter_list|(
name|fd
parameter_list|,
name|sym
parameter_list|)
name|void
modifier|*
name|fd
decl_stmt|;
name|char
modifier|*
name|sym
decl_stmt|;
block|{
name|struct
name|so_map
modifier|*
name|smp
init|=
operator|(
expr|struct
name|so_map
operator|*
operator|)
name|fd
decl_stmt|,
modifier|*
name|src_map
init|=
name|NULL
decl_stmt|;
name|struct
name|nzlist
modifier|*
name|np
decl_stmt|;
name|long
name|addr
decl_stmt|;
comment|/* 	 * Restrict search to passed map if dlopen()ed. 	 */
if|if
condition|(
name|smp
operator|&&
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_flags
operator|&
name|RTLD_DL
condition|)
name|src_map
operator|=
name|smp
expr_stmt|;
name|np
operator|=
name|lookup
argument_list|(
name|sym
argument_list|,
operator|&
name|src_map
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
name|generror
argument_list|(
literal|"Symbol \"%s\" not found"
argument_list|,
name|sym
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Fixup jmpslot so future calls transfer directly to target */
name|addr
operator|=
name|np
operator|->
name|nz_value
expr_stmt|;
if|if
condition|(
name|src_map
condition|)
name|addr
operator|+=
operator|(
name|long
operator|)
name|src_map
operator|->
name|som_addr
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
name|addr
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|__dlerror
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
block|{
name|char
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|dlerror_msg
expr_stmt|;
name|dlerror_msg
operator|=
name|NULL
expr_stmt|;
comment|/* Next call will return NULL */
return|return
name|err
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|__dlexit
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
block|{
name|struct
name|so_map
modifier|*
name|smp
decl_stmt|;
for|for
control|(
name|smp
operator|=
name|link_map_head
init|;
name|smp
condition|;
name|smp
operator|=
name|smp
operator|->
name|som_next
control|)
block|{
if|if
condition|(
name|LM_PRIVATE
argument_list|(
name|smp
argument_list|)
operator|->
name|spd_flags
operator|&
operator|(
name|RTLD_RTLD
operator||
name|RTLD_MAIN
operator|)
condition|)
continue|continue;
name|call_map
argument_list|(
name|smp
argument_list|,
literal|".fini"
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/*  * Generate an error message that can be later be retrieved via dlerror.  */
end_comment

begin_function
specifier|static
name|void
if|#
directive|if
name|__STDC__
name|generror
parameter_list|(
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|generror
parameter_list|(
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
endif|#
directive|endif
block|{
name|va_list
name|ap
decl_stmt|;
if|#
directive|if
name|__STDC__
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vsnprintf
argument_list|(
name|dlerror_buf
argument_list|,
name|DLERROR_BUF_SIZE
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|dlerror_msg
operator|=
name|dlerror_buf
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
if|#
directive|if
name|__STDC__
name|xprintf
parameter_list|(
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|xprintf
parameter_list|(
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
endif|#
directive|endif
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
if|#
directive|if
name|__STDC__
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vsprintf
argument_list|(
name|buf
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

