begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993 Paul Kranenburg  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Paul Kranenburg.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<ar.h>
end_include

begin_include
include|#
directive|include
file|<ranlib.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"ld.h"
end_include

begin_decl_stmt
specifier|static
name|struct
name|_dynamic
name|rrs_dyn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* defined in link.h */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|so_debug
name|rrs_so_debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* defined in link.h */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|section_dispatch_table
name|rrs_sdt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* defined in link.h */
end_comment

begin_decl_stmt
specifier|static
name|got_t
modifier|*
name|rrs_got
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|jmpslot_t
modifier|*
name|rrs_plt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* defined in md.h */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|relocation_info
modifier|*
name|rrs_reloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|nzlist
modifier|*
name|rrs_symbols
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RRS symbol table */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rrs_strtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RRS strings */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|rrs_hash
modifier|*
name|rrs_hashtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RT hash table */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|shobj
modifier|*
name|rrs_shobjs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reserved_rrs_relocs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|claimed_rrs_relocs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|discarded_rrs_relocs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|number_of_gotslots
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|number_of_jmpslots
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|number_of_rrs_hash_entries
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|number_of_rrs_symbols
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rrs_strtab_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rrs_symbol_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_jmpslot_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_got_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|got_origin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_reloc_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_hash_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|number_of_shobjs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convert a GOT offset into a table entry */
end_comment

begin_define
define|#
directive|define
name|GOTP
parameter_list|(
name|off
parameter_list|)
value|((got_t *)((long)rrs_got + got_origin + (off)))
end_define

begin_struct
struct|struct
name|shobj
block|{
name|struct
name|shobj
modifier|*
name|next
decl_stmt|;
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* RRS text segment: 		+-------------------+<-- sdt_rel (rrs_text_start) 		|                   | 		|    relocation     | 		|                   | 		+-------------------+<--<sdt>.sdt_hash 		|                   | 		|    hash buckets   | 		|                   | 		+-------------------+<--<sdt>.sdt_nzlist 		|                   | 		|     symbols       | 		|                   | 		+-------------------+<--<sdt>.sdt_strings 		|                   | 		|     strings       | 		|                   | 		+-------------------+<--<sdt>.sdt_sods 		|                   | 		|     shobjs        | 		|                   | 		+-------------------+ 		|                   | 		|  shobjs strings   |<--<shobj>.sod_name 		|                   | 		+-------------------+   RRS data segment:  		+-------------------+<-- __DYNAMIC (rrs_data_start) 		|                   | 		|     _dymamic      | 		|                   | 		+-------------------+<-- __DYNAMIC.d_debug 		|                   | 		|    so_debug       | 		|                   | 		+-------------------+<-- __DYNAMIC.d_un.d_sdt 		|                   | 		|       sdt         | 		|                   | 		+-------------------+<-- sdt_got 		|                   | 		|      _GOT_        |<-- _GLOBAL_OFFSET_TABLE_ 		|                   |		( == sdt_got + got_origin) 		|                   | 		+-------------------+<-- sdt_plt 		|                   | 		|       PLT         | 		|                   | 		+-------------------+ */
end_comment

begin_comment
comment|/*  * Add NAME to the list of needed run-time objects.  * Return 1 if ENTRY was added to the list.  */
end_comment

begin_function
name|int
name|rrs_add_shobj
parameter_list|(
name|entry
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
block|{
name|struct
name|shobj
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|rrs_shobjs
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|->
name|entry
operator|->
name|filename
argument_list|,
name|entry
operator|->
name|filename
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
operator|*
name|p
operator|=
operator|(
expr|struct
name|shobj
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|shobj
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|->
name|entry
operator|=
name|entry
expr_stmt|;
name|number_of_shobjs
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|alloc_rrs_reloc
parameter_list|(
name|entry
parameter_list|,
name|sp
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|symbol
modifier|*
name|sp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"alloc_rrs_reloc: %s in %s\n"
argument_list|,
name|sp
operator|->
name|name
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|reserved_rrs_relocs
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|alloc_rrs_segment_reloc
parameter_list|(
name|entry
parameter_list|,
name|r
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|r
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"alloc_rrs_segment_reloc at %#x in %s\n"
argument_list|,
name|r
operator|->
name|r_address
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|reserved_rrs_relocs
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|alloc_rrs_jmpslot
parameter_list|(
name|entry
parameter_list|,
name|sp
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|symbol
modifier|*
name|sp
decl_stmt|;
block|{
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|GS_HASJMPSLOT
condition|)
return|return;
name|sp
operator|->
name|flags
operator||=
name|GS_HASJMPSLOT
expr_stmt|;
name|number_of_jmpslots
operator|++
expr_stmt|;
name|reserved_rrs_relocs
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|alloc_rrs_gotslot
parameter_list|(
name|entry
parameter_list|,
name|r
parameter_list|,
name|lsp
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|r
decl_stmt|;
name|struct
name|localsymbol
modifier|*
name|lsp
decl_stmt|;
block|{
name|symbol
modifier|*
name|sp
init|=
name|lsp
operator|->
name|symbol
decl_stmt|;
if|if
condition|(
operator|!
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
name|sp
operator|!=
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: relocation for internal symbol "
literal|"expected at %#x"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|,
name|RELOC_ADDRESS
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|RELOC_STATICS_THROUGH_GOT_P
argument_list|(
name|r
argument_list|)
condition|)
comment|/* No need for a GOT slot */
return|return;
if|if
condition|(
name|lsp
operator|->
name|flags
operator|&
name|LS_HASGOTSLOT
condition|)
return|return;
name|lsp
operator|->
name|flags
operator||=
name|LS_HASGOTSLOT
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: relocation must refer "
literal|"to global symbol at %#x"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|,
name|RELOC_ADDRESS
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sp
operator|->
name|alias
condition|)
name|sp
operator|=
name|sp
operator|->
name|alias
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|GS_HASGOTSLOT
condition|)
return|return;
name|sp
operator|->
name|flags
operator||=
name|GS_HASGOTSLOT
expr_stmt|;
block|}
name|number_of_gotslots
operator|++
expr_stmt|;
name|reserved_rrs_relocs
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|alloc_rrs_cpy_reloc
parameter_list|(
name|entry
parameter_list|,
name|sp
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|symbol
modifier|*
name|sp
decl_stmt|;
block|{
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|GS_CPYRELOCRESERVED
condition|)
return|return;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"alloc_rrs_copy: %s in %s\n"
argument_list|,
name|sp
operator|->
name|name
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sp
operator|->
name|flags
operator||=
name|GS_CPYRELOCRESERVED
expr_stmt|;
name|reserved_rrs_relocs
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|relocation_info
modifier|*
name|rrs_next_reloc
parameter_list|()
block|{
name|struct
name|relocation_info
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|rrs_reloc
operator|+
name|claimed_rrs_relocs
operator|++
expr_stmt|;
if|if
condition|(
name|claimed_rrs_relocs
operator|>
name|reserved_rrs_relocs
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: RRS relocs exceed allocation %d"
argument_list|,
name|reserved_rrs_relocs
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Claim a RRS relocation as a result of a regular (ie. non-PIC)  * relocation record in a rel file.  *  * Return 1 if the output file needs no further updating.  * Return 0 if the relocation value pointed to by RELOCATION must  * written to a.out.  */
end_comment

begin_function
name|int
name|claim_rrs_reloc
parameter_list|(
name|entry
parameter_list|,
name|rp
parameter_list|,
name|sp
parameter_list|,
name|relocation
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|rp
decl_stmt|;
name|symbol
modifier|*
name|sp
decl_stmt|;
name|long
modifier|*
name|relocation
decl_stmt|;
block|{
name|struct
name|relocation_info
modifier|*
name|r
init|=
name|rrs_next_reloc
argument_list|()
decl_stmt|;
if|if
condition|(
name|rp
operator|->
name|r_address
operator|<
name|text_start
operator|+
name|text_size
condition|)
name|warnx
argument_list|(
literal|"%s: RRS text relocation at %#x for \"%s\""
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|,
name|rp
operator|->
name|r_address
argument_list|,
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"claim_rrs_reloc: %s in %s\n"
argument_list|,
name|sp
operator|->
name|name
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|r
operator|->
name|r_address
operator|=
name|rp
operator|->
name|r_address
expr_stmt|;
name|r
operator|->
name|r_symbolnum
operator|=
name|sp
operator|->
name|rrs_symbolnum
expr_stmt|;
if|if
condition|(
name|link_mode
operator|&
name|SYMBOLIC
condition|)
block|{
if|if
condition|(
operator|!
name|sp
operator|->
name|defined
condition|)
name|warnx
argument_list|(
literal|"Cannot reduce symbol \"%s\" in %s"
argument_list|,
name|sp
operator|->
name|name
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
operator|*
name|relocation
operator|+=
name|sp
operator|->
name|value
expr_stmt|;
operator|(
name|void
operator|)
name|md_make_reloc
argument_list|(
name|rp
argument_list|,
name|r
argument_list|,
name|RELTYPE_RELATIVE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|md_make_reloc
argument_list|(
name|rp
argument_list|,
name|r
argument_list|,
name|RELTYPE_EXTERN
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Claim a jmpslot. Setup RRS relocation if claimed for the first time.  */
end_comment

begin_function
name|long
name|claim_rrs_jmpslot
parameter_list|(
name|entry
parameter_list|,
name|rp
parameter_list|,
name|sp
parameter_list|,
name|addend
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|rp
decl_stmt|;
name|symbol
modifier|*
name|sp
decl_stmt|;
name|long
name|addend
decl_stmt|;
block|{
name|struct
name|relocation_info
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sp
operator|->
name|flags
operator|&
name|GS_HASJMPSLOT
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: "
literal|"%s: claim_rrs_jmpslot: %s: no reservation"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|,
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|jmpslot_offset
operator|!=
operator|-
literal|1
condition|)
return|return
name|rrs_sdt
operator|.
name|sdt_plt
operator|+
name|sp
operator|->
name|jmpslot_offset
return|;
name|sp
operator|->
name|jmpslot_offset
operator|=
name|current_jmpslot_offset
expr_stmt|;
name|current_jmpslot_offset
operator|+=
sizeof|sizeof
argument_list|(
name|jmpslot_t
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"claim_rrs_jmpslot: %s: %s(%d) -> offset %x\n"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|,
name|sp
operator|->
name|name
argument_list|,
name|sp
operator|->
name|rrs_symbolnum
argument_list|,
name|sp
operator|->
name|jmpslot_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|link_mode
operator|&
name|SYMBOLIC
operator|)
operator|||
name|rrs_section_type
operator|==
name|RRS_PARTIAL
condition|)
block|{
if|if
condition|(
operator|!
name|sp
operator|->
name|defined
condition|)
name|warnx
argument_list|(
literal|"Cannot reduce symbol \"%s\" in %s"
argument_list|,
name|sp
operator|->
name|name
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|md_fix_jmpslot
argument_list|(
name|rrs_plt
operator|+
name|sp
operator|->
name|jmpslot_offset
operator|/
sizeof|sizeof
argument_list|(
name|jmpslot_t
argument_list|)
argument_list|,
name|rrs_sdt
operator|.
name|sdt_plt
operator|+
name|sp
operator|->
name|jmpslot_offset
argument_list|,
name|sp
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrs_section_type
operator|==
name|RRS_PARTIAL
operator|||
operator|!
name|JMPSLOT_NEEDS_RELOC
condition|)
block|{
comment|/* PLT is self-contained */
name|discarded_rrs_relocs
operator|++
expr_stmt|;
return|return
name|rrs_sdt
operator|.
name|sdt_plt
operator|+
name|sp
operator|->
name|jmpslot_offset
return|;
block|}
block|}
else|else
block|{
name|md_make_jmpslot
argument_list|(
name|rrs_plt
operator|+
name|sp
operator|->
name|jmpslot_offset
operator|/
sizeof|sizeof
argument_list|(
name|jmpslot_t
argument_list|)
argument_list|,
name|sp
operator|->
name|jmpslot_offset
argument_list|,
name|claimed_rrs_relocs
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Install a run-time relocation for this PLT entry. 	 */
name|r
operator|=
name|rrs_next_reloc
argument_list|()
expr_stmt|;
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
operator|=
name|sp
operator|->
name|rrs_symbolnum
expr_stmt|;
name|r
operator|->
name|r_address
operator|=
operator|(
name|long
operator|)
name|rrs_sdt
operator|.
name|sdt_plt
operator|+
name|sp
operator|->
name|jmpslot_offset
expr_stmt|;
if|if
condition|(
name|link_mode
operator|&
name|SYMBOLIC
condition|)
block|{
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|md_make_jmpreloc
argument_list|(
name|rp
argument_list|,
name|r
argument_list|,
name|RELTYPE_RELATIVE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
operator|=
literal|1
expr_stmt|;
name|md_make_jmpreloc
argument_list|(
name|rp
argument_list|,
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|rrs_sdt
operator|.
name|sdt_plt
operator|+
name|sp
operator|->
name|jmpslot_offset
return|;
block|}
end_function

begin_comment
comment|/*  * Claim GOT entry for a global symbol. If this is the first relocation  * claiming the entry, setup a RRS relocation for it.  * Return offset into the GOT allocated to this symbol.  */
end_comment

begin_function
name|long
name|claim_rrs_gotslot
parameter_list|(
name|entry
parameter_list|,
name|rp
parameter_list|,
name|lsp
parameter_list|,
name|addend
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|rp
decl_stmt|;
name|struct
name|localsymbol
modifier|*
name|lsp
decl_stmt|;
name|long
name|addend
decl_stmt|;
block|{
name|struct
name|relocation_info
modifier|*
name|r
decl_stmt|;
name|symbol
modifier|*
name|sp
init|=
name|lsp
operator|->
name|symbol
decl_stmt|;
name|int
name|reloc_type
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|sp
operator|->
name|alias
condition|)
name|sp
operator|=
name|sp
operator|->
name|alias
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sp
operator|->
name|flags
operator|&
name|GS_HASGOTSLOT
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: "
literal|"%s: claim_rrs_gotslot: %s: no reservation"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|,
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|gotslot_offset
operator|!=
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|*
name|GOTP
argument_list|(
name|sp
operator|->
name|gotslot_offset
argument_list|)
operator|!=
name|addend
operator|+
operator|(
operator|(
operator|!
operator|(
name|link_mode
operator|&
name|SHAREABLE
operator|)
operator|||
operator|(
name|link_mode
operator|&
name|SYMBOLIC
operator|)
operator|)
condition|?
name|sp
operator|->
name|value
else|:
literal|0
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %s: gotslot at %#x is multiple valued, "
literal|"*got = %#x, addend = %#x, sp->value = %#x"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|,
name|sp
operator|->
name|name
argument_list|,
name|sp
operator|->
name|gotslot_offset
argument_list|,
operator|*
name|GOTP
argument_list|(
name|sp
operator|->
name|gotslot_offset
argument_list|)
argument_list|,
name|addend
argument_list|,
name|sp
operator|->
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This symbol already passed here before. */
return|return
name|sp
operator|->
name|gotslot_offset
return|;
block|}
if|if
condition|(
name|current_got_offset
operator|==
literal|0
condition|)
comment|/* GOT offset 0 is reserved */
name|current_got_offset
operator|+=
sizeof|sizeof
argument_list|(
name|got_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_got_offset
operator|>
name|MAX_GOTOFF
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: GOT overflow on symbol `%s' at %#x"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|,
name|sp
operator|->
name|name
argument_list|,
name|RELOC_ADDRESS
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|gotslot_offset
operator|=
name|current_got_offset
expr_stmt|;
name|current_got_offset
operator|+=
sizeof|sizeof
argument_list|(
name|got_t
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"claim_rrs_gotslot: %s(%d,%#x) slot offset %#x, addend %#x\n"
argument_list|,
name|sp
operator|->
name|name
argument_list|,
name|sp
operator|->
name|rrs_symbolnum
argument_list|,
name|sp
operator|->
name|value
argument_list|,
name|sp
operator|->
name|gotslot_offset
argument_list|,
name|addend
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sp
operator|->
name|defined
operator|&&
operator|(
operator|!
operator|(
name|link_mode
operator|&
name|SHAREABLE
operator|)
operator|||
operator|(
name|link_mode
operator|&
name|SYMBOLIC
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Reduce to just a base-relative translation. 		 */
operator|*
name|GOTP
argument_list|(
name|sp
operator|->
name|gotslot_offset
argument_list|)
operator|=
name|sp
operator|->
name|value
operator|+
name|addend
expr_stmt|;
name|reloc_type
operator|=
name|RELTYPE_RELATIVE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|link_mode
operator|&
name|SYMBOLIC
operator|)
operator|||
name|rrs_section_type
operator|==
name|RRS_PARTIAL
condition|)
block|{
comment|/* 		 * SYMBOLIC: all symbols must be known. 		 * RRS_PARTIAL: we don't link against shared objects, 		 * so again all symbols must be known. 		 */
name|warnx
argument_list|(
literal|"Cannot reduce symbol \"%s\" in %s"
argument_list|,
name|sp
operator|->
name|name
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This gotslot will be updated with symbol value at run-time. 		 */
operator|*
name|GOTP
argument_list|(
name|sp
operator|->
name|gotslot_offset
argument_list|)
operator|=
name|addend
expr_stmt|;
block|}
if|if
condition|(
name|rrs_section_type
operator|==
name|RRS_PARTIAL
condition|)
block|{
comment|/* 		 * Base address is known, gotslot should be fully 		 * relocated by now. 		 * NOTE: RRS_PARTIAL implies !SHAREABLE. 		 */
if|if
condition|(
operator|!
name|sp
operator|->
name|defined
condition|)
name|warnx
argument_list|(
literal|"Cannot reduce symbol \"%s\" in %s"
argument_list|,
name|sp
operator|->
name|name
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|discarded_rrs_relocs
operator|++
expr_stmt|;
return|return
name|sp
operator|->
name|gotslot_offset
return|;
block|}
comment|/* 	 * Claim a relocation entry. 	 * If symbol is defined and in "main" (!SHAREABLE) 	 * we still put out a relocation as we cannot easily 	 * undo the allocation. 	 * `RELTYPE_RELATIVE' relocations have the external bit off 	 * as no symbol need be looked up at run-time. 	 */
name|r
operator|=
name|rrs_next_reloc
argument_list|()
expr_stmt|;
name|r
operator|->
name|r_address
operator|=
name|got_symbol
operator|->
name|value
operator|+
name|sp
operator|->
name|gotslot_offset
expr_stmt|;
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
operator|=
name|sp
operator|->
name|rrs_symbolnum
expr_stmt|;
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
operator|=
operator|!
operator|(
name|reloc_type
operator|==
name|RELTYPE_RELATIVE
operator|)
expr_stmt|;
name|md_make_gotreloc
argument_list|(
name|rp
argument_list|,
name|r
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
return|return
name|sp
operator|->
name|gotslot_offset
return|;
block|}
end_function

begin_comment
comment|/*  * Claim a GOT entry for a static symbol. Return offset of the  * allocated GOT entry. If RELOC_STATICS_THROUGH_GOT_P is in effect,  * return the offset of the symbol with respect to the *location* of  * the GOT.  */
end_comment

begin_function
name|long
name|claim_rrs_internal_gotslot
parameter_list|(
name|entry
parameter_list|,
name|rp
parameter_list|,
name|lsp
parameter_list|,
name|addend
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|rp
decl_stmt|;
name|struct
name|localsymbol
modifier|*
name|lsp
decl_stmt|;
name|long
name|addend
decl_stmt|;
block|{
name|struct
name|relocation_info
modifier|*
name|r
decl_stmt|;
name|addend
operator|+=
name|lsp
operator|->
name|nzlist
operator|.
name|nz_value
expr_stmt|;
if|if
condition|(
operator|!
name|RELOC_STATICS_THROUGH_GOT_P
argument_list|(
name|r
argument_list|)
condition|)
return|return
name|addend
operator|-
name|got_symbol
operator|->
name|value
return|;
if|if
condition|(
operator|!
operator|(
name|lsp
operator|->
name|flags
operator|&
name|LS_HASGOTSLOT
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: "
literal|"%s: claim_rrs_internal_gotslot at %#x: no reservation"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|,
name|RELOC_ADDRESS
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsp
operator|->
name|gotslot_offset
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Already claimed */
if|if
condition|(
operator|*
name|GOTP
argument_list|(
name|lsp
operator|->
name|gotslot_offset
argument_list|)
operator|!=
name|addend
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: gotslot at %#x is multiple valued"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|,
name|lsp
operator|->
name|gotslot_offset
argument_list|)
expr_stmt|;
return|return
name|lsp
operator|->
name|gotslot_offset
return|;
block|}
if|if
condition|(
name|current_got_offset
operator|==
literal|0
condition|)
comment|/* GOT offset 0 is reserved */
name|current_got_offset
operator|+=
sizeof|sizeof
argument_list|(
name|got_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_got_offset
operator|>
name|MAX_GOTOFF
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: GOT overflow for relocation at %#x"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|,
name|RELOC_ADDRESS
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
name|lsp
operator|->
name|gotslot_offset
operator|=
name|current_got_offset
expr_stmt|;
name|current_got_offset
operator|+=
sizeof|sizeof
argument_list|(
name|got_t
argument_list|)
expr_stmt|;
operator|*
name|GOTP
argument_list|(
name|lsp
operator|->
name|gotslot_offset
argument_list|)
operator|=
name|addend
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"claim_rrs_internal_gotslot: %s: slot offset %#x, addend = %#x\n"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|,
name|lsp
operator|->
name|gotslot_offset
argument_list|,
name|addend
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rrs_section_type
operator|==
name|RRS_PARTIAL
condition|)
block|{
name|discarded_rrs_relocs
operator|++
expr_stmt|;
return|return
name|lsp
operator|->
name|gotslot_offset
return|;
block|}
comment|/* 	 * Relocation entry needed for this static GOT entry. 	 */
name|r
operator|=
name|rrs_next_reloc
argument_list|()
expr_stmt|;
name|r
operator|->
name|r_address
operator|=
name|got_symbol
operator|->
name|value
operator|+
name|lsp
operator|->
name|gotslot_offset
expr_stmt|;
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|md_make_gotreloc
argument_list|(
name|rp
argument_list|,
name|r
argument_list|,
name|RELTYPE_RELATIVE
argument_list|)
expr_stmt|;
return|return
name|lsp
operator|->
name|gotslot_offset
return|;
block|}
end_function

begin_function
name|void
name|claim_rrs_cpy_reloc
parameter_list|(
name|entry
parameter_list|,
name|rp
parameter_list|,
name|sp
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|rp
decl_stmt|;
name|symbol
modifier|*
name|sp
decl_stmt|;
block|{
name|struct
name|relocation_info
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|GS_CPYRELOCCLAIMED
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|sp
operator|->
name|flags
operator|&
name|GS_CPYRELOCRESERVED
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: "
literal|"%s: claim_cpy_reloc: %s: no reservation"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|,
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"claim_rrs_copy: %s: %s -> %x\n"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|,
name|sp
operator|->
name|name
argument_list|,
name|sp
operator|->
name|so_defined
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|r
operator|=
name|rrs_next_reloc
argument_list|()
expr_stmt|;
name|sp
operator|->
name|flags
operator||=
name|GS_CPYRELOCCLAIMED
expr_stmt|;
name|r
operator|->
name|r_address
operator|=
name|rp
operator|->
name|r_address
expr_stmt|;
name|RELOC_SYMBOL
argument_list|(
name|r
argument_list|)
operator|=
name|sp
operator|->
name|rrs_symbolnum
expr_stmt|;
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
operator|=
name|RELOC_EXTERN_P
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|md_make_cpyreloc
argument_list|(
name|rp
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|claim_rrs_segment_reloc
parameter_list|(
name|entry
parameter_list|,
name|rp
parameter_list|)
name|struct
name|file_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|rp
decl_stmt|;
block|{
name|struct
name|relocation_info
modifier|*
name|r
init|=
name|rrs_next_reloc
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"claim_rrs_segment_reloc: %s at %#x\n"
argument_list|,
name|get_file_name
argument_list|(
name|entry
argument_list|)
argument_list|,
name|rp
operator|->
name|r_address
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|r
operator|->
name|r_address
operator|=
name|rp
operator|->
name|r_address
expr_stmt|;
name|RELOC_TYPE
argument_list|(
name|r
argument_list|)
operator|=
name|RELOC_TYPE
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|RELOC_EXTERN_P
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|md_make_reloc
argument_list|(
name|rp
argument_list|,
name|r
argument_list|,
name|RELTYPE_RELATIVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fill the RRS hash table for the given symbol name.  * NOTE: the hash value computation must match the one in rtld.  */
end_comment

begin_function
name|void
name|rrs_insert_hash
parameter_list|(
name|cp
parameter_list|,
name|index
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|index
decl_stmt|;
block|{
name|int
name|hashval
init|=
literal|0
decl_stmt|;
name|struct
name|rrs_hash
modifier|*
name|hp
decl_stmt|;
for|for
control|(
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
name|hashval
operator|=
operator|(
name|hashval
operator|<<
literal|1
operator|)
operator|+
operator|*
name|cp
expr_stmt|;
name|hashval
operator|=
operator|(
name|hashval
operator|&
literal|0x7fffffff
operator|)
operator|%
name|rrs_sdt
operator|.
name|sdt_buckets
expr_stmt|;
comment|/* Get to the bucket */
name|hp
operator|=
name|rrs_hashtab
operator|+
name|hashval
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|rh_symbolnum
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Empty bucket, use it */
name|hp
operator|->
name|rh_symbolnum
operator|=
name|index
expr_stmt|;
name|hp
operator|->
name|rh_next
operator|=
literal|0
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|hp
operator|->
name|rh_next
operator|!=
literal|0
condition|)
name|hp
operator|=
name|rrs_hashtab
operator|+
name|hp
operator|->
name|rh_next
expr_stmt|;
name|hp
operator|->
name|rh_next
operator|=
name|current_hash_index
operator|++
expr_stmt|;
name|hp
operator|=
name|rrs_hashtab
operator|+
name|hp
operator|->
name|rh_next
expr_stmt|;
name|hp
operator|->
name|rh_symbolnum
operator|=
name|index
expr_stmt|;
name|hp
operator|->
name|rh_next
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * There are two interesting cases to consider here.  *  * 1) No shared objects were loaded, but there were PIC input rel files.  *    In this case we must output a _GLOBAL_OFFSET_TABLE_ but no other  *    RRS data. Also, the entries in the GOT must be fully resolved.  *  * 2) It's a genuine dynamically linked program, so the whole RRS scoop  *    goes into a.out.  */
end_comment

begin_function
name|void
name|consider_rrs_section_lengths
parameter_list|()
block|{
name|int
name|n
decl_stmt|;
name|struct
name|shobj
modifier|*
name|shp
decl_stmt|,
modifier|*
modifier|*
name|shpp
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* We run into trouble with this as long as shared object symbols    are not checked for definitions */
comment|/* 	 * First, determine the real number of shared objects we need. 	 */
for|for
control|(
name|shpp
operator|=
operator|&
name|rrs_shobjs
init|;
operator|*
name|shpp
condition|;
name|shpp
operator|=
operator|&
operator|(
operator|*
name|shpp
operator|)
operator|->
name|next
control|)
block|{
while|while
condition|(
operator|*
name|shpp
operator|&&
operator|!
operator|(
operator|(
operator|*
name|shpp
operator|)
operator|->
name|entry
operator|->
name|flags
operator|&
name|E_SYMBOLS_USED
operator|)
condition|)
block|{
if|if
condition|(
operator|--
name|number_of_shobjs
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: number_of_shobjs< 0"
argument_list|)
expr_stmt|;
operator|*
name|shpp
operator|=
operator|(
operator|*
name|shpp
operator|)
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|shpp
operator|==
name|NULL
condition|)
break|break;
block|}
endif|#
directive|endif
comment|/* First, determine what of the RRS we want */
if|if
condition|(
name|relocatable_output
condition|)
name|rrs_section_type
operator|=
name|RRS_NONE
expr_stmt|;
elseif|else
if|if
condition|(
name|link_mode
operator|&
name|SHAREABLE
condition|)
name|rrs_section_type
operator|=
name|RRS_FULL
expr_stmt|;
elseif|else
if|if
condition|(
name|number_of_shobjs
operator|==
literal|0
comment|/*&& !(link_mode& DYNAMIC)*/
condition|)
block|{
comment|/* 		 * First slots in both tables are reserved 		 * hence the "> 1" condition 		 */
if|if
condition|(
name|number_of_gotslots
operator|>
literal|1
operator|||
name|number_of_jmpslots
operator|>
literal|1
condition|)
name|rrs_section_type
operator|=
name|RRS_PARTIAL
expr_stmt|;
else|else
name|rrs_section_type
operator|=
name|RRS_NONE
expr_stmt|;
block|}
else|else
name|rrs_section_type
operator|=
name|RRS_FULL
expr_stmt|;
if|if
condition|(
name|rrs_section_type
operator|==
name|RRS_NONE
condition|)
block|{
name|got_symbol
operator|->
name|defined
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reserved_rrs_relocs
operator|>
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: empty RRS has reservations"
argument_list|)
expr_stmt|;
return|return;
block|}
name|rrs_symbol_size
operator|=
name|LD_VERSION_NZLIST_P
argument_list|(
name|soversion
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
expr|struct
name|nzlist
argument_list|)
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
expr_stmt|;
comment|/* 	 * If there is an entry point, __DYNAMIC must be referenced (usually 	 * from crt0), as this is the method used to determine whether the 	 * run-time linker must be called. 	 */
if|if
condition|(
operator|!
operator|(
name|link_mode
operator|&
name|SHAREABLE
operator|)
operator|&&
operator|!
operator|(
name|dynamic_symbol
operator|->
name|flags
operator|&
name|GS_REFERENCED
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"No reference to __DYNAMIC"
argument_list|)
expr_stmt|;
name|dynamic_symbol
operator|->
name|flags
operator||=
name|GS_REFERENCED
expr_stmt|;
if|if
condition|(
name|number_of_gotslots
operator|>
literal|1
condition|)
name|got_symbol
operator|->
name|flags
operator||=
name|GS_REFERENCED
expr_stmt|;
comment|/* Next, allocate relocs, got and plt */
name|n
operator|=
name|reserved_rrs_relocs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
expr_stmt|;
name|rrs_reloc
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
name|xmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|rrs_reloc
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|number_of_gotslots
operator|*
sizeof|sizeof
argument_list|(
name|got_t
argument_list|)
expr_stmt|;
name|rrs_got
operator|=
operator|(
name|got_t
operator|*
operator|)
name|xmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|rrs_got
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|number_of_jmpslots
operator|*
sizeof|sizeof
argument_list|(
name|jmpslot_t
argument_list|)
expr_stmt|;
name|rrs_plt
operator|=
operator|(
name|jmpslot_t
operator|*
operator|)
name|xmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|rrs_plt
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* Initialize first jmpslot */
name|md_fix_jmpslot
argument_list|(
name|rrs_plt
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrs_section_type
operator|==
name|RRS_PARTIAL
condition|)
block|{
name|rrs_data_size
operator|=
name|number_of_gotslots
operator|*
sizeof|sizeof
argument_list|(
name|got_t
argument_list|)
expr_stmt|;
name|rrs_data_size
operator|+=
name|number_of_jmpslots
operator|*
sizeof|sizeof
argument_list|(
name|jmpslot_t
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Walk the symbol table, assign RRS symbol numbers 	 * and calculate string space. 	 * Assign number 0 to __DYNAMIC (!! Sun compatibility) 	 */
name|dynamic_symbol
operator|->
name|rrs_symbolnum
operator|=
name|number_of_rrs_symbols
operator|++
expr_stmt|;
name|FOR_EACH_SYMBOL
argument_list|(
argument|i
argument_list|,
argument|sp
argument_list|)
block|{
if|if
condition|(
operator|(
name|link_mode
operator|&
name|SHAREABLE
operator|)
operator|&&
name|sp
operator|->
name|warning
condition|)
block|{
comment|/* Allocate N_WARNING& co */
name|rrs_strtab_size
operator|+=
literal|2
operator|+
name|strlen
argument_list|(
name|sp
operator|->
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|sp
operator|->
name|warning
argument_list|)
expr_stmt|;
name|number_of_rrs_symbols
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|sp
operator|->
name|flags
operator|&
name|GS_REFERENCED
operator|)
condition|)
continue|continue;
name|rrs_strtab_size
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
name|dynamic_symbol
condition|)
name|sp
operator|->
name|rrs_symbolnum
operator|=
name|number_of_rrs_symbols
operator|++
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|alias
condition|)
block|{
comment|/* 			 * (sigh) Always allocate space to hold the 			 * indirection. At this point there's not 			 * enough information to decide whether it's 			 * actually needed or not. 			 */
name|number_of_rrs_symbols
operator|++
expr_stmt|;
name|rrs_strtab_size
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|sp
operator|->
name|alias
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|END_EACH_SYMBOL
expr_stmt|;
comment|/* 	 * Now that we know how many RRS symbols there are going to be, 	 * allocate and initialize the RRS symbol hash table. 	 */
name|rrs_sdt
operator|.
name|sdt_buckets
operator|=
name|number_of_rrs_symbols
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|rrs_sdt
operator|.
name|sdt_buckets
operator|<
literal|4
condition|)
name|rrs_sdt
operator|.
name|sdt_buckets
operator|=
literal|4
expr_stmt|;
name|number_of_rrs_hash_entries
operator|=
name|rrs_sdt
operator|.
name|sdt_buckets
operator|+
name|number_of_rrs_symbols
expr_stmt|;
name|rrs_hashtab
operator|=
operator|(
expr|struct
name|rrs_hash
operator|*
operator|)
name|xmalloc
argument_list|(
name|number_of_rrs_hash_entries
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rrs_hash
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|rrs_sdt
operator|.
name|sdt_buckets
condition|;
name|n
operator|++
control|)
name|rrs_hashtab
index|[
name|n
index|]
operator|.
name|rh_symbolnum
operator|=
operator|-
literal|1
expr_stmt|;
name|current_hash_index
operator|=
name|rrs_sdt
operator|.
name|sdt_buckets
expr_stmt|;
comment|/* 	 * Get symbols into hash table now, so we can fine tune the size 	 * of the latter. We adjust the value of `number_of_rrs_hash_entries' 	 * to the number of hash link slots actually used. 	 */
name|FOR_EACH_SYMBOL
argument_list|(
argument|i
argument_list|,
argument|sp
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|GS_REFERENCED
condition|)
name|rrs_insert_hash
argument_list|(
name|sp
operator|->
name|name
argument_list|,
name|sp
operator|->
name|rrs_symbolnum
argument_list|)
expr_stmt|;
block|}
name|END_EACH_SYMBOL
expr_stmt|;
name|number_of_rrs_hash_entries
operator|=
name|current_hash_index
expr_stmt|;
comment|/* 	 * Calculate RRS section sizes. 	 */
name|rrs_data_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|_dynamic
argument_list|)
expr_stmt|;
name|rrs_data_size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|so_debug
argument_list|)
expr_stmt|;
name|rrs_data_size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|section_dispatch_table
argument_list|)
expr_stmt|;
name|rrs_data_size
operator|+=
name|number_of_gotslots
operator|*
sizeof|sizeof
argument_list|(
name|got_t
argument_list|)
expr_stmt|;
name|rrs_data_size
operator|+=
name|number_of_jmpslots
operator|*
sizeof|sizeof
argument_list|(
name|jmpslot_t
argument_list|)
expr_stmt|;
name|rrs_data_size
operator|=
name|MALIGN
argument_list|(
name|rrs_data_size
argument_list|)
expr_stmt|;
name|rrs_text_size
operator|=
name|reserved_rrs_relocs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
expr_stmt|;
name|rrs_text_size
operator|+=
name|number_of_rrs_hash_entries
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rrs_hash
argument_list|)
expr_stmt|;
name|rrs_text_size
operator|+=
name|number_of_rrs_symbols
operator|*
name|rrs_symbol_size
expr_stmt|;
comment|/* Align strings size */
name|rrs_strtab_size
operator|=
name|MALIGN
argument_list|(
name|rrs_strtab_size
argument_list|)
expr_stmt|;
name|rrs_text_size
operator|+=
name|rrs_strtab_size
expr_stmt|;
comment|/* Process needed shared objects */
for|for
control|(
name|shp
operator|=
name|rrs_shobjs
init|;
name|shp
condition|;
name|shp
operator|=
name|shp
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|name
init|=
name|shp
operator|->
name|entry
operator|->
name|local_sym_name
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'-'
operator|&&
operator|*
operator|(
name|name
operator|+
literal|1
operator|)
operator|==
literal|'l'
condition|)
name|name
operator|+=
literal|2
expr_stmt|;
name|rrs_text_size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sod
argument_list|)
expr_stmt|;
name|rrs_text_size
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Finally, align size */
name|rrs_text_size
operator|=
name|MALIGN
argument_list|(
name|rrs_text_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|relocate_rrs_addresses
parameter_list|()
block|{
name|dynamic_symbol
operator|->
name|value
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Get ready to allocate linkage table offsets. 	 * First jmpslot is reserved for the run-time binder 	 * GOT entry at offset 0 is reserved for `__DYNAMIC'. 	 */
name|current_jmpslot_offset
operator|=
sizeof|sizeof
argument_list|(
name|jmpslot_t
argument_list|)
expr_stmt|;
name|current_got_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|1
comment|/* Not "-fPIC" seen */
condition|)
block|{
name|int
name|gotsize
init|=
name|number_of_gotslots
operator|*
sizeof|sizeof
argument_list|(
name|got_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|gotsize
operator|+
name|MIN_GOTOFF
operator|-
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|got_t
argument_list|)
operator|>
name|MAX_GOTOFF
condition|)
name|warnx
argument_list|(
literal|"Global Offset Table overflow"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gotsize
operator|>
name|MAX_GOTOFF
condition|)
comment|/* Position at "two-complements" origin */
name|current_got_offset
operator|+=
name|MIN_GOTOFF
expr_stmt|;
block|}
name|got_origin
operator|=
operator|-
name|current_got_offset
expr_stmt|;
if|if
condition|(
name|rrs_section_type
operator|==
name|RRS_NONE
condition|)
return|return;
if|if
condition|(
name|rrs_section_type
operator|==
name|RRS_PARTIAL
condition|)
block|{
name|rrs_sdt
operator|.
name|sdt_got
operator|=
name|rrs_data_start
expr_stmt|;
name|got_symbol
operator|->
name|value
operator|=
name|rrs_sdt
operator|.
name|sdt_got
operator|+
name|got_origin
expr_stmt|;
name|rrs_sdt
operator|.
name|sdt_plt
operator|=
name|rrs_sdt
operator|.
name|sdt_got
operator|+
name|number_of_gotslots
operator|*
sizeof|sizeof
argument_list|(
name|got_t
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * RRS data relocations. 	 */
name|rrs_dyn
operator|.
name|d_version
operator|=
name|soversion
expr_stmt|;
name|rrs_dyn
operator|.
name|d_debug
operator|=
operator|(
expr|struct
name|so_debug
operator|*
operator|)
operator|(
name|rrs_data_start
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|_dynamic
argument_list|)
operator|)
expr_stmt|;
name|rrs_dyn
operator|.
name|d_un
operator|.
name|d_sdt
operator|=
operator|(
expr|struct
name|section_dispatch_table
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|rrs_dyn
operator|.
name|d_debug
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|so_debug
argument_list|)
operator|)
expr_stmt|;
name|rrs_sdt
operator|.
name|sdt_got
operator|=
operator|(
name|long
operator|)
name|rrs_dyn
operator|.
name|d_un
operator|.
name|d_sdt
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|section_dispatch_table
argument_list|)
expr_stmt|;
name|rrs_sdt
operator|.
name|sdt_plt
operator|=
name|rrs_sdt
operator|.
name|sdt_got
operator|+
name|number_of_gotslots
operator|*
sizeof|sizeof
argument_list|(
name|got_t
argument_list|)
expr_stmt|;
comment|/* 	 * RRS text relocations. 	 */
name|rrs_sdt
operator|.
name|sdt_rel
operator|=
name|rrs_text_start
expr_stmt|;
comment|/* 	 * Sun BUG compatibility alert. 	 * Main program's RRS text values are relative to TXTADDR? WHY?? 	 */
ifdef|#
directive|ifdef
name|SUN_COMPAT
if|if
condition|(
name|soversion
operator|==
name|LD_VERSION_SUN
operator|&&
operator|!
operator|(
name|link_mode
operator|&
name|SHAREABLE
operator|)
condition|)
name|rrs_sdt
operator|.
name|sdt_rel
operator|-=
name|N_TXTADDR
argument_list|(
name|outheader
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rrs_sdt
operator|.
name|sdt_hash
operator|=
name|rrs_sdt
operator|.
name|sdt_rel
operator|+
name|reserved_rrs_relocs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
expr_stmt|;
name|rrs_sdt
operator|.
name|sdt_nzlist
operator|=
name|rrs_sdt
operator|.
name|sdt_hash
operator|+
name|number_of_rrs_hash_entries
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rrs_hash
argument_list|)
expr_stmt|;
name|rrs_sdt
operator|.
name|sdt_strings
operator|=
name|rrs_sdt
operator|.
name|sdt_nzlist
operator|+
name|number_of_rrs_symbols
operator|*
name|rrs_symbol_size
expr_stmt|;
name|rrs_sdt
operator|.
name|sdt_str_sz
operator|=
name|rrs_strtab_size
expr_stmt|;
name|rrs_sdt
operator|.
name|sdt_text_sz
operator|=
name|text_size
expr_stmt|;
name|rrs_sdt
operator|.
name|sdt_plt_sz
operator|=
name|number_of_jmpslots
operator|*
sizeof|sizeof
argument_list|(
name|jmpslot_t
argument_list|)
expr_stmt|;
name|rrs_sdt
operator|.
name|sdt_sods
operator|=
name|rrs_shobjs
condition|?
name|rrs_sdt
operator|.
name|sdt_strings
operator|+
name|rrs_strtab_size
else|:
literal|0
expr_stmt|;
name|rrs_sdt
operator|.
name|sdt_filler1
operator|=
literal|0
expr_stmt|;
name|rrs_sdt
operator|.
name|sdt_filler2
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Assign addresses to _GLOBAL_OFFSET_TABLE_ and __DYNAMIC. 	 * The value `&__DYNAMIC' is in the GOT table at offset 0. 	 */
name|got_symbol
operator|->
name|value
operator|=
name|rrs_sdt
operator|.
name|sdt_got
operator|+
name|got_origin
expr_stmt|;
operator|*
name|GOTP
argument_list|(
literal|0
argument_list|)
operator|=
name|dynamic_symbol
operator|->
name|value
operator|=
name|rrs_data_start
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_rrs_data
parameter_list|()
block|{
name|long
name|pos
decl_stmt|;
if|if
condition|(
name|rrs_section_type
operator|==
name|RRS_NONE
condition|)
return|return;
name|pos
operator|=
name|rrs_data_start
operator|+
operator|(
name|N_DATOFF
argument_list|(
name|outheader
argument_list|)
operator|-
name|DATA_START
argument_list|(
name|outheader
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|outstream
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"write_rrs_data: fseek"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrs_section_type
operator|==
name|RRS_PARTIAL
condition|)
block|{
comment|/* 		 * Only a GOT and PLT are needed. 		 */
name|md_swapout_got
argument_list|(
name|rrs_got
argument_list|,
name|number_of_gotslots
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
name|rrs_got
argument_list|,
name|number_of_gotslots
argument_list|,
sizeof|sizeof
argument_list|(
name|got_t
argument_list|)
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
name|md_swapout_jmpslot
argument_list|(
name|rrs_plt
argument_list|,
name|number_of_jmpslots
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
name|rrs_plt
argument_list|,
name|number_of_jmpslots
argument_list|,
sizeof|sizeof
argument_list|(
name|jmpslot_t
argument_list|)
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
return|return;
block|}
name|md_swapout__dynamic
argument_list|(
operator|&
name|rrs_dyn
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
operator|&
name|rrs_dyn
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_dynamic
argument_list|)
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
name|md_swapout_so_debug
argument_list|(
operator|&
name|rrs_so_debug
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
operator|&
name|rrs_so_debug
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|so_debug
argument_list|)
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
name|md_swapout_section_dispatch_table
argument_list|(
operator|&
name|rrs_sdt
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
operator|&
name|rrs_sdt
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|section_dispatch_table
argument_list|)
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
name|md_swapout_got
argument_list|(
name|rrs_got
argument_list|,
name|number_of_gotslots
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
name|rrs_got
argument_list|,
name|number_of_gotslots
argument_list|,
sizeof|sizeof
argument_list|(
name|got_t
argument_list|)
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
name|md_swapout_jmpslot
argument_list|(
name|rrs_plt
argument_list|,
name|number_of_jmpslots
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
name|rrs_plt
argument_list|,
name|number_of_jmpslots
argument_list|,
sizeof|sizeof
argument_list|(
name|jmpslot_t
argument_list|)
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_rrs_text
parameter_list|()
block|{
name|long
name|pos
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|symsize
decl_stmt|;
name|struct
name|nzlist
modifier|*
name|nlp
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|struct
name|shobj
modifier|*
name|shp
decl_stmt|;
name|struct
name|sod
modifier|*
name|sodp
decl_stmt|;
name|int
name|bind
decl_stmt|;
if|if
condition|(
name|rrs_section_type
operator|==
name|RRS_PARTIAL
condition|)
return|return;
name|pos
operator|=
name|rrs_text_start
operator|+
operator|(
name|N_TXTOFF
argument_list|(
name|outheader
argument_list|)
operator|-
name|TEXT_START
argument_list|(
name|outheader
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|outstream
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"write_rrs_text: fseek"
argument_list|)
expr_stmt|;
comment|/* Write relocation records */
name|md_swapout_reloc
argument_list|(
name|rrs_reloc
argument_list|,
name|reserved_rrs_relocs
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
name|rrs_reloc
argument_list|,
name|reserved_rrs_relocs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
comment|/* Write the RRS symbol hash tables */
name|md_swapout_rrs_hash
argument_list|(
name|rrs_hashtab
argument_list|,
name|number_of_rrs_hash_entries
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
name|rrs_hashtab
argument_list|,
name|number_of_rrs_hash_entries
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rrs_hash
argument_list|)
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
comment|/* 	 * Determine size of an RRS symbol entry, allocate space 	 * to collect them in. 	 */
name|symsize
operator|=
name|number_of_rrs_symbols
operator|*
name|rrs_symbol_size
expr_stmt|;
name|nlp
operator|=
name|rrs_symbols
operator|=
operator|(
expr|struct
name|nzlist
operator|*
operator|)
name|alloca
argument_list|(
name|symsize
argument_list|)
expr_stmt|;
name|rrs_strtab
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|rrs_strtab_size
argument_list|)
expr_stmt|;
define|#
directive|define
name|INCR_NLP
parameter_list|(
name|p
parameter_list|)
value|((p) = (struct nzlist *)((long)(p) + rrs_symbol_size))
comment|/* __DYNAMIC symbol *must* be first for Sun compatibility */
name|nlp
operator|->
name|nz_desc
operator|=
name|nlp
operator|->
name|nz_other
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|LD_VERSION_NZLIST_P
argument_list|(
name|soversion
argument_list|)
condition|)
name|nlp
operator|->
name|nz_size
operator|=
literal|0
expr_stmt|;
name|nlp
operator|->
name|nz_type
operator|=
name|dynamic_symbol
operator|->
name|defined
expr_stmt|;
name|nlp
operator|->
name|nz_value
operator|=
name|dynamic_symbol
operator|->
name|value
expr_stmt|;
name|nlp
operator|->
name|nz_value
operator|=
name|dynamic_symbol
operator|->
name|value
expr_stmt|;
name|nlp
operator|->
name|nz_strx
operator|=
name|offset
expr_stmt|;
name|strcpy
argument_list|(
name|rrs_strtab
operator|+
name|offset
argument_list|,
name|dynamic_symbol
operator|->
name|name
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|dynamic_symbol
operator|->
name|name
argument_list|)
expr_stmt|;
name|INCR_NLP
argument_list|(
name|nlp
argument_list|)
expr_stmt|;
comment|/* 	 * Now, for each global symbol, construct a nzlist element 	 * for inclusion in the RRS symbol table. 	 */
name|FOR_EACH_SYMBOL
argument_list|(
argument|i
argument_list|,
argument|sp
argument_list|)
block|{
if|if
condition|(
name|sp
operator|==
name|dynamic_symbol
condition|)
continue|continue;
if|if
condition|(
operator|(
name|link_mode
operator|&
name|SHAREABLE
operator|)
operator|&&
name|sp
operator|->
name|warning
condition|)
block|{
comment|/* 			 * Write a N_WARNING duo. 			 */
name|nlp
operator|->
name|nz_type
operator|=
name|N_WARNING
expr_stmt|;
name|nlp
operator|->
name|nz_un
operator|.
name|n_strx
operator|=
name|offset
expr_stmt|;
name|nlp
operator|->
name|nz_value
operator|=
literal|0
expr_stmt|;
name|nlp
operator|->
name|nz_other
operator|=
literal|0
expr_stmt|;
name|nlp
operator|->
name|nz_desc
operator|=
literal|0
expr_stmt|;
name|nlp
operator|->
name|nz_size
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|rrs_strtab
operator|+
name|offset
argument_list|,
name|sp
operator|->
name|warning
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|sp
operator|->
name|warning
argument_list|)
expr_stmt|;
name|INCR_NLP
argument_list|(
name|nlp
argument_list|)
expr_stmt|;
name|nlp
operator|->
name|nz_type
operator|=
name|N_UNDF
operator|+
name|N_EXT
expr_stmt|;
name|nlp
operator|->
name|nz_un
operator|.
name|n_strx
operator|=
name|offset
expr_stmt|;
name|nlp
operator|->
name|nz_value
operator|=
literal|0
expr_stmt|;
name|nlp
operator|->
name|nz_other
operator|=
literal|0
expr_stmt|;
name|nlp
operator|->
name|nz_desc
operator|=
literal|0
expr_stmt|;
name|nlp
operator|->
name|nz_size
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|rrs_strtab
operator|+
name|offset
argument_list|,
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
name|INCR_NLP
argument_list|(
name|nlp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|sp
operator|->
name|flags
operator|&
name|GS_REFERENCED
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|long
operator|)
name|nlp
operator|-
operator|(
name|long
operator|)
name|rrs_symbols
operator|>=
name|number_of_rrs_symbols
operator|*
name|rrs_symbol_size
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: "
literal|"rrs symbols exceed allocation %d"
argument_list|,
name|number_of_rrs_symbols
argument_list|)
expr_stmt|;
name|nlp
operator|->
name|nz_desc
operator|=
literal|0
expr_stmt|;
name|nlp
operator|->
name|nz_other
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|LD_VERSION_NZLIST_P
argument_list|(
name|soversion
argument_list|)
condition|)
name|nlp
operator|->
name|nz_size
operator|=
literal|0
expr_stmt|;
name|bind
operator|=
operator|(
name|sp
operator|->
name|flags
operator|&
name|GS_WEAK
operator|)
condition|?
name|BIND_WEAK
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|defined
operator|>
literal|1
condition|)
block|{
comment|/* defined with known type */
if|if
condition|(
operator|!
operator|(
name|link_mode
operator|&
name|SHAREABLE
operator|)
operator|&&
name|sp
operator|->
name|alias
operator|&&
name|sp
operator|->
name|alias
operator|->
name|defined
operator|>
literal|1
condition|)
block|{
comment|/* 				 * If the target of an indirect symbol has 				 * been defined and we are outputting an 				 * executable, resolve the indirection; it's 				 * no longer needed. 				 */
name|nlp
operator|->
name|nz_type
operator|=
name|sp
operator|->
name|alias
operator|->
name|defined
expr_stmt|;
name|nlp
operator|->
name|nz_value
operator|=
name|sp
operator|->
name|alias
operator|->
name|value
expr_stmt|;
name|nlp
operator|->
name|nz_other
operator|=
name|N_OTHER
argument_list|(
name|bind
argument_list|,
name|sp
operator|->
name|alias
operator|->
name|aux
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|defined
operator|==
name|N_SIZE
condition|)
block|{
comment|/* 				 * Make sure this symbol isn't going 				 * to define anything. 				 */
name|nlp
operator|->
name|nz_type
operator|=
name|N_UNDF
expr_stmt|;
name|nlp
operator|->
name|nz_value
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|nlp
operator|->
name|nz_type
operator|=
name|sp
operator|->
name|defined
expr_stmt|;
name|nlp
operator|->
name|nz_value
operator|=
name|sp
operator|->
name|value
expr_stmt|;
name|nlp
operator|->
name|nz_other
operator|=
name|N_OTHER
argument_list|(
name|bind
argument_list|,
name|sp
operator|->
name|aux
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LD_VERSION_NZLIST_P
argument_list|(
name|soversion
argument_list|)
condition|)
name|nlp
operator|->
name|nz_size
operator|=
name|sp
operator|->
name|size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|common_size
condition|)
block|{
comment|/* 			 * A common definition. 			 */
name|nlp
operator|->
name|nz_type
operator|=
name|N_UNDF
operator||
name|N_EXT
expr_stmt|;
name|nlp
operator|->
name|nz_value
operator|=
name|sp
operator|->
name|common_size
expr_stmt|;
name|nlp
operator|->
name|nz_other
operator|=
name|N_OTHER
argument_list|(
name|bind
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sp
operator|->
name|defined
condition|)
block|{
comment|/* undefined */
name|nlp
operator|->
name|nz_type
operator|=
name|N_UNDF
operator||
name|N_EXT
expr_stmt|;
name|nlp
operator|->
name|nz_value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|so_defined
operator|&&
name|sp
operator|->
name|jmpslot_offset
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 				 * A PLT entry. The auxiliary type -- which 				 * must be AUX_FUNC -- is used by the run-time 				 * linker to unambiguously resolve function 				 * address references. 				 */
if|if
condition|(
name|sp
operator|->
name|aux
operator|!=
name|AUX_FUNC
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: non-function jmpslot"
argument_list|,
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
name|nlp
operator|->
name|nz_other
operator|=
name|N_OTHER
argument_list|(
name|bind
argument_list|,
name|sp
operator|->
name|aux
argument_list|)
expr_stmt|;
name|nlp
operator|->
name|nz_value
operator|=
name|rrs_sdt
operator|.
name|sdt_plt
operator|+
name|sp
operator|->
name|jmpslot_offset
expr_stmt|;
block|}
block|}
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: %s defined in mysterious way"
argument_list|,
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Set symbol's name */
name|nlp
operator|->
name|nz_strx
operator|=
name|offset
expr_stmt|;
name|strcpy
argument_list|(
name|rrs_strtab
operator|+
name|offset
argument_list|,
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|alias
condition|)
block|{
comment|/* 			 * Write an extra symbol for indirections (possibly 			 * just a dummy). 			 */
name|int
name|t
init|=
operator|(
name|nlp
operator|->
name|nz_type
operator|==
name|N_INDR
operator|+
name|N_EXT
operator|)
decl_stmt|;
name|INCR_NLP
argument_list|(
name|nlp
argument_list|)
expr_stmt|;
name|nlp
operator|->
name|nz_type
operator|=
name|N_UNDF
operator|+
operator|(
name|t
condition|?
name|N_EXT
else|:
literal|0
operator|)
expr_stmt|;
name|nlp
operator|->
name|nz_un
operator|.
name|n_strx
operator|=
name|offset
expr_stmt|;
name|nlp
operator|->
name|nz_value
operator|=
literal|0
expr_stmt|;
name|nlp
operator|->
name|nz_other
operator|=
literal|0
expr_stmt|;
name|nlp
operator|->
name|nz_desc
operator|=
literal|0
expr_stmt|;
name|nlp
operator|->
name|nz_size
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|rrs_strtab
operator|+
name|offset
argument_list|,
name|sp
operator|->
name|alias
operator|->
name|name
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|sp
operator|->
name|alias
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|INCR_NLP
argument_list|(
name|nlp
argument_list|)
expr_stmt|;
block|}
name|END_EACH_SYMBOL
expr_stmt|;
if|if
condition|(
name|MALIGN
argument_list|(
name|offset
argument_list|)
operator|!=
name|rrs_strtab_size
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: "
literal|"inconsistent RRS string table length: %d, expected %d"
argument_list|,
name|offset
argument_list|,
name|rrs_strtab_size
argument_list|)
expr_stmt|;
comment|/* Write the symbol table */
if|if
condition|(
name|rrs_symbol_size
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
condition|)
name|md_swapout_symbols
argument_list|(
name|rrs_symbols
argument_list|,
name|number_of_rrs_symbols
argument_list|)
expr_stmt|;
else|else
name|md_swapout_zsymbols
argument_list|(
name|rrs_symbols
argument_list|,
name|number_of_rrs_symbols
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
name|rrs_symbols
argument_list|,
name|symsize
argument_list|,
literal|1
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
comment|/* Write the strings */
name|mywrite
argument_list|(
name|rrs_strtab
argument_list|,
name|rrs_strtab_size
argument_list|,
literal|1
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
comment|/* 	 * Write the names of the shared objects needed at run-time 	 */
name|pos
operator|=
name|rrs_sdt
operator|.
name|sdt_sods
operator|+
name|number_of_shobjs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sod
argument_list|)
expr_stmt|;
name|sodp
operator|=
operator|(
expr|struct
name|sod
operator|*
operator|)
name|alloca
argument_list|(
name|number_of_shobjs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sod
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|shp
operator|=
name|rrs_shobjs
init|;
name|shp
condition|;
name|i
operator|++
operator|,
name|shp
operator|=
name|shp
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|name
init|=
name|shp
operator|->
name|entry
operator|->
name|local_sym_name
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|number_of_shobjs
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: # of link objects exceeds %d"
argument_list|,
name|number_of_shobjs
argument_list|)
expr_stmt|;
name|sodp
index|[
name|i
index|]
operator|.
name|sod_name
operator|=
name|pos
expr_stmt|;
name|sodp
index|[
name|i
index|]
operator|.
name|sod_major
operator|=
name|shp
operator|->
name|entry
operator|->
name|lib_major
expr_stmt|;
name|sodp
index|[
name|i
index|]
operator|.
name|sod_minor
operator|=
name|shp
operator|->
name|entry
operator|->
name|lib_minor
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'-'
operator|&&
operator|*
operator|(
name|name
operator|+
literal|1
operator|)
operator|==
literal|'l'
condition|)
block|{
name|name
operator|+=
literal|2
expr_stmt|;
name|sodp
index|[
name|i
index|]
operator|.
name|sod_library
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|sodp
index|[
name|i
index|]
operator|.
name|sod_library
operator|=
literal|0
expr_stmt|;
name|sodp
index|[
name|i
index|]
operator|.
name|sod_reserved
operator|=
literal|0
expr_stmt|;
name|pos
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|sodp
index|[
name|i
index|]
operator|.
name|sod_next
operator|=
operator|(
name|i
operator|==
name|number_of_shobjs
operator|-
literal|1
operator|)
condition|?
literal|0
else|:
operator|(
name|rrs_sdt
operator|.
name|sdt_sods
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sod
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|number_of_shobjs
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: "
literal|"# of link objects less then expected %d"
argument_list|,
name|number_of_shobjs
argument_list|)
expr_stmt|;
name|md_swapout_sod
argument_list|(
name|sodp
argument_list|,
name|number_of_shobjs
argument_list|)
expr_stmt|;
name|mywrite
argument_list|(
name|sodp
argument_list|,
name|number_of_shobjs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sod
argument_list|)
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|shp
operator|=
name|rrs_shobjs
init|;
name|shp
condition|;
name|i
operator|++
operator|,
name|shp
operator|=
name|shp
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|name
init|=
name|shp
operator|->
name|entry
operator|->
name|local_sym_name
decl_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'-'
operator|&&
operator|*
operator|(
name|name
operator|+
literal|1
operator|)
operator|==
literal|'l'
condition|)
block|{
name|name
operator|+=
literal|2
expr_stmt|;
block|}
name|mywrite
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|outstream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|write_rrs
parameter_list|()
block|{
comment|/* 	 * First, do some consistency checks on the RRS segment. 	 */
if|if
condition|(
name|rrs_section_type
operator|==
name|RRS_NONE
condition|)
block|{
if|if
condition|(
name|reserved_rrs_relocs
operator|>
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: "
literal|"RRS relocs in static program: %d"
argument_list|,
name|reserved_rrs_relocs
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"rrs_relocs: reserved %d claimed %d discarded %d, gotslots %d jmpslots %d\n"
argument_list|,
name|reserved_rrs_relocs
argument_list|,
name|claimed_rrs_relocs
argument_list|,
name|discarded_rrs_relocs
argument_list|,
name|number_of_gotslots
operator|-
literal|1
argument_list|,
name|number_of_jmpslots
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Final consistency check */
if|if
condition|(
name|claimed_rrs_relocs
operator|+
name|discarded_rrs_relocs
operator|!=
name|reserved_rrs_relocs
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"internal error: "
literal|"reserved relocs(%d) != claimed(%d) + discarded(%d)"
argument_list|,
name|reserved_rrs_relocs
argument_list|,
name|claimed_rrs_relocs
argument_list|,
name|discarded_rrs_relocs
argument_list|)
expr_stmt|;
block|}
comment|/* Write the RRS segments. */
name|write_rrs_text
argument_list|()
expr_stmt|;
name|write_rrs_data
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

