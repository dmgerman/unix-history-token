begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This routine is an exact implementation of Boris Hagelin's cryptographic machine.  See U. S. Patent #2,089,603. */
end_comment

begin_decl_stmt
name|int
name|cagetable
index|[]
block|{
literal|0
operator|,
literal|1
operator|,
literal|1
operator|,
literal|2
operator|,
literal|2
operator|,
literal|3
operator|,
literal|4
operator|,
literal|4
operator|,
literal|5
operator|,
literal|6
operator|,
literal|8
operator|,
literal|8
operator|,
literal|9
operator|,
literal|10
operator|,
literal|12
operator|,
literal|16
operator|,
literal|16
operator|,
literal|17
operator|,
literal|18
operator|,
literal|20
operator|,
literal|24
operator|,
literal|32
operator|,
literal|32
operator|,
literal|33
operator|,
literal|34
operator|,
literal|36
operator|,
literal|40
operator|,
literal|48
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|int
name|warr1
index|[
literal|52
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|warr2
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|warr3
index|[
literal|46
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|warr4
index|[
literal|42
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|warr5
index|[
literal|38
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|warr6
index|[
literal|34
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|wheel1
name|warr1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|wheel2
name|warr2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|wheel3
name|warr3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|wheel4
name|warr4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|wheel5
name|warr5
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|wheel6
name|warr6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|key
index|[
literal|130
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xxx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* subroutine to manufacture a wheel */
end_comment

begin_macro
name|setup
argument_list|(
argument|list
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|list
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
modifier|*
name|lp
decl_stmt|;
name|lp
operator|=
name|list
expr_stmt|;
while|while
condition|(
operator|--
name|n
condition|)
block|{
operator|*
name|lp
operator|=
name|lp
operator|+
literal|2
expr_stmt|;
name|lp
index|[
literal|1
index|]
operator|=
name|getbit
argument_list|()
expr_stmt|;
if|if
condition|(
name|xxx
condition|)
name|putchar
argument_list|(
name|lp
index|[
literal|1
index|]
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|lp
operator|=
name|lp
operator|+
literal|2
expr_stmt|;
block|}
operator|*
name|lp
operator|=
name|list
expr_stmt|;
name|lp
index|[
literal|1
index|]
operator|=
name|getbit
argument_list|()
expr_stmt|;
if|if
condition|(
name|xxx
condition|)
block|{
name|putchar
argument_list|(
name|lp
index|[
literal|1
index|]
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* subroutine to return the next bit from the main routines argument */
end_comment

begin_macro
name|getbit
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|i
operator|,
name|j
expr_stmt|;
name|int
name|b
decl_stmt|;
name|b
operator|=
operator|(
name|key
index|[
name|j
index|]
operator|>>
name|i
operator|)
operator|&
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|++
operator|>
literal|5
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|b
operator|)
return|;
block|}
end_block

begin_function
name|main
parameter_list|(
name|ncooky
parameter_list|,
name|cookyp
parameter_list|)
name|int
name|ncooky
decl_stmt|;
name|char
modifier|*
name|cookyp
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|ip
decl_stmt|,
modifier|*
name|jp
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|int
name|random
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|precious
decl_stmt|;
name|int
name|crypt
decl_stmt|;
name|int
name|cage
index|[
literal|27
index|]
decl_stmt|;
name|xxx
operator|=
literal|0
expr_stmt|;
comment|/* copy input key and pad with clever junk */
name|jp
operator|=
name|key
expr_stmt|;
operator|*
name|jp
operator|++
operator|=
literal|004
expr_stmt|;
operator|*
name|jp
operator|++
operator|=
literal|034
expr_stmt|;
if|if
condition|(
name|ncooky
operator|>
literal|1
condition|)
block|{
while|while
condition|(
operator|*
name|jp
operator|++
operator|=
operator|*
name|cookyp
index|[
literal|1
index|]
operator|++
condition|)
empty_stmt|;
name|jp
operator|--
expr_stmt|;
block|}
name|ip
operator|=
name|key
expr_stmt|;
while|while
condition|(
name|jp
operator|<
name|key
operator|+
literal|128
condition|)
block|{
operator|*
name|jp
operator|=
name|jp
index|[
operator|-
literal|1
index|]
operator|^
operator|*
name|ip
operator|++
expr_stmt|;
name|jp
operator|++
expr_stmt|;
block|}
comment|/* manufacture six wheels of various length */
name|setup
argument_list|(
name|wheel1
argument_list|,
literal|26
argument_list|)
expr_stmt|;
name|setup
argument_list|(
name|wheel2
argument_list|,
literal|25
argument_list|)
expr_stmt|;
name|setup
argument_list|(
name|wheel3
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|setup
argument_list|(
name|wheel4
argument_list|,
literal|21
argument_list|)
expr_stmt|;
name|setup
argument_list|(
name|wheel5
argument_list|,
literal|19
argument_list|)
expr_stmt|;
name|setup
argument_list|(
name|wheel6
argument_list|,
literal|17
argument_list|)
expr_stmt|;
comment|/* set up the cage bars from the key area */
name|jp
operator|=
name|key
expr_stmt|;
name|i
operator|=
literal|27
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|cage
index|[
name|i
index|]
operator|=
name|cagetable
index|[
operator|*
name|jp
operator|++
operator|%
literal|28
index|]
expr_stmt|;
if|if
condition|(
name|xxx
operator|&&
operator|(
name|cage
index|[
name|i
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|putchar
argument_list|(
name|cage
index|[
name|i
index|]
operator|/
literal|8
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|cage
index|[
name|i
index|]
operator|%
literal|8
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|xxx
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* the internal settings are now complete it's time to turn the crank, running the cage bars against the wheel lugs. */
while|while
condition|(
operator|(
name|precious
operator|=
name|getchar
argument_list|()
operator|)
operator|>=
literal|0
condition|)
block|{
name|temp
operator|=
literal|040
operator|*
name|wheel1
index|[
literal|1
index|]
operator|+
literal|020
operator|*
name|wheel2
index|[
literal|1
index|]
operator|+
literal|010
operator|*
name|wheel3
index|[
literal|1
index|]
operator|+
literal|004
operator|*
name|wheel4
index|[
literal|1
index|]
operator|+
literal|002
operator|*
name|wheel5
index|[
literal|1
index|]
operator|+
literal|001
operator|*
name|wheel6
index|[
literal|1
index|]
expr_stmt|;
name|wheel1
operator|=
operator|*
name|wheel1
expr_stmt|;
name|wheel2
operator|=
operator|*
name|wheel2
expr_stmt|;
name|wheel3
operator|=
operator|*
name|wheel3
expr_stmt|;
name|wheel4
operator|=
operator|*
name|wheel4
expr_stmt|;
name|wheel5
operator|=
operator|*
name|wheel5
expr_stmt|;
name|wheel6
operator|=
operator|*
name|wheel6
expr_stmt|;
name|random
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|27
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|random
operator|=
name|random
operator|+
operator|(
operator|(
name|temp
operator|&
name|cage
index|[
name|i
index|]
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
name|random
operator|=
operator|%
literal|26
expr_stmt|;
comment|/* now we have a random number to use to encrypt the input it is done in such a way that the process is its own inverse. */
if|if
condition|(
name|precious
operator|==
literal|'\n'
operator|||
name|precious
operator|==
literal|' '
condition|)
name|crypt
operator|=
name|precious
expr_stmt|;
else|else
block|{
name|crypt
operator|=
operator|(
literal|'a'
operator|+
literal|'z'
operator|-
name|precious
operator|+
name|random
operator|)
operator|%
literal|0400
expr_stmt|;
if|if
condition|(
name|crypt
operator|>=
literal|'a'
operator|&&
name|crypt
operator|<=
literal|'z'
operator|&&
name|precious
operator|>
literal|'z'
condition|)
name|crypt
operator|=
operator|+
literal|26
expr_stmt|;
if|if
condition|(
name|crypt
operator|>
literal|'z'
operator|&&
name|precious
operator|>=
literal|'a'
operator|&
name|precious
operator|<=
literal|'z'
condition|)
name|crypt
operator|=
operator|-
literal|26
expr_stmt|;
if|if
condition|(
name|crypt
operator|==
literal|'\n'
operator|||
name|crypt
operator|==
literal|' '
condition|)
name|crypt
operator|=
name|precious
expr_stmt|;
block|}
name|putchar
argument_list|(
name|crypt
argument_list|)
expr_stmt|;
block|}
name|flush
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_decl_stmt
name|char
name|ibuf
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|obuf
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ibufp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|icnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ocnt
decl_stmt|;
end_decl_stmt

begin_macro
name|getchar
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|icnt
operator|==
literal|0
condition|)
block|{
name|icnt
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|ibuf
argument_list|,
literal|512
argument_list|)
expr_stmt|;
if|if
condition|(
name|icnt
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ibufp
operator|=
name|ibuf
expr_stmt|;
block|}
name|icnt
operator|--
expr_stmt|;
return|return
operator|(
operator|*
name|ibufp
operator|++
operator|&
literal|0377
operator|)
return|;
block|}
end_block

begin_macro
name|putchar
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
name|obuf
index|[
name|ocnt
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|ocnt
operator|>=
literal|512
condition|)
name|flush
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|flush
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|ocnt
operator|>
literal|0
condition|)
name|write
argument_list|(
literal|1
argument_list|,
name|obuf
argument_list|,
name|ocnt
argument_list|)
expr_stmt|;
name|ocnt
operator|=
literal|0
expr_stmt|;
block|}
end_block

end_unit

