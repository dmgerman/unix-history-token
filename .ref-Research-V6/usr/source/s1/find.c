begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* find -- find files in a pathname. 	Use of find is documented in /usr/man/man1/find.1 .  	In addition, find has a secret first arg "+" which 	causes each file name to be printed along with a period 	if the predicates succeed.  */
end_comment

begin_decl_stmt
name|int
name|randlast
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|pathname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|verbose
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|anode
block|{
name|int
function_decl|(
modifier|*
name|F
function_decl|)
parameter_list|()
function_decl|;
name|struct
name|anode
modifier|*
name|L
decl_stmt|,
modifier|*
name|R
decl_stmt|;
block|}
name|node
index|[
literal|100
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|nn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of nodes */
end_comment

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|,
modifier|*
name|path
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|now
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ap
decl_stmt|,
name|ac
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ibuf
block|{
name|int
name|idev
decl_stmt|;
name|int
name|inum
decl_stmt|;
name|int
name|iflags
decl_stmt|;
name|char
name|inl
decl_stmt|;
name|char
name|iuid
decl_stmt|;
name|char
name|igid
decl_stmt|;
name|char
name|isize0
decl_stmt|;
name|char
modifier|*
name|isize
decl_stmt|;
name|int
name|iaddr
index|[
literal|8
index|]
decl_stmt|;
name|int
name|iatime
index|[
literal|2
index|]
decl_stmt|;
name|int
name|imtime
index|[
literal|2
index|]
decl_stmt|;
block|}
name|statb
struct|;
end_struct

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|struct
name|anode
modifier|*
name|exlist
decl_stmt|;
name|int
name|find
parameter_list|()
function_decl|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|ac
operator|=
name|argc
expr_stmt|;
name|av
operator|=
name|argv
expr_stmt|;
name|ap
operator|=
literal|2
expr_stmt|;
name|pathname
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|compstr
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"+"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verbose
operator|++
expr_stmt|;
name|ap
operator|++
expr_stmt|;
name|pathname
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
name|verbose
operator|=
literal|0
expr_stmt|;
name|argv
index|[
name|argc
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"Insufficient args\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|9
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|exlist
operator|=
name|exp
argument_list|()
operator|)
condition|)
block|{
comment|/* parse and compile the arguments */
name|printf
argument_list|(
literal|"Odd usage\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|9
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|<
name|argc
condition|)
block|{
name|printf
argument_list|(
literal|"Missing conjunction\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|9
argument_list|)
expr_stmt|;
block|}
name|descend
argument_list|(
name|pathname
argument_list|,
literal|'f'
argument_list|,
name|find
argument_list|,
name|exlist
argument_list|)
expr_stmt|;
comment|/* to find files that match  */
block|}
end_function

begin_comment
comment|/* compile time functions:  priority is  exp()<e1()<e2()<e3()  */
end_comment

begin_function
name|struct
name|anode
modifier|*
name|exp
parameter_list|()
block|{
comment|/* parse -o ... */
name|int
name|or
parameter_list|()
function_decl|;
name|int
name|p1
decl_stmt|;
name|char
modifier|*
name|na
decl_stmt|;
name|p1
operator|=
name|e1
argument_list|()
comment|/* get left operand */
expr_stmt|;
if|if
condition|(
name|compstr
argument_list|(
name|na
operator|=
name|nxtarg
argument_list|()
argument_list|,
literal|"-o"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|randlast
operator|--
expr_stmt|;
return|return
operator|(
name|mk
argument_list|(
operator|&
name|or
argument_list|,
name|p1
argument_list|,
name|exp
argument_list|()
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|na
operator|!=
literal|0
condition|)
operator|--
name|ap
expr_stmt|;
return|return
operator|(
name|p1
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|anode
modifier|*
name|e1
parameter_list|()
block|{
comment|/* parse -a */
name|int
name|and
parameter_list|()
function_decl|;
name|int
name|p1
decl_stmt|;
name|char
modifier|*
name|na
decl_stmt|;
name|p1
operator|=
name|e2
argument_list|()
expr_stmt|;
if|if
condition|(
name|compstr
argument_list|(
name|na
operator|=
name|nxtarg
argument_list|()
argument_list|,
literal|"-a"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|randlast
operator|--
expr_stmt|;
return|return
operator|(
name|mk
argument_list|(
operator|&
name|and
argument_list|,
name|p1
argument_list|,
name|e1
argument_list|()
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|na
operator|!=
literal|0
condition|)
operator|--
name|ap
expr_stmt|;
return|return
operator|(
name|p1
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|anode
modifier|*
name|e2
parameter_list|()
block|{
comment|/* parse not (!) */
name|int
name|not
parameter_list|()
function_decl|;
name|char
modifier|*
name|na
decl_stmt|;
if|if
condition|(
name|randlast
condition|)
block|{
name|printf
argument_list|(
literal|"operand follows operand.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|9
argument_list|)
expr_stmt|;
block|}
name|randlast
operator|++
expr_stmt|;
if|if
condition|(
name|compstr
argument_list|(
name|na
operator|=
name|nxtarg
argument_list|()
argument_list|,
literal|"!"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|mk
argument_list|(
operator|&
name|not
argument_list|,
name|e3
argument_list|()
argument_list|,
literal|0
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
operator|*
name|na
operator|!=
literal|0
condition|)
operator|--
name|ap
expr_stmt|;
return|return
operator|(
name|e3
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|anode
modifier|*
name|e3
parameter_list|()
block|{
comment|/* parse parens and predicates */
name|int
name|exeq
argument_list|()
decl_stmt|,
name|ok
argument_list|()
decl_stmt|,
name|glob
argument_list|()
decl_stmt|,
name|mtime
argument_list|()
decl_stmt|,
name|atime
argument_list|()
decl_stmt|,
name|user
argument_list|()
decl_stmt|,
name|group
argument_list|()
decl_stmt|,
name|size
argument_list|()
decl_stmt|,
name|perm
argument_list|()
decl_stmt|,
name|links
argument_list|()
decl_stmt|,
name|print
argument_list|()
decl_stmt|,
name|type
argument_list|()
decl_stmt|;
name|int
name|p1
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
name|s
decl_stmt|;
name|a
operator|=
name|nxtarg
argument_list|()
expr_stmt|;
if|if
condition|(
name|compstr
argument_list|(
name|a
argument_list|,
literal|"("
argument_list|)
operator|==
literal|0
condition|)
block|{
name|randlast
operator|--
expr_stmt|;
name|p1
operator|=
name|exp
argument_list|()
expr_stmt|;
name|a
operator|=
name|nxtarg
argument_list|()
expr_stmt|;
if|if
condition|(
name|compstr
argument_list|(
name|a
argument_list|,
literal|")"
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
return|return
operator|(
name|p1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|compstr
argument_list|(
name|a
argument_list|,
literal|"-print"
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|mk
argument_list|(
operator|&
name|print
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
name|b
operator|=
name|nxtarg
argument_list|()
expr_stmt|;
name|s
operator|=
operator|*
name|b
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|'+'
condition|)
name|b
operator|++
expr_stmt|;
if|if
condition|(
name|compstr
argument_list|(
name|a
argument_list|,
literal|"-name"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|mk
argument_list|(
operator|&
name|glob
argument_list|,
name|b
argument_list|,
literal|0
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|compstr
argument_list|(
name|a
argument_list|,
literal|"-mtime"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|mk
argument_list|(
operator|&
name|mtime
argument_list|,
name|atoi
argument_list|(
name|b
argument_list|)
argument_list|,
name|s
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|compstr
argument_list|(
name|a
argument_list|,
literal|"-atime"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|mk
argument_list|(
operator|&
name|atime
argument_list|,
name|atoi
argument_list|(
name|b
argument_list|)
argument_list|,
name|s
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|compstr
argument_list|(
name|a
argument_list|,
literal|"-user"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|getunum
argument_list|(
name|b
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot find user \"%s\"\n"
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|9
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|mk
argument_list|(
operator|&
name|user
argument_list|,
name|i
argument_list|,
name|s
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|compstr
argument_list|(
name|a
argument_list|,
literal|"-group"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|mk
argument_list|(
operator|&
name|group
argument_list|,
name|atoi
argument_list|(
name|b
argument_list|)
argument_list|,
name|s
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|compstr
argument_list|(
name|a
argument_list|,
literal|"-size"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|mk
argument_list|(
operator|&
name|size
argument_list|,
name|atoi
argument_list|(
name|b
argument_list|)
argument_list|,
name|s
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|compstr
argument_list|(
name|a
argument_list|,
literal|"-links"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|mk
argument_list|(
operator|&
name|links
argument_list|,
name|atoi
argument_list|(
name|b
argument_list|)
argument_list|,
name|s
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|compstr
argument_list|(
name|a
argument_list|,
literal|"-perm"
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|b
condition|;
operator|++
name|b
control|)
block|{
if|if
condition|(
operator|*
name|b
operator|==
literal|'-'
condition|)
continue|continue;
name|i
operator|=
operator|<<
literal|3
expr_stmt|;
name|i
operator|=
name|i
operator|+
operator|(
operator|*
name|b
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|mk
argument_list|(
operator|&
name|perm
argument_list|,
name|i
argument_list|,
name|s
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|compstr
argument_list|(
name|a
argument_list|,
literal|"-type"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|s
operator|==
literal|'d'
condition|?
literal|040000
else|:
name|s
operator|==
literal|'b'
condition|?
literal|060000
else|:
name|s
operator|==
literal|'c'
condition|?
literal|020000
else|:
literal|000000
expr_stmt|;
return|return
operator|(
name|mk
argument_list|(
operator|&
name|type
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|compstr
argument_list|(
name|a
argument_list|,
literal|"-exec"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|ap
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|compstr
argument_list|(
name|nxtarg
argument_list|()
argument_list|,
literal|";"
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
return|return
operator|(
name|mk
argument_list|(
operator|&
name|exeq
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|compstr
argument_list|(
name|a
argument_list|,
literal|"-ok"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|ap
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|compstr
argument_list|(
name|nxtarg
argument_list|()
argument_list|,
literal|";"
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
return|return
operator|(
name|mk
argument_list|(
operator|&
name|ok
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
name|err
label|:
name|printf
argument_list|(
literal|"Bad option: \"%s\" \"%s\"\n"
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|9
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|anode
modifier|*
name|mk
parameter_list|(
name|f
parameter_list|,
name|l
parameter_list|,
name|r
parameter_list|)
name|struct
name|anode
modifier|*
name|l
decl_stmt|,
decl|*
name|r
decl_stmt|;
end_function

begin_block
block|{
comment|/*make an expression node*/
name|node
index|[
name|nn
index|]
operator|.
name|F
operator|=
name|f
expr_stmt|;
name|node
index|[
name|nn
index|]
operator|.
name|L
operator|=
name|l
expr_stmt|;
name|node
index|[
name|nn
index|]
operator|.
name|R
operator|=
name|r
expr_stmt|;
return|return
operator|(
operator|&
operator|(
name|node
index|[
name|nn
operator|++
index|]
operator|)
operator|)
return|;
block|}
end_block

begin_macro
name|nxtarg
argument_list|()
end_macro

begin_block
block|{
comment|/* get next arg from command line */
if|if
condition|(
name|ap
operator|>=
name|ac
condition|)
return|return
operator|(
literal|""
operator|)
return|;
return|return
operator|(
name|av
index|[
name|ap
operator|++
index|]
operator|)
return|;
block|}
end_block

begin_macro
name|find
argument_list|(
argument|exlist
argument_list|,
argument|fullname
argument_list|)
end_macro

begin_comment
comment|/* execute predicat list with current file */
end_comment

begin_decl_stmt
name|struct
name|anode
modifier|*
name|exlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fullname
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|path
operator|=
name|fullname
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|fullname
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|fullname
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
name|fname
operator|=
operator|&
name|fullname
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|i
operator|=
call|(
modifier|*
name|exlist
operator|->
name|F
call|)
argument_list|(
name|exlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
if|if
condition|(
name|i
condition|)
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* execution time functions */
end_comment

begin_macro
name|and
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|anode
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
operator|(
call|(
modifier|*
name|p
operator|->
name|L
operator|->
name|F
call|)
argument_list|(
name|p
operator|->
name|L
argument_list|)
operator|)
operator|&&
operator|(
call|(
modifier|*
name|p
operator|->
name|R
operator|->
name|F
call|)
argument_list|(
name|p
operator|->
name|R
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|or
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|anode
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
operator|(
call|(
modifier|*
name|p
operator|->
name|L
operator|->
name|F
call|)
argument_list|(
name|p
operator|->
name|L
argument_list|)
operator|)
operator|||
operator|(
call|(
modifier|*
name|p
operator|->
name|R
operator|->
name|F
call|)
argument_list|(
name|p
operator|->
name|R
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|not
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|anode
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
operator|!
operator|(
call|(
modifier|*
name|p
operator|->
name|L
operator|->
name|F
call|)
argument_list|(
name|p
operator|->
name|L
argument_list|)
operator|)
operator|)
return|;
block|}
end_block

begin_macro
name|glob
argument_list|(
argument|p
argument_list|)
end_macro

begin_struct
struct|struct
block|{
name|int
name|f
decl_stmt|;
name|char
modifier|*
name|pat
decl_stmt|;
block|}
modifier|*
name|p
struct|;
end_struct

begin_block
block|{
return|return
operator|(
name|gmatch
argument_list|(
name|fname
argument_list|,
name|p
operator|->
name|pat
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|print
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|mtime
argument_list|(
argument|p
argument_list|)
end_macro

begin_struct
struct|struct
block|{
name|int
name|f
decl_stmt|,
name|t
decl_stmt|,
name|s
decl_stmt|;
block|}
modifier|*
name|p
struct|;
end_struct

begin_block
block|{
return|return
operator|(
name|scomp
argument_list|(
operator|(
name|now
index|[
literal|0
index|]
operator|-
name|statb
operator|.
name|imtime
index|[
literal|0
index|]
operator|)
operator|*
literal|3
operator|/
literal|4
argument_list|,
name|p
operator|->
name|t
argument_list|,
name|p
operator|->
name|s
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|atime
argument_list|(
argument|p
argument_list|)
end_macro

begin_struct
struct|struct
block|{
name|int
name|f
decl_stmt|,
name|t
decl_stmt|,
name|s
decl_stmt|;
block|}
modifier|*
name|p
struct|;
end_struct

begin_block
block|{
return|return
operator|(
name|scomp
argument_list|(
operator|(
name|now
index|[
literal|0
index|]
operator|-
name|statb
operator|.
name|iatime
index|[
literal|0
index|]
operator|)
operator|*
literal|3
operator|/
literal|4
argument_list|,
name|p
operator|->
name|t
argument_list|,
name|p
operator|->
name|s
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|user
argument_list|(
argument|p
argument_list|)
end_macro

begin_struct
struct|struct
block|{
name|int
name|f
decl_stmt|,
name|u
decl_stmt|,
name|s
decl_stmt|;
block|}
modifier|*
name|p
struct|;
end_struct

begin_block
block|{
return|return
operator|(
name|scomp
argument_list|(
name|statb
operator|.
name|iuid
argument_list|,
name|p
operator|->
name|u
argument_list|,
name|p
operator|->
name|s
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|group
argument_list|(
argument|p
argument_list|)
end_macro

begin_struct
struct|struct
block|{
name|int
name|f
decl_stmt|,
name|u
decl_stmt|;
block|}
modifier|*
name|p
struct|;
end_struct

begin_block
block|{
return|return
operator|(
name|p
operator|->
name|u
operator|==
name|statb
operator|.
name|igid
operator|)
return|;
block|}
end_block

begin_macro
name|links
argument_list|(
argument|p
argument_list|)
end_macro

begin_struct
struct|struct
block|{
name|int
name|f
decl_stmt|,
name|link
decl_stmt|,
name|s
decl_stmt|;
block|}
modifier|*
name|p
struct|;
end_struct

begin_block
block|{
return|return
operator|(
name|scomp
argument_list|(
name|statb
operator|.
name|inl
argument_list|,
name|p
operator|->
name|link
argument_list|,
name|p
operator|->
name|s
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|size
argument_list|(
argument|p
argument_list|)
end_macro

begin_struct
struct|struct
block|{
name|int
name|f
decl_stmt|,
name|sz
decl_stmt|,
name|s
decl_stmt|;
block|}
modifier|*
name|p
struct|;
end_struct

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|statb
operator|.
name|isize0
operator|<<
literal|7
expr_stmt|;
name|i
operator|=
name|i
operator||
operator|(
operator|(
name|statb
operator|.
name|isize
operator|>>
literal|9
operator|)
operator|&
literal|0177
operator|)
expr_stmt|;
return|return
operator|(
name|scomp
argument_list|(
name|i
argument_list|,
name|p
operator|->
name|sz
argument_list|,
name|p
operator|->
name|s
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|perm
argument_list|(
argument|p
argument_list|)
end_macro

begin_struct
struct|struct
block|{
name|int
name|f
decl_stmt|,
name|per
decl_stmt|,
name|s
decl_stmt|;
block|}
modifier|*
name|p
struct|;
end_struct

begin_block
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
operator|(
name|p
operator|->
name|s
operator|==
literal|'-'
operator|)
condition|?
name|p
operator|->
name|per
else|:
literal|03777
expr_stmt|;
comment|/* '-' means only arg bits */
return|return
operator|(
operator|(
name|statb
operator|.
name|iflags
operator|&
name|i
operator|&
literal|017777
operator|)
operator|==
name|p
operator|->
name|per
operator|)
return|;
block|}
end_block

begin_macro
name|type
argument_list|(
argument|p
argument_list|)
end_macro

begin_struct
struct|struct
block|{
name|int
name|f
decl_stmt|,
name|per
decl_stmt|,
name|s
decl_stmt|;
block|}
modifier|*
name|p
struct|;
end_struct

begin_block
block|{
return|return
operator|(
operator|(
name|statb
operator|.
name|iflags
operator|&
literal|060000
operator|)
operator|==
name|p
operator|->
name|per
operator|)
return|;
block|}
end_block

begin_macro
name|exeq
argument_list|(
argument|p
argument_list|)
end_macro

begin_struct
struct|struct
block|{
name|int
name|f
decl_stmt|,
name|com
decl_stmt|;
block|}
modifier|*
name|p
struct|;
end_struct

begin_block
block|{
return|return
operator|(
name|doex
argument_list|(
name|p
operator|->
name|com
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|ok
argument_list|(
argument|p
argument_list|)
end_macro

begin_struct
struct|struct
block|{
name|int
name|f
decl_stmt|,
name|com
decl_stmt|;
block|}
modifier|*
name|p
struct|;
end_struct

begin_block
block|{
name|char
name|c
decl_stmt|;
name|int
name|yes
decl_stmt|;
name|yes
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s ... %s ...? "
argument_list|,
name|av
index|[
name|p
operator|->
name|com
index|]
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'y'
condition|)
name|yes
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|yes
condition|)
return|return
operator|(
name|doex
argument_list|(
name|p
operator|->
name|com
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* support functions */
end_comment

begin_macro
name|scomp
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* funny signed compare */
if|if
condition|(
name|s
operator|==
literal|'+'
condition|)
return|return
operator|(
name|a
operator|>
name|b
operator|)
return|;
if|if
condition|(
name|s
operator|==
literal|'-'
condition|)
return|return
operator|(
name|a
operator|<
operator|(
name|b
operator|*
operator|-
literal|1
operator|)
operator|)
return|;
return|return
operator|(
name|a
operator|==
name|b
operator|)
return|;
block|}
end_block

begin_macro
name|doex
argument_list|(
argument|com
argument_list|)
end_macro

begin_block
block|{
name|int
name|ccode
decl_stmt|;
name|int
name|np
decl_stmt|,
name|i
decl_stmt|,
name|c
decl_stmt|;
name|char
modifier|*
name|nargv
index|[
literal|50
index|]
decl_stmt|,
modifier|*
name|ncom
decl_stmt|,
modifier|*
name|na
decl_stmt|;
name|ccode
operator|=
name|np
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|na
operator|=
name|av
index|[
name|com
operator|++
index|]
condition|)
block|{
if|if
condition|(
name|compstr
argument_list|(
name|na
argument_list|,
literal|";"
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|compstr
argument_list|(
name|na
argument_list|,
literal|"{}"
argument_list|)
operator|==
literal|0
condition|)
name|nargv
index|[
name|np
operator|++
index|]
operator|=
name|path
expr_stmt|;
else|else
name|nargv
index|[
name|np
operator|++
index|]
operator|=
name|na
expr_stmt|;
block|}
name|nargv
index|[
name|np
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|np
operator|==
literal|0
condition|)
return|return
operator|(
literal|9
operator|)
return|;
if|if
condition|(
name|fork
argument_list|()
condition|)
comment|/*parent*/
name|wait
argument_list|(
operator|&
name|ccode
argument_list|)
expr_stmt|;
else|else
block|{
comment|/*child*/
name|execv
argument_list|(
name|nargv
index|[
literal|0
index|]
argument_list|,
name|nargv
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|ncom
operator|=
literal|"/usr/bin/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
expr_stmt|;
while|while
condition|(
name|c
operator|=
name|nargv
index|[
literal|0
index|]
index|[
name|i
index|]
condition|)
block|{
name|ncom
index|[
literal|9
operator|+
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|ncom
index|[
literal|9
operator|+
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|execv
argument_list|(
name|ncom
operator|+
literal|4
argument_list|,
name|nargv
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|ncom
argument_list|,
name|nargv
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|9
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ccode
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|char
name|fin
index|[
literal|518
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|getunum
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* find username in /etc/passwd& return num. */
name|int
name|i
decl_stmt|;
name|char
name|str
index|[
literal|20
index|]
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
name|c
decl_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
name|fin
index|[
literal|0
index|]
operator|=
name|open
argument_list|(
literal|"/etc/passwd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|=
name|getchar
argument_list|()
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|sp
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|sp
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|':'
condition|)
if|if
condition|(
operator|!
operator|*
name|sp
operator|++
condition|)
goto|goto
name|RET
goto|;
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|compstr
argument_list|(
name|str
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|':'
condition|)
if|if
condition|(
operator|!
name|c
condition|)
goto|goto
name|RET
goto|;
name|sp
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|sp
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|':'
condition|)
name|sp
operator|++
expr_stmt|;
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
name|atoi
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|RET
label|:
name|close
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|fin
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|compstr
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
name|s1
index|[]
decl_stmt|,
name|s2
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* compare strings: */
specifier|register
name|char
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|;
name|c1
operator|=
name|s1
expr_stmt|;
name|c2
operator|=
name|s2
expr_stmt|;
while|while
condition|(
operator|*
name|c1
operator|==
operator|*
name|c2
condition|)
if|if
condition|(
operator|*
name|c1
operator|++
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* s1 == s2 */
else|else
name|c2
operator|++
expr_stmt|;
return|return
operator|(
operator|*
name|c1
operator|>
operator|*
name|c2
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|int
name|descend
argument_list|(
name|name
argument_list|,
name|goal
argument_list|,
name|func
argument_list|,
name|arg
argument_list|)
name|int
argument_list|(
operator|*
name|func
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|,
name|goal
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|dir
comment|/* open directory */
decl_stmt|,
name|offset
comment|/* in directory */
decl_stmt|;
name|int
name|dsize
decl_stmt|,
name|top
decl_stmt|;
struct|struct
block|{
name|int
name|dinode
decl_stmt|;
name|char
name|dname
index|[
literal|14
index|]
decl_stmt|;
block|}
name|dentry
index|[
literal|32
index|]
struct|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|char
name|aname
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"--bad status %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	if((statb.iflags&060000)!=040000){ /*not a directory*/
comment|/* 		if(goal=='f'||goal=='b') /* search goal for files */
comment|/* 			(*func)(arg,name); 		return(1); 	} else  if(goal=='d' || goal=='b') /* search goal is directories */
comment|/* 			(*func)(arg,name); */
call|(
modifier|*
name|func
call|)
argument_list|(
name|arg
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|statb
operator|.
name|iflags
operator|&
literal|060000
operator|)
operator|!=
literal|040000
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|top
operator|=
name|statb
operator|.
name|isize
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|top
condition|;
name|offset
operator|=
operator|+
literal|512
control|)
block|{
comment|/* each block */
name|dsize
operator|=
literal|512
operator|<
operator|(
name|top
operator|-
name|offset
operator|)
condition|?
literal|512
else|:
operator|(
name|top
operator|-
name|offset
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|dir
operator|=
name|open
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"--cannot open %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|offset
condition|)
name|seek
argument_list|(
name|dir
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|dir
argument_list|,
operator|&
name|dentry
argument_list|,
name|dsize
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"--cannot read %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|close
argument_list|(
name|dir
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|dsize
operator|>>
literal|4
operator|)
condition|;
operator|++
name|i
control|)
block|{
comment|/* each dir. entry */
if|if
condition|(
name|dentry
index|[
name|i
index|]
operator|.
name|dinode
operator|==
literal|0
operator|||
name|compstr
argument_list|(
name|dentry
index|[
name|i
index|]
operator|.
name|dname
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|compstr
argument_list|(
name|dentry
index|[
name|i
index|]
operator|.
name|dname
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dentry
index|[
name|i
index|]
operator|.
name|dinode
operator|==
operator|-
literal|1
condition|)
break|break;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|aname
index|[
name|j
index|]
operator|=
name|name
index|[
name|j
index|]
condition|;
operator|++
name|j
control|)
empty_stmt|;
if|if
condition|(
name|aname
index|[
name|j
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|aname
index|[
name|j
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
operator|(
name|aname
index|[
name|j
operator|++
index|]
operator|=
name|dentry
index|[
name|i
index|]
operator|.
name|dname
index|[
name|k
index|]
operator|)
operator|&&
name|k
operator|<
literal|13
condition|;
operator|++
name|k
control|)
empty_stmt|;
name|aname
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|descend
argument_list|(
name|aname
argument_list|,
name|goal
argument_list|,
name|func
argument_list|,
name|arg
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"--%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|gmatch
argument_list|(
argument|s
argument_list|,
argument|p
argument_list|)
end_macro

begin_comment
comment|/* string match as in glob */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
operator|&&
operator|*
name|p
operator|!=
literal|'.'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|amatch
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|amatch
argument_list|(
argument|s
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|cc
decl_stmt|,
name|scc
decl_stmt|,
name|k
decl_stmt|;
name|int
name|c
decl_stmt|,
name|lc
decl_stmt|;
name|scc
operator|=
operator|*
name|s
expr_stmt|;
name|lc
operator|=
literal|077777
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
operator|*
name|p
condition|)
block|{
case|case
literal|'['
case|:
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cc
operator|=
operator|*
operator|++
name|p
condition|)
block|{
switch|switch
condition|(
name|cc
condition|)
block|{
case|case
literal|']'
case|:
if|if
condition|(
name|k
condition|)
return|return
operator|(
name|amatch
argument_list|(
operator|++
name|s
argument_list|,
operator|++
name|p
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'-'
case|:
name|k
operator|=
operator||
name|lc
operator|<=
name|scc
operator|&
name|scc
operator|<=
operator|(
name|cc
operator|=
name|p
index|[
literal|1
index|]
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|scc
operator|==
operator|(
name|lc
operator|=
name|cc
operator|)
condition|)
name|k
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'?'
case|:
name|caseq
label|:
if|if
condition|(
name|scc
condition|)
return|return
operator|(
name|amatch
argument_list|(
operator|++
name|s
argument_list|,
operator|++
name|p
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'*'
case|:
return|return
operator|(
name|umatch
argument_list|(
name|s
argument_list|,
operator|++
name|p
argument_list|)
operator|)
return|;
case|case
literal|0
case|:
return|return
operator|(
operator|!
name|scc
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
name|scc
condition|)
goto|goto
name|caseq
goto|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|umatch
argument_list|(
argument|s
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
while|while
condition|(
operator|*
name|s
condition|)
if|if
condition|(
name|amatch
argument_list|(
name|s
operator|++
argument_list|,
name|p
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

