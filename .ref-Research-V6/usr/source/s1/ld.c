begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*  *  link editor  */
end_comment

begin_define
define|#
directive|define
name|SIGINT
value|2
end_define

begin_define
define|#
directive|define
name|ARCMAGIC
value|0177555
end_define

begin_define
define|#
directive|define
name|FMAGIC
value|0407
end_define

begin_define
define|#
directive|define
name|NMAGIC
value|0410
end_define

begin_define
define|#
directive|define
name|IMAGIC
value|0411
end_define

begin_define
define|#
directive|define
name|EXTERN
value|040
end_define

begin_define
define|#
directive|define
name|UNDEF
value|00
end_define

begin_define
define|#
directive|define
name|ABS
value|01
end_define

begin_define
define|#
directive|define
name|TEXT
value|02
end_define

begin_define
define|#
directive|define
name|DATA
value|03
end_define

begin_define
define|#
directive|define
name|BSS
value|04
end_define

begin_define
define|#
directive|define
name|COMM
value|05
end_define

begin_comment
comment|/* internal use only */
end_comment

begin_define
define|#
directive|define
name|RABS
value|00
end_define

begin_define
define|#
directive|define
name|RTEXT
value|02
end_define

begin_define
define|#
directive|define
name|RDATA
value|04
end_define

begin_define
define|#
directive|define
name|RBSS
value|06
end_define

begin_define
define|#
directive|define
name|REXT
value|010
end_define

begin_define
define|#
directive|define
name|RELFLG
value|01
end_define

begin_define
define|#
directive|define
name|NROUT
value|256
end_define

begin_define
define|#
directive|define
name|NSYM
value|501
end_define

begin_define
define|#
directive|define
name|NSYMPR
value|500
end_define

begin_define
define|#
directive|define
name|RONLY
value|0400
end_define

begin_expr_stmt
name|char
name|premeof
index|[]
literal|"Premature EOF on %s"
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|page
block|{
name|int
name|nuser
decl_stmt|;
name|int
name|bno
decl_stmt|;
name|int
name|nibuf
decl_stmt|;
name|int
name|buff
index|[
literal|256
index|]
decl_stmt|;
block|}
name|page
index|[
literal|2
index|]
struct|;
end_struct

begin_struct
struct|struct
block|{
name|int
name|nuser
decl_stmt|;
name|int
name|bno
decl_stmt|;
block|}
name|fpage
struct|;
end_struct

begin_struct
struct|struct
name|stream
block|{
name|int
modifier|*
name|ptr
decl_stmt|;
name|int
name|bno
decl_stmt|;
name|int
name|nibuf
decl_stmt|;
name|int
name|size
decl_stmt|;
name|struct
name|page
modifier|*
name|pno
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|stream
name|text
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|stream
name|reloc
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|archdr
block|{
name|char
name|aname
index|[
literal|8
index|]
decl_stmt|;
name|int
name|atime
index|[
literal|2
index|]
decl_stmt|;
name|char
name|auid
decl_stmt|,
name|amode
decl_stmt|;
name|int
name|asize
decl_stmt|;
block|}
name|archdr
struct|;
end_struct

begin_struct
struct|struct
name|filhdr
block|{
name|int
name|fmagic
decl_stmt|;
name|int
name|tsize
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|int
name|bsize
decl_stmt|;
name|int
name|ssize
decl_stmt|;
name|int
name|entry
decl_stmt|;
name|int
name|pad
decl_stmt|;
name|int
name|relflg
decl_stmt|;
block|}
name|filhdr
struct|;
end_struct

begin_struct
struct|struct
name|liblist
block|{
name|int
name|off
decl_stmt|;
name|int
name|bno
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|liblist
name|liblist
index|[
name|NROUT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|liblist
modifier|*
name|libp
block|{
operator|&
name|liblist
index|[
literal|0
index|]
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_struct
struct|struct
name|symbol
block|{
name|char
name|sname
index|[
literal|8
index|]
decl_stmt|;
name|char
name|stype
decl_stmt|;
name|char
name|spad
decl_stmt|;
name|int
name|svalue
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|symbol
name|cursym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symbol
name|symtab
index|[
name|NSYM
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symbol
modifier|*
name|hshtab
index|[
name|NSYM
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symbol
modifier|*
name|symp
block|{
name|symtab
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|struct
name|symbol
modifier|*
modifier|*
name|local
index|[
name|NSYMPR
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symbol
modifier|*
name|p_etext
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symbol
modifier|*
name|p_edata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symbol
modifier|*
name|p_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* discard local symbols */
end_comment

begin_decl_stmt
name|int
name|Xflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* discard locals starting with 'L' */
end_comment

begin_decl_stmt
name|int
name|rflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* preserve relocation bits, don't define common */
end_comment

begin_decl_stmt
name|int
name|arflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* original copy of rflag */
end_comment

begin_decl_stmt
name|int
name|sflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* discard all symbols */
end_comment

begin_decl_stmt
name|int
name|nflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pure procedure */
end_comment

begin_decl_stmt
name|int
name|dflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* define common even with rflag */
end_comment

begin_decl_stmt
name|int
name|iflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* I/D space separated */
end_comment

begin_decl_stmt
name|int
name|infil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|filname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ssize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nsym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|torigin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dorigin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|borigin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ctrel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cdrel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cbrel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|errlev
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|int
name|delarg
literal|4
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|char
name|tfname
index|[]
literal|"/tmp/lxyyyyy"
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|toutb
index|[
literal|259
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|doutb
index|[
literal|259
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|troutb
index|[
literal|259
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|droutb
index|[
literal|259
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|soutb
index|[
literal|259
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|symbol
modifier|*
modifier|*
name|lookup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|symbol
modifier|*
modifier|*
name|slookup
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|extern
name|int
name|delexit
parameter_list|()
function_decl|;
specifier|register
name|c
expr_stmt|;
specifier|register
name|char
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
name|struct
name|symbol
modifier|*
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
operator|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
literal|1
argument_list|)
operator|&
literal|01
operator|)
operator|==
literal|0
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|delexit
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|p
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<
name|argc
condition|;
name|c
operator|++
control|)
block|{
name|filname
operator|=
literal|0
expr_stmt|;
name|ap
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ap
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|ap
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'u'
case|:
if|if
condition|(
operator|++
name|c
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"Bad 'use'"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|hp
operator|=
name|slookup
argument_list|(
operator|*
name|p
operator|++
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|hp
operator|=
name|symp
expr_stmt|;
name|enter
argument_list|()
expr_stmt|;
block|}
continue|continue;
case|case
literal|'l'
case|:
break|break;
case|case
literal|'x'
case|:
name|xflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'X'
case|:
name|Xflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
name|rflag
operator|++
expr_stmt|;
name|arflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
name|sflag
operator|++
expr_stmt|;
name|xflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'n'
case|:
name|nflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
name|dflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'i'
case|:
name|iflag
operator|++
expr_stmt|;
continue|continue;
block|}
name|load1arg
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|infil
argument_list|)
expr_stmt|;
block|}
name|middle
argument_list|()
expr_stmt|;
name|setupout
argument_list|()
expr_stmt|;
name|p
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
name|libp
operator|=
name|liblist
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<
name|argc
condition|;
name|c
operator|++
control|)
block|{
name|ap
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ap
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|ap
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'u'
case|:
operator|++
name|c
expr_stmt|;
operator|++
name|p
expr_stmt|;
default|default:
continue|continue;
case|case
literal|'l'
case|:
break|break;
block|}
name|load2arg
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|infil
argument_list|)
expr_stmt|;
block|}
name|finishout
argument_list|()
expr_stmt|;
block|}
end_function

begin_macro
name|load1arg
argument_list|(
argument|acp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|acp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|noff
operator|,
name|nbno
expr_stmt|;
name|cp
operator|=
name|acp
expr_stmt|;
if|if
condition|(
name|getfile
argument_list|(
name|cp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|load1
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|nbno
operator|=
literal|0
expr_stmt|;
name|noff
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|nbno
argument_list|,
name|noff
argument_list|,
sizeof|sizeof
name|archdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|.
name|size
operator|<=
literal|0
condition|)
block|{
name|libp
operator|->
name|bno
operator|=
operator|-
literal|1
expr_stmt|;
name|libp
operator|++
expr_stmt|;
return|return;
block|}
name|mget
argument_list|(
operator|&
name|archdr
argument_list|,
sizeof|sizeof
name|archdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|load1
argument_list|(
literal|1
argument_list|,
name|nbno
argument_list|,
name|noff
operator|+
operator|(
sizeof|sizeof
name|archdr
operator|)
operator|/
literal|2
argument_list|)
condition|)
block|{
name|libp
operator|->
name|bno
operator|=
name|nbno
expr_stmt|;
name|libp
operator|->
name|off
operator|=
name|noff
expr_stmt|;
name|libp
operator|++
expr_stmt|;
block|}
name|noff
operator|=
operator|+
operator|(
name|archdr
operator|.
name|asize
operator|+
sizeof|sizeof
name|archdr
operator|)
operator|>>
literal|1
expr_stmt|;
name|nbno
operator|=
operator|+
operator|(
name|noff
operator|>>
literal|8
operator|)
operator|&
literal|0377
expr_stmt|;
name|noff
operator|=
operator|&
literal|0377
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|load1
argument_list|(
argument|libflg
argument_list|,
argument|bno
argument_list|,
argument|off
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sp
decl_stmt|,
modifier|*
modifier|*
name|hp
decl_stmt|,
modifier|*
modifier|*
modifier|*
name|cp
decl_stmt|;
name|struct
name|symbol
modifier|*
name|ssymp
decl_stmt|;
name|int
name|ndef
decl_stmt|,
name|nloc
decl_stmt|;
name|readhdr
argument_list|(
name|bno
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|ctrel
operator|=
name|tsize
expr_stmt|;
name|cdrel
operator|=
operator|+
name|dsize
expr_stmt|;
name|cbrel
operator|=
operator|+
name|bsize
expr_stmt|;
name|ndef
operator|=
literal|0
expr_stmt|;
name|nloc
operator|=
sizeof|sizeof
name|cursym
expr_stmt|;
name|cp
operator|=
name|local
expr_stmt|;
name|ssymp
operator|=
name|symp
expr_stmt|;
if|if
condition|(
operator|(
name|filhdr
operator|.
name|relflg
operator|&
name|RELFLG
operator|)
operator|==
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|"No relocation bits"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|off
operator|=
operator|+
operator|(
sizeof|sizeof
name|filhdr
operator|)
operator|/
literal|2
operator|+
name|filhdr
operator|.
name|tsize
operator|+
name|filhdr
operator|.
name|dsize
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|bno
argument_list|,
name|off
argument_list|,
name|filhdr
operator|.
name|ssize
argument_list|)
expr_stmt|;
while|while
condition|(
name|text
operator|.
name|size
operator|>
literal|0
condition|)
block|{
name|mget
argument_list|(
operator|&
name|cursym
argument_list|,
sizeof|sizeof
name|cursym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cursym
operator|.
name|stype
operator|&
name|EXTERN
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|Xflag
operator|==
literal|0
operator|||
name|cursym
operator|.
name|sname
index|[
literal|0
index|]
operator|!=
literal|'L'
condition|)
name|nloc
operator|=
operator|+
sizeof|sizeof
name|cursym
expr_stmt|;
continue|continue;
block|}
name|symreloc
argument_list|()
expr_stmt|;
name|hp
operator|=
name|lookup
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
operator|*
name|hp
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|hp
operator|=
name|enter
argument_list|()
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|hp
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sp
operator|->
name|stype
operator|!=
name|EXTERN
operator|+
name|UNDEF
condition|)
continue|continue;
if|if
condition|(
name|cursym
operator|.
name|stype
operator|==
name|EXTERN
operator|+
name|UNDEF
condition|)
block|{
if|if
condition|(
name|cursym
operator|.
name|svalue
operator|>
name|sp
operator|->
name|svalue
condition|)
name|sp
operator|->
name|svalue
operator|=
name|cursym
operator|.
name|svalue
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sp
operator|->
name|svalue
operator|!=
literal|0
operator|&&
name|cursym
operator|.
name|stype
operator|==
name|EXTERN
operator|+
name|TEXT
condition|)
continue|continue;
name|ndef
operator|++
expr_stmt|;
name|sp
operator|->
name|stype
operator|=
name|cursym
operator|.
name|stype
expr_stmt|;
name|sp
operator|->
name|svalue
operator|=
name|cursym
operator|.
name|svalue
expr_stmt|;
block|}
if|if
condition|(
name|libflg
operator|==
literal|0
operator|||
name|ndef
condition|)
block|{
name|tsize
operator|=
operator|+
name|filhdr
operator|.
name|tsize
expr_stmt|;
name|dsize
operator|=
operator|+
name|filhdr
operator|.
name|dsize
expr_stmt|;
name|bsize
operator|=
operator|+
name|filhdr
operator|.
name|bsize
expr_stmt|;
name|ssize
operator|=
operator|+
name|nloc
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*  * No symbols defined by this library member.  * Rip out the hash table entries and reset the symbol table.  */
name|symp
operator|=
name|ssymp
expr_stmt|;
while|while
condition|(
name|cp
operator|>
name|local
condition|)
operator|*
operator|*
operator|--
name|cp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|middle
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sp
decl_stmt|;
specifier|register
name|t
operator|,
name|csize
expr_stmt|;
name|int
name|nund
decl_stmt|,
name|corigin
decl_stmt|;
name|p_etext
operator|=
operator|*
name|slookup
argument_list|(
literal|"_etext"
argument_list|)
expr_stmt|;
name|p_edata
operator|=
operator|*
name|slookup
argument_list|(
literal|"_edata"
argument_list|)
expr_stmt|;
name|p_end
operator|=
operator|*
name|slookup
argument_list|(
literal|"_end"
argument_list|)
expr_stmt|;
comment|/*  * If there are any undefined symbols, save the relocation bits.  */
if|if
condition|(
name|rflag
operator|==
literal|0
condition|)
for|for
control|(
name|sp
operator|=
name|symtab
init|;
name|sp
operator|<
name|symp
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|sp
operator|->
name|stype
operator|==
name|EXTERN
operator|+
name|UNDEF
operator|&&
name|sp
operator|->
name|svalue
operator|==
literal|0
operator|&&
name|sp
operator|!=
name|p_end
operator|&&
name|sp
operator|!=
name|p_edata
operator|&&
name|sp
operator|!=
name|p_etext
condition|)
block|{
name|rflag
operator|++
expr_stmt|;
name|dflag
operator|=
literal|0
expr_stmt|;
name|nflag
operator|=
literal|0
expr_stmt|;
name|iflag
operator|=
literal|0
expr_stmt|;
name|sflag
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/*  * Assign common locations.  */
name|csize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dflag
operator|||
name|rflag
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|sp
operator|=
name|symtab
init|;
name|sp
operator|<
name|symp
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|sp
operator|->
name|stype
operator|==
name|EXTERN
operator|+
name|UNDEF
operator|&&
operator|(
name|t
operator|=
name|sp
operator|->
name|svalue
operator|)
operator|!=
literal|0
condition|)
block|{
name|t
operator|=
operator|(
name|t
operator|+
literal|1
operator|)
operator|&
operator|~
literal|01
expr_stmt|;
name|sp
operator|->
name|svalue
operator|=
name|csize
expr_stmt|;
name|sp
operator|->
name|stype
operator|=
name|EXTERN
operator|+
name|COMM
expr_stmt|;
name|csize
operator|=
operator|+
name|t
expr_stmt|;
block|}
if|if
condition|(
name|p_etext
operator|&&
name|p_etext
operator|->
name|stype
operator|==
name|EXTERN
operator|+
name|UNDEF
condition|)
block|{
name|p_etext
operator|->
name|stype
operator|=
name|EXTERN
operator|+
name|TEXT
expr_stmt|;
name|p_etext
operator|->
name|svalue
operator|=
name|tsize
expr_stmt|;
block|}
if|if
condition|(
name|p_edata
operator|&&
name|p_edata
operator|->
name|stype
operator|==
name|EXTERN
operator|+
name|UNDEF
condition|)
block|{
name|p_edata
operator|->
name|stype
operator|=
name|EXTERN
operator|+
name|DATA
expr_stmt|;
name|p_edata
operator|->
name|svalue
operator|=
name|dsize
expr_stmt|;
block|}
if|if
condition|(
name|p_end
operator|&&
name|p_end
operator|->
name|stype
operator|==
name|EXTERN
operator|+
name|UNDEF
condition|)
block|{
name|p_end
operator|->
name|stype
operator|=
name|EXTERN
operator|+
name|BSS
expr_stmt|;
name|p_end
operator|->
name|svalue
operator|=
name|bsize
expr_stmt|;
block|}
block|}
comment|/*  * Now set symbols to their final value  */
if|if
condition|(
name|nflag
operator|||
name|iflag
condition|)
name|tsize
operator|=
operator|(
name|tsize
operator|+
literal|077
operator|)
operator|&
operator|~
literal|077
expr_stmt|;
name|dorigin
operator|=
name|tsize
expr_stmt|;
if|if
condition|(
name|nflag
condition|)
name|dorigin
operator|=
operator|(
name|tsize
operator|+
literal|017777
operator|)
operator|&
operator|~
literal|017777
expr_stmt|;
if|if
condition|(
name|iflag
condition|)
name|dorigin
operator|=
literal|0
expr_stmt|;
name|corigin
operator|=
name|dorigin
operator|+
name|dsize
expr_stmt|;
name|borigin
operator|=
name|corigin
operator|+
name|csize
expr_stmt|;
name|nund
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|symtab
init|;
name|sp
operator|<
name|symp
condition|;
name|sp
operator|++
control|)
switch|switch
condition|(
name|sp
operator|->
name|stype
condition|)
block|{
case|case
name|EXTERN
operator|+
name|UNDEF
case|:
name|errlev
operator|=
operator||
literal|01
expr_stmt|;
if|if
condition|(
name|arflag
operator|==
literal|0
operator|&&
name|sp
operator|->
name|svalue
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nund
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Undefined:\n"
argument_list|)
expr_stmt|;
name|nund
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"%.8s\n"
argument_list|,
name|sp
operator|->
name|sname
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|EXTERN
operator|+
name|ABS
case|:
default|default:
continue|continue;
case|case
name|EXTERN
operator|+
name|TEXT
case|:
name|sp
operator|->
name|svalue
operator|=
operator|+
name|torigin
expr_stmt|;
continue|continue;
case|case
name|EXTERN
operator|+
name|DATA
case|:
name|sp
operator|->
name|svalue
operator|=
operator|+
name|dorigin
expr_stmt|;
continue|continue;
case|case
name|EXTERN
operator|+
name|BSS
case|:
name|sp
operator|->
name|svalue
operator|=
operator|+
name|borigin
expr_stmt|;
continue|continue;
case|case
name|EXTERN
operator|+
name|COMM
case|:
name|sp
operator|->
name|stype
operator|=
name|EXTERN
operator|+
name|BSS
expr_stmt|;
name|sp
operator|->
name|svalue
operator|=
operator|+
name|corigin
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sflag
operator|||
name|xflag
condition|)
name|ssize
operator|=
literal|0
expr_stmt|;
name|bsize
operator|=
operator|+
name|csize
expr_stmt|;
name|nsym
operator|=
name|ssize
operator|/
operator|(
sizeof|sizeof
name|cursym
operator|)
expr_stmt|;
block|}
end_block

begin_macro
name|setupout
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|pid
expr_stmt|;
if|if
condition|(
operator|(
name|toutb
index|[
literal|0
index|]
operator|=
name|creat
argument_list|(
literal|"l.out"
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"Can't create l.out"
argument_list|)
expr_stmt|;
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|tfname
index|[
literal|12
index|]
init|;
name|p
operator|>
operator|&
name|tfname
index|[
literal|7
index|]
condition|;
control|)
block|{
operator|*
operator|--
name|p
operator|=
operator|(
name|pid
operator|&
literal|07
operator|)
operator|+
literal|'0'
expr_stmt|;
name|pid
operator|=
operator|>>
literal|3
expr_stmt|;
block|}
name|tcreat
argument_list|(
name|doutb
argument_list|,
literal|'a'
argument_list|)
expr_stmt|;
if|if
condition|(
name|sflag
operator|==
literal|0
operator|||
name|xflag
operator|==
literal|0
condition|)
name|tcreat
argument_list|(
name|soutb
argument_list|,
literal|'b'
argument_list|)
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
block|{
name|tcreat
argument_list|(
name|troutb
argument_list|,
literal|'c'
argument_list|)
expr_stmt|;
name|tcreat
argument_list|(
name|droutb
argument_list|,
literal|'d'
argument_list|)
expr_stmt|;
block|}
name|filhdr
operator|.
name|fmagic
operator|=
name|FMAGIC
expr_stmt|;
if|if
condition|(
name|nflag
condition|)
name|filhdr
operator|.
name|fmagic
operator|=
name|NMAGIC
expr_stmt|;
if|if
condition|(
name|iflag
condition|)
name|filhdr
operator|.
name|fmagic
operator|=
name|IMAGIC
expr_stmt|;
name|filhdr
operator|.
name|tsize
operator|=
name|tsize
expr_stmt|;
name|filhdr
operator|.
name|dsize
operator|=
name|dsize
expr_stmt|;
name|filhdr
operator|.
name|bsize
operator|=
name|bsize
expr_stmt|;
name|filhdr
operator|.
name|ssize
operator|=
name|sflag
condition|?
literal|0
else|:
operator|(
name|ssize
operator|+
operator|(
sizeof|sizeof
name|cursym
operator|)
operator|*
operator|(
name|symp
operator|-
name|symtab
operator|)
operator|)
expr_stmt|;
name|filhdr
operator|.
name|entry
operator|=
literal|0
expr_stmt|;
name|filhdr
operator|.
name|pad
operator|=
literal|0
expr_stmt|;
name|filhdr
operator|.
name|relflg
operator|=
operator|(
name|rflag
operator|==
literal|0
operator|)
expr_stmt|;
name|mput
argument_list|(
name|toutb
argument_list|,
operator|&
name|filhdr
argument_list|,
sizeof|sizeof
name|filhdr
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|tcreat
argument_list|(
argument|buf
argument_list|,
argument|letter
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tfname
index|[
literal|6
index|]
operator|=
name|letter
expr_stmt|;
if|if
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|=
name|creat
argument_list|(
name|tfname
argument_list|,
name|RONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"Can't create temp"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|load2arg
argument_list|(
argument|acp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|acp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|liblist
modifier|*
name|lp
decl_stmt|;
name|cp
operator|=
name|acp
expr_stmt|;
if|if
condition|(
name|getfile
argument_list|(
name|cp
argument_list|)
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|cp
condition|)
name|cp
operator|++
expr_stmt|;
while|while
condition|(
name|cp
operator|>=
name|acp
operator|&&
operator|*
operator|--
name|cp
operator|!=
literal|'/'
condition|)
empty_stmt|;
name|mkfsym
argument_list|(
operator|++
name|cp
argument_list|)
expr_stmt|;
name|load2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|lp
operator|=
name|libp
init|;
name|lp
operator|->
name|bno
operator|!=
operator|-
literal|1
condition|;
name|lp
operator|++
control|)
block|{
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|lp
operator|->
name|bno
argument_list|,
name|lp
operator|->
name|off
argument_list|,
sizeof|sizeof
name|archdr
argument_list|)
expr_stmt|;
name|mget
argument_list|(
operator|&
name|archdr
argument_list|,
sizeof|sizeof
name|archdr
argument_list|)
expr_stmt|;
name|mkfsym
argument_list|(
name|archdr
operator|.
name|aname
argument_list|)
expr_stmt|;
name|load2
argument_list|(
name|lp
operator|->
name|bno
argument_list|,
name|lp
operator|->
name|off
operator|+
operator|(
sizeof|sizeof
name|archdr
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
name|libp
operator|=
operator|++
name|lp
expr_stmt|;
block|}
end_block

begin_macro
name|load2
argument_list|(
argument|bno
argument_list|,
argument|off
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
modifier|*
name|lp
decl_stmt|,
name|symno
decl_stmt|;
name|readhdr
argument_list|(
name|bno
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|ctrel
operator|=
name|torigin
expr_stmt|;
name|cdrel
operator|=
operator|+
name|dorigin
expr_stmt|;
name|cbrel
operator|=
operator|+
name|borigin
expr_stmt|;
comment|/*  * Reread the symbol table, recording the numbering  * of symbols for fixing external references.  */
name|lp
operator|=
name|local
expr_stmt|;
name|symno
operator|=
operator|-
literal|1
expr_stmt|;
name|off
operator|=
operator|+
operator|(
sizeof|sizeof
name|filhdr
operator|)
operator|/
literal|2
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|bno
argument_list|,
name|off
operator|+
name|filhdr
operator|.
name|tsize
operator|+
name|filhdr
operator|.
name|dsize
argument_list|,
name|filhdr
operator|.
name|ssize
argument_list|)
expr_stmt|;
while|while
condition|(
name|text
operator|.
name|size
operator|>
literal|0
condition|)
block|{
name|symno
operator|++
expr_stmt|;
name|mget
argument_list|(
operator|&
name|cursym
argument_list|,
sizeof|sizeof
name|cursym
argument_list|)
expr_stmt|;
name|symreloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|cursym
operator|.
name|stype
operator|&
name|EXTERN
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|sflag
operator|&&
operator|!
name|xflag
operator|&&
operator|(
operator|!
name|Xflag
operator|||
name|cursym
operator|.
name|sname
index|[
literal|0
index|]
operator|!=
literal|'L'
operator|)
condition|)
name|mput
argument_list|(
name|soutb
argument_list|,
operator|&
name|cursym
argument_list|,
sizeof|sizeof
name|cursym
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|sp
operator|=
operator|*
name|lookup
argument_list|()
operator|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"internal error: symbol not found"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursym
operator|.
name|stype
operator|==
name|EXTERN
operator|+
name|UNDEF
condition|)
block|{
if|if
condition|(
name|lp
operator|>=
operator|&
name|local
index|[
name|NSYMPR
index|]
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"Local symbol overflow"
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
name|symno
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
name|sp
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cursym
operator|.
name|stype
operator|!=
name|sp
operator|->
name|stype
operator|||
name|cursym
operator|.
name|svalue
operator|!=
name|sp
operator|->
name|svalue
condition|)
block|{
name|printf
argument_list|(
literal|"%.8s: "
argument_list|,
name|cursym
operator|.
name|sname
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|"Multiply defined"
argument_list|)
expr_stmt|;
block|}
block|}
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|bno
argument_list|,
name|off
argument_list|,
name|filhdr
operator|.
name|tsize
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|reloc
argument_list|,
name|bno
argument_list|,
name|off
operator|+
operator|(
name|filhdr
operator|.
name|tsize
operator|+
name|filhdr
operator|.
name|dsize
operator|)
operator|/
literal|2
argument_list|,
name|filhdr
operator|.
name|tsize
argument_list|)
expr_stmt|;
name|load2td
argument_list|(
name|lp
argument_list|,
name|ctrel
argument_list|,
name|toutb
argument_list|,
name|troutb
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|bno
argument_list|,
name|off
operator|+
operator|(
name|filhdr
operator|.
name|tsize
operator|/
literal|2
operator|)
argument_list|,
name|filhdr
operator|.
name|dsize
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|reloc
argument_list|,
name|bno
argument_list|,
name|off
operator|+
name|filhdr
operator|.
name|tsize
operator|+
operator|(
name|filhdr
operator|.
name|dsize
operator|/
literal|2
operator|)
argument_list|,
name|filhdr
operator|.
name|dsize
argument_list|)
expr_stmt|;
name|load2td
argument_list|(
name|lp
argument_list|,
name|cdrel
argument_list|,
name|doutb
argument_list|,
name|droutb
argument_list|)
expr_stmt|;
name|torigin
operator|=
operator|+
name|filhdr
operator|.
name|tsize
expr_stmt|;
name|dorigin
operator|=
operator|+
name|filhdr
operator|.
name|dsize
expr_stmt|;
name|borigin
operator|=
operator|+
name|filhdr
operator|.
name|bsize
expr_stmt|;
block|}
end_block

begin_macro
name|load2td
argument_list|(
argument|lp
argument_list|,
argument|creloc
argument_list|,
argument|b1
argument_list|,
argument|b2
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|r
operator|,
name|t
expr_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sp
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 	 * The pickup code is copied from "get" for speed. 	 */
if|if
condition|(
operator|--
name|text
operator|.
name|size
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|text
operator|.
name|size
operator|<
literal|0
condition|)
break|break;
name|text
operator|.
name|size
operator|++
expr_stmt|;
name|t
operator|=
name|get
argument_list|(
operator|&
name|text
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|--
name|text
operator|.
name|nibuf
operator|<
literal|0
condition|)
block|{
name|text
operator|.
name|nibuf
operator|++
expr_stmt|;
name|text
operator|.
name|size
operator|++
expr_stmt|;
name|t
operator|=
name|get
argument_list|(
operator|&
name|text
argument_list|)
expr_stmt|;
block|}
else|else
name|t
operator|=
operator|*
name|text
operator|.
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|reloc
operator|.
name|size
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|reloc
operator|.
name|size
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"Relocation error"
argument_list|)
expr_stmt|;
name|reloc
operator|.
name|size
operator|++
expr_stmt|;
name|r
operator|=
name|get
argument_list|(
operator|&
name|reloc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|--
name|reloc
operator|.
name|nibuf
operator|<
literal|0
condition|)
block|{
name|reloc
operator|.
name|nibuf
operator|++
expr_stmt|;
name|reloc
operator|.
name|size
operator|++
expr_stmt|;
name|r
operator|=
name|get
argument_list|(
operator|&
name|reloc
argument_list|)
expr_stmt|;
block|}
else|else
name|r
operator|=
operator|*
name|reloc
operator|.
name|ptr
operator|++
expr_stmt|;
switch|switch
condition|(
name|r
operator|&
literal|016
condition|)
block|{
case|case
name|RTEXT
case|:
name|t
operator|=
operator|+
name|ctrel
expr_stmt|;
break|break;
case|case
name|RDATA
case|:
name|t
operator|=
operator|+
name|cdrel
expr_stmt|;
break|break;
case|case
name|RBSS
case|:
name|t
operator|=
operator|+
name|cbrel
expr_stmt|;
break|break;
case|case
name|REXT
case|:
name|sp
operator|=
name|lookloc
argument_list|(
name|lp
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|stype
operator|==
name|EXTERN
operator|+
name|UNDEF
condition|)
block|{
name|r
operator|=
operator|(
name|r
operator|&
literal|01
operator|)
operator|+
operator|(
operator|(
name|nsym
operator|+
operator|(
name|sp
operator|-
name|symtab
operator|)
operator|)
operator|<<
literal|4
operator|)
operator|+
name|REXT
expr_stmt|;
break|break;
block|}
name|t
operator|=
operator|+
name|sp
operator|->
name|svalue
expr_stmt|;
name|r
operator|=
operator|(
name|r
operator|&
literal|01
operator|)
operator|+
operator|(
operator|(
name|sp
operator|->
name|stype
operator|-
operator|(
name|EXTERN
operator|+
name|ABS
operator|)
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|r
operator|&
literal|01
condition|)
name|t
operator|=
operator|-
name|creloc
expr_stmt|;
name|putw
argument_list|(
name|t
argument_list|,
name|b1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
name|putw
argument_list|(
name|r
argument_list|,
name|b2
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|finishout
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|n
operator|,
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|nflag
operator|||
name|iflag
condition|)
block|{
name|n
operator|=
name|torigin
expr_stmt|;
while|while
condition|(
name|n
operator|&
literal|077
condition|)
block|{
name|n
operator|=
operator|+
literal|2
expr_stmt|;
name|putw
argument_list|(
literal|0
argument_list|,
name|toutb
argument_list|)
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
name|putw
argument_list|(
literal|0
argument_list|,
name|troutb
argument_list|)
expr_stmt|;
block|}
block|}
name|copy
argument_list|(
name|doutb
argument_list|,
literal|'a'
argument_list|)
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
block|{
name|copy
argument_list|(
name|troutb
argument_list|,
literal|'c'
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|droutb
argument_list|,
literal|'d'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sflag
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|xflag
operator|==
literal|0
condition|)
name|copy
argument_list|(
name|soutb
argument_list|,
literal|'b'
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|symtab
init|;
name|p
operator|<
name|symp
condition|;
control|)
name|putw
argument_list|(
operator|*
name|p
operator|++
argument_list|,
name|toutb
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|toutb
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|toutb
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
literal|"a.out"
argument_list|)
expr_stmt|;
name|link
argument_list|(
literal|"l.out"
argument_list|,
literal|"a.out"
argument_list|)
expr_stmt|;
name|delarg
operator|=
name|errlev
expr_stmt|;
name|delexit
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|delexit
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|c
expr_stmt|;
name|unlink
argument_list|(
literal|"l.out"
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|'a'
init|;
name|c
operator|<=
literal|'d'
condition|;
name|c
operator|++
control|)
block|{
name|tfname
index|[
literal|6
index|]
operator|=
name|c
expr_stmt|;
name|unlink
argument_list|(
name|tfname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|delarg
operator|==
literal|0
condition|)
name|chmod
argument_list|(
literal|"a.out"
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|delarg
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|copy
argument_list|(
argument|buf
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|f
operator|,
operator|*
name|p
operator|,
name|n
expr_stmt|;
name|fflush
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|tfname
index|[
literal|6
index|]
operator|=
name|c
expr_stmt|;
name|f
operator|=
name|open
argument_list|(
name|tfname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|f
argument_list|,
name|doutb
argument_list|,
literal|512
argument_list|)
operator|)
operator|>
literal|1
condition|)
block|{
name|n
operator|=
operator|>>
literal|1
expr_stmt|;
name|p
operator|=
name|doutb
expr_stmt|;
do|do
name|putw
argument_list|(
operator|*
name|p
operator|++
argument_list|,
name|toutb
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|n
condition|)
do|;
block|}
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|mkfsym
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|sflag
operator|||
name|xflag
condition|)
return|return;
name|cp8c
argument_list|(
name|s
argument_list|,
name|cursym
operator|.
name|sname
argument_list|)
expr_stmt|;
name|cursym
operator|.
name|stype
operator|=
literal|037
expr_stmt|;
name|cursym
operator|.
name|svalue
operator|=
name|torigin
expr_stmt|;
name|mput
argument_list|(
name|soutb
argument_list|,
operator|&
name|cursym
argument_list|,
sizeof|sizeof
name|cursym
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|mget
argument_list|(
argument|aloc
argument_list|,
argument|an
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|aloc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
operator|*
name|loc
operator|,
name|n
expr_stmt|;
specifier|register
operator|*
name|p
expr_stmt|;
name|n
operator|=
name|an
expr_stmt|;
name|n
operator|=
operator|>>
literal|1
expr_stmt|;
name|loc
operator|=
name|aloc
expr_stmt|;
if|if
condition|(
operator|(
name|text
operator|.
name|nibuf
operator|=
operator|-
name|n
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|text
operator|.
name|size
operator|=
operator|-
name|n
operator|)
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|text
operator|.
name|ptr
expr_stmt|;
do|do
operator|*
name|loc
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|n
condition|)
do|;
name|text
operator|.
name|ptr
operator|=
name|p
expr_stmt|;
return|return;
block|}
else|else
name|text
operator|.
name|size
operator|=
operator|+
name|n
expr_stmt|;
block|}
name|text
operator|.
name|nibuf
operator|=
operator|+
name|n
expr_stmt|;
do|do
block|{
operator|*
name|loc
operator|++
operator|=
name|get
argument_list|(
operator|&
name|text
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|n
condition|)
do|;
block|}
end_block

begin_macro
name|mput
argument_list|(
argument|buf
argument_list|,
argument|aloc
argument_list|,
argument|an
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|aloc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
operator|*
name|loc
expr_stmt|;
specifier|register
name|n
expr_stmt|;
name|loc
operator|=
name|aloc
expr_stmt|;
name|n
operator|=
name|an
operator|>>
literal|1
expr_stmt|;
do|do
block|{
name|putw
argument_list|(
operator|*
name|loc
operator|++
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|n
condition|)
do|;
block|}
end_block

begin_macro
name|dseek
argument_list|(
argument|asp
argument_list|,
argument|ab
argument_list|,
argument|o
argument_list|,
argument|s
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|stream
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|page
modifier|*
name|p
decl_stmt|;
specifier|register
name|b
expr_stmt|;
name|int
name|n
decl_stmt|;
name|sp
operator|=
name|asp
expr_stmt|;
name|b
operator|=
name|ab
operator|+
operator|(
operator|(
name|o
operator|>>
literal|8
operator|)
operator|&
literal|0377
operator|)
expr_stmt|;
name|o
operator|=
operator|&
literal|0377
expr_stmt|;
operator|--
name|sp
operator|->
name|pno
operator|->
name|nuser
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|&
name|page
index|[
literal|0
index|]
operator|)
operator|->
name|bno
operator|!=
name|b
operator|&&
operator|(
name|p
operator|=
operator|&
name|page
index|[
literal|1
index|]
operator|)
operator|->
name|bno
operator|!=
name|b
condition|)
if|if
condition|(
name|p
operator|->
name|nuser
operator|==
literal|0
operator|||
operator|(
name|p
operator|=
operator|&
name|page
index|[
literal|0
index|]
operator|)
operator|->
name|nuser
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|page
index|[
literal|0
index|]
operator|.
name|nuser
operator|==
literal|0
operator|&&
name|page
index|[
literal|1
index|]
operator|.
name|nuser
operator|==
literal|0
condition|)
if|if
condition|(
name|page
index|[
literal|0
index|]
operator|.
name|bno
operator|<
name|page
index|[
literal|1
index|]
operator|.
name|bno
condition|)
name|p
operator|=
operator|&
name|page
index|[
literal|0
index|]
expr_stmt|;
name|p
operator|->
name|bno
operator|=
name|b
expr_stmt|;
name|seek
argument_list|(
name|infil
argument_list|,
name|b
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|infil
argument_list|,
name|p
operator|->
name|buff
argument_list|,
literal|512
argument_list|)
operator|>>
literal|1
operator|)
operator|<
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|nibuf
operator|=
name|n
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|"No pages"
argument_list|)
expr_stmt|;
operator|++
name|p
operator|->
name|nuser
expr_stmt|;
name|sp
operator|->
name|bno
operator|=
name|b
expr_stmt|;
name|sp
operator|->
name|pno
operator|=
name|p
expr_stmt|;
name|sp
operator|->
name|ptr
operator|=
name|p
operator|->
name|buff
operator|+
name|o
expr_stmt|;
if|if
condition|(
name|s
operator|!=
operator|-
literal|1
condition|)
name|sp
operator|->
name|size
operator|=
operator|(
name|s
operator|>>
literal|1
operator|)
operator|&
literal|077777
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|nibuf
operator|=
name|p
operator|->
name|nibuf
operator|-
name|o
operator|)
operator|<=
literal|0
condition|)
name|sp
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|get
argument_list|(
argument|asp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|stream
modifier|*
name|asp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|stream
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|asp
expr_stmt|;
if|if
condition|(
operator|--
name|sp
operator|->
name|nibuf
operator|<
literal|0
condition|)
block|{
name|dseek
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|bno
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|--
name|sp
operator|->
name|nibuf
expr_stmt|;
block|}
if|if
condition|(
operator|--
name|sp
operator|->
name|size
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|size
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|premeof
argument_list|)
expr_stmt|;
operator|++
name|fpage
operator|.
name|nuser
expr_stmt|;
operator|--
name|sp
operator|->
name|pno
operator|->
name|nuser
expr_stmt|;
name|sp
operator|->
name|pno
operator|=
operator|&
name|fpage
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|sp
operator|->
name|ptr
operator|++
operator|)
return|;
block|}
end_block

begin_macro
name|getfile
argument_list|(
argument|acp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|acp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|c
expr_stmt|;
name|cp
operator|=
name|acp
expr_stmt|;
name|archdr
operator|.
name|aname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'l'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|cp
index|[
literal|2
index|]
operator|)
operator|==
literal|'\0'
condition|)
name|c
operator|=
literal|'a'
expr_stmt|;
name|cp
operator|=
literal|"/lib/lib?.a"
expr_stmt|;
name|cp
index|[
literal|8
index|]
operator|=
name|c
expr_stmt|;
block|}
name|filname
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|infil
operator|=
name|open
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"cannot open"
argument_list|)
expr_stmt|;
name|page
index|[
literal|0
index|]
operator|.
name|bno
operator|=
name|page
index|[
literal|1
index|]
operator|.
name|bno
operator|=
operator|-
literal|1
expr_stmt|;
name|page
index|[
literal|0
index|]
operator|.
name|nuser
operator|=
name|page
index|[
literal|1
index|]
operator|.
name|nuser
operator|=
literal|0
expr_stmt|;
name|text
operator|.
name|pno
operator|=
name|reloc
operator|.
name|pno
operator|=
operator|&
name|fpage
expr_stmt|;
name|fpage
operator|.
name|nuser
operator|=
literal|2
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|.
name|size
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|premeof
argument_list|)
expr_stmt|;
return|return
operator|(
name|get
argument_list|(
operator|&
name|text
argument_list|)
operator|==
name|ARCMAGIC
operator|)
return|;
block|}
end_block

begin_function
name|struct
name|symbol
modifier|*
modifier|*
name|lookup
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
modifier|*
name|hp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|cursym
operator|.
name|sname
init|;
name|cp
operator|<
operator|&
name|cursym
operator|.
name|sname
index|[
literal|8
index|]
condition|;
control|)
name|i
operator|=
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
operator|*
name|cp
operator|++
expr_stmt|;
for|for
control|(
name|hp
operator|=
operator|&
name|hshtab
index|[
operator|(
name|i
operator|&
literal|077777
operator|)
operator|%
name|NSYM
operator|+
literal|2
index|]
init|;
operator|*
name|hp
operator|!=
literal|0
condition|;
control|)
block|{
name|cp1
operator|=
operator|(
operator|*
name|hp
operator|)
operator|->
name|sname
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|cursym
operator|.
name|sname
init|;
name|cp
operator|<
operator|&
name|cursym
operator|.
name|sname
index|[
literal|8
index|]
condition|;
control|)
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
operator|*
name|cp1
operator|++
condition|)
goto|goto
name|no
goto|;
break|break;
name|no
label|:
if|if
condition|(
operator|++
name|hp
operator|>=
operator|&
name|hshtab
index|[
name|NSYM
operator|+
literal|2
index|]
condition|)
name|hp
operator|=
name|hshtab
expr_stmt|;
block|}
return|return
operator|(
name|hp
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|symbol
modifier|*
modifier|*
name|slookup
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|cp8c
argument_list|(
name|s
argument_list|,
name|cursym
operator|.
name|sname
argument_list|)
expr_stmt|;
name|cursym
operator|.
name|stype
operator|=
name|EXTERN
operator|+
name|UNDEF
expr_stmt|;
name|cursym
operator|.
name|svalue
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|lookup
argument_list|()
operator|)
return|;
block|}
end_function

begin_macro
name|enter
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|symp
operator|)
operator|>=
operator|&
name|symtab
index|[
name|NSYM
index|]
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"Symbol table overflow"
argument_list|)
expr_stmt|;
name|cp8c
argument_list|(
name|cursym
operator|.
name|sname
argument_list|,
name|sp
operator|->
name|sname
argument_list|)
expr_stmt|;
name|sp
operator|->
name|stype
operator|=
name|cursym
operator|.
name|stype
expr_stmt|;
name|sp
operator|->
name|svalue
operator|=
name|cursym
operator|.
name|svalue
expr_stmt|;
name|symp
operator|++
expr_stmt|;
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_block

begin_macro
name|symreloc
argument_list|()
end_macro

begin_block
block|{
switch|switch
condition|(
name|cursym
operator|.
name|stype
condition|)
block|{
case|case
name|TEXT
case|:
case|case
name|EXTERN
operator|+
name|TEXT
case|:
name|cursym
operator|.
name|svalue
operator|=
operator|+
name|ctrel
expr_stmt|;
return|return;
case|case
name|DATA
case|:
case|case
name|EXTERN
operator|+
name|DATA
case|:
name|cursym
operator|.
name|svalue
operator|=
operator|+
name|cdrel
expr_stmt|;
return|return;
case|case
name|BSS
case|:
case|case
name|EXTERN
operator|+
name|BSS
case|:
name|cursym
operator|.
name|svalue
operator|=
operator|+
name|cbrel
expr_stmt|;
return|return;
case|case
name|EXTERN
operator|+
name|UNDEF
case|:
return|return;
block|}
if|if
condition|(
name|cursym
operator|.
name|stype
operator|&
name|EXTERN
condition|)
name|cursym
operator|.
name|stype
operator|=
name|EXTERN
operator|+
name|ABS
expr_stmt|;
block|}
end_block

begin_macro
name|error
argument_list|(
argument|n
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|filname
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|filname
argument_list|)
expr_stmt|;
if|if
condition|(
name|archdr
operator|.
name|aname
index|[
literal|0
index|]
condition|)
name|printf
argument_list|(
literal|"(%.8s)"
argument_list|,
name|archdr
operator|.
name|aname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|delexit
argument_list|()
expr_stmt|;
name|errlev
operator|=
literal|2
expr_stmt|;
block|}
end_block

begin_macro
name|lookloc
argument_list|(
argument|alp
argument_list|,
argument|r
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
modifier|*
name|clp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
specifier|register
name|sn
expr_stmt|;
name|lp
operator|=
name|alp
expr_stmt|;
name|sn
operator|=
operator|(
name|r
operator|>>
literal|4
operator|)
operator|&
literal|07777
expr_stmt|;
for|for
control|(
name|clp
operator|=
name|local
init|;
name|clp
operator|<
name|lp
condition|;
name|clp
operator|=
operator|+
literal|2
control|)
if|if
condition|(
name|clp
index|[
literal|0
index|]
operator|==
name|sn
condition|)
return|return
operator|(
name|clp
index|[
literal|1
index|]
operator|)
return|;
name|error
argument_list|(
literal|1
argument_list|,
literal|"Local symbol botch"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|readhdr
argument_list|(
argument|bno
argument_list|,
argument|off
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|st
operator|,
name|sd
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|bno
argument_list|,
name|off
argument_list|,
sizeof|sizeof
name|filhdr
argument_list|)
expr_stmt|;
name|mget
argument_list|(
operator|&
name|filhdr
argument_list|,
sizeof|sizeof
name|filhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|filhdr
operator|.
name|fmagic
operator|!=
name|FMAGIC
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"Bad format"
argument_list|)
expr_stmt|;
name|st
operator|=
operator|(
name|filhdr
operator|.
name|tsize
operator|+
literal|01
operator|)
operator|&
operator|~
literal|01
expr_stmt|;
name|filhdr
operator|.
name|tsize
operator|=
name|st
expr_stmt|;
name|cdrel
operator|=
operator|-
name|st
expr_stmt|;
name|sd
operator|=
operator|(
name|filhdr
operator|.
name|dsize
operator|+
literal|01
operator|)
operator|&
operator|~
literal|01
expr_stmt|;
name|cbrel
operator|=
operator|-
operator|(
name|st
operator|+
name|sd
operator|)
expr_stmt|;
name|filhdr
operator|.
name|bsize
operator|=
operator|(
name|filhdr
operator|.
name|bsize
operator|+
literal|01
operator|)
operator|&
operator|~
literal|01
expr_stmt|;
block|}
end_block

begin_macro
name|cp8c
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|f
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|te
decl_stmt|;
name|f
operator|=
name|from
expr_stmt|;
name|t
operator|=
name|to
expr_stmt|;
name|te
operator|=
name|t
operator|+
literal|8
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|t
operator|++
operator|=
operator|*
name|f
operator|++
operator|)
operator|&&
name|t
operator|<
name|te
condition|)
empty_stmt|;
while|while
condition|(
name|t
operator|<
name|te
condition|)
operator|*
name|t
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_block

end_unit

