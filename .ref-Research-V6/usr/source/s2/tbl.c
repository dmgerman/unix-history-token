begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_define
define|#
directive|define
name|ever
value|(;;)
end_define

begin_define
define|#
directive|define
name|MAXCHS
value|2000
end_define

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
name|line
index|[
literal|200
index|]
decl_stmt|;
specifier|extern
name|int
name|cin
decl_stmt|;
specifier|extern
name|char
modifier|*
name|cspace
decl_stmt|;
name|cspace
operator|=
name|getvec
argument_list|(
name|MAXCHS
operator|+
literal|100
argument_list|)
expr_stmt|;
for|for ever
block|{
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|match
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-ms"
argument_list|)
condition|)
operator|*
name|argv
operator|=
literal|"/usr/lib/tmac.s"
expr_stmt|;
name|cin
operator|=
name|copen
argument_list|(
operator|*
name|argv
argument_list|,
literal|'r'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cin
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|2
argument_list|,
literal|"where is input file %s\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|cexit
argument_list|()
expr_stmt|;
block|}
block|}
while|while
condition|(
name|gets
argument_list|(
name|line
argument_list|)
condition|)
if|if
condition|(
name|match
argument_list|(
name|line
argument_list|,
literal|".TS"
argument_list|)
condition|)
name|tableput
argument_list|()
expr_stmt|;
else|else
name|puts
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
break|break;
block|}
name|cexit
argument_list|()
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MAXCOL
value|35
end_define

begin_define
define|#
directive|define
name|MAXLIN
value|220
end_define

begin_define
define|#
directive|define
name|ONELINE
value|250
end_define

begin_decl_stmt
name|char
modifier|*
name|tabentry
index|[
name|MAXLIN
index|]
index|[
name|MAXCOL
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|extra
index|[
name|MAXCHS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cspace
decl_stmt|,
modifier|*
name|cstore
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|exstore
name|extra
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sep
index|[
name|MAXCOL
index|]
decl_stmt|,
name|dwide
index|[
name|MAXCOL
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|instead
index|[
name|MAXLIN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|newtab
index|[
name|MAXLIN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|style
index|[
name|MAXCOL
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|tableput
argument_list|()
end_macro

begin_block
block|{
comment|/* read input, write output, make tables on the way */
name|char
name|st
index|[
name|ONELINE
index|]
decl_stmt|,
modifier|*
name|format
decl_stmt|;
name|int
name|ilin
decl_stmt|,
name|nlin
decl_stmt|,
name|icol
decl_stmt|,
name|ncol
decl_stmt|,
name|k
decl_stmt|,
name|ch
decl_stmt|,
name|ws
decl_stmt|,
name|cs
decl_stmt|,
name|ns
decl_stmt|;
name|int
name|maxchnge
decl_stmt|,
name|ct
decl_stmt|;
name|printf
argument_list|(
literal|".TS\n"
argument_list|)
expr_stmt|;
comment|/* get command line */
name|cstore
operator|=
name|cspace
expr_stmt|;
name|exstore
operator|=
name|extra
expr_stmt|;
name|ncol
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ilin
operator|=
literal|0
init|;
name|ilin
operator|<
name|MAXLIN
condition|;
name|ilin
operator|++
control|)
name|newtab
index|[
name|ilin
index|]
operator|=
literal|0
expr_stmt|;
name|gets
argument_list|(
name|st
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|ONELINE
operator|&&
name|st
index|[
name|k
index|]
operator|!=
literal|'\0'
condition|;
name|k
operator|++
control|)
if|if
condition|(
operator|!
name|space
argument_list|(
name|st
index|[
name|k
index|]
argument_list|)
condition|)
block|{
name|style
index|[
name|ncol
index|]
operator|=
name|st
operator|+
name|k
expr_stmt|;
name|dwide
index|[
name|ncol
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|letter
argument_list|(
name|st
index|[
name|k
index|]
argument_list|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|st
index|[
name|k
index|]
operator|==
literal|'n'
operator|||
name|st
index|[
name|k
index|]
operator|==
literal|'N'
operator|)
operator|&&
operator|!
name|dwide
index|[
name|ncol
index|]
condition|)
block|{
name|dwide
index|[
name|ncol
index|]
operator|=
literal|1
expr_stmt|;
name|sep
index|[
name|ncol
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|style
index|[
name|ncol
index|]
operator|=
name|style
index|[
name|ncol
operator|-
literal|1
index|]
expr_stmt|;
name|dwide
index|[
name|ncol
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|digit
argument_list|(
name|st
index|[
name|k
index|]
argument_list|)
condition|)
name|sep
index|[
name|ncol
index|]
operator|=
name|numb
argument_list|(
name|st
operator|+
name|k
argument_list|)
expr_stmt|;
else|else
name|sep
index|[
name|ncol
index|]
operator|=
literal|3
expr_stmt|;
name|ncol
operator|++
expr_stmt|;
while|while
condition|(
name|digit
argument_list|(
name|st
index|[
name|k
index|]
argument_list|)
condition|)
name|st
index|[
name|k
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|st
index|[
name|k
index|]
operator|==
literal|'\0'
condition|)
break|break;
name|st
index|[
name|k
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* now get input lines */
for|for
control|(
name|nlin
operator|=
literal|0
init|;
name|gets
argument_list|(
name|cstore
argument_list|)
operator|&&
operator|!
name|match
argument_list|(
name|cstore
argument_list|,
literal|".TE"
argument_list|)
condition|;
name|nlin
operator|++
control|)
block|{
if|if
condition|(
name|cstore
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|letter
argument_list|(
name|cstore
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|instead
index|[
name|nlin
index|]
operator|=
name|cstore
expr_stmt|;
while|while
condition|(
operator|*
name|cstore
condition|)
name|cstore
operator|++
expr_stmt|;
block|}
else|else
name|instead
index|[
name|nlin
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|icol
operator|=
literal|0
init|;
name|icol
operator|<
name|ncol
condition|;
name|icol
operator|++
control|)
block|{
name|tabentry
index|[
name|nlin
index|]
index|[
name|icol
index|]
operator|=
name|cstore
expr_stmt|;
for|for
control|(
init|;
operator|(
name|ch
operator|=
operator|*
name|cstore
operator|)
operator|!=
literal|'\0'
operator|&&
name|ch
operator|!=
literal|'\t'
condition|;
name|cstore
operator|++
control|)
empty_stmt|;
operator|*
name|cstore
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dwide
index|[
name|icol
index|]
condition|)
if|if
condition|(
name|broken
argument_list|(
name|style
index|[
name|icol
index|]
argument_list|,
name|nlin
argument_list|)
condition|)
block|{
name|tabentry
index|[
name|nlin
index|]
index|[
name|icol
operator|+
literal|1
index|]
operator|=
name|maknew
argument_list|(
name|tabentry
index|[
name|nlin
index|]
index|[
name|icol
index|]
argument_list|)
expr_stmt|;
name|icol
operator|++
expr_stmt|;
if|if
condition|(
name|tabentry
index|[
name|nlin
index|]
index|[
name|icol
index|]
operator|==
literal|0
condition|)
name|newtab
index|[
name|nlin
index|]
operator|=
name|newtab
index|[
name|nlin
operator|+
literal|1
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|tabentry
index|[
name|nlin
index|]
index|[
operator|++
name|icol
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|span
argument_list|(
name|style
index|[
name|icol
operator|+
literal|1
index|]
argument_list|,
name|nlin
argument_list|)
condition|)
name|tabentry
index|[
name|nlin
index|]
index|[
operator|++
name|icol
index|]
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\0'
condition|)
break|break;
block|}
while|while
condition|(
operator|++
name|icol
operator|<
name|ncol
condition|)
name|tabentry
index|[
name|nlin
index|]
index|[
name|icol
index|]
operator|=
literal|""
expr_stmt|;
while|while
condition|(
operator|*
name|cstore
operator|!=
literal|'\0'
condition|)
operator|*
name|cstore
operator|++
expr_stmt|;
if|if
condition|(
name|cstore
operator|-
name|cspace
operator|>
name|MAXCHS
condition|)
name|cstore
operator|=
name|cspace
operator|=
name|getvec
argument_list|(
name|MAXCHS
operator|+
literal|100
argument_list|)
expr_stmt|;
block|}
comment|/* find longest command string */
for|for
control|(
name|icol
operator|=
name|maxchnge
operator|=
literal|0
init|;
name|icol
operator|<
name|ncol
condition|;
name|icol
operator|++
control|)
if|if
condition|(
name|slen
argument_list|(
name|style
index|[
name|icol
index|]
argument_list|)
operator|>
name|maxchnge
condition|)
name|maxchnge
operator|=
name|slen
argument_list|(
name|style
index|[
name|icol
index|]
argument_list|)
expr_stmt|;
comment|/* set tab stops */
name|printf
argument_list|(
literal|".nr 49 0\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|icol
operator|=
literal|0
init|;
name|icol
operator|<
name|ncol
condition|;
name|icol
operator|++
control|)
block|{
name|ct
operator|=
literal|1
operator|+
operator|(
name|icol
operator|>
literal|0
condition|?
name|sep
index|[
name|icol
operator|-
literal|1
index|]
else|:
literal|0
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|".nr %2d 0\n"
argument_list|,
name|icol
operator|+
literal|50
argument_list|)
expr_stmt|;
for|for
control|(
name|ilin
operator|=
literal|0
init|;
name|ilin
operator|<
name|nlin
condition|;
name|ilin
operator|++
control|)
block|{
if|if
condition|(
name|icol
operator|>
literal|0
operator|&&
name|dwide
index|[
name|icol
operator|-
literal|1
index|]
operator|>
literal|0
operator|&&
name|tabentry
index|[
name|ilin
index|]
index|[
name|icol
index|]
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|".nr 48 \\n(%2d+\\w'%s'+%dn\n"
argument_list|,
name|icol
operator|+
literal|48
argument_list|,
name|tabentry
index|[
name|ilin
index|]
index|[
name|icol
operator|-
literal|1
index|]
argument_list|,
name|sep
index|[
name|icol
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".if \\n(48-\\n(%2d .nr %2d \\n(48\n"
argument_list|,
name|icol
operator|+
literal|50
argument_list|,
name|icol
operator|+
literal|50
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|span
argument_list|(
name|style
index|[
name|icol
index|]
argument_list|,
name|ilin
argument_list|)
operator|&&
comment|/* not part of span */
operator|(
name|dwide
index|[
name|icol
index|]
operator|==
literal|0
operator|||
name|tabentry
index|[
name|ilin
index|]
index|[
name|icol
operator|+
literal|1
index|]
operator|!=
literal|0
operator|)
comment|/* not a double item */
operator|&&
operator|(
operator|!
name|span
argument_list|(
name|style
index|[
name|icol
operator|+
literal|1
index|]
argument_list|,
name|ilin
argument_list|)
operator|||
name|icol
operator|==
name|ncol
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|".nr 47 \\n(%2d+\\w'%s'+%dn\n"
argument_list|,
name|icol
operator|+
literal|49
argument_list|,
name|tabentry
index|[
name|ilin
index|]
index|[
name|icol
index|]
argument_list|,
name|ct
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".if \\n(47-\\n(%2d .nr %2d \\n(47\n"
argument_list|,
name|icol
operator|+
literal|50
argument_list|,
name|icol
operator|+
literal|50
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* clean up spanned headings */
for|for
control|(
name|ilin
operator|=
literal|0
init|;
name|ilin
operator|<
name|maxchnge
condition|;
name|ilin
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|span
argument_list|(
name|style
index|[
name|icol
index|]
argument_list|,
name|ilin
argument_list|)
operator|)
operator|&&
operator|(
name|icol
operator|==
literal|1
operator|||
name|dwide
index|[
name|icol
operator|-
literal|1
index|]
operator|==
literal|0
operator|)
operator|&&
name|span
argument_list|(
name|style
index|[
name|icol
operator|+
operator|(
name|dwide
index|[
name|icol
index|]
condition|?
literal|2
else|:
literal|1
operator|)
index|]
argument_list|,
name|ilin
argument_list|)
condition|)
name|printf
argument_list|(
literal|".nr %d \\n(%2d+\\w'%s'+%dn\n"
argument_list|,
name|ilin
operator|+
literal|30
argument_list|,
name|icol
operator|+
literal|49
argument_list|,
name|tabentry
index|[
name|ilin
index|]
index|[
name|icol
index|]
argument_list|,
name|ct
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|span
argument_list|(
name|style
index|[
name|icol
index|]
argument_list|,
name|ilin
argument_list|)
operator|&&
operator|(
name|icol
operator|+
literal|1
operator|==
name|ncol
operator|||
operator|!
name|span
argument_list|(
name|style
index|[
name|icol
operator|+
literal|1
index|]
argument_list|,
name|ilin
argument_list|)
operator|)
condition|)
name|printf
argument_list|(
literal|".if \\n(%d-\\n(%d .nr %d \\n(%d\n"
argument_list|,
literal|30
operator|+
name|ilin
argument_list|,
name|icol
operator|+
literal|50
argument_list|,
name|icol
operator|+
literal|50
argument_list|,
name|ilin
operator|+
literal|30
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* run out table, put field characters in */
name|printf
argument_list|(
literal|".fc
literal|@\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ilin
operator|=
literal|0
init|;
name|ilin
operator|<
name|nlin
condition|;
name|ilin
operator|++
control|)
block|{
if|if
condition|(
name|instead
index|[
name|ilin
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|instead
index|[
name|ilin
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* is a new set of tab stops needed */
if|if
condition|(
name|ilin
operator|<
name|maxchnge
operator|||
name|newtab
index|[
name|ilin
index|]
condition|)
name|settab
argument_list|(
name|ncol
argument_list|,
name|ilin
argument_list|)
expr_stmt|;
for|for
control|(
name|icol
operator|=
literal|0
init|;
name|icol
operator|<
name|ncol
condition|;
name|icol
operator|++
control|)
block|{
switch|switch
condition|(
name|ylet
argument_list|(
name|style
index|[
name|icol
index|]
argument_list|,
name|ilin
argument_list|)
condition|)
block|{
default|default:
case|case
literal|'L'
case|:
case|case
literal|'l'
case|:
name|format
operator|=
literal|"
literal|%s@
literal|"
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
case|case
literal|'r'
case|:
name|format
operator|=
literal|"
literal|@%s
literal|"
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
if|if
condition|(
operator|!
name|dwide
index|[
name|icol
index|]
operator|||
name|tabentry
index|[
name|ilin
index|]
index|[
name|icol
operator|+
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
name|format
operator|=
name|dwide
index|[
name|icol
index|]
condition|?
literal|"
literal|@%s
literal|"
else|:
literal|"
literal|%s@
literal|"
expr_stmt|;
break|break;
block|}
case|case
literal|'c'
case|:
case|case
literal|'C'
case|:
name|format
operator|=
literal|"
literal|@%s@
literal|"
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|format
operator|=
literal|""
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|dwide
index|[
name|icol
operator|-
literal|1
index|]
operator|>
literal|0
operator|&&
name|tabentry
index|[
name|ilin
index|]
index|[
name|icol
index|]
operator|==
literal|0
operator|)
condition|)
name|printf
argument_list|(
name|format
argument_list|,
name|tabentry
index|[
name|ilin
index|]
index|[
name|icol
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|span
argument_list|(
name|style
index|[
name|icol
operator|+
literal|1
index|]
argument_list|,
name|ilin
argument_list|)
condition|)
for|for
control|(
name|k
operator|=
name|sep
index|[
name|icol
index|]
init|;
name|k
operator|>
literal|0
condition|;
name|k
operator|--
control|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|".fc\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".TE\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|match
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|s1
operator|==
operator|*
name|s2
condition|)
if|if
condition|(
operator|*
name|s1
operator|++
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
operator|*
name|s2
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|slen
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
operator|*
name|str
operator|++
operator|!=
literal|'\0'
condition|;
name|k
operator|++
control|)
empty_stmt|;
return|return
operator|(
name|k
operator|)
return|;
block|}
end_block

begin_macro
name|space
argument_list|(
argument|ch
argument_list|)
end_macro

begin_block
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|letter
argument_list|(
argument|ch
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'z'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'Z'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|numb
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* convert to integer */
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
operator|*
name|str
operator|>=
literal|'0'
operator|&&
operator|*
name|str
operator|<=
literal|'9'
condition|;
name|str
operator|++
control|)
name|k
operator|=
name|k
operator|*
literal|10
operator|+
operator|*
name|str
operator|-
literal|'0'
expr_stmt|;
return|return
operator|(
name|k
operator|)
return|;
block|}
end_block

begin_macro
name|broken
argument_list|(
argument|str
argument_list|,
argument|nlin
argument_list|)
end_macro

begin_block
block|{
switch|switch
condition|(
name|ylet
argument_list|(
name|str
argument_list|,
name|nlin
argument_list|)
condition|)
block|{
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|ylet
argument_list|(
argument|str
argument_list|,
argument|k
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|k
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|str
operator|&&
name|k
operator|--
condition|)
name|str
operator|++
expr_stmt|;
return|return
operator|(
operator|*
operator|--
name|str
operator|)
return|;
block|}
end_block

begin_macro
name|span
argument_list|(
argument|str
argument_list|,
argument|k
argument_list|)
end_macro

begin_block
block|{
switch|switch
condition|(
name|ylet
argument_list|(
name|str
argument_list|,
name|k
argument_list|)
condition|)
block|{
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|maknew
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* make two numerical fields */
name|int
name|point
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|p
operator|=
name|str
expr_stmt|;
for|for
control|(
name|point
operator|=
literal|0
init|;
operator|*
name|str
condition|;
name|str
operator|++
control|)
if|if
condition|(
operator|*
name|str
operator|==
literal|'.'
condition|)
name|point
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|point
operator|&&
operator|*
operator|(
name|str
operator|-
literal|1
operator|)
operator|==
literal|'$'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
init|;
name|str
operator|>
name|p
condition|;
name|str
operator|--
control|)
if|if
condition|(
operator|(
name|point
operator|&&
operator|*
name|str
operator|==
literal|'.'
operator|)
operator|||
operator|(
operator|!
name|point
operator|&&
name|digit
argument_list|(
operator|*
operator|(
name|str
operator|-
literal|1
operator|)
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|point
operator|&&
name|p
operator|==
name|str
condition|)
comment|/* not numerical, don't split */
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|=
name|str
expr_stmt|;
name|q
operator|=
name|exstore
expr_stmt|;
while|while
condition|(
operator|*
name|exstore
operator|++
operator|=
operator|*
name|str
operator|++
condition|)
empty_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_block

begin_macro
name|digit
argument_list|(
argument|x
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
name|x
operator|>=
literal|'0'
operator|&&
name|x
operator|<=
literal|'9'
operator|)
return|;
block|}
end_block

begin_macro
name|settab
argument_list|(
argument|ncol
argument_list|,
argument|ilin
argument_list|)
end_macro

begin_block
block|{
name|int
name|k
decl_stmt|,
name|icol
decl_stmt|;
name|printf
argument_list|(
literal|".ta "
argument_list|)
expr_stmt|;
for|for
control|(
name|icol
operator|=
literal|0
init|;
name|icol
operator|<
name|ncol
condition|;
name|icol
operator|++
control|)
if|if
condition|(
operator|(
name|dwide
index|[
name|icol
index|]
operator|==
literal|0
operator|||
name|tabentry
index|[
name|ilin
index|]
index|[
name|icol
operator|+
literal|1
index|]
operator|!=
literal|0
operator|)
operator|&&
operator|!
name|span
argument_list|(
name|style
index|[
name|icol
operator|+
literal|1
index|]
argument_list|,
name|ilin
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\\n(%du "
argument_list|,
name|icol
operator|+
literal|50
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

