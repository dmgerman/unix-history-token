begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*  * C compiler, phase 1  *  *  * Handles processing of declarations,  * except for top-level processing of  * externals.  */
end_comment

begin_include
include|#
directive|include
file|"c0h.c"
end_include

begin_comment
comment|/*  * Process a sequence of declaration statements  */
end_comment

begin_macro
name|declist
argument_list|(
argument|sclass
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|sc
operator|,
name|elsize
operator|,
name|offset
expr_stmt|;
name|int
name|type
decl_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|sclass
expr_stmt|;
while|while
condition|(
operator|(
name|elsize
operator|=
name|getkeywords
argument_list|(
operator|&
name|sclass
argument_list|,
operator|&
name|type
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|offset
operator|=
name|declare
argument_list|(
name|sclass
argument_list|,
name|type
argument_list|,
name|offset
argument_list|,
name|elsize
argument_list|)
expr_stmt|;
name|sclass
operator|=
name|sc
expr_stmt|;
block|}
return|return
operator|(
name|offset
operator|+
name|align
argument_list|(
name|INT
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Read the keywords introducing a declaration statement  */
end_comment

begin_macro
name|getkeywords
argument_list|(
argument|scptr
argument_list|,
argument|tptr
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|scptr
decl_stmt|,
modifier|*
name|tptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|skw
operator|,
name|tkw
operator|,
name|longf
expr_stmt|;
name|int
name|o
decl_stmt|,
name|elsize
decl_stmt|,
name|isadecl
decl_stmt|,
name|ismos
decl_stmt|;
name|isadecl
operator|=
literal|0
expr_stmt|;
name|longf
operator|=
literal|0
expr_stmt|;
name|tkw
operator|=
operator|-
literal|1
expr_stmt|;
name|skw
operator|=
operator|*
name|scptr
expr_stmt|;
name|elsize
operator|=
literal|0
expr_stmt|;
name|ismos
operator|=
name|skw
operator|==
name|MOS
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|mosflg
operator|=
name|ismos
expr_stmt|;
switch|switch
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|KEYW
condition|?
name|cval
else|:
operator|-
literal|1
condition|)
block|{
case|case
name|AUTO
case|:
case|case
name|STATIC
case|:
case|case
name|EXTERN
case|:
case|case
name|REG
case|:
if|if
condition|(
name|skw
operator|&&
name|skw
operator|!=
name|cval
condition|)
name|error
argument_list|(
literal|"Conflict in storage class"
argument_list|)
expr_stmt|;
name|skw
operator|=
name|cval
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|longf
operator|++
expr_stmt|;
break|break;
case|case
name|STRUCT
case|:
name|o
operator|=
name|STRUCT
expr_stmt|;
name|elsize
operator|=
name|strdec
argument_list|(
operator|&
name|o
argument_list|,
name|ismos
argument_list|)
expr_stmt|;
name|cval
operator|=
name|o
expr_stmt|;
case|case
name|INT
case|:
case|case
name|CHAR
case|:
case|case
name|FLOAT
case|:
case|case
name|DOUBLE
case|:
if|if
condition|(
name|tkw
operator|>=
literal|0
condition|)
name|error
argument_list|(
literal|"Type clash"
argument_list|)
expr_stmt|;
name|tkw
operator|=
name|cval
expr_stmt|;
break|break;
default|default:
name|peeksym
operator|=
name|o
expr_stmt|;
if|if
condition|(
name|isadecl
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|tkw
operator|<
literal|0
condition|)
name|tkw
operator|=
name|INT
expr_stmt|;
if|if
condition|(
name|skw
operator|==
literal|0
condition|)
name|skw
operator|=
name|AUTO
expr_stmt|;
if|if
condition|(
name|longf
condition|)
block|{
if|if
condition|(
name|tkw
operator|==
name|FLOAT
condition|)
name|tkw
operator|=
name|DOUBLE
expr_stmt|;
elseif|else
if|if
condition|(
name|tkw
operator|==
name|INT
condition|)
name|tkw
operator|=
name|LONG
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Misplaced 'long'"
argument_list|)
expr_stmt|;
block|}
operator|*
name|scptr
operator|=
name|skw
expr_stmt|;
operator|*
name|tptr
operator|=
name|tkw
expr_stmt|;
return|return
operator|(
name|elsize
operator|)
return|;
block|}
name|isadecl
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Process a structure declaration; a subroutine  * of getkeywords.  */
end_comment

begin_macro
name|strdec
argument_list|(
argument|tkwp
argument_list|,
argument|mosf
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|tkwp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|elsize
operator|,
name|o
expr_stmt|;
specifier|register
name|struct
name|hshtab
modifier|*
name|ssym
decl_stmt|;
name|int
name|savebits
decl_stmt|;
name|struct
name|hshtab
modifier|*
name|ds
decl_stmt|;
name|mosflg
operator|=
literal|1
expr_stmt|;
name|ssym
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|NAME
condition|)
block|{
name|ssym
operator|=
name|csym
expr_stmt|;
if|if
condition|(
name|ssym
operator|->
name|hclass
operator|==
literal|0
condition|)
block|{
name|ssym
operator|->
name|hclass
operator|=
name|STRTAG
expr_stmt|;
name|ssym
operator|->
name|lenp
operator|=
name|dimp
expr_stmt|;
name|chkdim
argument_list|()
expr_stmt|;
name|dimtab
index|[
name|dimp
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ssym
operator|->
name|hclass
operator|!=
name|STRTAG
condition|)
name|redec
argument_list|()
expr_stmt|;
name|mosflg
operator|=
name|mosf
expr_stmt|;
name|o
operator|=
name|symbol
argument_list|()
expr_stmt|;
block|}
name|mosflg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|o
operator|!=
name|LBRACE
condition|)
block|{
if|if
condition|(
name|ssym
operator|==
literal|0
condition|)
block|{
name|syntax
label|:
name|decsyn
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ssym
operator|->
name|hclass
operator|!=
name|STRTAG
condition|)
name|error
argument_list|(
literal|"Bad structure name"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|elsize
operator|=
name|dimtab
index|[
name|ssym
operator|->
name|lenp
operator|&
literal|0377
index|]
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|tkwp
operator|=
name|RSTRUCT
expr_stmt|;
name|elsize
operator|=
name|ssym
expr_stmt|;
block|}
name|peeksym
operator|=
name|o
expr_stmt|;
block|}
else|else
block|{
name|ds
operator|=
name|defsym
expr_stmt|;
name|mosflg
operator|=
literal|0
expr_stmt|;
name|savebits
operator|=
name|bitoffs
expr_stmt|;
name|bitoffs
operator|=
literal|0
expr_stmt|;
name|elsize
operator|=
name|declist
argument_list|(
name|MOS
argument_list|)
expr_stmt|;
name|bitoffs
operator|=
name|savebits
expr_stmt|;
name|defsym
operator|=
name|ds
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|!=
name|RBRACE
condition|)
goto|goto
name|syntax
goto|;
if|if
condition|(
name|ssym
condition|)
block|{
if|if
condition|(
name|dimtab
index|[
name|ssym
operator|->
name|lenp
operator|&
literal|0377
index|]
condition|)
name|error
argument_list|(
literal|"%.8s redeclared"
argument_list|,
name|ssym
operator|->
name|name
argument_list|)
expr_stmt|;
name|dimtab
index|[
name|ssym
operator|->
name|lenp
operator|&
literal|0377
index|]
operator|=
name|elsize
expr_stmt|;
block|}
block|}
return|return
operator|(
name|elsize
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Check that the dimension table has not overflowed  */
end_comment

begin_macro
name|chkdim
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|dimp
operator|>=
name|dimsiz
condition|)
block|{
name|error
argument_list|(
literal|"Dimension/struct table overflow"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Process a comma-separated list of declarators  */
end_comment

begin_macro
name|declare
argument_list|(
argument|askw
argument_list|,
argument|tkw
argument_list|,
argument|offset
argument_list|,
argument|elsize
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|o
decl_stmt|;
specifier|register
name|int
name|skw
decl_stmt|;
name|skw
operator|=
name|askw
expr_stmt|;
do|do
block|{
name|offset
operator|=
operator|+
name|decl1
argument_list|(
name|skw
argument_list|,
name|tkw
argument_list|,
name|offset
argument_list|,
name|elsize
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|COMMA
condition|)
do|;
if|if
condition|(
name|o
operator|==
name|SEMI
operator|||
name|o
operator|==
name|RPARN
operator|&&
name|skw
operator|==
name|ARG1
condition|)
return|return
operator|(
name|offset
operator|)
return|;
name|decsyn
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Process a single declarator  */
end_comment

begin_macro
name|decl1
argument_list|(
argument|askw
argument_list|,
argument|tkw
argument_list|,
argument|offset
argument_list|,
argument|elsize
argument_list|)
end_macro

begin_block
block|{
name|int
name|t1
decl_stmt|,
name|chkoff
decl_stmt|,
name|a
decl_stmt|;
specifier|register
name|int
name|type
decl_stmt|,
name|skw
decl_stmt|;
specifier|register
name|struct
name|hshtab
modifier|*
name|dsym
decl_stmt|;
name|skw
operator|=
name|askw
expr_stmt|;
name|chkoff
operator|=
literal|0
expr_stmt|;
name|mosflg
operator|=
name|skw
operator|==
name|MOS
expr_stmt|;
if|if
condition|(
operator|(
name|peeksym
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|SEMI
operator|||
name|peeksym
operator|==
name|RPARN
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Filler field 	 */
if|if
condition|(
name|peeksym
operator|==
name|COLON
operator|&&
name|skw
operator|==
name|MOS
condition|)
block|{
name|peeksym
operator|=
operator|-
literal|1
expr_stmt|;
name|t1
operator|=
name|conexp
argument_list|()
expr_stmt|;
name|elsize
operator|=
name|align
argument_list|(
name|tkw
argument_list|,
name|offset
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|bitoffs
operator|=
operator|+
name|t1
expr_stmt|;
return|return
operator|(
name|elsize
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|t1
operator|=
name|getype
argument_list|()
operator|)
operator|<
literal|0
condition|)
goto|goto
name|syntax
goto|;
name|type
operator|=
literal|0
expr_stmt|;
do|do
name|type
operator|=
name|type
operator|<<
name|TYLEN
operator||
operator|(
name|t1
operator|&
name|XTYPE
operator|)
expr_stmt|;
do|while
condition|(
operator|(
operator|(
name|t1
operator|=
operator|>>
name|TYLEN
operator|)
operator|&
name|XTYPE
operator|)
operator|!=
literal|0
condition|)
do|;
name|type
operator|=
operator||
name|tkw
expr_stmt|;
name|dsym
operator|=
name|defsym
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dsym
operator|->
name|hclass
operator|==
literal|0
operator|||
operator|(
name|skw
operator|==
name|ARG
operator|&&
name|dsym
operator|->
name|hclass
operator|==
name|ARG1
operator|)
operator|||
operator|(
name|skw
operator|==
name|EXTERN
operator|&&
name|dsym
operator|->
name|hclass
operator|==
name|EXTERN
operator|&&
name|dsym
operator|->
name|htype
operator|==
name|type
operator|)
operator|)
condition|)
if|if
condition|(
name|skw
operator|==
name|MOS
operator|&&
name|dsym
operator|->
name|hclass
operator|==
name|MOS
operator|&&
name|dsym
operator|->
name|htype
operator|==
name|type
condition|)
name|chkoff
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|redec
argument_list|()
expr_stmt|;
goto|goto
name|syntax
goto|;
block|}
name|dsym
operator|->
name|htype
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|skw
condition|)
name|dsym
operator|->
name|hclass
operator|=
name|skw
expr_stmt|;
if|if
condition|(
name|skw
operator|==
name|ARG1
condition|)
block|{
if|if
condition|(
name|paraml
operator|==
literal|0
condition|)
name|paraml
operator|=
name|dsym
expr_stmt|;
else|else
name|parame
operator|->
name|hoffset
operator|=
name|dsym
expr_stmt|;
name|parame
operator|=
name|dsym
expr_stmt|;
block|}
if|if
condition|(
name|elsize
operator|&&
operator|(
operator|(
name|type
operator|&
name|TYPE
operator|)
operator|==
name|RSTRUCT
operator|||
operator|(
name|type
operator|&
name|TYPE
operator|)
operator|==
name|STRUCT
operator|)
condition|)
block|{
name|dsym
operator|->
name|lenp
operator|=
name|dimp
expr_stmt|;
name|chkdim
argument_list|()
expr_stmt|;
name|dimtab
index|[
name|dimp
operator|++
index|]
operator|=
name|elsize
expr_stmt|;
block|}
name|elsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|skw
operator|==
name|MOS
condition|)
block|{
name|elsize
operator|=
name|length
argument_list|(
name|dsym
argument_list|)
expr_stmt|;
name|t1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|peeksym
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|COLON
condition|)
block|{
name|elsize
operator|=
literal|0
expr_stmt|;
name|peeksym
operator|=
operator|-
literal|1
expr_stmt|;
name|t1
operator|=
name|conexp
argument_list|()
expr_stmt|;
name|dsym
operator|->
name|hflag
operator|=
operator||
name|FFIELD
expr_stmt|;
block|}
name|a
operator|=
name|align
argument_list|(
name|type
argument_list|,
name|offset
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|elsize
operator|=
operator|+
name|a
expr_stmt|;
name|offset
operator|=
operator|+
name|a
expr_stmt|;
if|if
condition|(
name|t1
condition|)
block|{
if|if
condition|(
name|chkoff
operator|&&
operator|(
name|dsym
operator|->
name|bitoffs
operator|!=
name|bitoffs
operator|||
name|dsym
operator|->
name|flen
operator|!=
name|t1
operator|)
condition|)
name|redec
argument_list|()
expr_stmt|;
name|dsym
operator|->
name|bitoffs
operator|=
name|bitoffs
expr_stmt|;
name|dsym
operator|->
name|flen
operator|=
name|t1
expr_stmt|;
name|bitoffs
operator|=
operator|+
name|t1
expr_stmt|;
block|}
if|if
condition|(
name|chkoff
operator|&&
name|dsym
operator|->
name|hoffset
operator|!=
name|offset
condition|)
name|redec
argument_list|()
expr_stmt|;
name|dsym
operator|->
name|hoffset
operator|=
name|offset
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dsym
operator|->
name|htype
operator|&
name|XTYPE
operator|)
operator|==
name|FUNC
condition|)
block|{
if|if
condition|(
name|dsym
operator|->
name|hclass
operator|!=
name|EXTERN
operator|&&
name|dsym
operator|->
name|hclass
operator|!=
name|AUTO
condition|)
name|error
argument_list|(
literal|"Bad function"
argument_list|)
expr_stmt|;
name|dsym
operator|->
name|hclass
operator|=
name|EXTERN
expr_stmt|;
block|}
if|if
condition|(
name|dsym
operator|->
name|hclass
operator|==
name|AUTO
condition|)
block|{
name|autolen
operator|=
operator|+
name|rlength
argument_list|(
name|dsym
argument_list|)
expr_stmt|;
name|dsym
operator|->
name|hoffset
operator|=
operator|-
name|autolen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dsym
operator|->
name|hclass
operator|==
name|STATIC
condition|)
block|{
name|dsym
operator|->
name|hoffset
operator|=
name|isn
expr_stmt|;
name|outcode
argument_list|(
literal|"BBNBNB"
argument_list|,
name|BSS
argument_list|,
name|LABEL
argument_list|,
name|isn
operator|++
argument_list|,
name|SSPACE
argument_list|,
name|rlength
argument_list|(
name|dsym
argument_list|)
argument_list|,
name|PROG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dsym
operator|->
name|hclass
operator|==
name|REG
condition|)
block|{
if|if
condition|(
operator|(
name|type
operator|&
name|TYPE
operator|)
operator|>
name|CHAR
operator|&&
operator|(
name|type
operator|&
name|XTYPE
operator|)
operator|==
literal|0
operator|||
operator|(
name|type
operator|&
name|XTYPE
operator|)
operator|>
name|PTR
operator|||
name|regvar
operator|<
literal|3
condition|)
name|error
argument_list|(
literal|"Bad register %o"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|dsym
operator|->
name|hoffset
operator|=
operator|--
name|regvar
expr_stmt|;
block|}
name|syntax
label|:
return|return
operator|(
name|elsize
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Read a declarator and get the implied type  */
end_comment

begin_macro
name|getype
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|o
decl_stmt|,
name|type
decl_stmt|;
specifier|register
name|struct
name|hshtab
modifier|*
name|ds
decl_stmt|;
switch|switch
condition|(
name|o
operator|=
name|symbol
argument_list|()
condition|)
block|{
case|case
name|TIMES
case|:
return|return
operator|(
name|getype
argument_list|()
operator|<<
name|TYLEN
operator||
name|PTR
operator|)
return|;
case|case
name|LPARN
case|:
name|type
operator|=
name|getype
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|!=
name|RPARN
condition|)
goto|goto
name|syntax
goto|;
goto|goto
name|getf
goto|;
case|case
name|NAME
case|:
name|defsym
operator|=
name|ds
operator|=
name|csym
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|ssp
operator|=
name|dimp
expr_stmt|;
name|getf
label|:
switch|switch
condition|(
name|o
operator|=
name|symbol
argument_list|()
condition|)
block|{
case|case
name|LPARN
case|:
if|if
condition|(
name|xdflg
condition|)
block|{
name|xdflg
operator|=
literal|0
expr_stmt|;
name|ds
operator|=
name|defsym
expr_stmt|;
name|declare
argument_list|(
name|ARG1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|defsym
operator|=
name|ds
expr_stmt|;
name|xdflg
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|!=
name|RPARN
condition|)
goto|goto
name|syntax
goto|;
name|type
operator|=
name|type
operator|<<
name|TYLEN
operator||
name|FUNC
expr_stmt|;
goto|goto
name|getf
goto|;
case|case
name|LBRACK
case|:
name|chkdim
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|!=
name|RBRACK
condition|)
block|{
name|peeksym
operator|=
name|o
expr_stmt|;
name|cval
operator|=
name|conexp
argument_list|()
expr_stmt|;
for|for
control|(
name|o
operator|=
name|ds
operator|->
name|ssp
operator|&
literal|0377
init|;
name|o
operator|<
name|dimp
condition|;
name|o
operator|++
control|)
name|dimtab
index|[
name|o
index|]
operator|=
operator|*
name|cval
expr_stmt|;
name|dimtab
index|[
name|dimp
operator|++
index|]
operator|=
name|cval
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|!=
name|RBRACK
condition|)
goto|goto
name|syntax
goto|;
block|}
else|else
name|dimtab
index|[
name|dimp
operator|++
index|]
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|type
operator|<<
name|TYLEN
operator||
name|ARRAY
expr_stmt|;
goto|goto
name|getf
goto|;
block|}
name|peeksym
operator|=
name|o
expr_stmt|;
return|return
operator|(
name|type
operator|)
return|;
block|}
name|syntax
label|:
name|decsyn
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Enforce alignment restrictions in structures,  * including bit-field considerations.  */
end_comment

begin_macro
name|align
argument_list|(
argument|type
argument_list|,
argument|offset
argument_list|,
argument|aflen
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|a
operator|,
name|t
operator|,
name|flen
expr_stmt|;
name|char
modifier|*
name|ftl
decl_stmt|;
name|flen
operator|=
name|aflen
expr_stmt|;
name|a
operator|=
name|offset
expr_stmt|;
name|t
operator|=
name|type
expr_stmt|;
name|ftl
operator|=
literal|"Field too long"
expr_stmt|;
if|if
condition|(
name|flen
operator|==
literal|0
operator|&&
name|bitoffs
condition|)
block|{
name|a
operator|=
operator|+
operator|(
name|bitoffs
operator|-
literal|1
operator|)
operator|/
name|NBPC
expr_stmt|;
name|bitoffs
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|t
operator|&
name|XTYPE
operator|)
operator|==
name|ARRAY
condition|)
name|t
operator|=
name|decref
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|CHAR
condition|)
block|{
name|a
operator|=
operator|(
name|a
operator|+
name|ALIGN
operator|)
operator|&
operator|~
name|ALIGN
expr_stmt|;
if|if
condition|(
name|a
operator|>
name|offset
condition|)
name|bitoffs
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flen
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|INT
condition|)
block|{
if|if
condition|(
name|flen
operator|>
name|NBPW
condition|)
name|error
argument_list|(
name|ftl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flen
operator|+
name|bitoffs
operator|>
name|NBPW
condition|)
block|{
name|bitoffs
operator|=
literal|0
expr_stmt|;
name|a
operator|=
operator|+
name|NCPW
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|CHAR
condition|)
block|{
if|if
condition|(
name|flen
operator|>
name|NBPC
condition|)
name|error
argument_list|(
name|ftl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flen
operator|+
name|bitoffs
operator|>
name|NCPW
condition|)
block|{
name|bitoffs
operator|=
literal|0
expr_stmt|;
name|a
operator|=
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
name|error
argument_list|(
literal|"Bad type for field"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|a
operator|-
name|offset
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Complain about syntax error in declaration  */
end_comment

begin_macro
name|decsyn
argument_list|(
argument|o
argument_list|)
end_macro

begin_block
block|{
name|error
argument_list|(
literal|"Declaration syntax"
argument_list|)
expr_stmt|;
name|errflush
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Complain about a redeclaration  */
end_comment

begin_macro
name|redec
argument_list|()
end_macro

begin_block
block|{
name|error
argument_list|(
literal|"%.8s redeclared"
argument_list|,
name|defsym
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

