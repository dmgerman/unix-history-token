begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*  	    	C compiler, part 2   */
end_comment

begin_include
include|#
directive|include
file|"c1h.c"
end_include

begin_decl_stmt
name|char
name|maprel
index|[]
block|{
name|EQUAL
operator|,
name|NEQUAL
operator|,
name|GREATEQ
operator|,
name|GREAT
operator|,
name|LESSEQ
operator|,
name|LESS
operator|,
name|GREATQP
operator|,
name|GREATP
operator|,
name|LESSEQP
operator|,
name|LESSP
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|char
name|notrel
index|[]
block|{
name|NEQUAL
operator|,
name|EQUAL
operator|,
name|GREAT
operator|,
name|GREATEQ
operator|,
name|LESS
operator|,
name|LESSEQ
operator|,
name|GREATP
operator|,
name|GREATQP
operator|,
name|LESSP
operator|,
name|LESSEQP
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_struct
struct|struct
name|tconst
name|czero
block|{
name|CON
operator|,
name|INT
operator|,
literal|0
operator|,
literal|0
block|}
struct|;
end_struct

begin_struct
struct|struct
name|tconst
name|cone
block|{
name|CON
operator|,
name|INT
operator|,
literal|0
operator|,
literal|1
block|}
struct|;
end_struct

begin_struct
struct|struct
name|tconst
name|fczero
block|{
name|SFCON
operator|,
name|DOUBLE
operator|,
literal|0
operator|,
literal|0
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|table
modifier|*
name|cregtab
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|int
name|nreg
literal|3
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|int
name|isn
literal|10000
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|int
name|namsiz
literal|8
expr_stmt|;
end_expr_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
extern|extern fout;
if|if
condition|(
name|argc
operator|<
literal|4
condition|)
block|{
name|error
argument_list|(
literal|"Arg count"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|ascbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Missing temp file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fout
operator|=
name|creat
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't create %s"
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|spacep
operator|=
name|treespace
expr_stmt|;
name|getree
argument_list|()
expr_stmt|;
comment|/* 	 * If any floating-point instructions 	 * were used, generate a reference which 	 * pulls in the floating-point part of printf. 	 */
if|if
condition|(
name|nfloat
condition|)
name|printf
argument_list|(
literal|".globl	fltused\n"
argument_list|)
expr_stmt|;
comment|/* 	 * tack on the string file. 	 */
name|close
argument_list|(
name|ascbuf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fopen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
name|ascbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Missing temp file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|".globl\n.data\n"
argument_list|)
expr_stmt|;
name|getree
argument_list|()
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|nerror
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a tree, a code table, and a  * count of available registers, find the code table  * for the appropriate operator such that the operands  * are of the right type and the number of registers  * required is not too large.  * Return a ptr to the table entry or 0 if none found.  */
end_comment

begin_function
name|char
modifier|*
name|match
parameter_list|(
name|atree
parameter_list|,
name|table
parameter_list|,
name|nrleft
parameter_list|)
name|struct
name|tnode
modifier|*
name|atree
decl_stmt|;
name|struct
name|table
modifier|*
name|table
decl_stmt|;
block|{
name|int
name|op
decl_stmt|,
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|dope
decl_stmt|;
name|struct
name|tnode
modifier|*
name|p2
decl_stmt|;
specifier|register
name|struct
name|tnode
modifier|*
name|p1
decl_stmt|,
modifier|*
name|tree
decl_stmt|;
specifier|register
name|struct
name|optab
modifier|*
name|opt
decl_stmt|;
if|if
condition|(
operator|(
name|tree
operator|=
name|atree
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|table
operator|==
name|lsptab
condition|)
name|table
operator|=
name|sptab
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|=
name|tree
operator|->
name|op
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dope
operator|=
name|opdope
index|[
name|op
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|dope
operator|&
name|LEAF
operator|)
operator|==
literal|0
condition|)
name|p1
operator|=
name|tree
operator|->
name|tr1
expr_stmt|;
else|else
name|p1
operator|=
name|tree
expr_stmt|;
name|t1
operator|=
name|p1
operator|->
name|type
expr_stmt|;
name|d1
operator|=
name|dcalc
argument_list|(
name|p1
argument_list|,
name|nrleft
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dope
operator|&
name|BINARY
operator|)
operator|!=
literal|0
condition|)
block|{
name|p2
operator|=
name|tree
operator|->
name|tr2
expr_stmt|;
comment|/* 		 * If a subtree starts off with a conversion operator, 		 * try for a match with the conversion eliminated. 		 * E.g. int = double can be done without generating 		 * the converted int in a register by 		 * movf double,fr0; movfi fr0,int . 		 */
if|if
condition|(
name|opdope
index|[
name|p1
operator|->
name|op
index|]
operator|&
name|CNVRT
operator|&&
operator|(
name|opdope
index|[
name|p2
operator|->
name|op
index|]
operator|&
name|CNVRT
operator|)
operator|==
literal|0
condition|)
block|{
name|tree
operator|->
name|tr1
operator|=
name|p1
operator|->
name|tr1
expr_stmt|;
if|if
condition|(
name|opt
operator|=
name|match
argument_list|(
name|tree
argument_list|,
name|table
argument_list|,
name|nrleft
argument_list|)
condition|)
return|return
operator|(
name|opt
operator|)
return|;
name|tree
operator|->
name|tr1
operator|=
name|p1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opdope
index|[
name|p2
operator|->
name|op
index|]
operator|&
name|CNVRT
operator|&&
operator|(
name|opdope
index|[
name|p1
operator|->
name|op
index|]
operator|&
name|CNVRT
operator|)
operator|==
literal|0
condition|)
block|{
name|tree
operator|->
name|tr2
operator|=
name|p2
operator|->
name|tr1
expr_stmt|;
if|if
condition|(
name|opt
operator|=
name|match
argument_list|(
name|tree
argument_list|,
name|table
argument_list|,
name|nrleft
argument_list|)
condition|)
return|return
operator|(
name|opt
operator|)
return|;
name|tree
operator|->
name|tr2
operator|=
name|p2
expr_stmt|;
block|}
name|t2
operator|=
name|p2
operator|->
name|type
expr_stmt|;
name|d2
operator|=
name|dcalc
argument_list|(
name|p2
argument_list|,
name|nrleft
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|table
operator|->
name|op
operator|!=
name|op
condition|;
name|table
operator|++
control|)
if|if
condition|(
name|table
operator|->
name|op
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|opt
operator|=
name|table
operator|->
name|tabp
init|;
name|opt
operator|->
name|tabdeg1
operator|!=
literal|0
condition|;
name|opt
operator|++
control|)
block|{
if|if
condition|(
name|d1
operator|>
operator|(
name|opt
operator|->
name|tabdeg1
operator|&
literal|077
operator|)
operator|||
operator|(
name|opt
operator|->
name|tabdeg1
operator|>=
literal|0100
operator|&&
operator|(
name|p1
operator|->
name|op
operator|!=
name|STAR
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|notcompat
argument_list|(
name|p1
argument_list|,
name|opt
operator|->
name|tabtyp1
argument_list|,
name|op
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|opdope
index|[
name|op
index|]
operator|&
name|BINARY
operator|)
operator|!=
literal|0
operator|&&
name|p2
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|d2
operator|>
operator|(
name|opt
operator|->
name|tabdeg2
operator|&
literal|077
operator|)
operator|||
operator|(
name|opt
operator|->
name|tabdeg2
operator|>=
literal|0100
operator|)
operator|&&
operator|(
name|p2
operator|->
name|op
operator|!=
name|STAR
operator|)
condition|)
continue|continue;
if|if
condition|(
name|notcompat
argument_list|(
name|p2
argument_list|,
name|opt
operator|->
name|tabtyp2
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
block|}
return|return
operator|(
name|opt
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a tree, a code table, and a register,  * produce code to evaluate the tree with the appropriate table.  * Registers reg and upcan be used.  * If there is a value, it is desired that it appear in reg.  * The routine returns the register in which the value actually appears.  * This routine must work or there is an error.  * If the table called for is cctab, sptab, or efftab,  * and tree can't be done using the called-for table,  * another try is made.  * If the tree can't be compiled using cctab, regtab is  * used and a "tst" instruction is produced.  * If the tree can't be compiled using sptab,  * regtab is used and the register is pushed on the stack.  * If the tree can't be compiled using efftab,  * just use regtab.  * Regtab must succeed or an "op not found" error results.  *  * A number of special cases are recognized, and  * there is an interaction with the optimizer routines.  */
end_comment

begin_macro
name|rcexpr
argument_list|(
argument|atree
argument_list|,
argument|atable
argument_list|,
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|atree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|table
modifier|*
name|atable
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|r
expr_stmt|;
name|int
name|modf
decl_stmt|,
name|nargs
decl_stmt|,
name|recurf
decl_stmt|;
specifier|register
name|struct
name|tnode
modifier|*
name|tree
decl_stmt|;
specifier|register
name|struct
name|table
modifier|*
name|table
decl_stmt|;
name|table
operator|=
name|atable
expr_stmt|;
name|recurf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg
operator|<
literal|0
condition|)
block|{
name|recurf
operator|++
expr_stmt|;
name|reg
operator|=
operator|~
name|reg
expr_stmt|;
if|if
condition|(
name|reg
operator|>=
literal|020
condition|)
block|{
name|reg
operator|=
operator|-
literal|020
expr_stmt|;
name|recurf
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|tree
operator|=
name|atree
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|tree
operator|->
name|op
condition|)
block|{
comment|/* 	 * A conditional branch 	 */
case|case
name|CBRANCH
case|:
name|cbranch
argument_list|(
name|optim
argument_list|(
name|tree
operator|->
name|btree
argument_list|)
argument_list|,
name|tree
operator|->
name|lbl
argument_list|,
name|tree
operator|->
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * An initializing expression 	 */
case|case
name|INIT
case|:
if|if
condition|(
name|tree
operator|->
name|tr1
operator|->
name|op
operator|==
name|AMPER
condition|)
name|tree
operator|->
name|tr1
operator|=
name|tree
operator|->
name|tr1
operator|->
name|tr1
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|tr1
operator|->
name|op
operator|==
name|NAME
condition|)
name|pname
argument_list|(
name|tree
operator|->
name|tr1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tree
operator|->
name|tr1
operator|==
name|CON
condition|)
name|psoct
argument_list|(
name|tree
operator|->
name|tr1
operator|->
name|value
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Illegal initialization"
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Put the value of an expression in r0, 	 * for a switch or a return 	 */
case|case
name|RFORCE
case|:
if|if
condition|(
operator|(
name|r
operator|=
name|rcexpr
argument_list|(
name|tree
operator|->
name|tr1
argument_list|,
name|regtab
argument_list|,
name|reg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"mov%c	r%d,r0\n"
argument_list|,
name|isfloat
argument_list|(
name|tree
operator|->
name|tr1
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * sequential execution 	 */
case|case
name|COMMA
case|:
name|rcexpr
argument_list|(
name|tree
operator|->
name|tr1
argument_list|,
name|efftab
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|atree
operator|=
name|tree
operator|=
name|tree
operator|->
name|tr2
expr_stmt|;
break|break;
comment|/* 	 * In the generated&~ operator, 	 * fiddle things so a PDP-11 "bit" 	 * instruction will be produced when cctab is used. 	 */
case|case
name|NAND
case|:
if|if
condition|(
name|table
operator|==
name|cctab
condition|)
block|{
name|tree
operator|->
name|op
operator|=
name|TAND
expr_stmt|;
name|tree
operator|->
name|tr2
operator|=
name|optim
argument_list|(
name|block
argument_list|(
literal|1
argument_list|,
name|COMPL
argument_list|,
name|INT
argument_list|,
literal|0
argument_list|,
name|tree
operator|->
name|tr2
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Handle a subroutine call. It has to be done 	 * here because if cexpr got called twice, the 	 * arguments might be compiled twice. 	 * There is also some fiddling so the 	 * first argument, in favorable circumstances, 	 * goes to (sp) instead of -(sp), reducing 	 * the amount of stack-popping. 	 */
case|case
name|CALL
case|:
name|r
operator|=
literal|0
expr_stmt|;
name|nargs
operator|=
literal|0
expr_stmt|;
name|modf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|tr1
operator|->
name|op
operator|!=
name|NAME
condition|)
block|{
comment|/* get nargs right */
name|nargs
operator|++
expr_stmt|;
name|nstack
operator|++
expr_stmt|;
block|}
name|tree
operator|=
name|tree
operator|->
name|tr2
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|op
condition|)
block|{
while|while
condition|(
name|tree
operator|->
name|op
operator|==
name|COMMA
condition|)
block|{
name|r
operator|=
operator|+
name|comarg
argument_list|(
name|tree
operator|->
name|tr2
argument_list|,
operator|&
name|modf
argument_list|)
expr_stmt|;
name|tree
operator|=
name|tree
operator|->
name|tr1
expr_stmt|;
name|nargs
operator|++
expr_stmt|;
block|}
name|r
operator|=
operator|+
name|comarg
argument_list|(
name|tree
argument_list|,
operator|&
name|modf
argument_list|)
expr_stmt|;
name|nargs
operator|++
expr_stmt|;
block|}
name|tree
operator|=
name|atree
expr_stmt|;
name|tree
operator|->
name|op
operator|=
name|CALL2
expr_stmt|;
if|if
condition|(
name|modf
operator|&&
name|tree
operator|->
name|tr1
operator|->
name|op
operator|==
name|NAME
operator|&&
name|tree
operator|->
name|tr1
operator|->
name|class
operator|==
name|EXTERN
condition|)
name|tree
operator|->
name|op
operator|=
name|CALL1
expr_stmt|;
name|cexpr
argument_list|(
name|tree
argument_list|,
name|regtab
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|popstk
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|nstack
operator|=
operator|-
name|nargs
expr_stmt|;
if|if
condition|(
name|table
operator|==
name|efftab
operator|||
name|table
operator|==
name|regtab
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|r
operator|=
literal|0
expr_stmt|;
goto|goto
name|fixup
goto|;
comment|/* 	 * Longs need special treatment. 	 */
case|case
name|ASLSH
case|:
case|case
name|LSHIFT
case|:
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|LONG
condition|)
block|{
if|if
condition|(
name|tree
operator|->
name|tr2
operator|->
name|op
operator|==
name|ITOL
condition|)
name|tree
operator|->
name|tr2
operator|=
name|tree
operator|->
name|tr2
operator|->
name|tr1
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|op
operator|==
name|ASLSH
condition|)
name|tree
operator|->
name|op
operator|=
name|ASLSHL
expr_stmt|;
else|else
name|tree
operator|->
name|op
operator|=
name|LLSHIFT
expr_stmt|;
block|}
break|break;
comment|/* 	 * Try to change * and / to shifts. 	 */
case|case
name|TIMES
case|:
case|case
name|DIVIDE
case|:
case|case
name|ASTIMES
case|:
case|case
name|ASDIV
case|:
name|tree
operator|=
name|pow2
argument_list|(
name|tree
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Try to find postfix ++ and -- operators that can be 	 * pulled out and done after the rest of the expression 	 */
if|if
condition|(
name|table
operator|!=
name|cctab
operator|&&
name|table
operator|!=
name|cregtab
operator|&&
name|recurf
operator|<
literal|2
operator|&&
operator|(
name|opdope
index|[
name|tree
operator|->
name|op
index|]
operator|&
name|LEAF
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|=
name|delay
argument_list|(
operator|&
name|atree
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
condition|)
block|{
name|tree
operator|=
name|atree
expr_stmt|;
name|table
operator|=
name|efftab
expr_stmt|;
name|reg
operator|=
name|r
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Basically, try to reorder the computation 	 * so  reg = x+y  is done as  reg = x; reg =+ y 	 */
if|if
condition|(
name|recurf
operator|==
literal|0
operator|&&
name|reorder
argument_list|(
operator|&
name|atree
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
condition|)
block|{
if|if
condition|(
name|table
operator|==
name|cctab
operator|&&
name|atree
operator|->
name|op
operator|==
name|NAME
condition|)
return|return
operator|(
name|reg
operator|)
return|;
block|}
name|tree
operator|=
name|atree
expr_stmt|;
if|if
condition|(
name|table
operator|==
name|efftab
operator|&&
name|tree
operator|->
name|op
operator|==
name|NAME
condition|)
return|return
operator|(
name|reg
operator|)
return|;
if|if
condition|(
operator|(
name|r
operator|=
name|cexpr
argument_list|(
name|tree
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
if|if
condition|(
name|table
operator|!=
name|regtab
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|cexpr
argument_list|(
name|tree
argument_list|,
name|regtab
argument_list|,
name|reg
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|fixup
label|:
name|modf
operator|=
name|isfloat
argument_list|(
name|tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|==
name|sptab
operator|||
name|table
operator|==
name|lsptab
condition|)
block|{
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|LONG
condition|)
block|{
name|printf
argument_list|(
literal|"mov\tr%d,-(sp)\n"
argument_list|,
name|r
operator|+
literal|1
argument_list|)
expr_stmt|;
name|nstack
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"mov%c	r%d,%c(sp)\n"
argument_list|,
name|modf
argument_list|,
name|r
argument_list|,
name|table
operator|==
name|sptab
condition|?
literal|'-'
else|:
literal|0
argument_list|)
expr_stmt|;
name|nstack
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|table
operator|==
name|cctab
condition|)
name|printf
argument_list|(
literal|"tst%c	r%d\n"
argument_list|,
name|modf
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
block|}
if|if
condition|(
name|tree
operator|->
name|op
operator|>
literal|0
operator|&&
name|tree
operator|->
name|op
operator|<
name|RFORCE
operator|&&
name|opntab
index|[
name|tree
operator|->
name|op
index|]
condition|)
name|error
argument_list|(
literal|"No code table for op: %s"
argument_list|,
name|opntab
index|[
name|tree
operator|->
name|op
index|]
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"No code table for op %d"
argument_list|,
name|tree
operator|->
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|reg
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Try to compile the tree with the code table using  * registers areg and up.  If successful,  * return the register where the value actually ended up.  * If unsuccessful, return -1.  *  * Most of the work is the macro-expansion of the  * code table.  */
end_comment

begin_macro
name|cexpr
argument_list|(
argument|atree
argument_list|,
argument|table
argument_list|,
argument|areg
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|atree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|table
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|,
name|r
decl_stmt|;
specifier|register
name|struct
name|tnode
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|tree
decl_stmt|;
name|struct
name|table
modifier|*
name|ctable
decl_stmt|;
name|struct
name|tnode
modifier|*
name|p2
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|reg
decl_stmt|,
name|reg1
decl_stmt|,
name|rreg
decl_stmt|,
name|flag
decl_stmt|,
name|opd
decl_stmt|;
name|char
modifier|*
name|opt
decl_stmt|;
name|tree
operator|=
name|atree
expr_stmt|;
name|reg
operator|=
name|areg
expr_stmt|;
name|p1
operator|=
name|tree
operator|->
name|tr2
expr_stmt|;
name|c
operator|=
name|tree
operator|->
name|op
expr_stmt|;
name|opd
operator|=
name|opdope
index|[
name|c
index|]
expr_stmt|;
comment|/* 	 * When the value of a relational or a logical expression is 	 * desired, more work must be done. 	 */
if|if
condition|(
operator|(
name|opd
operator|&
name|RELAT
operator|||
name|c
operator|==
name|LOGAND
operator|||
name|c
operator|==
name|LOGOR
operator|||
name|c
operator|==
name|EXCLA
operator|)
operator|&&
name|table
operator|!=
name|cctab
condition|)
block|{
name|cbranch
argument_list|(
name|tree
argument_list|,
name|c
operator|=
name|isn
operator|++
argument_list|,
literal|1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|rcexpr
argument_list|(
operator|&
name|czero
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|branch
argument_list|(
name|isn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|rcexpr
argument_list|(
operator|&
name|cone
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|label
argument_list|(
name|isn
operator|++
argument_list|)
expr_stmt|;
return|return
operator|(
name|reg
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
name|QUEST
condition|)
block|{
if|if
condition|(
name|table
operator|==
name|cctab
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cbranch
argument_list|(
name|tree
operator|->
name|tr1
argument_list|,
name|c
operator|=
name|isn
operator|++
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|flag
operator|=
name|nstack
expr_stmt|;
name|rreg
operator|=
name|rcexpr
argument_list|(
name|p1
operator|->
name|tr1
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|nstack
operator|=
name|flag
expr_stmt|;
name|branch
argument_list|(
name|r
operator|=
name|isn
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|label
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|reg
operator|=
name|rcexpr
argument_list|(
name|p1
operator|->
name|tr2
argument_list|,
name|table
argument_list|,
name|rreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rreg
operator|!=
name|reg
condition|)
name|printf
argument_list|(
literal|"mov%c	r%d,r%d\n"
argument_list|,
name|isfloat
argument_list|(
name|tree
argument_list|)
argument_list|,
name|reg
argument_list|,
name|rreg
argument_list|)
expr_stmt|;
name|label
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|rreg
operator|)
return|;
block|}
name|reg
operator|=
name|oddreg
argument_list|(
name|tree
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg1
operator|=
name|reg
operator|+
literal|1
expr_stmt|;
comment|/* 	 * long values take 2 registers. 	 */
if|if
condition|(
name|tree
operator|->
name|type
operator|==
name|LONG
operator|&&
name|tree
operator|->
name|op
operator|!=
name|ITOL
condition|)
name|reg1
operator|++
expr_stmt|;
comment|/* 	 * Leaves of the expression tree 	 */
if|if
condition|(
operator|(
name|r
operator|=
name|chkleaf
argument_list|(
name|tree
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* 	 * x + (-1) is better done as x-1. 	 */
if|if
condition|(
operator|(
name|tree
operator|->
name|op
operator|==
name|PLUS
operator|||
name|tree
operator|->
name|op
operator|==
name|ASPLUS
operator|)
operator|&&
operator|(
name|p1
operator|=
name|tree
operator|->
name|tr2
operator|)
operator|->
name|op
operator|==
name|CON
operator|&&
name|p1
operator|->
name|value
operator|==
operator|-
literal|1
condition|)
block|{
name|p1
operator|->
name|value
operator|=
literal|1
expr_stmt|;
name|tree
operator|->
name|op
operator|=
operator|+
operator|(
name|MINUS
operator|-
name|PLUS
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|table
operator|==
name|cregtab
condition|)
name|table
operator|=
name|regtab
expr_stmt|;
comment|/* 	 * The following peculiar code depends on the fact that 	 * if you just want the codition codes set, efftab 	 * will generate the right code unless the operator is 	 * postfix ++ or --. Unravelled, if the table is 	 * cctab and the operator is not special, try first 	 * for efftab;  if the table isn't, if the operator is, 	 * or the first match fails, try to match 	 * with the table actually asked for. 	 */
if|if
condition|(
name|table
operator|!=
name|cctab
operator|||
name|c
operator|==
name|INCAFT
operator|||
name|c
operator|==
name|DECAFT
operator|||
operator|(
name|opt
operator|=
name|match
argument_list|(
name|tree
argument_list|,
name|efftab
argument_list|,
name|nreg
operator|-
name|reg
argument_list|)
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|opt
operator|=
name|match
argument_list|(
name|tree
argument_list|,
name|table
argument_list|,
name|nreg
operator|-
name|reg
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|string
operator|=
name|opt
operator|->
name|tabstring
expr_stmt|;
name|p1
operator|=
name|tree
operator|->
name|tr1
expr_stmt|;
name|p2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opdope
index|[
name|tree
operator|->
name|op
index|]
operator|&
name|BINARY
condition|)
name|p2
operator|=
name|tree
operator|->
name|tr2
expr_stmt|;
name|loop
label|:
comment|/* 	 * The 0200 bit asks for a tab. 	 */
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|string
operator|++
operator|)
operator|&
literal|0200
condition|)
block|{
name|c
operator|=
operator|&
literal|0177
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\0'
case|:
if|if
condition|(
operator|!
name|isfloat
argument_list|(
name|tree
argument_list|)
condition|)
if|if
condition|(
name|tree
operator|->
name|op
operator|==
name|DIVIDE
operator|||
name|tree
operator|->
name|op
operator|==
name|ASDIV
condition|)
name|reg
operator|--
expr_stmt|;
return|return
operator|(
name|reg
operator|)
return|;
comment|/* A1 */
case|case
literal|'A'
case|:
name|p
operator|=
name|p1
expr_stmt|;
goto|goto
name|adr
goto|;
comment|/* A2 */
case|case
literal|'B'
case|:
name|p
operator|=
name|p2
expr_stmt|;
goto|goto
name|adr
goto|;
name|adr
label|:
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'\''
condition|)
block|{
name|c
operator|=
literal|1
expr_stmt|;
name|string
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|string
operator|==
literal|'+'
condition|)
block|{
name|c
operator|=
literal|2
expr_stmt|;
name|string
operator|++
expr_stmt|;
block|}
name|pname
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
comment|/* I */
case|case
literal|'M'
case|:
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|string
operator|)
operator|==
literal|'\''
condition|)
name|string
operator|++
expr_stmt|;
else|else
name|c
operator|=
literal|0
expr_stmt|;
name|prins
argument_list|(
name|tree
operator|->
name|op
argument_list|,
name|c
argument_list|,
name|instab
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
comment|/* B1 */
case|case
literal|'C'
case|:
if|if
condition|(
operator|(
name|opd
operator|&
name|LEAF
operator|)
operator|!=
literal|0
condition|)
name|p
operator|=
name|tree
expr_stmt|;
else|else
name|p
operator|=
name|p1
expr_stmt|;
goto|goto
name|pbyte
goto|;
comment|/* BF */
case|case
literal|'P'
case|:
name|p
operator|=
name|tree
expr_stmt|;
goto|goto
name|pb1
goto|;
comment|/* B2 */
case|case
literal|'D'
case|:
name|p
operator|=
name|p2
expr_stmt|;
name|pbyte
label|:
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|CHAR
condition|)
name|putchar
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
name|pb1
label|:
if|if
condition|(
name|isfloat
argument_list|(
name|p
argument_list|)
condition|)
name|putchar
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
comment|/* BE */
case|case
literal|'L'
case|:
if|if
condition|(
name|p1
operator|->
name|type
operator|==
name|CHAR
operator|||
name|p2
operator|->
name|type
operator|==
name|CHAR
condition|)
name|putchar
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
name|p
operator|=
name|tree
expr_stmt|;
goto|goto
name|pb1
goto|;
comment|/* F */
case|case
literal|'G'
case|:
name|p
operator|=
name|p1
expr_stmt|;
name|flag
operator|=
literal|01
expr_stmt|;
goto|goto
name|subtre
goto|;
comment|/* S */
case|case
literal|'K'
case|:
name|p
operator|=
name|p2
expr_stmt|;
name|flag
operator|=
literal|02
expr_stmt|;
goto|goto
name|subtre
goto|;
comment|/* H */
case|case
literal|'H'
case|:
name|p
operator|=
name|tree
expr_stmt|;
name|flag
operator|=
literal|04
expr_stmt|;
name|subtre
label|:
name|ctable
operator|=
name|regtab
expr_stmt|;
name|c
operator|=
operator|*
name|string
operator|++
operator|-
literal|'A'
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'!'
condition|)
block|{
name|string
operator|++
expr_stmt|;
name|c
operator|=
operator||
literal|020
expr_stmt|;
comment|/* force right register */
block|}
if|if
condition|(
operator|(
name|c
operator|&
literal|02
operator|)
operator|!=
literal|0
condition|)
name|ctable
operator|=
name|sptab
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
literal|04
operator|)
operator|!=
literal|0
condition|)
name|ctable
operator|=
name|cctab
expr_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
literal|01
operator|)
operator|&&
name|ctable
operator|==
name|regtab
operator|&&
operator|(
name|c
operator|&
literal|01
operator|)
operator|==
literal|0
operator|&&
operator|(
name|tree
operator|->
name|op
operator|==
name|DIVIDE
operator|||
name|tree
operator|->
name|op
operator|==
name|MOD
operator|||
name|tree
operator|->
name|op
operator|==
name|ASDIV
operator|||
name|tree
operator|->
name|op
operator|==
name|ASMOD
operator|)
condition|)
name|ctable
operator|=
name|cregtab
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
literal|01
operator|)
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|tr1
expr_stmt|;
if|if
condition|(
name|collcon
argument_list|(
name|p
argument_list|)
operator|&&
name|ctable
operator|!=
name|sptab
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|STAR
condition|)
name|p
operator|=
name|p
operator|->
name|tr1
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|tr1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|table
operator|==
name|lsptab
operator|&&
name|ctable
operator|==
name|sptab
condition|)
name|ctable
operator|=
name|lsptab
expr_stmt|;
if|if
condition|(
name|c
operator|&
literal|010
condition|)
name|r
operator|=
name|reg1
expr_stmt|;
elseif|else
if|if
condition|(
name|opdope
index|[
name|p
operator|->
name|op
index|]
operator|&
name|LEAF
operator|||
name|p
operator|->
name|degree
operator|<
literal|2
condition|)
name|r
operator|=
name|reg
expr_stmt|;
else|else
name|r
operator|=
name|areg
expr_stmt|;
name|rreg
operator|=
name|rcexpr
argument_list|(
name|p
argument_list|,
name|ctable
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctable
operator|!=
name|regtab
operator|&&
name|ctable
operator|!=
name|cregtab
condition|)
goto|goto
name|loop
goto|;
if|if
condition|(
name|c
operator|&
literal|010
condition|)
block|{
if|if
condition|(
name|c
operator|&
literal|020
operator|&&
name|rreg
operator|!=
name|reg1
condition|)
name|printf
argument_list|(
literal|"mov%c	r%d,r%d\n"
argument_list|,
name|isfloat
argument_list|(
name|tree
argument_list|)
argument_list|,
name|rreg
argument_list|,
name|reg1
argument_list|)
expr_stmt|;
else|else
name|reg1
operator|=
name|rreg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rreg
operator|!=
name|reg
condition|)
if|if
condition|(
operator|(
name|c
operator|&
literal|020
operator|)
operator|==
literal|0
operator|&&
name|oddreg
argument_list|(
name|tree
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|flag
operator|&
literal|04
operator|||
name|flag
operator|&
literal|01
operator|&&
name|xdcalc
argument_list|(
name|p2
argument_list|,
name|nreg
operator|-
name|rreg
operator|-
literal|1
argument_list|)
operator|<=
operator|(
name|opt
operator|->
name|tabdeg2
operator|&
literal|077
operator|)
operator|||
name|flag
operator|&
literal|02
operator|&&
name|xdcalc
argument_list|(
name|p1
argument_list|,
name|nreg
operator|-
name|rreg
operator|-
literal|1
argument_list|)
operator|<=
operator|(
name|opt
operator|->
name|tabdeg1
operator|&
literal|077
operator|)
operator|)
condition|)
block|{
name|reg
operator|=
name|rreg
expr_stmt|;
name|reg1
operator|=
name|rreg
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"mov%c\tr%d,r%d\n"
argument_list|,
name|isfloat
argument_list|(
name|tree
argument_list|)
argument_list|,
name|rreg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
comment|/* R */
case|case
literal|'I'
case|:
name|r
operator|=
name|reg
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'-'
condition|)
block|{
name|string
operator|++
expr_stmt|;
name|r
operator|--
expr_stmt|;
block|}
goto|goto
name|preg
goto|;
comment|/* R1 */
case|case
literal|'J'
case|:
name|r
operator|=
name|reg1
expr_stmt|;
name|preg
label|:
if|if
condition|(
operator|*
name|string
operator|==
literal|'+'
condition|)
block|{
name|string
operator|++
expr_stmt|;
name|r
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|>
name|nreg
condition|)
name|error
argument_list|(
literal|"Register overflow: simplify expression"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"r%d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|'-'
case|:
comment|/* check -(sp) */
if|if
condition|(
operator|*
name|string
operator|==
literal|'('
condition|)
block|{
name|nstack
operator|++
expr_stmt|;
if|if
condition|(
name|table
operator|!=
name|lsptab
condition|)
name|putchar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
break|break;
case|case
literal|')'
case|:
comment|/* check (sp)+ */
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'+'
condition|)
name|nstack
operator|--
expr_stmt|;
goto|goto
name|loop
goto|;
comment|/* #1 */
case|case
literal|'#'
case|:
name|p
operator|=
name|p1
operator|->
name|tr1
expr_stmt|;
goto|goto
name|nmbr
goto|;
comment|/* #2 */
case|case
literal|'"'
case|:
name|p
operator|=
name|p2
operator|->
name|tr1
expr_stmt|;
name|nmbr
label|:
if|if
condition|(
name|collcon
argument_list|(
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|STAR
condition|)
block|{
name|printf
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|tr1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|p
operator|->
name|tr2
operator|)
operator|->
name|op
operator|==
name|CON
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|value
condition|)
name|psoct
argument_list|(
name|p
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|AMPER
condition|)
name|pname
argument_list|(
name|p
operator|->
name|tr1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
goto|goto
name|loop
goto|;
case|case
literal|'T'
case|:
comment|/* "tst R" if 1st op not in cctab */
if|if
condition|(
name|dcalc
argument_list|(
name|p1
argument_list|,
literal|5
argument_list|)
operator|>
literal|12
operator|&&
operator|!
name|match
argument_list|(
name|p1
argument_list|,
name|cctab
argument_list|,
literal|10
argument_list|)
condition|)
name|printf
argument_list|(
literal|"tst	r%d\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
case|case
literal|'V'
case|:
comment|/* adc or sbc as required for longs */
switch|switch
condition|(
name|tree
operator|->
name|op
condition|)
block|{
case|case
name|PLUS
case|:
case|case
name|ASPLUS
case|:
case|case
name|INCBEF
case|:
case|case
name|INCAFT
case|:
name|printf
argument_list|(
literal|"adc"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
case|case
name|ASMINUS
case|:
case|case
name|NEG
case|:
case|case
name|DECBEF
case|:
case|case
name|DECAFT
case|:
name|printf
argument_list|(
literal|"sbc"
argument_list|)
expr_stmt|;
break|break;
default|default:
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|string
operator|++
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
empty_stmt|;
break|break;
block|}
goto|goto
name|loop
goto|;
block|}
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
end_block

begin_comment
comment|/*  * This routine just calls sreorder (below)  * on the subtrees and then on the tree itself.  * It returns non-zero if anything changed.  */
end_comment

begin_macro
name|reorder
argument_list|(
argument|treep
argument_list|,
argument|table
argument_list|,
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
modifier|*
name|treep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|table
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|r
operator|,
name|r1
expr_stmt|;
specifier|register
name|struct
name|tnode
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|*
name|treep
expr_stmt|;
if|if
condition|(
name|opdope
index|[
name|p
operator|->
name|op
index|]
operator|&
name|LEAF
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|r1
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sreorder
argument_list|(
operator|&
name|p
operator|->
name|tr1
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
condition|)
name|r1
operator|++
expr_stmt|;
if|if
condition|(
name|opdope
index|[
name|p
operator|->
name|op
index|]
operator|&
name|BINARY
condition|)
while|while
condition|(
name|sreorder
argument_list|(
operator|&
name|p
operator|->
name|tr2
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
condition|)
name|r1
operator|++
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sreorder
argument_list|(
name|treep
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
condition|)
name|r
operator|++
expr_stmt|;
operator|*
name|treep
operator|=
name|optim
argument_list|(
operator|*
name|treep
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Basically this routine carries out two kinds of optimization.  * First, it observes that "x + (reg = y)" where actually  * the = is any assignment op is better done as "reg=y; x+reg".  * In this case rcexpr is called to do the first part and the  * tree is modified so the name of the register  * replaces the assignment.  * Moreover, expressions like "reg = x+y" are best done as  * "reg = x; reg =+ y" (so long as "reg" and "y" are not the same!).  */
end_comment

begin_macro
name|sreorder
argument_list|(
argument|treep
argument_list|,
argument|table
argument_list|,
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
modifier|*
name|treep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|table
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tnode
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|p
operator|=
operator|*
name|treep
expr_stmt|;
if|if
condition|(
name|opdope
index|[
name|p
operator|->
name|op
index|]
operator|&
name|LEAF
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|PLUS
condition|)
if|if
condition|(
name|reorder
argument_list|(
operator|&
name|p
operator|->
name|tr2
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
condition|)
operator|*
name|treep
operator|=
name|p
operator|=
name|optim
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p
operator|->
name|tr1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|STAR
operator|||
name|p
operator|->
name|op
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|reorder
argument_list|(
operator|&
name|p
operator|->
name|tr1
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
condition|)
operator|*
name|treep
operator|=
name|p
operator|=
name|optim
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p
operator|->
name|tr1
expr_stmt|;
block|}
if|if
condition|(
name|p1
operator|->
name|op
operator|==
name|NAME
condition|)
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|ASLSH
case|:
case|case
name|ASRSH
case|:
case|case
name|ASSIGN
case|:
if|if
condition|(
name|p1
operator|->
name|class
operator|!=
name|REG
operator|||
name|isfloat
argument_list|(
name|p
operator|->
name|tr2
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|ASSIGN
condition|)
switch|switch
condition|(
name|p
operator|->
name|tr2
operator|->
name|op
condition|)
block|{
case|case
name|TIMES
case|:
case|case
name|DIVIDE
case|:
if|if
condition|(
operator|!
name|ispow2
argument_list|(
name|p
operator|->
name|tr2
argument_list|)
condition|)
break|break;
name|p
operator|->
name|tr2
operator|=
name|pow2
argument_list|(
name|p
operator|->
name|tr2
argument_list|)
expr_stmt|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|AND
case|:
case|case
name|NAND
case|:
case|case
name|OR
case|:
case|case
name|EXOR
case|:
case|case
name|LSHIFT
case|:
case|case
name|RSHIFT
case|:
name|p1
operator|=
name|p
operator|->
name|tr2
operator|->
name|tr2
expr_stmt|;
if|if
condition|(
name|xdcalc
argument_list|(
name|p1
argument_list|)
operator|>
literal|12
operator|||
name|p1
operator|->
name|op
operator|==
name|NAME
operator|&&
operator|(
name|p1
operator|->
name|nloc
operator|==
name|p
operator|->
name|tr1
operator|->
name|nloc
operator|||
name|p1
operator|->
name|regno
operator|==
name|p
operator|->
name|tr1
operator|->
name|nloc
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p1
operator|=
name|p
operator|->
name|tr2
expr_stmt|;
name|p
operator|->
name|tr2
operator|=
name|p1
operator|->
name|tr1
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|tr1
operator|->
name|op
operator|!=
name|NAME
operator|||
name|p1
operator|->
name|tr1
operator|->
name|class
operator|!=
name|REG
operator|||
name|p1
operator|->
name|tr1
operator|->
name|nloc
operator|!=
name|p
operator|->
name|tr1
operator|->
name|nloc
condition|)
name|rcexpr
argument_list|(
name|p
argument_list|,
name|efftab
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|p
operator|->
name|tr2
operator|=
name|p1
operator|->
name|tr2
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|p1
operator|->
name|op
operator|+
name|ASPLUS
operator|-
name|PLUS
expr_stmt|;
operator|*
name|treep
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
goto|goto
name|OK
goto|;
case|case
name|ASTIMES
case|:
case|case
name|ASDIV
case|:
if|if
condition|(
operator|!
name|ispow2
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ASPLUS
case|:
case|case
name|ASMINUS
case|:
case|case
name|ASSAND
case|:
case|case
name|ASSNAND
case|:
case|case
name|ASOR
case|:
case|case
name|ASXOR
case|:
case|case
name|DECBEF
case|:
case|case
name|INCBEF
case|:
name|OK
label|:
if|if
condition|(
name|table
operator|==
name|cctab
operator|||
name|table
operator|==
name|cregtab
condition|)
name|reg
operator|=
operator|+
literal|020
expr_stmt|;
name|rcexpr
argument_list|(
name|optim
argument_list|(
name|p
argument_list|)
argument_list|,
name|efftab
argument_list|,
operator|~
name|reg
argument_list|)
expr_stmt|;
operator|*
name|treep
operator|=
name|p1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Delay handles postfix ++ and --   * It observes that "x + y++" is better  * treated as "x + y; y++".  * If the operator is ++ or -- itself,  * it calls rcexpr to load the operand, letting  * the calling instance of rcexpr to do the  * ++ using efftab.  * Otherwise it uses sdelay to search for inc/dec  * among the operands.  */
end_comment

begin_macro
name|delay
argument_list|(
argument|treep
argument_list|,
argument|table
argument_list|,
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
modifier|*
name|treep
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tnode
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
specifier|register
name|r
expr_stmt|;
name|p
operator|=
operator|*
name|treep
expr_stmt|;
if|if
condition|(
name|table
operator|!=
name|efftab
operator|&&
operator|(
name|p
operator|->
name|op
operator|==
name|INCAFT
operator|||
name|p
operator|->
name|op
operator|==
name|DECAFT
operator|)
operator|&&
name|p
operator|->
name|tr1
operator|->
name|op
operator|==
name|NAME
condition|)
block|{
return|return
operator|(
literal|1
operator|+
name|rcexpr
argument_list|(
name|p
operator|->
name|tr1
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
operator|)
return|;
block|}
name|p1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opdope
index|[
name|p
operator|->
name|op
index|]
operator|&
name|BINARY
condition|)
name|p1
operator|=
name|sdelay
argument_list|(
operator|&
name|p
operator|->
name|tr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
literal|0
condition|)
name|p1
operator|=
name|sdelay
argument_list|(
operator|&
name|p
operator|->
name|tr1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
condition|)
block|{
name|r
operator|=
name|rcexpr
argument_list|(
name|optim
argument_list|(
name|p
argument_list|)
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
expr_stmt|;
operator|*
name|treep
operator|=
name|p1
expr_stmt|;
return|return
operator|(
name|r
operator|+
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|sdelay
argument_list|(
argument|ap
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tnode
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|p
operator|=
operator|*
name|ap
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|op
operator|==
name|INCAFT
operator|||
name|p
operator|->
name|op
operator|==
name|DECAFT
operator|)
operator|&&
name|p
operator|->
name|tr1
operator|->
name|op
operator|==
name|NAME
condition|)
block|{
operator|*
name|ap
operator|=
name|ncopy
argument_list|(
name|p
operator|->
name|tr1
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|STAR
operator|||
name|p
operator|->
name|op
operator|==
name|PLUS
condition|)
if|if
condition|(
name|p1
operator|=
name|sdelay
argument_list|(
operator|&
name|p
operator|->
name|tr1
argument_list|)
condition|)
return|return
operator|(
name|p1
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|PLUS
condition|)
return|return
operator|(
name|sdelay
argument_list|(
operator|&
name|p
operator|->
name|tr2
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Copy a tree node for a register variable.  * Used by sdelay because if *reg-- is turned  * into *reg; reg-- the *reg will in turn  * be changed to some offset class, accidentally  * modifying the reg--.  */
end_comment

begin_macro
name|ncopy
argument_list|(
argument|ap
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tname
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tname
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ap
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|class
operator|!=
name|REG
condition|)
return|return
operator|(
name|p
operator|)
return|;
return|return
operator|(
name|block
argument_list|(
literal|3
argument_list|,
name|NAME
argument_list|,
name|p
operator|->
name|type
argument_list|,
name|p
operator|->
name|elsize
argument_list|,
name|p
operator|->
name|tr1
argument_list|,
name|p
operator|->
name|offset
argument_list|,
name|p
operator|->
name|nloc
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * If the tree can be immediately loaded into a register,  * produce code to do so and return success.  */
end_comment

begin_macro
name|chkleaf
argument_list|(
argument|atree
argument_list|,
argument|table
argument_list|,
argument|reg
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|atree
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|tnode
name|lbuf
decl_stmt|;
specifier|register
name|struct
name|tnode
modifier|*
name|tree
decl_stmt|;
name|tree
operator|=
name|atree
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|op
operator|!=
name|STAR
operator|&&
name|dcalc
argument_list|(
name|tree
argument_list|,
name|nreg
operator|-
name|reg
argument_list|)
operator|>
literal|12
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|lbuf
operator|.
name|op
operator|=
name|LOAD
expr_stmt|;
name|lbuf
operator|.
name|type
operator|=
name|tree
operator|->
name|type
expr_stmt|;
name|lbuf
operator|.
name|degree
operator|=
name|tree
operator|->
name|degree
expr_stmt|;
name|lbuf
operator|.
name|tr1
operator|=
name|tree
expr_stmt|;
return|return
operator|(
name|rcexpr
argument_list|(
operator|&
name|lbuf
argument_list|,
name|table
argument_list|,
name|reg
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Compile a function argument.  * If the stack is currently empty, put it in (sp)  * rather than -(sp); this will save a pop.  * Return the number of bytes pushed,  * for future popping.  */
end_comment

begin_macro
name|comarg
argument_list|(
argument|atree
argument_list|,
argument|flagp
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|flagp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tnode
modifier|*
name|tree
decl_stmt|;
specifier|register
name|retval
expr_stmt|;
name|tree
operator|=
name|atree
expr_stmt|;
if|if
condition|(
name|nstack
operator|||
name|isfloat
argument_list|(
name|tree
argument_list|)
operator|||
name|tree
operator|->
name|type
operator|==
name|LONG
condition|)
block|{
name|rcexpr
argument_list|(
name|tree
argument_list|,
name|sptab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
name|arlength
argument_list|(
name|tree
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|flagp
operator|)
operator|++
expr_stmt|;
name|rcexpr
argument_list|(
name|tree
argument_list|,
name|lsptab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_block

end_unit

