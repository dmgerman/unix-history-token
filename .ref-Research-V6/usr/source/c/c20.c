begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*  *	 C object code improver  */
end_comment

begin_include
include|#
directive|include
file|"c2h.c"
end_include

begin_struct
struct|struct
name|optab
name|optab
index|[]
block|{
literal|"jbr"
operator|,
name|JBR
operator|,
literal|"jeq"
operator|,
name|CBR
operator||
name|JEQ
operator|<<
literal|8
operator|,
literal|"jne"
operator|,
name|CBR
operator||
name|JNE
operator|<<
literal|8
operator|,
literal|"jle"
operator|,
name|CBR
operator||
name|JLE
operator|<<
literal|8
operator|,
literal|"jge"
operator|,
name|CBR
operator||
name|JGE
operator|<<
literal|8
operator|,
literal|"jlt"
operator|,
name|CBR
operator||
name|JLT
operator|<<
literal|8
operator|,
literal|"jgt"
operator|,
name|CBR
operator||
name|JGT
operator|<<
literal|8
operator|,
literal|"jlo"
operator|,
name|CBR
operator||
name|JLO
operator|<<
literal|8
operator|,
literal|"jhi"
operator|,
name|CBR
operator||
name|JHI
operator|<<
literal|8
operator|,
literal|"jlos"
operator|,
name|CBR
operator||
name|JLOS
operator|<<
literal|8
operator|,
literal|"jhis"
operator|,
name|CBR
operator||
name|JHIS
operator|<<
literal|8
operator|,
literal|"jmp"
operator|,
name|JMP
operator|,
literal|".globl"
operator|,
name|EROU
operator|,
literal|"mov"
operator|,
name|MOV
operator|,
literal|"clr"
operator|,
name|CLR
operator|,
literal|"com"
operator|,
name|COM
operator|,
literal|"inc"
operator|,
name|INC
operator|,
literal|"dec"
operator|,
name|DEC
operator|,
literal|"neg"
operator|,
name|NEG
operator|,
literal|"tst"
operator|,
name|TST
operator|,
literal|"asr"
operator|,
name|ASR
operator|,
literal|"asl"
operator|,
name|ASL
operator|,
literal|"sxt"
operator|,
name|SXT
operator|,
literal|"cmp"
operator|,
name|CMP
operator|,
literal|"add"
operator|,
name|ADD
operator|,
literal|"sub"
operator|,
name|SUB
operator|,
literal|"bit"
operator|,
name|BIT
operator|,
literal|"bic"
operator|,
name|BIC
operator|,
literal|"bis"
operator|,
name|BIS
operator|,
literal|"mul"
operator|,
name|MUL
operator|,
literal|"ash"
operator|,
name|ASH
operator|,
literal|"xor"
operator|,
name|XOR
operator|,
literal|".text"
operator|,
name|TEXT
operator|,
literal|".data"
operator|,
name|DATA
operator|,
literal|".bss"
operator|,
name|BSS
operator|,
literal|".even"
operator|,
name|EVEN
operator|,
literal|"movf"
operator|,
name|MOVF
operator|,
literal|"movof"
operator|,
name|MOVOF
operator|,
literal|"movfo"
operator|,
name|MOVFO
operator|,
literal|"addf"
operator|,
name|ADDF
operator|,
literal|"subf"
operator|,
name|SUBF
operator|,
literal|"divf"
operator|,
name|DIVF
operator|,
literal|"mulf"
operator|,
name|MULF
operator|,
literal|"clrf"
operator|,
name|CLRF
operator|,
literal|"cmpf"
operator|,
name|CMPF
operator|,
literal|"negf"
operator|,
name|NEGF
operator|,
literal|"tstf"
operator|,
name|TSTF
operator|,
literal|"cfcc"
operator|,
name|CFCC
operator|,
literal|"sob"
operator|,
name|SOB
operator|,
literal|"jsr"
operator|,
name|JSR
operator|,
literal|".end"
operator|,
name|END
operator|,
literal|0
operator|,
literal|0
block|}
struct|;
end_struct

begin_decl_stmt
name|char
name|revbr
index|[]
block|{
name|JNE
operator|,
name|JEQ
operator|,
name|JGT
operator|,
name|JLT
operator|,
name|JGE
operator|,
name|JLE
operator|,
name|JHIS
operator|,
name|JLOS
operator|,
name|JHI
operator|,
name|JLO
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|int
name|isn
literal|20000
expr_stmt|;
end_expr_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|niter
decl_stmt|,
name|maxiter
decl_stmt|,
name|isend
decl_stmt|;
extern|extern end;
extern|extern fin
operator|,
extern|fout;
name|int
name|nflag
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|debug
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|nflag
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|fin
operator|=
name|open
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"C2: can't find %s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|fin
operator|=
name|dup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|fout
operator|=
name|creat
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fout
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"C2: can't create %s\n"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|fout
operator|=
name|dup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|lasta
operator|=
name|firstr
operator|=
name|lastr
operator|=
name|sbrk
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|maxiter
operator|=
literal|0
expr_stmt|;
name|opsetup
argument_list|()
expr_stmt|;
do|do
block|{
name|isend
operator|=
name|input
argument_list|()
expr_stmt|;
name|movedat
argument_list|()
expr_stmt|;
name|niter
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|refcount
argument_list|()
expr_stmt|;
do|do
block|{
name|iterate
argument_list|()
expr_stmt|;
name|clearreg
argument_list|()
expr_stmt|;
name|niter
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|nchange
condition|)
do|;
name|comjump
argument_list|()
expr_stmt|;
name|rmove
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|nchange
operator|||
name|jumpsw
argument_list|()
condition|)
do|;
name|addsob
argument_list|()
expr_stmt|;
name|output
argument_list|()
expr_stmt|;
if|if
condition|(
name|niter
operator|>
name|maxiter
condition|)
name|maxiter
operator|=
name|niter
expr_stmt|;
name|lasta
operator|=
name|firstr
expr_stmt|;
block|}
do|while
condition|(
name|isend
condition|)
do|;
name|flush
argument_list|()
expr_stmt|;
name|fout
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|nflag
condition|)
block|{
name|printf
argument_list|(
literal|"%d iterations\n"
argument_list|,
name|maxiter
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d jumps to jumps\n"
argument_list|,
name|nbrbr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d inst. after jumps\n"
argument_list|,
name|iaftbr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d jumps to .+2\n"
argument_list|,
name|njp1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d redundant labels\n"
argument_list|,
name|nrlab
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d cross-jumps\n"
argument_list|,
name|nxjump
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d code motions\n"
argument_list|,
name|ncmot
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d branches reversed\n"
argument_list|,
name|nrevbr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d redundant moves\n"
argument_list|,
name|redunm
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d simplified addresses\n"
argument_list|,
name|nsaddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d loops inverted\n"
argument_list|,
name|loopiv
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d redundant jumps\n"
argument_list|,
name|nredunj
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d common seqs before jmp's\n"
argument_list|,
name|ncomj
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d skips over jumps\n"
argument_list|,
name|nskip
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d sob's added\n"
argument_list|,
name|nsob
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d redundant tst's\n"
argument_list|,
name|nrtst
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d literals eliminated\n"
argument_list|,
name|nlit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%dK core\n"
argument_list|,
operator|(
operator|(
name|lastr
operator|+
literal|01777
operator|)
operator|>>
literal|10
operator|)
operator|&
literal|077
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|input
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|,
modifier|*
name|lastp
decl_stmt|;
specifier|register
name|int
name|op
decl_stmt|;
name|lastp
operator|=
operator|&
name|first
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|op
operator|=
name|getline
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|op
operator|.
name|op
condition|)
block|{
case|case
name|LABEL
case|:
name|p
operator|=
name|alloc
argument_list|(
sizeof|sizeof
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'L'
condition|)
block|{
name|p
operator|->
name|combop
operator|=
name|LABEL
expr_stmt|;
name|p
operator|->
name|labno
operator|=
name|getnum
argument_list|(
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|code
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|combop
operator|=
name|DLABEL
expr_stmt|;
name|p
operator|->
name|labno
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|copy
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|JBR
case|:
case|case
name|CBR
case|:
case|case
name|JMP
case|:
case|case
name|JSW
case|:
name|p
operator|=
name|alloc
argument_list|(
sizeof|sizeof
name|first
argument_list|)
expr_stmt|;
name|p
operator|->
name|combop
operator|=
name|op
expr_stmt|;
if|if
condition|(
operator|*
name|curlp
operator|==
literal|'L'
operator|&&
operator|(
name|p
operator|->
name|labno
operator|=
name|getnum
argument_list|(
name|curlp
operator|+
literal|1
argument_list|)
operator|)
condition|)
name|p
operator|->
name|code
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|p
operator|->
name|labno
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|copy
argument_list|(
name|curlp
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|p
operator|=
name|alloc
argument_list|(
sizeof|sizeof
name|first
argument_list|)
expr_stmt|;
name|p
operator|->
name|combop
operator|=
name|op
expr_stmt|;
name|p
operator|->
name|labno
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|copy
argument_list|(
name|curlp
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|->
name|forw
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|back
operator|=
name|lastp
expr_stmt|;
name|lastp
operator|->
name|forw
operator|=
name|p
expr_stmt|;
name|lastp
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|ref
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|EROU
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|op
operator|==
name|END
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|getline
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|lp
decl_stmt|;
specifier|register
name|c
expr_stmt|;
name|lp
operator|=
name|line
expr_stmt|;
while|while
condition|(
name|c
operator|=
name|getchar
argument_list|()
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|LABEL
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|oplook
argument_list|()
operator|)
return|;
block|}
operator|*
name|lp
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|END
operator|)
return|;
block|}
end_block

begin_macro
name|getnum
argument_list|(
argument|ap
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|n
operator|,
name|c
expr_stmt|;
name|p
operator|=
name|ap
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
operator|--
name|p
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_macro
name|output
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|t
decl_stmt|;
specifier|register
name|struct
name|optab
modifier|*
name|op
decl_stmt|;
specifier|register
name|int
name|byte
decl_stmt|;
name|t
operator|=
operator|&
name|first
expr_stmt|;
while|while
condition|(
name|t
operator|=
name|t
operator|->
name|forw
condition|)
switch|switch
condition|(
name|t
operator|->
name|op
condition|)
block|{
case|case
name|END
case|:
return|return;
case|case
name|LABEL
case|:
name|printf
argument_list|(
literal|"L%d:"
argument_list|,
name|t
operator|->
name|labno
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DLABEL
case|:
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|t
operator|->
name|code
argument_list|)
expr_stmt|;
continue|continue;
default|default:
if|if
condition|(
operator|(
name|byte
operator|=
name|t
operator|->
name|subop
operator|)
operator|==
name|BYTE
condition|)
name|t
operator|->
name|subop
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|op
operator|=
name|optab
init|;
name|op
operator|->
name|opstring
operator|!=
literal|0
condition|;
name|op
operator|++
control|)
if|if
condition|(
name|op
operator|->
name|opcode
operator|==
name|t
operator|->
name|combop
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|op
operator|->
name|opstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte
operator|==
name|BYTE
condition|)
name|printf
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|t
operator|->
name|code
condition|)
block|{
name|reducelit
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%s\n"
argument_list|,
name|t
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|op
operator|==
name|JBR
operator|||
name|t
operator|->
name|op
operator|==
name|CBR
condition|)
name|printf
argument_list|(
literal|"\tL%d\n"
argument_list|,
name|t
operator|->
name|labno
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|JSW
case|:
name|printf
argument_list|(
literal|"L%d\n"
argument_list|,
name|t
operator|->
name|labno
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|SOB
case|:
name|printf
argument_list|(
literal|"sob	%s,L%d\n"
argument_list|,
name|t
operator|->
name|code
argument_list|,
name|t
operator|->
name|labno
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|0
case|:
if|if
condition|(
name|t
operator|->
name|code
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|t
operator|->
name|code
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
end_block

begin_comment
comment|/*  * Notice addresses of the form  * $xx,xx(r)  * and replace them with (pc),xx(r)  *     -- Thanx and a tip of the Hatlo hat to Bliss-11.  */
end_comment

begin_macro
name|reducelit
argument_list|(
argument|at
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|node
modifier|*
name|at
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|;
name|char
modifier|*
name|c2s
decl_stmt|;
specifier|register
name|struct
name|node
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|at
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|->
name|code
operator|!=
literal|'$'
condition|)
return|return;
name|c1
operator|=
name|t
operator|->
name|code
expr_stmt|;
while|while
condition|(
operator|*
name|c1
operator|!=
literal|','
condition|)
if|if
condition|(
operator|*
name|c1
operator|++
operator|==
literal|'\0'
condition|)
return|return;
name|c2s
operator|=
name|c1
expr_stmt|;
name|c1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|c1
operator|==
literal|'*'
condition|)
name|c1
operator|++
expr_stmt|;
name|c2
operator|=
name|t
operator|->
name|code
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|c1
operator|++
operator|==
operator|*
name|c2
operator|++
condition|)
empty_stmt|;
if|if
condition|(
operator|*
operator|--
name|c1
operator|!=
literal|'('
operator|||
operator|*
operator|--
name|c2
operator|!=
literal|','
condition|)
return|return;
name|t
operator|->
name|code
operator|=
name|copy
argument_list|(
literal|"(pc)"
argument_list|,
name|c2s
argument_list|)
expr_stmt|;
name|nlit
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|copy
argument_list|(
argument|ap
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|char
modifier|*
name|onp
decl_stmt|;
specifier|register
name|n
expr_stmt|;
name|int
name|na
decl_stmt|;
name|na
operator|=
name|nargs
argument_list|()
expr_stmt|;
name|p
operator|=
name|ap
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
do|do
name|n
operator|++
expr_stmt|;
do|while
condition|(
operator|*
name|p
operator|++
condition|)
do|;
if|if
condition|(
name|na
operator|>
literal|1
condition|)
block|{
name|p
operator|=
operator|(
operator|&
name|ap
operator|)
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
condition|)
name|n
operator|++
expr_stmt|;
block|}
name|onp
operator|=
name|np
operator|=
name|alloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|p
operator|=
name|ap
expr_stmt|;
while|while
condition|(
operator|*
name|np
operator|++
operator|=
operator|*
name|p
operator|++
condition|)
empty_stmt|;
if|if
condition|(
name|na
operator|>
literal|1
condition|)
block|{
name|p
operator|=
operator|(
operator|&
name|ap
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|np
operator|--
expr_stmt|;
while|while
condition|(
operator|*
name|np
operator|++
operator|=
operator|*
name|p
operator|++
condition|)
empty_stmt|;
block|}
return|return
operator|(
name|onp
operator|)
return|;
block|}
end_block

begin_macro
name|opsetup
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|optab
modifier|*
name|optp
decl_stmt|,
modifier|*
modifier|*
name|ophp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|optp
operator|=
name|optab
init|;
name|p
operator|=
name|optp
operator|->
name|opstring
condition|;
name|optp
operator|++
control|)
block|{
name|ophp
operator|=
operator|&
name|ophash
index|[
operator|(
operator|(
operator|(
name|p
index|[
literal|0
index|]
operator|<<
literal|3
operator|)
operator|+
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|1
operator|)
operator|+
name|p
index|[
literal|2
index|]
operator|)
operator|&
literal|077777
operator|)
operator|%
name|OPHS
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|ophp
operator|++
condition|)
if|if
condition|(
name|ophp
operator|>
operator|&
name|ophash
index|[
name|OPHS
index|]
condition|)
name|ophp
operator|=
name|ophash
expr_stmt|;
operator|*
operator|--
name|ophp
operator|=
name|optp
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|oplook
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|optab
modifier|*
name|optp
decl_stmt|;
specifier|register
name|char
modifier|*
name|lp
decl_stmt|,
modifier|*
name|op
decl_stmt|;
specifier|static
name|char
name|tmpop
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|optab
modifier|*
modifier|*
name|ophp
decl_stmt|;
name|op
operator|=
name|tmpop
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|line
init|;
operator|*
name|lp
operator|&&
operator|*
name|lp
operator|!=
literal|' '
operator|&&
operator|*
name|lp
operator|!=
literal|'\t'
condition|;
control|)
operator|*
name|op
operator|++
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
operator|*
name|op
operator|++
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|==
literal|'\t'
operator|||
operator|*
name|lp
operator|==
literal|' '
condition|)
name|lp
operator|++
expr_stmt|;
name|curlp
operator|=
name|lp
expr_stmt|;
name|ophp
operator|=
operator|&
name|ophash
index|[
operator|(
operator|(
operator|(
name|tmpop
index|[
literal|0
index|]
operator|<<
literal|3
operator|)
operator|+
operator|(
name|tmpop
index|[
literal|1
index|]
operator|<<
literal|1
operator|)
operator|+
name|tmpop
index|[
literal|2
index|]
operator|)
operator|&
literal|077777
operator|)
operator|%
name|OPHS
index|]
expr_stmt|;
while|while
condition|(
name|optp
operator|=
operator|*
name|ophp
condition|)
block|{
name|op
operator|=
name|optp
operator|->
name|opstring
expr_stmt|;
name|lp
operator|=
name|tmpop
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|==
operator|*
name|op
operator|++
condition|)
if|if
condition|(
operator|*
name|lp
operator|++
operator|==
literal|0
condition|)
return|return
operator|(
name|optp
operator|->
name|opcode
operator|)
return|;
if|if
condition|(
operator|*
name|lp
operator|++
operator|==
literal|'b'
operator|&&
operator|*
name|lp
operator|++
operator|==
literal|0
operator|&&
operator|*
operator|--
name|op
operator|==
literal|0
condition|)
return|return
operator|(
name|optp
operator|->
name|opcode
operator|+
operator|(
name|BYTE
operator|<<
literal|8
operator|)
operator|)
return|;
name|ophp
operator|++
expr_stmt|;
if|if
condition|(
name|ophp
operator|>=
operator|&
name|ophash
index|[
name|OPHS
index|]
condition|)
name|ophp
operator|=
name|ophash
expr_stmt|;
block|}
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'L'
condition|)
block|{
name|lp
operator|=
operator|&
name|line
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|lp
condition|)
if|if
condition|(
operator|*
name|lp
operator|<
literal|'0'
operator|||
operator|*
name|lp
operator|++
operator|>
literal|'9'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|curlp
operator|=
name|line
expr_stmt|;
return|return
operator|(
name|JSW
operator|)
return|;
block|}
name|curlp
operator|=
name|line
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|refcount
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
specifier|static
name|struct
name|node
modifier|*
name|labhash
index|[
name|LABHS
index|]
decl_stmt|;
specifier|register
name|struct
name|node
modifier|*
modifier|*
name|hp
decl_stmt|;
for|for
control|(
name|hp
operator|=
name|labhash
init|;
name|hp
operator|<
operator|&
name|labhash
index|[
name|LABHS
index|]
condition|;
control|)
operator|*
name|hp
operator|++
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|first
operator|.
name|forw
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|forw
control|)
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|LABEL
condition|)
block|{
name|labhash
index|[
name|p
operator|->
name|labno
operator|%
name|LABHS
index|]
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|refc
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|first
operator|.
name|forw
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|forw
control|)
block|{
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|JBR
operator|||
name|p
operator|->
name|op
operator|==
name|CBR
operator|||
name|p
operator|->
name|op
operator|==
name|JSW
condition|)
block|{
name|p
operator|->
name|ref
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
name|labhash
index|[
name|p
operator|->
name|labno
operator|%
name|LABHS
index|]
expr_stmt|;
if|if
condition|(
name|lp
operator|==
literal|0
operator|||
name|p
operator|->
name|labno
operator|!=
name|lp
operator|->
name|labno
condition|)
for|for
control|(
name|lp
operator|=
name|first
operator|.
name|forw
init|;
name|lp
operator|!=
literal|0
condition|;
name|lp
operator|=
name|lp
operator|->
name|forw
control|)
block|{
if|if
condition|(
name|lp
operator|->
name|op
operator|==
name|LABEL
operator|&&
name|p
operator|->
name|labno
operator|==
name|lp
operator|->
name|labno
condition|)
break|break;
block|}
if|if
condition|(
name|lp
condition|)
block|{
name|hp
operator|=
name|nonlab
argument_list|(
name|lp
argument_list|)
operator|->
name|back
expr_stmt|;
if|if
condition|(
name|hp
operator|!=
name|lp
condition|)
block|{
name|p
operator|->
name|labno
operator|=
name|hp
operator|->
name|labno
expr_stmt|;
name|lp
operator|=
name|hp
expr_stmt|;
block|}
name|p
operator|->
name|ref
operator|=
name|lp
expr_stmt|;
name|lp
operator|->
name|refc
operator|++
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|p
operator|=
name|first
operator|.
name|forw
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|forw
control|)
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|LABEL
operator|&&
name|p
operator|->
name|refc
operator|==
literal|0
operator|&&
operator|(
name|lp
operator|=
name|nonlab
argument_list|(
name|p
argument_list|)
operator|)
operator|->
name|op
operator|&&
name|lp
operator|->
name|op
operator|!=
name|JSW
condition|)
name|decref
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|iterate
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|,
modifier|*
name|rp
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|nchange
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|first
operator|.
name|forw
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|forw
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|->
name|op
operator|==
name|JBR
operator|||
name|p
operator|->
name|op
operator|==
name|CBR
operator|||
name|p
operator|->
name|op
operator|==
name|JSW
operator|)
operator|&&
name|p
operator|->
name|ref
condition|)
block|{
name|rp
operator|=
name|nonlab
argument_list|(
name|p
operator|->
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|op
operator|==
name|JBR
operator|&&
name|rp
operator|->
name|labno
operator|&&
name|p
operator|!=
name|rp
condition|)
block|{
name|nbrbr
operator|++
expr_stmt|;
name|p
operator|->
name|labno
operator|=
name|rp
operator|->
name|labno
expr_stmt|;
name|decref
argument_list|(
name|p
operator|->
name|ref
argument_list|)
expr_stmt|;
name|rp
operator|->
name|ref
operator|->
name|refc
operator|++
expr_stmt|;
name|p
operator|->
name|ref
operator|=
name|rp
operator|->
name|ref
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|CBR
operator|&&
operator|(
name|p1
operator|=
name|p
operator|->
name|forw
operator|)
operator|->
name|op
operator|==
name|JBR
condition|)
block|{
name|rp
operator|=
name|p
operator|->
name|ref
expr_stmt|;
do|do
name|rp
operator|=
name|rp
operator|->
name|back
expr_stmt|;
do|while
condition|(
name|rp
operator|->
name|op
operator|==
name|LABEL
condition|)
do|;
if|if
condition|(
name|rp
operator|==
name|p1
condition|)
block|{
name|decref
argument_list|(
name|p
operator|->
name|ref
argument_list|)
expr_stmt|;
name|p
operator|->
name|ref
operator|=
name|p1
operator|->
name|ref
expr_stmt|;
name|p
operator|->
name|labno
operator|=
name|p1
operator|->
name|labno
expr_stmt|;
name|p1
operator|->
name|forw
operator|->
name|back
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|forw
operator|=
name|p1
operator|->
name|forw
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|revbr
index|[
name|p
operator|->
name|subop
index|]
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
name|nskip
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|JBR
operator|||
name|p
operator|->
name|op
operator|==
name|JMP
condition|)
block|{
while|while
condition|(
name|p
operator|->
name|forw
operator|&&
name|p
operator|->
name|forw
operator|->
name|op
operator|!=
name|LABEL
operator|&&
name|p
operator|->
name|forw
operator|->
name|op
operator|!=
name|EROU
operator|&&
name|p
operator|->
name|forw
operator|->
name|op
operator|!=
name|END
condition|)
block|{
name|nchange
operator|++
expr_stmt|;
name|iaftbr
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|forw
operator|->
name|ref
condition|)
name|decref
argument_list|(
name|p
operator|->
name|forw
operator|->
name|ref
argument_list|)
expr_stmt|;
name|p
operator|->
name|forw
operator|=
name|p
operator|->
name|forw
operator|->
name|forw
expr_stmt|;
name|p
operator|->
name|forw
operator|->
name|back
operator|=
name|p
expr_stmt|;
block|}
name|rp
operator|=
name|p
operator|->
name|forw
expr_stmt|;
while|while
condition|(
name|rp
operator|&&
name|rp
operator|->
name|op
operator|==
name|LABEL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|ref
operator|==
name|rp
condition|)
block|{
name|p
operator|->
name|back
operator|->
name|forw
operator|=
name|p
operator|->
name|forw
expr_stmt|;
name|p
operator|->
name|forw
operator|->
name|back
operator|=
name|p
operator|->
name|back
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|back
expr_stmt|;
name|decref
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
name|njp1
operator|++
expr_stmt|;
break|break;
block|}
name|rp
operator|=
name|rp
operator|->
name|forw
expr_stmt|;
block|}
name|xjump
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|codemove
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|xjump
argument_list|(
argument|ap
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|p3
decl_stmt|;
name|int
name|nxj
decl_stmt|;
name|nxj
operator|=
literal|0
expr_stmt|;
name|p1
operator|=
name|ap
expr_stmt|;
if|if
condition|(
operator|(
name|p2
operator|=
name|p1
operator|->
name|ref
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|(
name|p1
operator|=
name|p1
operator|->
name|back
operator|)
operator|&&
name|p1
operator|->
name|op
operator|==
name|LABEL
condition|)
empty_stmt|;
while|while
condition|(
operator|(
name|p2
operator|=
name|p2
operator|->
name|back
operator|)
operator|&&
name|p2
operator|->
name|op
operator|==
name|LABEL
condition|)
empty_stmt|;
if|if
condition|(
operator|!
name|equop
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
operator|||
name|p1
operator|==
name|p2
condition|)
return|return
operator|(
name|nxj
operator|)
return|;
name|p3
operator|=
name|insertl
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|p1
operator|->
name|combop
operator|=
name|JBR
expr_stmt|;
name|p1
operator|->
name|ref
operator|=
name|p3
expr_stmt|;
name|p1
operator|->
name|labno
operator|=
name|p3
operator|->
name|labno
expr_stmt|;
name|p1
operator|->
name|code
operator|=
literal|0
expr_stmt|;
name|nxj
operator|++
expr_stmt|;
name|nxjump
operator|++
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|insertl
argument_list|(
argument|ap
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|node
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|lp
decl_stmt|,
modifier|*
name|op
decl_stmt|;
name|op
operator|=
name|ap
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|op
operator|==
name|LABEL
condition|)
block|{
name|op
operator|->
name|refc
operator|++
expr_stmt|;
return|return
operator|(
name|op
operator|)
return|;
block|}
if|if
condition|(
name|op
operator|->
name|back
operator|->
name|op
operator|==
name|LABEL
condition|)
block|{
name|op
operator|=
name|op
operator|->
name|back
expr_stmt|;
name|op
operator|->
name|refc
operator|++
expr_stmt|;
return|return
operator|(
name|op
operator|)
return|;
block|}
name|lp
operator|=
name|alloc
argument_list|(
sizeof|sizeof
name|first
argument_list|)
expr_stmt|;
name|lp
operator|->
name|combop
operator|=
name|LABEL
expr_stmt|;
name|lp
operator|->
name|labno
operator|=
name|isn
operator|++
expr_stmt|;
name|lp
operator|->
name|ref
operator|=
literal|0
expr_stmt|;
name|lp
operator|->
name|code
operator|=
literal|0
expr_stmt|;
name|lp
operator|->
name|refc
operator|=
literal|1
expr_stmt|;
name|lp
operator|->
name|back
operator|=
name|op
operator|->
name|back
expr_stmt|;
name|lp
operator|->
name|forw
operator|=
name|op
expr_stmt|;
name|op
operator|->
name|back
operator|->
name|forw
operator|=
name|lp
expr_stmt|;
name|op
operator|->
name|back
operator|=
name|lp
expr_stmt|;
return|return
operator|(
name|lp
operator|)
return|;
block|}
end_block

begin_macro
name|codemove
argument_list|(
argument|ap
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|node
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|p3
decl_stmt|;
name|struct
name|node
modifier|*
name|t
decl_stmt|,
modifier|*
name|tl
decl_stmt|;
name|int
name|n
decl_stmt|;
name|p1
operator|=
name|ap
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|op
operator|!=
name|JBR
operator|||
operator|(
name|p2
operator|=
name|p1
operator|->
name|ref
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|p1
operator|)
return|;
while|while
condition|(
name|p2
operator|->
name|op
operator|==
name|LABEL
condition|)
if|if
condition|(
operator|(
name|p2
operator|=
name|p2
operator|->
name|back
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|p1
operator|)
return|;
if|if
condition|(
name|p2
operator|->
name|op
operator|!=
name|JBR
operator|&&
name|p2
operator|->
name|op
operator|!=
name|JMP
condition|)
goto|goto
name|ivloop
goto|;
name|p2
operator|=
name|p2
operator|->
name|forw
expr_stmt|;
name|p3
operator|=
name|p1
operator|->
name|ref
expr_stmt|;
while|while
condition|(
name|p3
condition|)
block|{
if|if
condition|(
name|p3
operator|->
name|op
operator|==
name|JBR
operator|||
name|p3
operator|->
name|op
operator|==
name|JMP
condition|)
block|{
if|if
condition|(
name|p1
operator|==
name|p3
condition|)
return|return
operator|(
name|p1
operator|)
return|;
name|ncmot
operator|++
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
name|p1
operator|->
name|back
operator|->
name|forw
operator|=
name|p2
expr_stmt|;
name|p1
operator|->
name|forw
operator|->
name|back
operator|=
name|p3
expr_stmt|;
name|p2
operator|->
name|back
operator|->
name|forw
operator|=
name|p3
operator|->
name|forw
expr_stmt|;
name|p3
operator|->
name|forw
operator|->
name|back
operator|=
name|p2
operator|->
name|back
expr_stmt|;
name|p2
operator|->
name|back
operator|=
name|p1
operator|->
name|back
expr_stmt|;
name|p3
operator|->
name|forw
operator|=
name|p1
operator|->
name|forw
expr_stmt|;
name|decref
argument_list|(
name|p1
operator|->
name|ref
argument_list|)
expr_stmt|;
return|return
operator|(
name|p2
operator|)
return|;
block|}
else|else
name|p3
operator|=
name|p3
operator|->
name|forw
expr_stmt|;
block|}
return|return
operator|(
name|p1
operator|)
return|;
name|ivloop
label|:
if|if
condition|(
name|p1
operator|->
name|forw
operator|->
name|op
operator|!=
name|LABEL
condition|)
return|return
operator|(
name|p1
operator|)
return|;
name|p3
operator|=
name|p2
operator|=
name|p2
operator|->
name|forw
expr_stmt|;
name|n
operator|=
literal|16
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|p3
operator|=
name|p3
operator|->
name|forw
operator|)
operator|==
literal|0
operator|||
name|p3
operator|==
name|p1
operator|||
operator|--
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|p1
operator|)
return|;
block|}
do|while
condition|(
name|p3
operator|->
name|op
operator|!=
name|CBR
operator|||
name|p3
operator|->
name|labno
operator|!=
name|p1
operator|->
name|forw
operator|->
name|labno
condition|)
do|;
do|do
if|if
condition|(
operator|(
name|p1
operator|=
name|p1
operator|->
name|back
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ap
operator|)
return|;
do|while
condition|(
name|p1
operator|!=
name|p3
condition|)
do|;
name|p1
operator|=
name|ap
expr_stmt|;
name|tl
operator|=
name|insertl
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|p3
operator|->
name|subop
operator|=
name|revbr
index|[
name|p3
operator|->
name|subop
index|]
expr_stmt|;
name|decref
argument_list|(
name|p3
operator|->
name|ref
argument_list|)
expr_stmt|;
name|p2
operator|->
name|back
operator|->
name|forw
operator|=
name|p1
expr_stmt|;
name|p3
operator|->
name|forw
operator|->
name|back
operator|=
name|p1
expr_stmt|;
name|p1
operator|->
name|back
operator|->
name|forw
operator|=
name|p2
expr_stmt|;
name|p1
operator|->
name|forw
operator|->
name|back
operator|=
name|p3
expr_stmt|;
name|t
operator|=
name|p1
operator|->
name|back
expr_stmt|;
name|p1
operator|->
name|back
operator|=
name|p2
operator|->
name|back
expr_stmt|;
name|p2
operator|->
name|back
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|p1
operator|->
name|forw
expr_stmt|;
name|p1
operator|->
name|forw
operator|=
name|p3
operator|->
name|forw
expr_stmt|;
name|p3
operator|->
name|forw
operator|=
name|t
expr_stmt|;
name|p2
operator|=
name|insertl
argument_list|(
name|p1
operator|->
name|forw
argument_list|)
expr_stmt|;
name|p3
operator|->
name|labno
operator|=
name|p2
operator|->
name|labno
expr_stmt|;
name|p3
operator|->
name|ref
operator|=
name|p2
expr_stmt|;
name|decref
argument_list|(
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|tl
operator|->
name|refc
operator|<=
literal|0
condition|)
name|nrlab
operator|--
expr_stmt|;
name|loopiv
operator|++
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
return|return
operator|(
name|p3
operator|)
return|;
block|}
end_block

begin_macro
name|comjump
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|p3
decl_stmt|;
for|for
control|(
name|p1
operator|=
name|first
operator|.
name|forw
init|;
name|p1
operator|!=
literal|0
condition|;
name|p1
operator|=
name|p1
operator|->
name|forw
control|)
if|if
condition|(
name|p1
operator|->
name|op
operator|==
name|JBR
operator|&&
operator|(
name|p2
operator|=
name|p1
operator|->
name|ref
operator|)
operator|&&
name|p2
operator|->
name|refc
operator|>
literal|1
condition|)
for|for
control|(
name|p3
operator|=
name|p1
operator|->
name|forw
init|;
name|p3
operator|!=
literal|0
condition|;
name|p3
operator|=
name|p3
operator|->
name|forw
control|)
if|if
condition|(
name|p3
operator|->
name|op
operator|==
name|JBR
operator|&&
name|p3
operator|->
name|ref
operator|==
name|p2
condition|)
name|backjmp
argument_list|(
name|p1
argument_list|,
name|p3
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|backjmp
argument_list|(
argument|ap1
argument_list|,
argument|ap2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|node
modifier|*
name|ap1
decl_stmt|,
modifier|*
name|ap2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|p3
decl_stmt|;
name|p1
operator|=
name|ap1
expr_stmt|;
name|p2
operator|=
name|ap2
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|(
name|p1
operator|=
name|p1
operator|->
name|back
operator|)
operator|&&
name|p1
operator|->
name|op
operator|==
name|LABEL
condition|)
empty_stmt|;
name|p2
operator|=
name|p2
operator|->
name|back
expr_stmt|;
if|if
condition|(
name|equop
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
block|{
name|p3
operator|=
name|insertl
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|p2
operator|->
name|back
operator|->
name|forw
operator|=
name|p2
operator|->
name|forw
expr_stmt|;
name|p2
operator|->
name|forw
operator|->
name|back
operator|=
name|p2
operator|->
name|back
expr_stmt|;
name|p2
operator|=
name|p2
operator|->
name|forw
expr_stmt|;
name|decref
argument_list|(
name|p2
operator|->
name|ref
argument_list|)
expr_stmt|;
name|p2
operator|->
name|labno
operator|=
name|p3
operator|->
name|labno
expr_stmt|;
name|p2
operator|->
name|ref
operator|=
name|p3
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
name|ncomj
operator|++
expr_stmt|;
block|}
else|else
return|return;
block|}
block|}
end_block

end_unit

