begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_include
include|#
directive|include
file|"ne.h"
end_include

begin_include
include|#
directive|include
file|"y.tab.c"
end_include

begin_decl_stmt
name|char
modifier|*
name|cntrl
index|[]
block|{
literal|"sup"
operator|,
literal|"super"
operator|,
literal|"sub"
operator|,
literal|".EN"
operator|,
literal|"sum"
operator|,
literal|"from"
operator|,
literal|"to"
operator|,
literal|"hat"
operator|,
literal|"dot"
operator|,
literal|"dotdot"
operator|,
literal|"bar"
operator|,
literal|"tilde"
operator|,
literal|"under"
operator|,
literal|"prod"
operator|,
literal|"int"
operator|,
literal|"integral"
operator|,
literal|"union"
operator|,
literal|"inter"
operator|,
literal|"pile"
operator|,
literal|"lpile"
operator|,
literal|"cpile"
operator|,
literal|"rpile"
operator|,
literal|"over"
operator|,
literal|"sqrt"
operator|,
literal|"above"
operator|,
literal|"size"
operator|,
literal|"font"
operator|,
literal|"roman"
operator|,
literal|"italic"
operator|,
literal|"bold"
operator|,
literal|"left"
operator|,
literal|"right"
operator|,
literal|"delim"
operator|,
literal|"DELIM"
operator|,
literal|"DEFINE"
operator|,
literal|"define"
operator|,
literal|".gsize"
operator|,
literal|".GSIZE"
operator|,
literal|"gsize"
operator|,
literal|"GSIZE"
operator|,
literal|"gfont"
operator|,
literal|"GFONT"
operator|,
literal|"HAT"
operator|,
literal|"DOT"
operator|,
literal|"DOTDOT"
operator|,
literal|"BAR"
operator|,
literal|"TILDE"
operator|,
literal|"UNDER"
operator|,
literal|"PROD"
operator|,
literal|"INT"
operator|,
literal|"INTEGRAL"
operator|,
literal|"UNION"
operator|,
literal|"INTER"
operator|,
literal|"SUM"
operator|,
literal|"FROM"
operator|,
literal|"TO"
operator|,
literal|"SUP"
operator|,
literal|"SUPER"
operator|,
literal|"SUB"
operator|,
literal|"PILE"
operator|,
literal|"LPILE"
operator|,
literal|"CPILE"
operator|,
literal|"RPILE"
operator|,
literal|"OVER"
operator|,
literal|"SQRT"
operator|,
literal|"ABOVE"
operator|,
literal|"SIZE"
operator|,
literal|"FONT"
operator|,
literal|"ROMAN"
operator|,
literal|"ITALIC"
operator|,
literal|"BOLD"
operator|,
literal|"LEFT"
operator|,
literal|"RIGHT"
operator|,
literal|"up"
operator|,
literal|"UP"
operator|,
literal|"down"
operator|,
literal|"DOWN"
operator|,
literal|"fwd"
operator|,
literal|"FWD"
operator|,
literal|"back"
operator|,
literal|"BACK"
operator|,
literal|"mark"
operator|,
literal|"MARK"
operator|,
literal|"lineup"
operator|,
literal|"LINEUP"
operator|,
literal|"matrix"
operator|,
literal|"lcol"
operator|,
literal|"ccol"
operator|,
literal|"rcol"
operator|,
literal|"col"
operator|,
literal|0
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|int
name|icntrl
index|[]
block|{
name|SUPER
operator|,
name|SUPER
operator|,
name|SUB
operator|,
literal|0
operator|,
comment|/* EOF */
name|SUM
operator|,
name|FROM
operator|,
name|TO
operator|,
name|HAT
operator|,
name|DOT
operator|,
name|DOTDOT
operator|,
name|BAR
operator|,
name|TILDE
operator|,
name|UNDER
operator|,
name|PROD
operator|,
name|INT
operator|,
name|INT
operator|,
name|UNION
operator|,
name|INTER
operator|,
name|PILE
operator|,
name|LPILE
operator|,
name|CPILE
operator|,
name|RPILE
operator|,
name|OVER
operator|,
name|SQRT
operator|,
name|ABOVE
operator|,
name|SIZE
operator|,
name|FONT
operator|,
name|ROMAN
operator|,
name|ITALIC
operator|,
name|BOLD
operator|,
name|LEFT
operator|,
name|RIGHT
operator|,
name|DELIM
operator|,
name|DELIM
operator|,
name|DEFINE
operator|,
name|DEFINE
operator|,
name|GSIZE
operator|,
name|GSIZE
operator|,
name|GSIZE
operator|,
name|GSIZE
operator|,
name|GFONT
operator|,
name|GFONT
operator|,
name|HAT
operator|,
name|DOT
operator|,
name|DOTDOT
operator|,
name|BAR
operator|,
name|TILDE
operator|,
name|UNDER
operator|,
name|PROD
operator|,
name|INT
operator|,
name|INT
operator|,
name|UNION
operator|,
name|INTER
operator|,
name|SUM
operator|,
name|FROM
operator|,
name|TO
operator|,
name|SUPER
operator|,
name|SUPER
operator|,
name|SUB
operator|,
name|PILE
operator|,
name|LPILE
operator|,
name|CPILE
operator|,
name|RPILE
operator|,
name|OVER
operator|,
name|SQRT
operator|,
name|ABOVE
operator|,
name|SIZE
operator|,
name|FONT
operator|,
name|ROMAN
operator|,
name|ITALIC
operator|,
name|BOLD
operator|,
name|LEFT
operator|,
name|RIGHT
operator|,
name|UP
operator|,
name|UP
operator|,
name|DOWN
operator|,
name|DOWN
operator|,
name|FWD
operator|,
name|FWD
operator|,
name|BACK
operator|,
name|BACK
operator|,
name|MARK
operator|,
name|MARK
operator|,
name|LINEUP
operator|,
name|LINEUP
operator|,
name|MATRIX
operator|,
name|LCOL
operator|,
name|CCOL
operator|,
name|RCOL
operator|,
name|COL
operator|,
literal|0
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|int
name|peek
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|SSIZE
value|400
end_define

begin_decl_stmt
name|char
name|token
index|[
name|SSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|speek
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|swt
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|int
name|sw
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_macro
name|getc
argument_list|()
end_macro

begin_block
block|{
name|loop
label|:
if|if
condition|(
name|sw
operator|>=
literal|0
condition|)
block|{
name|lastchar
operator|=
operator|(
name|peek
operator|<
literal|0
operator|)
condition|?
operator|*
name|swt
index|[
name|sw
index|]
operator|++
else|:
name|peek
expr_stmt|;
name|peek
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lastchar
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|lastchar
operator|)
return|;
name|peek
operator|=
name|speek
index|[
name|sw
operator|--
index|]
expr_stmt|;
return|return
operator|(
literal|' '
operator|)
return|;
block|}
name|lastchar
operator|=
operator|(
name|peek
operator|<
literal|0
operator|)
condition|?
name|getchar
argument_list|()
else|:
name|peek
expr_stmt|;
if|if
condition|(
name|lastchar
operator|==
literal|'\n'
condition|)
name|linect
operator|++
expr_stmt|;
name|peek
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lastchar
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|lastchar
operator|)
return|;
if|if
condition|(
operator|++
name|ifile
operator|>
name|svargc
condition|)
block|{
name|peek
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|'\0'
operator|)
return|;
block|}
name|close
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|linect
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|fin
operator|=
name|open
argument_list|(
name|svargv
index|[
name|ifile
index|]
argument_list|,
literal|0
argument_list|)
operator|)
operator|>=
literal|0
condition|)
goto|goto
name|loop
goto|;
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"can't open file %s\n"
argument_list|,
name|svargv
index|[
name|ifile
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|yylex
argument_list|()
end_macro

begin_block
block|{
name|int
name|c
decl_stmt|,
name|type
decl_stmt|;
name|beg
label|:
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
condition|)
empty_stmt|;
name|yylval
operator|=
name|c
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\0'
case|:
return|return
operator|(
literal|'\0'
operator|)
return|;
case|case
literal|'~'
case|:
return|return
operator|(
name|SPACE
operator|)
return|;
case|case
literal|'^'
case|:
return|return
operator|(
name|THIN
operator|)
return|;
case|case
literal|'\t'
case|:
return|return
operator|(
name|TAB
operator|)
return|;
case|case
literal|'{'
case|:
return|return
operator|(
name|MQ
operator|)
return|;
case|case
literal|'}'
case|:
return|return
operator|(
name|MQ1
operator|)
return|;
case|case
literal|'"'
case|:
for|for
control|(
name|sp
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|getc
argument_list|()
operator|)
operator|!=
literal|'"'
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'\\'
condition|)
name|token
index|[
name|sp
operator|++
index|]
operator|=
name|c
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|()
operator|)
operator|!=
literal|'"'
condition|)
name|token
index|[
name|sp
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|token
index|[
name|sp
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|>=
name|SSIZE
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"quoted string %.20s... too long"
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
name|token
index|[
name|sp
index|]
operator|=
literal|'\0'
expr_stmt|;
name|yylval
operator|=
operator|&
name|token
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
name|QTEXT
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
name|righteq
condition|)
return|return
operator|(
literal|'\0'
operator|)
return|;
name|getstr
argument_list|(
name|token
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|=
name|lookup
argument_list|(
name|token
argument_list|,
name|nptr
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|sw
operator|>=
literal|9
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"definitions nested> 9"
argument_list|,
name|sw
argument_list|)
expr_stmt|;
name|swt
index|[
operator|++
name|sw
index|]
operator|=
name|sptr
index|[
name|type
index|]
expr_stmt|;
name|speek
index|[
name|sw
index|]
operator|=
name|peek
expr_stmt|;
name|peek
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|beg
goto|;
block|}
name|type
operator|=
name|lookup
argument_list|(
name|token
argument_list|,
name|cntrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|<
literal|0
condition|)
return|return
operator|(
name|CONTIG
operator|)
return|;
if|if
condition|(
name|icntrl
index|[
name|type
index|]
operator|==
name|DEFINE
condition|)
block|{
name|define
argument_list|()
expr_stmt|;
goto|goto
name|beg
goto|;
block|}
elseif|else
if|if
condition|(
name|icntrl
index|[
name|type
index|]
operator|==
name|DELIM
condition|)
block|{
name|delim
argument_list|()
expr_stmt|;
goto|goto
name|beg
goto|;
block|}
elseif|else
if|if
condition|(
name|icntrl
index|[
name|type
index|]
operator|==
name|GSIZE
condition|)
block|{
name|globsize
argument_list|()
expr_stmt|;
goto|goto
name|beg
goto|;
block|}
elseif|else
if|if
condition|(
name|icntrl
index|[
name|type
index|]
operator|==
name|GFONT
condition|)
block|{
name|globfont
argument_list|()
expr_stmt|;
goto|goto
name|beg
goto|;
block|}
else|else
return|return
operator|(
name|icntrl
index|[
name|type
index|]
operator|)
return|;
block|}
end_block

begin_macro
name|getstr
argument_list|(
argument|s
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
for|for
control|(
name|sp
operator|=
literal|0
init|;
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'{'
operator|&&
name|c
operator|!=
literal|'}'
operator|&&
name|c
operator|!=
literal|'"'
operator|&&
name|c
operator|!=
literal|'~'
operator|&&
name|c
operator|!=
literal|'^'
operator|&&
name|c
operator|!=
name|righteq
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|()
operator|)
operator|!=
literal|'"'
condition|)
name|s
index|[
name|sp
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|s
index|[
name|sp
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|sp
operator|>=
name|SSIZE
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"token %.20s... too long"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'{'
operator|||
name|c
operator|==
literal|'}'
operator|||
name|c
operator|==
literal|'"'
operator|||
name|c
operator|==
literal|'~'
operator|||
name|c
operator|==
literal|'^'
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
name|righteq
condition|)
name|peek
operator|=
name|c
expr_stmt|;
name|s
index|[
name|sp
index|]
operator|=
literal|'\0'
expr_stmt|;
name|yylval
operator|=
name|s
expr_stmt|;
block|}
end_block

begin_macro
name|lookup
argument_list|(
argument|str
argument_list|,
argument|tbl
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tbl
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
operator|,
name|j
operator|,
name|r
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tbl
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
comment|/* table of tbl wds */
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|r
operator|=
name|tbl
index|[
name|i
index|]
index|[
name|j
index|]
operator|)
operator|==
name|str
index|[
name|j
index|]
operator|&&
name|r
operator|!=
literal|'\0'
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|r
operator|==
name|str
index|[
name|j
index|]
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|cstr
argument_list|(
argument|s
argument_list|,
argument|quote
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|quote
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|del
decl_stmt|,
name|c
decl_stmt|,
name|i
decl_stmt|;
while|while
condition|(
operator|(
name|del
operator|=
name|getc
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|del
operator|==
literal|'\t'
operator|||
name|del
operator|==
literal|'\n'
condition|)
empty_stmt|;
if|if
condition|(
name|quote
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|getc
argument_list|()
operator|)
operator|!=
name|del
condition|;
control|)
name|s
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
else|else
block|{
name|s
index|[
literal|0
index|]
operator|=
name|del
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|(
name|c
operator|=
name|getc
argument_list|()
operator|)
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
condition|;
control|)
name|s
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|s
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_block

begin_macro
name|define
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|alloc
parameter_list|()
function_decl|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
condition|)
empty_stmt|;
name|getstr
argument_list|(
name|token
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|lookup
argument_list|(
name|token
argument_list|,
name|nptr
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|yyval
operator|=
name|i
expr_stmt|;
name|free
argument_list|(
name|sptr
index|[
name|yyval
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|yyval
operator|=
name|ptr
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|token
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|nptr
index|[
name|yyval
index|]
operator|=
name|alloc
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|nptr
index|[
name|yyval
index|]
index|[
name|i
index|]
operator|=
name|token
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
block|}
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|".\tdefine %s\n"
argument_list|,
name|nptr
index|[
name|yyval
index|]
argument_list|)
expr_stmt|;
name|cstr
argument_list|(
name|token
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|token
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|sptr
index|[
name|yyval
index|]
operator|=
name|alloc
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sptr
index|[
name|yyval
index|]
index|[
name|i
index|]
operator|=
name|token
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|".\tname %s defined as %s\n"
argument_list|,
name|nptr
index|[
name|yyval
index|]
argument_list|,
name|sptr
index|[
name|yyval
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|delim
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|yyval
operator|=
name|eqnreg
operator|=
literal|0
expr_stmt|;
name|cstr
argument_list|(
name|token
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lefteq
operator|=
name|token
index|[
literal|0
index|]
expr_stmt|;
name|righteq
operator|=
name|token
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|lefteq
operator|==
literal|'o'
operator|&&
name|righteq
operator|==
literal|'f'
operator|)
operator|||
operator|(
name|lefteq
operator|==
literal|'O'
operator|&&
name|righteq
operator|==
literal|'F'
operator|)
condition|)
name|lefteq
operator|=
name|righteq
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_macro
name|globsize
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|int
name|gsize
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
condition|)
empty_stmt|;
name|getstr
argument_list|(
name|token
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|gsize
operator|=
name|numb
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|eqnreg
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|globfont
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|int
name|gfont
decl_stmt|;
while|while
condition|(
operator|(
name|gfont
operator|=
name|getc
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|gfont
operator|==
literal|'\n'
condition|)
empty_stmt|;
name|yyval
operator|=
name|eqnreg
operator|=
literal|0
expr_stmt|;
block|}
end_block

end_unit

