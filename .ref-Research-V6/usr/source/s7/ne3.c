begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"ne.h"
end_include

begin_decl_stmt
name|char
modifier|*
name|res
index|[]
block|{
literal|">="
operator|,
literal|"<="
operator|,
literal|"!="
operator|,
literal|"+-"
operator|,
literal|"=="
operator|,
literal|"cdot"
operator|,
literal|"CDOT"
operator|,
literal|"times"
operator|,
literal|"TIMES"
operator|,
literal|"SIGMA"
operator|,
literal|"pi"
operator|,
literal|"PI"
operator|,
literal|"alpha"
operator|,
literal|"beta"
operator|,
literal|"gamma"
operator|,
literal|"GAMMA"
operator|,
literal|"delta"
operator|,
literal|"epsilon"
operator|,
literal|"omega"
operator|,
literal|"DELTA"
operator|,
literal|"LAMBDA"
operator|,
literal|"PHI"
operator|,
literal|"OMEGA"
operator|,
literal|"lambda"
operator|,
literal|"mu"
operator|,
literal|"nu"
operator|,
literal|"theta"
operator|,
literal|"rho"
operator|,
literal|"sigma"
operator|,
literal|"tau"
operator|,
literal|"phi"
operator|,
literal|"INF"
operator|,
literal|"INFINITY"
operator|,
literal|"inf"
operator|,
literal|"infinity"
operator|,
literal|"partial"
operator|,
literal|"PARTIAL"
operator|,
literal|"zeta"
operator|,
literal|"eta"
operator|,
literal|"iota"
operator|,
literal|"kappa"
operator|,
literal|"xi"
operator|,
literal|"omicron"
operator|,
literal|"upsilon"
operator|,
literal|"chi"
operator|,
literal|"psi"
operator|,
literal|"THETA"
operator|,
literal|"XI"
operator|,
literal|"UPSILON"
operator|,
literal|"PSI"
operator|,
literal|"del"
operator|,
literal|"DEL"
operator|,
literal|"nothing"
operator|,
literal|"NOTHING"
operator|,
literal|"approx"
operator|,
literal|"APPROX"
operator|,
literal|0
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|char
modifier|*
name|restran
index|[]
block|{
literal|">\b_"
operator|,
literal|"<\b_"
operator|,
literal|"/\b="
operator|,
literal|"+\b_"
operator|,
literal|"=\b_"
operator|,
literal|"
literal|8.
literal|9"
operator|,
literal|"
literal|8.
literal|9"
operator|,
literal|"x"
operator|,
literal|"x"
operator|,
literal|"
literal|R
literal|"
operator|,
literal|"
literal|J
literal|"
operator|,
literal|"
literal|P
literal|"
operator|,
literal|"
literal|A
literal|"
operator|,
literal|"
literal|B
literal|"
operator|,
literal|"
literal|\\e
literal|"
operator|,
literal|"
literal|G
literal|"
operator|,
literal|"
literal|D
literal|"
operator|,
literal|"
literal|S
literal|"
operator|,
literal|"
literal|C
literal|"
operator|,
literal|"
literal|W
literal|"
operator|,
literal|"
literal|E
literal|"
operator|,
literal|"
literal|F
literal|"
operator|,
literal|"
literal|Z
literal|"
operator|,
literal|"
literal|L
literal|"
operator|,
literal|"
literal|M
literal|"
operator|,
literal|"
literal|@
literal|"
operator|,
literal|"
literal|T
literal|"
operator|,
literal|"
literal|K
literal|"
operator|,
literal|"
literal|Y
literal|"
operator|,
literal|"
literal|I
literal|"
operator|,
literal|"
literal|U
literal|"
operator|,
literal|"
literal|o
literal|"
operator|,
literal|"
literal|o
literal|"
operator|,
literal|"
literal|o
literal|"
operator|,
literal|"
literal|o
literal|"
operator|,
literal|"
literal|]
literal|"
operator|,
literal|"
literal|]
literal|"
operator|,
literal|"
literal|Q
literal|"
operator|,
literal|"
literal|N
literal|"
operator|,
literal|"i"
operator|,
literal|"k"
operator|,
literal|"
literal|X
literal|"
operator|,
literal|"o"
operator|,
literal|"u"
operator|,
literal|"X"
operator|,
literal|"
literal|V
literal|"
operator|,
literal|"
literal|O
literal|"
operator|,
literal|"X"
operator|,
literal|"U"
operator|,
literal|"
literal|H
literal|"
operator|,
literal|"
literal|[
literal|"
operator|,
literal|"
literal|[
literal|"
operator|,
literal|""
operator|,
literal|""
operator|,
literal|"~\b="
operator|,
literal|"~\b="
operator|,
literal|0
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|int
name|csp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|psp
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CSSIZE
value|400
end_define

begin_decl_stmt
name|char
name|cs
index|[
literal|420
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|text
argument_list|(
argument|t
argument_list|,
argument|p1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|t
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|p1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|c
decl_stmt|;
name|int
name|w
decl_stmt|;
name|yyval
operator|=
name|oalloc
argument_list|()
expr_stmt|;
name|ebase
index|[
name|yyval
index|]
operator|=
literal|0
expr_stmt|;
name|eht
index|[
name|yyval
index|]
operator|=
literal|2
expr_stmt|;
comment|/* ht in 1/2 spaces */
if|if
condition|(
name|t
operator|==
literal|'q'
condition|)
name|j
operator|=
name|p1
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|'~'
condition|)
name|j
operator|=
operator|&
literal|"~"
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|'^'
condition|)
name|j
operator|=
operator|&
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|==
literal|'\t'
condition|)
name|j
operator|=
operator|&
literal|"\\t"
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|i
operator|=
name|lookup
argument_list|(
name|p1
argument_list|,
name|res
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|j
operator|=
name|restran
index|[
name|i
index|]
expr_stmt|;
else|else
block|{
for|for
control|(
name|csp
operator|=
name|psp
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|p1
index|[
name|psp
operator|++
index|]
operator|)
operator|!=
literal|'\0'
condition|;
control|)
block|{
name|trans
argument_list|(
name|c
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|csp
operator|>
name|CSSIZE
condition|)
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"converted token %.20s... too long"
argument_list|,
name|p1
argument_list|)
expr_stmt|;
block|}
name|cs
index|[
name|csp
index|]
operator|=
literal|'\0'
expr_stmt|;
name|j
operator|=
name|cs
expr_stmt|;
block|}
name|ewid
index|[
name|yyval
index|]
operator|=
name|width
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|".\t%ctext: S%d<- %s; b=%d,h=%d,w=%d\n"
argument_list|,
name|t
argument_list|,
name|yyval
argument_list|,
name|j
argument_list|,
name|ebase
index|[
name|yyval
index|]
argument_list|,
name|eht
index|[
name|yyval
index|]
argument_list|,
name|ewid
index|[
name|yyval
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".ds %d \"%s\n"
argument_list|,
name|yyval
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|width
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|,
name|w
decl_stmt|;
name|w
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\b'
operator|||
name|c
operator|==
literal|033
condition|)
name|w
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
operator|*
name|s
operator|==
literal|'\\'
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
operator|*
name|s
operator|==
literal|'e'
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|040
condition|)
name|w
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|w
operator|)
return|;
block|}
end_block

begin_macro
name|trans
argument_list|(
argument|c
argument_list|,
argument|p1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|p1
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'>'
case|:
case|case
literal|'<'
case|:
case|case
literal|'='
case|:
if|if
condition|(
name|p1
index|[
name|psp
index|]
operator|==
literal|'='
condition|)
block|{
comment|/* look ahead for ==<=>= */
name|cs
index|[
name|csp
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|cs
index|[
name|csp
operator|++
index|]
operator|=
literal|'\b'
expr_stmt|;
name|cs
index|[
name|csp
operator|++
index|]
operator|=
literal|'_'
expr_stmt|;
name|psp
operator|++
expr_stmt|;
block|}
else|else
name|cs
index|[
name|csp
operator|++
index|]
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/* troff - pass 2 or 3 more chars */
name|cs
index|[
name|csp
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|cs
index|[
name|csp
operator|++
index|]
operator|=
name|c
operator|=
name|p1
index|[
name|psp
operator|++
index|]
expr_stmt|;
name|cs
index|[
name|csp
operator|++
index|]
operator|=
name|p1
index|[
name|psp
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
name|cs
index|[
name|csp
operator|++
index|]
operator|=
name|p1
index|[
name|psp
operator|++
index|]
expr_stmt|;
break|break;
default|default:
name|cs
index|[
name|csp
operator|++
index|]
operator|=
name|c
expr_stmt|;
break|break;
block|}
block|}
end_block

end_unit

