begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*  */
end_comment

begin_include
include|#
directive|include
file|"../param.h"
end_include

begin_include
include|#
directive|include
file|"../systm.h"
end_include

begin_include
include|#
directive|include
file|"../filsys.h"
end_include

begin_include
include|#
directive|include
file|"../conf.h"
end_include

begin_include
include|#
directive|include
file|"../buf.h"
end_include

begin_include
include|#
directive|include
file|"../inode.h"
end_include

begin_include
include|#
directive|include
file|"../user.h"
end_include

begin_comment
comment|/*  * iinit is called once (from main)  * very early in initialization.  * It reads the root's super block  * and initializes the current date  * from the last modified date.  *  * panic: iinit -- cannot read the super  * block. Usually because of an IO error.  */
end_comment

begin_macro
name|iinit
argument_list|()
end_macro

begin_block
block|{
specifier|register
operator|*
name|cp
operator|,
operator|*
name|bp
expr_stmt|;
operator|(
operator|*
name|bdevsw
index|[
name|rootdev
operator|.
name|d_major
index|]
operator|.
name|d_open
operator|)
operator|(
name|rootdev
operator|,
literal|1
operator|)
expr_stmt|;
name|bp
operator|=
name|bread
argument_list|(
name|rootdev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|=
name|getblk
argument_list|(
name|NODEV
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|u_error
condition|)
name|panic
argument_list|(
literal|"iinit"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bp
operator|->
name|b_addr
argument_list|,
name|cp
operator|->
name|b_addr
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|mount
index|[
literal|0
index|]
operator|.
name|m_bufp
operator|=
name|cp
expr_stmt|;
name|mount
index|[
literal|0
index|]
operator|.
name|m_dev
operator|=
name|rootdev
expr_stmt|;
name|cp
operator|=
name|cp
operator|->
name|b_addr
expr_stmt|;
name|cp
operator|->
name|s_flock
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|s_ilock
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|s_ronly
operator|=
literal|0
expr_stmt|;
name|time
index|[
literal|0
index|]
operator|=
name|cp
operator|->
name|s_time
index|[
literal|0
index|]
expr_stmt|;
name|time
index|[
literal|1
index|]
operator|=
name|cp
operator|->
name|s_time
index|[
literal|1
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * alloc will obtain the next available  * free disk block from the free list of  * the specified device.  * The super block has up to 100 remembered  * free blocks; the last of these is read to  * obtain 100 more . . .  *  * no space on dev x/y -- when  * the free list is exhausted.  */
end_comment

begin_macro
name|alloc
argument_list|(
argument|dev
argument_list|)
end_macro

begin_block
block|{
name|int
name|bno
decl_stmt|;
specifier|register
operator|*
name|bp
operator|,
operator|*
name|ip
operator|,
operator|*
name|fp
expr_stmt|;
name|fp
operator|=
name|getfs
argument_list|(
name|dev
argument_list|)
expr_stmt|;
while|while
condition|(
name|fp
operator|->
name|s_flock
condition|)
name|sleep
argument_list|(
operator|&
name|fp
operator|->
name|s_flock
argument_list|,
name|PINOD
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|fp
operator|->
name|s_nfree
operator|<=
literal|0
condition|)
goto|goto
name|nospace
goto|;
name|bno
operator|=
name|fp
operator|->
name|s_free
index|[
operator|--
name|fp
operator|->
name|s_nfree
index|]
expr_stmt|;
if|if
condition|(
name|bno
operator|==
literal|0
condition|)
goto|goto
name|nospace
goto|;
block|}
do|while
condition|(
name|badblock
argument_list|(
name|fp
argument_list|,
name|bno
argument_list|,
name|dev
argument_list|)
condition|)
do|;
if|if
condition|(
name|fp
operator|->
name|s_nfree
operator|<=
literal|0
condition|)
block|{
name|fp
operator|->
name|s_flock
operator|++
expr_stmt|;
name|bp
operator|=
name|bread
argument_list|(
name|dev
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|ip
operator|=
name|bp
operator|->
name|b_addr
expr_stmt|;
name|fp
operator|->
name|s_nfree
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
name|bcopy
argument_list|(
name|ip
argument_list|,
name|fp
operator|->
name|s_free
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|s_flock
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|fp
operator|->
name|s_flock
argument_list|)
expr_stmt|;
block|}
name|bp
operator|=
name|getblk
argument_list|(
name|dev
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|clrbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|s_fmod
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
name|nospace
label|:
name|fp
operator|->
name|s_nfree
operator|=
literal|0
expr_stmt|;
name|prdev
argument_list|(
literal|"no space"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_error
operator|=
name|ENOSPC
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * place the specified disk block  * back on the free list of the  * specified device.  */
end_comment

begin_macro
name|free
argument_list|(
argument|dev
argument_list|,
argument|bno
argument_list|)
end_macro

begin_block
block|{
specifier|register
operator|*
name|fp
operator|,
operator|*
name|bp
operator|,
operator|*
name|ip
expr_stmt|;
name|fp
operator|=
name|getfs
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|fp
operator|->
name|s_fmod
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|fp
operator|->
name|s_flock
condition|)
name|sleep
argument_list|(
operator|&
name|fp
operator|->
name|s_flock
argument_list|,
name|PINOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|badblock
argument_list|(
name|fp
argument_list|,
name|bno
argument_list|,
name|dev
argument_list|)
condition|)
return|return;
if|if
condition|(
name|fp
operator|->
name|s_nfree
operator|<=
literal|0
condition|)
block|{
name|fp
operator|->
name|s_nfree
operator|=
literal|1
expr_stmt|;
name|fp
operator|->
name|s_free
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|s_nfree
operator|>=
literal|100
condition|)
block|{
name|fp
operator|->
name|s_flock
operator|++
expr_stmt|;
name|bp
operator|=
name|getblk
argument_list|(
name|dev
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|ip
operator|=
name|bp
operator|->
name|b_addr
expr_stmt|;
operator|*
name|ip
operator|++
operator|=
name|fp
operator|->
name|s_nfree
expr_stmt|;
name|bcopy
argument_list|(
name|fp
operator|->
name|s_free
argument_list|,
name|ip
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|fp
operator|->
name|s_nfree
operator|=
literal|0
expr_stmt|;
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|s_flock
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|fp
operator|->
name|s_flock
argument_list|)
expr_stmt|;
block|}
name|fp
operator|->
name|s_free
index|[
name|fp
operator|->
name|s_nfree
operator|++
index|]
operator|=
name|bno
expr_stmt|;
name|fp
operator|->
name|s_fmod
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Check that a block number is in the  * range between the I list and the size  * of the device.  * This is used mainly to check that a  * garbage file system has not been mounted.  *  * bad block on dev x/y -- not in range  */
end_comment

begin_macro
name|badblock
argument_list|(
argument|afp
argument_list|,
argument|abn
argument_list|,
argument|dev
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|filsys
modifier|*
name|fp
decl_stmt|;
specifier|register
name|char
modifier|*
name|bn
decl_stmt|;
name|fp
operator|=
name|afp
expr_stmt|;
name|bn
operator|=
name|abn
expr_stmt|;
if|if
condition|(
name|bn
operator|<
name|fp
operator|->
name|s_isize
operator|+
literal|2
operator|||
name|bn
operator|>=
name|fp
operator|->
name|s_fsize
condition|)
block|{
name|prdev
argument_list|(
literal|"bad block"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Allocate an unused I node  * on the specified device.  * Used with file creation.  * The algorithm keeps up to  * 100 spare I nodes in the  * super block. When this runs out,  * a linear search through the  * I list is instituted to pick  * up 100 more.  */
end_comment

begin_macro
name|ialloc
argument_list|(
argument|dev
argument_list|)
end_macro

begin_block
block|{
specifier|register
operator|*
name|fp
operator|,
operator|*
name|bp
operator|,
operator|*
name|ip
expr_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|ino
decl_stmt|;
name|fp
operator|=
name|getfs
argument_list|(
name|dev
argument_list|)
expr_stmt|;
while|while
condition|(
name|fp
operator|->
name|s_ilock
condition|)
name|sleep
argument_list|(
operator|&
name|fp
operator|->
name|s_ilock
argument_list|,
name|PINOD
argument_list|)
expr_stmt|;
name|loop
label|:
if|if
condition|(
name|fp
operator|->
name|s_ninode
operator|>
literal|0
condition|)
block|{
name|ino
operator|=
name|fp
operator|->
name|s_inode
index|[
operator|--
name|fp
operator|->
name|s_ninode
index|]
expr_stmt|;
name|ip
operator|=
name|iget
argument_list|(
name|dev
argument_list|,
name|ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|ip
operator|->
name|i_mode
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|bp
operator|=
operator|&
name|ip
operator|->
name|i_mode
init|;
name|bp
operator|<
operator|&
name|ip
operator|->
name|i_addr
index|[
literal|8
index|]
condition|;
control|)
operator|*
name|bp
operator|++
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|s_fmod
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ip
operator|)
return|;
block|}
comment|/* 		 * Inode was allocated after all. 		 * Look some more. 		 */
name|iput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|fp
operator|->
name|s_ilock
operator|++
expr_stmt|;
name|ino
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fp
operator|->
name|s_isize
condition|;
name|i
operator|++
control|)
block|{
name|bp
operator|=
name|bread
argument_list|(
name|dev
argument_list|,
name|i
operator|+
literal|2
argument_list|)
expr_stmt|;
name|ip
operator|=
name|bp
operator|->
name|b_addr
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|256
condition|;
name|j
operator|=
operator|+
literal|16
control|)
block|{
name|ino
operator|++
expr_stmt|;
if|if
condition|(
name|ip
index|[
name|j
index|]
operator|!=
literal|0
condition|)
continue|continue;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NINODE
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|dev
operator|==
name|inode
index|[
name|k
index|]
operator|.
name|i_dev
operator|&&
name|ino
operator|==
name|inode
index|[
name|k
index|]
operator|.
name|i_number
condition|)
goto|goto
name|cont
goto|;
name|fp
operator|->
name|s_inode
index|[
name|fp
operator|->
name|s_ninode
operator|++
index|]
operator|=
name|ino
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|s_ninode
operator|>=
literal|100
condition|)
break|break;
name|cont
label|:
empty_stmt|;
block|}
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|s_ninode
operator|>=
literal|100
condition|)
break|break;
block|}
name|fp
operator|->
name|s_ilock
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|fp
operator|->
name|s_ilock
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|s_ninode
operator|>
literal|0
condition|)
goto|goto
name|loop
goto|;
name|prdev
argument_list|(
literal|"Out of inodes"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|u
operator|.
name|u_error
operator|=
name|ENOSPC
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Free the specified I node  * on the specified device.  * The algorithm stores up  * to 100 I nodes in the super  * block and throws away any more.  */
end_comment

begin_macro
name|ifree
argument_list|(
argument|dev
argument_list|,
argument|ino
argument_list|)
end_macro

begin_block
block|{
specifier|register
operator|*
name|fp
expr_stmt|;
name|fp
operator|=
name|getfs
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|s_ilock
condition|)
return|return;
if|if
condition|(
name|fp
operator|->
name|s_ninode
operator|>=
literal|100
condition|)
return|return;
name|fp
operator|->
name|s_inode
index|[
name|fp
operator|->
name|s_ninode
operator|++
index|]
operator|=
name|ino
expr_stmt|;
name|fp
operator|->
name|s_fmod
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * getfs maps a device number into  * a pointer to the incore super  * block.  * The algorithm is a linear  * search through the mount table.  * A consistency check of the  * in core free-block and i-node  * counts.  *  * bad count on dev x/y -- the count  *	check failed. At this point, all  *	the counts are zeroed which will  *	almost certainly lead to "no space"  *	diagnostic  * panic: no fs -- the device is not mounted.  *	this "cannot happen"  */
end_comment

begin_macro
name|getfs
argument_list|(
argument|dev
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|mount
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|n1
decl_stmt|,
modifier|*
name|n2
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|mount
index|[
literal|0
index|]
init|;
name|p
operator|<
operator|&
name|mount
index|[
name|NMOUNT
index|]
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|m_bufp
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|m_dev
operator|==
name|dev
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|m_bufp
operator|->
name|b_addr
expr_stmt|;
name|n1
operator|=
name|p
operator|->
name|s_nfree
expr_stmt|;
name|n2
operator|=
name|p
operator|->
name|s_ninode
expr_stmt|;
if|if
condition|(
name|n1
operator|>
literal|100
operator|||
name|n2
operator|>
literal|100
condition|)
block|{
name|prdev
argument_list|(
literal|"bad count"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|p
operator|->
name|s_nfree
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|s_ninode
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
name|panic
argument_list|(
literal|"no fs"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * update is the internal name of  * 'sync'. It goes through the disk  * queues to initiate sandbagged IO;  * goes through the I nodes to write  * modified nodes; and it goes through  * the mount table to initiate modified  * super blocks.  */
end_comment

begin_macro
name|update
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
specifier|register
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
specifier|register
operator|*
name|bp
expr_stmt|;
if|if
condition|(
name|updlock
condition|)
return|return;
name|updlock
operator|++
expr_stmt|;
for|for
control|(
name|mp
operator|=
operator|&
name|mount
index|[
literal|0
index|]
init|;
name|mp
operator|<
operator|&
name|mount
index|[
name|NMOUNT
index|]
condition|;
name|mp
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|m_bufp
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
name|mp
operator|->
name|m_bufp
operator|->
name|b_addr
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|s_fmod
operator|==
literal|0
operator|||
name|ip
operator|->
name|s_ilock
operator|!=
literal|0
operator|||
name|ip
operator|->
name|s_flock
operator|!=
literal|0
operator|||
name|ip
operator|->
name|s_ronly
operator|!=
literal|0
condition|)
continue|continue;
name|bp
operator|=
name|getblk
argument_list|(
name|mp
operator|->
name|m_dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ip
operator|->
name|s_fmod
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|s_time
index|[
literal|0
index|]
operator|=
name|time
index|[
literal|0
index|]
expr_stmt|;
name|ip
operator|->
name|s_time
index|[
literal|1
index|]
operator|=
name|time
index|[
literal|1
index|]
expr_stmt|;
name|bcopy
argument_list|(
name|ip
argument_list|,
name|bp
operator|->
name|b_addr
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ip
operator|=
operator|&
name|inode
index|[
literal|0
index|]
init|;
name|ip
operator|<
operator|&
name|inode
index|[
name|NINODE
index|]
condition|;
name|ip
operator|++
control|)
if|if
condition|(
operator|(
name|ip
operator|->
name|i_flag
operator|&
name|ILOCK
operator|)
operator|==
literal|0
condition|)
block|{
name|ip
operator|->
name|i_flag
operator|=
operator||
name|ILOCK
expr_stmt|;
name|iupdat
argument_list|(
name|ip
argument_list|,
name|time
argument_list|)
expr_stmt|;
name|prele
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
name|updlock
operator|=
literal|0
expr_stmt|;
name|bflush
argument_list|(
name|NODEV
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

