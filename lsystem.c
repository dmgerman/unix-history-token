begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1984-2016  Mark Nudelman  *  * You may distribute under the terms of either the GNU General Public  * License or the Less License, as specified in the README file.  *  * For more information, see the README file.  */
end_comment

begin_comment
comment|/*  * Routines to execute other programs.  * Necessarily very OS dependent.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"position.h"
end_include

begin_if
if|#
directive|if
name|MSDOS_COMPILER
end_if

begin_include
include|#
directive|include
file|<dos.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_include
include|#
directive|include
file|<direct.h>
end_include

begin_define
define|#
directive|define
name|setdisk
parameter_list|(
name|n
parameter_list|)
value|_chdrive((n)+1)
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<dir.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|screen_trashed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|IFILE
name|curr_ifile
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|HAVE_SYSTEM
end_if

begin_comment
comment|/*  * Pass the specified command to a shell to be executed.  * Like plain "system()", but handles resetting terminal modes, etc.  */
end_comment

begin_function
name|public
name|void
name|lsystem
parameter_list|(
name|cmd
parameter_list|,
name|donemsg
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
name|char
modifier|*
name|donemsg
decl_stmt|;
block|{
specifier|register
name|int
name|inp
decl_stmt|;
if|#
directive|if
name|HAVE_SHELL
specifier|register
name|char
modifier|*
name|shell
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
name|IFILE
name|save_ifile
decl_stmt|;
if|#
directive|if
name|MSDOS_COMPILER
operator|&&
name|MSDOS_COMPILER
operator|!=
name|WIN32C
name|char
name|cwd
index|[
name|FILENAME_MAX
operator|+
literal|1
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Print the command which is to be executed, 	 * unless the command starts with a "-". 	 */
if|if
condition|(
name|cmd
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|cmd
operator|++
expr_stmt|;
else|else
block|{
name|clear_bot
argument_list|()
expr_stmt|;
name|putstr
argument_list|(
literal|"!"
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|MSDOS_COMPILER
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'\0'
condition|)
name|cmd
operator|=
name|getenv
argument_list|(
literal|"COMSPEC"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 	 * Working directory is global on MSDOS. 	 * The child might change the working directory, so we 	 * must save and restore CWD across calls to "system", 	 * or else we won't find our file when we return and 	 * try to "reedit_ifile" it. 	 */
name|getcwd
argument_list|(
name|cwd
argument_list|,
name|FILENAME_MAX
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* 	 * Close the current input file. 	 */
name|save_ifile
operator|=
name|save_curr_ifile
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|edit_ifile
argument_list|(
name|NULL_IFILE
argument_list|)
expr_stmt|;
comment|/* 	 * De-initialize the terminal and take out of raw mode. 	 */
name|deinit
argument_list|()
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
comment|/* Make sure the deinit chars get out */
name|raw_mode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
name|close_getchr
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Restore signals to their defaults. 	 */
name|init_signals
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_DUP
comment|/* 	 * Force standard input to be the user's terminal 	 * (the normal standard input), even if less's standard input  	 * is coming from a pipe. 	 */
name|inp
operator|=
name|dup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|OS2
comment|/* The __open() system call translates "/dev/tty" to "con". */
if|if
condition|(
name|__open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|OPEN_READ
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|OPEN_READ
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
name|dup
argument_list|(
name|inp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Pass the command to the system to be executed. 	 * If we have a SHELL environment variable, use 	 *<$SHELL -c "command"> instead of just<command>. 	 * If the command is empty, just invoke a shell. 	 */
if|#
directive|if
name|HAVE_SHELL
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|shell
operator|=
name|lgetenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
name|shell
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'\0'
condition|)
name|p
operator|=
name|save
argument_list|(
name|shell
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|esccmd
init|=
name|shell_quote
argument_list|(
name|cmd
argument_list|)
decl_stmt|;
if|if
condition|(
name|esccmd
operator|!=
name|NULL
condition|)
block|{
name|int
name|len
init|=
call|(
name|int
call|)
argument_list|(
name|strlen
argument_list|(
name|shell
argument_list|)
operator|+
name|strlen
argument_list|(
name|esccmd
argument_list|)
operator|+
literal|5
argument_list|)
decl_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|SNPRINTF3
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
literal|"%s %s %s"
argument_list|,
name|shell
argument_list|,
name|shell_coption
argument_list|()
argument_list|,
name|esccmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|esccmd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'\0'
condition|)
name|p
operator|=
name|save
argument_list|(
literal|"sh"
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|save
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
name|system
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|DJGPPC
comment|/* 	 * Make stdin of the child be in cooked mode. 	 */
name|setmode
argument_list|(
literal|0
argument_list|,
name|O_TEXT
argument_list|)
expr_stmt|;
comment|/* 	 * We don't need to catch signals of the child (it 	 * also makes trouble with some DPMI servers). 	 */
name|__djgpp_exception_toggle
argument_list|()
expr_stmt|;
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|__djgpp_exception_toggle
argument_list|()
expr_stmt|;
else|#
directive|else
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|HAVE_DUP
comment|/* 	 * Restore standard input, reset signals, raw mode, etc. 	 */
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|inp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
name|open_getchr
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|init_signals
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|raw_mode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|donemsg
operator|!=
name|NULL
condition|)
block|{
name|putstr
argument_list|(
name|donemsg
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"  (press RETURN)"
argument_list|)
expr_stmt|;
name|get_return
argument_list|()
expr_stmt|;
name|putchr
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
name|init
argument_list|()
expr_stmt|;
name|screen_trashed
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|MSDOS_COMPILER
operator|&&
name|MSDOS_COMPILER
operator|!=
name|WIN32C
comment|/* 	 * Restore the previous directory (possibly 	 * changed by the child program we just ran). 	 */
name|chdir
argument_list|(
name|cwd
argument_list|)
expr_stmt|;
if|#
directive|if
name|MSDOS_COMPILER
operator|!=
name|DJGPPC
comment|/* 	 * Some versions of chdir() don't change to the drive 	 * which is part of CWD.  (DJGPP does this in chdir.) 	 */
if|if
condition|(
name|cwd
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|cwd
index|[
literal|0
index|]
operator|>=
literal|'a'
operator|&&
name|cwd
index|[
literal|0
index|]
operator|<=
literal|'z'
condition|)
name|setdisk
argument_list|(
name|cwd
index|[
literal|0
index|]
operator|-
literal|'a'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cwd
index|[
literal|0
index|]
operator|>=
literal|'A'
operator|&&
name|cwd
index|[
literal|0
index|]
operator|<=
literal|'Z'
condition|)
name|setdisk
argument_list|(
name|cwd
index|[
literal|0
index|]
operator|-
literal|'A'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* 	 * Reopen the current input file. 	 */
name|reedit_ifile
argument_list|(
name|save_ifile
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|||
name|defined
argument_list|(
name|SIGWIND
argument_list|)
comment|/* 	 * Since we were ignoring window change signals while we executed 	 * the system command, we must assume the window changed. 	 * Warning: this leaves a signal pending (in "sigs"), 	 * so psignals() should be called soon after lsystem(). 	 */
name|winch
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|PIPEC
end_if

begin_comment
comment|/*  * Pipe a section of the input file into the given shell command.  * The section to be piped is the section "between" the current  * position and the position marked by the given letter.  *  * If the mark is after the current screen, the section between  * the top line displayed and the mark is piped.  * If the mark is before the current screen, the section between  * the mark and the bottom line displayed is piped.  * If the mark is on the current screen, or if the mark is ".",  * the whole current screen is piped.  */
end_comment

begin_function
name|public
name|int
name|pipe_mark
parameter_list|(
name|c
parameter_list|,
name|cmd
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
block|{
name|POSITION
name|mpos
decl_stmt|,
name|tpos
decl_stmt|,
name|bpos
decl_stmt|;
comment|/* 	 * mpos = the marked position. 	 * tpos = top of screen. 	 * bpos = bottom of screen. 	 */
name|mpos
operator|=
name|markpos
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpos
operator|==
name|NULL_POSITION
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|tpos
operator|=
name|position
argument_list|(
name|TOP
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpos
operator|==
name|NULL_POSITION
condition|)
name|tpos
operator|=
name|ch_zero
argument_list|()
expr_stmt|;
name|bpos
operator|=
name|position
argument_list|(
name|BOTTOM
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
return|return
operator|(
name|pipe_data
argument_list|(
name|cmd
argument_list|,
name|tpos
argument_list|,
name|bpos
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|mpos
operator|<=
name|tpos
condition|)
return|return
operator|(
name|pipe_data
argument_list|(
name|cmd
argument_list|,
name|mpos
argument_list|,
name|bpos
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|bpos
operator|==
name|NULL_POSITION
condition|)
return|return
operator|(
name|pipe_data
argument_list|(
name|cmd
argument_list|,
name|tpos
argument_list|,
name|bpos
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|pipe_data
argument_list|(
name|cmd
argument_list|,
name|tpos
argument_list|,
name|mpos
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a pipe to the given shell command.  * Feed it the file contents between the positions spos and epos.  */
end_comment

begin_function
name|public
name|int
name|pipe_data
parameter_list|(
name|cmd
parameter_list|,
name|spos
parameter_list|,
name|epos
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
name|POSITION
name|spos
decl_stmt|;
name|POSITION
name|epos
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|extern
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
comment|/* 	 * This is structured much like lsystem(). 	 * Since we're running a shell program, we must be careful 	 * to perform the necessary deinitialization before running 	 * the command, and reinitialization after it. 	 */
if|if
condition|(
name|ch_seek
argument_list|(
name|spos
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Cannot seek to start position"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|f
operator|=
name|popen
argument_list|(
name|cmd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Cannot create pipe"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|clear_bot
argument_list|()
expr_stmt|;
name|putstr
argument_list|(
literal|"!"
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|deinit
argument_list|()
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|raw_mode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|init_signals
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
name|close_getchr
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
name|LSIGNAL
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|EOI
expr_stmt|;
while|while
condition|(
name|epos
operator|==
name|NULL_POSITION
operator|||
name|spos
operator|++
operator|<=
name|epos
condition|)
block|{
comment|/* 		 * Read a character from the file and give it to the pipe. 		 */
name|c
operator|=
name|ch_forw_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOI
condition|)
break|break;
if|if
condition|(
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
operator|==
name|EOF
condition|)
break|break;
block|}
comment|/* 	 * Finish up the last line. 	 */
while|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOI
condition|)
block|{
name|c
operator|=
name|ch_forw_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOI
condition|)
break|break;
if|if
condition|(
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
operator|==
name|EOF
condition|)
break|break;
block|}
name|pclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGPIPE
name|LSIGNAL
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
name|open_getchr
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|init_signals
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|raw_mode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|init
argument_list|()
expr_stmt|;
name|screen_trashed
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|||
name|defined
argument_list|(
name|SIGWIND
argument_list|)
comment|/* {{ Probably don't need this here. }} */
name|winch
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

