begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  tables.c - tables serialization code  *  *  Copyright (c) 1990 The Regents of the University of California.  *  All rights reserved.  *  *  This code is derived from software contributed to Berkeley by  *  Vern Paxson.  *  *  The United States Government has rights in this work pursuant  *  to contract no. DE-AC03-76SF00098 between the United States  *  Department of Energy and the University of California.  *  *  This file is part of flex.  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  *  *  Neither the name of the University nor the names of its contributors  *  may be used to endorse or promote products derived from this software  *  without specific prior written permission.  *  *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  *  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  *  PURPOSE.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"flexdef.h"
end_include

begin_include
include|#
directive|include
file|"tables.h"
end_include

begin_comment
comment|/** Convert size_t to t_flag.  *  @param n in {1,2,4}  *  @return YYTD_DATA*.   */
end_comment

begin_define
define|#
directive|define
name|BYTES2TFLAG
parameter_list|(
name|n
parameter_list|)
define|\
value|(((n) == sizeof(flex_int8_t))\         ? YYTD_DATA8\         :(((n)== sizeof(flex_int16_t))\             ? YYTD_DATA16\             : YYTD_DATA32))
end_define

begin_comment
comment|/** Clear YYTD_DATA* bit flags  * @return the flag with the YYTD_DATA* bits cleared  */
end_comment

begin_define
define|#
directive|define
name|TFLAGS_CLRDATA
parameter_list|(
name|flg
parameter_list|)
value|((flg)& ~(YYTD_DATA8 | YYTD_DATA16 | YYTD_DATA32))
end_define

begin_function_decl
name|int
name|yytbl_write32
parameter_list|(
name|struct
name|yytbl_writer
modifier|*
name|wr
parameter_list|,
name|flex_uint32_t
name|v
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|yytbl_write16
parameter_list|(
name|struct
name|yytbl_writer
modifier|*
name|wr
parameter_list|,
name|flex_uint16_t
name|v
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|yytbl_write8
parameter_list|(
name|struct
name|yytbl_writer
modifier|*
name|wr
parameter_list|,
name|flex_uint8_t
name|v
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|yytbl_writen
parameter_list|(
name|struct
name|yytbl_writer
modifier|*
name|wr
parameter_list|,
name|void
modifier|*
name|v
parameter_list|,
name|flex_int32_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|flex_int32_t
name|yytbl_data_geti
parameter_list|(
specifier|const
name|struct
name|yytbl_data
modifier|*
name|tbl
parameter_list|,
name|int
name|i
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* XXX Not used static flex_int32_t yytbl_data_getijk (const struct yytbl_data *tbl, int i, 				  int j, int k);  */
end_comment

begin_comment
comment|/** Initialize the table writer.  *  @param wr an uninitialized writer  *  @param the output file  *  @return 0 on success  */
end_comment

begin_function
name|int
name|yytbl_writer_init
parameter_list|(
name|struct
name|yytbl_writer
modifier|*
name|wr
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
block|{
name|wr
operator|->
name|out
operator|=
name|out
expr_stmt|;
name|wr
operator|->
name|total_written
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** Initialize a table header.  *  @param th  The uninitialized structure  *  @param version_str the  version string  *  @param name the name of this table set  */
end_comment

begin_function
name|int
name|yytbl_hdr_init
parameter_list|(
name|struct
name|yytbl_hdr
modifier|*
name|th
parameter_list|,
specifier|const
name|char
modifier|*
name|version_str
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|memset
argument_list|(
name|th
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|yytbl_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_magic
operator|=
name|YYTBL_MAGIC
expr_stmt|;
name|th
operator|->
name|th_hsize
operator|=
literal|14
operator|+
name|strlen
argument_list|(
name|version_str
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|th
operator|->
name|th_hsize
operator|+=
name|yypad64
argument_list|(
name|th
operator|->
name|th_hsize
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_ssize
operator|=
literal|0
expr_stmt|;
comment|// Not known at this point.
name|th
operator|->
name|th_flags
operator|=
literal|0
expr_stmt|;
name|th
operator|->
name|th_version
operator|=
name|copy_string
argument_list|(
name|version_str
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_name
operator|=
name|copy_string
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** Allocate and initialize a table data structure.  *  @param tbl a pointer to an uninitialized table  *  @param id  the table identifier  *  @return 0 on success  */
end_comment

begin_function
name|int
name|yytbl_data_init
parameter_list|(
name|struct
name|yytbl_data
modifier|*
name|td
parameter_list|,
name|enum
name|yytbl_id
name|id
parameter_list|)
block|{
name|memset
argument_list|(
name|td
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|yytbl_data
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_id
operator|=
name|id
expr_stmt|;
name|td
operator|->
name|td_flags
operator|=
name|YYTD_DATA32
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** Clean up table and data array.  *  @param td will be destroyed  *  @return 0 on success  */
end_comment

begin_function
name|int
name|yytbl_data_destroy
parameter_list|(
name|struct
name|yytbl_data
modifier|*
name|td
parameter_list|)
block|{
if|if
condition|(
name|td
operator|->
name|td_data
condition|)
name|free
argument_list|(
name|td
operator|->
name|td_data
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_data
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|td
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** Write enough padding to bring the file pointer to a 64-bit boundary. */
end_comment

begin_function
specifier|static
name|int
name|yytbl_write_pad64
parameter_list|(
name|struct
name|yytbl_writer
modifier|*
name|wr
parameter_list|)
block|{
name|int
name|pad
decl_stmt|,
name|bwritten
init|=
literal|0
decl_stmt|;
name|pad
operator|=
name|yypad64
argument_list|(
name|wr
operator|->
name|total_written
argument_list|)
expr_stmt|;
while|while
condition|(
name|pad
operator|--
operator|>
literal|0
condition|)
if|if
condition|(
name|yytbl_write8
argument_list|(
name|wr
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
else|else
name|bwritten
operator|++
expr_stmt|;
return|return
name|bwritten
return|;
block|}
end_function

begin_comment
comment|/** write the header.  *  @param out the output stream  *  @param th table header to be written  *  @return -1 on error, or bytes written on success.  */
end_comment

begin_function
name|int
name|yytbl_hdr_fwrite
parameter_list|(
name|struct
name|yytbl_writer
modifier|*
name|wr
parameter_list|,
specifier|const
name|struct
name|yytbl_hdr
modifier|*
name|th
parameter_list|)
block|{
name|int
name|sz
decl_stmt|,
name|rv
decl_stmt|;
name|int
name|bwritten
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|yytbl_write32
argument_list|(
name|wr
argument_list|,
name|th
operator|->
name|th_magic
argument_list|)
operator|<
literal|0
operator|||
name|yytbl_write32
argument_list|(
name|wr
argument_list|,
name|th
operator|->
name|th_hsize
argument_list|)
operator|<
literal|0
condition|)
name|flex_die
argument_list|(
name|_
argument_list|(
literal|"th_magic|th_hsize write32 failed"
argument_list|)
argument_list|)
expr_stmt|;
name|bwritten
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|fgetpos
argument_list|(
name|wr
operator|->
name|out
argument_list|,
operator|&
operator|(
name|wr
operator|->
name|th_ssize_pos
operator|)
argument_list|)
operator|!=
literal|0
condition|)
name|flex_die
argument_list|(
name|_
argument_list|(
literal|"fgetpos failed"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yytbl_write32
argument_list|(
name|wr
argument_list|,
name|th
operator|->
name|th_ssize
argument_list|)
operator|<
literal|0
operator|||
name|yytbl_write16
argument_list|(
name|wr
argument_list|,
name|th
operator|->
name|th_flags
argument_list|)
operator|<
literal|0
condition|)
name|flex_die
argument_list|(
name|_
argument_list|(
literal|"th_ssize|th_flags write failed"
argument_list|)
argument_list|)
expr_stmt|;
name|bwritten
operator|+=
literal|6
expr_stmt|;
name|sz
operator|=
name|strlen
argument_list|(
name|th
operator|->
name|th_version
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|yytbl_writen
argument_list|(
name|wr
argument_list|,
name|th
operator|->
name|th_version
argument_list|,
name|sz
argument_list|)
operator|)
operator|!=
name|sz
condition|)
name|flex_die
argument_list|(
name|_
argument_list|(
literal|"th_version writen failed"
argument_list|)
argument_list|)
expr_stmt|;
name|bwritten
operator|+=
name|rv
expr_stmt|;
name|sz
operator|=
name|strlen
argument_list|(
name|th
operator|->
name|th_name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|yytbl_writen
argument_list|(
name|wr
argument_list|,
name|th
operator|->
name|th_name
argument_list|,
name|sz
argument_list|)
operator|)
operator|!=
name|sz
condition|)
name|flex_die
argument_list|(
name|_
argument_list|(
literal|"th_name writen failed"
argument_list|)
argument_list|)
expr_stmt|;
name|bwritten
operator|+=
name|rv
expr_stmt|;
comment|/* add padding */
if|if
condition|(
operator|(
name|rv
operator|=
name|yytbl_write_pad64
argument_list|(
name|wr
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|flex_die
argument_list|(
name|_
argument_list|(
literal|"pad64 failed"
argument_list|)
argument_list|)
expr_stmt|;
name|bwritten
operator|+=
name|rv
expr_stmt|;
comment|/* Sanity check */
if|if
condition|(
name|bwritten
operator|!=
operator|(
name|int
operator|)
name|th
operator|->
name|th_hsize
condition|)
name|flex_die
argument_list|(
name|_
argument_list|(
literal|"pad64 failed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bwritten
return|;
block|}
end_function

begin_comment
comment|/** Write this table.  *  @param out the file writer  *  @param td table data to be written  *  @return -1 on error, or bytes written on success.  */
end_comment

begin_function
name|int
name|yytbl_data_fwrite
parameter_list|(
name|struct
name|yytbl_writer
modifier|*
name|wr
parameter_list|,
name|struct
name|yytbl_data
modifier|*
name|td
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|flex_int32_t
name|bwritten
init|=
literal|0
decl_stmt|;
name|flex_int32_t
name|i
decl_stmt|,
name|total_len
decl_stmt|;
name|fpos_t
name|pos
decl_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|yytbl_write16
argument_list|(
name|wr
argument_list|,
name|td
operator|->
name|td_id
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|bwritten
operator|+=
name|rv
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|yytbl_write16
argument_list|(
name|wr
argument_list|,
name|td
operator|->
name|td_flags
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|bwritten
operator|+=
name|rv
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|yytbl_write32
argument_list|(
name|wr
argument_list|,
name|td
operator|->
name|td_hilen
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|bwritten
operator|+=
name|rv
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|yytbl_write32
argument_list|(
name|wr
argument_list|,
name|td
operator|->
name|td_lolen
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|bwritten
operator|+=
name|rv
expr_stmt|;
name|total_len
operator|=
name|yytbl_calc_total_len
argument_list|(
name|td
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total_len
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|YYTDFLAGS2BYTES
argument_list|(
name|td
operator|->
name|td_flags
argument_list|)
condition|)
block|{
case|case
sizeof|sizeof
argument_list|(
name|flex_int8_t
argument_list|)
case|:
name|rv
operator|=
name|yytbl_write8
argument_list|(
name|wr
argument_list|,
name|yytbl_data_geti
argument_list|(
name|td
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|flex_int16_t
argument_list|)
case|:
name|rv
operator|=
name|yytbl_write16
argument_list|(
name|wr
argument_list|,
name|yytbl_data_geti
argument_list|(
name|td
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|flex_int32_t
argument_list|)
case|:
name|rv
operator|=
name|yytbl_write32
argument_list|(
name|wr
argument_list|,
name|yytbl_data_geti
argument_list|(
name|td
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|flex_die
argument_list|(
name|_
argument_list|(
literal|"invalid td_flags detected"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rv
operator|<
literal|0
condition|)
block|{
name|flex_die
argument_list|(
name|_
argument_list|(
literal|"error while writing tables"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bwritten
operator|+=
name|rv
expr_stmt|;
block|}
comment|/* Sanity check */
if|if
condition|(
name|bwritten
operator|!=
call|(
name|int
call|)
argument_list|(
literal|12
operator|+
name|total_len
operator|*
name|YYTDFLAGS2BYTES
argument_list|(
name|td
operator|->
name|td_flags
argument_list|)
argument_list|)
condition|)
block|{
name|flex_die
argument_list|(
name|_
argument_list|(
literal|"insanity detected"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* add padding */
if|if
condition|(
operator|(
name|rv
operator|=
name|yytbl_write_pad64
argument_list|(
name|wr
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|flex_die
argument_list|(
name|_
argument_list|(
literal|"pad64 failed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bwritten
operator|+=
name|rv
expr_stmt|;
comment|/* Now go back and update the th_hsize member */
if|if
condition|(
name|fgetpos
argument_list|(
name|wr
operator|->
name|out
argument_list|,
operator|&
name|pos
argument_list|)
operator|!=
literal|0
operator|||
name|fsetpos
argument_list|(
name|wr
operator|->
name|out
argument_list|,
operator|&
operator|(
name|wr
operator|->
name|th_ssize_pos
operator|)
argument_list|)
operator|!=
literal|0
operator|||
name|yytbl_write32
argument_list|(
name|wr
argument_list|,
name|wr
operator|->
name|total_written
argument_list|)
operator|<
literal|0
operator|||
name|fsetpos
argument_list|(
name|wr
operator|->
name|out
argument_list|,
operator|&
name|pos
argument_list|)
condition|)
block|{
name|flex_die
argument_list|(
name|_
argument_list|(
literal|"get|set|fwrite32 failed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
comment|/* Don't count the int we just wrote. */
name|wr
operator|->
name|total_written
operator|-=
sizeof|sizeof
argument_list|(
name|flex_int32_t
argument_list|)
expr_stmt|;
return|return
name|bwritten
return|;
block|}
end_function

begin_comment
comment|/** Write n bytes.  *  @param  wr   the table writer  *  @param  v    data to be written  *  @param  len  number of bytes  *  @return  -1 on error. number of bytes written on success.  */
end_comment

begin_function
name|int
name|yytbl_writen
parameter_list|(
name|struct
name|yytbl_writer
modifier|*
name|wr
parameter_list|,
name|void
modifier|*
name|v
parameter_list|,
name|flex_int32_t
name|len
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|rv
operator|=
name|fwrite
argument_list|(
name|v
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|wr
operator|->
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|len
condition|)
return|return
operator|-
literal|1
return|;
name|wr
operator|->
name|total_written
operator|+=
name|len
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/** Write four bytes in network byte order  *  @param  wr  the table writer  *  @param  v    a dword in host byte order  *  @return  -1 on error. number of bytes written on success.  */
end_comment

begin_function
name|int
name|yytbl_write32
parameter_list|(
name|struct
name|yytbl_writer
modifier|*
name|wr
parameter_list|,
name|flex_uint32_t
name|v
parameter_list|)
block|{
name|flex_uint32_t
name|vnet
decl_stmt|;
name|size_t
name|bytes
decl_stmt|,
name|rv
decl_stmt|;
name|vnet
operator|=
name|htonl
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|bytes
operator|=
sizeof|sizeof
argument_list|(
name|flex_uint32_t
argument_list|)
expr_stmt|;
name|rv
operator|=
name|fwrite
argument_list|(
operator|&
name|vnet
argument_list|,
name|bytes
argument_list|,
literal|1
argument_list|,
name|wr
operator|->
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|wr
operator|->
name|total_written
operator|+=
name|bytes
expr_stmt|;
return|return
name|bytes
return|;
block|}
end_function

begin_comment
comment|/** Write two bytes in network byte order.  *  @param  wr  the table writer  *  @param  v    a word in host byte order  *  @return  -1 on error. number of bytes written on success.  */
end_comment

begin_function
name|int
name|yytbl_write16
parameter_list|(
name|struct
name|yytbl_writer
modifier|*
name|wr
parameter_list|,
name|flex_uint16_t
name|v
parameter_list|)
block|{
name|flex_uint16_t
name|vnet
decl_stmt|;
name|size_t
name|bytes
decl_stmt|,
name|rv
decl_stmt|;
name|vnet
operator|=
name|htons
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|bytes
operator|=
sizeof|sizeof
argument_list|(
name|flex_uint16_t
argument_list|)
expr_stmt|;
name|rv
operator|=
name|fwrite
argument_list|(
operator|&
name|vnet
argument_list|,
name|bytes
argument_list|,
literal|1
argument_list|,
name|wr
operator|->
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|wr
operator|->
name|total_written
operator|+=
name|bytes
expr_stmt|;
return|return
name|bytes
return|;
block|}
end_function

begin_comment
comment|/** Write a byte.  *  @param  wr  the table writer  *  @param  v    the value to be written  *  @return  -1 on error. number of bytes written on success.  */
end_comment

begin_function
name|int
name|yytbl_write8
parameter_list|(
name|struct
name|yytbl_writer
modifier|*
name|wr
parameter_list|,
name|flex_uint8_t
name|v
parameter_list|)
block|{
name|size_t
name|bytes
decl_stmt|,
name|rv
decl_stmt|;
name|bytes
operator|=
sizeof|sizeof
argument_list|(
name|flex_uint8_t
argument_list|)
expr_stmt|;
name|rv
operator|=
name|fwrite
argument_list|(
operator|&
name|v
argument_list|,
name|bytes
argument_list|,
literal|1
argument_list|,
name|wr
operator|->
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|wr
operator|->
name|total_written
operator|+=
name|bytes
expr_stmt|;
return|return
name|bytes
return|;
block|}
end_function

begin_comment
comment|/* XXX Not Used */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/** Extract data element [i][j] from array data tables.   * @param tbl data table  * @param i index into higher dimension array. i should be zero for one-dimensional arrays.  * @param j index into lower dimension array.  * @param k index into struct, must be 0 or 1. Only valid for YYTD_ID_TRANSITION table  * @return data[i][j + k]  */
end_comment

begin_endif
unit|static flex_int32_t yytbl_data_getijk (const struct yytbl_data *tbl, int i, 				  int j, int k) { 	flex_int32_t lo;  	k %= 2; 	lo = tbl->td_lolen;  	switch (YYTDFLAGS2BYTES (tbl->td_flags)) { 	case sizeof (flex_int8_t): 		return ((flex_int8_t *) (tbl->td_data))[(i * lo + j) * (k + 1) + 						   k]; 	case sizeof (flex_int16_t): 		return ((flex_int16_t *) (tbl->td_data))[(i * lo + j) * (k + 								    1) + 						    k]; 	case sizeof (flex_int32_t): 		return ((flex_int32_t *) (tbl->td_data))[(i * lo + j) * (k + 								    1) + 						    k]; 	default: 		flex_die (_("invalid td_flags detected")); 		break; 	}  	return 0; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Not used */
end_comment

begin_comment
comment|/** Extract data element [i] from array data tables treated as a single flat array of integers.  * Be careful for 2-dimensional arrays or for YYTD_ID_TRANSITION, which is an array  * of structs.   * @param tbl data table  * @param i index into array.  * @return data[i]  */
end_comment

begin_function
specifier|static
name|flex_int32_t
name|yytbl_data_geti
parameter_list|(
specifier|const
name|struct
name|yytbl_data
modifier|*
name|tbl
parameter_list|,
name|int
name|i
parameter_list|)
block|{
switch|switch
condition|(
name|YYTDFLAGS2BYTES
argument_list|(
name|tbl
operator|->
name|td_flags
argument_list|)
condition|)
block|{
case|case
sizeof|sizeof
argument_list|(
name|flex_int8_t
argument_list|)
case|:
return|return
operator|(
operator|(
name|flex_int8_t
operator|*
operator|)
operator|(
name|tbl
operator|->
name|td_data
operator|)
operator|)
index|[
name|i
index|]
return|;
case|case
sizeof|sizeof
argument_list|(
name|flex_int16_t
argument_list|)
case|:
return|return
operator|(
operator|(
name|flex_int16_t
operator|*
operator|)
operator|(
name|tbl
operator|->
name|td_data
operator|)
operator|)
index|[
name|i
index|]
return|;
case|case
sizeof|sizeof
argument_list|(
name|flex_int32_t
argument_list|)
case|:
return|return
operator|(
operator|(
name|flex_int32_t
operator|*
operator|)
operator|(
name|tbl
operator|->
name|td_data
operator|)
operator|)
index|[
name|i
index|]
return|;
default|default:
name|flex_die
argument_list|(
name|_
argument_list|(
literal|"invalid td_flags detected"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** Set data element [i] in array data tables treated as a single flat array of integers.  * Be careful for 2-dimensional arrays or for YYTD_ID_TRANSITION, which is an array  * of structs.   * @param tbl data table  * @param i index into array.  * @param newval new value for data[i]  */
end_comment

begin_function
specifier|static
name|void
name|yytbl_data_seti
parameter_list|(
specifier|const
name|struct
name|yytbl_data
modifier|*
name|tbl
parameter_list|,
name|int
name|i
parameter_list|,
name|flex_int32_t
name|newval
parameter_list|)
block|{
switch|switch
condition|(
name|YYTDFLAGS2BYTES
argument_list|(
name|tbl
operator|->
name|td_flags
argument_list|)
condition|)
block|{
case|case
sizeof|sizeof
argument_list|(
name|flex_int8_t
argument_list|)
case|:
operator|(
operator|(
name|flex_int8_t
operator|*
operator|)
operator|(
name|tbl
operator|->
name|td_data
operator|)
operator|)
index|[
name|i
index|]
operator|=
operator|(
name|flex_int8_t
operator|)
name|newval
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|flex_int16_t
argument_list|)
case|:
operator|(
operator|(
name|flex_int16_t
operator|*
operator|)
operator|(
name|tbl
operator|->
name|td_data
operator|)
operator|)
index|[
name|i
index|]
operator|=
operator|(
name|flex_int16_t
operator|)
name|newval
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|flex_int32_t
argument_list|)
case|:
operator|(
operator|(
name|flex_int32_t
operator|*
operator|)
operator|(
name|tbl
operator|->
name|td_data
operator|)
operator|)
index|[
name|i
index|]
operator|=
operator|(
name|flex_int32_t
operator|)
name|newval
expr_stmt|;
break|break;
default|default:
name|flex_die
argument_list|(
name|_
argument_list|(
literal|"invalid td_flags detected"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/** Calculate the number of bytes  needed to hold the largest  *  absolute value in this data array.  *  @param tbl  the data table  *  @return sizeof(n) where n in {flex_int8_t, flex_int16_t, flex_int32_t}  */
end_comment

begin_function
specifier|static
name|size_t
name|min_int_size
parameter_list|(
name|struct
name|yytbl_data
modifier|*
name|tbl
parameter_list|)
block|{
name|flex_uint32_t
name|i
decl_stmt|,
name|total_len
decl_stmt|;
name|flex_int32_t
name|max
init|=
literal|0
decl_stmt|;
name|total_len
operator|=
name|yytbl_calc_total_len
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total_len
condition|;
name|i
operator|++
control|)
block|{
name|flex_int32_t
name|n
decl_stmt|;
name|n
operator|=
name|abs
argument_list|(
name|yytbl_data_geti
argument_list|(
name|tbl
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|max
condition|)
name|max
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|max
operator|<=
name|INT8_MAX
condition|)
return|return
sizeof|sizeof
argument_list|(
name|flex_int8_t
argument_list|)
return|;
elseif|else
if|if
condition|(
name|max
operator|<=
name|INT16_MAX
condition|)
return|return
sizeof|sizeof
argument_list|(
name|flex_int16_t
argument_list|)
return|;
else|else
return|return
sizeof|sizeof
argument_list|(
name|flex_int32_t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** Transform data to smallest possible of (int32, int16, int8).  * For example, we may have generated an int32 array due to user options  * (e.g., %option align), but if the maximum value in that array  * is 80 (for example), then we can serialize it with only 1 byte per int.  * This is NOT the same as compressed DFA tables. We're just trying  * to save storage space here.  *  * @param tbl the table to be compressed  */
end_comment

begin_function
name|void
name|yytbl_data_compress
parameter_list|(
name|struct
name|yytbl_data
modifier|*
name|tbl
parameter_list|)
block|{
name|flex_int32_t
name|i
decl_stmt|,
name|newsz
decl_stmt|,
name|total_len
decl_stmt|;
name|struct
name|yytbl_data
name|newtbl
decl_stmt|;
name|yytbl_data_init
argument_list|(
operator|&
name|newtbl
argument_list|,
name|tbl
operator|->
name|td_id
argument_list|)
expr_stmt|;
name|newtbl
operator|.
name|td_hilen
operator|=
name|tbl
operator|->
name|td_hilen
expr_stmt|;
name|newtbl
operator|.
name|td_lolen
operator|=
name|tbl
operator|->
name|td_lolen
expr_stmt|;
name|newtbl
operator|.
name|td_flags
operator|=
name|tbl
operator|->
name|td_flags
expr_stmt|;
name|newsz
operator|=
name|min_int_size
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsz
operator|==
operator|(
name|int
operator|)
name|YYTDFLAGS2BYTES
argument_list|(
name|tbl
operator|->
name|td_flags
argument_list|)
condition|)
comment|/* No change in this table needed. */
return|return;
if|if
condition|(
name|newsz
operator|>
operator|(
name|int
operator|)
name|YYTDFLAGS2BYTES
argument_list|(
name|tbl
operator|->
name|td_flags
argument_list|)
condition|)
block|{
name|flex_die
argument_list|(
name|_
argument_list|(
literal|"detected negative compression"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|total_len
operator|=
name|yytbl_calc_total_len
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
name|newtbl
operator|.
name|td_data
operator|=
name|calloc
argument_list|(
name|total_len
argument_list|,
name|newsz
argument_list|)
expr_stmt|;
name|newtbl
operator|.
name|td_flags
operator|=
name|TFLAGS_CLRDATA
argument_list|(
name|newtbl
operator|.
name|td_flags
argument_list|)
operator||
name|BYTES2TFLAG
argument_list|(
name|newsz
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total_len
condition|;
name|i
operator|++
control|)
block|{
name|flex_int32_t
name|g
decl_stmt|;
name|g
operator|=
name|yytbl_data_geti
argument_list|(
name|tbl
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|yytbl_data_seti
argument_list|(
operator|&
name|newtbl
argument_list|,
name|i
argument_list|,
name|g
argument_list|)
expr_stmt|;
block|}
comment|/* Now copy over the old table */
name|free
argument_list|(
name|tbl
operator|->
name|td_data
argument_list|)
expr_stmt|;
operator|*
name|tbl
operator|=
name|newtbl
expr_stmt|;
block|}
end_function

begin_comment
comment|/* vim:set noexpandtab cindent tabstop=8 softtabstop=0 shiftwidth=8 textwidth=0: */
end_comment

end_unit

