begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: getaddrinfo.c,v 1.5 2007/07/22 05:19:01 lukem Exp $	*/
end_comment

begin_comment
comment|/*	from	?	*/
end_comment

begin_comment
comment|/*  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Issues to be discussed:  * - Thread safe-ness must be checked.  * - Return values.  There are nonstandard return values defined and used  *   in the source code.  This is because RFC2553 is silent about which error  *   code must be returned for which situation.  * - IPv4 classful (shortened) form.  RFC2553 is silent about it.  XNET 5.2  *   says to use inet_aton() to convert IPv4 numeric to binary (alows  *   classful form as a result).  *   current code - disallow classful form for IPv4 (due to use of inet_pton).  * - freeaddrinfo(NULL).  RFC2553 is silent about it.  XNET 5.2 says it is  *   invalid.  *   current code - SEGV on freeaddrinfo(NULL)  * Note:  * - We use getipnodebyname() just for thread-safeness.  There's no intent  *   to let it do PF_UNSPEC (actually we never pass PF_UNSPEC to  *   getipnodebyname().  * - The code filters out AFs that are not supported by the kernel,  *   when globbing NULL hostname (to loopback, or wildcard).  Is it the right  *   thing to do?  What is the relationship with post-RFC2553 AI_ADDRCONFIG  *   in ai_flags?  * - (post-2553) semantics of AI_ADDRCONFIG itself is too vague.  *   (1) what should we do against numeric hostname (2) what should we do  *   against NULL hostname (3) what is AI_ADDRCONFIG itself.  AF not ready?  *   non-loopback address configured?  global address configured?  * - The code makes use of following calls when asked to resolver with  *   ai_family  = PF_UNSPEC:  *	getipnodebyname(host, AF_INET6);  *	getipnodebyname(host, AF_INET);  *   This will result in the following queries if the node is configure to  *   prefer /etc/hosts than DNS:  *	lookup /etc/hosts for IPv6 address  *	lookup DNS for IPv6 address  *	lookup /etc/hosts for IPv4 address  *	lookup DNS for IPv4 address  *   which may not meet people's requirement.  *   The right thing to happen is to have underlying layer which does  *   PF_UNSPEC lookup (lookup both) and return chain of addrinfos.  *   This would result in a bit of code duplicate with _dns_ghbyname() and  *   friends.  */
end_comment

begin_include
include|#
directive|include
file|"tnftp.h"
end_include

begin_define
define|#
directive|define
name|SUCCESS
value|0
end_define

begin_define
define|#
directive|define
name|ANY
value|0
end_define

begin_define
define|#
directive|define
name|YES
value|1
end_define

begin_define
define|#
directive|define
name|NO
value|0
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
name|in_addrany
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|in_loopback
index|[]
init|=
block|{
literal|127
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|in6_addrany
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|in6_loopback
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_struct
specifier|static
specifier|const
struct|struct
name|afd
block|{
name|int
name|a_af
decl_stmt|;
name|int
name|a_addrlen
decl_stmt|;
name|int
name|a_socklen
decl_stmt|;
name|int
name|a_off
decl_stmt|;
specifier|const
name|char
modifier|*
name|a_addrany
decl_stmt|;
specifier|const
name|char
modifier|*
name|a_loopback
decl_stmt|;
name|int
name|a_scoped
decl_stmt|;
block|}
name|afdl
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|INET6
block|{
name|PF_INET6
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|,
name|sin6_addr
argument_list|)
block|,
name|in6_addrany
block|,
name|in6_loopback
block|,
literal|1
block|}
block|,
endif|#
directive|endif
block|{
name|PF_INET
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|,
name|sin_addr
argument_list|)
block|,
name|in_addrany
block|,
name|in_loopback
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|, }
struct|;
end_struct

begin_struct
struct|struct
name|explore
block|{
name|int
name|e_af
decl_stmt|;
name|int
name|e_socktype
decl_stmt|;
name|int
name|e_protocol
decl_stmt|;
specifier|const
name|char
modifier|*
name|e_protostr
decl_stmt|;
name|int
name|e_wild
decl_stmt|;
define|#
directive|define
name|WILD_AF
parameter_list|(
name|ex
parameter_list|)
value|((ex)->e_wild& 0x01)
define|#
directive|define
name|WILD_SOCKTYPE
parameter_list|(
name|ex
parameter_list|)
value|((ex)->e_wild& 0x02)
define|#
directive|define
name|WILD_PROTOCOL
parameter_list|(
name|ex
parameter_list|)
value|((ex)->e_wild& 0x04)
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|explore
name|explore
index|[]
init|=
block|{
if|#
directive|if
literal|0
block|{ PF_LOCAL, 0, ANY, ANY, NULL, 0x01 },
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
block|{
name|PF_INET6
block|,
name|SOCK_DGRAM
block|,
name|IPPROTO_UDP
block|,
literal|"udp"
block|,
literal|0x07
block|}
block|,
block|{
name|PF_INET6
block|,
name|SOCK_STREAM
block|,
name|IPPROTO_TCP
block|,
literal|"tcp"
block|,
literal|0x07
block|}
block|,
block|{
name|PF_INET6
block|,
name|SOCK_RAW
block|,
name|ANY
block|,
name|NULL
block|,
literal|0x05
block|}
block|,
endif|#
directive|endif
block|{
name|PF_INET
block|,
name|SOCK_DGRAM
block|,
name|IPPROTO_UDP
block|,
literal|"udp"
block|,
literal|0x07
block|}
block|,
block|{
name|PF_INET
block|,
name|SOCK_STREAM
block|,
name|IPPROTO_TCP
block|,
literal|"tcp"
block|,
literal|0x07
block|}
block|,
block|{
name|PF_INET
block|,
name|SOCK_RAW
block|,
name|ANY
block|,
name|NULL
block|,
literal|0x05
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_define
define|#
directive|define
name|PTON_MAX
value|16
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PTON_MAX
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|str_isnumber
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|explore_fqdn
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|explore_null
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|explore_numeric
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|explore_numeric_scope
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_canonname
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|,
name|struct
name|addrinfo
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|addrinfo
modifier|*
name|get_ai
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|,
specifier|const
name|struct
name|afd
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_portmatch
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_port
parameter_list|(
name|struct
name|addrinfo
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|afd
modifier|*
name|find_afd
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|addrconfig
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function_decl
specifier|static
name|int
name|ip6_str2scopeid
parameter_list|(
name|char
modifier|*
parameter_list|,
name|struct
name|sockaddr_in6
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ai_errlist
index|[]
init|=
block|{
literal|"Success"
block|,
literal|"Address family for hostname not supported"
block|,
comment|/* EAI_ADDRFAMILY */
literal|"Temporary failure in name resolution"
block|,
comment|/* EAI_AGAIN      */
literal|"Invalid value for ai_flags"
block|,
comment|/* EAI_BADFLAGS   */
literal|"Non-recoverable failure in name resolution"
block|,
comment|/* EAI_FAIL       */
literal|"ai_family not supported"
block|,
comment|/* EAI_FAMILY     */
literal|"Memory allocation failure"
block|,
comment|/* EAI_MEMORY     */
literal|"No address associated with hostname"
block|,
comment|/* EAI_NODATA     */
literal|"hostname nor servname provided, or not known"
block|,
comment|/* EAI_NONAME     */
literal|"servname not supported for ai_socktype"
block|,
comment|/* EAI_SERVICE    */
literal|"ai_socktype not supported"
block|,
comment|/* EAI_SOCKTYPE   */
literal|"System error returned in errno"
block|,
comment|/* EAI_SYSTEM     */
literal|"Invalid value for hints"
block|,
comment|/* EAI_BADHINTS	  */
literal|"Resolved protocol is unknown"
block|,
comment|/* EAI_PROTOCOL   */
literal|"Unknown error"
block|,
comment|/* EAI_MAX        */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX macros that make external reference is BAD. */
end_comment

begin_define
define|#
directive|define
name|GET_AI
parameter_list|(
name|ai
parameter_list|,
name|afd
parameter_list|,
name|addr
parameter_list|)
define|\
value|do { \
comment|/* external reference: pai, error, and label free */
value|\ 	(ai) = get_ai(pai, (afd), (addr)); \ 	if ((ai) == NULL) { \ 		error = EAI_MEMORY; \ 		goto free; \ 	} \ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_define
define|#
directive|define
name|GET_PORT
parameter_list|(
name|ai
parameter_list|,
name|serv
parameter_list|)
define|\
value|do { \
comment|/* external reference: error and label free */
value|\ 	error = get_port((ai), (serv), 0); \ 	if (error != 0) \ 		goto free; \ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_define
define|#
directive|define
name|GET_CANONNAME
parameter_list|(
name|ai
parameter_list|,
name|str
parameter_list|)
define|\
value|do { \
comment|/* external reference: pai, error and label free */
value|\ 	error = get_canonname(pai, (ai), (str)); \ 	if (error != 0) \ 		goto free; \ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_define
define|#
directive|define
name|ERR
parameter_list|(
name|err
parameter_list|)
define|\
value|do { \
comment|/* external reference: error, and label bad */
value|\ 	error = (err); \ 	goto bad; \
comment|/*NOTREACHED*/
value|\ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_define
define|#
directive|define
name|MATCH_FAMILY
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|w
parameter_list|)
define|\
value|((x) == (y) || (
comment|/*CONSTCOND*/
value|(w)&& ((x) == PF_UNSPEC || (y) == PF_UNSPEC)))
end_define

begin_define
define|#
directive|define
name|MATCH
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|w
parameter_list|)
define|\
value|((x) == (y) || (
comment|/*CONSTCOND*/
value|(w)&& ((x) == ANY || (y) == ANY)))
end_define

begin_function
specifier|const
name|char
modifier|*
name|gai_strerror
parameter_list|(
name|int
name|ecode
parameter_list|)
block|{
if|if
condition|(
name|ecode
operator|<
literal|0
operator|||
name|ecode
operator|>
name|EAI_MAX
condition|)
name|ecode
operator|=
name|EAI_MAX
expr_stmt|;
return|return
name|ai_errlist
index|[
name|ecode
index|]
return|;
block|}
end_function

begin_function
name|void
name|freeaddrinfo
parameter_list|(
name|struct
name|addrinfo
modifier|*
name|ai
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|next
decl_stmt|;
do|do
block|{
name|next
operator|=
name|ai
operator|->
name|ai_next
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_canonname
condition|)
name|free
argument_list|(
name|ai
operator|->
name|ai_canonname
argument_list|)
expr_stmt|;
comment|/* no need to free(ai->ai_addr) */
name|free
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|ai
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
name|ai
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|int
name|str_isnumber
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|char
modifier|*
name|ep
decl_stmt|;
name|long
name|l
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
name|NO
return|;
name|ep
operator|=
name|NULL
expr_stmt|;
name|l
operator|=
name|strtol
argument_list|(
name|p
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|&&
operator|*
name|ep
operator|==
literal|'\0'
operator|&&
name|l
operator|>=
literal|0
condition|)
return|return
name|YES
return|;
else|else
return|return
name|NO
return|;
block|}
end_function

begin_function
name|int
name|getaddrinfo
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
specifier|const
name|char
modifier|*
name|servname
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
name|hints
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|addrinfo
name|sentinel
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|cur
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|addrinfo
name|ai
decl_stmt|;
name|struct
name|addrinfo
name|ai0
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
specifier|const
name|struct
name|explore
modifier|*
name|ex
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sentinel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sentinel
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
name|pai
operator|=
operator|&
name|ai
expr_stmt|;
name|pai
operator|->
name|ai_flags
operator|=
literal|0
expr_stmt|;
name|pai
operator|->
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|pai
operator|->
name|ai_socktype
operator|=
name|ANY
expr_stmt|;
name|pai
operator|->
name|ai_protocol
operator|=
name|ANY
expr_stmt|;
name|pai
operator|->
name|ai_addrlen
operator|=
literal|0
expr_stmt|;
name|pai
operator|->
name|ai_canonname
operator|=
name|NULL
expr_stmt|;
name|pai
operator|->
name|ai_addr
operator|=
name|NULL
expr_stmt|;
name|pai
operator|->
name|ai_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hostname
operator|==
name|NULL
operator|&&
name|servname
operator|==
name|NULL
condition|)
return|return
name|EAI_NONAME
return|;
if|if
condition|(
name|hints
condition|)
block|{
comment|/* error check for hints */
if|if
condition|(
name|hints
operator|->
name|ai_addrlen
operator|||
name|hints
operator|->
name|ai_canonname
operator|||
name|hints
operator|->
name|ai_addr
operator|||
name|hints
operator|->
name|ai_next
condition|)
name|ERR
argument_list|(
name|EAI_BADHINTS
argument_list|)
expr_stmt|;
comment|/* xxx */
if|if
condition|(
name|hints
operator|->
name|ai_flags
operator|&
operator|~
name|AI_MASK
condition|)
name|ERR
argument_list|(
name|EAI_BADFLAGS
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hints
operator|->
name|ai_family
condition|)
block|{
case|case
name|PF_UNSPEC
case|:
case|case
name|PF_INET
case|:
ifdef|#
directive|ifdef
name|INET6
case|case
name|PF_INET6
case|:
endif|#
directive|endif
break|break;
default|default:
name|ERR
argument_list|(
name|EAI_FAMILY
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|pai
argument_list|,
name|hints
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pai
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * if both socktype/protocol are specified, check if they 		 * are meaningful combination. 		 */
if|if
condition|(
name|pai
operator|->
name|ai_socktype
operator|!=
name|ANY
operator|&&
name|pai
operator|->
name|ai_protocol
operator|!=
name|ANY
condition|)
block|{
for|for
control|(
name|ex
operator|=
name|explore
init|;
name|ex
operator|->
name|e_af
operator|>=
literal|0
condition|;
name|ex
operator|++
control|)
block|{
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|!=
name|ex
operator|->
name|e_af
condition|)
continue|continue;
if|if
condition|(
name|ex
operator|->
name|e_socktype
operator|==
name|ANY
condition|)
continue|continue;
if|if
condition|(
name|ex
operator|->
name|e_protocol
operator|==
name|ANY
condition|)
continue|continue;
if|if
condition|(
name|pai
operator|->
name|ai_socktype
operator|==
name|ex
operator|->
name|e_socktype
operator|&&
name|pai
operator|->
name|ai_protocol
operator|!=
name|ex
operator|->
name|e_protocol
condition|)
block|{
name|ERR
argument_list|(
name|EAI_BADHINTS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * post-2553: AI_ALL and AI_V4MAPPED are effective only against 	 * AF_INET6 query.  They needs to be ignored if specified in other 	 * occassions. 	 */
switch|switch
condition|(
name|pai
operator|->
name|ai_flags
operator|&
operator|(
name|AI_ALL
operator||
name|AI_V4MAPPED
operator|)
condition|)
block|{
case|case
name|AI_V4MAPPED
case|:
case|case
name|AI_ALL
operator||
name|AI_V4MAPPED
case|:
ifdef|#
directive|ifdef
name|INET6
comment|/* XXXLUKEM */
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|!=
name|AF_INET6
condition|)
name|pai
operator|->
name|ai_flags
operator|&=
operator|~
operator|(
name|AI_ALL
operator||
name|AI_V4MAPPED
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|AI_ALL
case|:
if|#
directive|if
literal|1
comment|/* illegal */
name|ERR
argument_list|(
name|EAI_BADFLAGS
argument_list|)
expr_stmt|;
else|#
directive|else
name|pai
operator|->
name|ai_flags
operator|&=
operator|~
operator|(
name|AI_ALL
operator||
name|AI_V4MAPPED
operator|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
comment|/* 	 * check for special cases.  (1) numeric servname is disallowed if 	 * socktype/protocol are left unspecified. (2) servname is disallowed 	 * for raw and other inet{,6} sockets. 	 */
if|if
condition|(
name|MATCH_FAMILY
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|,
name|PF_INET
argument_list|,
literal|1
argument_list|)
ifdef|#
directive|ifdef
name|PF_INET6
operator|||
name|MATCH_FAMILY
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|,
name|PF_INET6
argument_list|,
literal|1
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|ai0
operator|=
operator|*
name|pai
expr_stmt|;
comment|/* backup *pai */
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|==
name|PF_UNSPEC
condition|)
block|{
ifdef|#
directive|ifdef
name|PF_INET6
name|pai
operator|->
name|ai_family
operator|=
name|PF_INET6
expr_stmt|;
else|#
directive|else
name|pai
operator|->
name|ai_family
operator|=
name|PF_INET
expr_stmt|;
endif|#
directive|endif
block|}
name|error
operator|=
name|get_portmatch
argument_list|(
name|pai
argument_list|,
name|servname
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|ERR
argument_list|(
name|error
argument_list|)
expr_stmt|;
operator|*
name|pai
operator|=
name|ai0
expr_stmt|;
block|}
name|ai0
operator|=
operator|*
name|pai
expr_stmt|;
comment|/* NULL hostname, or numeric hostname */
for|for
control|(
name|ex
operator|=
name|explore
init|;
name|ex
operator|->
name|e_af
operator|>=
literal|0
condition|;
name|ex
operator|++
control|)
block|{
operator|*
name|pai
operator|=
name|ai0
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH_FAMILY
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|,
name|ex
operator|->
name|e_af
argument_list|,
name|WILD_AF
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|pai
operator|->
name|ai_socktype
argument_list|,
name|ex
operator|->
name|e_socktype
argument_list|,
name|WILD_SOCKTYPE
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|pai
operator|->
name|ai_protocol
argument_list|,
name|ex
operator|->
name|e_protocol
argument_list|,
name|WILD_PROTOCOL
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|==
name|PF_UNSPEC
condition|)
name|pai
operator|->
name|ai_family
operator|=
name|ex
operator|->
name|e_af
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_socktype
operator|==
name|ANY
operator|&&
name|ex
operator|->
name|e_socktype
operator|!=
name|ANY
condition|)
name|pai
operator|->
name|ai_socktype
operator|=
name|ex
operator|->
name|e_socktype
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_protocol
operator|==
name|ANY
operator|&&
name|ex
operator|->
name|e_protocol
operator|!=
name|ANY
condition|)
name|pai
operator|->
name|ai_protocol
operator|=
name|ex
operator|->
name|e_protocol
expr_stmt|;
if|if
condition|(
name|hostname
operator|==
name|NULL
condition|)
name|error
operator|=
name|explore_null
argument_list|(
name|pai
argument_list|,
name|servname
argument_list|,
operator|&
name|cur
operator|->
name|ai_next
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|explore_numeric_scope
argument_list|(
name|pai
argument_list|,
name|hostname
argument_list|,
name|servname
argument_list|,
operator|&
name|cur
operator|->
name|ai_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|free
goto|;
while|while
condition|(
name|cur
operator|&&
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
comment|/* 	 * XXX 	 * If numreic representation of AF1 can be interpreted as FQDN 	 * representation of AF2, we need to think again about the code below. 	 */
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
goto|goto
name|good
goto|;
if|if
condition|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_NUMERICHOST
condition|)
name|ERR
argument_list|(
name|EAI_NODATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostname
operator|==
name|NULL
condition|)
name|ERR
argument_list|(
name|EAI_NODATA
argument_list|)
expr_stmt|;
comment|/* 	 * hostname as alphabetical name. 	 * we would like to prefer AF_INET6 than AF_INET, so we'll make a 	 * outer loop by AFs. 	 */
for|for
control|(
name|afd
operator|=
name|afdl
init|;
name|afd
operator|->
name|a_af
condition|;
name|afd
operator|++
control|)
block|{
operator|*
name|pai
operator|=
name|ai0
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH_FAMILY
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|,
name|afd
operator|->
name|a_af
argument_list|,
literal|1
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|ex
operator|=
name|explore
init|;
name|ex
operator|->
name|e_af
operator|>=
literal|0
condition|;
name|ex
operator|++
control|)
block|{
operator|*
name|pai
operator|=
name|ai0
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|==
name|PF_UNSPEC
condition|)
name|pai
operator|->
name|ai_family
operator|=
name|afd
operator|->
name|a_af
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH_FAMILY
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|,
name|ex
operator|->
name|e_af
argument_list|,
name|WILD_AF
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|pai
operator|->
name|ai_socktype
argument_list|,
name|ex
operator|->
name|e_socktype
argument_list|,
name|WILD_SOCKTYPE
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|pai
operator|->
name|ai_protocol
argument_list|,
name|ex
operator|->
name|e_protocol
argument_list|,
name|WILD_PROTOCOL
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|==
name|PF_UNSPEC
condition|)
name|pai
operator|->
name|ai_family
operator|=
name|ex
operator|->
name|e_af
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_socktype
operator|==
name|ANY
operator|&&
name|ex
operator|->
name|e_socktype
operator|!=
name|ANY
condition|)
name|pai
operator|->
name|ai_socktype
operator|=
name|ex
operator|->
name|e_socktype
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_protocol
operator|==
name|ANY
operator|&&
name|ex
operator|->
name|e_protocol
operator|!=
name|ANY
condition|)
name|pai
operator|->
name|ai_protocol
operator|=
name|ex
operator|->
name|e_protocol
expr_stmt|;
name|error
operator|=
name|explore_fqdn
argument_list|(
name|pai
argument_list|,
name|hostname
argument_list|,
name|servname
argument_list|,
operator|&
name|cur
operator|->
name|ai_next
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur
operator|&&
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
block|}
comment|/* XXX */
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|free
goto|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
block|{
name|good
label|:
operator|*
name|res
operator|=
name|sentinel
operator|.
name|ai_next
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
else|else
name|error
operator|=
name|EAI_FAIL
expr_stmt|;
block|}
name|free
label|:
name|bad
label|:
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
name|freeaddrinfo
argument_list|(
name|sentinel
operator|.
name|ai_next
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * FQDN hostname, DNS lookup  */
end_comment

begin_function
specifier|static
name|int
name|explore_fqdn
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
specifier|const
name|char
modifier|*
name|servname
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|int
name|h_error
decl_stmt|;
name|int
name|af
decl_stmt|;
name|char
modifier|*
modifier|*
name|aplist
init|=
name|NULL
decl_stmt|,
modifier|*
name|apbuf
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ap
decl_stmt|;
name|struct
name|addrinfo
name|sentinel
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
name|int
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|USE_GETIPNODEBY
name|int
name|naddrs
decl_stmt|;
endif|#
directive|endif
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|#
directive|if
literal|0
block|struct addrinfo pai4;
ifdef|#
directive|ifdef
name|INET6
block|struct addrinfo pai6;
endif|#
directive|endif
endif|#
directive|endif
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
name|sentinel
operator|.
name|ai_next
operator|=
name|NULL
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
comment|/* 	 * If AI_ADDRCONFIG is specified, check if we are expected to 	 * return the address family or not. 	 * assumes PF_UNSPEC = PF_INET + PF_INET6. 	 * 	 * NOTE: PF_UNSPEC case is for future use. 	 */
if|if
condition|(
operator|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_ADDRCONFIG
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|pai
operator|->
name|ai_family
condition|)
block|{
if|#
directive|if
literal|0
block|case PF_UNSPEC: 			pai4 = pai6 = *pai; 			pai4.ai_family = PF_INET;
ifndef|#
directive|ifndef
name|INET6
block|if (!addrconfig(&pai4)) 				return 0;
else|#
directive|else
block|pai6.ai_family = PF_INET6; 			if (!addrconfig(&pai4)) { 				if (!addrconfig(&pai6)) 					return 0; 				pai =&pai6; 			} else { 				if (!addrconfig(&pai6)) 					pai =&pai4; 				else 					;
comment|/* as is */
block|}
endif|#
directive|endif
block|break;
endif|#
directive|endif
default|default:
if|if
condition|(
operator|!
name|addrconfig
argument_list|(
name|pai
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
block|}
block|}
comment|/* 	 * if the servname does not match socktype/protocol, ignore it. 	 */
if|if
condition|(
name|get_portmatch
argument_list|(
name|pai
argument_list|,
name|servname
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|afd
operator|=
name|find_afd
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|)
expr_stmt|;
if|if
condition|(
name|afd
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|USE_GETIPNODEBY
name|hp
operator|=
name|getipnodebyname
argument_list|(
name|hostname
argument_list|,
name|pai
operator|->
name|ai_family
argument_list|,
name|pai
operator|->
name|ai_flags
operator|&
name|AI_ADDRCONFIG
argument_list|,
operator|&
name|h_error
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GETHOSTBYNAME2
argument_list|)
name|hp
operator|=
name|gethostbyname2
argument_list|(
name|hostname
argument_list|,
name|pai
operator|->
name|ai_family
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|!=
name|AF_INET
condition|)
return|return
literal|0
return|;
name|hp
operator|=
name|gethostbyname
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(HAVE_GETHOSTBYNAME2) */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_H_ERRNO
argument_list|)
name|h_error
operator|=
name|h_errno
expr_stmt|;
else|#
directive|else
name|h_error
operator|=
name|EINVAL
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/*USE_GETIPNODEBY*/
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|h_error
condition|)
block|{
case|case
name|HOST_NOT_FOUND
case|:
case|case
name|NO_DATA
case|:
name|error
operator|=
name|EAI_NODATA
expr_stmt|;
break|break;
case|case
name|TRY_AGAIN
case|:
name|error
operator|=
name|EAI_AGAIN
expr_stmt|;
break|break;
case|case
name|NO_RECOVERY
case|:
ifdef|#
directive|ifdef
name|NETDB_INTERNAL
case|case
name|NETDB_INTERNAL
case|:
endif|#
directive|endif
default|default:
name|error
operator|=
name|EAI_FAIL
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|hp
operator|->
name|h_name
operator|==
name|NULL
operator|)
operator|||
operator|(
name|hp
operator|->
name|h_name
index|[
literal|0
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
name|hp
operator|->
name|h_addr_list
index|[
literal|0
index|]
operator|==
name|NULL
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_GETIPNODEBY
name|freehostent
argument_list|(
name|hp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|EAI_FAIL
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
goto|goto
name|free
goto|;
ifdef|#
directive|ifdef
name|USE_GETIPNODEBY
name|aplist
operator|=
name|hp
operator|->
name|h_addr_list
expr_stmt|;
else|#
directive|else
comment|/* 	 * hp will be overwritten if we use gethostbyname2(). 	 * always deep copy for simplification. 	 */
for|for
control|(
name|naddrs
operator|=
literal|0
init|;
name|hp
operator|->
name|h_addr_list
index|[
name|naddrs
index|]
operator|!=
name|NULL
condition|;
name|naddrs
operator|++
control|)
empty_stmt|;
name|naddrs
operator|++
expr_stmt|;
name|aplist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|aplist
index|[
literal|0
index|]
argument_list|)
operator|*
name|naddrs
argument_list|)
expr_stmt|;
name|apbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|hp
operator|->
name|h_length
operator|*
name|naddrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|aplist
operator|==
name|NULL
operator|||
name|apbuf
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EAI_MEMORY
expr_stmt|;
goto|goto
name|free
goto|;
block|}
name|memset
argument_list|(
name|aplist
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|aplist
index|[
literal|0
index|]
argument_list|)
operator|*
name|naddrs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|naddrs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|aplist
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
name|memcpy
argument_list|(
operator|&
name|apbuf
index|[
name|i
operator|*
name|hp
operator|->
name|h_length
index|]
argument_list|,
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
argument_list|,
operator|(
name|size_t
operator|)
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|aplist
index|[
name|i
index|]
operator|=
operator|&
name|apbuf
index|[
name|i
operator|*
name|hp
operator|->
name|h_length
index|]
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|aplist
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|af
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
name|ap
operator|=
name|aplist
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|af
operator|==
name|AF_INET6
operator|&&
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|ap
argument_list|)
condition|)
block|{
name|af
operator|=
name|AF_INET
expr_stmt|;
name|ap
operator|=
name|ap
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|af
operator|!=
name|pai
operator|->
name|ai_family
condition|)
continue|continue;
name|GET_AI
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|afd
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|GET_PORT
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|servname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_CANONNAME
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * RFC2553 says that ai_canonname will be set only for 			 * the first element.  we do it for all the elements, 			 * just for convenience. 			 */
name|GET_CANONNAME
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|cur
operator|&&
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
operator|*
name|res
operator|=
name|sentinel
operator|.
name|ai_next
expr_stmt|;
return|return
literal|0
return|;
name|free
label|:
ifdef|#
directive|ifdef
name|USE_GETIPNODEBY
if|if
condition|(
name|hp
condition|)
name|freehostent
argument_list|(
name|hp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|aplist
condition|)
name|free
argument_list|(
name|aplist
argument_list|)
expr_stmt|;
if|if
condition|(
name|apbuf
condition|)
name|free
argument_list|(
name|apbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
name|freeaddrinfo
argument_list|(
name|sentinel
operator|.
name|ai_next
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * hostname == NULL.  * passive socket -> anyaddr (0.0.0.0 or ::)  * non-passive socket -> localhost (127.0.0.1 or ::1)  */
end_comment

begin_function
specifier|static
name|int
name|explore_null
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
parameter_list|,
specifier|const
name|char
modifier|*
name|servname
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
parameter_list|)
block|{
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|cur
decl_stmt|;
name|struct
name|addrinfo
name|sentinel
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
name|sentinel
operator|.
name|ai_next
operator|=
name|NULL
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
comment|/* 	 * filter out AFs that are not supported by the kernel 	 * XXX errno? 	 */
if|if
condition|(
operator|!
name|addrconfig
argument_list|(
name|pai
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* 	 * if the servname does not match socktype/protocol, ignore it. 	 */
if|if
condition|(
name|get_portmatch
argument_list|(
name|pai
argument_list|,
name|servname
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|afd
operator|=
name|find_afd
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|)
expr_stmt|;
if|if
condition|(
name|afd
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_PASSIVE
condition|)
block|{
name|GET_AI
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|afd
argument_list|,
name|afd
operator|->
name|a_addrany
argument_list|)
expr_stmt|;
comment|/* xxx meaningless? 		 * GET_CANONNAME(cur->ai_next, "anyaddr"); 		 */
name|GET_PORT
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|servname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GET_AI
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|afd
argument_list|,
name|afd
operator|->
name|a_loopback
argument_list|)
expr_stmt|;
comment|/* xxx meaningless? 		 * GET_CANONNAME(cur->ai_next, "localhost"); 		 */
name|GET_PORT
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|servname
argument_list|)
expr_stmt|;
block|}
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
operator|*
name|res
operator|=
name|sentinel
operator|.
name|ai_next
expr_stmt|;
return|return
literal|0
return|;
name|free
label|:
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
name|freeaddrinfo
argument_list|(
name|sentinel
operator|.
name|ai_next
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * numeric hostname  */
end_comment

begin_function
specifier|static
name|int
name|explore_numeric
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
specifier|const
name|char
modifier|*
name|servname
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
parameter_list|)
block|{
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|cur
decl_stmt|;
name|struct
name|addrinfo
name|sentinel
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|pton
index|[
name|PTON_MAX
index|]
decl_stmt|;
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
name|sentinel
operator|.
name|ai_next
operator|=
name|NULL
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
comment|/* 	 * if the servname does not match socktype/protocol, ignore it. 	 */
if|if
condition|(
name|get_portmatch
argument_list|(
name|pai
argument_list|,
name|servname
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|afd
operator|=
name|find_afd
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|)
expr_stmt|;
if|if
condition|(
name|afd
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|afd
operator|->
name|a_af
condition|)
block|{
if|#
directive|if
literal|0
comment|/*X/Open spec*/
block|case AF_INET: 		if (inet_aton(hostname, (struct in_addr *)pton) == 1) { 			if (pai->ai_family == afd->a_af || 			    pai->ai_family == PF_UNSPEC
comment|/*?*/
block|) { 				GET_AI(cur->ai_next, afd, pton); 				GET_PORT(cur->ai_next, servname); 				while (cur&& cur->ai_next) 					cur = cur->ai_next; 			} else 				ERR(EAI_FAMILY);
comment|/*xxx*/
block|} 		break;
endif|#
directive|endif
default|default:
if|if
condition|(
name|inet_pton
argument_list|(
name|afd
operator|->
name|a_af
argument_list|,
name|hostname
argument_list|,
name|pton
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|==
name|afd
operator|->
name|a_af
operator|||
name|pai
operator|->
name|ai_family
operator|==
name|PF_UNSPEC
comment|/*?*/
condition|)
block|{
name|GET_AI
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|afd
argument_list|,
name|pton
argument_list|)
expr_stmt|;
name|GET_PORT
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|servname
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur
operator|&&
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
else|else
name|ERR
argument_list|(
name|EAI_FAMILY
argument_list|)
expr_stmt|;
comment|/*xxx*/
block|}
break|break;
block|}
operator|*
name|res
operator|=
name|sentinel
operator|.
name|ai_next
expr_stmt|;
return|return
literal|0
return|;
name|free
label|:
name|bad
label|:
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
name|freeaddrinfo
argument_list|(
name|sentinel
operator|.
name|ai_next
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * numeric hostname with scope  */
end_comment

begin_function
specifier|static
name|int
name|explore_numeric_scope
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
specifier|const
name|char
modifier|*
name|servname
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SCOPE_DELIMITER
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|INET6
argument_list|)
return|return
name|explore_numeric
argument_list|(
name|pai
argument_list|,
name|hostname
argument_list|,
name|servname
argument_list|,
name|res
argument_list|)
return|;
else|#
directive|else
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|cur
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|hostname2
init|=
name|NULL
decl_stmt|,
modifier|*
name|scope
decl_stmt|,
modifier|*
name|addr
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
comment|/* 	 * if the servname does not match socktype/protocol, ignore it. 	 */
if|if
condition|(
name|get_portmatch
argument_list|(
name|pai
argument_list|,
name|servname
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|afd
operator|=
name|find_afd
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|)
expr_stmt|;
if|if
condition|(
name|afd
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|afd
operator|->
name|a_scoped
condition|)
return|return
name|explore_numeric
argument_list|(
name|pai
argument_list|,
name|hostname
argument_list|,
name|servname
argument_list|,
name|res
argument_list|)
return|;
name|cp
operator|=
name|strchr
argument_list|(
name|hostname
argument_list|,
name|SCOPE_DELIMITER
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
name|explore_numeric
argument_list|(
name|pai
argument_list|,
name|hostname
argument_list|,
name|servname
argument_list|,
name|res
argument_list|)
return|;
if|#
directive|if
literal|0
comment|/* 	 * Handle special case of<scope id><delimiter><scoped_address> 	 */
block|hostname2 = strdup(hostname); 	if (hostname2 == NULL) 		return EAI_MEMORY;
comment|/* terminate at the delimiter */
block|hostname2[cp - hostname] = '\0'; 	scope = hostname2; 	addr = cp + 1;
else|#
directive|else
comment|/* 	 * Handle special case of<scoped_address><delimiter><scope id> 	 */
name|hostname2
operator|=
name|strdup
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostname2
operator|==
name|NULL
condition|)
return|return
name|EAI_MEMORY
return|;
comment|/* terminate at the delimiter */
name|hostname2
index|[
name|cp
operator|-
name|hostname
index|]
operator|=
literal|'\0'
expr_stmt|;
name|addr
operator|=
name|hostname2
expr_stmt|;
name|scope
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|explore_numeric
argument_list|(
name|pai
argument_list|,
name|addr
argument_list|,
name|servname
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|int
name|scopeid
decl_stmt|;
for|for
control|(
name|cur
operator|=
operator|*
name|res
init|;
name|cur
condition|;
name|cur
operator|=
name|cur
operator|->
name|ai_next
control|)
block|{
if|if
condition|(
name|cur
operator|->
name|ai_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|cur
operator|->
name|ai_addr
expr_stmt|;
if|if
condition|(
operator|(
name|scopeid
operator|=
name|ip6_str2scopeid
argument_list|(
name|scope
argument_list|,
name|sin6
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|hostname2
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAI_NODATA
operator|)
return|;
comment|/* XXX: is return OK? */
block|}
name|sin6
operator|->
name|sin6_scope_id
operator|=
name|scopeid
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|hostname2
argument_list|)
expr_stmt|;
return|return
name|error
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|get_canonname
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
parameter_list|,
name|struct
name|addrinfo
modifier|*
name|ai
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
operator|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_CANONNAME
operator|)
operator|!=
literal|0
condition|)
block|{
name|ai
operator|->
name|ai_canonname
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_canonname
operator|==
name|NULL
condition|)
return|return
name|EAI_MEMORY
return|;
name|strcpy
argument_list|(
name|ai
operator|->
name|ai_canonname
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|addrinfo
modifier|*
name|get_ai
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
parameter_list|,
specifier|const
name|struct
name|afd
modifier|*
name|afd
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
name|ai
operator|=
operator|(
expr|struct
name|addrinfo
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
operator|+
operator|(
name|afd
operator|->
name|a_socklen
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
name|ai
argument_list|,
name|pai
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
argument_list|)
expr_stmt|;
name|ai
operator|->
name|ai_addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|ai
operator|+
literal|1
operator|)
expr_stmt|;
name|memset
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|)
name|afd
operator|->
name|a_socklen
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STRUCT_SOCKADDR_SA_LEN
argument_list|)
name|ai
operator|->
name|ai_addr
operator|->
name|sa_len
operator|=
name|afd
operator|->
name|a_socklen
expr_stmt|;
endif|#
directive|endif
name|ai
operator|->
name|ai_addrlen
operator|=
name|afd
operator|->
name|a_socklen
expr_stmt|;
name|ai
operator|->
name|ai_addr
operator|->
name|sa_family
operator|=
name|ai
operator|->
name|ai_family
operator|=
name|afd
operator|->
name|a_af
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|ai
operator|->
name|ai_addr
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|+
name|afd
operator|->
name|a_off
argument_list|,
name|addr
argument_list|,
operator|(
name|size_t
operator|)
name|afd
operator|->
name|a_addrlen
argument_list|)
expr_stmt|;
return|return
name|ai
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_portmatch
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
name|ai
parameter_list|,
specifier|const
name|char
modifier|*
name|servname
parameter_list|)
block|{
comment|/* get_port does not touch first argument. when matchonly == 1. */
comment|/* LINTED const cast */
return|return
name|get_port
argument_list|(
operator|(
expr|struct
name|addrinfo
operator|*
operator|)
name|ai
argument_list|,
name|servname
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_port
parameter_list|(
name|struct
name|addrinfo
modifier|*
name|ai
parameter_list|,
specifier|const
name|char
modifier|*
name|servname
parameter_list|,
name|int
name|matchonly
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|proto
decl_stmt|;
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
name|int
name|port
decl_stmt|;
name|int
name|allownumeric
decl_stmt|;
if|if
condition|(
name|servname
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|ai
operator|->
name|ai_family
condition|)
block|{
case|case
name|AF_INET
case|:
ifdef|#
directive|ifdef
name|AF_INET6
case|case
name|AF_INET6
case|:
endif|#
directive|endif
break|break;
default|default:
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|ai
operator|->
name|ai_socktype
condition|)
block|{
case|case
name|SOCK_RAW
case|:
return|return
name|EAI_SERVICE
return|;
case|case
name|SOCK_DGRAM
case|:
case|case
name|SOCK_STREAM
case|:
name|allownumeric
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ANY
case|:
name|allownumeric
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|EAI_SOCKTYPE
return|;
block|}
if|if
condition|(
name|str_isnumber
argument_list|(
name|servname
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|allownumeric
condition|)
return|return
name|EAI_SERVICE
return|;
name|port
operator|=
name|htons
argument_list|(
name|atoi
argument_list|(
name|servname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|<
literal|0
operator|||
name|port
operator|>
literal|65535
condition|)
return|return
name|EAI_SERVICE
return|;
block|}
else|else
block|{
switch|switch
condition|(
name|ai
operator|->
name|ai_socktype
condition|)
block|{
case|case
name|SOCK_DGRAM
case|:
name|proto
operator|=
literal|"udp"
expr_stmt|;
break|break;
case|case
name|SOCK_STREAM
case|:
name|proto
operator|=
literal|"tcp"
expr_stmt|;
break|break;
default|default:
name|proto
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|sp
operator|=
name|getservbyname
argument_list|(
name|servname
argument_list|,
name|proto
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|EAI_SERVICE
return|;
name|port
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|matchonly
condition|)
block|{
switch|switch
condition|(
name|ai
operator|->
name|ai_family
condition|)
block|{
case|case
name|AF_INET
case|:
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|ai
operator|->
name|ai_addr
operator|)
operator|->
name|sin_port
operator|=
name|port
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|ai
operator|->
name|ai_addr
operator|)
operator|->
name|sin6_port
operator|=
name|port
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|afd
modifier|*
name|find_afd
parameter_list|(
name|int
name|af
parameter_list|)
block|{
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
if|if
condition|(
name|af
operator|==
name|PF_UNSPEC
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|afd
operator|=
name|afdl
init|;
name|afd
operator|->
name|a_af
condition|;
name|afd
operator|++
control|)
block|{
if|if
condition|(
name|afd
operator|->
name|a_af
operator|==
name|af
condition|)
return|return
name|afd
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * post-2553: AI_ADDRCONFIG check.  if we use getipnodeby* as backend, backend  * will take care of it.  * the semantics of AI_ADDRCONFIG is not defined well.  we are not sure  * if the code is right or not.  */
end_comment

begin_function
specifier|static
name|int
name|addrconfig
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_GETIPNODEBY
return|return
literal|1
return|;
else|#
directive|else
name|int
name|s
decl_stmt|;
comment|/* XXX errno */
name|s
operator|=
name|socket
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EMFILE
condition|)
return|return
literal|0
return|;
block|}
else|else
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_comment
comment|/* convert a string to a scope identifier. XXX: IPv6 specific */
end_comment

begin_function
specifier|static
name|int
name|ip6_str2scopeid
parameter_list|(
name|char
modifier|*
name|scope
parameter_list|,
name|struct
name|sockaddr_in6
modifier|*
name|sin6
parameter_list|)
block|{
name|int
name|scopeid
decl_stmt|;
name|struct
name|in6_addr
modifier|*
name|a6
init|=
operator|&
name|sin6
operator|->
name|sin6_addr
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
comment|/* empty scopeid portion is invalid */
if|if
condition|(
operator|*
name|scope
operator|==
literal|'\0'
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
name|a6
argument_list|)
operator|||
name|IN6_IS_ADDR_MC_LINKLOCAL
argument_list|(
name|a6
argument_list|)
condition|)
block|{
comment|/* 		 * We currently assume a one-to-one mapping between links 		 * and interfaces, so we simply use interface indices for 		 * like-local scopes. 		 */
name|scopeid
operator|=
name|if_nametoindex
argument_list|(
name|scope
argument_list|)
expr_stmt|;
if|if
condition|(
name|scopeid
operator|==
literal|0
condition|)
goto|goto
name|trynumeric
goto|;
return|return
operator|(
name|scopeid
operator|)
return|;
block|}
comment|/* still unclear about literal, allow numeric only - placeholder */
if|if
condition|(
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
name|a6
argument_list|)
operator|||
name|IN6_IS_ADDR_MC_SITELOCAL
argument_list|(
name|a6
argument_list|)
condition|)
goto|goto
name|trynumeric
goto|;
if|if
condition|(
name|IN6_IS_ADDR_MC_ORGLOCAL
argument_list|(
name|a6
argument_list|)
condition|)
goto|goto
name|trynumeric
goto|;
else|else
goto|goto
name|trynumeric
goto|;
comment|/* global */
comment|/* try to convert to a numeric id as a last resort */
name|trynumeric
label|:
name|scopeid
operator|=
operator|(
name|int
operator|)
name|strtoul
argument_list|(
name|scope
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|==
literal|'\0'
condition|)
return|return
name|scopeid
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

