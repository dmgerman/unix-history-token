begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: snprintf.c,v 1.6 2007/07/22 05:19:02 lukem Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright Patrick Powell 1995  * This code is based on code written by Patrick Powell (papowell@astart.com)  * It may be used for any purpose as long as this notice remains intact  * on all source code distributions  */
end_comment

begin_comment
comment|/**************************************************************  * Original:  * Patrick Powell Tue Apr 11 09:48:21 PDT 1995  * A bombproof version of doprnt (dopr) included.  * Sigh.  This sort of thing is always nasty do deal with.  Note that  * the version here does not include floating point...  *  * snprintf() is used instead of sprintf() as it does limit checks  * for string length.  This covers a nasty loophole.  *  * The other functions are there to prevent NULL pointers from  * causing nast effects.  *  * More Recently:  *  Brandon Long<blong@fiction.net> 9/15/96 for mutt 0.43  *  This was ugly.  It is still ugly.  I opted out of floating point  *  numbers, but the formatter understands just about everything  *  from the normal C string format, at least as far as I can tell from  *  the Solaris 2.5 printf(3S) man page.  *  *  Brandon Long<blong@fiction.net> 10/22/97 for mutt 0.87.1  *    Ok, added some minimal floating point support, which means this  *    probably requires libm on most operating systems.  Don't yet  *    support the exponent (e,E) and sigfig (g,G).  Also, fmtint()  *    was pretty badly broken, it just wasn't being exercised in ways  *    which showed it, so that's been fixed.  Also, formated the code  *    to mutt conventions, and removed dead code left over from the  *    original.  Also, there is now a builtin-test, just compile with:  *           gcc -DTEST_SNPRINTF -o snprintf snprintf.c -lm  *    and run snprintf for results.  *  *  Thomas Roessler<roessler@guug.de> 01/27/98 for mutt 0.89i  *    The PGP code was using unsigned hexadecimal formats.  *    Unfortunately, unsigned formats simply didn't work.  *  *  Michael Elkins<me@cs.hmc.edu> 03/05/98 for mutt 0.90.8  *    The original code assumed that both snprintf() and vsnprintf() were  *    missing.  Some systems only have snprintf() but not vsnprintf(), so  *    the code is now broken down under HAVE_SNPRINTF and HAVE_VSNPRINTF.  *  *  Andrew Tridgell (tridge@samba.org) Oct 1998  *    fixed handling of %.0f  *    added test for HAVE_LONG_DOUBLE  *  *  Luke Mewburn<lukem@NetBSD.org>, Thu Sep 30 23:28:21 EST 1999  *	cleaned up formatting, autoconf tests  *	added long long support  *  **************************************************************/
end_comment

begin_include
include|#
directive|include
file|"tnftp.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LONG_DOUBLE
argument_list|)
end_if

begin_define
define|#
directive|define
name|LDOUBLE
value|long double
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LDOUBLE
value|double
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LONG_LONG_INT
argument_list|)
end_if

begin_define
define|#
directive|define
name|LLONG
value|long long
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LLONG
value|long
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|dopr
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|size_t
modifier|*
name|retlen
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fmtstr
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|char
modifier|*
name|value
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fmtint
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|LLONG
name|value
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fmtfp
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|LDOUBLE
name|fvalue
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dopr_outch
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|int
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * dopr(): poor man's version of doprintf  */
end_comment

begin_comment
comment|/* format read states */
end_comment

begin_define
define|#
directive|define
name|DP_S_DEFAULT
value|0
end_define

begin_define
define|#
directive|define
name|DP_S_FLAGS
value|1
end_define

begin_define
define|#
directive|define
name|DP_S_MIN
value|2
end_define

begin_define
define|#
directive|define
name|DP_S_DOT
value|3
end_define

begin_define
define|#
directive|define
name|DP_S_MAX
value|4
end_define

begin_define
define|#
directive|define
name|DP_S_MOD
value|5
end_define

begin_define
define|#
directive|define
name|DP_S_CONV
value|6
end_define

begin_define
define|#
directive|define
name|DP_S_DONE
value|7
end_define

begin_comment
comment|/* format flags - Bits */
end_comment

begin_define
define|#
directive|define
name|DP_F_MINUS
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|DP_F_PLUS
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|DP_F_SPACE
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|DP_F_NUM
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|DP_F_ZERO
value|(1<< 4)
end_define

begin_define
define|#
directive|define
name|DP_F_UP
value|(1<< 5)
end_define

begin_define
define|#
directive|define
name|DP_F_UNSIGNED
value|(1<< 6)
end_define

begin_comment
comment|/* Conversion Flags */
end_comment

begin_define
define|#
directive|define
name|DP_C_SHORT
value|1
end_define

begin_define
define|#
directive|define
name|DP_C_LONG
value|2
end_define

begin_define
define|#
directive|define
name|DP_C_LDOUBLE
value|3
end_define

begin_define
define|#
directive|define
name|DP_C_LLONG
value|4
end_define

begin_define
define|#
directive|define
name|char_to_int
parameter_list|(
name|p
parameter_list|)
value|(p - '0')
end_define

begin_function
specifier|static
name|void
name|dopr
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|size_t
modifier|*
name|retlen
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
name|char
name|ch
decl_stmt|;
name|LLONG
name|value
decl_stmt|;
name|LDOUBLE
name|fvalue
decl_stmt|;
name|char
modifier|*
name|strvalue
decl_stmt|;
name|int
name|min
decl_stmt|;
name|int
name|max
decl_stmt|;
name|int
name|state
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|cflags
decl_stmt|;
name|size_t
name|currlen
decl_stmt|;
name|state
operator|=
name|DP_S_DEFAULT
expr_stmt|;
name|flags
operator|=
name|currlen
operator|=
name|cflags
operator|=
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
operator|-
literal|1
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
while|while
condition|(
name|state
operator|!=
name|DP_S_DONE
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|currlen
operator|>=
name|maxlen
operator|)
condition|)
name|state
operator|=
name|DP_S_DONE
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|DP_S_DEFAULT
case|:
if|if
condition|(
name|ch
operator|==
literal|'%'
condition|)
name|state
operator|=
name|DP_S_FLAGS
expr_stmt|;
else|else
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
name|DP_S_FLAGS
case|:
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'-'
case|:
name|flags
operator||=
name|DP_F_MINUS
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|flags
operator||=
name|DP_F_PLUS
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|' '
case|:
name|flags
operator||=
name|DP_F_SPACE
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|flags
operator||=
name|DP_F_NUM
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
name|flags
operator||=
name|DP_F_ZERO
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
default|default:
name|state
operator|=
name|DP_S_MIN
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|DP_S_MIN
case|:
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|ch
argument_list|)
condition|)
block|{
name|min
operator|=
literal|10
operator|*
name|min
operator|+
name|char_to_int
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'*'
condition|)
block|{
name|min
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
name|state
operator|=
name|DP_S_DOT
expr_stmt|;
block|}
else|else
name|state
operator|=
name|DP_S_DOT
expr_stmt|;
break|break;
case|case
name|DP_S_DOT
case|:
if|if
condition|(
name|ch
operator|==
literal|'.'
condition|)
block|{
name|state
operator|=
name|DP_S_MAX
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
block|}
else|else
name|state
operator|=
name|DP_S_MOD
expr_stmt|;
break|break;
case|case
name|DP_S_MAX
case|:
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|max
operator|<
literal|0
condition|)
name|max
operator|=
literal|0
expr_stmt|;
name|max
operator|=
literal|10
operator|*
name|max
operator|+
name|char_to_int
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'*'
condition|)
block|{
name|max
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
name|state
operator|=
name|DP_S_MOD
expr_stmt|;
block|}
else|else
name|state
operator|=
name|DP_S_MOD
expr_stmt|;
break|break;
case|case
name|DP_S_MOD
case|:
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'h'
case|:
name|cflags
operator|=
name|DP_C_SHORT
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
operator|*
name|format
operator|==
literal|'l'
condition|)
block|{
name|cflags
operator|=
name|DP_C_LLONG
expr_stmt|;
name|format
operator|++
expr_stmt|;
block|}
else|else
name|cflags
operator|=
name|DP_C_LONG
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|cflags
operator|=
name|DP_C_LLONG
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|cflags
operator|=
name|DP_C_LDOUBLE
expr_stmt|;
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|state
operator|=
name|DP_S_CONV
expr_stmt|;
break|break;
case|case
name|DP_S_CONV
case|:
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
switch|switch
condition|(
name|cflags
condition|)
block|{
case|case
name|DP_C_SHORT
case|:
name|value
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|DP_C_LONG
case|:
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|long int
argument_list|)
expr_stmt|;
break|break;
case|case
name|DP_C_LLONG
case|:
name|value
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|LLONG
argument_list|)
expr_stmt|;
break|break;
default|default:
name|value
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
block|}
name|fmtint
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|value
argument_list|,
literal|10
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|flags
operator||=
name|DP_F_UP
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'x'
case|:
case|case
literal|'o'
case|:
case|case
literal|'u'
case|:
name|flags
operator||=
name|DP_F_UNSIGNED
expr_stmt|;
switch|switch
condition|(
name|cflags
condition|)
block|{
case|case
name|DP_C_SHORT
case|:
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
break|break;
case|case
name|DP_C_LONG
case|:
name|value
operator|=
operator|(
name|LLONG
operator|)
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned long int
argument_list|)
expr_stmt|;
break|break;
case|case
name|DP_C_LLONG
case|:
name|value
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned LLONG
argument_list|)
expr_stmt|;
break|break;
default|default:
name|value
operator|=
operator|(
name|LLONG
operator|)
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|unsigned int
argument_list|)
expr_stmt|;
break|break;
block|}
name|fmtint
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|value
argument_list|,
name|ch
operator|==
literal|'o'
condition|?
literal|8
else|:
operator|(
name|ch
operator|==
literal|'u'
condition|?
literal|10
else|:
literal|16
operator|)
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|cflags
operator|==
name|DP_C_LDOUBLE
condition|)
name|fvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|LDOUBLE
argument_list|)
expr_stmt|;
else|else
name|fvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|double
argument_list|)
expr_stmt|;
comment|/* um, floating point? */
name|fmtfp
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|fvalue
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|flags
operator||=
name|DP_F_UP
expr_stmt|;
case|case
literal|'e'
case|:
if|if
condition|(
name|cflags
operator|==
name|DP_C_LDOUBLE
condition|)
name|fvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|LDOUBLE
argument_list|)
expr_stmt|;
else|else
name|fvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|double
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|flags
operator||=
name|DP_F_UP
expr_stmt|;
case|case
literal|'g'
case|:
if|if
condition|(
name|cflags
operator|==
name|DP_C_LDOUBLE
condition|)
name|fvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|LDOUBLE
argument_list|)
expr_stmt|;
else|else
name|fvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|double
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|strvalue
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|<
literal|0
condition|)
name|max
operator|=
name|maxlen
expr_stmt|;
comment|/* ie, no max */
name|fmtstr
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|strvalue
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|value
operator|=
operator|(
name|long
operator|)
name|va_arg
argument_list|(
name|args
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|fmtint
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|value
argument_list|,
literal|16
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* XXX */
if|if
condition|(
name|cflags
operator|==
name|DP_C_SHORT
condition|)
block|{
name|short
name|int
modifier|*
name|num
decl_stmt|;
name|num
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|short int *
argument_list|)
expr_stmt|;
operator|*
name|num
operator|=
name|currlen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LONG
condition|)
block|{
comment|/* XXX */
name|long
name|int
modifier|*
name|num
decl_stmt|;
name|num
operator|=
name|va_arg
argument_list|(
argument|args
argument_list|,
argument|long int *
argument_list|)
expr_stmt|;
operator|*
name|num
operator|=
operator|(
name|long
name|int
operator|)
name|currlen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cflags
operator|==
name|DP_C_LLONG
condition|)
block|{
comment|/* XXX */
name|LLONG
modifier|*
name|num
decl_stmt|;
name|num
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|LLONG
operator|*
argument_list|)
expr_stmt|;
operator|*
name|num
operator|=
operator|(
name|LLONG
operator|)
name|currlen
expr_stmt|;
block|}
else|else
block|{
name|int
modifier|*
name|num
decl_stmt|;
name|num
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
operator|*
name|num
operator|=
name|currlen
expr_stmt|;
block|}
break|break;
case|case
literal|'%'
case|:
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
operator|&
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* not supported yet, treat as next char */
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
break|break;
default|default:
comment|/* Unknown, skip */
break|break;
block|}
name|ch
operator|=
operator|*
name|format
operator|++
expr_stmt|;
name|state
operator|=
name|DP_S_DEFAULT
expr_stmt|;
name|flags
operator|=
name|cflags
operator|=
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|DP_S_DONE
case|:
break|break;
default|default:
comment|/* hmm? */
break|break;
comment|/* some picky compilers need this */
block|}
block|}
if|if
condition|(
name|currlen
operator|>=
name|maxlen
operator|-
literal|1
condition|)
name|currlen
operator|=
name|maxlen
operator|-
literal|1
expr_stmt|;
name|buffer
index|[
name|currlen
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|retlen
operator|=
name|currlen
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fmtstr
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|char
modifier|*
name|value
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|padlen
decl_stmt|,
name|strln
decl_stmt|;
comment|/* amount to pad */
name|int
name|cnt
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
name|value
operator|=
literal|"<NULL>"
expr_stmt|;
block|}
for|for
control|(
name|strln
operator|=
literal|0
init|;
name|value
index|[
name|strln
index|]
condition|;
operator|++
name|strln
control|)
empty_stmt|;
comment|/* strlen */
name|padlen
operator|=
name|min
operator|-
name|strln
expr_stmt|;
if|if
condition|(
name|padlen
operator|<
literal|0
condition|)
name|padlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DP_F_MINUS
condition|)
name|padlen
operator|=
operator|-
name|padlen
expr_stmt|;
comment|/* Left Justify */
while|while
condition|(
operator|(
name|padlen
operator|>
literal|0
operator|)
operator|&&
operator|(
name|cnt
operator|<
name|max
operator|)
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|--
name|padlen
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|value
operator|&&
operator|(
name|cnt
operator|<
name|max
operator|)
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
operator|*
name|value
operator|++
argument_list|)
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|padlen
operator|<
literal|0
operator|)
operator|&&
operator|(
name|cnt
operator|<
name|max
operator|)
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|++
name|padlen
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Have to handle DP_F_NUM (ie 0x and 0 alternates) */
end_comment

begin_function
specifier|static
name|void
name|fmtint
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|LLONG
name|value
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|signvalue
init|=
literal|0
decl_stmt|;
name|unsigned
name|LLONG
name|uvalue
decl_stmt|;
name|char
name|convert
index|[
literal|20
index|]
decl_stmt|;
name|int
name|place
init|=
literal|0
decl_stmt|;
name|int
name|spadlen
init|=
literal|0
decl_stmt|;
comment|/* amount to space pad */
name|int
name|zpadlen
init|=
literal|0
decl_stmt|;
comment|/* amount to zero pad */
name|int
name|caps
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|max
operator|<
literal|0
condition|)
name|max
operator|=
literal|0
expr_stmt|;
name|uvalue
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|DP_F_UNSIGNED
operator|)
condition|)
block|{
if|if
condition|(
name|value
operator|<
literal|0
condition|)
block|{
name|signvalue
operator|=
literal|'-'
expr_stmt|;
name|uvalue
operator|=
operator|-
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|DP_F_PLUS
condition|)
comment|/* Do a sign (+/i) */
name|signvalue
operator|=
literal|'+'
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|DP_F_SPACE
condition|)
name|signvalue
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|DP_F_UP
condition|)
name|caps
operator|=
literal|1
expr_stmt|;
comment|/* Should characters be upper case? */
do|do
block|{
name|convert
index|[
name|place
operator|++
index|]
operator|=
operator|(
name|caps
condition|?
literal|"0123456789ABCDEF"
else|:
literal|"0123456789abcdef"
operator|)
index|[
name|uvalue
operator|%
operator|(
name|unsigned
operator|)
name|base
index|]
expr_stmt|;
name|uvalue
operator|=
operator|(
name|uvalue
operator|/
operator|(
name|unsigned
operator|)
name|base
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|uvalue
operator|&&
operator|(
name|place
operator|<
literal|20
operator|)
condition|)
do|;
if|if
condition|(
name|place
operator|==
literal|20
condition|)
name|place
operator|--
expr_stmt|;
name|convert
index|[
name|place
index|]
operator|=
literal|0
expr_stmt|;
name|zpadlen
operator|=
name|max
operator|-
name|place
expr_stmt|;
name|spadlen
operator|=
name|min
operator|-
name|MAX
argument_list|(
name|max
argument_list|,
name|place
argument_list|)
operator|-
operator|(
name|signvalue
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|zpadlen
operator|<
literal|0
condition|)
name|zpadlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|spadlen
operator|<
literal|0
condition|)
name|spadlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DP_F_ZERO
condition|)
block|{
name|zpadlen
operator|=
name|MAX
argument_list|(
name|zpadlen
argument_list|,
name|spadlen
argument_list|)
expr_stmt|;
name|spadlen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|DP_F_MINUS
condition|)
name|spadlen
operator|=
operator|-
name|spadlen
expr_stmt|;
comment|/* Left Justifty */
ifdef|#
directive|ifdef
name|DEBUG_SNPRINTF
name|printf
argument_list|(
literal|"zpad: %d, spad: %d, min: %d, max: %d, place: %d\n"
argument_list|,
name|zpadlen
argument_list|,
name|spadlen
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|place
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Spaces */
while|while
condition|(
name|spadlen
operator|>
literal|0
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|--
name|spadlen
expr_stmt|;
block|}
comment|/* Sign */
if|if
condition|(
name|signvalue
condition|)
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|signvalue
argument_list|)
expr_stmt|;
comment|/* Zeros */
if|if
condition|(
name|zpadlen
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|zpadlen
operator|>
literal|0
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
operator|--
name|zpadlen
expr_stmt|;
block|}
block|}
comment|/* Digits */
while|while
condition|(
name|place
operator|>
literal|0
condition|)
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|convert
index|[
operator|--
name|place
index|]
argument_list|)
expr_stmt|;
comment|/* Left Justified spaces */
while|while
condition|(
name|spadlen
operator|<
literal|0
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|++
name|spadlen
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|LDOUBLE
name|abs_val
parameter_list|(
name|LDOUBLE
name|value
parameter_list|)
block|{
name|LDOUBLE
name|result
init|=
name|value
decl_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|result
operator|=
operator|-
name|value
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|LDOUBLE
name|pow10
parameter_list|(
name|int
name|exp
parameter_list|)
block|{
name|LDOUBLE
name|result
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|exp
condition|)
block|{
name|result
operator|*=
literal|10
expr_stmt|;
name|exp
operator|--
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|round
parameter_list|(
name|LDOUBLE
name|value
parameter_list|)
block|{
name|long
name|intpart
decl_stmt|;
name|intpart
operator|=
operator|(
name|long
operator|)
name|value
expr_stmt|;
name|value
operator|=
name|value
operator|-
name|intpart
expr_stmt|;
if|if
condition|(
name|value
operator|>=
literal|0.5
condition|)
name|intpart
operator|++
expr_stmt|;
return|return
name|intpart
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fmtfp
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|LDOUBLE
name|fvalue
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|signvalue
init|=
literal|0
decl_stmt|;
name|LDOUBLE
name|ufvalue
decl_stmt|;
name|char
name|iconvert
index|[
literal|20
index|]
decl_stmt|;
name|char
name|fconvert
index|[
literal|20
index|]
decl_stmt|;
name|int
name|iplace
init|=
literal|0
decl_stmt|;
name|int
name|fplace
init|=
literal|0
decl_stmt|;
name|int
name|padlen
init|=
literal|0
decl_stmt|;
comment|/* amount to pad */
name|int
name|zpadlen
init|=
literal|0
decl_stmt|;
name|int
name|caps
init|=
literal|0
decl_stmt|;
name|long
name|intpart
decl_stmt|;
name|long
name|fracpart
decl_stmt|;
comment|/* AIX manpage says the default is 0, but Solaris says the default is 	 * 6, and sprintf on AIX defaults to 6 */
if|if
condition|(
name|max
operator|<
literal|0
condition|)
name|max
operator|=
literal|6
expr_stmt|;
name|ufvalue
operator|=
name|abs_val
argument_list|(
name|fvalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|fvalue
operator|<
literal|0
condition|)
name|signvalue
operator|=
literal|'-'
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|DP_F_PLUS
condition|)
comment|/* Do a sign (+/i) */
name|signvalue
operator|=
literal|'+'
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|DP_F_SPACE
condition|)
name|signvalue
operator|=
literal|' '
expr_stmt|;
if|#
directive|if
literal|0
block|if (flags& DP_F_UP) 		caps = 1;
comment|/* Should characters be upper case? */
endif|#
directive|endif
name|intpart
operator|=
operator|(
name|long
operator|)
name|ufvalue
expr_stmt|;
comment|/* Sorry, we only support 9 digits past the decimal because of our 	 * conversion method */
if|if
condition|(
name|max
operator|>
literal|9
condition|)
name|max
operator|=
literal|9
expr_stmt|;
comment|/* We "cheat" by converting the fractional part to integer by 	 * multiplying by a factor of 10 */
name|fracpart
operator|=
name|round
argument_list|(
operator|(
name|pow10
argument_list|(
name|max
argument_list|)
operator|)
operator|*
operator|(
name|ufvalue
operator|-
name|intpart
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fracpart
operator|>=
name|pow10
argument_list|(
name|max
argument_list|)
condition|)
block|{
name|intpart
operator|++
expr_stmt|;
name|fracpart
operator|-=
name|pow10
argument_list|(
name|max
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_SNPRINTF
name|printf
argument_list|(
literal|"fmtfp: %g %d.%d min=%d max=%d\n"
argument_list|,
operator|(
name|double
operator|)
name|fvalue
argument_list|,
name|intpart
argument_list|,
name|fracpart
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Convert integer part */
do|do
block|{
name|iconvert
index|[
name|iplace
operator|++
index|]
operator|=
operator|(
name|caps
condition|?
literal|"0123456789ABCDEF"
else|:
literal|"0123456789abcdef"
operator|)
index|[
name|intpart
operator|%
literal|10
index|]
expr_stmt|;
name|intpart
operator|=
operator|(
name|intpart
operator|/
literal|10
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|intpart
operator|&&
operator|(
name|iplace
operator|<
literal|20
operator|)
condition|)
do|;
if|if
condition|(
name|iplace
operator|==
literal|20
condition|)
name|iplace
operator|--
expr_stmt|;
name|iconvert
index|[
name|iplace
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Convert fractional part */
do|do
block|{
name|fconvert
index|[
name|fplace
operator|++
index|]
operator|=
operator|(
name|caps
condition|?
literal|"0123456789ABCDEF"
else|:
literal|"0123456789abcdef"
operator|)
index|[
name|fracpart
operator|%
literal|10
index|]
expr_stmt|;
name|fracpart
operator|=
operator|(
name|fracpart
operator|/
literal|10
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|fracpart
operator|&&
operator|(
name|fplace
operator|<
literal|20
operator|)
condition|)
do|;
if|if
condition|(
name|fplace
operator|==
literal|20
condition|)
name|fplace
operator|--
expr_stmt|;
name|fconvert
index|[
name|fplace
index|]
operator|=
literal|0
expr_stmt|;
comment|/* -1 for decimal point, another -1 if we are printing a sign */
name|padlen
operator|=
name|min
operator|-
name|iplace
operator|-
name|max
operator|-
literal|1
operator|-
operator|(
operator|(
name|signvalue
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|zpadlen
operator|=
name|max
operator|-
name|fplace
expr_stmt|;
if|if
condition|(
name|zpadlen
operator|<
literal|0
condition|)
name|zpadlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|padlen
operator|<
literal|0
condition|)
name|padlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DP_F_MINUS
condition|)
name|padlen
operator|=
operator|-
name|padlen
expr_stmt|;
comment|/* Left Justifty */
if|if
condition|(
operator|(
name|flags
operator|&
name|DP_F_ZERO
operator|)
operator|&&
operator|(
name|padlen
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|signvalue
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|signvalue
argument_list|)
expr_stmt|;
operator|--
name|padlen
expr_stmt|;
name|signvalue
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|padlen
operator|>
literal|0
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
operator|--
name|padlen
expr_stmt|;
block|}
block|}
while|while
condition|(
name|padlen
operator|>
literal|0
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|--
name|padlen
expr_stmt|;
block|}
if|if
condition|(
name|signvalue
condition|)
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|signvalue
argument_list|)
expr_stmt|;
while|while
condition|(
name|iplace
operator|>
literal|0
condition|)
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|iconvert
index|[
operator|--
name|iplace
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SNPRINTF
name|printf
argument_list|(
literal|"fmtfp: fplace=%d zpadlen=%d\n"
argument_list|,
name|fplace
argument_list|,
name|zpadlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*          * Decimal point.  This should probably use locale to find the correct          * char to print out.          */
if|if
condition|(
name|max
operator|>
literal|0
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
while|while
condition|(
name|fplace
operator|>
literal|0
condition|)
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
name|fconvert
index|[
operator|--
name|fplace
index|]
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|zpadlen
operator|>
literal|0
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
operator|--
name|zpadlen
expr_stmt|;
block|}
while|while
condition|(
name|padlen
operator|<
literal|0
condition|)
block|{
name|dopr_outch
argument_list|(
name|buffer
argument_list|,
name|currlen
argument_list|,
name|maxlen
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|++
name|padlen
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dopr_outch
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|currlen
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
operator|*
name|currlen
operator|<
name|maxlen
condition|)
name|buffer
index|[
operator|(
operator|*
name|currlen
operator|)
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vsnprintf
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|count
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
name|size_t
name|retlen
decl_stmt|;
name|str
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|dopr
argument_list|(
name|str
argument_list|,
name|count
argument_list|,
operator|&
name|retlen
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|retlen
operator|)
return|;
block|}
end_function

begin_comment
comment|/* VARARGS3 */
end_comment

begin_function
name|int
name|snprintf
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|count
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vsnprintf
argument_list|(
name|str
argument_list|,
name|count
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TEST_SNPRINTF
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_STRING
end_ifndef

begin_define
define|#
directive|define
name|LONG_STRING
value|1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
name|buf1
index|[
name|LONG_STRING
index|]
decl_stmt|;
name|char
name|buf2
index|[
name|LONG_STRING
index|]
decl_stmt|;
name|char
modifier|*
name|fp_fmt
index|[]
init|=
block|{
literal|"%-1.5f"
block|,
literal|"%1.5f"
block|,
literal|"%123.9f"
block|,
literal|"%10.5f"
block|,
literal|"% 10.5f"
block|,
literal|"%+22.9f"
block|,
literal|"%+4.9f"
block|,
literal|"%01.3f"
block|,
literal|"%4f"
block|,
literal|"%3.1f"
block|,
literal|"%3.2f"
block|,
literal|"%.0f"
block|,
literal|"%.1f"
block|,
name|NULL
block|}
decl_stmt|;
name|double
name|fp_nums
index|[]
init|=
block|{
operator|-
literal|1.5
block|,
literal|134.21
block|,
literal|91340.2
block|,
literal|341.1234
block|,
literal|0203.9
block|,
literal|0.96
block|,
literal|0.996
block|,
literal|0.9996
block|,
literal|1.996
block|,
literal|4.136
block|,
literal|0
block|}
decl_stmt|;
name|char
modifier|*
name|int_fmt
index|[]
init|=
block|{
literal|"%-1.5d"
block|,
literal|"%1.5d"
block|,
literal|"%123.9d"
block|,
literal|"%5.5d"
block|,
literal|"%10.5d"
block|,
literal|"% 10.5d"
block|,
literal|"%+22.33d"
block|,
literal|"%01.3d"
block|,
literal|"%4d"
block|,
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LONG_LONG_INT
argument_list|)
literal|"%12lld"
block|,
endif|#
directive|endif
name|NULL
block|}
decl_stmt|;
name|LLONG
name|int_nums
index|[]
init|=
block|{
operator|-
literal|1
block|,
literal|134
block|,
literal|91340
block|,
literal|341
block|,
literal|0203
block|,
literal|4294967290
block|,
literal|4294967297
block|,
literal|0
block|}
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|fail
init|=
literal|0
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|;
name|printf
argument_list|(
literal|"Testing snprintf format codes against system sprintf...\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|fp_fmt
index|[
name|x
index|]
operator|!=
name|NULL
condition|;
name|x
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"testing %s\n"
argument_list|,
name|fp_fmt
index|[
name|x
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|fp_nums
index|[
name|y
index|]
operator|!=
literal|0
condition|;
name|y
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|,
name|fp_fmt
index|[
name|x
index|]
argument_list|,
name|fp_nums
index|[
name|y
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf2
argument_list|,
name|fp_fmt
index|[
name|x
index|]
argument_list|,
name|fp_nums
index|[
name|y
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"snprintf doesn't match Format: %s\n"
argument_list|,
name|fp_fmt
index|[
name|x
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tsnprintf = %s\n\tsprintf  = %s\n"
argument_list|,
name|buf1
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|fail
operator|++
expr_stmt|;
block|}
name|num
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|int_fmt
index|[
name|x
index|]
operator|!=
name|NULL
condition|;
name|x
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"testing %s\n"
argument_list|,
name|int_fmt
index|[
name|x
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|int_nums
index|[
name|y
index|]
operator|!=
literal|0
condition|;
name|y
operator|++
control|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|,
name|int_fmt
index|[
name|x
index|]
argument_list|,
name|int_nums
index|[
name|y
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"got %d>%s< (%d)\n"
argument_list|,
name|len
argument_list|,
name|buf1
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|buf1
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf2
argument_list|,
name|int_fmt
index|[
name|x
index|]
argument_list|,
name|int_nums
index|[
name|y
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"snprintf doesn't match Format: %s\n"
argument_list|,
name|int_fmt
index|[
name|x
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tsnprintf = %s\n\tsprintf  = %s\n"
argument_list|,
name|buf1
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|fail
operator|++
expr_stmt|;
block|}
name|num
operator|++
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"%d tests failed out of %d.\n"
argument_list|,
name|fail
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST_SNPRINTF */
end_comment

end_unit

