begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * validator/val_secalgo.c - validator security algorithm functions.  *  * Copyright (c) 2012, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains helper functions for the validator module.  * These functions take raw data buffers, formatted for crypto verification,  * and do the library calls (for the crypto library in use).  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_comment
comment|/* packed_rrset on top to define enum types (forced by c99 standard) */
end_comment

begin_include
include|#
directive|include
file|"util/data/packed_rrset.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_secalgo.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_nsec3.h"
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"sldns/rrdef.h"
end_include

begin_include
include|#
directive|include
file|"sldns/keyraw.h"
end_include

begin_include
include|#
directive|include
file|"sldns/sbuffer.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_SSL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_NSS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_NETTLE
argument_list|)
end_if

begin_error
error|#
directive|error
literal|"Need crypto library to do digital signature cryptography"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OpenSSL implementation */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SSL
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_ERR_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_RAND_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_CONF_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/conf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_ENGINE_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/engine.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* return size of digest if supported, or 0 otherwise */
end_comment

begin_function
name|size_t
name|nsec3_hash_algo_size_supported
parameter_list|(
name|int
name|id
parameter_list|)
block|{
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|NSEC3_HASH_SHA1
case|:
return|return
name|SHA_DIGEST_LENGTH
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* perform nsec3 hash. return false on failure */
end_comment

begin_function
name|int
name|secalgo_nsec3_hash
parameter_list|(
name|int
name|algo
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|res
parameter_list|)
block|{
switch|switch
condition|(
name|algo
condition|)
block|{
case|case
name|NSEC3_HASH_SHA1
case|:
operator|(
name|void
operator|)
name|SHA1
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|void
name|secalgo_hash_sha256
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|res
parameter_list|)
block|{
operator|(
name|void
operator|)
name|SHA256
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Return size of DS digest according to its hash algorithm.  * @param algo: DS digest algo.  * @return size in bytes of digest, or 0 if not supported.  */
end_comment

begin_function
name|size_t
name|ds_digest_size_supported
parameter_list|(
name|int
name|algo
parameter_list|)
block|{
switch|switch
condition|(
name|algo
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_EVP_SHA1
case|case
name|LDNS_SHA1
case|:
return|return
name|SHA_DIGEST_LENGTH
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_EVP_SHA256
case|case
name|LDNS_SHA256
case|:
return|return
name|SHA256_DIGEST_LENGTH
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_GOST
case|case
name|LDNS_HASH_GOST
case|:
comment|/* we support GOST if it can be loaded */
operator|(
name|void
operator|)
name|sldns_key_EVP_load_gost_id
argument_list|()
expr_stmt|;
if|if
condition|(
name|EVP_get_digestbyname
argument_list|(
literal|"md_gost94"
argument_list|)
condition|)
return|return
literal|32
return|;
else|else
return|return
literal|0
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_ECDSA
case|case
name|LDNS_SHA384
case|:
return|return
name|SHA384_DIGEST_LENGTH
return|;
endif|#
directive|endif
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_GOST
end_ifdef

begin_comment
comment|/** Perform GOST hash */
end_comment

begin_function
specifier|static
name|int
name|do_gost94
parameter_list|(
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|dest
parameter_list|)
block|{
specifier|const
name|EVP_MD
modifier|*
name|md
init|=
name|EVP_get_digestbyname
argument_list|(
literal|"md_gost94"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|md
condition|)
return|return
literal|0
return|;
return|return
name|sldns_digest_evp
argument_list|(
name|data
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|len
argument_list|,
name|dest
argument_list|,
name|md
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|secalgo_ds_digest
parameter_list|(
name|int
name|algo
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|res
parameter_list|)
block|{
switch|switch
condition|(
name|algo
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_EVP_SHA1
case|case
name|LDNS_SHA1
case|:
operator|(
name|void
operator|)
name|SHA1
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_EVP_SHA256
case|case
name|LDNS_SHA256
case|:
operator|(
name|void
operator|)
name|SHA256
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_GOST
case|case
name|LDNS_HASH_GOST
case|:
if|if
condition|(
name|do_gost94
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|res
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_ECDSA
case|case
name|LDNS_SHA384
case|:
operator|(
name|void
operator|)
name|SHA384
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
default|default:
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"unknown DS digest algorithm %d"
argument_list|,
name|algo
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** return true if DNSKEY algorithm id is supported */
end_comment

begin_function
name|int
name|dnskey_algo_id_is_supported
parameter_list|(
name|int
name|id
parameter_list|)
block|{
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|LDNS_RSAMD5
case|:
comment|/* RFC 6725 deprecates RSAMD5 */
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|USE_DSA
case|case
name|LDNS_DSA
case|:
case|case
name|LDNS_DSA_NSEC3
case|:
endif|#
directive|endif
case|case
name|LDNS_RSASHA1
case|:
case|case
name|LDNS_RSASHA1_NSEC3
case|:
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EVP_SHA256
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_SHA2
argument_list|)
case|case
name|LDNS_RSASHA256
case|:
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EVP_SHA512
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_SHA2
argument_list|)
case|case
name|LDNS_RSASHA512
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_ECDSA
case|case
name|LDNS_ECDSAP256SHA256
case|:
case|case
name|LDNS_ECDSAP384SHA384
case|:
endif|#
directive|endif
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|USE_GOST
case|case
name|LDNS_ECC_GOST
case|:
comment|/* we support GOST if it can be loaded */
return|return
name|sldns_key_EVP_load_gost_id
argument_list|()
return|;
endif|#
directive|endif
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Output a libcrypto openssl error to the logfile.  * @param str: string to add to it.  * @param e: the error to output, error number from ERR_get_error().  */
end_comment

begin_function
specifier|static
name|void
name|log_crypto_error
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|unsigned
name|long
name|e
parameter_list|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
comment|/* or use ERR_error_string if ERR_error_string_n is not avail TODO */
name|ERR_error_string_n
argument_list|(
name|e
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* buf now contains */
comment|/* error:[error code]:[library name]:[function name]:[reason string] */
name|log_err
argument_list|(
literal|"%s crypto %s"
argument_list|,
name|str
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_DSA
end_ifdef

begin_comment
comment|/**  * Setup DSA key digest in DER encoding ...   * @param sig: input is signature output alloced ptr (unless failure).  * 	caller must free alloced ptr if this routine returns true.  * @param len: input is initial siglen, output is output len.  * @return false on failure.  */
end_comment

begin_function
specifier|static
name|int
name|setup_dsa_sig
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|sig
parameter_list|,
name|unsigned
name|int
modifier|*
name|len
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|orig
init|=
operator|*
name|sig
decl_stmt|;
name|unsigned
name|int
name|origlen
init|=
operator|*
name|len
decl_stmt|;
name|int
name|newlen
decl_stmt|;
name|BIGNUM
modifier|*
name|R
decl_stmt|,
modifier|*
name|S
decl_stmt|;
name|DSA_SIG
modifier|*
name|dsasig
decl_stmt|;
comment|/* extract the R and S field from the sig buffer */
if|if
condition|(
name|origlen
operator|<
literal|1
operator|+
literal|2
operator|*
name|SHA_DIGEST_LENGTH
condition|)
return|return
literal|0
return|;
name|R
operator|=
name|BN_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|R
condition|)
return|return
literal|0
return|;
operator|(
name|void
operator|)
name|BN_bin2bn
argument_list|(
name|orig
operator|+
literal|1
argument_list|,
name|SHA_DIGEST_LENGTH
argument_list|,
name|R
argument_list|)
expr_stmt|;
name|S
operator|=
name|BN_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|S
condition|)
return|return
literal|0
return|;
operator|(
name|void
operator|)
name|BN_bin2bn
argument_list|(
name|orig
operator|+
literal|21
argument_list|,
name|SHA_DIGEST_LENGTH
argument_list|,
name|S
argument_list|)
expr_stmt|;
name|dsasig
operator|=
name|DSA_SIG_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|dsasig
condition|)
return|return
literal|0
return|;
name|dsasig
operator|->
name|r
operator|=
name|R
expr_stmt|;
name|dsasig
operator|->
name|s
operator|=
name|S
expr_stmt|;
operator|*
name|sig
operator|=
name|NULL
expr_stmt|;
name|newlen
operator|=
name|i2d_DSA_SIG
argument_list|(
name|dsasig
argument_list|,
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|newlen
operator|<
literal|0
condition|)
block|{
name|DSA_SIG_free
argument_list|(
name|dsasig
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|sig
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|len
operator|=
operator|(
name|unsigned
name|int
operator|)
name|newlen
expr_stmt|;
name|DSA_SIG_free
argument_list|(
name|dsasig
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_DSA */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_ECDSA
end_ifdef

begin_comment
comment|/**  * Setup the ECDSA signature in its encoding that the library wants.  * Converts from plain numbers to ASN formatted.  * @param sig: input is signature, output alloced ptr (unless failure).  * 	caller must free alloced ptr if this routine returns true.  * @param len: input is initial siglen, output is output len.  * @return false on failure.  */
end_comment

begin_function
specifier|static
name|int
name|setup_ecdsa_sig
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|sig
parameter_list|,
name|unsigned
name|int
modifier|*
name|len
parameter_list|)
block|{
comment|/* convert from two BIGNUMs in the rdata buffer, to ASN notation. 	 * ASN preable:  30440220<R 32bytefor256> 0220<S 32bytefor256> 	 * the '20' is the length of that field (=bnsize). i	 * the '44' is the total remaining length. 	 * if negative, start with leading zero. 	 * if starts with 00s, remove them from the number. 	 */
name|uint8_t
name|pre
index|[]
init|=
block|{
literal|0x30
block|,
literal|0x44
block|,
literal|0x02
block|,
literal|0x20
block|}
decl_stmt|;
name|int
name|pre_len
init|=
literal|4
decl_stmt|;
name|uint8_t
name|mid
index|[]
init|=
block|{
literal|0x02
block|,
literal|0x20
block|}
decl_stmt|;
name|int
name|mid_len
init|=
literal|2
decl_stmt|;
name|int
name|raw_sig_len
decl_stmt|,
name|r_high
decl_stmt|,
name|s_high
decl_stmt|,
name|r_rem
init|=
literal|0
decl_stmt|,
name|s_rem
init|=
literal|0
decl_stmt|;
name|int
name|bnsize
init|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|*
name|len
operator|)
operator|/
literal|2
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|d
init|=
operator|*
name|sig
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|;
comment|/* if too short or not even length, fails */
if|if
condition|(
operator|*
name|len
operator|<
literal|16
operator|||
name|bnsize
operator|*
literal|2
operator|!=
operator|(
name|int
operator|)
operator|*
name|len
condition|)
return|return
literal|0
return|;
comment|/* strip leading zeroes from r (but not last one) */
while|while
condition|(
name|r_rem
operator|<
name|bnsize
operator|-
literal|1
operator|&&
name|d
index|[
name|r_rem
index|]
operator|==
literal|0
condition|)
name|r_rem
operator|++
expr_stmt|;
comment|/* strip leading zeroes from s (but not last one) */
while|while
condition|(
name|s_rem
operator|<
name|bnsize
operator|-
literal|1
operator|&&
name|d
index|[
name|bnsize
operator|+
name|s_rem
index|]
operator|==
literal|0
condition|)
name|s_rem
operator|++
expr_stmt|;
name|r_high
operator|=
operator|(
operator|(
name|d
index|[
literal|0
operator|+
name|r_rem
index|]
operator|&
literal|0x80
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|s_high
operator|=
operator|(
operator|(
name|d
index|[
name|bnsize
operator|+
name|s_rem
index|]
operator|&
literal|0x80
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|raw_sig_len
operator|=
name|pre_len
operator|+
name|r_high
operator|+
name|bnsize
operator|-
name|r_rem
operator|+
name|mid_len
operator|+
name|s_high
operator|+
name|bnsize
operator|-
name|s_rem
expr_stmt|;
operator|*
name|sig
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|raw_sig_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|sig
condition|)
return|return
literal|0
return|;
name|p
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|*
name|sig
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|pre
index|[
literal|0
index|]
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|raw_sig_len
operator|-
literal|2
argument_list|)
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
name|pre
index|[
literal|2
index|]
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|bnsize
operator|+
name|r_high
operator|-
name|r_rem
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|r_high
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
block|}
name|memmove
argument_list|(
name|p
argument_list|,
name|d
operator|+
name|r_rem
argument_list|,
operator|(
name|size_t
operator|)
name|bnsize
operator|-
name|r_rem
argument_list|)
expr_stmt|;
name|p
operator|+=
name|bnsize
operator|-
name|r_rem
expr_stmt|;
name|memmove
argument_list|(
name|p
argument_list|,
name|mid
argument_list|,
operator|(
name|size_t
operator|)
name|mid_len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p
operator|+=
name|mid_len
operator|-
literal|1
expr_stmt|;
operator|*
name|p
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|bnsize
operator|+
name|s_high
operator|-
name|s_rem
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|s_high
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
block|}
name|memmove
argument_list|(
name|p
argument_list|,
name|d
operator|+
name|bnsize
operator|+
name|s_rem
argument_list|,
operator|(
name|size_t
operator|)
name|bnsize
operator|-
name|s_rem
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
operator|(
name|unsigned
name|int
operator|)
name|raw_sig_len
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_ECDSA */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_ECDSA_EVP_WORKAROUND
end_ifdef

begin_decl_stmt
specifier|static
name|EVP_MD
name|ecdsa_evp_256_md
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|EVP_MD
name|ecdsa_evp_384_md
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ecdsa_evp_workaround_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* openssl before 1.0.0 fixes RSA with the SHA256 	 * hash in EVP.  We create one for ecdsa_sha256 */
name|ecdsa_evp_256_md
operator|=
operator|*
name|EVP_sha256
argument_list|()
expr_stmt|;
name|ecdsa_evp_256_md
operator|.
name|required_pkey_type
index|[
literal|0
index|]
operator|=
name|EVP_PKEY_EC
expr_stmt|;
name|ecdsa_evp_256_md
operator|.
name|verify
operator|=
operator|(
name|void
operator|*
operator|)
name|ECDSA_verify
expr_stmt|;
name|ecdsa_evp_384_md
operator|=
operator|*
name|EVP_sha384
argument_list|()
expr_stmt|;
name|ecdsa_evp_384_md
operator|.
name|required_pkey_type
index|[
literal|0
index|]
operator|=
name|EVP_PKEY_EC
expr_stmt|;
name|ecdsa_evp_384_md
operator|.
name|verify
operator|=
operator|(
name|void
operator|*
operator|)
name|ECDSA_verify
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_ECDSA_EVP_WORKAROUND */
end_comment

begin_comment
comment|/**  * Setup key and digest for verification. Adjust sig if necessary.  *  * @param algo: key algorithm  * @param evp_key: EVP PKEY public key to create.  * @param digest_type: digest type to use  * @param key: key to setup for.  * @param keylen: length of key.  * @return false on failure.  */
end_comment

begin_function
specifier|static
name|int
name|setup_key_digest
parameter_list|(
name|int
name|algo
parameter_list|,
name|EVP_PKEY
modifier|*
modifier|*
name|evp_key
parameter_list|,
specifier|const
name|EVP_MD
modifier|*
modifier|*
name|digest_type
parameter_list|,
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|size_t
name|keylen
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_DSA
name|DSA
modifier|*
name|dsa
decl_stmt|;
endif|#
directive|endif
name|RSA
modifier|*
name|rsa
decl_stmt|;
switch|switch
condition|(
name|algo
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_DSA
case|case
name|LDNS_DSA
case|:
case|case
name|LDNS_DSA_NSEC3
case|:
operator|*
name|evp_key
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|evp_key
condition|)
block|{
name|log_err
argument_list|(
literal|"verify: malloc failure in crypto"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dsa
operator|=
name|sldns_key_buf2dsa_raw
argument_list|(
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dsa
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: "
literal|"sldns_key_buf2dsa_raw failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|EVP_PKEY_assign_DSA
argument_list|(
operator|*
name|evp_key
argument_list|,
name|dsa
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: "
literal|"EVP_PKEY_assign_DSA failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|digest_type
operator|=
name|EVP_dss1
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* USE_DSA */
case|case
name|LDNS_RSASHA1
case|:
case|case
name|LDNS_RSASHA1_NSEC3
case|:
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EVP_SHA256
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_SHA2
argument_list|)
case|case
name|LDNS_RSASHA256
case|:
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EVP_SHA512
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_SHA2
argument_list|)
case|case
name|LDNS_RSASHA512
case|:
endif|#
directive|endif
operator|*
name|evp_key
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|evp_key
condition|)
block|{
name|log_err
argument_list|(
literal|"verify: malloc failure in crypto"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|rsa
operator|=
name|sldns_key_buf2rsa_raw
argument_list|(
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rsa
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: "
literal|"sldns_key_buf2rsa_raw SHA failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|EVP_PKEY_assign_RSA
argument_list|(
operator|*
name|evp_key
argument_list|,
name|rsa
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: "
literal|"EVP_PKEY_assign_RSA SHA failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* select SHA version */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EVP_SHA256
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_SHA2
argument_list|)
if|if
condition|(
name|algo
operator|==
name|LDNS_RSASHA256
condition|)
operator|*
name|digest_type
operator|=
name|EVP_sha256
argument_list|()
expr_stmt|;
elseif|else
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EVP_SHA512
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_SHA2
argument_list|)
if|if
condition|(
name|algo
operator|==
name|LDNS_RSASHA512
condition|)
operator|*
name|digest_type
operator|=
name|EVP_sha512
argument_list|()
expr_stmt|;
else|else
endif|#
directive|endif
operator|*
name|digest_type
operator|=
name|EVP_sha1
argument_list|()
expr_stmt|;
break|break;
case|case
name|LDNS_RSAMD5
case|:
operator|*
name|evp_key
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|evp_key
condition|)
block|{
name|log_err
argument_list|(
literal|"verify: malloc failure in crypto"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|rsa
operator|=
name|sldns_key_buf2rsa_raw
argument_list|(
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rsa
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: "
literal|"sldns_key_buf2rsa_raw MD5 failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|EVP_PKEY_assign_RSA
argument_list|(
operator|*
name|evp_key
argument_list|,
name|rsa
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: "
literal|"EVP_PKEY_assign_RSA MD5 failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|digest_type
operator|=
name|EVP_md5
argument_list|()
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|USE_GOST
case|case
name|LDNS_ECC_GOST
case|:
operator|*
name|evp_key
operator|=
name|sldns_gost2pkey_raw
argument_list|(
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|evp_key
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: "
literal|"sldns_gost2pkey_raw failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|digest_type
operator|=
name|EVP_get_digestbyname
argument_list|(
literal|"md_gost94"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|digest_type
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: "
literal|"EVP_getdigest md_gost94 failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_ECDSA
case|case
name|LDNS_ECDSAP256SHA256
case|:
operator|*
name|evp_key
operator|=
name|sldns_ecdsa2pkey_raw
argument_list|(
name|key
argument_list|,
name|keylen
argument_list|,
name|LDNS_ECDSAP256SHA256
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|evp_key
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: "
literal|"sldns_ecdsa2pkey_raw failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|USE_ECDSA_EVP_WORKAROUND
operator|*
name|digest_type
operator|=
operator|&
name|ecdsa_evp_256_md
expr_stmt|;
else|#
directive|else
operator|*
name|digest_type
operator|=
name|EVP_sha256
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|LDNS_ECDSAP384SHA384
case|:
operator|*
name|evp_key
operator|=
name|sldns_ecdsa2pkey_raw
argument_list|(
name|key
argument_list|,
name|keylen
argument_list|,
name|LDNS_ECDSAP384SHA384
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|evp_key
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: "
literal|"sldns_ecdsa2pkey_raw failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|USE_ECDSA_EVP_WORKAROUND
operator|*
name|digest_type
operator|=
operator|&
name|ecdsa_evp_384_md
expr_stmt|;
else|#
directive|else
operator|*
name|digest_type
operator|=
name|EVP_sha384
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
endif|#
directive|endif
comment|/* USE_ECDSA */
default|default:
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: unknown algorithm %d"
argument_list|,
name|algo
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Check a canonical sig+rrset and signature against a dnskey  * @param buf: buffer with data to verify, the first rrsig part and the  *	canonicalized rrset.  * @param algo: DNSKEY algorithm.  * @param sigblock: signature rdata field from RRSIG  * @param sigblock_len: length of sigblock data.  * @param key: public key data from DNSKEY RR.  * @param keylen: length of keydata.  * @param reason: bogus reason in more detail.  * @return secure if verification succeeded, bogus on crypto failure,  *	unchecked on format errors and alloc failures.  */
end_comment

begin_function
name|enum
name|sec_status
name|verify_canonrrset
parameter_list|(
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|int
name|algo
parameter_list|,
name|unsigned
name|char
modifier|*
name|sigblock
parameter_list|,
name|unsigned
name|int
name|sigblock_len
parameter_list|,
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|unsigned
name|int
name|keylen
parameter_list|,
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
specifier|const
name|EVP_MD
modifier|*
name|digest_type
decl_stmt|;
name|EVP_MD_CTX
modifier|*
name|ctx
decl_stmt|;
name|int
name|res
decl_stmt|,
name|dofree
init|=
literal|0
decl_stmt|,
name|docrypto_free
init|=
literal|0
decl_stmt|;
name|EVP_PKEY
modifier|*
name|evp_key
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|setup_key_digest
argument_list|(
name|algo
argument_list|,
operator|&
name|evp_key
argument_list|,
operator|&
name|digest_type
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: failed to setup key"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"use of key for crypto failed"
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|evp_key
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
ifdef|#
directive|ifdef
name|USE_DSA
comment|/* if it is a DSA signature in bind format, convert to DER format */
if|if
condition|(
operator|(
name|algo
operator|==
name|LDNS_DSA
operator|||
name|algo
operator|==
name|LDNS_DSA_NSEC3
operator|)
operator|&&
name|sigblock_len
operator|==
literal|1
operator|+
literal|2
operator|*
name|SHA_DIGEST_LENGTH
condition|)
block|{
if|if
condition|(
operator|!
name|setup_dsa_sig
argument_list|(
operator|&
name|sigblock
argument_list|,
operator|&
name|sigblock_len
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: failed to setup DSA sig"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"use of key for DSA crypto failed"
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|evp_key
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
name|docrypto_free
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|USE_ECDSA
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_DSA
argument_list|)
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_ECDSA
if|if
condition|(
name|algo
operator|==
name|LDNS_ECDSAP256SHA256
operator|||
name|algo
operator|==
name|LDNS_ECDSAP384SHA384
condition|)
block|{
comment|/* EVP uses ASN prefix on sig, which is not in the wire data */
if|if
condition|(
operator|!
name|setup_ecdsa_sig
argument_list|(
operator|&
name|sigblock
argument_list|,
operator|&
name|sigblock_len
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: failed to setup ECDSA sig"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"use of signature for ECDSA crypto failed"
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|evp_key
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
name|dofree
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_ECDSA */
comment|/* do the signature cryptography work */
ifdef|#
directive|ifdef
name|HAVE_EVP_MD_CTX_NEW
name|ctx
operator|=
name|EVP_MD_CTX_new
argument_list|()
expr_stmt|;
else|#
directive|else
name|ctx
operator|=
operator|(
name|EVP_MD_CTX
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
condition|)
name|EVP_MD_CTX_init
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ctx
condition|)
block|{
name|log_err
argument_list|(
literal|"EVP_MD_CTX_new: malloc failure"
argument_list|)
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|evp_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|dofree
condition|)
name|free
argument_list|(
name|sigblock
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|docrypto_free
condition|)
name|OPENSSL_free
argument_list|(
name|sigblock
argument_list|)
expr_stmt|;
return|return
name|sec_status_unchecked
return|;
block|}
if|if
condition|(
name|EVP_VerifyInit
argument_list|(
name|ctx
argument_list|,
name|digest_type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: EVP_VerifyInit failed"
argument_list|)
expr_stmt|;
name|EVP_MD_CTX_destroy
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|evp_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|dofree
condition|)
name|free
argument_list|(
name|sigblock
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|docrypto_free
condition|)
name|OPENSSL_free
argument_list|(
name|sigblock
argument_list|)
expr_stmt|;
return|return
name|sec_status_unchecked
return|;
block|}
if|if
condition|(
name|EVP_VerifyUpdate
argument_list|(
name|ctx
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|sldns_buffer_limit
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: EVP_VerifyUpdate failed"
argument_list|)
expr_stmt|;
name|EVP_MD_CTX_destroy
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|evp_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|dofree
condition|)
name|free
argument_list|(
name|sigblock
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|docrypto_free
condition|)
name|OPENSSL_free
argument_list|(
name|sigblock
argument_list|)
expr_stmt|;
return|return
name|sec_status_unchecked
return|;
block|}
name|res
operator|=
name|EVP_VerifyFinal
argument_list|(
name|ctx
argument_list|,
name|sigblock
argument_list|,
name|sigblock_len
argument_list|,
name|evp_key
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_EVP_MD_CTX_NEW
name|EVP_MD_CTX_destroy
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
else|#
directive|else
name|EVP_MD_CTX_cleanup
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EVP_PKEY_free
argument_list|(
name|evp_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|dofree
condition|)
name|free
argument_list|(
name|sigblock
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|docrypto_free
condition|)
name|OPENSSL_free
argument_list|(
name|sigblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|1
condition|)
block|{
return|return
name|sec_status_secure
return|;
block|}
elseif|else
if|if
condition|(
name|res
operator|==
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: signature mismatch"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"signature crypto failed"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
name|log_crypto_error
argument_list|(
literal|"verify:"
argument_list|,
name|ERR_get_error
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|sec_status_unchecked
return|;
block|}
end_function

begin_comment
comment|/**************************************************/
end_comment

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_NSS
argument_list|)
end_elif

begin_comment
comment|/* libnss implementation */
end_comment

begin_comment
comment|/* nss3 */
end_comment

begin_include
include|#
directive|include
file|"sechash.h"
end_include

begin_include
include|#
directive|include
file|"pk11pub.h"
end_include

begin_include
include|#
directive|include
file|"keyhi.h"
end_include

begin_include
include|#
directive|include
file|"secerr.h"
end_include

begin_include
include|#
directive|include
file|"cryptohi.h"
end_include

begin_comment
comment|/* nspr4 */
end_comment

begin_include
include|#
directive|include
file|"prerror.h"
end_include

begin_comment
comment|/* return size of digest if supported, or 0 otherwise */
end_comment

begin_function
name|size_t
name|nsec3_hash_algo_size_supported
parameter_list|(
name|int
name|id
parameter_list|)
block|{
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|NSEC3_HASH_SHA1
case|:
return|return
name|SHA1_LENGTH
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* perform nsec3 hash. return false on failure */
end_comment

begin_function
name|int
name|secalgo_nsec3_hash
parameter_list|(
name|int
name|algo
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|res
parameter_list|)
block|{
switch|switch
condition|(
name|algo
condition|)
block|{
case|case
name|NSEC3_HASH_SHA1
case|:
operator|(
name|void
operator|)
name|HASH_HashBuf
argument_list|(
name|HASH_AlgSHA1
argument_list|,
name|res
argument_list|,
name|buf
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|void
name|secalgo_hash_sha256
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|res
parameter_list|)
block|{
operator|(
name|void
operator|)
name|HASH_HashBuf
argument_list|(
name|HASH_AlgSHA256
argument_list|,
name|res
argument_list|,
name|buf
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|ds_digest_size_supported
parameter_list|(
name|int
name|algo
parameter_list|)
block|{
comment|/* uses libNSS */
switch|switch
condition|(
name|algo
condition|)
block|{
case|case
name|LDNS_SHA1
case|:
return|return
name|SHA1_LENGTH
return|;
ifdef|#
directive|ifdef
name|USE_SHA2
case|case
name|LDNS_SHA256
case|:
return|return
name|SHA256_LENGTH
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_ECDSA
case|case
name|LDNS_SHA384
case|:
return|return
name|SHA384_LENGTH
return|;
endif|#
directive|endif
comment|/* GOST not supported in NSS */
case|case
name|LDNS_HASH_GOST
case|:
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|secalgo_ds_digest
parameter_list|(
name|int
name|algo
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|res
parameter_list|)
block|{
comment|/* uses libNSS */
switch|switch
condition|(
name|algo
condition|)
block|{
case|case
name|LDNS_SHA1
case|:
return|return
name|HASH_HashBuf
argument_list|(
name|HASH_AlgSHA1
argument_list|,
name|res
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|==
name|SECSuccess
return|;
if|#
directive|if
name|defined
argument_list|(
name|USE_SHA2
argument_list|)
case|case
name|LDNS_SHA256
case|:
return|return
name|HASH_HashBuf
argument_list|(
name|HASH_AlgSHA256
argument_list|,
name|res
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|==
name|SECSuccess
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_ECDSA
case|case
name|LDNS_SHA384
case|:
return|return
name|HASH_HashBuf
argument_list|(
name|HASH_AlgSHA384
argument_list|,
name|res
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|==
name|SECSuccess
return|;
endif|#
directive|endif
case|case
name|LDNS_HASH_GOST
case|:
default|default:
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"unknown DS digest algorithm %d"
argument_list|,
name|algo
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|dnskey_algo_id_is_supported
parameter_list|(
name|int
name|id
parameter_list|)
block|{
comment|/* uses libNSS */
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|LDNS_RSAMD5
case|:
comment|/* RFC 6725 deprecates RSAMD5 */
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|USE_DSA
case|case
name|LDNS_DSA
case|:
case|case
name|LDNS_DSA_NSEC3
case|:
endif|#
directive|endif
case|case
name|LDNS_RSASHA1
case|:
case|case
name|LDNS_RSASHA1_NSEC3
case|:
ifdef|#
directive|ifdef
name|USE_SHA2
case|case
name|LDNS_RSASHA256
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_SHA2
case|case
name|LDNS_RSASHA512
case|:
endif|#
directive|endif
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|USE_ECDSA
case|case
name|LDNS_ECDSAP256SHA256
case|:
case|case
name|LDNS_ECDSAP384SHA384
case|:
return|return
name|PK11_TokenExists
argument_list|(
name|CKM_ECDSA
argument_list|)
return|;
endif|#
directive|endif
case|case
name|LDNS_ECC_GOST
case|:
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* return a new public key for NSS */
end_comment

begin_function
specifier|static
name|SECKEYPublicKey
modifier|*
name|nss_key_create
parameter_list|(
name|KeyType
name|ktype
parameter_list|)
block|{
name|SECKEYPublicKey
modifier|*
name|key
decl_stmt|;
name|PLArenaPool
modifier|*
name|arena
init|=
name|PORT_NewArena
argument_list|(
name|DER_DEFAULT_CHUNKSIZE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|arena
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory, PORT_NewArena failed"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|key
operator|=
name|PORT_ArenaZNew
argument_list|(
name|arena
argument_list|,
name|SECKEYPublicKey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory, PORT_ArenaZNew failed"
argument_list|)
expr_stmt|;
name|PORT_FreeArena
argument_list|(
name|arena
argument_list|,
name|PR_FALSE
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|key
operator|->
name|arena
operator|=
name|arena
expr_stmt|;
name|key
operator|->
name|keyType
operator|=
name|ktype
expr_stmt|;
name|key
operator|->
name|pkcs11Slot
operator|=
name|NULL
expr_stmt|;
name|key
operator|->
name|pkcs11ID
operator|=
name|CK_INVALID_HANDLE
expr_stmt|;
return|return
name|key
return|;
block|}
end_function

begin_function
specifier|static
name|SECKEYPublicKey
modifier|*
name|nss_buf2ecdsa
parameter_list|(
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|algo
parameter_list|)
block|{
name|SECKEYPublicKey
modifier|*
name|pk
decl_stmt|;
name|SECItem
name|pub
init|=
block|{
name|siBuffer
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
name|SECItem
name|params
init|=
block|{
name|siBuffer
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
specifier|static
name|unsigned
name|char
name|param256
index|[]
init|=
block|{
comment|/* OBJECTIDENTIFIER 1.2.840.10045.3.1.7 (P-256) 		 * {iso(1) member-body(2) us(840) ansi-x962(10045) curves(3) prime(1) prime256v1(7)} */
literal|0x06
block|,
literal|0x08
block|,
literal|0x2a
block|,
literal|0x86
block|,
literal|0x48
block|,
literal|0xce
block|,
literal|0x3d
block|,
literal|0x03
block|,
literal|0x01
block|,
literal|0x07
block|}
decl_stmt|;
specifier|static
name|unsigned
name|char
name|param384
index|[]
init|=
block|{
comment|/* OBJECTIDENTIFIER 1.3.132.0.34 (P-384) 		 * {iso(1) identified-organization(3) certicom(132) curve(0) ansip384r1(34)} */
literal|0x06
block|,
literal|0x05
block|,
literal|0x2b
block|,
literal|0x81
block|,
literal|0x04
block|,
literal|0x00
block|,
literal|0x22
block|}
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|256
operator|+
literal|2
index|]
decl_stmt|;
comment|/* sufficient for 2*384/8+1 */
comment|/* check length, which uncompressed must be 2 bignums */
if|if
condition|(
name|algo
operator|==
name|LDNS_ECDSAP256SHA256
condition|)
block|{
if|if
condition|(
name|len
operator|!=
literal|2
operator|*
literal|256
operator|/
literal|8
condition|)
return|return
name|NULL
return|;
comment|/* ECCurve_X9_62_PRIME_256V1 */
block|}
elseif|else
if|if
condition|(
name|algo
operator|==
name|LDNS_ECDSAP384SHA384
condition|)
block|{
if|if
condition|(
name|len
operator|!=
literal|2
operator|*
literal|384
operator|/
literal|8
condition|)
return|return
name|NULL
return|;
comment|/* ECCurve_X9_62_PRIME_384R1 */
block|}
else|else
return|return
name|NULL
return|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0x04
expr_stmt|;
comment|/* POINT_FORM_UNCOMPRESSED */
name|memmove
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
name|key
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|pub
operator|.
name|data
operator|=
name|buf
expr_stmt|;
name|pub
operator|.
name|len
operator|=
name|len
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|algo
operator|==
name|LDNS_ECDSAP256SHA256
condition|)
block|{
name|params
operator|.
name|data
operator|=
name|param256
expr_stmt|;
name|params
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
name|param256
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|params
operator|.
name|data
operator|=
name|param384
expr_stmt|;
name|params
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
name|param384
argument_list|)
expr_stmt|;
block|}
name|pk
operator|=
name|nss_key_create
argument_list|(
name|ecKey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pk
condition|)
return|return
name|NULL
return|;
name|pk
operator|->
name|u
operator|.
name|ec
operator|.
name|size
operator|=
operator|(
name|len
operator|/
literal|2
operator|)
operator|*
literal|8
expr_stmt|;
if|if
condition|(
name|SECITEM_CopyItem
argument_list|(
name|pk
operator|->
name|arena
argument_list|,
operator|&
name|pk
operator|->
name|u
operator|.
name|ec
operator|.
name|publicValue
argument_list|,
operator|&
name|pub
argument_list|)
condition|)
block|{
name|SECKEY_DestroyPublicKey
argument_list|(
name|pk
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|SECITEM_CopyItem
argument_list|(
name|pk
operator|->
name|arena
argument_list|,
operator|&
name|pk
operator|->
name|u
operator|.
name|ec
operator|.
name|DEREncodedParams
argument_list|,
operator|&
name|params
argument_list|)
condition|)
block|{
name|SECKEY_DestroyPublicKey
argument_list|(
name|pk
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|pk
return|;
block|}
end_function

begin_function
specifier|static
name|SECKEYPublicKey
modifier|*
name|nss_buf2dsa
parameter_list|(
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|SECKEYPublicKey
modifier|*
name|pk
decl_stmt|;
name|uint8_t
name|T
decl_stmt|;
name|uint16_t
name|length
decl_stmt|;
name|uint16_t
name|offset
decl_stmt|;
name|SECItem
name|Q
init|=
block|{
name|siBuffer
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
name|SECItem
name|P
init|=
block|{
name|siBuffer
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
name|SECItem
name|G
init|=
block|{
name|siBuffer
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
name|SECItem
name|Y
init|=
block|{
name|siBuffer
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|T
operator|=
operator|(
name|uint8_t
operator|)
name|key
index|[
literal|0
index|]
expr_stmt|;
name|length
operator|=
operator|(
literal|64
operator|+
name|T
operator|*
literal|8
operator|)
expr_stmt|;
name|offset
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|T
operator|>
literal|8
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|len
operator|<
operator|(
name|size_t
operator|)
literal|1
operator|+
name|SHA1_LENGTH
operator|+
literal|3
operator|*
name|length
condition|)
return|return
name|NULL
return|;
name|Q
operator|.
name|data
operator|=
name|key
operator|+
name|offset
expr_stmt|;
name|Q
operator|.
name|len
operator|=
name|SHA1_LENGTH
expr_stmt|;
name|offset
operator|+=
name|SHA1_LENGTH
expr_stmt|;
name|P
operator|.
name|data
operator|=
name|key
operator|+
name|offset
expr_stmt|;
name|P
operator|.
name|len
operator|=
name|length
expr_stmt|;
name|offset
operator|+=
name|length
expr_stmt|;
name|G
operator|.
name|data
operator|=
name|key
operator|+
name|offset
expr_stmt|;
name|G
operator|.
name|len
operator|=
name|length
expr_stmt|;
name|offset
operator|+=
name|length
expr_stmt|;
name|Y
operator|.
name|data
operator|=
name|key
operator|+
name|offset
expr_stmt|;
name|Y
operator|.
name|len
operator|=
name|length
expr_stmt|;
name|offset
operator|+=
name|length
expr_stmt|;
name|pk
operator|=
name|nss_key_create
argument_list|(
name|dsaKey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pk
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|SECITEM_CopyItem
argument_list|(
name|pk
operator|->
name|arena
argument_list|,
operator|&
name|pk
operator|->
name|u
operator|.
name|dsa
operator|.
name|params
operator|.
name|prime
argument_list|,
operator|&
name|P
argument_list|)
condition|)
block|{
name|SECKEY_DestroyPublicKey
argument_list|(
name|pk
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|SECITEM_CopyItem
argument_list|(
name|pk
operator|->
name|arena
argument_list|,
operator|&
name|pk
operator|->
name|u
operator|.
name|dsa
operator|.
name|params
operator|.
name|subPrime
argument_list|,
operator|&
name|Q
argument_list|)
condition|)
block|{
name|SECKEY_DestroyPublicKey
argument_list|(
name|pk
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|SECITEM_CopyItem
argument_list|(
name|pk
operator|->
name|arena
argument_list|,
operator|&
name|pk
operator|->
name|u
operator|.
name|dsa
operator|.
name|params
operator|.
name|base
argument_list|,
operator|&
name|G
argument_list|)
condition|)
block|{
name|SECKEY_DestroyPublicKey
argument_list|(
name|pk
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|SECITEM_CopyItem
argument_list|(
name|pk
operator|->
name|arena
argument_list|,
operator|&
name|pk
operator|->
name|u
operator|.
name|dsa
operator|.
name|publicValue
argument_list|,
operator|&
name|Y
argument_list|)
condition|)
block|{
name|SECKEY_DestroyPublicKey
argument_list|(
name|pk
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|pk
return|;
block|}
end_function

begin_function
specifier|static
name|SECKEYPublicKey
modifier|*
name|nss_buf2rsa
parameter_list|(
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|SECKEYPublicKey
modifier|*
name|pk
decl_stmt|;
name|uint16_t
name|exp
decl_stmt|;
name|uint16_t
name|offset
decl_stmt|;
name|uint16_t
name|int16
decl_stmt|;
name|SECItem
name|modulus
init|=
block|{
name|siBuffer
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
name|SECItem
name|exponent
init|=
block|{
name|siBuffer
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|key
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|<
literal|3
condition|)
return|return
name|NULL
return|;
comment|/* the exponent is too large so it's places further */
name|memmove
argument_list|(
operator|&
name|int16
argument_list|,
name|key
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|exp
operator|=
name|ntohs
argument_list|(
name|int16
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|exp
operator|=
name|key
index|[
literal|0
index|]
expr_stmt|;
name|offset
operator|=
literal|1
expr_stmt|;
block|}
comment|/* key length at least one */
if|if
condition|(
name|len
operator|<
operator|(
name|size_t
operator|)
name|offset
operator|+
name|exp
operator|+
literal|1
condition|)
return|return
name|NULL
return|;
name|exponent
operator|.
name|data
operator|=
name|key
operator|+
name|offset
expr_stmt|;
name|exponent
operator|.
name|len
operator|=
name|exp
expr_stmt|;
name|offset
operator|+=
name|exp
expr_stmt|;
name|modulus
operator|.
name|data
operator|=
name|key
operator|+
name|offset
expr_stmt|;
name|modulus
operator|.
name|len
operator|=
operator|(
name|len
operator|-
name|offset
operator|)
expr_stmt|;
name|pk
operator|=
name|nss_key_create
argument_list|(
name|rsaKey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pk
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|SECITEM_CopyItem
argument_list|(
name|pk
operator|->
name|arena
argument_list|,
operator|&
name|pk
operator|->
name|u
operator|.
name|rsa
operator|.
name|modulus
argument_list|,
operator|&
name|modulus
argument_list|)
condition|)
block|{
name|SECKEY_DestroyPublicKey
argument_list|(
name|pk
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|SECITEM_CopyItem
argument_list|(
name|pk
operator|->
name|arena
argument_list|,
operator|&
name|pk
operator|->
name|u
operator|.
name|rsa
operator|.
name|publicExponent
argument_list|,
operator|&
name|exponent
argument_list|)
condition|)
block|{
name|SECKEY_DestroyPublicKey
argument_list|(
name|pk
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|pk
return|;
block|}
end_function

begin_comment
comment|/**  * Setup key and digest for verification. Adjust sig if necessary.  *  * @param algo: key algorithm  * @param evp_key: EVP PKEY public key to create.  * @param digest_type: digest type to use  * @param key: key to setup for.  * @param keylen: length of key.  * @param prefix: if returned, the ASN prefix for the hashblob.  * @param prefixlen: length of the prefix.  * @return false on failure.  */
end_comment

begin_function
specifier|static
name|int
name|nss_setup_key_digest
parameter_list|(
name|int
name|algo
parameter_list|,
name|SECKEYPublicKey
modifier|*
modifier|*
name|pubkey
parameter_list|,
name|HASH_HashType
modifier|*
name|htype
parameter_list|,
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|size_t
name|keylen
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|prefix
parameter_list|,
name|size_t
modifier|*
name|prefixlen
parameter_list|)
block|{
comment|/* uses libNSS */
comment|/* hash prefix for md5, RFC2537 */
specifier|static
name|unsigned
name|char
name|p_md5
index|[]
init|=
block|{
literal|0x30
block|,
literal|0x20
block|,
literal|0x30
block|,
literal|0x0c
block|,
literal|0x06
block|,
literal|0x08
block|,
literal|0x2a
block|,
literal|0x86
block|,
literal|0x48
block|,
literal|0x86
block|,
literal|0xf7
block|,
literal|0x0d
block|,
literal|0x02
block|,
literal|0x05
block|,
literal|0x05
block|,
literal|0x00
block|,
literal|0x04
block|,
literal|0x10
block|}
decl_stmt|;
comment|/* hash prefix to prepend to hash output, from RFC3110 */
specifier|static
name|unsigned
name|char
name|p_sha1
index|[]
init|=
block|{
literal|0x30
block|,
literal|0x21
block|,
literal|0x30
block|,
literal|0x09
block|,
literal|0x06
block|,
literal|0x05
block|,
literal|0x2B
block|,
literal|0x0E
block|,
literal|0x03
block|,
literal|0x02
block|,
literal|0x1A
block|,
literal|0x05
block|,
literal|0x00
block|,
literal|0x04
block|,
literal|0x14
block|}
decl_stmt|;
comment|/* from RFC5702 */
specifier|static
name|unsigned
name|char
name|p_sha256
index|[]
init|=
block|{
literal|0x30
block|,
literal|0x31
block|,
literal|0x30
block|,
literal|0x0d
block|,
literal|0x06
block|,
literal|0x09
block|,
literal|0x60
block|,
literal|0x86
block|,
literal|0x48
block|,
literal|0x01
block|,
literal|0x65
block|,
literal|0x03
block|,
literal|0x04
block|,
literal|0x02
block|,
literal|0x01
block|,
literal|0x05
block|,
literal|0x00
block|,
literal|0x04
block|,
literal|0x20
block|}
decl_stmt|;
specifier|static
name|unsigned
name|char
name|p_sha512
index|[]
init|=
block|{
literal|0x30
block|,
literal|0x51
block|,
literal|0x30
block|,
literal|0x0d
block|,
literal|0x06
block|,
literal|0x09
block|,
literal|0x60
block|,
literal|0x86
block|,
literal|0x48
block|,
literal|0x01
block|,
literal|0x65
block|,
literal|0x03
block|,
literal|0x04
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x05
block|,
literal|0x00
block|,
literal|0x04
block|,
literal|0x40
block|}
decl_stmt|;
comment|/* from RFC6234 */
comment|/* for future RSASHA384 ..  	static unsigned char p_sha384[] = {0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 	0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30}; 	*/
switch|switch
condition|(
name|algo
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_DSA
case|case
name|LDNS_DSA
case|:
case|case
name|LDNS_DSA_NSEC3
case|:
operator|*
name|pubkey
operator|=
name|nss_buf2dsa
argument_list|(
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pubkey
condition|)
block|{
name|log_err
argument_list|(
literal|"verify: malloc failure in crypto"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|htype
operator|=
name|HASH_AlgSHA1
expr_stmt|;
comment|/* no prefix for DSA verification */
break|break;
endif|#
directive|endif
case|case
name|LDNS_RSASHA1
case|:
case|case
name|LDNS_RSASHA1_NSEC3
case|:
ifdef|#
directive|ifdef
name|USE_SHA2
case|case
name|LDNS_RSASHA256
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_SHA2
case|case
name|LDNS_RSASHA512
case|:
endif|#
directive|endif
operator|*
name|pubkey
operator|=
name|nss_buf2rsa
argument_list|(
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pubkey
condition|)
block|{
name|log_err
argument_list|(
literal|"verify: malloc failure in crypto"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* select SHA version */
ifdef|#
directive|ifdef
name|USE_SHA2
if|if
condition|(
name|algo
operator|==
name|LDNS_RSASHA256
condition|)
block|{
operator|*
name|htype
operator|=
name|HASH_AlgSHA256
expr_stmt|;
operator|*
name|prefix
operator|=
name|p_sha256
expr_stmt|;
operator|*
name|prefixlen
operator|=
sizeof|sizeof
argument_list|(
name|p_sha256
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_SHA2
if|if
condition|(
name|algo
operator|==
name|LDNS_RSASHA512
condition|)
block|{
operator|*
name|htype
operator|=
name|HASH_AlgSHA512
expr_stmt|;
operator|*
name|prefix
operator|=
name|p_sha512
expr_stmt|;
operator|*
name|prefixlen
operator|=
sizeof|sizeof
argument_list|(
name|p_sha512
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
operator|*
name|htype
operator|=
name|HASH_AlgSHA1
expr_stmt|;
operator|*
name|prefix
operator|=
name|p_sha1
expr_stmt|;
operator|*
name|prefixlen
operator|=
sizeof|sizeof
argument_list|(
name|p_sha1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LDNS_RSAMD5
case|:
operator|*
name|pubkey
operator|=
name|nss_buf2rsa
argument_list|(
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pubkey
condition|)
block|{
name|log_err
argument_list|(
literal|"verify: malloc failure in crypto"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|htype
operator|=
name|HASH_AlgMD5
expr_stmt|;
operator|*
name|prefix
operator|=
name|p_md5
expr_stmt|;
operator|*
name|prefixlen
operator|=
sizeof|sizeof
argument_list|(
name|p_md5
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|USE_ECDSA
case|case
name|LDNS_ECDSAP256SHA256
case|:
operator|*
name|pubkey
operator|=
name|nss_buf2ecdsa
argument_list|(
name|key
argument_list|,
name|keylen
argument_list|,
name|LDNS_ECDSAP256SHA256
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pubkey
condition|)
block|{
name|log_err
argument_list|(
literal|"verify: malloc failure in crypto"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|htype
operator|=
name|HASH_AlgSHA256
expr_stmt|;
comment|/* no prefix for DSA verification */
break|break;
case|case
name|LDNS_ECDSAP384SHA384
case|:
operator|*
name|pubkey
operator|=
name|nss_buf2ecdsa
argument_list|(
name|key
argument_list|,
name|keylen
argument_list|,
name|LDNS_ECDSAP384SHA384
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pubkey
condition|)
block|{
name|log_err
argument_list|(
literal|"verify: malloc failure in crypto"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|htype
operator|=
name|HASH_AlgSHA384
expr_stmt|;
comment|/* no prefix for DSA verification */
break|break;
endif|#
directive|endif
comment|/* USE_ECDSA */
case|case
name|LDNS_ECC_GOST
case|:
default|default:
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: unknown algorithm %d"
argument_list|,
name|algo
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Check a canonical sig+rrset and signature against a dnskey  * @param buf: buffer with data to verify, the first rrsig part and the  *	canonicalized rrset.  * @param algo: DNSKEY algorithm.  * @param sigblock: signature rdata field from RRSIG  * @param sigblock_len: length of sigblock data.  * @param key: public key data from DNSKEY RR.  * @param keylen: length of keydata.  * @param reason: bogus reason in more detail.  * @return secure if verification succeeded, bogus on crypto failure,  *	unchecked on format errors and alloc failures.  */
end_comment

begin_function
name|enum
name|sec_status
name|verify_canonrrset
parameter_list|(
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|int
name|algo
parameter_list|,
name|unsigned
name|char
modifier|*
name|sigblock
parameter_list|,
name|unsigned
name|int
name|sigblock_len
parameter_list|,
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|unsigned
name|int
name|keylen
parameter_list|,
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
comment|/* uses libNSS */
comment|/* large enough for the different hashes */
name|unsigned
name|char
name|hash
index|[
name|HASH_LENGTH_MAX
index|]
decl_stmt|;
name|unsigned
name|char
name|hash2
index|[
name|HASH_LENGTH_MAX
operator|*
literal|2
index|]
decl_stmt|;
name|HASH_HashType
name|htype
init|=
literal|0
decl_stmt|;
name|SECKEYPublicKey
modifier|*
name|pubkey
init|=
name|NULL
decl_stmt|;
name|SECItem
name|secsig
init|=
block|{
name|siBuffer
block|,
name|sigblock
block|,
name|sigblock_len
block|}
decl_stmt|;
name|SECItem
name|sechash
init|=
block|{
name|siBuffer
block|,
name|hash
block|,
literal|0
block|}
decl_stmt|;
name|SECStatus
name|res
decl_stmt|;
name|unsigned
name|char
modifier|*
name|prefix
init|=
name|NULL
decl_stmt|;
comment|/* prefix for hash, RFC3110, RFC5702 */
name|size_t
name|prefixlen
init|=
literal|0
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|nss_setup_key_digest
argument_list|(
name|algo
argument_list|,
operator|&
name|pubkey
argument_list|,
operator|&
name|htype
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
operator|&
name|prefix
argument_list|,
operator|&
name|prefixlen
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: failed to setup key"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"use of key for crypto failed"
expr_stmt|;
name|SECKEY_DestroyPublicKey
argument_list|(
name|pubkey
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
ifdef|#
directive|ifdef
name|USE_DSA
comment|/* need to convert DSA, ECDSA signatures? */
if|if
condition|(
operator|(
name|algo
operator|==
name|LDNS_DSA
operator|||
name|algo
operator|==
name|LDNS_DSA_NSEC3
operator|)
condition|)
block|{
if|if
condition|(
name|sigblock_len
operator|==
literal|1
operator|+
literal|2
operator|*
name|SHA1_LENGTH
condition|)
block|{
name|secsig
operator|.
name|data
operator|++
expr_stmt|;
name|secsig
operator|.
name|len
operator|--
expr_stmt|;
block|}
else|else
block|{
name|SECItem
modifier|*
name|p
init|=
name|DSAU_DecodeDerSig
argument_list|(
operator|&
name|secsig
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: failed DER decode"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"signature DER decode failed"
expr_stmt|;
name|SECKEY_DestroyPublicKey
argument_list|(
name|pubkey
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
if|if
condition|(
name|SECITEM_CopyItem
argument_list|(
name|pubkey
operator|->
name|arena
argument_list|,
operator|&
name|secsig
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"alloc failure in DER decode"
argument_list|)
expr_stmt|;
name|SECKEY_DestroyPublicKey
argument_list|(
name|pubkey
argument_list|)
expr_stmt|;
name|SECITEM_FreeItem
argument_list|(
name|p
argument_list|,
name|PR_TRUE
argument_list|)
expr_stmt|;
return|return
name|sec_status_unchecked
return|;
block|}
name|SECITEM_FreeItem
argument_list|(
name|p
argument_list|,
name|PR_TRUE
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* USE_DSA */
comment|/* do the signature cryptography work */
comment|/* hash the data */
name|sechash
operator|.
name|len
operator|=
name|HASH_ResultLen
argument_list|(
name|htype
argument_list|)
expr_stmt|;
if|if
condition|(
name|sechash
operator|.
name|len
operator|>
sizeof|sizeof
argument_list|(
name|hash
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: hash too large for buffer"
argument_list|)
expr_stmt|;
name|SECKEY_DestroyPublicKey
argument_list|(
name|pubkey
argument_list|)
expr_stmt|;
return|return
name|sec_status_unchecked
return|;
block|}
if|if
condition|(
name|HASH_HashBuf
argument_list|(
name|htype
argument_list|,
name|hash
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|sldns_buffer_limit
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|!=
name|SECSuccess
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: HASH_HashBuf failed"
argument_list|)
expr_stmt|;
name|SECKEY_DestroyPublicKey
argument_list|(
name|pubkey
argument_list|)
expr_stmt|;
return|return
name|sec_status_unchecked
return|;
block|}
if|if
condition|(
name|prefix
condition|)
block|{
name|int
name|hashlen
init|=
name|sechash
operator|.
name|len
decl_stmt|;
if|if
condition|(
name|prefixlen
operator|+
name|hashlen
operator|>
sizeof|sizeof
argument_list|(
name|hash2
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: hashprefix too large"
argument_list|)
expr_stmt|;
name|SECKEY_DestroyPublicKey
argument_list|(
name|pubkey
argument_list|)
expr_stmt|;
return|return
name|sec_status_unchecked
return|;
block|}
name|sechash
operator|.
name|data
operator|=
name|hash2
expr_stmt|;
name|sechash
operator|.
name|len
operator|=
name|prefixlen
operator|+
name|hashlen
expr_stmt|;
name|memcpy
argument_list|(
name|sechash
operator|.
name|data
argument_list|,
name|prefix
argument_list|,
name|prefixlen
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|sechash
operator|.
name|data
operator|+
name|prefixlen
argument_list|,
name|hash
argument_list|,
name|hashlen
argument_list|)
expr_stmt|;
block|}
comment|/* verify the signature */
name|res
operator|=
name|PK11_Verify
argument_list|(
name|pubkey
argument_list|,
operator|&
name|secsig
argument_list|,
operator|&
name|sechash
argument_list|,
name|NULL
comment|/*wincx*/
argument_list|)
expr_stmt|;
name|SECKEY_DestroyPublicKey
argument_list|(
name|pubkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|SECSuccess
condition|)
block|{
return|return
name|sec_status_secure
return|;
block|}
name|err
operator|=
name|PORT_GetError
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|SEC_ERROR_BAD_SIGNATURE
condition|)
block|{
comment|/* failed to verify */
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: PK11_Verify failed: %s"
argument_list|,
name|PORT_ErrorToString
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if it is not supported, like ECC is removed, we get, 		 * SEC_ERROR_NO_MODULE */
if|if
condition|(
name|err
operator|==
name|SEC_ERROR_NO_MODULE
condition|)
return|return
name|sec_status_unchecked
return|;
comment|/* but other errors are commonly returned 		 * for a bad signature from NSS.  Thus we return bogus, 		 * not unchecked */
operator|*
name|reason
operator|=
literal|"signature crypto failed"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: signature mismatch: %s"
argument_list|,
name|PORT_ErrorToString
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"signature crypto failed"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_NETTLE
argument_list|)
end_elif

begin_include
include|#
directive|include
file|"sha.h"
end_include

begin_include
include|#
directive|include
file|"bignum.h"
end_include

begin_include
include|#
directive|include
file|"macros.h"
end_include

begin_include
include|#
directive|include
file|"rsa.h"
end_include

begin_include
include|#
directive|include
file|"dsa.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NETTLE_DSA_COMPAT_H
end_ifdef

begin_include
include|#
directive|include
file|"dsa-compat.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"asn1.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_ECDSA
end_ifdef

begin_include
include|#
directive|include
file|"ecdsa.h"
end_include

begin_include
include|#
directive|include
file|"ecc-curve.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|_digest_nettle
parameter_list|(
name|int
name|algo
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|res
parameter_list|)
block|{
switch|switch
condition|(
name|algo
condition|)
block|{
case|case
name|SHA1_DIGEST_SIZE
case|:
block|{
name|struct
name|sha1_ctx
name|ctx
decl_stmt|;
name|sha1_init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|sha1_update
argument_list|(
operator|&
name|ctx
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|sha1_digest
argument_list|(
operator|&
name|ctx
argument_list|,
name|SHA1_DIGEST_SIZE
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
case|case
name|SHA256_DIGEST_SIZE
case|:
block|{
name|struct
name|sha256_ctx
name|ctx
decl_stmt|;
name|sha256_init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|sha256_update
argument_list|(
operator|&
name|ctx
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|sha256_digest
argument_list|(
operator|&
name|ctx
argument_list|,
name|SHA256_DIGEST_SIZE
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
case|case
name|SHA384_DIGEST_SIZE
case|:
block|{
name|struct
name|sha384_ctx
name|ctx
decl_stmt|;
name|sha384_init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|sha384_update
argument_list|(
operator|&
name|ctx
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|sha384_digest
argument_list|(
operator|&
name|ctx
argument_list|,
name|SHA384_DIGEST_SIZE
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
case|case
name|SHA512_DIGEST_SIZE
case|:
block|{
name|struct
name|sha512_ctx
name|ctx
decl_stmt|;
name|sha512_init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|sha512_update
argument_list|(
operator|&
name|ctx
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|sha512_digest
argument_list|(
operator|&
name|ctx
argument_list|,
name|SHA512_DIGEST_SIZE
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* return size of digest if supported, or 0 otherwise */
end_comment

begin_function
name|size_t
name|nsec3_hash_algo_size_supported
parameter_list|(
name|int
name|id
parameter_list|)
block|{
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|NSEC3_HASH_SHA1
case|:
return|return
name|SHA1_DIGEST_SIZE
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* perform nsec3 hash. return false on failure */
end_comment

begin_function
name|int
name|secalgo_nsec3_hash
parameter_list|(
name|int
name|algo
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|res
parameter_list|)
block|{
switch|switch
condition|(
name|algo
condition|)
block|{
case|case
name|NSEC3_HASH_SHA1
case|:
return|return
name|_digest_nettle
argument_list|(
name|SHA1_DIGEST_SIZE
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|buf
argument_list|,
name|len
argument_list|,
name|res
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|void
name|secalgo_hash_sha256
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|res
parameter_list|)
block|{
name|_digest_nettle
argument_list|(
name|SHA256_DIGEST_SIZE
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|buf
argument_list|,
name|len
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Return size of DS digest according to its hash algorithm.  * @param algo: DS digest algo.  * @return size in bytes of digest, or 0 if not supported.  */
end_comment

begin_function
name|size_t
name|ds_digest_size_supported
parameter_list|(
name|int
name|algo
parameter_list|)
block|{
switch|switch
condition|(
name|algo
condition|)
block|{
case|case
name|LDNS_SHA1
case|:
return|return
name|SHA1_DIGEST_SIZE
return|;
ifdef|#
directive|ifdef
name|USE_SHA2
case|case
name|LDNS_SHA256
case|:
return|return
name|SHA256_DIGEST_SIZE
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_ECDSA
case|case
name|LDNS_SHA384
case|:
return|return
name|SHA384_DIGEST_SIZE
return|;
endif|#
directive|endif
comment|/* GOST not supported */
case|case
name|LDNS_HASH_GOST
case|:
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|secalgo_ds_digest
parameter_list|(
name|int
name|algo
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|res
parameter_list|)
block|{
switch|switch
condition|(
name|algo
condition|)
block|{
case|case
name|LDNS_SHA1
case|:
return|return
name|_digest_nettle
argument_list|(
name|SHA1_DIGEST_SIZE
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|res
argument_list|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|USE_SHA2
argument_list|)
case|case
name|LDNS_SHA256
case|:
return|return
name|_digest_nettle
argument_list|(
name|SHA256_DIGEST_SIZE
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|res
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_ECDSA
case|case
name|LDNS_SHA384
case|:
return|return
name|_digest_nettle
argument_list|(
name|SHA384_DIGEST_SIZE
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|res
argument_list|)
return|;
endif|#
directive|endif
case|case
name|LDNS_HASH_GOST
case|:
default|default:
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"unknown DS digest algorithm %d"
argument_list|,
name|algo
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|dnskey_algo_id_is_supported
parameter_list|(
name|int
name|id
parameter_list|)
block|{
comment|/* uses libnettle */
switch|switch
condition|(
name|id
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_DSA
case|case
name|LDNS_DSA
case|:
case|case
name|LDNS_DSA_NSEC3
case|:
endif|#
directive|endif
case|case
name|LDNS_RSASHA1
case|:
case|case
name|LDNS_RSASHA1_NSEC3
case|:
ifdef|#
directive|ifdef
name|USE_SHA2
case|case
name|LDNS_RSASHA256
case|:
case|case
name|LDNS_RSASHA512
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_ECDSA
case|case
name|LDNS_ECDSAP256SHA256
case|:
case|case
name|LDNS_ECDSAP384SHA384
case|:
endif|#
directive|endif
return|return
literal|1
return|;
case|case
name|LDNS_RSAMD5
case|:
comment|/* RFC 6725 deprecates RSAMD5 */
case|case
name|LDNS_ECC_GOST
case|:
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_DSA
end_ifdef

begin_function
specifier|static
name|char
modifier|*
name|_verify_nettle_dsa
parameter_list|(
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|unsigned
name|char
modifier|*
name|sigblock
parameter_list|,
name|unsigned
name|int
name|sigblock_len
parameter_list|,
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|unsigned
name|int
name|keylen
parameter_list|)
block|{
name|uint8_t
name|digest
index|[
name|SHA1_DIGEST_SIZE
index|]
decl_stmt|;
name|uint8_t
name|key_t
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|struct
name|dsa_public_key
name|pubkey
decl_stmt|;
name|struct
name|dsa_signature
name|signature
decl_stmt|;
name|unsigned
name|int
name|expected_len
decl_stmt|;
comment|/* Extract DSA signature from the record */
name|nettle_dsa_signature_init
argument_list|(
operator|&
name|signature
argument_list|)
expr_stmt|;
comment|/* Signature length: 41 bytes - RFC 2536 sec. 3 */
if|if
condition|(
name|sigblock_len
operator|==
literal|41
condition|)
block|{
if|if
condition|(
name|key
index|[
literal|0
index|]
operator|!=
name|sigblock
index|[
literal|0
index|]
condition|)
return|return
literal|"invalid T value in DSA signature or pubkey"
return|;
name|nettle_mpz_set_str_256_u
argument_list|(
name|signature
operator|.
name|r
argument_list|,
literal|20
argument_list|,
name|sigblock
operator|+
literal|1
argument_list|)
expr_stmt|;
name|nettle_mpz_set_str_256_u
argument_list|(
name|signature
operator|.
name|s
argument_list|,
literal|20
argument_list|,
name|sigblock
operator|+
literal|1
operator|+
literal|20
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* DER encoded, decode the ASN1 notated R and S bignums */
comment|/* SEQUENCE { r INTEGER, s INTEGER } */
name|struct
name|asn1_der_iterator
name|i
decl_stmt|,
name|seq
decl_stmt|;
if|if
condition|(
name|asn1_der_iterator_first
argument_list|(
operator|&
name|i
argument_list|,
name|sigblock_len
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|sigblock
argument_list|)
operator|!=
name|ASN1_ITERATOR_CONSTRUCTED
operator|||
name|i
operator|.
name|type
operator|!=
name|ASN1_SEQUENCE
condition|)
return|return
literal|"malformed DER encoded DSA signature"
return|;
comment|/* decode this element of i using the seq iterator */
if|if
condition|(
name|asn1_der_decode_constructed
argument_list|(
operator|&
name|i
argument_list|,
operator|&
name|seq
argument_list|)
operator|!=
name|ASN1_ITERATOR_PRIMITIVE
operator|||
name|seq
operator|.
name|type
operator|!=
name|ASN1_INTEGER
condition|)
return|return
literal|"malformed DER encoded DSA signature"
return|;
if|if
condition|(
operator|!
name|asn1_der_get_bignum
argument_list|(
operator|&
name|seq
argument_list|,
name|signature
operator|.
name|r
argument_list|,
literal|20
operator|*
literal|8
argument_list|)
condition|)
return|return
literal|"malformed DER encoded DSA signature"
return|;
if|if
condition|(
name|asn1_der_iterator_next
argument_list|(
operator|&
name|seq
argument_list|)
operator|!=
name|ASN1_ITERATOR_PRIMITIVE
operator|||
name|seq
operator|.
name|type
operator|!=
name|ASN1_INTEGER
condition|)
return|return
literal|"malformed DER encoded DSA signature"
return|;
if|if
condition|(
operator|!
name|asn1_der_get_bignum
argument_list|(
operator|&
name|seq
argument_list|,
name|signature
operator|.
name|s
argument_list|,
literal|20
operator|*
literal|8
argument_list|)
condition|)
return|return
literal|"malformed DER encoded DSA signature"
return|;
if|if
condition|(
name|asn1_der_iterator_next
argument_list|(
operator|&
name|i
argument_list|)
operator|!=
name|ASN1_ITERATOR_END
condition|)
return|return
literal|"malformed DER encoded DSA signature"
return|;
block|}
comment|/* Validate T values constraints - RFC 2536 sec. 2& sec. 3 */
name|key_t
operator|=
name|key
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|key_t
operator|>
literal|8
condition|)
block|{
return|return
literal|"invalid T value in DSA pubkey"
return|;
block|}
comment|/* Pubkey minimum length: 21 bytes - RFC 2536 sec. 2 */
if|if
condition|(
name|keylen
operator|<
literal|21
condition|)
block|{
return|return
literal|"DSA pubkey too short"
return|;
block|}
name|expected_len
operator|=
literal|1
operator|+
comment|/* T */
literal|20
operator|+
comment|/* Q */
operator|(
literal|64
operator|+
name|key_t
operator|*
literal|8
operator|)
operator|+
comment|/* P */
operator|(
literal|64
operator|+
name|key_t
operator|*
literal|8
operator|)
operator|+
comment|/* G */
operator|(
literal|64
operator|+
name|key_t
operator|*
literal|8
operator|)
expr_stmt|;
comment|/* Y */
if|if
condition|(
name|keylen
operator|!=
name|expected_len
condition|)
block|{
return|return
literal|"invalid DSA pubkey length"
return|;
block|}
comment|/* Extract DSA pubkey from the record */
name|nettle_dsa_public_key_init
argument_list|(
operator|&
name|pubkey
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|1
expr_stmt|;
name|nettle_mpz_set_str_256_u
argument_list|(
name|pubkey
operator|.
name|q
argument_list|,
literal|20
argument_list|,
name|key
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|20
expr_stmt|;
name|nettle_mpz_set_str_256_u
argument_list|(
name|pubkey
operator|.
name|p
argument_list|,
operator|(
literal|64
operator|+
name|key_t
operator|*
literal|8
operator|)
argument_list|,
name|key
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
operator|(
literal|64
operator|+
name|key_t
operator|*
literal|8
operator|)
expr_stmt|;
name|nettle_mpz_set_str_256_u
argument_list|(
name|pubkey
operator|.
name|g
argument_list|,
operator|(
literal|64
operator|+
name|key_t
operator|*
literal|8
operator|)
argument_list|,
name|key
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
operator|(
literal|64
operator|+
name|key_t
operator|*
literal|8
operator|)
expr_stmt|;
name|nettle_mpz_set_str_256_u
argument_list|(
name|pubkey
operator|.
name|y
argument_list|,
operator|(
literal|64
operator|+
name|key_t
operator|*
literal|8
operator|)
argument_list|,
name|key
operator|+
name|offset
argument_list|)
expr_stmt|;
comment|/* Digest content of "buf" and verify its DSA signature in "sigblock"*/
name|res
operator|=
name|_digest_nettle
argument_list|(
name|SHA1_DIGEST_SIZE
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|sldns_buffer_limit
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|digest
argument_list|)
expr_stmt|;
name|res
operator|&=
name|dsa_sha1_verify_digest
argument_list|(
operator|&
name|pubkey
argument_list|,
name|digest
argument_list|,
operator|&
name|signature
argument_list|)
expr_stmt|;
comment|/* Clear and return */
name|nettle_dsa_signature_clear
argument_list|(
operator|&
name|signature
argument_list|)
expr_stmt|;
name|nettle_dsa_public_key_clear
argument_list|(
operator|&
name|pubkey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
return|return
literal|"DSA signature verification failed"
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_DSA */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|_verify_nettle_rsa
parameter_list|(
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
name|digest_size
parameter_list|,
name|char
modifier|*
name|sigblock
parameter_list|,
name|unsigned
name|int
name|sigblock_len
parameter_list|,
name|uint8_t
modifier|*
name|key
parameter_list|,
name|unsigned
name|int
name|keylen
parameter_list|)
block|{
name|uint16_t
name|exp_len
init|=
literal|0
decl_stmt|;
name|size_t
name|exp_offset
init|=
literal|0
decl_stmt|,
name|mod_offset
init|=
literal|0
decl_stmt|;
name|struct
name|rsa_public_key
name|pubkey
decl_stmt|;
name|mpz_t
name|signature
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
comment|/* RSA pubkey parsing as per RFC 3110 sec. 2 */
if|if
condition|(
name|keylen
operator|<=
literal|1
condition|)
block|{
return|return
literal|"null RSA key"
return|;
block|}
if|if
condition|(
name|key
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* 1-byte length */
name|exp_len
operator|=
name|key
index|[
literal|0
index|]
expr_stmt|;
name|exp_offset
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 1-byte NUL + 2-bytes exponent length */
if|if
condition|(
name|keylen
operator|<
literal|3
condition|)
block|{
return|return
literal|"incorrect RSA key length"
return|;
block|}
name|exp_len
operator|=
name|READ_UINT16
argument_list|(
name|key
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp_len
operator|==
literal|0
condition|)
return|return
literal|"null RSA exponent length"
return|;
name|exp_offset
operator|=
literal|3
expr_stmt|;
block|}
comment|/* Check that we are not over-running input length */
if|if
condition|(
name|keylen
operator|<
name|exp_offset
operator|+
name|exp_len
operator|+
literal|1
condition|)
block|{
return|return
literal|"RSA key content shorter than expected"
return|;
block|}
name|mod_offset
operator|=
name|exp_offset
operator|+
name|exp_len
expr_stmt|;
name|nettle_rsa_public_key_init
argument_list|(
operator|&
name|pubkey
argument_list|)
expr_stmt|;
name|pubkey
operator|.
name|size
operator|=
name|keylen
operator|-
name|mod_offset
expr_stmt|;
name|nettle_mpz_set_str_256_u
argument_list|(
name|pubkey
operator|.
name|e
argument_list|,
name|exp_len
argument_list|,
operator|&
name|key
index|[
name|exp_offset
index|]
argument_list|)
expr_stmt|;
name|nettle_mpz_set_str_256_u
argument_list|(
name|pubkey
operator|.
name|n
argument_list|,
name|pubkey
operator|.
name|size
argument_list|,
operator|&
name|key
index|[
name|mod_offset
index|]
argument_list|)
expr_stmt|;
comment|/* Digest content of "buf" and verify its RSA signature in "sigblock"*/
name|nettle_mpz_init_set_str_256_u
argument_list|(
name|signature
argument_list|,
name|sigblock_len
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|sigblock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|digest_size
condition|)
block|{
case|case
name|SHA1_DIGEST_SIZE
case|:
block|{
name|uint8_t
name|digest
index|[
name|SHA1_DIGEST_SIZE
index|]
decl_stmt|;
name|res
operator|=
name|_digest_nettle
argument_list|(
name|SHA1_DIGEST_SIZE
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|sldns_buffer_limit
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|digest
argument_list|)
expr_stmt|;
name|res
operator|&=
name|rsa_sha1_verify_digest
argument_list|(
operator|&
name|pubkey
argument_list|,
name|digest
argument_list|,
name|signature
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SHA256_DIGEST_SIZE
case|:
block|{
name|uint8_t
name|digest
index|[
name|SHA256_DIGEST_SIZE
index|]
decl_stmt|;
name|res
operator|=
name|_digest_nettle
argument_list|(
name|SHA256_DIGEST_SIZE
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|sldns_buffer_limit
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|digest
argument_list|)
expr_stmt|;
name|res
operator|&=
name|rsa_sha256_verify_digest
argument_list|(
operator|&
name|pubkey
argument_list|,
name|digest
argument_list|,
name|signature
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SHA512_DIGEST_SIZE
case|:
block|{
name|uint8_t
name|digest
index|[
name|SHA512_DIGEST_SIZE
index|]
decl_stmt|;
name|res
operator|=
name|_digest_nettle
argument_list|(
name|SHA512_DIGEST_SIZE
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|sldns_buffer_limit
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|digest
argument_list|)
expr_stmt|;
name|res
operator|&=
name|rsa_sha512_verify_digest
argument_list|(
operator|&
name|pubkey
argument_list|,
name|digest
argument_list|,
name|signature
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
comment|/* Clear and return */
name|nettle_rsa_public_key_clear
argument_list|(
operator|&
name|pubkey
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|signature
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
block|{
return|return
literal|"RSA signature verification failed"
return|;
block|}
else|else
block|{
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_ECDSA
end_ifdef

begin_function
specifier|static
name|char
modifier|*
name|_verify_nettle_ecdsa
parameter_list|(
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
name|digest_size
parameter_list|,
name|unsigned
name|char
modifier|*
name|sigblock
parameter_list|,
name|unsigned
name|int
name|sigblock_len
parameter_list|,
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|unsigned
name|int
name|keylen
parameter_list|)
block|{
name|int
name|res
init|=
literal|0
decl_stmt|;
name|struct
name|ecc_point
name|pubkey
decl_stmt|;
name|struct
name|dsa_signature
name|signature
decl_stmt|;
comment|/* Always matched strength, as per RFC 6605 sec. 1 */
if|if
condition|(
name|sigblock_len
operator|!=
literal|2
operator|*
name|digest_size
operator|||
name|keylen
operator|!=
literal|2
operator|*
name|digest_size
condition|)
block|{
return|return
literal|"wrong ECDSA signature length"
return|;
block|}
comment|/* Parse ECDSA signature as per RFC 6605 sec. 4 */
name|nettle_dsa_signature_init
argument_list|(
operator|&
name|signature
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|digest_size
condition|)
block|{
case|case
name|SHA256_DIGEST_SIZE
case|:
block|{
name|uint8_t
name|digest
index|[
name|SHA256_DIGEST_SIZE
index|]
decl_stmt|;
name|mpz_t
name|x
decl_stmt|,
name|y
decl_stmt|;
name|nettle_ecc_point_init
argument_list|(
operator|&
name|pubkey
argument_list|,
operator|&
name|nettle_secp_256r1
argument_list|)
expr_stmt|;
name|nettle_mpz_init_set_str_256_u
argument_list|(
name|x
argument_list|,
name|SHA256_DIGEST_SIZE
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|nettle_mpz_init_set_str_256_u
argument_list|(
name|y
argument_list|,
name|SHA256_DIGEST_SIZE
argument_list|,
name|key
operator|+
name|SHA256_DIGEST_SIZE
argument_list|)
expr_stmt|;
name|nettle_mpz_set_str_256_u
argument_list|(
name|signature
operator|.
name|r
argument_list|,
name|SHA256_DIGEST_SIZE
argument_list|,
name|sigblock
argument_list|)
expr_stmt|;
name|nettle_mpz_set_str_256_u
argument_list|(
name|signature
operator|.
name|s
argument_list|,
name|SHA256_DIGEST_SIZE
argument_list|,
name|sigblock
operator|+
name|SHA256_DIGEST_SIZE
argument_list|)
expr_stmt|;
name|res
operator|=
name|_digest_nettle
argument_list|(
name|SHA256_DIGEST_SIZE
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|sldns_buffer_limit
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|digest
argument_list|)
expr_stmt|;
name|res
operator|&=
name|nettle_ecc_point_set
argument_list|(
operator|&
name|pubkey
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|res
operator|&=
name|nettle_ecdsa_verify
argument_list|(
operator|&
name|pubkey
argument_list|,
name|SHA256_DIGEST_SIZE
argument_list|,
name|digest
argument_list|,
operator|&
name|signature
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|y
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SHA384_DIGEST_SIZE
case|:
block|{
name|uint8_t
name|digest
index|[
name|SHA384_DIGEST_SIZE
index|]
decl_stmt|;
name|mpz_t
name|x
decl_stmt|,
name|y
decl_stmt|;
name|nettle_ecc_point_init
argument_list|(
operator|&
name|pubkey
argument_list|,
operator|&
name|nettle_secp_384r1
argument_list|)
expr_stmt|;
name|nettle_mpz_init_set_str_256_u
argument_list|(
name|x
argument_list|,
name|SHA384_DIGEST_SIZE
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|nettle_mpz_init_set_str_256_u
argument_list|(
name|y
argument_list|,
name|SHA384_DIGEST_SIZE
argument_list|,
name|key
operator|+
name|SHA384_DIGEST_SIZE
argument_list|)
expr_stmt|;
name|nettle_mpz_set_str_256_u
argument_list|(
name|signature
operator|.
name|r
argument_list|,
name|SHA384_DIGEST_SIZE
argument_list|,
name|sigblock
argument_list|)
expr_stmt|;
name|nettle_mpz_set_str_256_u
argument_list|(
name|signature
operator|.
name|s
argument_list|,
name|SHA384_DIGEST_SIZE
argument_list|,
name|sigblock
operator|+
name|SHA384_DIGEST_SIZE
argument_list|)
expr_stmt|;
name|res
operator|=
name|_digest_nettle
argument_list|(
name|SHA384_DIGEST_SIZE
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|sldns_buffer_limit
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|digest
argument_list|)
expr_stmt|;
name|res
operator|&=
name|nettle_ecc_point_set
argument_list|(
operator|&
name|pubkey
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|res
operator|&=
name|nettle_ecdsa_verify
argument_list|(
operator|&
name|pubkey
argument_list|,
name|SHA384_DIGEST_SIZE
argument_list|,
name|digest
argument_list|,
operator|&
name|signature
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|nettle_ecc_point_clear
argument_list|(
operator|&
name|pubkey
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
return|return
literal|"unknown ECDSA algorithm"
return|;
block|}
comment|/* Clear and return */
name|nettle_dsa_signature_clear
argument_list|(
operator|&
name|signature
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
return|return
literal|"ECDSA signature verification failed"
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Check a canonical sig+rrset and signature against a dnskey  * @param buf: buffer with data to verify, the first rrsig part and the  *	canonicalized rrset.  * @param algo: DNSKEY algorithm.  * @param sigblock: signature rdata field from RRSIG  * @param sigblock_len: length of sigblock data.  * @param key: public key data from DNSKEY RR.  * @param keylen: length of keydata.  * @param reason: bogus reason in more detail.  * @return secure if verification succeeded, bogus on crypto failure,  *	unchecked on format errors and alloc failures.  */
end_comment

begin_function
name|enum
name|sec_status
name|verify_canonrrset
parameter_list|(
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|int
name|algo
parameter_list|,
name|unsigned
name|char
modifier|*
name|sigblock
parameter_list|,
name|unsigned
name|int
name|sigblock_len
parameter_list|,
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|unsigned
name|int
name|keylen
parameter_list|,
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
name|unsigned
name|int
name|digest_size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sigblock_len
operator|==
literal|0
operator|||
name|keylen
operator|==
literal|0
condition|)
block|{
operator|*
name|reason
operator|=
literal|"null signature"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
switch|switch
condition|(
name|algo
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_DSA
case|case
name|LDNS_DSA
case|:
case|case
name|LDNS_DSA_NSEC3
case|:
operator|*
name|reason
operator|=
name|_verify_nettle_dsa
argument_list|(
name|buf
argument_list|,
name|sigblock
argument_list|,
name|sigblock_len
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|reason
operator|!=
name|NULL
condition|)
return|return
name|sec_status_bogus
return|;
else|else
return|return
name|sec_status_secure
return|;
endif|#
directive|endif
comment|/* USE_DSA */
case|case
name|LDNS_RSASHA1
case|:
case|case
name|LDNS_RSASHA1_NSEC3
case|:
name|digest_size
operator|=
operator|(
name|digest_size
condition|?
name|digest_size
else|:
name|SHA1_DIGEST_SIZE
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_SHA2
case|case
name|LDNS_RSASHA256
case|:
name|digest_size
operator|=
operator|(
name|digest_size
condition|?
name|digest_size
else|:
name|SHA256_DIGEST_SIZE
operator|)
expr_stmt|;
case|case
name|LDNS_RSASHA512
case|:
name|digest_size
operator|=
operator|(
name|digest_size
condition|?
name|digest_size
else|:
name|SHA512_DIGEST_SIZE
operator|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|reason
operator|=
name|_verify_nettle_rsa
argument_list|(
name|buf
argument_list|,
name|digest_size
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sigblock
argument_list|,
name|sigblock_len
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|reason
operator|!=
name|NULL
condition|)
return|return
name|sec_status_bogus
return|;
else|else
return|return
name|sec_status_secure
return|;
ifdef|#
directive|ifdef
name|USE_ECDSA
case|case
name|LDNS_ECDSAP256SHA256
case|:
name|digest_size
operator|=
operator|(
name|digest_size
condition|?
name|digest_size
else|:
name|SHA256_DIGEST_SIZE
operator|)
expr_stmt|;
case|case
name|LDNS_ECDSAP384SHA384
case|:
name|digest_size
operator|=
operator|(
name|digest_size
condition|?
name|digest_size
else|:
name|SHA384_DIGEST_SIZE
operator|)
expr_stmt|;
operator|*
name|reason
operator|=
name|_verify_nettle_ecdsa
argument_list|(
name|buf
argument_list|,
name|digest_size
argument_list|,
name|sigblock
argument_list|,
name|sigblock_len
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|reason
operator|!=
name|NULL
condition|)
return|return
name|sec_status_bogus
return|;
else|else
return|return
name|sec_status_secure
return|;
endif|#
directive|endif
case|case
name|LDNS_RSAMD5
case|:
case|case
name|LDNS_ECC_GOST
case|:
default|default:
operator|*
name|reason
operator|=
literal|"unable to verify signature, unknown algorithm"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SSL or HAVE_NSS or HAVE_NETTLE */
end_comment

end_unit

