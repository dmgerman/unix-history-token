begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * validator/val_secalgo.c - validator security algorithm functions.  *  * Copyright (c) 2012, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains helper functions for the validator module.  * These functions take raw data buffers, formatted for crypto verification,  * and do the library calls (for the crypto library in use).  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_secalgo.h"
end_include

begin_include
include|#
directive|include
file|"util/data/packed_rrset.h"
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"ldns/rrdef.h"
end_include

begin_include
include|#
directive|include
file|"ldns/keyraw.h"
end_include

begin_include
include|#
directive|include
file|"ldns/sbuffer.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_SSL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_NSS
argument_list|)
end_if

begin_error
error|#
directive|error
literal|"Need crypto library to do digital signature cryptography"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OpenSSL implementation */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SSL
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_ERR_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_RAND_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_CONF_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/conf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_ENGINE_H
end_ifdef

begin_include
include|#
directive|include
file|<openssl/engine.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Return size of DS digest according to its hash algorithm.  * @param algo: DS digest algo.  * @return size in bytes of digest, or 0 if not supported.   */
end_comment

begin_function
name|size_t
name|ds_digest_size_supported
parameter_list|(
name|int
name|algo
parameter_list|)
block|{
switch|switch
condition|(
name|algo
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_EVP_SHA1
case|case
name|LDNS_SHA1
case|:
return|return
name|SHA_DIGEST_LENGTH
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_EVP_SHA256
case|case
name|LDNS_SHA256
case|:
return|return
name|SHA256_DIGEST_LENGTH
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_GOST
case|case
name|LDNS_HASH_GOST
case|:
if|if
condition|(
name|EVP_get_digestbyname
argument_list|(
literal|"md_gost94"
argument_list|)
condition|)
return|return
literal|32
return|;
else|else
return|return
literal|0
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_ECDSA
case|case
name|LDNS_SHA384
case|:
return|return
name|SHA384_DIGEST_LENGTH
return|;
endif|#
directive|endif
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_GOST
end_ifdef

begin_comment
comment|/** Perform GOST hash */
end_comment

begin_function
specifier|static
name|int
name|do_gost94
parameter_list|(
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|dest
parameter_list|)
block|{
specifier|const
name|EVP_MD
modifier|*
name|md
init|=
name|EVP_get_digestbyname
argument_list|(
literal|"md_gost94"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|md
condition|)
return|return
literal|0
return|;
return|return
name|sldns_digest_evp
argument_list|(
name|data
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|len
argument_list|,
name|dest
argument_list|,
name|md
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|secalgo_ds_digest
parameter_list|(
name|int
name|algo
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|res
parameter_list|)
block|{
switch|switch
condition|(
name|algo
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_EVP_SHA1
case|case
name|LDNS_SHA1
case|:
operator|(
name|void
operator|)
name|SHA1
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_EVP_SHA256
case|case
name|LDNS_SHA256
case|:
operator|(
name|void
operator|)
name|SHA256
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_GOST
case|case
name|LDNS_HASH_GOST
case|:
if|if
condition|(
name|do_gost94
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|res
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_ECDSA
case|case
name|LDNS_SHA384
case|:
operator|(
name|void
operator|)
name|SHA384
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
default|default:
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"unknown DS digest algorithm %d"
argument_list|,
name|algo
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** return true if DNSKEY algorithm id is supported */
end_comment

begin_function
name|int
name|dnskey_algo_id_is_supported
parameter_list|(
name|int
name|id
parameter_list|)
block|{
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|LDNS_RSAMD5
case|:
comment|/* RFC 6725 deprecates RSAMD5 */
return|return
literal|0
return|;
case|case
name|LDNS_DSA
case|:
case|case
name|LDNS_DSA_NSEC3
case|:
case|case
name|LDNS_RSASHA1
case|:
case|case
name|LDNS_RSASHA1_NSEC3
case|:
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EVP_SHA256
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_SHA2
argument_list|)
case|case
name|LDNS_RSASHA256
case|:
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EVP_SHA512
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_SHA2
argument_list|)
case|case
name|LDNS_RSASHA512
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_ECDSA
case|case
name|LDNS_ECDSAP256SHA256
case|:
case|case
name|LDNS_ECDSAP384SHA384
case|:
endif|#
directive|endif
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|USE_GOST
case|case
name|LDNS_ECC_GOST
case|:
comment|/* we support GOST if it can be loaded */
return|return
name|sldns_key_EVP_load_gost_id
argument_list|()
return|;
endif|#
directive|endif
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Output a libcrypto openssl error to the logfile.  * @param str: string to add to it.  * @param e: the error to output, error number from ERR_get_error().  */
end_comment

begin_function
specifier|static
name|void
name|log_crypto_error
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|unsigned
name|long
name|e
parameter_list|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
comment|/* or use ERR_error_string if ERR_error_string_n is not avail TODO */
name|ERR_error_string_n
argument_list|(
name|e
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* buf now contains */
comment|/* error:[error code]:[library name]:[function name]:[reason string] */
name|log_err
argument_list|(
literal|"%s crypto %s"
argument_list|,
name|str
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Setup DSA key digest in DER encoding ...   * @param sig: input is signature output alloced ptr (unless failure).  * 	caller must free alloced ptr if this routine returns true.  * @param len: input is initial siglen, output is output len.  * @return false on failure.  */
end_comment

begin_function
specifier|static
name|int
name|setup_dsa_sig
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|sig
parameter_list|,
name|unsigned
name|int
modifier|*
name|len
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|orig
init|=
operator|*
name|sig
decl_stmt|;
name|unsigned
name|int
name|origlen
init|=
operator|*
name|len
decl_stmt|;
name|int
name|newlen
decl_stmt|;
name|BIGNUM
modifier|*
name|R
decl_stmt|,
modifier|*
name|S
decl_stmt|;
name|DSA_SIG
modifier|*
name|dsasig
decl_stmt|;
comment|/* extract the R and S field from the sig buffer */
if|if
condition|(
name|origlen
operator|<
literal|1
operator|+
literal|2
operator|*
name|SHA_DIGEST_LENGTH
condition|)
return|return
literal|0
return|;
name|R
operator|=
name|BN_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|R
condition|)
return|return
literal|0
return|;
operator|(
name|void
operator|)
name|BN_bin2bn
argument_list|(
name|orig
operator|+
literal|1
argument_list|,
name|SHA_DIGEST_LENGTH
argument_list|,
name|R
argument_list|)
expr_stmt|;
name|S
operator|=
name|BN_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|S
condition|)
return|return
literal|0
return|;
operator|(
name|void
operator|)
name|BN_bin2bn
argument_list|(
name|orig
operator|+
literal|21
argument_list|,
name|SHA_DIGEST_LENGTH
argument_list|,
name|S
argument_list|)
expr_stmt|;
name|dsasig
operator|=
name|DSA_SIG_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|dsasig
condition|)
return|return
literal|0
return|;
name|dsasig
operator|->
name|r
operator|=
name|R
expr_stmt|;
name|dsasig
operator|->
name|s
operator|=
name|S
expr_stmt|;
operator|*
name|sig
operator|=
name|NULL
expr_stmt|;
name|newlen
operator|=
name|i2d_DSA_SIG
argument_list|(
name|dsasig
argument_list|,
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|newlen
operator|<
literal|0
condition|)
block|{
name|DSA_SIG_free
argument_list|(
name|dsasig
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|sig
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|len
operator|=
operator|(
name|unsigned
name|int
operator|)
name|newlen
expr_stmt|;
name|DSA_SIG_free
argument_list|(
name|dsasig
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_ECDSA
end_ifdef

begin_comment
comment|/**  * Setup the ECDSA signature in its encoding that the library wants.  * Converts from plain numbers to ASN formatted.  * @param sig: input is signature, output alloced ptr (unless failure).  * 	caller must free alloced ptr if this routine returns true.  * @param len: input is initial siglen, output is output len.  * @return false on failure.  */
end_comment

begin_function
specifier|static
name|int
name|setup_ecdsa_sig
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|sig
parameter_list|,
name|unsigned
name|int
modifier|*
name|len
parameter_list|)
block|{
name|ECDSA_SIG
modifier|*
name|ecdsa_sig
decl_stmt|;
name|int
name|newlen
decl_stmt|;
name|int
name|bnsize
init|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|*
name|len
operator|)
operator|/
literal|2
argument_list|)
decl_stmt|;
comment|/* if too short or not even length, fails */
if|if
condition|(
operator|*
name|len
operator|<
literal|16
operator|||
name|bnsize
operator|*
literal|2
operator|!=
operator|(
name|int
operator|)
operator|*
name|len
condition|)
return|return
literal|0
return|;
comment|/* use the raw data to parse two evenly long BIGNUMs, "r | s". */
name|ecdsa_sig
operator|=
name|ECDSA_SIG_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ecdsa_sig
condition|)
return|return
literal|0
return|;
name|ecdsa_sig
operator|->
name|r
operator|=
name|BN_bin2bn
argument_list|(
operator|*
name|sig
argument_list|,
name|bnsize
argument_list|,
name|ecdsa_sig
operator|->
name|r
argument_list|)
expr_stmt|;
name|ecdsa_sig
operator|->
name|s
operator|=
name|BN_bin2bn
argument_list|(
operator|*
name|sig
operator|+
name|bnsize
argument_list|,
name|bnsize
argument_list|,
name|ecdsa_sig
operator|->
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ecdsa_sig
operator|->
name|r
operator|||
operator|!
name|ecdsa_sig
operator|->
name|s
condition|)
block|{
name|ECDSA_SIG_free
argument_list|(
name|ecdsa_sig
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* spool it into ASN format */
operator|*
name|sig
operator|=
name|NULL
expr_stmt|;
name|newlen
operator|=
name|i2d_ECDSA_SIG
argument_list|(
name|ecdsa_sig
argument_list|,
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|newlen
operator|<=
literal|0
condition|)
block|{
name|ECDSA_SIG_free
argument_list|(
name|ecdsa_sig
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|sig
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|len
operator|=
operator|(
name|unsigned
name|int
operator|)
name|newlen
expr_stmt|;
name|ECDSA_SIG_free
argument_list|(
name|ecdsa_sig
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_ECDSA */
end_comment

begin_comment
comment|/**  * Setup key and digest for verification. Adjust sig if necessary.  *  * @param algo: key algorithm  * @param evp_key: EVP PKEY public key to create.  * @param digest_type: digest type to use  * @param key: key to setup for.  * @param keylen: length of key.  * @return false on failure.  */
end_comment

begin_function
specifier|static
name|int
name|setup_key_digest
parameter_list|(
name|int
name|algo
parameter_list|,
name|EVP_PKEY
modifier|*
modifier|*
name|evp_key
parameter_list|,
specifier|const
name|EVP_MD
modifier|*
modifier|*
name|digest_type
parameter_list|,
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|size_t
name|keylen
parameter_list|)
block|{
name|DSA
modifier|*
name|dsa
decl_stmt|;
name|RSA
modifier|*
name|rsa
decl_stmt|;
switch|switch
condition|(
name|algo
condition|)
block|{
case|case
name|LDNS_DSA
case|:
case|case
name|LDNS_DSA_NSEC3
case|:
operator|*
name|evp_key
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|evp_key
condition|)
block|{
name|log_err
argument_list|(
literal|"verify: malloc failure in crypto"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dsa
operator|=
name|sldns_key_buf2dsa_raw
argument_list|(
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dsa
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: "
literal|"sldns_key_buf2dsa_raw failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|EVP_PKEY_assign_DSA
argument_list|(
operator|*
name|evp_key
argument_list|,
name|dsa
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: "
literal|"EVP_PKEY_assign_DSA failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|digest_type
operator|=
name|EVP_dss1
argument_list|()
expr_stmt|;
break|break;
case|case
name|LDNS_RSASHA1
case|:
case|case
name|LDNS_RSASHA1_NSEC3
case|:
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EVP_SHA256
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_SHA2
argument_list|)
case|case
name|LDNS_RSASHA256
case|:
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EVP_SHA512
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_SHA2
argument_list|)
case|case
name|LDNS_RSASHA512
case|:
endif|#
directive|endif
operator|*
name|evp_key
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|evp_key
condition|)
block|{
name|log_err
argument_list|(
literal|"verify: malloc failure in crypto"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|rsa
operator|=
name|sldns_key_buf2rsa_raw
argument_list|(
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rsa
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: "
literal|"sldns_key_buf2rsa_raw SHA failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|EVP_PKEY_assign_RSA
argument_list|(
operator|*
name|evp_key
argument_list|,
name|rsa
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: "
literal|"EVP_PKEY_assign_RSA SHA failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* select SHA version */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EVP_SHA256
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_SHA2
argument_list|)
if|if
condition|(
name|algo
operator|==
name|LDNS_RSASHA256
condition|)
operator|*
name|digest_type
operator|=
name|EVP_sha256
argument_list|()
expr_stmt|;
elseif|else
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EVP_SHA512
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_SHA2
argument_list|)
if|if
condition|(
name|algo
operator|==
name|LDNS_RSASHA512
condition|)
operator|*
name|digest_type
operator|=
name|EVP_sha512
argument_list|()
expr_stmt|;
else|else
endif|#
directive|endif
operator|*
name|digest_type
operator|=
name|EVP_sha1
argument_list|()
expr_stmt|;
break|break;
case|case
name|LDNS_RSAMD5
case|:
operator|*
name|evp_key
operator|=
name|EVP_PKEY_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|evp_key
condition|)
block|{
name|log_err
argument_list|(
literal|"verify: malloc failure in crypto"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|rsa
operator|=
name|sldns_key_buf2rsa_raw
argument_list|(
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rsa
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: "
literal|"sldns_key_buf2rsa_raw MD5 failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|EVP_PKEY_assign_RSA
argument_list|(
operator|*
name|evp_key
argument_list|,
name|rsa
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: "
literal|"EVP_PKEY_assign_RSA MD5 failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|digest_type
operator|=
name|EVP_md5
argument_list|()
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|USE_GOST
case|case
name|LDNS_ECC_GOST
case|:
operator|*
name|evp_key
operator|=
name|sldns_gost2pkey_raw
argument_list|(
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|evp_key
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: "
literal|"sldns_gost2pkey_raw failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|digest_type
operator|=
name|EVP_get_digestbyname
argument_list|(
literal|"md_gost94"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|digest_type
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: "
literal|"EVP_getdigest md_gost94 failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_ECDSA
case|case
name|LDNS_ECDSAP256SHA256
case|:
operator|*
name|evp_key
operator|=
name|sldns_ecdsa2pkey_raw
argument_list|(
name|key
argument_list|,
name|keylen
argument_list|,
name|LDNS_ECDSAP256SHA256
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|evp_key
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: "
literal|"sldns_ecdsa2pkey_raw failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|USE_ECDSA_EVP_WORKAROUND
comment|/* openssl before 1.0.0 fixes RSA with the SHA256 			 * hash in EVP.  We create one for ecdsa_sha256 */
block|{
specifier|static
name|int
name|md_ecdsa_256_done
init|=
literal|0
decl_stmt|;
specifier|static
name|EVP_MD
name|md
decl_stmt|;
if|if
condition|(
operator|!
name|md_ecdsa_256_done
condition|)
block|{
name|EVP_MD
name|m
init|=
operator|*
name|EVP_sha256
argument_list|()
decl_stmt|;
name|md_ecdsa_256_done
operator|=
literal|1
expr_stmt|;
name|m
operator|.
name|required_pkey_type
index|[
literal|0
index|]
operator|=
operator|(
operator|*
name|evp_key
operator|)
operator|->
name|type
expr_stmt|;
name|m
operator|.
name|verify
operator|=
operator|(
name|void
operator|*
operator|)
name|ECDSA_verify
expr_stmt|;
name|md
operator|=
name|m
expr_stmt|;
block|}
operator|*
name|digest_type
operator|=
operator|&
name|md
expr_stmt|;
block|}
else|#
directive|else
operator|*
name|digest_type
operator|=
name|EVP_sha256
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|LDNS_ECDSAP384SHA384
case|:
operator|*
name|evp_key
operator|=
name|sldns_ecdsa2pkey_raw
argument_list|(
name|key
argument_list|,
name|keylen
argument_list|,
name|LDNS_ECDSAP384SHA384
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|evp_key
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: "
literal|"sldns_ecdsa2pkey_raw failed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|USE_ECDSA_EVP_WORKAROUND
comment|/* openssl before 1.0.0 fixes RSA with the SHA384 			 * hash in EVP.  We create one for ecdsa_sha384 */
block|{
specifier|static
name|int
name|md_ecdsa_384_done
init|=
literal|0
decl_stmt|;
specifier|static
name|EVP_MD
name|md
decl_stmt|;
if|if
condition|(
operator|!
name|md_ecdsa_384_done
condition|)
block|{
name|EVP_MD
name|m
init|=
operator|*
name|EVP_sha384
argument_list|()
decl_stmt|;
name|md_ecdsa_384_done
operator|=
literal|1
expr_stmt|;
name|m
operator|.
name|required_pkey_type
index|[
literal|0
index|]
operator|=
operator|(
operator|*
name|evp_key
operator|)
operator|->
name|type
expr_stmt|;
name|m
operator|.
name|verify
operator|=
operator|(
name|void
operator|*
operator|)
name|ECDSA_verify
expr_stmt|;
name|md
operator|=
name|m
expr_stmt|;
block|}
operator|*
name|digest_type
operator|=
operator|&
name|md
expr_stmt|;
block|}
else|#
directive|else
operator|*
name|digest_type
operator|=
name|EVP_sha384
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
endif|#
directive|endif
comment|/* USE_ECDSA */
default|default:
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: unknown algorithm %d"
argument_list|,
name|algo
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Check a canonical sig+rrset and signature against a dnskey  * @param buf: buffer with data to verify, the first rrsig part and the  *	canonicalized rrset.  * @param algo: DNSKEY algorithm.  * @param sigblock: signature rdata field from RRSIG  * @param sigblock_len: length of sigblock data.  * @param key: public key data from DNSKEY RR.  * @param keylen: length of keydata.  * @param reason: bogus reason in more detail.  * @return secure if verification succeeded, bogus on crypto failure,  *	unchecked on format errors and alloc failures.  */
end_comment

begin_function
name|enum
name|sec_status
name|verify_canonrrset
parameter_list|(
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|int
name|algo
parameter_list|,
name|unsigned
name|char
modifier|*
name|sigblock
parameter_list|,
name|unsigned
name|int
name|sigblock_len
parameter_list|,
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|unsigned
name|int
name|keylen
parameter_list|,
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
specifier|const
name|EVP_MD
modifier|*
name|digest_type
decl_stmt|;
name|EVP_MD_CTX
name|ctx
decl_stmt|;
name|int
name|res
decl_stmt|,
name|dofree
init|=
literal|0
decl_stmt|;
name|EVP_PKEY
modifier|*
name|evp_key
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|setup_key_digest
argument_list|(
name|algo
argument_list|,
operator|&
name|evp_key
argument_list|,
operator|&
name|digest_type
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: failed to setup key"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"use of key for crypto failed"
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|evp_key
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
comment|/* if it is a DSA signature in bind format, convert to DER format */
if|if
condition|(
operator|(
name|algo
operator|==
name|LDNS_DSA
operator|||
name|algo
operator|==
name|LDNS_DSA_NSEC3
operator|)
operator|&&
name|sigblock_len
operator|==
literal|1
operator|+
literal|2
operator|*
name|SHA_DIGEST_LENGTH
condition|)
block|{
if|if
condition|(
operator|!
name|setup_dsa_sig
argument_list|(
operator|&
name|sigblock
argument_list|,
operator|&
name|sigblock_len
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: failed to setup DSA sig"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"use of key for DSA crypto failed"
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|evp_key
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
name|dofree
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_ECDSA
elseif|else
if|if
condition|(
name|algo
operator|==
name|LDNS_ECDSAP256SHA256
operator|||
name|algo
operator|==
name|LDNS_ECDSAP384SHA384
condition|)
block|{
comment|/* EVP uses ASN prefix on sig, which is not in the wire data */
if|if
condition|(
operator|!
name|setup_ecdsa_sig
argument_list|(
operator|&
name|sigblock
argument_list|,
operator|&
name|sigblock_len
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: failed to setup ECDSA sig"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"use of signature for ECDSA crypto failed"
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|evp_key
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
name|dofree
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_ECDSA */
comment|/* do the signature cryptography work */
name|EVP_MD_CTX_init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_VerifyInit
argument_list|(
operator|&
name|ctx
argument_list|,
name|digest_type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: EVP_VerifyInit failed"
argument_list|)
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|evp_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|dofree
condition|)
name|free
argument_list|(
name|sigblock
argument_list|)
expr_stmt|;
return|return
name|sec_status_unchecked
return|;
block|}
if|if
condition|(
name|EVP_VerifyUpdate
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|sldns_buffer_limit
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: EVP_VerifyUpdate failed"
argument_list|)
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|evp_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|dofree
condition|)
name|free
argument_list|(
name|sigblock
argument_list|)
expr_stmt|;
return|return
name|sec_status_unchecked
return|;
block|}
name|res
operator|=
name|EVP_VerifyFinal
argument_list|(
operator|&
name|ctx
argument_list|,
name|sigblock
argument_list|,
name|sigblock_len
argument_list|,
name|evp_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|EVP_MD_CTX_cleanup
argument_list|(
operator|&
name|ctx
argument_list|)
operator|==
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: EVP_MD_CTX_cleanup failed"
argument_list|)
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|evp_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|dofree
condition|)
name|free
argument_list|(
name|sigblock
argument_list|)
expr_stmt|;
return|return
name|sec_status_unchecked
return|;
block|}
name|EVP_PKEY_free
argument_list|(
name|evp_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|dofree
condition|)
name|free
argument_list|(
name|sigblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|1
condition|)
block|{
return|return
name|sec_status_secure
return|;
block|}
elseif|else
if|if
condition|(
name|res
operator|==
literal|0
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: signature mismatch"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"signature crypto failed"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
name|log_crypto_error
argument_list|(
literal|"verify:"
argument_list|,
name|ERR_get_error
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|sec_status_unchecked
return|;
block|}
end_function

begin_comment
comment|/**************************************************/
end_comment

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_NSS
argument_list|)
end_elif

begin_comment
comment|/* libnss implementation */
end_comment

begin_comment
comment|/* nss3 */
end_comment

begin_include
include|#
directive|include
file|"sechash.h"
end_include

begin_include
include|#
directive|include
file|"pk11pub.h"
end_include

begin_include
include|#
directive|include
file|"keyhi.h"
end_include

begin_include
include|#
directive|include
file|"secerr.h"
end_include

begin_include
include|#
directive|include
file|"cryptohi.h"
end_include

begin_comment
comment|/* nspr4 */
end_comment

begin_include
include|#
directive|include
file|"prerror.h"
end_include

begin_function
name|size_t
name|ds_digest_size_supported
parameter_list|(
name|int
name|algo
parameter_list|)
block|{
comment|/* uses libNSS */
switch|switch
condition|(
name|algo
condition|)
block|{
case|case
name|LDNS_SHA1
case|:
return|return
name|SHA1_LENGTH
return|;
ifdef|#
directive|ifdef
name|USE_SHA2
case|case
name|LDNS_SHA256
case|:
return|return
name|SHA256_LENGTH
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_ECDSA
case|case
name|LDNS_SHA384
case|:
return|return
name|SHA384_LENGTH
return|;
endif|#
directive|endif
comment|/* GOST not supported in NSS */
case|case
name|LDNS_HASH_GOST
case|:
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|secalgo_ds_digest
parameter_list|(
name|int
name|algo
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|res
parameter_list|)
block|{
comment|/* uses libNSS */
switch|switch
condition|(
name|algo
condition|)
block|{
case|case
name|LDNS_SHA1
case|:
return|return
name|HASH_HashBuf
argument_list|(
name|HASH_AlgSHA1
argument_list|,
name|res
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|==
name|SECSuccess
return|;
if|#
directive|if
name|defined
argument_list|(
name|USE_SHA2
argument_list|)
case|case
name|LDNS_SHA256
case|:
return|return
name|HASH_HashBuf
argument_list|(
name|HASH_AlgSHA256
argument_list|,
name|res
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|==
name|SECSuccess
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_ECDSA
case|case
name|LDNS_SHA384
case|:
return|return
name|HASH_HashBuf
argument_list|(
name|HASH_AlgSHA384
argument_list|,
name|res
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|==
name|SECSuccess
return|;
endif|#
directive|endif
case|case
name|LDNS_HASH_GOST
case|:
default|default:
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"unknown DS digest algorithm %d"
argument_list|,
name|algo
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|dnskey_algo_id_is_supported
parameter_list|(
name|int
name|id
parameter_list|)
block|{
comment|/* uses libNSS */
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|LDNS_RSAMD5
case|:
comment|/* RFC 6725 deprecates RSAMD5 */
return|return
literal|0
return|;
case|case
name|LDNS_DSA
case|:
case|case
name|LDNS_DSA_NSEC3
case|:
case|case
name|LDNS_RSASHA1
case|:
case|case
name|LDNS_RSASHA1_NSEC3
case|:
ifdef|#
directive|ifdef
name|USE_SHA2
case|case
name|LDNS_RSASHA256
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_SHA2
case|case
name|LDNS_RSASHA512
case|:
endif|#
directive|endif
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|USE_ECDSA
case|case
name|LDNS_ECDSAP256SHA256
case|:
case|case
name|LDNS_ECDSAP384SHA384
case|:
return|return
name|PK11_TokenExists
argument_list|(
name|CKM_ECDSA
argument_list|)
return|;
endif|#
directive|endif
case|case
name|LDNS_ECC_GOST
case|:
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* return a new public key for NSS */
end_comment

begin_function
specifier|static
name|SECKEYPublicKey
modifier|*
name|nss_key_create
parameter_list|(
name|KeyType
name|ktype
parameter_list|)
block|{
name|SECKEYPublicKey
modifier|*
name|key
decl_stmt|;
name|PLArenaPool
modifier|*
name|arena
init|=
name|PORT_NewArena
argument_list|(
name|DER_DEFAULT_CHUNKSIZE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|arena
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory, PORT_NewArena failed"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|key
operator|=
name|PORT_ArenaZNew
argument_list|(
name|arena
argument_list|,
name|SECKEYPublicKey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory, PORT_ArenaZNew failed"
argument_list|)
expr_stmt|;
name|PORT_FreeArena
argument_list|(
name|arena
argument_list|,
name|PR_FALSE
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|key
operator|->
name|arena
operator|=
name|arena
expr_stmt|;
name|key
operator|->
name|keyType
operator|=
name|ktype
expr_stmt|;
name|key
operator|->
name|pkcs11Slot
operator|=
name|NULL
expr_stmt|;
name|key
operator|->
name|pkcs11ID
operator|=
name|CK_INVALID_HANDLE
expr_stmt|;
return|return
name|key
return|;
block|}
end_function

begin_function
specifier|static
name|SECKEYPublicKey
modifier|*
name|nss_buf2ecdsa
parameter_list|(
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|algo
parameter_list|)
block|{
name|SECKEYPublicKey
modifier|*
name|pk
decl_stmt|;
name|SECItem
name|pub
init|=
block|{
name|siBuffer
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
name|SECItem
name|params
init|=
block|{
name|siBuffer
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
specifier|static
name|unsigned
name|char
name|param256
index|[]
init|=
block|{
comment|/* OBJECTIDENTIFIER 1.2.840.10045.3.1.7 (P-256) 		 * {iso(1) member-body(2) us(840) ansi-x962(10045) curves(3) prime(1) prime256v1(7)} */
literal|0x06
block|,
literal|0x08
block|,
literal|0x2a
block|,
literal|0x86
block|,
literal|0x48
block|,
literal|0xce
block|,
literal|0x3d
block|,
literal|0x03
block|,
literal|0x01
block|,
literal|0x07
block|}
decl_stmt|;
specifier|static
name|unsigned
name|char
name|param384
index|[]
init|=
block|{
comment|/* OBJECTIDENTIFIER 1.3.132.0.34 (P-384) 		 * {iso(1) identified-organization(3) certicom(132) curve(0) ansip384r1(34)} */
literal|0x06
block|,
literal|0x05
block|,
literal|0x2b
block|,
literal|0x81
block|,
literal|0x04
block|,
literal|0x00
block|,
literal|0x22
block|}
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|256
operator|+
literal|2
index|]
decl_stmt|;
comment|/* sufficient for 2*384/8+1 */
comment|/* check length, which uncompressed must be 2 bignums */
if|if
condition|(
name|algo
operator|==
name|LDNS_ECDSAP256SHA256
condition|)
block|{
if|if
condition|(
name|len
operator|!=
literal|2
operator|*
literal|256
operator|/
literal|8
condition|)
return|return
name|NULL
return|;
comment|/* ECCurve_X9_62_PRIME_256V1 */
block|}
elseif|else
if|if
condition|(
name|algo
operator|==
name|LDNS_ECDSAP384SHA384
condition|)
block|{
if|if
condition|(
name|len
operator|!=
literal|2
operator|*
literal|384
operator|/
literal|8
condition|)
return|return
name|NULL
return|;
comment|/* ECCurve_X9_62_PRIME_384R1 */
block|}
else|else
return|return
name|NULL
return|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0x04
expr_stmt|;
comment|/* POINT_FORM_UNCOMPRESSED */
name|memmove
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
name|key
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|pub
operator|.
name|data
operator|=
name|buf
expr_stmt|;
name|pub
operator|.
name|len
operator|=
name|len
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|algo
operator|==
name|LDNS_ECDSAP256SHA256
condition|)
block|{
name|params
operator|.
name|data
operator|=
name|param256
expr_stmt|;
name|params
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
name|param256
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|params
operator|.
name|data
operator|=
name|param384
expr_stmt|;
name|params
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
name|param384
argument_list|)
expr_stmt|;
block|}
name|pk
operator|=
name|nss_key_create
argument_list|(
name|ecKey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pk
condition|)
return|return
name|NULL
return|;
name|pk
operator|->
name|u
operator|.
name|ec
operator|.
name|size
operator|=
operator|(
name|len
operator|/
literal|2
operator|)
operator|*
literal|8
expr_stmt|;
if|if
condition|(
name|SECITEM_CopyItem
argument_list|(
name|pk
operator|->
name|arena
argument_list|,
operator|&
name|pk
operator|->
name|u
operator|.
name|ec
operator|.
name|publicValue
argument_list|,
operator|&
name|pub
argument_list|)
condition|)
block|{
name|SECKEY_DestroyPublicKey
argument_list|(
name|pk
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|SECITEM_CopyItem
argument_list|(
name|pk
operator|->
name|arena
argument_list|,
operator|&
name|pk
operator|->
name|u
operator|.
name|ec
operator|.
name|DEREncodedParams
argument_list|,
operator|&
name|params
argument_list|)
condition|)
block|{
name|SECKEY_DestroyPublicKey
argument_list|(
name|pk
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|pk
return|;
block|}
end_function

begin_function
specifier|static
name|SECKEYPublicKey
modifier|*
name|nss_buf2dsa
parameter_list|(
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|SECKEYPublicKey
modifier|*
name|pk
decl_stmt|;
name|uint8_t
name|T
decl_stmt|;
name|uint16_t
name|length
decl_stmt|;
name|uint16_t
name|offset
decl_stmt|;
name|SECItem
name|Q
init|=
block|{
name|siBuffer
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
name|SECItem
name|P
init|=
block|{
name|siBuffer
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
name|SECItem
name|G
init|=
block|{
name|siBuffer
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
name|SECItem
name|Y
init|=
block|{
name|siBuffer
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|T
operator|=
operator|(
name|uint8_t
operator|)
name|key
index|[
literal|0
index|]
expr_stmt|;
name|length
operator|=
operator|(
literal|64
operator|+
name|T
operator|*
literal|8
operator|)
expr_stmt|;
name|offset
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|T
operator|>
literal|8
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|len
operator|<
operator|(
name|size_t
operator|)
literal|1
operator|+
name|SHA1_LENGTH
operator|+
literal|3
operator|*
name|length
condition|)
return|return
name|NULL
return|;
name|Q
operator|.
name|data
operator|=
name|key
operator|+
name|offset
expr_stmt|;
name|Q
operator|.
name|len
operator|=
name|SHA1_LENGTH
expr_stmt|;
name|offset
operator|+=
name|SHA1_LENGTH
expr_stmt|;
name|P
operator|.
name|data
operator|=
name|key
operator|+
name|offset
expr_stmt|;
name|P
operator|.
name|len
operator|=
name|length
expr_stmt|;
name|offset
operator|+=
name|length
expr_stmt|;
name|G
operator|.
name|data
operator|=
name|key
operator|+
name|offset
expr_stmt|;
name|G
operator|.
name|len
operator|=
name|length
expr_stmt|;
name|offset
operator|+=
name|length
expr_stmt|;
name|Y
operator|.
name|data
operator|=
name|key
operator|+
name|offset
expr_stmt|;
name|Y
operator|.
name|len
operator|=
name|length
expr_stmt|;
name|offset
operator|+=
name|length
expr_stmt|;
name|pk
operator|=
name|nss_key_create
argument_list|(
name|dsaKey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pk
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|SECITEM_CopyItem
argument_list|(
name|pk
operator|->
name|arena
argument_list|,
operator|&
name|pk
operator|->
name|u
operator|.
name|dsa
operator|.
name|params
operator|.
name|prime
argument_list|,
operator|&
name|P
argument_list|)
condition|)
block|{
name|SECKEY_DestroyPublicKey
argument_list|(
name|pk
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|SECITEM_CopyItem
argument_list|(
name|pk
operator|->
name|arena
argument_list|,
operator|&
name|pk
operator|->
name|u
operator|.
name|dsa
operator|.
name|params
operator|.
name|subPrime
argument_list|,
operator|&
name|Q
argument_list|)
condition|)
block|{
name|SECKEY_DestroyPublicKey
argument_list|(
name|pk
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|SECITEM_CopyItem
argument_list|(
name|pk
operator|->
name|arena
argument_list|,
operator|&
name|pk
operator|->
name|u
operator|.
name|dsa
operator|.
name|params
operator|.
name|base
argument_list|,
operator|&
name|G
argument_list|)
condition|)
block|{
name|SECKEY_DestroyPublicKey
argument_list|(
name|pk
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|SECITEM_CopyItem
argument_list|(
name|pk
operator|->
name|arena
argument_list|,
operator|&
name|pk
operator|->
name|u
operator|.
name|dsa
operator|.
name|publicValue
argument_list|,
operator|&
name|Y
argument_list|)
condition|)
block|{
name|SECKEY_DestroyPublicKey
argument_list|(
name|pk
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|pk
return|;
block|}
end_function

begin_function
specifier|static
name|SECKEYPublicKey
modifier|*
name|nss_buf2rsa
parameter_list|(
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|SECKEYPublicKey
modifier|*
name|pk
decl_stmt|;
name|uint16_t
name|exp
decl_stmt|;
name|uint16_t
name|offset
decl_stmt|;
name|uint16_t
name|int16
decl_stmt|;
name|SECItem
name|modulus
init|=
block|{
name|siBuffer
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
name|SECItem
name|exponent
init|=
block|{
name|siBuffer
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|key
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|<
literal|3
condition|)
return|return
name|NULL
return|;
comment|/* the exponent is too large so it's places further */
name|memmove
argument_list|(
operator|&
name|int16
argument_list|,
name|key
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|exp
operator|=
name|ntohs
argument_list|(
name|int16
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|exp
operator|=
name|key
index|[
literal|0
index|]
expr_stmt|;
name|offset
operator|=
literal|1
expr_stmt|;
block|}
comment|/* key length at least one */
if|if
condition|(
name|len
operator|<
operator|(
name|size_t
operator|)
name|offset
operator|+
name|exp
operator|+
literal|1
condition|)
return|return
name|NULL
return|;
name|exponent
operator|.
name|data
operator|=
name|key
operator|+
name|offset
expr_stmt|;
name|exponent
operator|.
name|len
operator|=
name|exp
expr_stmt|;
name|offset
operator|+=
name|exp
expr_stmt|;
name|modulus
operator|.
name|data
operator|=
name|key
operator|+
name|offset
expr_stmt|;
name|modulus
operator|.
name|len
operator|=
operator|(
name|len
operator|-
name|offset
operator|)
expr_stmt|;
name|pk
operator|=
name|nss_key_create
argument_list|(
name|rsaKey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pk
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|SECITEM_CopyItem
argument_list|(
name|pk
operator|->
name|arena
argument_list|,
operator|&
name|pk
operator|->
name|u
operator|.
name|rsa
operator|.
name|modulus
argument_list|,
operator|&
name|modulus
argument_list|)
condition|)
block|{
name|SECKEY_DestroyPublicKey
argument_list|(
name|pk
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|SECITEM_CopyItem
argument_list|(
name|pk
operator|->
name|arena
argument_list|,
operator|&
name|pk
operator|->
name|u
operator|.
name|rsa
operator|.
name|publicExponent
argument_list|,
operator|&
name|exponent
argument_list|)
condition|)
block|{
name|SECKEY_DestroyPublicKey
argument_list|(
name|pk
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|pk
return|;
block|}
end_function

begin_comment
comment|/**  * Setup key and digest for verification. Adjust sig if necessary.  *  * @param algo: key algorithm  * @param evp_key: EVP PKEY public key to create.  * @param digest_type: digest type to use  * @param key: key to setup for.  * @param keylen: length of key.  * @param prefix: if returned, the ASN prefix for the hashblob.  * @param prefixlen: length of the prefix.  * @return false on failure.  */
end_comment

begin_function
specifier|static
name|int
name|nss_setup_key_digest
parameter_list|(
name|int
name|algo
parameter_list|,
name|SECKEYPublicKey
modifier|*
modifier|*
name|pubkey
parameter_list|,
name|HASH_HashType
modifier|*
name|htype
parameter_list|,
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|size_t
name|keylen
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|prefix
parameter_list|,
name|size_t
modifier|*
name|prefixlen
parameter_list|)
block|{
comment|/* uses libNSS */
comment|/* hash prefix for md5, RFC2537 */
specifier|static
name|unsigned
name|char
name|p_md5
index|[]
init|=
block|{
literal|0x30
block|,
literal|0x20
block|,
literal|0x30
block|,
literal|0x0c
block|,
literal|0x06
block|,
literal|0x08
block|,
literal|0x2a
block|,
literal|0x86
block|,
literal|0x48
block|,
literal|0x86
block|,
literal|0xf7
block|,
literal|0x0d
block|,
literal|0x02
block|,
literal|0x05
block|,
literal|0x05
block|,
literal|0x00
block|,
literal|0x04
block|,
literal|0x10
block|}
decl_stmt|;
comment|/* hash prefix to prepend to hash output, from RFC3110 */
specifier|static
name|unsigned
name|char
name|p_sha1
index|[]
init|=
block|{
literal|0x30
block|,
literal|0x21
block|,
literal|0x30
block|,
literal|0x09
block|,
literal|0x06
block|,
literal|0x05
block|,
literal|0x2B
block|,
literal|0x0E
block|,
literal|0x03
block|,
literal|0x02
block|,
literal|0x1A
block|,
literal|0x05
block|,
literal|0x00
block|,
literal|0x04
block|,
literal|0x14
block|}
decl_stmt|;
comment|/* from RFC5702 */
specifier|static
name|unsigned
name|char
name|p_sha256
index|[]
init|=
block|{
literal|0x30
block|,
literal|0x31
block|,
literal|0x30
block|,
literal|0x0d
block|,
literal|0x06
block|,
literal|0x09
block|,
literal|0x60
block|,
literal|0x86
block|,
literal|0x48
block|,
literal|0x01
block|,
literal|0x65
block|,
literal|0x03
block|,
literal|0x04
block|,
literal|0x02
block|,
literal|0x01
block|,
literal|0x05
block|,
literal|0x00
block|,
literal|0x04
block|,
literal|0x20
block|}
decl_stmt|;
specifier|static
name|unsigned
name|char
name|p_sha512
index|[]
init|=
block|{
literal|0x30
block|,
literal|0x51
block|,
literal|0x30
block|,
literal|0x0d
block|,
literal|0x06
block|,
literal|0x09
block|,
literal|0x60
block|,
literal|0x86
block|,
literal|0x48
block|,
literal|0x01
block|,
literal|0x65
block|,
literal|0x03
block|,
literal|0x04
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x05
block|,
literal|0x00
block|,
literal|0x04
block|,
literal|0x40
block|}
decl_stmt|;
comment|/* from RFC6234 */
comment|/* for future RSASHA384 ..  	static unsigned char p_sha384[] = {0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 	0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30}; 	*/
switch|switch
condition|(
name|algo
condition|)
block|{
case|case
name|LDNS_DSA
case|:
case|case
name|LDNS_DSA_NSEC3
case|:
operator|*
name|pubkey
operator|=
name|nss_buf2dsa
argument_list|(
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pubkey
condition|)
block|{
name|log_err
argument_list|(
literal|"verify: malloc failure in crypto"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|htype
operator|=
name|HASH_AlgSHA1
expr_stmt|;
comment|/* no prefix for DSA verification */
break|break;
case|case
name|LDNS_RSASHA1
case|:
case|case
name|LDNS_RSASHA1_NSEC3
case|:
ifdef|#
directive|ifdef
name|USE_SHA2
case|case
name|LDNS_RSASHA256
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_SHA2
case|case
name|LDNS_RSASHA512
case|:
endif|#
directive|endif
operator|*
name|pubkey
operator|=
name|nss_buf2rsa
argument_list|(
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pubkey
condition|)
block|{
name|log_err
argument_list|(
literal|"verify: malloc failure in crypto"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* select SHA version */
ifdef|#
directive|ifdef
name|USE_SHA2
if|if
condition|(
name|algo
operator|==
name|LDNS_RSASHA256
condition|)
block|{
operator|*
name|htype
operator|=
name|HASH_AlgSHA256
expr_stmt|;
operator|*
name|prefix
operator|=
name|p_sha256
expr_stmt|;
operator|*
name|prefixlen
operator|=
sizeof|sizeof
argument_list|(
name|p_sha256
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_SHA2
if|if
condition|(
name|algo
operator|==
name|LDNS_RSASHA512
condition|)
block|{
operator|*
name|htype
operator|=
name|HASH_AlgSHA512
expr_stmt|;
operator|*
name|prefix
operator|=
name|p_sha512
expr_stmt|;
operator|*
name|prefixlen
operator|=
sizeof|sizeof
argument_list|(
name|p_sha512
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
operator|*
name|htype
operator|=
name|HASH_AlgSHA1
expr_stmt|;
operator|*
name|prefix
operator|=
name|p_sha1
expr_stmt|;
operator|*
name|prefixlen
operator|=
sizeof|sizeof
argument_list|(
name|p_sha1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LDNS_RSAMD5
case|:
operator|*
name|pubkey
operator|=
name|nss_buf2rsa
argument_list|(
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pubkey
condition|)
block|{
name|log_err
argument_list|(
literal|"verify: malloc failure in crypto"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|htype
operator|=
name|HASH_AlgMD5
expr_stmt|;
operator|*
name|prefix
operator|=
name|p_md5
expr_stmt|;
operator|*
name|prefixlen
operator|=
sizeof|sizeof
argument_list|(
name|p_md5
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|USE_ECDSA
case|case
name|LDNS_ECDSAP256SHA256
case|:
operator|*
name|pubkey
operator|=
name|nss_buf2ecdsa
argument_list|(
name|key
argument_list|,
name|keylen
argument_list|,
name|LDNS_ECDSAP256SHA256
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pubkey
condition|)
block|{
name|log_err
argument_list|(
literal|"verify: malloc failure in crypto"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|htype
operator|=
name|HASH_AlgSHA256
expr_stmt|;
comment|/* no prefix for DSA verification */
break|break;
case|case
name|LDNS_ECDSAP384SHA384
case|:
operator|*
name|pubkey
operator|=
name|nss_buf2ecdsa
argument_list|(
name|key
argument_list|,
name|keylen
argument_list|,
name|LDNS_ECDSAP384SHA384
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pubkey
condition|)
block|{
name|log_err
argument_list|(
literal|"verify: malloc failure in crypto"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|htype
operator|=
name|HASH_AlgSHA384
expr_stmt|;
comment|/* no prefix for DSA verification */
break|break;
endif|#
directive|endif
comment|/* USE_ECDSA */
case|case
name|LDNS_ECC_GOST
case|:
default|default:
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: unknown algorithm %d"
argument_list|,
name|algo
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Check a canonical sig+rrset and signature against a dnskey  * @param buf: buffer with data to verify, the first rrsig part and the  *	canonicalized rrset.  * @param algo: DNSKEY algorithm.  * @param sigblock: signature rdata field from RRSIG  * @param sigblock_len: length of sigblock data.  * @param key: public key data from DNSKEY RR.  * @param keylen: length of keydata.  * @param reason: bogus reason in more detail.  * @return secure if verification succeeded, bogus on crypto failure,  *	unchecked on format errors and alloc failures.  */
end_comment

begin_function
name|enum
name|sec_status
name|verify_canonrrset
parameter_list|(
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|int
name|algo
parameter_list|,
name|unsigned
name|char
modifier|*
name|sigblock
parameter_list|,
name|unsigned
name|int
name|sigblock_len
parameter_list|,
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|unsigned
name|int
name|keylen
parameter_list|,
name|char
modifier|*
modifier|*
name|reason
parameter_list|)
block|{
comment|/* uses libNSS */
comment|/* large enough for the different hashes */
name|unsigned
name|char
name|hash
index|[
name|HASH_LENGTH_MAX
index|]
decl_stmt|;
name|unsigned
name|char
name|hash2
index|[
name|HASH_LENGTH_MAX
operator|*
literal|2
index|]
decl_stmt|;
name|HASH_HashType
name|htype
init|=
literal|0
decl_stmt|;
name|SECKEYPublicKey
modifier|*
name|pubkey
init|=
name|NULL
decl_stmt|;
name|SECItem
name|secsig
init|=
block|{
name|siBuffer
block|,
name|sigblock
block|,
name|sigblock_len
block|}
decl_stmt|;
name|SECItem
name|sechash
init|=
block|{
name|siBuffer
block|,
name|hash
block|,
literal|0
block|}
decl_stmt|;
name|SECStatus
name|res
decl_stmt|;
name|unsigned
name|char
modifier|*
name|prefix
init|=
name|NULL
decl_stmt|;
comment|/* prefix for hash, RFC3110, RFC5702 */
name|size_t
name|prefixlen
init|=
literal|0
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|nss_setup_key_digest
argument_list|(
name|algo
argument_list|,
operator|&
name|pubkey
argument_list|,
operator|&
name|htype
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
operator|&
name|prefix
argument_list|,
operator|&
name|prefixlen
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: failed to setup key"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"use of key for crypto failed"
expr_stmt|;
name|SECKEY_DestroyPublicKey
argument_list|(
name|pubkey
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
comment|/* need to convert DSA, ECDSA signatures? */
if|if
condition|(
operator|(
name|algo
operator|==
name|LDNS_DSA
operator|||
name|algo
operator|==
name|LDNS_DSA_NSEC3
operator|)
condition|)
block|{
if|if
condition|(
name|sigblock_len
operator|==
literal|1
operator|+
literal|2
operator|*
name|SHA1_LENGTH
condition|)
block|{
name|secsig
operator|.
name|data
operator|++
expr_stmt|;
name|secsig
operator|.
name|len
operator|--
expr_stmt|;
block|}
else|else
block|{
name|SECItem
modifier|*
name|p
init|=
name|DSAU_DecodeDerSig
argument_list|(
operator|&
name|secsig
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: failed DER decode"
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"signature DER decode failed"
expr_stmt|;
name|SECKEY_DestroyPublicKey
argument_list|(
name|pubkey
argument_list|)
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
if|if
condition|(
name|SECITEM_CopyItem
argument_list|(
name|pubkey
operator|->
name|arena
argument_list|,
operator|&
name|secsig
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|log_err
argument_list|(
literal|"alloc failure in DER decode"
argument_list|)
expr_stmt|;
name|SECKEY_DestroyPublicKey
argument_list|(
name|pubkey
argument_list|)
expr_stmt|;
name|SECITEM_FreeItem
argument_list|(
name|p
argument_list|,
name|PR_TRUE
argument_list|)
expr_stmt|;
return|return
name|sec_status_unchecked
return|;
block|}
name|SECITEM_FreeItem
argument_list|(
name|p
argument_list|,
name|PR_TRUE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* do the signature cryptography work */
comment|/* hash the data */
name|sechash
operator|.
name|len
operator|=
name|HASH_ResultLen
argument_list|(
name|htype
argument_list|)
expr_stmt|;
if|if
condition|(
name|sechash
operator|.
name|len
operator|>
sizeof|sizeof
argument_list|(
name|hash
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: hash too large for buffer"
argument_list|)
expr_stmt|;
name|SECKEY_DestroyPublicKey
argument_list|(
name|pubkey
argument_list|)
expr_stmt|;
return|return
name|sec_status_unchecked
return|;
block|}
if|if
condition|(
name|HASH_HashBuf
argument_list|(
name|htype
argument_list|,
name|hash
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sldns_buffer_begin
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|sldns_buffer_limit
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|!=
name|SECSuccess
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: HASH_HashBuf failed"
argument_list|)
expr_stmt|;
name|SECKEY_DestroyPublicKey
argument_list|(
name|pubkey
argument_list|)
expr_stmt|;
return|return
name|sec_status_unchecked
return|;
block|}
if|if
condition|(
name|prefix
condition|)
block|{
name|int
name|hashlen
init|=
name|sechash
operator|.
name|len
decl_stmt|;
if|if
condition|(
name|prefixlen
operator|+
name|hashlen
operator|>
sizeof|sizeof
argument_list|(
name|hash2
argument_list|)
condition|)
block|{
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: hashprefix too large"
argument_list|)
expr_stmt|;
name|SECKEY_DestroyPublicKey
argument_list|(
name|pubkey
argument_list|)
expr_stmt|;
return|return
name|sec_status_unchecked
return|;
block|}
name|sechash
operator|.
name|data
operator|=
name|hash2
expr_stmt|;
name|sechash
operator|.
name|len
operator|=
name|prefixlen
operator|+
name|hashlen
expr_stmt|;
name|memcpy
argument_list|(
name|sechash
operator|.
name|data
argument_list|,
name|prefix
argument_list|,
name|prefixlen
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|sechash
operator|.
name|data
operator|+
name|prefixlen
argument_list|,
name|hash
argument_list|,
name|hashlen
argument_list|)
expr_stmt|;
block|}
comment|/* verify the signature */
name|res
operator|=
name|PK11_Verify
argument_list|(
name|pubkey
argument_list|,
operator|&
name|secsig
argument_list|,
operator|&
name|sechash
argument_list|,
name|NULL
comment|/*wincx*/
argument_list|)
expr_stmt|;
name|SECKEY_DestroyPublicKey
argument_list|(
name|pubkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|SECSuccess
condition|)
block|{
return|return
name|sec_status_secure
return|;
block|}
name|err
operator|=
name|PORT_GetError
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|SEC_ERROR_BAD_SIGNATURE
condition|)
block|{
comment|/* failed to verify */
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: PK11_Verify failed: %s"
argument_list|,
name|PORT_ErrorToString
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if it is not supported, like ECC is removed, we get, 		 * SEC_ERROR_NO_MODULE */
if|if
condition|(
name|err
operator|==
name|SEC_ERROR_NO_MODULE
condition|)
return|return
name|sec_status_unchecked
return|;
comment|/* but other errors are commonly returned 		 * for a bad signature from NSS.  Thus we return bogus, 		 * not unchecked */
operator|*
name|reason
operator|=
literal|"signature crypto failed"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
name|verbose
argument_list|(
name|VERB_QUERY
argument_list|,
literal|"verify: signature mismatch: %s"
argument_list|,
name|PORT_ErrorToString
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|reason
operator|=
literal|"signature crypto failed"
expr_stmt|;
return|return
name|sec_status_bogus
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SSL or HAVE_NSS */
end_comment

end_unit

