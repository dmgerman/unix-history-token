begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * validator/val_neg.c - validator aggressive negative caching functions.  *  * Copyright (c) 2008, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains helper functions for the validator module.  * The functions help with aggressive negative caching.  * This creates new denials of existance, and proofs for absence of types  * from cached NSEC records.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OPENSSL_SSL_H
end_ifdef

begin_include
include|#
directive|include
file|"openssl/ssl.h"
end_include

begin_define
define|#
directive|define
name|NSEC3_SHA_LEN
value|SHA_DIGEST_LENGTH
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NSEC3_SHA_LEN
value|20
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"validator/val_neg.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_nsec.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_nsec3.h"
end_include

begin_include
include|#
directive|include
file|"validator/val_utils.h"
end_include

begin_include
include|#
directive|include
file|"util/data/dname.h"
end_include

begin_include
include|#
directive|include
file|"util/data/msgreply.h"
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/rrset.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/dns.h"
end_include

begin_include
include|#
directive|include
file|"ldns/rrdef.h"
end_include

begin_include
include|#
directive|include
file|"ldns/sbuffer.h"
end_include

begin_function
name|int
name|val_neg_data_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|val_neg_data
modifier|*
name|x
init|=
operator|(
expr|struct
name|val_neg_data
operator|*
operator|)
name|a
decl_stmt|;
name|struct
name|val_neg_data
modifier|*
name|y
init|=
operator|(
expr|struct
name|val_neg_data
operator|*
operator|)
name|b
decl_stmt|;
name|int
name|m
decl_stmt|;
return|return
name|dname_canon_lab_cmp
argument_list|(
name|x
operator|->
name|name
argument_list|,
name|x
operator|->
name|labs
argument_list|,
name|y
operator|->
name|name
argument_list|,
name|y
operator|->
name|labs
argument_list|,
operator|&
name|m
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|val_neg_zone_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|val_neg_zone
modifier|*
name|x
init|=
operator|(
expr|struct
name|val_neg_zone
operator|*
operator|)
name|a
decl_stmt|;
name|struct
name|val_neg_zone
modifier|*
name|y
init|=
operator|(
expr|struct
name|val_neg_zone
operator|*
operator|)
name|b
decl_stmt|;
name|int
name|m
decl_stmt|;
if|if
condition|(
name|x
operator|->
name|dclass
operator|!=
name|y
operator|->
name|dclass
condition|)
block|{
if|if
condition|(
name|x
operator|->
name|dclass
operator|<
name|y
operator|->
name|dclass
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
return|return
name|dname_canon_lab_cmp
argument_list|(
name|x
operator|->
name|name
argument_list|,
name|x
operator|->
name|labs
argument_list|,
name|y
operator|->
name|name
argument_list|,
name|y
operator|->
name|labs
argument_list|,
operator|&
name|m
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|val_neg_cache
modifier|*
name|val_neg_create
parameter_list|(
name|struct
name|config_file
modifier|*
name|cfg
parameter_list|,
name|size_t
name|maxiter
parameter_list|)
block|{
name|struct
name|val_neg_cache
modifier|*
name|neg
init|=
operator|(
expr|struct
name|val_neg_cache
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|neg
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|neg
condition|)
block|{
name|log_err
argument_list|(
literal|"Could not create neg cache: out of memory"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|neg
operator|->
name|nsec3_max_iter
operator|=
name|maxiter
expr_stmt|;
name|neg
operator|->
name|max
operator|=
literal|1024
operator|*
literal|1024
expr_stmt|;
comment|/* 1 M is thousands of entries */
if|if
condition|(
name|cfg
condition|)
name|neg
operator|->
name|max
operator|=
name|cfg
operator|->
name|neg_cache_size
expr_stmt|;
name|rbtree_init
argument_list|(
operator|&
name|neg
operator|->
name|tree
argument_list|,
operator|&
name|val_neg_zone_compare
argument_list|)
expr_stmt|;
name|lock_basic_init
argument_list|(
operator|&
name|neg
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lock_protect
argument_list|(
operator|&
name|neg
operator|->
name|lock
argument_list|,
name|neg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|neg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|neg
return|;
block|}
end_function

begin_function
name|size_t
name|val_neg_get_mem
parameter_list|(
name|struct
name|val_neg_cache
modifier|*
name|neg
parameter_list|)
block|{
name|size_t
name|result
decl_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|neg
operator|->
name|lock
argument_list|)
expr_stmt|;
name|result
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|neg
argument_list|)
operator|+
name|neg
operator|->
name|use
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|neg
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/** clear datas on cache deletion */
end_comment

begin_function
specifier|static
name|void
name|neg_clear_datas
parameter_list|(
name|rbnode_t
modifier|*
name|n
parameter_list|,
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|struct
name|val_neg_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|val_neg_data
operator|*
operator|)
name|n
decl_stmt|;
name|free
argument_list|(
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** clear zones on cache deletion */
end_comment

begin_function
specifier|static
name|void
name|neg_clear_zones
parameter_list|(
name|rbnode_t
modifier|*
name|n
parameter_list|,
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|struct
name|val_neg_zone
modifier|*
name|z
init|=
operator|(
expr|struct
name|val_neg_zone
operator|*
operator|)
name|n
decl_stmt|;
comment|/* delete all the rrset entries in the tree */
name|traverse_postorder
argument_list|(
operator|&
name|z
operator|->
name|tree
argument_list|,
operator|&
name|neg_clear_datas
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|z
operator|->
name|nsec3_salt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|z
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|z
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|neg_cache_delete
parameter_list|(
name|struct
name|val_neg_cache
modifier|*
name|neg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|neg
condition|)
return|return;
name|lock_basic_destroy
argument_list|(
operator|&
name|neg
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* delete all the zones in the tree */
name|traverse_postorder
argument_list|(
operator|&
name|neg
operator|->
name|tree
argument_list|,
operator|&
name|neg_clear_zones
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|neg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Put data element at the front of the LRU list.  * @param neg: negative cache with LRU start and end.  * @param data: this data is fronted.  */
end_comment

begin_function
specifier|static
name|void
name|neg_lru_front
parameter_list|(
name|struct
name|val_neg_cache
modifier|*
name|neg
parameter_list|,
name|struct
name|val_neg_data
modifier|*
name|data
parameter_list|)
block|{
name|data
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|next
operator|=
name|neg
operator|->
name|first
expr_stmt|;
if|if
condition|(
operator|!
name|neg
operator|->
name|first
condition|)
name|neg
operator|->
name|last
operator|=
name|data
expr_stmt|;
else|else
name|neg
operator|->
name|first
operator|->
name|prev
operator|=
name|data
expr_stmt|;
name|neg
operator|->
name|first
operator|=
name|data
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Remove data element from LRU list.  * @param neg: negative cache with LRU start and end.  * @param data: this data is removed from the list.  */
end_comment

begin_function
specifier|static
name|void
name|neg_lru_remove
parameter_list|(
name|struct
name|val_neg_cache
modifier|*
name|neg
parameter_list|,
name|struct
name|val_neg_data
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|data
operator|->
name|prev
condition|)
name|data
operator|->
name|prev
operator|->
name|next
operator|=
name|data
operator|->
name|next
expr_stmt|;
else|else
name|neg
operator|->
name|first
operator|=
name|data
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|next
condition|)
name|data
operator|->
name|next
operator|->
name|prev
operator|=
name|data
operator|->
name|prev
expr_stmt|;
else|else
name|neg
operator|->
name|last
operator|=
name|data
operator|->
name|prev
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Touch LRU for data element, put it at the start of the LRU list.  * @param neg: negative cache with LRU start and end.  * @param data: this data is used.  */
end_comment

begin_function
specifier|static
name|void
name|neg_lru_touch
parameter_list|(
name|struct
name|val_neg_cache
modifier|*
name|neg
parameter_list|,
name|struct
name|val_neg_data
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|data
operator|==
name|neg
operator|->
name|first
condition|)
return|return;
comment|/* nothing to do */
comment|/* remove from current lru position */
name|neg_lru_remove
argument_list|(
name|neg
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* add at front */
name|neg_lru_front
argument_list|(
name|neg
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Delete a zone element from the negative cache.  * May delete other zone elements to keep tree coherent, or  * only mark the element as 'not in use'.  * @param neg: negative cache.  * @param z: zone element to delete.  */
end_comment

begin_function
specifier|static
name|void
name|neg_delete_zone
parameter_list|(
name|struct
name|val_neg_cache
modifier|*
name|neg
parameter_list|,
name|struct
name|val_neg_zone
modifier|*
name|z
parameter_list|)
block|{
name|struct
name|val_neg_zone
modifier|*
name|p
decl_stmt|,
modifier|*
name|np
decl_stmt|;
if|if
condition|(
operator|!
name|z
condition|)
return|return;
name|log_assert
argument_list|(
name|z
operator|->
name|in_use
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|z
operator|->
name|count
operator|>
literal|0
argument_list|)
expr_stmt|;
name|z
operator|->
name|in_use
operator|=
literal|0
expr_stmt|;
comment|/* go up the tree and reduce counts */
name|p
operator|=
name|z
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|log_assert
argument_list|(
name|p
operator|->
name|count
operator|>
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|count
operator|--
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|parent
expr_stmt|;
block|}
comment|/* remove zones with zero count */
name|p
operator|=
name|z
expr_stmt|;
while|while
condition|(
name|p
operator|&&
name|p
operator|->
name|count
operator|==
literal|0
condition|)
block|{
name|np
operator|=
name|p
operator|->
name|parent
expr_stmt|;
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
operator|&
name|neg
operator|->
name|tree
argument_list|,
operator|&
name|p
operator|->
name|node
argument_list|)
expr_stmt|;
name|neg
operator|->
name|use
operator|-=
name|p
operator|->
name|len
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|nsec3_salt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|np
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|neg_delete_data
parameter_list|(
name|struct
name|val_neg_cache
modifier|*
name|neg
parameter_list|,
name|struct
name|val_neg_data
modifier|*
name|el
parameter_list|)
block|{
name|struct
name|val_neg_zone
modifier|*
name|z
decl_stmt|;
name|struct
name|val_neg_data
modifier|*
name|p
decl_stmt|,
modifier|*
name|np
decl_stmt|;
if|if
condition|(
operator|!
name|el
condition|)
return|return;
name|z
operator|=
name|el
operator|->
name|zone
expr_stmt|;
name|log_assert
argument_list|(
name|el
operator|->
name|in_use
argument_list|)
expr_stmt|;
name|log_assert
argument_list|(
name|el
operator|->
name|count
operator|>
literal|0
argument_list|)
expr_stmt|;
name|el
operator|->
name|in_use
operator|=
literal|0
expr_stmt|;
comment|/* remove it from the lru list */
name|neg_lru_remove
argument_list|(
name|neg
argument_list|,
name|el
argument_list|)
expr_stmt|;
comment|/* go up the tree and reduce counts */
name|p
operator|=
name|el
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|log_assert
argument_list|(
name|p
operator|->
name|count
operator|>
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|count
operator|--
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|parent
expr_stmt|;
block|}
comment|/* delete 0 count items from tree */
name|p
operator|=
name|el
expr_stmt|;
while|while
condition|(
name|p
operator|&&
name|p
operator|->
name|count
operator|==
literal|0
condition|)
block|{
name|np
operator|=
name|p
operator|->
name|parent
expr_stmt|;
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
operator|&
name|z
operator|->
name|tree
argument_list|,
operator|&
name|p
operator|->
name|node
argument_list|)
expr_stmt|;
name|neg
operator|->
name|use
operator|-=
name|p
operator|->
name|len
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|np
expr_stmt|;
block|}
comment|/* check if the zone is now unused */
if|if
condition|(
name|z
operator|->
name|tree
operator|.
name|count
operator|==
literal|0
condition|)
block|{
name|neg_delete_zone
argument_list|(
name|neg
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Create more space in negative cache  * The oldest elements are deleted until enough space is present.  * Empty zones are deleted.  * @param neg: negative cache.  * @param need: how many bytes are needed.  */
end_comment

begin_function
specifier|static
name|void
name|neg_make_space
parameter_list|(
name|struct
name|val_neg_cache
modifier|*
name|neg
parameter_list|,
name|size_t
name|need
parameter_list|)
block|{
comment|/* delete elements until enough space or its empty */
while|while
condition|(
name|neg
operator|->
name|last
operator|&&
name|neg
operator|->
name|max
operator|<
name|neg
operator|->
name|use
operator|+
name|need
condition|)
block|{
name|neg_delete_data
argument_list|(
name|neg
argument_list|,
name|neg
operator|->
name|last
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|val_neg_zone
modifier|*
name|neg_find_zone
parameter_list|(
name|struct
name|val_neg_cache
modifier|*
name|neg
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uint16_t
name|dclass
parameter_list|)
block|{
name|struct
name|val_neg_zone
name|lookfor
decl_stmt|;
name|struct
name|val_neg_zone
modifier|*
name|result
decl_stmt|;
name|lookfor
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|lookfor
expr_stmt|;
name|lookfor
operator|.
name|name
operator|=
name|nm
expr_stmt|;
name|lookfor
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|lookfor
operator|.
name|labs
operator|=
name|dname_count_labels
argument_list|(
name|lookfor
operator|.
name|name
argument_list|)
expr_stmt|;
name|lookfor
operator|.
name|dclass
operator|=
name|dclass
expr_stmt|;
name|result
operator|=
operator|(
expr|struct
name|val_neg_zone
operator|*
operator|)
name|rbtree_search
argument_list|(
operator|&
name|neg
operator|->
name|tree
argument_list|,
name|lookfor
operator|.
name|node
operator|.
name|key
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * Find the given data  * @param zone: negative zone  * @param nm: what to look for.  * @param len: length of nm  * @param labs: labels in nm  * @return data or NULL if not found.  */
end_comment

begin_function
specifier|static
name|struct
name|val_neg_data
modifier|*
name|neg_find_data
parameter_list|(
name|struct
name|val_neg_zone
modifier|*
name|zone
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|labs
parameter_list|)
block|{
name|struct
name|val_neg_data
name|lookfor
decl_stmt|;
name|struct
name|val_neg_data
modifier|*
name|result
decl_stmt|;
name|lookfor
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|lookfor
expr_stmt|;
name|lookfor
operator|.
name|name
operator|=
name|nm
expr_stmt|;
name|lookfor
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|lookfor
operator|.
name|labs
operator|=
name|labs
expr_stmt|;
name|result
operator|=
operator|(
expr|struct
name|val_neg_data
operator|*
operator|)
name|rbtree_search
argument_list|(
operator|&
name|zone
operator|->
name|tree
argument_list|,
name|lookfor
operator|.
name|node
operator|.
name|key
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * Calculate space needed for the data and all its parents  * @param rep: NSEC entries.  * @return size.  */
end_comment

begin_function
specifier|static
name|size_t
name|calc_data_need
parameter_list|(
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|)
block|{
name|uint8_t
modifier|*
name|d
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|len
decl_stmt|,
name|res
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|rep
operator|->
name|an_numrrsets
init|;
name|i
operator|<
name|rep
operator|->
name|an_numrrsets
operator|+
name|rep
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC
condition|)
block|{
name|d
operator|=
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|dname
expr_stmt|;
name|len
operator|=
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|dname_len
expr_stmt|;
name|res
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|val_neg_data
argument_list|)
operator|+
name|len
expr_stmt|;
while|while
condition|(
operator|!
name|dname_is_root
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|log_assert
argument_list|(
name|len
operator|>
literal|1
argument_list|)
expr_stmt|;
comment|/* not root label */
name|dname_remove_label
argument_list|(
operator|&
name|d
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|res
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|val_neg_data
argument_list|)
operator|+
name|len
expr_stmt|;
block|}
block|}
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/**  * Calculate space needed for zone and all its parents  * @param d: name of zone  * @param len: length of name  * @return size.  */
end_comment

begin_function
specifier|static
name|size_t
name|calc_zone_need
parameter_list|(
name|uint8_t
modifier|*
name|d
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|size_t
name|res
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|val_neg_zone
argument_list|)
operator|+
name|len
decl_stmt|;
while|while
condition|(
operator|!
name|dname_is_root
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|log_assert
argument_list|(
name|len
operator|>
literal|1
argument_list|)
expr_stmt|;
comment|/* not root label */
name|dname_remove_label
argument_list|(
operator|&
name|d
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|res
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|val_neg_zone
argument_list|)
operator|+
name|len
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/**  * Find closest existing parent zone of the given name.  * @param neg: negative cache.  * @param nm: name to look for  * @param nm_len: length of nm  * @param labs: labelcount of nm.  * @param qclass: class.  * @return the zone or NULL if none found.  */
end_comment

begin_function
specifier|static
name|struct
name|val_neg_zone
modifier|*
name|neg_closest_zone_parent
parameter_list|(
name|struct
name|val_neg_cache
modifier|*
name|neg
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|nm_len
parameter_list|,
name|int
name|labs
parameter_list|,
name|uint16_t
name|qclass
parameter_list|)
block|{
name|struct
name|val_neg_zone
name|key
decl_stmt|;
name|struct
name|val_neg_zone
modifier|*
name|result
decl_stmt|;
name|rbnode_t
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|key
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|key
operator|.
name|name
operator|=
name|nm
expr_stmt|;
name|key
operator|.
name|len
operator|=
name|nm_len
expr_stmt|;
name|key
operator|.
name|labs
operator|=
name|labs
expr_stmt|;
name|key
operator|.
name|dclass
operator|=
name|qclass
expr_stmt|;
if|if
condition|(
name|rbtree_find_less_equal
argument_list|(
operator|&
name|neg
operator|->
name|tree
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|res
argument_list|)
condition|)
block|{
comment|/* exact match */
name|result
operator|=
operator|(
expr|struct
name|val_neg_zone
operator|*
operator|)
name|res
expr_stmt|;
block|}
else|else
block|{
comment|/* smaller element (or no element) */
name|int
name|m
decl_stmt|;
name|result
operator|=
operator|(
expr|struct
name|val_neg_zone
operator|*
operator|)
name|res
expr_stmt|;
if|if
condition|(
operator|!
name|result
operator|||
name|result
operator|->
name|dclass
operator|!=
name|qclass
condition|)
return|return
name|NULL
return|;
comment|/* count number of labels matched */
operator|(
name|void
operator|)
name|dname_lab_cmp
argument_list|(
name|result
operator|->
name|name
argument_list|,
name|result
operator|->
name|labs
argument_list|,
name|key
operator|.
name|name
argument_list|,
name|key
operator|.
name|labs
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
condition|)
block|{
comment|/* go up until qname is subdomain of stub */
if|if
condition|(
name|result
operator|->
name|labs
operator|<=
name|m
condition|)
break|break;
name|result
operator|=
name|result
operator|->
name|parent
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * Find closest existing parent data for the given name.  * @param zone: to look in.  * @param nm: name to look for  * @param nm_len: length of nm  * @param labs: labelcount of nm.  * @return the data or NULL if none found.  */
end_comment

begin_function
specifier|static
name|struct
name|val_neg_data
modifier|*
name|neg_closest_data_parent
parameter_list|(
name|struct
name|val_neg_zone
modifier|*
name|zone
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|nm_len
parameter_list|,
name|int
name|labs
parameter_list|)
block|{
name|struct
name|val_neg_data
name|key
decl_stmt|;
name|struct
name|val_neg_data
modifier|*
name|result
decl_stmt|;
name|rbnode_t
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|key
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|key
operator|.
name|name
operator|=
name|nm
expr_stmt|;
name|key
operator|.
name|len
operator|=
name|nm_len
expr_stmt|;
name|key
operator|.
name|labs
operator|=
name|labs
expr_stmt|;
if|if
condition|(
name|rbtree_find_less_equal
argument_list|(
operator|&
name|zone
operator|->
name|tree
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|res
argument_list|)
condition|)
block|{
comment|/* exact match */
name|result
operator|=
operator|(
expr|struct
name|val_neg_data
operator|*
operator|)
name|res
expr_stmt|;
block|}
else|else
block|{
comment|/* smaller element (or no element) */
name|int
name|m
decl_stmt|;
name|result
operator|=
operator|(
expr|struct
name|val_neg_data
operator|*
operator|)
name|res
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
return|return
name|NULL
return|;
comment|/* count number of labels matched */
operator|(
name|void
operator|)
name|dname_lab_cmp
argument_list|(
name|result
operator|->
name|name
argument_list|,
name|result
operator|->
name|labs
argument_list|,
name|key
operator|.
name|name
argument_list|,
name|key
operator|.
name|labs
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
condition|)
block|{
comment|/* go up until qname is subdomain of stub */
if|if
condition|(
name|result
operator|->
name|labs
operator|<=
name|m
condition|)
break|break;
name|result
operator|=
name|result
operator|->
name|parent
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * Create a single zone node  * @param nm: name for zone (copied)  * @param nm_len: length of name  * @param labs: labels in name.  * @param dclass: class of zone, host order.  * @return new zone or NULL on failure  */
end_comment

begin_function
specifier|static
name|struct
name|val_neg_zone
modifier|*
name|neg_setup_zone_node
parameter_list|(
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|nm_len
parameter_list|,
name|int
name|labs
parameter_list|,
name|uint16_t
name|dclass
parameter_list|)
block|{
name|struct
name|val_neg_zone
modifier|*
name|zone
init|=
operator|(
expr|struct
name|val_neg_zone
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zone
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|zone
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|zone
operator|->
name|node
operator|.
name|key
operator|=
name|zone
expr_stmt|;
name|zone
operator|->
name|name
operator|=
name|memdup
argument_list|(
name|nm
argument_list|,
name|nm_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zone
operator|->
name|name
condition|)
block|{
name|free
argument_list|(
name|zone
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|zone
operator|->
name|len
operator|=
name|nm_len
expr_stmt|;
name|zone
operator|->
name|labs
operator|=
name|labs
expr_stmt|;
name|zone
operator|->
name|dclass
operator|=
name|dclass
expr_stmt|;
name|rbtree_init
argument_list|(
operator|&
name|zone
operator|->
name|tree
argument_list|,
operator|&
name|val_neg_data_compare
argument_list|)
expr_stmt|;
return|return
name|zone
return|;
block|}
end_function

begin_comment
comment|/**  * Create a linked list of parent zones, starting at longname ending on  * the parent (can be NULL, creates to the root).  * @param nm: name for lowest in chain  * @param nm_len: length of name  * @param labs: labels in name.  * @param dclass: class of zone.  * @param parent: NULL for to root, else so it fits under here.  * @return zone; a chain of zones and their parents up to the parent.  *  	or NULL on malloc failure  */
end_comment

begin_function
specifier|static
name|struct
name|val_neg_zone
modifier|*
name|neg_zone_chain
parameter_list|(
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|nm_len
parameter_list|,
name|int
name|labs
parameter_list|,
name|uint16_t
name|dclass
parameter_list|,
name|struct
name|val_neg_zone
modifier|*
name|parent
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|tolabs
init|=
name|parent
condition|?
name|parent
operator|->
name|labs
else|:
literal|0
decl_stmt|;
name|struct
name|val_neg_zone
modifier|*
name|zone
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|,
modifier|*
name|first
init|=
name|NULL
decl_stmt|;
comment|/* create the new subtree, i is labelcount of current creation */
comment|/* this creates a 'first' to z->parent=NULL list of zones */
for|for
control|(
name|i
operator|=
name|labs
init|;
name|i
operator|!=
name|tolabs
condition|;
name|i
operator|--
control|)
block|{
comment|/* create new item */
name|zone
operator|=
name|neg_setup_zone_node
argument_list|(
name|nm
argument_list|,
name|nm_len
argument_list|,
name|i
argument_list|,
name|dclass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zone
condition|)
block|{
comment|/* need to delete other allocations in this routine!*/
name|struct
name|val_neg_zone
modifier|*
name|p
init|=
name|first
decl_stmt|,
modifier|*
name|np
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|np
operator|=
name|p
operator|->
name|parent
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|np
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|i
operator|==
name|labs
condition|)
block|{
name|first
operator|=
name|zone
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|->
name|parent
operator|=
name|zone
expr_stmt|;
block|}
comment|/* prepare for next name */
name|prev
operator|=
name|zone
expr_stmt|;
name|dname_remove_label
argument_list|(
operator|&
name|nm
argument_list|,
operator|&
name|nm_len
argument_list|)
expr_stmt|;
block|}
return|return
name|first
return|;
block|}
end_function

begin_function
name|void
name|val_neg_zone_take_inuse
parameter_list|(
name|struct
name|val_neg_zone
modifier|*
name|zone
parameter_list|)
block|{
if|if
condition|(
operator|!
name|zone
operator|->
name|in_use
condition|)
block|{
name|struct
name|val_neg_zone
modifier|*
name|p
decl_stmt|;
name|zone
operator|->
name|in_use
operator|=
literal|1
expr_stmt|;
comment|/* increase usage count of all parents */
for|for
control|(
name|p
operator|=
name|zone
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|parent
control|)
block|{
name|p
operator|->
name|count
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|struct
name|val_neg_zone
modifier|*
name|neg_create_zone
parameter_list|(
name|struct
name|val_neg_cache
modifier|*
name|neg
parameter_list|,
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|nm_len
parameter_list|,
name|uint16_t
name|dclass
parameter_list|)
block|{
name|struct
name|val_neg_zone
modifier|*
name|zone
decl_stmt|;
name|struct
name|val_neg_zone
modifier|*
name|parent
decl_stmt|;
name|struct
name|val_neg_zone
modifier|*
name|p
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|int
name|labs
init|=
name|dname_count_labels
argument_list|(
name|nm
argument_list|)
decl_stmt|;
comment|/* find closest enclosing parent zone that (still) exists */
name|parent
operator|=
name|neg_closest_zone_parent
argument_list|(
name|neg
argument_list|,
name|nm
argument_list|,
name|nm_len
argument_list|,
name|labs
argument_list|,
name|dclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|&&
name|query_dname_compare
argument_list|(
name|parent
operator|->
name|name
argument_list|,
name|nm
argument_list|)
operator|==
literal|0
condition|)
return|return
name|parent
return|;
comment|/* already exists, weird */
comment|/* if parent exists, it is in use */
name|log_assert
argument_list|(
operator|!
name|parent
operator|||
name|parent
operator|->
name|count
operator|>
literal|0
argument_list|)
expr_stmt|;
name|zone
operator|=
name|neg_zone_chain
argument_list|(
name|nm
argument_list|,
name|nm_len
argument_list|,
name|labs
argument_list|,
name|dclass
argument_list|,
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zone
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|/* insert the list of zones into the tree */
name|p
operator|=
name|zone
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|np
operator|=
name|p
operator|->
name|parent
expr_stmt|;
comment|/* mem use */
name|neg
operator|->
name|use
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|val_neg_zone
argument_list|)
operator|+
name|p
operator|->
name|len
expr_stmt|;
comment|/* insert in tree */
operator|(
name|void
operator|)
name|rbtree_insert
argument_list|(
operator|&
name|neg
operator|->
name|tree
argument_list|,
operator|&
name|p
operator|->
name|node
argument_list|)
expr_stmt|;
comment|/* last one needs proper parent pointer */
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
name|p
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|p
operator|=
name|np
expr_stmt|;
block|}
return|return
name|zone
return|;
block|}
end_function

begin_comment
comment|/** find zone name of message, returns the SOA record */
end_comment

begin_function
specifier|static
name|struct
name|ub_packed_rrset_key
modifier|*
name|reply_find_soa
parameter_list|(
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|rep
operator|->
name|an_numrrsets
init|;
name|i
operator|<
name|rep
operator|->
name|an_numrrsets
operator|+
name|rep
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_SOA
condition|)
return|return
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/** see if the reply has NSEC records worthy of caching */
end_comment

begin_function
specifier|static
name|int
name|reply_has_nsec
parameter_list|(
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|rep
operator|->
name|security
operator|!=
name|sec_status_secure
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
name|rep
operator|->
name|an_numrrsets
init|;
name|i
operator|<
name|rep
operator|->
name|an_numrrsets
operator|+
name|rep
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC
condition|)
block|{
name|d
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|entry
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|security
operator|==
name|sec_status_secure
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Create single node of data element.  * @param nm: name (copied)  * @param nm_len: length of name  * @param labs: labels in name.  * @return element with name nm, or NULL malloc failure.  */
end_comment

begin_function
specifier|static
name|struct
name|val_neg_data
modifier|*
name|neg_setup_data_node
parameter_list|(
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|nm_len
parameter_list|,
name|int
name|labs
parameter_list|)
block|{
name|struct
name|val_neg_data
modifier|*
name|el
decl_stmt|;
name|el
operator|=
operator|(
expr|struct
name|val_neg_data
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|el
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|el
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|el
operator|->
name|node
operator|.
name|key
operator|=
name|el
expr_stmt|;
name|el
operator|->
name|name
operator|=
name|memdup
argument_list|(
name|nm
argument_list|,
name|nm_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|el
operator|->
name|name
condition|)
block|{
name|free
argument_list|(
name|el
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|el
operator|->
name|len
operator|=
name|nm_len
expr_stmt|;
name|el
operator|->
name|labs
operator|=
name|labs
expr_stmt|;
return|return
name|el
return|;
block|}
end_function

begin_comment
comment|/**  * Create chain of data element and parents  * @param nm: name  * @param nm_len: length of name  * @param labs: labels in name.  * @param parent: up to where to make, if NULL up to root label.  * @return lowest element with name nm, or NULL malloc failure.  */
end_comment

begin_function
specifier|static
name|struct
name|val_neg_data
modifier|*
name|neg_data_chain
parameter_list|(
name|uint8_t
modifier|*
name|nm
parameter_list|,
name|size_t
name|nm_len
parameter_list|,
name|int
name|labs
parameter_list|,
name|struct
name|val_neg_data
modifier|*
name|parent
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|tolabs
init|=
name|parent
condition|?
name|parent
operator|->
name|labs
else|:
literal|0
decl_stmt|;
name|struct
name|val_neg_data
modifier|*
name|el
decl_stmt|,
modifier|*
name|first
init|=
name|NULL
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
comment|/* create the new subtree, i is labelcount of current creation */
comment|/* this creates a 'first' to z->parent=NULL list of zones */
for|for
control|(
name|i
operator|=
name|labs
init|;
name|i
operator|!=
name|tolabs
condition|;
name|i
operator|--
control|)
block|{
comment|/* create new item */
name|el
operator|=
name|neg_setup_data_node
argument_list|(
name|nm
argument_list|,
name|nm_len
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|el
condition|)
block|{
comment|/* need to delete other allocations in this routine!*/
name|struct
name|val_neg_data
modifier|*
name|p
init|=
name|first
decl_stmt|,
modifier|*
name|np
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|np
operator|=
name|p
operator|->
name|parent
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|np
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|i
operator|==
name|labs
condition|)
block|{
name|first
operator|=
name|el
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|->
name|parent
operator|=
name|el
expr_stmt|;
block|}
comment|/* prepare for next name */
name|prev
operator|=
name|el
expr_stmt|;
name|dname_remove_label
argument_list|(
operator|&
name|nm
argument_list|,
operator|&
name|nm_len
argument_list|)
expr_stmt|;
block|}
return|return
name|first
return|;
block|}
end_function

begin_comment
comment|/**  * Remove NSEC records between start and end points.  * By walking the tree, the tree is sorted canonically.  * @param neg: negative cache.  * @param zone: the zone  * @param el: element to start walking at.  * @param nsec: the nsec record with the end point  */
end_comment

begin_function
specifier|static
name|void
name|wipeout
parameter_list|(
name|struct
name|val_neg_cache
modifier|*
name|neg
parameter_list|,
name|struct
name|val_neg_zone
modifier|*
name|zone
parameter_list|,
name|struct
name|val_neg_data
modifier|*
name|el
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|nsec
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
init|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|nsec
operator|->
name|entry
operator|.
name|data
decl_stmt|;
name|uint8_t
modifier|*
name|end
decl_stmt|;
name|size_t
name|end_len
decl_stmt|;
name|int
name|end_labs
decl_stmt|,
name|m
decl_stmt|;
name|rbnode_t
modifier|*
name|walk
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|struct
name|val_neg_data
modifier|*
name|cur
decl_stmt|;
name|uint8_t
name|buf
index|[
literal|257
index|]
decl_stmt|;
comment|/* get endpoint */
if|if
condition|(
operator|!
name|d
operator|||
name|d
operator|->
name|count
operator|==
literal|0
operator|||
name|d
operator|->
name|rr_len
index|[
literal|0
index|]
operator|<
literal|2
operator|+
literal|1
condition|)
return|return;
if|if
condition|(
name|ntohs
argument_list|(
name|nsec
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC
condition|)
block|{
name|end
operator|=
name|d
operator|->
name|rr_data
index|[
literal|0
index|]
operator|+
literal|2
expr_stmt|;
name|end_len
operator|=
name|dname_valid
argument_list|(
name|end
argument_list|,
name|d
operator|->
name|rr_len
index|[
literal|0
index|]
operator|-
literal|2
argument_list|)
expr_stmt|;
name|end_labs
operator|=
name|dname_count_labels
argument_list|(
name|end
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* NSEC3 */
if|if
condition|(
operator|!
name|nsec3_get_nextowner_b32
argument_list|(
name|nsec
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
return|return;
name|end
operator|=
name|buf
expr_stmt|;
name|end_labs
operator|=
name|dname_count_size_labels
argument_list|(
name|end
argument_list|,
operator|&
name|end_len
argument_list|)
expr_stmt|;
block|}
comment|/* sanity check, both owner and end must be below the zone apex */
if|if
condition|(
operator|!
name|dname_subdomain_c
argument_list|(
name|el
operator|->
name|name
argument_list|,
name|zone
operator|->
name|name
argument_list|)
operator|||
operator|!
name|dname_subdomain_c
argument_list|(
name|end
argument_list|,
name|zone
operator|->
name|name
argument_list|)
condition|)
return|return;
comment|/* detect end of zone NSEC ; wipe until the end of zone */
if|if
condition|(
name|query_dname_compare
argument_list|(
name|end
argument_list|,
name|zone
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|end
operator|=
name|NULL
expr_stmt|;
block|}
name|walk
operator|=
name|rbtree_next
argument_list|(
operator|&
name|el
operator|->
name|node
argument_list|)
expr_stmt|;
while|while
condition|(
name|walk
operator|&&
name|walk
operator|!=
name|RBTREE_NULL
condition|)
block|{
name|cur
operator|=
operator|(
expr|struct
name|val_neg_data
operator|*
operator|)
name|walk
expr_stmt|;
comment|/* sanity check: must be larger than start */
if|if
condition|(
name|dname_canon_lab_cmp
argument_list|(
name|cur
operator|->
name|name
argument_list|,
name|cur
operator|->
name|labs
argument_list|,
name|el
operator|->
name|name
argument_list|,
name|el
operator|->
name|labs
argument_list|,
operator|&
name|m
argument_list|)
operator|<=
literal|0
condition|)
block|{
comment|/* r == 0 skip original record. */
comment|/* r< 0  too small! */
name|walk
operator|=
name|rbtree_next
argument_list|(
name|walk
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* stop at endpoint, also data at empty nonterminals must be 		 * removed (no NSECs there) so everything between  		 * start and end */
if|if
condition|(
name|end
operator|&&
name|dname_canon_lab_cmp
argument_list|(
name|cur
operator|->
name|name
argument_list|,
name|cur
operator|->
name|labs
argument_list|,
name|end
argument_list|,
name|end_labs
argument_list|,
operator|&
name|m
argument_list|)
operator|>=
literal|0
condition|)
block|{
break|break;
block|}
comment|/* this element has to be deleted, but we cannot do it 		 * now, because we are walking the tree still ... */
comment|/* get the next element: */
name|next
operator|=
name|rbtree_next
argument_list|(
name|walk
argument_list|)
expr_stmt|;
comment|/* now delete the original element, this may trigger 		 * rbtree rebalances, but really, the next element is 		 * the one we need. 		 * But it may trigger delete of other data and the 		 * entire zone. However, if that happens, this is done 		 * by deleting the *parents* of the element for deletion, 		 * and maybe also the entire zone if it is empty.  		 * But parents are smaller in canonical compare, thus, 		 * if a larger element exists, then it is not a parent, 		 * it cannot get deleted, the zone cannot get empty. 		 * If the next==NULL, then zone can be empty. */
if|if
condition|(
name|cur
operator|->
name|in_use
condition|)
name|neg_delete_data
argument_list|(
name|neg
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|walk
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|neg_insert_data
parameter_list|(
name|struct
name|val_neg_cache
modifier|*
name|neg
parameter_list|,
name|struct
name|val_neg_zone
modifier|*
name|zone
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|nsec
parameter_list|)
block|{
name|struct
name|packed_rrset_data
modifier|*
name|d
decl_stmt|;
name|struct
name|val_neg_data
modifier|*
name|parent
decl_stmt|;
name|struct
name|val_neg_data
modifier|*
name|el
decl_stmt|;
name|uint8_t
modifier|*
name|nm
init|=
name|nsec
operator|->
name|rk
operator|.
name|dname
decl_stmt|;
name|size_t
name|nm_len
init|=
name|nsec
operator|->
name|rk
operator|.
name|dname_len
decl_stmt|;
name|int
name|labs
init|=
name|dname_count_labels
argument_list|(
name|nsec
operator|->
name|rk
operator|.
name|dname
argument_list|)
decl_stmt|;
name|d
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|nsec
operator|->
name|entry
operator|.
name|data
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|security
operator|==
name|sec_status_secure
operator|||
operator|(
name|d
operator|->
name|security
operator|==
name|sec_status_unchecked
operator|&&
name|d
operator|->
name|rrsig_count
operator|>
literal|0
operator|)
operator|)
condition|)
return|return;
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"negcache rr"
argument_list|,
name|nsec
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|ntohs
argument_list|(
name|nsec
operator|->
name|rk
operator|.
name|type
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|nsec
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
argument_list|)
expr_stmt|;
comment|/* find closest enclosing parent data that (still) exists */
name|parent
operator|=
name|neg_closest_data_parent
argument_list|(
name|zone
argument_list|,
name|nm
argument_list|,
name|nm_len
argument_list|,
name|labs
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|&&
name|query_dname_compare
argument_list|(
name|parent
operator|->
name|name
argument_list|,
name|nm
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* perfect match already exists */
name|log_assert
argument_list|(
name|parent
operator|->
name|count
operator|>
literal|0
argument_list|)
expr_stmt|;
name|el
operator|=
name|parent
expr_stmt|;
block|}
else|else
block|{
name|struct
name|val_neg_data
modifier|*
name|p
decl_stmt|,
modifier|*
name|np
decl_stmt|;
comment|/* create subtree for perfect match */
comment|/* if parent exists, it is in use */
name|log_assert
argument_list|(
operator|!
name|parent
operator|||
name|parent
operator|->
name|count
operator|>
literal|0
argument_list|)
expr_stmt|;
name|el
operator|=
name|neg_data_chain
argument_list|(
name|nm
argument_list|,
name|nm_len
argument_list|,
name|labs
argument_list|,
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|el
condition|)
block|{
name|log_err
argument_list|(
literal|"out of memory inserting NSEC negative cache"
argument_list|)
expr_stmt|;
return|return;
block|}
name|el
operator|->
name|in_use
operator|=
literal|0
expr_stmt|;
comment|/* set on below */
comment|/* insert the list of zones into the tree */
name|p
operator|=
name|el
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|np
operator|=
name|p
operator|->
name|parent
expr_stmt|;
comment|/* mem use */
name|neg
operator|->
name|use
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|val_neg_data
argument_list|)
operator|+
name|p
operator|->
name|len
expr_stmt|;
comment|/* insert in tree */
name|p
operator|->
name|zone
operator|=
name|zone
expr_stmt|;
operator|(
name|void
operator|)
name|rbtree_insert
argument_list|(
operator|&
name|zone
operator|->
name|tree
argument_list|,
operator|&
name|p
operator|->
name|node
argument_list|)
expr_stmt|;
comment|/* last one needs proper parent pointer */
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
name|p
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|p
operator|=
name|np
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|el
operator|->
name|in_use
condition|)
block|{
name|struct
name|val_neg_data
modifier|*
name|p
decl_stmt|;
name|el
operator|->
name|in_use
operator|=
literal|1
expr_stmt|;
comment|/* increase usage count of all parents */
for|for
control|(
name|p
operator|=
name|el
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|parent
control|)
block|{
name|p
operator|->
name|count
operator|++
expr_stmt|;
block|}
name|neg_lru_front
argument_list|(
name|neg
argument_list|,
name|el
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* in use, bring to front, lru */
name|neg_lru_touch
argument_list|(
name|neg
argument_list|,
name|el
argument_list|)
expr_stmt|;
block|}
comment|/* if nsec3 store last used parameters */
if|if
condition|(
name|ntohs
argument_list|(
name|nsec
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC3
condition|)
block|{
name|int
name|h
decl_stmt|;
name|uint8_t
modifier|*
name|s
decl_stmt|;
name|size_t
name|slen
decl_stmt|,
name|it
decl_stmt|;
if|if
condition|(
name|nsec3_get_params
argument_list|(
name|nsec
argument_list|,
literal|0
argument_list|,
operator|&
name|h
argument_list|,
operator|&
name|it
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|slen
argument_list|)
operator|&&
name|it
operator|<=
name|neg
operator|->
name|nsec3_max_iter
operator|&&
operator|(
name|h
operator|!=
name|zone
operator|->
name|nsec3_hash
operator|||
name|it
operator|!=
name|zone
operator|->
name|nsec3_iter
operator|||
name|slen
operator|!=
name|zone
operator|->
name|nsec3_saltlen
operator|||
name|memcmp
argument_list|(
name|zone
operator|->
name|nsec3_salt
argument_list|,
name|s
argument_list|,
name|slen
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|uint8_t
modifier|*
name|sa
init|=
name|memdup
argument_list|(
name|s
argument_list|,
name|slen
argument_list|)
decl_stmt|;
if|if
condition|(
name|sa
condition|)
block|{
name|free
argument_list|(
name|zone
operator|->
name|nsec3_salt
argument_list|)
expr_stmt|;
name|zone
operator|->
name|nsec3_salt
operator|=
name|sa
expr_stmt|;
name|zone
operator|->
name|nsec3_saltlen
operator|=
name|slen
expr_stmt|;
name|zone
operator|->
name|nsec3_hash
operator|=
name|h
expr_stmt|;
name|zone
operator|->
name|nsec3_iter
operator|=
name|it
expr_stmt|;
block|}
block|}
block|}
comment|/* wipe out the cache items between NSEC start and end */
name|wipeout
argument_list|(
name|neg
argument_list|,
name|zone
argument_list|,
name|el
argument_list|,
name|nsec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|val_neg_addreply
parameter_list|(
name|struct
name|val_neg_cache
modifier|*
name|neg
parameter_list|,
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|need
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|soa
decl_stmt|;
name|struct
name|val_neg_zone
modifier|*
name|zone
decl_stmt|;
comment|/* see if secure nsecs inside */
if|if
condition|(
operator|!
name|reply_has_nsec
argument_list|(
name|rep
argument_list|)
condition|)
return|return;
comment|/* find the zone name in message */
name|soa
operator|=
name|reply_find_soa
argument_list|(
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|soa
condition|)
return|return;
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"negcache insert for zone"
argument_list|,
name|soa
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|,
name|ntohs
argument_list|(
name|soa
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ask for enough space to store all of it */
name|need
operator|=
name|calc_data_need
argument_list|(
name|rep
argument_list|)
operator|+
name|calc_zone_need
argument_list|(
name|soa
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|soa
operator|->
name|rk
operator|.
name|dname_len
argument_list|)
expr_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|neg
operator|->
name|lock
argument_list|)
expr_stmt|;
name|neg_make_space
argument_list|(
name|neg
argument_list|,
name|need
argument_list|)
expr_stmt|;
comment|/* find or create the zone entry */
name|zone
operator|=
name|neg_find_zone
argument_list|(
name|neg
argument_list|,
name|soa
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|soa
operator|->
name|rk
operator|.
name|dname_len
argument_list|,
name|ntohs
argument_list|(
name|soa
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zone
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|zone
operator|=
name|neg_create_zone
argument_list|(
name|neg
argument_list|,
name|soa
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|soa
operator|->
name|rk
operator|.
name|dname_len
argument_list|,
name|ntohs
argument_list|(
name|soa
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|neg
operator|->
name|lock
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"out of memory adding negative zone"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|val_neg_zone_take_inuse
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* insert the NSECs */
for|for
control|(
name|i
operator|=
name|rep
operator|->
name|an_numrrsets
init|;
name|i
operator|<
name|rep
operator|->
name|an_numrrsets
operator|+
name|rep
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|!=
name|LDNS_RR_TYPE_NSEC
condition|)
continue|continue;
if|if
condition|(
operator|!
name|dname_subdomain_c
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|zone
operator|->
name|name
argument_list|)
condition|)
continue|continue;
comment|/* insert NSEC into this zone's tree */
name|neg_insert_data
argument_list|(
name|neg
argument_list|,
name|zone
argument_list|,
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zone
operator|->
name|tree
operator|.
name|count
operator|==
literal|0
condition|)
block|{
comment|/* remove empty zone if inserts failed */
name|neg_delete_zone
argument_list|(
name|neg
argument_list|,
name|zone
argument_list|)
expr_stmt|;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|neg
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Lookup closest data record. For NSEC denial.  * @param zone: zone to look in  * @param qname: name to look for.  * @param len: length of name  * @param labs: labels in name  * @param data: data element, exact or smaller or NULL  * @return true if exact match.  */
end_comment

begin_function
specifier|static
name|int
name|neg_closest_data
parameter_list|(
name|struct
name|val_neg_zone
modifier|*
name|zone
parameter_list|,
name|uint8_t
modifier|*
name|qname
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|labs
parameter_list|,
name|struct
name|val_neg_data
modifier|*
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|val_neg_data
name|key
decl_stmt|;
name|rbnode_t
modifier|*
name|r
decl_stmt|;
name|key
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|key
expr_stmt|;
name|key
operator|.
name|name
operator|=
name|qname
expr_stmt|;
name|key
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|key
operator|.
name|labs
operator|=
name|labs
expr_stmt|;
if|if
condition|(
name|rbtree_find_less_equal
argument_list|(
operator|&
name|zone
operator|->
name|tree
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|r
argument_list|)
condition|)
block|{
comment|/* exact match */
operator|*
name|data
operator|=
operator|(
expr|struct
name|val_neg_data
operator|*
operator|)
name|r
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* smaller match */
operator|*
name|data
operator|=
operator|(
expr|struct
name|val_neg_data
operator|*
operator|)
name|r
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|int
name|val_neg_dlvlookup
parameter_list|(
name|struct
name|val_neg_cache
modifier|*
name|neg
parameter_list|,
name|uint8_t
modifier|*
name|qname
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uint16_t
name|qclass
parameter_list|,
name|struct
name|rrset_cache
modifier|*
name|rrset_cache
parameter_list|,
name|time_t
name|now
parameter_list|)
block|{
comment|/* lookup closest zone */
name|struct
name|val_neg_zone
modifier|*
name|zone
decl_stmt|;
name|struct
name|val_neg_data
modifier|*
name|data
decl_stmt|;
name|int
name|labs
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|nsec
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|d
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|uint8_t
modifier|*
name|wc
decl_stmt|;
name|struct
name|query_info
name|qinfo
decl_stmt|;
if|if
condition|(
operator|!
name|neg
condition|)
return|return
literal|0
return|;
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"negcache dlvlookup"
argument_list|,
name|qname
argument_list|,
name|LDNS_RR_TYPE_DLV
argument_list|,
name|qclass
argument_list|)
expr_stmt|;
name|labs
operator|=
name|dname_count_labels
argument_list|(
name|qname
argument_list|)
expr_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|neg
operator|->
name|lock
argument_list|)
expr_stmt|;
name|zone
operator|=
name|neg_closest_zone_parent
argument_list|(
name|neg
argument_list|,
name|qname
argument_list|,
name|len
argument_list|,
name|labs
argument_list|,
name|qclass
argument_list|)
expr_stmt|;
while|while
condition|(
name|zone
operator|&&
operator|!
name|zone
operator|->
name|in_use
condition|)
name|zone
operator|=
name|zone
operator|->
name|parent
expr_stmt|;
if|if
condition|(
operator|!
name|zone
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|neg
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"negcache zone"
argument_list|,
name|zone
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|zone
operator|->
name|dclass
argument_list|)
expr_stmt|;
comment|/* DLV is defined to use NSEC only */
if|if
condition|(
name|zone
operator|->
name|nsec3_hash
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|neg
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* lookup closest data record */
operator|(
name|void
operator|)
name|neg_closest_data
argument_list|(
name|zone
argument_list|,
name|qname
argument_list|,
name|len
argument_list|,
name|labs
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
while|while
condition|(
name|data
operator|&&
operator|!
name|data
operator|->
name|in_use
condition|)
name|data
operator|=
name|data
operator|->
name|parent
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|neg
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"negcache rr"
argument_list|,
name|data
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_NSEC
argument_list|,
name|zone
operator|->
name|dclass
argument_list|)
expr_stmt|;
comment|/* lookup rrset in rrset cache */
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|query_dname_compare
argument_list|(
name|data
operator|->
name|name
argument_list|,
name|zone
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
name|flags
operator|=
name|PACKED_RRSET_NSEC_AT_APEX
expr_stmt|;
name|nsec
operator|=
name|rrset_cache_lookup
argument_list|(
name|rrset_cache
argument_list|,
name|data
operator|->
name|name
argument_list|,
name|data
operator|->
name|len
argument_list|,
name|LDNS_RR_TYPE_NSEC
argument_list|,
name|zone
operator|->
name|dclass
argument_list|,
name|flags
argument_list|,
name|now
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* check if secure and TTL ok */
if|if
condition|(
operator|!
name|nsec
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|neg
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|d
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|nsec
operator|->
name|entry
operator|.
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
name|now
operator|>
name|d
operator|->
name|ttl
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|nsec
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
comment|/* delete data record if expired */
name|neg_delete_data
argument_list|(
name|neg
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|neg
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|d
operator|->
name|security
operator|!=
name|sec_status_secure
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|nsec
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
name|neg_delete_data
argument_list|(
name|neg
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|neg
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"negcache got secure rrset"
argument_list|)
expr_stmt|;
comment|/* check NSEC security */
comment|/* check if NSEC proves no DLV type exists */
comment|/* check if NSEC proves NXDOMAIN for qname */
name|qinfo
operator|.
name|qname
operator|=
name|qname
expr_stmt|;
name|qinfo
operator|.
name|qtype
operator|=
name|LDNS_RR_TYPE_DLV
expr_stmt|;
name|qinfo
operator|.
name|qclass
operator|=
name|qclass
expr_stmt|;
if|if
condition|(
operator|!
name|nsec_proves_nodata
argument_list|(
name|nsec
argument_list|,
operator|&
name|qinfo
argument_list|,
operator|&
name|wc
argument_list|)
operator|&&
operator|!
name|val_nsec_proves_name_error
argument_list|(
name|nsec
argument_list|,
name|qname
argument_list|)
condition|)
block|{
comment|/* the NSEC is not a denial for the DLV */
name|lock_rw_unlock
argument_list|(
operator|&
name|nsec
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|neg
operator|->
name|lock
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"negcache not proven"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* so the NSEC was a NODATA proof, or NXDOMAIN proof. */
comment|/* no need to check for wildcard NSEC; no wildcards in DLV repos */
comment|/* no need to lookup SOA record for client; no response message */
name|lock_rw_unlock
argument_list|(
operator|&
name|nsec
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
comment|/* if OK touch the LRU for neg_data element */
name|neg_lru_touch
argument_list|(
name|neg
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|neg
operator|->
name|lock
argument_list|)
expr_stmt|;
name|verbose
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"negcache DLV denial proven"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** see if the reply has signed NSEC records and return the signer */
end_comment

begin_function
specifier|static
name|uint8_t
modifier|*
name|reply_nsec_signer
parameter_list|(
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|size_t
modifier|*
name|signer_len
parameter_list|,
name|uint16_t
modifier|*
name|dclass
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|d
decl_stmt|;
name|uint8_t
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|i
operator|=
name|rep
operator|->
name|an_numrrsets
init|;
name|i
operator|<
name|rep
operator|->
name|an_numrrsets
operator|+
name|rep
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC
operator|||
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC3
condition|)
block|{
name|d
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|entry
operator|.
name|data
expr_stmt|;
comment|/* return first signer name of first NSEC */
if|if
condition|(
name|d
operator|->
name|rrsig_count
operator|!=
literal|0
condition|)
block|{
name|val_find_rrset_signer
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|,
operator|&
name|s
argument_list|,
name|signer_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&&
operator|*
name|signer_len
condition|)
block|{
operator|*
name|dclass
operator|=
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|rrset_class
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|val_neg_addreferral
parameter_list|(
name|struct
name|val_neg_cache
modifier|*
name|neg
parameter_list|,
name|struct
name|reply_info
modifier|*
name|rep
parameter_list|,
name|uint8_t
modifier|*
name|zone_name
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|need
decl_stmt|;
name|uint8_t
modifier|*
name|signer
decl_stmt|;
name|size_t
name|signer_len
decl_stmt|;
name|uint16_t
name|dclass
decl_stmt|;
name|struct
name|val_neg_zone
modifier|*
name|zone
decl_stmt|;
comment|/* no SOA in this message, find RRSIG over NSEC's signer name. 	 * note the NSEC records are maybe not validated yet */
name|signer
operator|=
name|reply_nsec_signer
argument_list|(
name|rep
argument_list|,
operator|&
name|signer_len
argument_list|,
operator|&
name|dclass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|signer
condition|)
return|return;
if|if
condition|(
operator|!
name|dname_subdomain_c
argument_list|(
name|signer
argument_list|,
name|zone_name
argument_list|)
condition|)
block|{
comment|/* the signer is not in the bailiwick, throw it out */
return|return;
block|}
name|log_nametypeclass
argument_list|(
name|VERB_ALGO
argument_list|,
literal|"negcache insert referral "
argument_list|,
name|signer
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|,
name|dclass
argument_list|)
expr_stmt|;
comment|/* ask for enough space to store all of it */
name|need
operator|=
name|calc_data_need
argument_list|(
name|rep
argument_list|)
operator|+
name|calc_zone_need
argument_list|(
name|signer
argument_list|,
name|signer_len
argument_list|)
expr_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|neg
operator|->
name|lock
argument_list|)
expr_stmt|;
name|neg_make_space
argument_list|(
name|neg
argument_list|,
name|need
argument_list|)
expr_stmt|;
comment|/* find or create the zone entry */
name|zone
operator|=
name|neg_find_zone
argument_list|(
name|neg
argument_list|,
name|signer
argument_list|,
name|signer_len
argument_list|,
name|dclass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zone
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|zone
operator|=
name|neg_create_zone
argument_list|(
name|neg
argument_list|,
name|signer
argument_list|,
name|signer_len
argument_list|,
name|dclass
argument_list|)
operator|)
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|neg
operator|->
name|lock
argument_list|)
expr_stmt|;
name|log_err
argument_list|(
literal|"out of memory adding negative zone"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|val_neg_zone_take_inuse
argument_list|(
name|zone
argument_list|)
expr_stmt|;
comment|/* insert the NSECs */
for|for
control|(
name|i
operator|=
name|rep
operator|->
name|an_numrrsets
init|;
name|i
operator|<
name|rep
operator|->
name|an_numrrsets
operator|+
name|rep
operator|->
name|ns_numrrsets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|!=
name|LDNS_RR_TYPE_NSEC
operator|&&
name|ntohs
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|type
argument_list|)
operator|!=
name|LDNS_RR_TYPE_NSEC3
condition|)
continue|continue;
if|if
condition|(
operator|!
name|dname_subdomain_c
argument_list|(
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
operator|->
name|rk
operator|.
name|dname
argument_list|,
name|zone
operator|->
name|name
argument_list|)
condition|)
continue|continue;
comment|/* insert NSEC into this zone's tree */
name|neg_insert_data
argument_list|(
name|neg
argument_list|,
name|zone
argument_list|,
name|rep
operator|->
name|rrsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zone
operator|->
name|tree
operator|.
name|count
operator|==
literal|0
condition|)
block|{
comment|/* remove empty zone if inserts failed */
name|neg_delete_zone
argument_list|(
name|neg
argument_list|,
name|zone
argument_list|)
expr_stmt|;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|neg
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Check that an NSEC3 rrset does not have a type set.  * None of the nsec3s in a hash-collision are allowed to have the type.  * (since we do not know which one is the nsec3 looked at, flags, ..., we  * ignore the cached item and let it bypass negative caching).  * @param k: the nsec3 rrset to check.  * @param t: type to check  * @return true if no RRs have the type.  */
end_comment

begin_function
specifier|static
name|int
name|nsec3_no_type
parameter_list|(
name|struct
name|ub_packed_rrset_key
modifier|*
name|k
parameter_list|,
name|uint16_t
name|t
parameter_list|)
block|{
name|int
name|count
init|=
call|(
name|int
call|)
argument_list|(
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|k
operator|->
name|entry
operator|.
name|data
argument_list|)
operator|->
name|count
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|nsec3_has_type
argument_list|(
name|k
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * See if rrset exists in rrset cache.  * If it does, the bit is checked, and if not expired, it is returned  * allocated in region.  * @param rrset_cache: rrset cache  * @param qname: to lookup rrset name  * @param qname_len: length of qname.  * @param qtype: type of rrset to lookup, host order  * @param qclass: class of rrset to lookup, host order  * @param flags: flags for rrset to lookup  * @param region: where to alloc result  * @param checkbit: if true, a bit in the nsec typemap is checked for absence.  * @param checktype: which bit to check  * @param now: to check ttl against  * @return rrset or NULL  */
end_comment

begin_function
specifier|static
name|struct
name|ub_packed_rrset_key
modifier|*
name|grab_nsec
parameter_list|(
name|struct
name|rrset_cache
modifier|*
name|rrset_cache
parameter_list|,
name|uint8_t
modifier|*
name|qname
parameter_list|,
name|size_t
name|qname_len
parameter_list|,
name|uint16_t
name|qtype
parameter_list|,
name|uint16_t
name|qclass
parameter_list|,
name|uint32_t
name|flags
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|int
name|checkbit
parameter_list|,
name|uint16_t
name|checktype
parameter_list|,
name|time_t
name|now
parameter_list|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|r
decl_stmt|,
modifier|*
name|k
init|=
name|rrset_cache_lookup
argument_list|(
name|rrset_cache
argument_list|,
name|qname
argument_list|,
name|qname_len
argument_list|,
name|qtype
argument_list|,
name|qclass
argument_list|,
name|flags
argument_list|,
name|now
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|struct
name|packed_rrset_data
modifier|*
name|d
decl_stmt|;
if|if
condition|(
operator|!
name|k
condition|)
return|return
name|NULL
return|;
name|d
operator|=
operator|(
expr|struct
name|packed_rrset_data
operator|*
operator|)
name|k
operator|->
name|entry
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|ttl
operator|<
name|now
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|k
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* only secure or unchecked records that have signatures. */
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|security
operator|==
name|sec_status_secure
operator|||
operator|(
name|d
operator|->
name|security
operator|==
name|sec_status_unchecked
operator|&&
name|d
operator|->
name|rrsig_count
operator|>
literal|0
operator|)
operator|)
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|k
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* check if checktype is absent */
if|if
condition|(
name|checkbit
operator|&&
operator|(
operator|(
name|qtype
operator|==
name|LDNS_RR_TYPE_NSEC
operator|&&
name|nsec_has_type
argument_list|(
name|k
argument_list|,
name|checktype
argument_list|)
operator|)
operator|||
operator|(
name|qtype
operator|==
name|LDNS_RR_TYPE_NSEC3
operator|&&
operator|!
name|nsec3_no_type
argument_list|(
name|k
argument_list|,
name|checktype
argument_list|)
operator|)
operator|)
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|k
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* looks OK! copy to region and return it */
name|r
operator|=
name|packed_rrset_copy_region
argument_list|(
name|k
argument_list|,
name|region
argument_list|,
name|now
argument_list|)
expr_stmt|;
comment|/* if it failed, we return the NULL */
name|lock_rw_unlock
argument_list|(
operator|&
name|k
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/** find nsec3 closest encloser in neg cache */
end_comment

begin_function
specifier|static
name|struct
name|val_neg_data
modifier|*
name|neg_find_nsec3_ce
parameter_list|(
name|struct
name|val_neg_zone
modifier|*
name|zone
parameter_list|,
name|uint8_t
modifier|*
name|qname
parameter_list|,
name|size_t
name|qname_len
parameter_list|,
name|int
name|qlabs
parameter_list|,
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|uint8_t
modifier|*
name|hashnc
parameter_list|,
name|size_t
modifier|*
name|nclen
parameter_list|)
block|{
name|struct
name|val_neg_data
modifier|*
name|data
decl_stmt|;
name|uint8_t
name|hashce
index|[
name|NSEC3_SHA_LEN
index|]
decl_stmt|;
name|uint8_t
name|b32
index|[
literal|257
index|]
decl_stmt|;
name|size_t
name|celen
decl_stmt|,
name|b32len
decl_stmt|;
operator|*
name|nclen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|qlabs
operator|>
literal|0
condition|)
block|{
comment|/* hash */
if|if
condition|(
operator|!
operator|(
name|celen
operator|=
name|nsec3_get_hashed
argument_list|(
name|buf
argument_list|,
name|qname
argument_list|,
name|qname_len
argument_list|,
name|zone
operator|->
name|nsec3_hash
argument_list|,
name|zone
operator|->
name|nsec3_iter
argument_list|,
name|zone
operator|->
name|nsec3_salt
argument_list|,
name|zone
operator|->
name|nsec3_saltlen
argument_list|,
name|hashce
argument_list|,
sizeof|sizeof
argument_list|(
name|hashce
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
operator|(
name|b32len
operator|=
name|nsec3_hash_to_b32
argument_list|(
name|hashce
argument_list|,
name|celen
argument_list|,
name|zone
operator|->
name|name
argument_list|,
name|zone
operator|->
name|len
argument_list|,
name|b32
argument_list|,
sizeof|sizeof
argument_list|(
name|b32
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* lookup (exact match only) */
name|data
operator|=
name|neg_find_data
argument_list|(
name|zone
argument_list|,
name|b32
argument_list|,
name|b32len
argument_list|,
name|zone
operator|->
name|labs
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|&&
name|data
operator|->
name|in_use
condition|)
block|{
comment|/* found ce match! */
return|return
name|data
return|;
block|}
operator|*
name|nclen
operator|=
name|celen
expr_stmt|;
name|memmove
argument_list|(
name|hashnc
argument_list|,
name|hashce
argument_list|,
name|celen
argument_list|)
expr_stmt|;
name|dname_remove_label
argument_list|(
operator|&
name|qname
argument_list|,
operator|&
name|qname_len
argument_list|)
expr_stmt|;
name|qlabs
operator|--
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/** check nsec3 parameters on nsec3 rrset with current zone values */
end_comment

begin_function
specifier|static
name|int
name|neg_params_ok
parameter_list|(
name|struct
name|val_neg_zone
modifier|*
name|zone
parameter_list|,
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
parameter_list|)
block|{
name|int
name|h
decl_stmt|;
name|uint8_t
modifier|*
name|s
decl_stmt|;
name|size_t
name|slen
decl_stmt|,
name|it
decl_stmt|;
if|if
condition|(
operator|!
name|nsec3_get_params
argument_list|(
name|rrset
argument_list|,
literal|0
argument_list|,
operator|&
name|h
argument_list|,
operator|&
name|it
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|slen
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|h
operator|==
name|zone
operator|->
name|nsec3_hash
operator|&&
name|it
operator|==
name|zone
operator|->
name|nsec3_iter
operator|&&
name|slen
operator|==
name|zone
operator|->
name|nsec3_saltlen
operator|&&
name|memcmp
argument_list|(
name|zone
operator|->
name|nsec3_salt
argument_list|,
name|s
argument_list|,
name|slen
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/** get next closer for nsec3 proof */
end_comment

begin_function
specifier|static
name|struct
name|ub_packed_rrset_key
modifier|*
name|neg_nsec3_getnc
parameter_list|(
name|struct
name|val_neg_zone
modifier|*
name|zone
parameter_list|,
name|uint8_t
modifier|*
name|hashnc
parameter_list|,
name|size_t
name|nclen
parameter_list|,
name|struct
name|rrset_cache
modifier|*
name|rrset_cache
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|time_t
name|now
parameter_list|,
name|uint8_t
modifier|*
name|b32
parameter_list|,
name|size_t
name|maxb32
parameter_list|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|nc_rrset
decl_stmt|;
name|struct
name|val_neg_data
modifier|*
name|data
decl_stmt|;
name|size_t
name|b32len
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|b32len
operator|=
name|nsec3_hash_to_b32
argument_list|(
name|hashnc
argument_list|,
name|nclen
argument_list|,
name|zone
operator|->
name|name
argument_list|,
name|zone
operator|->
name|len
argument_list|,
name|b32
argument_list|,
name|maxb32
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
operator|(
name|void
operator|)
name|neg_closest_data
argument_list|(
name|zone
argument_list|,
name|b32
argument_list|,
name|b32len
argument_list|,
name|zone
operator|->
name|labs
operator|+
literal|1
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|&&
name|zone
operator|->
name|tree
operator|.
name|count
operator|!=
literal|0
condition|)
block|{
comment|/* could be before the first entry ; return the last 		 * entry (possibly the rollover nsec3 at end) */
name|data
operator|=
operator|(
expr|struct
name|val_neg_data
operator|*
operator|)
name|rbtree_last
argument_list|(
operator|&
name|zone
operator|->
name|tree
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|data
operator|&&
operator|!
name|data
operator|->
name|in_use
condition|)
name|data
operator|=
name|data
operator|->
name|parent
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
return|return
name|NULL
return|;
comment|/* got a data element in tree, grab it */
name|nc_rrset
operator|=
name|grab_nsec
argument_list|(
name|rrset_cache
argument_list|,
name|data
operator|->
name|name
argument_list|,
name|data
operator|->
name|len
argument_list|,
name|LDNS_RR_TYPE_NSEC3
argument_list|,
name|zone
operator|->
name|dclass
argument_list|,
literal|0
argument_list|,
name|region
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nc_rrset
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|neg_params_ok
argument_list|(
name|zone
argument_list|,
name|nc_rrset
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|nc_rrset
return|;
block|}
end_function

begin_comment
comment|/** neg cache nsec3 proof procedure*/
end_comment

begin_function
specifier|static
name|struct
name|dns_msg
modifier|*
name|neg_nsec3_proof_ds
parameter_list|(
name|struct
name|val_neg_zone
modifier|*
name|zone
parameter_list|,
name|uint8_t
modifier|*
name|qname
parameter_list|,
name|size_t
name|qname_len
parameter_list|,
name|int
name|qlabs
parameter_list|,
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|struct
name|rrset_cache
modifier|*
name|rrset_cache
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|time_t
name|now
parameter_list|,
name|uint8_t
modifier|*
name|topname
parameter_list|)
block|{
name|struct
name|dns_msg
modifier|*
name|msg
decl_stmt|;
name|struct
name|val_neg_data
modifier|*
name|data
decl_stmt|;
name|uint8_t
name|hashnc
index|[
name|NSEC3_SHA_LEN
index|]
decl_stmt|;
name|size_t
name|nclen
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|ce_rrset
decl_stmt|,
modifier|*
name|nc_rrset
decl_stmt|;
name|struct
name|nsec3_cached_hash
name|c
decl_stmt|;
name|uint8_t
name|nc_b32
index|[
literal|257
index|]
decl_stmt|;
comment|/* for NSEC3 ; determine the closest encloser for which we 	 * can find an exact match. Remember the hashed lower name, 	 * since that is the one we need a closest match for.  	 * If we find a match straight away, then it becomes NODATA. 	 * Otherwise, NXDOMAIN or if OPTOUT, an insecure delegation. 	 * Also check that parameters are the same on closest encloser 	 * and on closest match. 	 */
if|if
condition|(
operator|!
name|zone
operator|->
name|nsec3_hash
condition|)
return|return
name|NULL
return|;
comment|/* not nsec3 zone */
if|if
condition|(
operator|!
operator|(
name|data
operator|=
name|neg_find_nsec3_ce
argument_list|(
name|zone
argument_list|,
name|qname
argument_list|,
name|qname_len
argument_list|,
name|qlabs
argument_list|,
name|buf
argument_list|,
name|hashnc
argument_list|,
operator|&
name|nclen
argument_list|)
operator|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
comment|/* grab the ce rrset */
name|ce_rrset
operator|=
name|grab_nsec
argument_list|(
name|rrset_cache
argument_list|,
name|data
operator|->
name|name
argument_list|,
name|data
operator|->
name|len
argument_list|,
name|LDNS_RR_TYPE_NSEC3
argument_list|,
name|zone
operator|->
name|dclass
argument_list|,
literal|0
argument_list|,
name|region
argument_list|,
literal|1
argument_list|,
name|LDNS_RR_TYPE_DS
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ce_rrset
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|neg_params_ok
argument_list|(
name|zone
argument_list|,
name|ce_rrset
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|nclen
operator|==
literal|0
condition|)
block|{
comment|/* exact match, just check the type bits */
comment|/* need: -SOA, -DS, +NS */
if|if
condition|(
name|nsec3_has_type
argument_list|(
name|ce_rrset
argument_list|,
literal|0
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|)
operator|||
name|nsec3_has_type
argument_list|(
name|ce_rrset
argument_list|,
literal|0
argument_list|,
name|LDNS_RR_TYPE_DS
argument_list|)
operator|||
operator|!
name|nsec3_has_type
argument_list|(
name|ce_rrset
argument_list|,
literal|0
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
operator|(
name|msg
operator|=
name|dns_msg_create
argument_list|(
name|qname
argument_list|,
name|qname_len
argument_list|,
name|LDNS_RR_TYPE_DS
argument_list|,
name|zone
operator|->
name|dclass
argument_list|,
name|region
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* TTL reduced in grab_nsec */
if|if
condition|(
operator|!
name|dns_msg_authadd
argument_list|(
name|msg
argument_list|,
name|region
argument_list|,
name|ce_rrset
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|msg
return|;
block|}
comment|/* optout is not allowed without knowing the trust-anchor in use, 	 * otherwise the optout could spoof away that anchor */
if|if
condition|(
operator|!
name|topname
condition|)
return|return
name|NULL
return|;
comment|/* if there is no exact match, it must be in an optout span 	 * (an existing DS implies an NSEC3 must exist) */
name|nc_rrset
operator|=
name|neg_nsec3_getnc
argument_list|(
name|zone
argument_list|,
name|hashnc
argument_list|,
name|nclen
argument_list|,
name|rrset_cache
argument_list|,
name|region
argument_list|,
name|now
argument_list|,
name|nc_b32
argument_list|,
sizeof|sizeof
argument_list|(
name|nc_b32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nc_rrset
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|neg_params_ok
argument_list|(
name|zone
argument_list|,
name|nc_rrset
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|nsec3_has_optout
argument_list|(
name|nc_rrset
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
name|c
operator|.
name|hash
operator|=
name|hashnc
expr_stmt|;
name|c
operator|.
name|hash_len
operator|=
name|nclen
expr_stmt|;
name|c
operator|.
name|b32
operator|=
name|nc_b32
operator|+
literal|1
expr_stmt|;
name|c
operator|.
name|b32_len
operator|=
operator|(
name|size_t
operator|)
name|nc_b32
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|nsec3_covers
argument_list|(
name|zone
operator|->
name|name
argument_list|,
operator|&
name|c
argument_list|,
name|nc_rrset
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|)
condition|)
block|{
comment|/* nc_rrset covers the next closer name. 		 * ce_rrset equals a closer encloser. 		 * nc_rrset is optout. 		 * No need to check wildcard for type DS */
comment|/* capacity=3: ce + nc + soa(if needed) */
if|if
condition|(
operator|!
operator|(
name|msg
operator|=
name|dns_msg_create
argument_list|(
name|qname
argument_list|,
name|qname_len
argument_list|,
name|LDNS_RR_TYPE_DS
argument_list|,
name|zone
operator|->
name|dclass
argument_list|,
name|region
argument_list|,
literal|3
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* now=0 because TTL was reduced in grab_nsec */
if|if
condition|(
operator|!
name|dns_msg_authadd
argument_list|(
name|msg
argument_list|,
name|region
argument_list|,
name|ce_rrset
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|dns_msg_authadd
argument_list|(
name|msg
argument_list|,
name|region
argument_list|,
name|nc_rrset
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|msg
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * Add SOA record for external responses.  * @param rrset_cache: to look into.  * @param now: current time.  * @param region: where to perform the allocation  * @param msg: current msg with NSEC.  * @param zone: val_neg_zone if we have one.  * @return false on lookup or alloc failure.  */
end_comment

begin_function
specifier|static
name|int
name|add_soa
parameter_list|(
name|struct
name|rrset_cache
modifier|*
name|rrset_cache
parameter_list|,
name|time_t
name|now
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|dns_msg
modifier|*
name|msg
parameter_list|,
name|struct
name|val_neg_zone
modifier|*
name|zone
parameter_list|)
block|{
name|struct
name|ub_packed_rrset_key
modifier|*
name|soa
decl_stmt|;
name|uint8_t
modifier|*
name|nm
decl_stmt|;
name|size_t
name|nmlen
decl_stmt|;
name|uint16_t
name|dclass
decl_stmt|;
if|if
condition|(
name|zone
condition|)
block|{
name|nm
operator|=
name|zone
operator|->
name|name
expr_stmt|;
name|nmlen
operator|=
name|zone
operator|->
name|len
expr_stmt|;
name|dclass
operator|=
name|zone
operator|->
name|dclass
expr_stmt|;
block|}
else|else
block|{
comment|/* Assumes the signer is the zone SOA to add */
name|nm
operator|=
name|reply_nsec_signer
argument_list|(
name|msg
operator|->
name|rep
argument_list|,
operator|&
name|nmlen
argument_list|,
operator|&
name|dclass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nm
condition|)
return|return
literal|0
return|;
block|}
name|soa
operator|=
name|rrset_cache_lookup
argument_list|(
name|rrset_cache
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|,
name|dclass
argument_list|,
name|PACKED_RRSET_SOA_NEG
argument_list|,
name|now
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|soa
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|dns_msg_authadd
argument_list|(
name|msg
argument_list|,
name|region
argument_list|,
name|soa
argument_list|,
name|now
argument_list|)
condition|)
block|{
name|lock_rw_unlock
argument_list|(
operator|&
name|soa
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lock_rw_unlock
argument_list|(
operator|&
name|soa
operator|->
name|entry
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|struct
name|dns_msg
modifier|*
name|val_neg_getmsg
parameter_list|(
name|struct
name|val_neg_cache
modifier|*
name|neg
parameter_list|,
name|struct
name|query_info
modifier|*
name|qinfo
parameter_list|,
name|struct
name|regional
modifier|*
name|region
parameter_list|,
name|struct
name|rrset_cache
modifier|*
name|rrset_cache
parameter_list|,
name|sldns_buffer
modifier|*
name|buf
parameter_list|,
name|time_t
name|now
parameter_list|,
name|int
name|addsoa
parameter_list|,
name|uint8_t
modifier|*
name|topname
parameter_list|)
block|{
name|struct
name|dns_msg
modifier|*
name|msg
decl_stmt|;
name|struct
name|ub_packed_rrset_key
modifier|*
name|rrset
decl_stmt|;
name|uint8_t
modifier|*
name|zname
decl_stmt|;
name|size_t
name|zname_len
decl_stmt|;
name|int
name|zname_labs
decl_stmt|;
name|struct
name|val_neg_zone
modifier|*
name|zone
decl_stmt|;
comment|/* only for DS queries */
if|if
condition|(
name|qinfo
operator|->
name|qtype
operator|!=
name|LDNS_RR_TYPE_DS
condition|)
return|return
name|NULL
return|;
name|log_assert
argument_list|(
operator|!
name|topname
operator|||
name|dname_subdomain_c
argument_list|(
name|qinfo
operator|->
name|qname
argument_list|,
name|topname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* see if info from neg cache is available  	 * For NSECs, because there is no optout; a DS next to a delegation 	 * always has exactly an NSEC for it itself; check its DS bit. 	 * flags=0 (not the zone apex). 	 */
name|rrset
operator|=
name|grab_nsec
argument_list|(
name|rrset_cache
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|,
name|qinfo
operator|->
name|qname_len
argument_list|,
name|LDNS_RR_TYPE_NSEC
argument_list|,
name|qinfo
operator|->
name|qclass
argument_list|,
literal|0
argument_list|,
name|region
argument_list|,
literal|1
argument_list|,
name|qinfo
operator|->
name|qtype
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrset
condition|)
block|{
comment|/* return msg with that rrset */
if|if
condition|(
operator|!
operator|(
name|msg
operator|=
name|dns_msg_create
argument_list|(
name|qinfo
operator|->
name|qname
argument_list|,
name|qinfo
operator|->
name|qname_len
argument_list|,
name|qinfo
operator|->
name|qtype
argument_list|,
name|qinfo
operator|->
name|qclass
argument_list|,
name|region
argument_list|,
literal|2
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* TTL already subtracted in grab_nsec */
if|if
condition|(
operator|!
name|dns_msg_authadd
argument_list|(
name|msg
argument_list|,
name|region
argument_list|,
name|rrset
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|addsoa
operator|&&
operator|!
name|add_soa
argument_list|(
name|rrset_cache
argument_list|,
name|now
argument_list|,
name|region
argument_list|,
name|msg
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|msg
return|;
block|}
comment|/* check NSEC3 neg cache for type DS */
comment|/* need to look one zone higher for DS type */
name|zname
operator|=
name|qinfo
operator|->
name|qname
expr_stmt|;
name|zname_len
operator|=
name|qinfo
operator|->
name|qname_len
expr_stmt|;
name|dname_remove_label
argument_list|(
operator|&
name|zname
argument_list|,
operator|&
name|zname_len
argument_list|)
expr_stmt|;
name|zname_labs
operator|=
name|dname_count_labels
argument_list|(
name|zname
argument_list|)
expr_stmt|;
comment|/* lookup closest zone */
name|lock_basic_lock
argument_list|(
operator|&
name|neg
operator|->
name|lock
argument_list|)
expr_stmt|;
name|zone
operator|=
name|neg_closest_zone_parent
argument_list|(
name|neg
argument_list|,
name|zname
argument_list|,
name|zname_len
argument_list|,
name|zname_labs
argument_list|,
name|qinfo
operator|->
name|qclass
argument_list|)
expr_stmt|;
while|while
condition|(
name|zone
operator|&&
operator|!
name|zone
operator|->
name|in_use
condition|)
name|zone
operator|=
name|zone
operator|->
name|parent
expr_stmt|;
comment|/* check that the zone is not too high up so that we do not pick data 	 * out of a zone that is above the last-seen key (or trust-anchor). */
if|if
condition|(
name|zone
operator|&&
name|topname
condition|)
block|{
if|if
condition|(
operator|!
name|dname_subdomain_c
argument_list|(
name|zone
operator|->
name|name
argument_list|,
name|topname
argument_list|)
condition|)
name|zone
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|zone
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|neg
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|msg
operator|=
name|neg_nsec3_proof_ds
argument_list|(
name|zone
argument_list|,
name|qinfo
operator|->
name|qname
argument_list|,
name|qinfo
operator|->
name|qname_len
argument_list|,
name|zname_labs
operator|+
literal|1
argument_list|,
name|buf
argument_list|,
name|rrset_cache
argument_list|,
name|region
argument_list|,
name|now
argument_list|,
name|topname
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|&&
name|addsoa
operator|&&
operator|!
name|add_soa
argument_list|(
name|rrset_cache
argument_list|,
name|now
argument_list|,
name|region
argument_list|,
name|msg
argument_list|,
name|zone
argument_list|)
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|neg
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|neg
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|msg
return|;
block|}
end_function

end_unit

