begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Disassembler code for CRIS.    Copyright 2000, 2001, 2002, 2004, 2005 Free Software Foundation, Inc.    Contributed by Axis Communications AB, Lund, Sweden.    Written by Hans-Peter Nilsson.     This file is part of the GNU binutils and GDB, the GNU debugger.     This program is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any later    version.     This program is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for    more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,    MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"opcode/cris.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* No instruction will be disassembled longer than this.  In theory, and    in silicon, address prefixes can be cascaded.  In practice, cascading    is not used by GCC, and not supported by the assembler.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_BYTES_PER_CRIS_INSN
end_ifndef

begin_define
define|#
directive|define
name|MAX_BYTES_PER_CRIS_INSN
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Whether or not to decode prefixes, folding it into the following    instruction.  FIXME: Make this optional later.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PARSE_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|PARSE_PREFIX
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Sometimes we prefix all registers with this character.  */
end_comment

begin_define
define|#
directive|define
name|REGISTER_PREFIX_CHAR
value|'$'
end_define

begin_comment
comment|/* Whether or not to trace the following sequence:    sub* X,r%d    bound* Y,r%d    adds.w [pc+r%d.w],pc     This is the assembly form of a switch-statement in C.    The "sub is optional.  If there is none, then X will be zero.    X is the value of the first case,    Y is the number of cases (including default).     This results in case offsets printed on the form:     case N: -> case_address    where N is an estimation on the corresponding 'case' operand in C,    and case_address is where execution of that case continues after the    sequence presented above.     The old style of output was to print the offsets as instructions,    which made it hard to follow "case"-constructs in the disassembly,    and caused a lot of annoying warnings about undefined instructions.     FIXME: Make this optional later.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TRACE_CASE
end_ifndef

begin_define
define|#
directive|define
name|TRACE_CASE
value|(disdata->trace_case)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_enum
enum|enum
name|cris_disass_family
block|{
name|cris_dis_v0_v10
block|,
name|cris_dis_common_v10_v32
block|,
name|cris_dis_v32
block|}
enum|;
end_enum

begin_comment
comment|/* Stored in the disasm_info->private_data member.  */
end_comment

begin_struct
struct|struct
name|cris_disasm_data
block|{
comment|/* Whether to print something less confusing if we find something      matching a switch-construct.  */
name|bfd_boolean
name|trace_case
decl_stmt|;
comment|/* Whether this code is flagged as crisv32.  FIXME: Should be an enum      that includes "compatible".  */
name|enum
name|cris_disass_family
name|distype
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Value of first element in switch.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|case_offset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How many more case-offsets to print.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|case_offset_counter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of case offsets.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|no_of_case_offsets
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Candidate for next case_offset.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|last_immediate
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|cris_constraint
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
name|unsigned
parameter_list|,
name|struct
name|cris_disasm_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Parse disassembler options and store state in info.  FIXME: For the    time being, we abuse static variables.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|cris_parse_disassembler_options
parameter_list|(
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|enum
name|cris_disass_family
name|distype
parameter_list|)
block|{
name|struct
name|cris_disasm_data
modifier|*
name|disdata
decl_stmt|;
name|info
operator|->
name|private_data
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cris_disasm_data
argument_list|)
argument_list|)
expr_stmt|;
name|disdata
operator|=
operator|(
expr|struct
name|cris_disasm_data
operator|*
operator|)
name|info
operator|->
name|private_data
expr_stmt|;
if|if
condition|(
name|disdata
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Default true.  */
name|disdata
operator|->
name|trace_case
operator|=
operator|(
name|info
operator|->
name|disassembler_options
operator|==
name|NULL
operator|||
operator|(
name|strcmp
argument_list|(
name|info
operator|->
name|disassembler_options
argument_list|,
literal|"nocase"
argument_list|)
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
name|disdata
operator|->
name|distype
operator|=
name|distype
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|cris_spec_reg
modifier|*
name|spec_reg_info
parameter_list|(
name|unsigned
name|int
name|sreg
parameter_list|,
name|enum
name|cris_disass_family
name|distype
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cris_spec_regs
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cris_spec_regs
index|[
name|i
index|]
operator|.
name|number
operator|==
name|sreg
condition|)
block|{
if|if
condition|(
name|distype
operator|==
name|cris_dis_v32
condition|)
switch|switch
condition|(
name|cris_spec_regs
index|[
name|i
index|]
operator|.
name|applicable_version
condition|)
block|{
case|case
name|cris_ver_warning
case|:
case|case
name|cris_ver_version_all
case|:
case|case
name|cris_ver_v3p
case|:
case|case
name|cris_ver_v8p
case|:
case|case
name|cris_ver_v10p
case|:
case|case
name|cris_ver_v32p
case|:
comment|/* No ambiguous sizes or register names with CRISv32.  */
if|if
condition|(
name|cris_spec_regs
index|[
name|i
index|]
operator|.
name|warning
operator|==
name|NULL
condition|)
return|return
operator|&
name|cris_spec_regs
index|[
name|i
index|]
return|;
default|default:
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|cris_spec_regs
index|[
name|i
index|]
operator|.
name|applicable_version
operator|!=
name|cris_ver_v32p
condition|)
return|return
operator|&
name|cris_spec_regs
index|[
name|i
index|]
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the number of bits in the argument.  */
end_comment

begin_function
specifier|static
name|int
name|number_of_bits
parameter_list|(
name|unsigned
name|int
name|val
parameter_list|)
block|{
name|int
name|bits
decl_stmt|;
for|for
control|(
name|bits
operator|=
literal|0
init|;
name|val
operator|!=
literal|0
condition|;
name|val
operator|&=
name|val
operator|-
literal|1
control|)
name|bits
operator|++
expr_stmt|;
return|return
name|bits
return|;
block|}
end_function

begin_comment
comment|/* Get an entry in the opcode-table.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|cris_opcode
modifier|*
name|get_opcode_entry
parameter_list|(
name|unsigned
name|int
name|insn
parameter_list|,
name|unsigned
name|int
name|prefix_insn
parameter_list|,
name|struct
name|cris_disasm_data
modifier|*
name|disdata
parameter_list|)
block|{
comment|/* For non-prefixed insns, we keep a table of pointers, indexed by the      insn code.  Each entry is initialized when found to be NULL.  */
specifier|static
specifier|const
name|struct
name|cris_opcode
modifier|*
modifier|*
name|opc_table
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|cris_opcode
modifier|*
name|max_matchedp
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|cris_opcode
modifier|*
modifier|*
name|prefix_opc_table
init|=
name|NULL
decl_stmt|;
comment|/* We hold a table for each prefix that need to be handled differently.  */
specifier|static
specifier|const
name|struct
name|cris_opcode
modifier|*
modifier|*
name|dip_prefixes
init|=
name|NULL
decl_stmt|;
specifier|static
specifier|const
name|struct
name|cris_opcode
modifier|*
modifier|*
name|bdapq_m1_prefixes
init|=
name|NULL
decl_stmt|;
specifier|static
specifier|const
name|struct
name|cris_opcode
modifier|*
modifier|*
name|bdapq_m2_prefixes
init|=
name|NULL
decl_stmt|;
specifier|static
specifier|const
name|struct
name|cris_opcode
modifier|*
modifier|*
name|bdapq_m4_prefixes
init|=
name|NULL
decl_stmt|;
specifier|static
specifier|const
name|struct
name|cris_opcode
modifier|*
modifier|*
name|rest_prefixes
init|=
name|NULL
decl_stmt|;
comment|/* Allocate and clear the opcode-table.  */
if|if
condition|(
name|opc_table
operator|==
name|NULL
condition|)
block|{
name|opc_table
operator|=
name|malloc
argument_list|(
literal|65536
operator|*
sizeof|sizeof
argument_list|(
name|opc_table
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opc_table
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|opc_table
argument_list|,
literal|0
argument_list|,
literal|65536
operator|*
sizeof|sizeof
argument_list|(
specifier|const
expr|struct
name|cris_opcode
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|dip_prefixes
operator|=
name|malloc
argument_list|(
literal|65536
operator|*
sizeof|sizeof
argument_list|(
specifier|const
expr|struct
name|cris_opcode
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dip_prefixes
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|dip_prefixes
argument_list|,
literal|0
argument_list|,
literal|65536
operator|*
sizeof|sizeof
argument_list|(
name|dip_prefixes
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|bdapq_m1_prefixes
operator|=
name|malloc
argument_list|(
literal|65536
operator|*
sizeof|sizeof
argument_list|(
specifier|const
expr|struct
name|cris_opcode
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bdapq_m1_prefixes
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|bdapq_m1_prefixes
argument_list|,
literal|0
argument_list|,
literal|65536
operator|*
sizeof|sizeof
argument_list|(
name|bdapq_m1_prefixes
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|bdapq_m2_prefixes
operator|=
name|malloc
argument_list|(
literal|65536
operator|*
sizeof|sizeof
argument_list|(
specifier|const
expr|struct
name|cris_opcode
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bdapq_m2_prefixes
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|bdapq_m2_prefixes
argument_list|,
literal|0
argument_list|,
literal|65536
operator|*
sizeof|sizeof
argument_list|(
name|bdapq_m2_prefixes
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|bdapq_m4_prefixes
operator|=
name|malloc
argument_list|(
literal|65536
operator|*
sizeof|sizeof
argument_list|(
specifier|const
expr|struct
name|cris_opcode
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bdapq_m4_prefixes
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|bdapq_m4_prefixes
argument_list|,
literal|0
argument_list|,
literal|65536
operator|*
sizeof|sizeof
argument_list|(
name|bdapq_m4_prefixes
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|rest_prefixes
operator|=
name|malloc
argument_list|(
literal|65536
operator|*
sizeof|sizeof
argument_list|(
specifier|const
expr|struct
name|cris_opcode
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rest_prefixes
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|rest_prefixes
argument_list|,
literal|0
argument_list|,
literal|65536
operator|*
sizeof|sizeof
argument_list|(
name|rest_prefixes
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Get the right table if this is a prefix.      This code is connected to cris_constraints in that it knows what      prefixes play a role in recognition of patterns; the necessary      state is reflected by which table is used.  If constraints      involving match or non-match of prefix insns are changed, then this      probably needs changing too.  */
if|if
condition|(
name|prefix_insn
operator|!=
name|NO_CRIS_PREFIX
condition|)
block|{
specifier|const
name|struct
name|cris_opcode
modifier|*
name|popcodep
init|=
operator|(
name|opc_table
index|[
name|prefix_insn
index|]
operator|!=
name|NULL
condition|?
name|opc_table
index|[
name|prefix_insn
index|]
else|:
name|get_opcode_entry
argument_list|(
name|prefix_insn
argument_list|,
name|NO_CRIS_PREFIX
argument_list|,
name|disdata
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|popcodep
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|popcodep
operator|->
name|match
operator|==
name|BDAP_QUICK_OPCODE
condition|)
block|{
comment|/* Since some offsets are recognized with "push" macros, we 	     have to have different tables for them.  */
name|int
name|offset
init|=
operator|(
name|prefix_insn
operator|&
literal|255
operator|)
decl_stmt|;
if|if
condition|(
name|offset
operator|>
literal|127
condition|)
name|offset
operator|-=
literal|256
expr_stmt|;
switch|switch
condition|(
name|offset
condition|)
block|{
case|case
operator|-
literal|4
case|:
name|prefix_opc_table
operator|=
name|bdapq_m4_prefixes
expr_stmt|;
break|break;
case|case
operator|-
literal|2
case|:
name|prefix_opc_table
operator|=
name|bdapq_m2_prefixes
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
name|prefix_opc_table
operator|=
name|bdapq_m1_prefixes
expr_stmt|;
break|break;
default|default:
name|prefix_opc_table
operator|=
name|rest_prefixes
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|popcodep
operator|->
name|match
operator|==
name|DIP_OPCODE
condition|)
comment|/* We don't allow postincrement when the prefix is DIP, so use a 	   different table for DIP.  */
name|prefix_opc_table
operator|=
name|dip_prefixes
expr_stmt|;
else|else
name|prefix_opc_table
operator|=
name|rest_prefixes
expr_stmt|;
block|}
if|if
condition|(
name|prefix_insn
operator|!=
name|NO_CRIS_PREFIX
operator|&&
name|prefix_opc_table
index|[
name|insn
index|]
operator|!=
name|NULL
condition|)
name|max_matchedp
operator|=
name|prefix_opc_table
index|[
name|insn
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|prefix_insn
operator|==
name|NO_CRIS_PREFIX
operator|&&
name|opc_table
index|[
name|insn
index|]
operator|!=
name|NULL
condition|)
name|max_matchedp
operator|=
name|opc_table
index|[
name|insn
index|]
expr_stmt|;
else|else
block|{
specifier|const
name|struct
name|cris_opcode
modifier|*
name|opcodep
decl_stmt|;
name|int
name|max_level_of_match
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|opcodep
operator|=
name|cris_opcodes
init|;
name|opcodep
operator|->
name|name
operator|!=
name|NULL
condition|;
name|opcodep
operator|++
control|)
block|{
name|int
name|level_of_match
decl_stmt|;
if|if
condition|(
name|disdata
operator|->
name|distype
operator|==
name|cris_dis_v32
condition|)
block|{
switch|switch
condition|(
name|opcodep
operator|->
name|applicable_version
condition|)
block|{
case|case
name|cris_ver_version_all
case|:
break|break;
case|case
name|cris_ver_v0_3
case|:
case|case
name|cris_ver_v0_10
case|:
case|case
name|cris_ver_v3_10
case|:
case|case
name|cris_ver_sim_v0_10
case|:
case|case
name|cris_ver_v8_10
case|:
case|case
name|cris_ver_v10
case|:
case|case
name|cris_ver_warning
case|:
continue|continue;
case|case
name|cris_ver_v3p
case|:
case|case
name|cris_ver_v8p
case|:
case|case
name|cris_ver_v10p
case|:
case|case
name|cris_ver_v32p
case|:
break|break;
case|case
name|cris_ver_v8
case|:
name|abort
argument_list|()
expr_stmt|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|opcodep
operator|->
name|applicable_version
condition|)
block|{
case|case
name|cris_ver_version_all
case|:
case|case
name|cris_ver_v0_3
case|:
case|case
name|cris_ver_v3p
case|:
case|case
name|cris_ver_v0_10
case|:
case|case
name|cris_ver_v8p
case|:
case|case
name|cris_ver_v8_10
case|:
case|case
name|cris_ver_v10
case|:
case|case
name|cris_ver_sim_v0_10
case|:
case|case
name|cris_ver_v10p
case|:
case|case
name|cris_ver_warning
case|:
break|break;
case|case
name|cris_ver_v32p
case|:
continue|continue;
case|case
name|cris_ver_v8
case|:
name|abort
argument_list|()
expr_stmt|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* We give a double lead for bits matching the template in 	     cris_opcodes.  Not even, because then "move p8,r10" would 	     be given 2 bits lead over "clear.d r10".  When there's a 	     tie, the first entry in the table wins.  This is 	     deliberate, to avoid a more complicated recognition 	     formula.  */
if|if
condition|(
operator|(
name|opcodep
operator|->
name|match
operator|&
name|insn
operator|)
operator|==
name|opcodep
operator|->
name|match
operator|&&
operator|(
name|opcodep
operator|->
name|lose
operator|&
name|insn
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|level_of_match
operator|=
name|cris_constraint
argument_list|(
name|opcodep
operator|->
name|args
argument_list|,
name|insn
argument_list|,
name|prefix_insn
argument_list|,
name|disdata
argument_list|)
operator|)
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|level_of_match
operator|+=
literal|2
operator|*
name|number_of_bits
argument_list|(
name|opcodep
operator|->
name|match
operator||
name|opcodep
operator|->
name|lose
argument_list|)
operator|)
operator|>
name|max_level_of_match
operator|)
condition|)
block|{
name|max_matchedp
operator|=
name|opcodep
expr_stmt|;
name|max_level_of_match
operator|=
name|level_of_match
expr_stmt|;
comment|/* If there was a full match, never mind looking 			 further.  */
if|if
condition|(
name|level_of_match
operator|>=
literal|2
operator|*
literal|16
condition|)
break|break;
block|}
block|}
comment|/* Fill in the new entry.  	 If there are changes to the opcode-table involving prefixes, and 	 disassembly then does not work correctly, try removing the 	 else-clause below that fills in the prefix-table.  If that 	 helps, you need to change the prefix_opc_table setting above, or 	 something related.  */
if|if
condition|(
name|prefix_insn
operator|==
name|NO_CRIS_PREFIX
condition|)
name|opc_table
index|[
name|insn
index|]
operator|=
name|max_matchedp
expr_stmt|;
else|else
name|prefix_opc_table
index|[
name|insn
index|]
operator|=
name|max_matchedp
expr_stmt|;
block|}
return|return
name|max_matchedp
return|;
block|}
end_function

begin_comment
comment|/* Return -1 if the constraints of a bitwise-matched instruction say    that there is no match.  Otherwise return a nonnegative number    indicating the confidence in the match (higher is better).  */
end_comment

begin_function
specifier|static
name|int
name|cris_constraint
parameter_list|(
specifier|const
name|char
modifier|*
name|cs
parameter_list|,
name|unsigned
name|int
name|insn
parameter_list|,
name|unsigned
name|int
name|prefix_insn
parameter_list|,
name|struct
name|cris_disasm_data
modifier|*
name|disdata
parameter_list|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|int
name|prefix_ok
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|cs
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'!'
case|:
comment|/* Do not recognize "pop" if there's a prefix and then only for            v0..v10.  */
if|if
condition|(
name|prefix_insn
operator|!=
name|NO_CRIS_PREFIX
operator|||
name|disdata
operator|->
name|distype
operator|!=
name|cris_dis_v0_v10
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
literal|'U'
case|:
comment|/* Not recognized at disassembly.  */
return|return
operator|-
literal|1
return|;
case|case
literal|'M'
case|:
comment|/* Size modifier for "clear", i.e. special register 0, 4 or 8. 	   Check that it is one of them.  Only special register 12 could 	   be mismatched, but checking for matches is more logical than 	   checking for mismatches when there are only a few cases.  */
name|tmp
operator|=
operator|(
operator|(
name|insn
operator|>>
literal|12
operator|)
operator|&
literal|0xf
operator|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
literal|0
operator|&&
name|tmp
operator|!=
literal|4
operator|&&
name|tmp
operator|!=
literal|8
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x30
operator|)
operator|==
literal|0x30
condition|)
return|return
operator|-
literal|1
return|;
break|break;
case|case
literal|'S'
case|:
comment|/* A prefix operand without side-effect.  */
if|if
condition|(
name|prefix_insn
operator|!=
name|NO_CRIS_PREFIX
operator|&&
operator|(
name|insn
operator|&
literal|0x400
operator|)
operator|==
literal|0
condition|)
block|{
name|prefix_ok
operator|=
literal|1
expr_stmt|;
break|break;
block|}
else|else
return|return
operator|-
literal|1
return|;
case|case
literal|'s'
case|:
case|case
literal|'y'
case|:
case|case
literal|'Y'
case|:
comment|/* If this is a prefixed insn with postincrement (side-effect), 	   the prefix must not be DIP.  */
if|if
condition|(
name|prefix_insn
operator|!=
name|NO_CRIS_PREFIX
condition|)
block|{
if|if
condition|(
name|insn
operator|&
literal|0x400
condition|)
block|{
specifier|const
name|struct
name|cris_opcode
modifier|*
name|prefix_opcodep
init|=
name|get_opcode_entry
argument_list|(
name|prefix_insn
argument_list|,
name|NO_CRIS_PREFIX
argument_list|,
name|disdata
argument_list|)
decl_stmt|;
if|if
condition|(
name|prefix_opcodep
operator|->
name|match
operator|==
name|DIP_OPCODE
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|prefix_ok
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'B'
case|:
comment|/* If we don't fall through, then the prefix is ok.  */
name|prefix_ok
operator|=
literal|1
expr_stmt|;
comment|/* A "push" prefix.  Check for valid "push" size. 	   In case of special register, it may be != 4.  */
if|if
condition|(
name|prefix_insn
operator|!=
name|NO_CRIS_PREFIX
condition|)
block|{
comment|/* Match the prefix insn to BDAPQ.  */
specifier|const
name|struct
name|cris_opcode
modifier|*
name|prefix_opcodep
init|=
name|get_opcode_entry
argument_list|(
name|prefix_insn
argument_list|,
name|NO_CRIS_PREFIX
argument_list|,
name|disdata
argument_list|)
decl_stmt|;
if|if
condition|(
name|prefix_opcodep
operator|->
name|match
operator|==
name|BDAP_QUICK_OPCODE
condition|)
block|{
name|int
name|pushsize
init|=
operator|(
name|prefix_insn
operator|&
literal|255
operator|)
decl_stmt|;
if|if
condition|(
name|pushsize
operator|>
literal|127
condition|)
name|pushsize
operator|-=
literal|256
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'P'
condition|)
block|{
name|unsigned
name|int
name|spec_reg
init|=
operator|(
name|insn
operator|>>
literal|12
operator|)
operator|&
literal|15
decl_stmt|;
specifier|const
name|struct
name|cris_spec_reg
modifier|*
name|sregp
init|=
name|spec_reg_info
argument_list|(
name|spec_reg
argument_list|,
name|disdata
operator|->
name|distype
argument_list|)
decl_stmt|;
comment|/* For a special-register, the "prefix size" must 		       match the size of the register.  */
if|if
condition|(
name|sregp
operator|&&
name|sregp
operator|->
name|reg_size
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
name|pushsize
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'R'
condition|)
block|{
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x30
operator|)
operator|==
literal|0x20
operator|&&
name|pushsize
operator|==
operator|-
literal|4
condition|)
break|break;
block|}
comment|/* FIXME:  Should abort here; next constraint letter 		   *must* be 'P' or 'R'.  */
block|}
block|}
return|return
operator|-
literal|1
return|;
case|case
literal|'D'
case|:
name|retval
operator|=
operator|(
operator|(
operator|(
name|insn
operator|>>
literal|12
operator|)
operator|&
literal|15
operator|)
operator|==
operator|(
name|insn
operator|&
literal|15
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|retval
condition|)
return|return
operator|-
literal|1
return|;
else|else
name|retval
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
block|{
specifier|const
name|struct
name|cris_spec_reg
modifier|*
name|sregp
init|=
name|spec_reg_info
argument_list|(
operator|(
name|insn
operator|>>
literal|12
operator|)
operator|&
literal|15
argument_list|,
name|disdata
operator|->
name|distype
argument_list|)
decl_stmt|;
comment|/* Since we match four bits, we will give a value of 4-1 = 3 	     in a match.  If there is a corresponding exact match of a 	     special register in another pattern, it will get a value of 	     4, which will be higher.  This should be correct in that an 	     exact pattern would match better than a general pattern.  	     Note that there is a reason for not returning zero; the 	     pattern for "clear" is partly  matched in the bit-pattern 	     (the two lower bits must be zero), while the bit-pattern 	     for a move from a special register is matched in the 	     register constraint.  */
if|if
condition|(
name|sregp
operator|!=
name|NULL
condition|)
block|{
name|retval
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|prefix_insn
operator|!=
name|NO_CRIS_PREFIX
operator|&&
operator|!
name|prefix_ok
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Format number as hex with a leading "0x" into outbuffer.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|format_hex
parameter_list|(
name|unsigned
name|long
name|number
parameter_list|,
name|char
modifier|*
name|outbuffer
parameter_list|,
name|struct
name|cris_disasm_data
modifier|*
name|disdata
parameter_list|)
block|{
comment|/* Truncate negative numbers on>32-bit hosts.  */
name|number
operator|&=
literal|0xffffffff
expr_stmt|;
name|sprintf
argument_list|(
name|outbuffer
argument_list|,
literal|"0x%lx"
argument_list|,
name|number
argument_list|)
expr_stmt|;
comment|/* Save this value for the "case" support.  */
if|if
condition|(
name|TRACE_CASE
condition|)
name|last_immediate
operator|=
name|number
expr_stmt|;
return|return
name|outbuffer
operator|+
name|strlen
argument_list|(
name|outbuffer
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Format number as decimal into outbuffer.  Parameter signedp says    whether the number should be formatted as signed (!= 0) or    unsigned (== 0).  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|format_dec
parameter_list|(
name|long
name|number
parameter_list|,
name|char
modifier|*
name|outbuffer
parameter_list|,
name|int
name|signedp
parameter_list|)
block|{
name|last_immediate
operator|=
name|number
expr_stmt|;
name|sprintf
argument_list|(
name|outbuffer
argument_list|,
name|signedp
condition|?
literal|"%ld"
else|:
literal|"%lu"
argument_list|,
name|number
argument_list|)
expr_stmt|;
return|return
name|outbuffer
operator|+
name|strlen
argument_list|(
name|outbuffer
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Format the name of the general register regno into outbuffer.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|format_reg
parameter_list|(
name|struct
name|cris_disasm_data
modifier|*
name|disdata
parameter_list|,
name|int
name|regno
parameter_list|,
name|char
modifier|*
name|outbuffer_start
parameter_list|,
name|bfd_boolean
name|with_reg_prefix
parameter_list|)
block|{
name|char
modifier|*
name|outbuffer
init|=
name|outbuffer_start
decl_stmt|;
if|if
condition|(
name|with_reg_prefix
condition|)
operator|*
name|outbuffer
operator|++
operator|=
name|REGISTER_PREFIX_CHAR
expr_stmt|;
switch|switch
condition|(
name|regno
condition|)
block|{
case|case
literal|15
case|:
comment|/* For v32, there is no context in which we output PC.  */
if|if
condition|(
name|disdata
operator|->
name|distype
operator|==
name|cris_dis_v32
condition|)
name|strcpy
argument_list|(
name|outbuffer
argument_list|,
literal|"acr"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|outbuffer
argument_list|,
literal|"pc"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|strcpy
argument_list|(
name|outbuffer
argument_list|,
literal|"sp"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|outbuffer
argument_list|,
literal|"r%d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|outbuffer_start
operator|+
name|strlen
argument_list|(
name|outbuffer_start
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Format the name of a support register into outbuffer.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|format_sup_reg
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|,
name|char
modifier|*
name|outbuffer_start
parameter_list|,
name|bfd_boolean
name|with_reg_prefix
parameter_list|)
block|{
name|char
modifier|*
name|outbuffer
init|=
name|outbuffer_start
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|with_reg_prefix
condition|)
operator|*
name|outbuffer
operator|++
operator|=
name|REGISTER_PREFIX_CHAR
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cris_support_regs
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cris_support_regs
index|[
name|i
index|]
operator|.
name|number
operator|==
name|regno
condition|)
block|{
name|sprintf
argument_list|(
name|outbuffer
argument_list|,
literal|"%s"
argument_list|,
name|cris_support_regs
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
name|outbuffer_start
operator|+
name|strlen
argument_list|(
name|outbuffer_start
argument_list|)
return|;
block|}
comment|/* There's supposed to be register names covering all numbers, though      some may be generic names.  */
name|sprintf
argument_list|(
name|outbuffer
argument_list|,
literal|"format_sup_reg-BUG"
argument_list|)
expr_stmt|;
return|return
name|outbuffer_start
operator|+
name|strlen
argument_list|(
name|outbuffer_start
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the length of an instruction.  */
end_comment

begin_function
specifier|static
name|unsigned
name|bytes_to_skip
parameter_list|(
name|unsigned
name|int
name|insn
parameter_list|,
specifier|const
name|struct
name|cris_opcode
modifier|*
name|matchedp
parameter_list|,
name|enum
name|cris_disass_family
name|distype
parameter_list|,
specifier|const
name|struct
name|cris_opcode
modifier|*
name|prefix_matchedp
parameter_list|)
block|{
comment|/* Each insn is a word plus "immediate" operands.  */
name|unsigned
name|to_skip
init|=
literal|2
decl_stmt|;
specifier|const
name|char
modifier|*
name|template
init|=
name|matchedp
operator|->
name|args
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|template
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'s'
operator|||
operator|*
name|s
operator|==
literal|'N'
operator|||
operator|*
name|s
operator|==
literal|'Y'
operator|)
operator|&&
operator|(
name|insn
operator|&
literal|0x400
operator|)
operator|&&
operator|(
name|insn
operator|&
literal|15
operator|)
operator|==
literal|15
operator|&&
name|prefix_matchedp
operator|==
name|NULL
condition|)
block|{
comment|/* Immediate via [pc+], so we have to check the size of the 	   operand.  */
name|int
name|mode_size
init|=
literal|1
operator|<<
operator|(
operator|(
name|insn
operator|>>
literal|4
operator|)
operator|&
operator|(
operator|*
name|template
operator|==
literal|'z'
condition|?
literal|1
else|:
literal|3
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|matchedp
operator|->
name|imm_oprnd_size
operator|==
name|SIZE_FIX_32
condition|)
name|to_skip
operator|+=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|matchedp
operator|->
name|imm_oprnd_size
operator|==
name|SIZE_SPEC_REG
condition|)
block|{
specifier|const
name|struct
name|cris_spec_reg
modifier|*
name|sregp
init|=
name|spec_reg_info
argument_list|(
operator|(
name|insn
operator|>>
literal|12
operator|)
operator|&
literal|15
argument_list|,
name|distype
argument_list|)
decl_stmt|;
comment|/* FIXME: Improve error handling; should have been caught 	       earlier.  */
if|if
condition|(
name|sregp
operator|==
name|NULL
condition|)
return|return
literal|2
return|;
comment|/* PC is incremented by two, not one, for a byte.  Except on 	       CRISv32, where constants are always DWORD-size for 	       special registers.  */
name|to_skip
operator|+=
name|distype
operator|==
name|cris_dis_v32
condition|?
literal|4
else|:
operator|(
name|sregp
operator|->
name|reg_size
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
block|}
else|else
name|to_skip
operator|+=
operator|(
name|mode_size
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'n'
condition|)
name|to_skip
operator|+=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'b'
condition|)
name|to_skip
operator|+=
literal|2
expr_stmt|;
return|return
name|to_skip
return|;
block|}
end_function

begin_comment
comment|/* Print condition code flags.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|print_flags
parameter_list|(
name|struct
name|cris_disasm_data
modifier|*
name|disdata
parameter_list|,
name|unsigned
name|int
name|insn
parameter_list|,
name|char
modifier|*
name|cp
parameter_list|)
block|{
comment|/* Use the v8 (Etrax 100) flag definitions for disassembly.      The differences with v0 (Etrax 1..4) vs. Svinto are:       v0 'd'<=> v8 'm'       v0 'e'<=> v8 'b'.      FIXME: Emit v0..v3 flag names somehow.  */
specifier|static
specifier|const
name|char
name|v8_fnames
index|[]
init|=
literal|"cvznxibm"
decl_stmt|;
specifier|static
specifier|const
name|char
name|v32_fnames
index|[]
init|=
literal|"cvznxiup"
decl_stmt|;
specifier|const
name|char
modifier|*
name|fnames
init|=
name|disdata
operator|->
name|distype
operator|==
name|cris_dis_v32
condition|?
name|v32_fnames
else|:
name|v8_fnames
decl_stmt|;
name|unsigned
name|char
name|flagbits
init|=
operator|(
operator|(
operator|(
name|insn
operator|>>
literal|8
operator|)
operator|&
literal|0xf0
operator|)
operator||
operator|(
name|insn
operator|&
literal|15
operator|)
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|flagbits
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
operator|*
name|cp
operator|++
operator|=
name|fnames
index|[
name|i
index|]
expr_stmt|;
return|return
name|cp
return|;
block|}
end_function

begin_comment
comment|/* Print out an insn with its operands, and update the info->insn_type    fields.  The prefix_opcodep and the rest hold a prefix insn that is    supposed to be output as an address mode.  */
end_comment

begin_function
specifier|static
name|void
name|print_with_operands
parameter_list|(
specifier|const
name|struct
name|cris_opcode
modifier|*
name|opcodep
parameter_list|,
name|unsigned
name|int
name|insn
parameter_list|,
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|,
comment|/* If a prefix insn was before this insn (and is supposed 			to be output as an address), here is a description of 			it.  */
specifier|const
name|struct
name|cris_opcode
modifier|*
name|prefix_opcodep
parameter_list|,
name|unsigned
name|int
name|prefix_insn
parameter_list|,
name|unsigned
name|char
modifier|*
name|prefix_buffer
parameter_list|,
name|bfd_boolean
name|with_reg_prefix
parameter_list|)
block|{
comment|/* Get a buffer of somewhat reasonable size where we store      intermediate parts of the insn.  */
name|char
name|temp
index|[
sizeof|sizeof
argument_list|(
literal|".d [$r13=$r12-2147483648],$r10"
argument_list|)
operator|*
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|tp
init|=
name|temp
decl_stmt|;
specifier|static
specifier|const
name|char
name|mode_char
index|[]
init|=
literal|"bwd?"
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|cs
decl_stmt|;
name|struct
name|cris_disasm_data
modifier|*
name|disdata
init|=
operator|(
expr|struct
name|cris_disasm_data
operator|*
operator|)
name|info
operator|->
name|private_data
decl_stmt|;
comment|/* Print out the name first thing we do.  */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|opcodep
operator|->
name|name
argument_list|)
expr_stmt|;
name|cs
operator|=
name|opcodep
operator|->
name|args
expr_stmt|;
name|s
operator|=
name|cs
expr_stmt|;
comment|/* Ignore any prefix indicator.  */
if|if
condition|(
operator|*
name|s
operator|==
literal|'p'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'m'
operator|||
operator|*
name|s
operator|==
literal|'M'
operator|||
operator|*
name|s
operator|==
literal|'z'
condition|)
block|{
operator|*
name|tp
operator|++
operator|=
literal|'.'
expr_stmt|;
comment|/* Get the size-letter.  */
operator|*
name|tp
operator|++
operator|=
operator|*
name|s
operator|==
literal|'M'
condition|?
operator|(
name|insn
operator|&
literal|0x8000
condition|?
literal|'d'
else|:
name|insn
operator|&
literal|0x4000
condition|?
literal|'w'
else|:
literal|'b'
operator|)
else|:
name|mode_char
index|[
operator|(
name|insn
operator|>>
literal|4
operator|)
operator|&
operator|(
operator|*
name|s
operator|==
literal|'z'
condition|?
literal|1
else|:
literal|3
operator|)
index|]
expr_stmt|;
comment|/* Ignore the size and the space character that follows.  */
name|s
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Add a space if this isn't a long-branch, because for those will add      the condition part of the name later.  */
if|if
condition|(
name|opcodep
operator|->
name|match
operator|!=
operator|(
name|BRANCH_PC_LOW
operator|+
name|BRANCH_INCR_HIGH
operator|*
literal|256
operator|)
condition|)
operator|*
name|tp
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* Fill in the insn-type if deducible from the name (and there's no      better way).  */
if|if
condition|(
name|opcodep
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'j'
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|opcodep
operator|->
name|name
argument_list|,
literal|"jsr"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
comment|/* It's "jsr" or "jsrc".  */
name|info
operator|->
name|insn_type
operator|=
name|dis_jsr
expr_stmt|;
else|else
comment|/* Any other jump-type insn is considered a branch.  */
name|info
operator|->
name|insn_type
operator|=
name|dis_branch
expr_stmt|;
block|}
comment|/* We might know some more fields right now.  */
name|info
operator|->
name|branch_delay_insns
operator|=
name|opcodep
operator|->
name|delayed
expr_stmt|;
comment|/* Handle operands.  */
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'T'
case|:
name|tp
operator|=
name|format_sup_reg
argument_list|(
operator|(
name|insn
operator|>>
literal|12
operator|)
operator|&
literal|15
argument_list|,
name|tp
argument_list|,
name|with_reg_prefix
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
if|if
condition|(
name|with_reg_prefix
condition|)
operator|*
name|tp
operator|++
operator|=
name|REGISTER_PREFIX_CHAR
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|'a'
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|'c'
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|'r'
expr_stmt|;
break|break;
case|case
literal|'['
case|:
case|case
literal|']'
case|:
case|case
literal|','
case|:
operator|*
name|tp
operator|++
operator|=
operator|*
name|s
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
comment|/* Ignore at this point; used at earlier stages to avoid 	   recognition if there's a prefix at something that in other 	   ways looks like a "pop".  */
break|break;
case|case
literal|'d'
case|:
comment|/* Ignore.  This is an optional ".d " on the large one of 	   relaxable insns.  */
break|break;
case|case
literal|'B'
case|:
comment|/* This was the prefix that made this a "push".  We've already 	   handled it by recognizing it, so signal that the prefix is 	   handled by setting it to NULL.  */
name|prefix_opcodep
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
name|tp
operator|=
name|format_reg
argument_list|(
name|disdata
argument_list|,
name|insn
operator|&
literal|15
argument_list|,
name|tp
argument_list|,
name|with_reg_prefix
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|tp
operator|=
name|format_reg
argument_list|(
name|disdata
argument_list|,
operator|(
name|insn
operator|>>
literal|12
operator|)
operator|&
literal|15
argument_list|,
name|tp
argument_list|,
name|with_reg_prefix
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
block|{
comment|/* Like N but pc-relative to the start of the insn.  */
name|unsigned
name|long
name|number
init|=
operator|(
name|buffer
index|[
literal|2
index|]
operator|+
name|buffer
index|[
literal|3
index|]
operator|*
literal|256
operator|+
name|buffer
index|[
literal|4
index|]
operator|*
literal|65536
operator|+
name|buffer
index|[
literal|5
index|]
operator|*
literal|0x1000000
operator|+
name|addr
operator|)
decl_stmt|;
comment|/* Finish off and output previous formatted bytes.  */
operator|*
name|tp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|temp
index|[
literal|0
index|]
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|tp
operator|=
name|temp
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
operator|(
name|bfd_vma
operator|)
name|number
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'u'
case|:
block|{
comment|/* Like n but the offset is bits<3:0> in the instruction.  */
name|unsigned
name|long
name|number
init|=
operator|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|0xf
operator|)
operator|*
literal|2
operator|+
name|addr
decl_stmt|;
comment|/* Finish off and output previous formatted bytes.  */
operator|*
name|tp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|temp
index|[
literal|0
index|]
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|tp
operator|=
name|temp
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
operator|(
name|bfd_vma
operator|)
name|number
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'N'
case|:
case|case
literal|'y'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
comment|/* Any "normal" memory operand.  */
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x400
operator|)
operator|&&
operator|(
name|insn
operator|&
literal|15
operator|)
operator|==
literal|15
operator|&&
name|prefix_opcodep
operator|==
name|NULL
condition|)
block|{
comment|/* We're looking at [pc+], i.e. we need to output an immediate 	       number, where the size can depend on different things.  */
name|long
name|number
decl_stmt|;
name|int
name|signedp
init|=
operator|(
operator|(
operator|*
name|cs
operator|==
literal|'z'
operator|&&
operator|(
name|insn
operator|&
literal|0x20
operator|)
operator|)
operator|||
name|opcodep
operator|->
name|match
operator|==
name|BDAP_QUICK_OPCODE
operator|)
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
if|if
condition|(
name|opcodep
operator|->
name|imm_oprnd_size
operator|==
name|SIZE_FIX_32
condition|)
name|nbytes
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|opcodep
operator|->
name|imm_oprnd_size
operator|==
name|SIZE_SPEC_REG
condition|)
block|{
specifier|const
name|struct
name|cris_spec_reg
modifier|*
name|sregp
init|=
name|spec_reg_info
argument_list|(
operator|(
name|insn
operator|>>
literal|12
operator|)
operator|&
literal|15
argument_list|,
name|disdata
operator|->
name|distype
argument_list|)
decl_stmt|;
comment|/* A NULL return should have been as a non-match earlier, 		   so catch it as an internal error in the error-case 		   below.  */
if|if
condition|(
name|sregp
operator|==
name|NULL
condition|)
comment|/* Whatever non-valid size.  */
name|nbytes
operator|=
literal|42
expr_stmt|;
else|else
comment|/* PC is always incremented by a multiple of two. 		     For CRISv32, immediates are always 4 bytes for 		     special registers.  */
name|nbytes
operator|=
name|disdata
operator|->
name|distype
operator|==
name|cris_dis_v32
condition|?
literal|4
else|:
operator|(
name|sregp
operator|->
name|reg_size
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|mode_size
init|=
literal|1
operator|<<
operator|(
operator|(
name|insn
operator|>>
literal|4
operator|)
operator|&
operator|(
operator|*
name|cs
operator|==
literal|'z'
condition|?
literal|1
else|:
literal|3
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|mode_size
operator|==
literal|1
condition|)
name|nbytes
operator|=
literal|2
expr_stmt|;
else|else
name|nbytes
operator|=
name|mode_size
expr_stmt|;
block|}
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|1
case|:
name|number
operator|=
name|buffer
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|signedp
operator|&&
name|number
operator|>
literal|127
condition|)
name|number
operator|-=
literal|256
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|number
operator|=
name|buffer
index|[
literal|2
index|]
operator|+
name|buffer
index|[
literal|3
index|]
operator|*
literal|256
expr_stmt|;
if|if
condition|(
name|signedp
operator|&&
name|number
operator|>
literal|32767
condition|)
name|number
operator|-=
literal|65536
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|number
operator|=
name|buffer
index|[
literal|2
index|]
operator|+
name|buffer
index|[
literal|3
index|]
operator|*
literal|256
operator|+
name|buffer
index|[
literal|4
index|]
operator|*
literal|65536
operator|+
name|buffer
index|[
literal|5
index|]
operator|*
literal|0x1000000
expr_stmt|;
break|break;
default|default:
name|strcpy
argument_list|(
name|tp
argument_list|,
literal|"bug"
argument_list|)
expr_stmt|;
name|tp
operator|+=
literal|3
expr_stmt|;
name|number
operator|=
literal|42
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|cs
operator|==
literal|'z'
operator|&&
operator|(
name|insn
operator|&
literal|0x20
operator|)
operator|)
operator|||
operator|(
name|opcodep
operator|->
name|match
operator|==
name|BDAP_QUICK_OPCODE
operator|&&
operator|(
name|nbytes
operator|<=
literal|2
operator|||
name|buffer
index|[
literal|1
operator|+
name|nbytes
index|]
operator|==
literal|0
operator|)
operator|)
condition|)
name|tp
operator|=
name|format_dec
argument_list|(
name|number
argument_list|,
name|tp
argument_list|,
name|signedp
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|int
name|highbyte
init|=
operator|(
name|number
operator|>>
literal|24
operator|)
operator|&
literal|0xff
decl_stmt|;
comment|/* Either output this as an address or as a number.  If it's 		   a dword with the same high-byte as the address of the 		   insn, assume it's an address, and also if it's a non-zero 		   non-0xff high-byte.  If this is a jsr or a jump, then 		   it's definitely an address.  */
if|if
condition|(
name|nbytes
operator|==
literal|4
operator|&&
operator|(
name|highbyte
operator|==
operator|(
operator|(
name|addr
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
operator|||
operator|(
name|highbyte
operator|!=
literal|0
operator|&&
name|highbyte
operator|!=
literal|0xff
operator|)
operator|||
name|info
operator|->
name|insn_type
operator|==
name|dis_branch
operator|||
name|info
operator|->
name|insn_type
operator|==
name|dis_jsr
operator|)
condition|)
block|{
comment|/* Finish off and output previous formatted bytes.  */
operator|*
name|tp
operator|=
literal|0
expr_stmt|;
name|tp
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|temp
index|[
literal|0
index|]
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
operator|(
name|bfd_vma
operator|)
name|number
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|info
operator|->
name|target
operator|=
name|number
expr_stmt|;
block|}
else|else
name|tp
operator|=
name|format_hex
argument_list|(
name|number
argument_list|,
name|tp
argument_list|,
name|disdata
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Not an immediate number.  Then this is a (possibly 	       prefixed) memory operand.  */
if|if
condition|(
name|info
operator|->
name|insn_type
operator|!=
name|dis_nonbranch
condition|)
block|{
name|int
name|mode_size
init|=
literal|1
operator|<<
operator|(
operator|(
name|insn
operator|>>
literal|4
operator|)
operator|&
operator|(
name|opcodep
operator|->
name|args
index|[
literal|0
index|]
operator|==
literal|'z'
condition|?
literal|1
else|:
literal|3
operator|)
operator|)
decl_stmt|;
name|int
name|size
decl_stmt|;
name|info
operator|->
name|insn_type
operator|=
name|dis_dref
expr_stmt|;
name|info
operator|->
name|flags
operator||=
name|CRIS_DIS_FLAG_MEMREF
expr_stmt|;
if|if
condition|(
name|opcodep
operator|->
name|imm_oprnd_size
operator|==
name|SIZE_FIX_32
condition|)
name|size
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|opcodep
operator|->
name|imm_oprnd_size
operator|==
name|SIZE_SPEC_REG
condition|)
block|{
specifier|const
name|struct
name|cris_spec_reg
modifier|*
name|sregp
init|=
name|spec_reg_info
argument_list|(
operator|(
name|insn
operator|>>
literal|12
operator|)
operator|&
literal|15
argument_list|,
name|disdata
operator|->
name|distype
argument_list|)
decl_stmt|;
comment|/* FIXME: Improve error handling; should have been caught 		       earlier.  */
if|if
condition|(
name|sregp
operator|==
name|NULL
condition|)
name|size
operator|=
literal|4
expr_stmt|;
else|else
name|size
operator|=
name|sregp
operator|->
name|reg_size
expr_stmt|;
block|}
else|else
name|size
operator|=
name|mode_size
expr_stmt|;
name|info
operator|->
name|data_size
operator|=
name|size
expr_stmt|;
block|}
operator|*
name|tp
operator|++
operator|=
literal|'['
expr_stmt|;
if|if
condition|(
name|prefix_opcodep
comment|/* We don't match dip with a postincremented field 		   as a side-effect address mode.  */
operator|&&
operator|(
operator|(
name|insn
operator|&
literal|0x400
operator|)
operator|==
literal|0
operator|||
name|prefix_opcodep
operator|->
name|match
operator|!=
name|DIP_OPCODE
operator|)
condition|)
block|{
if|if
condition|(
name|insn
operator|&
literal|0x400
condition|)
block|{
name|tp
operator|=
name|format_reg
argument_list|(
name|disdata
argument_list|,
name|insn
operator|&
literal|15
argument_list|,
name|tp
argument_list|,
name|with_reg_prefix
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|'='
expr_stmt|;
block|}
comment|/* We mainly ignore the prefix format string when the 		   address-mode syntax is output.  */
switch|switch
condition|(
name|prefix_opcodep
operator|->
name|match
condition|)
block|{
case|case
name|DIP_OPCODE
case|:
comment|/* It's [r], [r+] or [pc+].  */
if|if
condition|(
operator|(
name|prefix_insn
operator|&
literal|0x400
operator|)
operator|&&
operator|(
name|prefix_insn
operator|&
literal|15
operator|)
operator|==
literal|15
condition|)
block|{
comment|/* It's [pc+].  This cannot possibly be anything 			   but an address.  */
name|unsigned
name|long
name|number
init|=
name|prefix_buffer
index|[
literal|2
index|]
operator|+
name|prefix_buffer
index|[
literal|3
index|]
operator|*
literal|256
operator|+
name|prefix_buffer
index|[
literal|4
index|]
operator|*
literal|65536
operator|+
name|prefix_buffer
index|[
literal|5
index|]
operator|*
literal|0x1000000
decl_stmt|;
name|info
operator|->
name|target
operator|=
operator|(
name|bfd_vma
operator|)
name|number
expr_stmt|;
comment|/* Finish off and output previous formatted 			   data.  */
operator|*
name|tp
operator|=
literal|0
expr_stmt|;
name|tp
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|temp
index|[
literal|0
index|]
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
operator|(
name|bfd_vma
operator|)
name|number
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* For a memref in an address, we use target2. 			   In this case, target is zero.  */
name|info
operator|->
name|flags
operator||=
operator|(
name|CRIS_DIS_FLAG_MEM_TARGET2_IS_REG
operator||
name|CRIS_DIS_FLAG_MEM_TARGET2_MEM
operator|)
expr_stmt|;
name|info
operator|->
name|target2
operator|=
name|prefix_insn
operator|&
literal|15
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|'['
expr_stmt|;
name|tp
operator|=
name|format_reg
argument_list|(
name|disdata
argument_list|,
name|prefix_insn
operator|&
literal|15
argument_list|,
name|tp
argument_list|,
name|with_reg_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix_insn
operator|&
literal|0x400
condition|)
operator|*
name|tp
operator|++
operator|=
literal|'+'
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|']'
expr_stmt|;
block|}
break|break;
case|case
name|BDAP_QUICK_OPCODE
case|:
block|{
name|int
name|number
decl_stmt|;
name|number
operator|=
name|prefix_buffer
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|number
operator|>
literal|127
condition|)
name|number
operator|-=
literal|256
expr_stmt|;
comment|/* Output "reg+num" or, if num< 0, "reg-num".  */
name|tp
operator|=
name|format_reg
argument_list|(
name|disdata
argument_list|,
operator|(
name|prefix_insn
operator|>>
literal|12
operator|)
operator|&
literal|15
argument_list|,
name|tp
argument_list|,
name|with_reg_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|number
operator|>=
literal|0
condition|)
operator|*
name|tp
operator|++
operator|=
literal|'+'
expr_stmt|;
name|tp
operator|=
name|format_dec
argument_list|(
name|number
argument_list|,
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info
operator|->
name|flags
operator||=
name|CRIS_DIS_FLAG_MEM_TARGET_IS_REG
expr_stmt|;
name|info
operator|->
name|target
operator|=
operator|(
name|prefix_insn
operator|>>
literal|12
operator|)
operator|&
literal|15
expr_stmt|;
name|info
operator|->
name|target2
operator|=
operator|(
name|bfd_vma
operator|)
name|number
expr_stmt|;
break|break;
block|}
case|case
name|BIAP_OPCODE
case|:
comment|/* Output "r+R.m".  */
name|tp
operator|=
name|format_reg
argument_list|(
name|disdata
argument_list|,
name|prefix_insn
operator|&
literal|15
argument_list|,
name|tp
argument_list|,
name|with_reg_prefix
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|'+'
expr_stmt|;
name|tp
operator|=
name|format_reg
argument_list|(
name|disdata
argument_list|,
operator|(
name|prefix_insn
operator|>>
literal|12
operator|)
operator|&
literal|15
argument_list|,
name|tp
argument_list|,
name|with_reg_prefix
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
name|mode_char
index|[
operator|(
name|prefix_insn
operator|>>
literal|4
operator|)
operator|&
literal|3
index|]
expr_stmt|;
name|info
operator|->
name|flags
operator||=
operator|(
name|CRIS_DIS_FLAG_MEM_TARGET2_IS_REG
operator||
name|CRIS_DIS_FLAG_MEM_TARGET_IS_REG
operator||
operator|(
operator|(
name|prefix_insn
operator|&
literal|0x8000
operator|)
condition|?
name|CRIS_DIS_FLAG_MEM_TARGET2_MULT4
else|:
operator|(
operator|(
name|prefix_insn
operator|&
literal|0x8000
operator|)
condition|?
name|CRIS_DIS_FLAG_MEM_TARGET2_MULT2
else|:
literal|0
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* Is it the casejump?  It's a "adds.w [pc+r%d.w],pc".  */
if|if
condition|(
name|insn
operator|==
literal|0xf83f
operator|&&
operator|(
name|prefix_insn
operator|&
operator|~
literal|0xf000
operator|)
operator|==
literal|0x55f
condition|)
comment|/* Then start interpreting data as offsets.  */
name|case_offset_counter
operator|=
name|no_of_case_offsets
expr_stmt|;
break|break;
case|case
name|BDAP_INDIR_OPCODE
case|:
comment|/* Output "r+s.m", or, if "s" is [pc+], "r+s" or 		       "r-s".  */
name|tp
operator|=
name|format_reg
argument_list|(
name|disdata
argument_list|,
operator|(
name|prefix_insn
operator|>>
literal|12
operator|)
operator|&
literal|15
argument_list|,
name|tp
argument_list|,
name|with_reg_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prefix_insn
operator|&
literal|0x400
operator|)
operator|&&
operator|(
name|prefix_insn
operator|&
literal|15
operator|)
operator|==
literal|15
condition|)
block|{
name|long
name|number
decl_stmt|;
name|unsigned
name|int
name|nbytes
decl_stmt|;
comment|/* It's a value.  Get its size.  */
name|int
name|mode_size
init|=
literal|1
operator|<<
operator|(
operator|(
name|prefix_insn
operator|>>
literal|4
operator|)
operator|&
literal|3
operator|)
decl_stmt|;
if|if
condition|(
name|mode_size
operator|==
literal|1
condition|)
name|nbytes
operator|=
literal|2
expr_stmt|;
else|else
name|nbytes
operator|=
name|mode_size
expr_stmt|;
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|1
case|:
name|number
operator|=
name|prefix_buffer
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|number
operator|>
literal|127
condition|)
name|number
operator|-=
literal|256
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|number
operator|=
name|prefix_buffer
index|[
literal|2
index|]
operator|+
name|prefix_buffer
index|[
literal|3
index|]
operator|*
literal|256
expr_stmt|;
if|if
condition|(
name|number
operator|>
literal|32767
condition|)
name|number
operator|-=
literal|65536
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|number
operator|=
name|prefix_buffer
index|[
literal|2
index|]
operator|+
name|prefix_buffer
index|[
literal|3
index|]
operator|*
literal|256
operator|+
name|prefix_buffer
index|[
literal|4
index|]
operator|*
literal|65536
operator|+
name|prefix_buffer
index|[
literal|5
index|]
operator|*
literal|0x1000000
expr_stmt|;
break|break;
default|default:
name|strcpy
argument_list|(
name|tp
argument_list|,
literal|"bug"
argument_list|)
expr_stmt|;
name|tp
operator|+=
literal|3
expr_stmt|;
name|number
operator|=
literal|42
expr_stmt|;
block|}
name|info
operator|->
name|flags
operator||=
name|CRIS_DIS_FLAG_MEM_TARGET_IS_REG
expr_stmt|;
name|info
operator|->
name|target2
operator|=
operator|(
name|bfd_vma
operator|)
name|number
expr_stmt|;
comment|/* If the size is dword, then assume it's an 			   address.  */
if|if
condition|(
name|nbytes
operator|==
literal|4
condition|)
block|{
comment|/* Finish off and output previous formatted 			       bytes.  */
operator|*
name|tp
operator|++
operator|=
literal|'+'
expr_stmt|;
operator|*
name|tp
operator|=
literal|0
expr_stmt|;
name|tp
operator|=
name|temp
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
operator|(
name|bfd_vma
operator|)
name|number
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|number
operator|>=
literal|0
condition|)
operator|*
name|tp
operator|++
operator|=
literal|'+'
expr_stmt|;
name|tp
operator|=
name|format_dec
argument_list|(
name|number
argument_list|,
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Output "r+[R].m" or "r+[R+].m".  */
operator|*
name|tp
operator|++
operator|=
literal|'+'
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|'['
expr_stmt|;
name|tp
operator|=
name|format_reg
argument_list|(
name|disdata
argument_list|,
name|prefix_insn
operator|&
literal|15
argument_list|,
name|tp
argument_list|,
name|with_reg_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix_insn
operator|&
literal|0x400
condition|)
operator|*
name|tp
operator|++
operator|=
literal|'+'
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|']'
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
name|mode_char
index|[
operator|(
name|prefix_insn
operator|>>
literal|4
operator|)
operator|&
literal|3
index|]
expr_stmt|;
name|info
operator|->
name|flags
operator||=
operator|(
name|CRIS_DIS_FLAG_MEM_TARGET2_IS_REG
operator||
name|CRIS_DIS_FLAG_MEM_TARGET2_MEM
operator||
name|CRIS_DIS_FLAG_MEM_TARGET_IS_REG
operator||
operator|(
operator|(
operator|(
name|prefix_insn
operator|>>
literal|4
operator|)
operator|==
literal|2
operator|)
condition|?
literal|0
else|:
operator|(
operator|(
operator|(
name|prefix_insn
operator|>>
literal|4
operator|)
operator|&
literal|3
operator|)
operator|==
literal|1
condition|?
name|CRIS_DIS_FLAG_MEM_TARGET2_MEM_WORD
else|:
name|CRIS_DIS_FLAG_MEM_TARGET2_MEM_BYTE
operator|)
operator|)
operator|)
expr_stmt|;
block|}
break|break;
default|default:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"?prefix-bug"
argument_list|)
expr_stmt|;
block|}
comment|/* To mark that the prefix is used, reset it.  */
name|prefix_opcodep
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|=
name|format_reg
argument_list|(
name|disdata
argument_list|,
name|insn
operator|&
literal|15
argument_list|,
name|tp
argument_list|,
name|with_reg_prefix
argument_list|)
expr_stmt|;
name|info
operator|->
name|flags
operator||=
name|CRIS_DIS_FLAG_MEM_TARGET_IS_REG
expr_stmt|;
name|info
operator|->
name|target
operator|=
name|insn
operator|&
literal|15
expr_stmt|;
if|if
condition|(
name|insn
operator|&
literal|0x400
condition|)
operator|*
name|tp
operator|++
operator|=
literal|'+'
expr_stmt|;
block|}
operator|*
name|tp
operator|++
operator|=
literal|']'
expr_stmt|;
block|}
break|break;
case|case
literal|'x'
case|:
name|tp
operator|=
name|format_reg
argument_list|(
name|disdata
argument_list|,
operator|(
name|insn
operator|>>
literal|12
operator|)
operator|&
literal|15
argument_list|,
name|tp
argument_list|,
name|with_reg_prefix
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
name|mode_char
index|[
operator|(
name|insn
operator|>>
literal|4
operator|)
operator|&
literal|3
index|]
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|tp
operator|=
name|format_dec
argument_list|(
name|insn
operator|&
literal|63
argument_list|,
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
block|{
name|int
name|where
init|=
name|buffer
index|[
literal|2
index|]
operator|+
name|buffer
index|[
literal|3
index|]
operator|*
literal|256
decl_stmt|;
if|if
condition|(
name|where
operator|>
literal|32767
condition|)
name|where
operator|-=
literal|65536
expr_stmt|;
name|where
operator|+=
name|addr
operator|+
operator|(
operator|(
name|disdata
operator|->
name|distype
operator|==
name|cris_dis_v32
operator|)
condition|?
literal|0
else|:
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|BA_PC_INCR_OPCODE
condition|)
name|info
operator|->
name|insn_type
operator|=
name|dis_branch
expr_stmt|;
else|else
name|info
operator|->
name|insn_type
operator|=
name|dis_condbranch
expr_stmt|;
name|info
operator|->
name|target
operator|=
operator|(
name|bfd_vma
operator|)
name|where
expr_stmt|;
operator|*
name|tp
operator|=
literal|0
expr_stmt|;
name|tp
operator|=
name|temp
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s%s "
argument_list|,
name|temp
argument_list|,
name|cris_cc_strings
index|[
name|insn
operator|>>
literal|12
index|]
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
operator|(
name|bfd_vma
operator|)
name|where
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'c'
case|:
name|tp
operator|=
name|format_dec
argument_list|(
name|insn
operator|&
literal|31
argument_list|,
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|tp
operator|=
name|format_dec
argument_list|(
name|insn
operator|&
literal|15
argument_list|,
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
block|{
name|long
name|offset
init|=
name|insn
operator|&
literal|0xfe
decl_stmt|;
name|bfd_vma
name|target
decl_stmt|;
if|if
condition|(
name|insn
operator|&
literal|1
condition|)
name|offset
operator||=
operator|~
literal|0xff
expr_stmt|;
if|if
condition|(
name|opcodep
operator|->
name|match
operator|==
name|BA_QUICK_OPCODE
condition|)
name|info
operator|->
name|insn_type
operator|=
name|dis_branch
expr_stmt|;
else|else
name|info
operator|->
name|insn_type
operator|=
name|dis_condbranch
expr_stmt|;
name|target
operator|=
name|addr
operator|+
operator|(
operator|(
name|disdata
operator|->
name|distype
operator|==
name|cris_dis_v32
operator|)
condition|?
literal|0
else|:
literal|2
operator|)
operator|+
name|offset
expr_stmt|;
name|info
operator|->
name|target
operator|=
name|target
expr_stmt|;
operator|*
name|tp
operator|=
literal|0
expr_stmt|;
name|tp
operator|=
name|temp
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|target
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'Q'
case|:
case|case
literal|'O'
case|:
block|{
name|long
name|number
init|=
name|buffer
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|number
operator|>
literal|127
condition|)
name|number
operator|=
name|number
operator|-
literal|256
expr_stmt|;
name|tp
operator|=
name|format_dec
argument_list|(
name|number
argument_list|,
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|','
expr_stmt|;
name|tp
operator|=
name|format_reg
argument_list|(
name|disdata
argument_list|,
operator|(
name|insn
operator|>>
literal|12
operator|)
operator|&
literal|15
argument_list|,
name|tp
argument_list|,
name|with_reg_prefix
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
name|tp
operator|=
name|print_flags
argument_list|(
name|disdata
argument_list|,
name|insn
argument_list|,
name|tp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|tp
operator|=
name|format_dec
argument_list|(
operator|(
name|insn
operator|&
literal|32
operator|)
condition|?
operator|(
name|insn
operator|&
literal|31
operator|)
operator||
operator|~
literal|31L
else|:
name|insn
operator|&
literal|31
argument_list|,
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
block|{
specifier|const
name|struct
name|cris_spec_reg
modifier|*
name|sregp
init|=
name|spec_reg_info
argument_list|(
operator|(
name|insn
operator|>>
literal|12
operator|)
operator|&
literal|15
argument_list|,
name|disdata
operator|->
name|distype
argument_list|)
decl_stmt|;
if|if
condition|(
name|sregp
operator|->
name|name
operator|==
name|NULL
condition|)
comment|/* Should have been caught as a non-match eariler.  */
operator|*
name|tp
operator|++
operator|=
literal|'?'
expr_stmt|;
else|else
block|{
if|if
condition|(
name|with_reg_prefix
condition|)
operator|*
name|tp
operator|++
operator|=
name|REGISTER_PREFIX_CHAR
expr_stmt|;
name|strcpy
argument_list|(
name|tp
argument_list|,
name|sregp
operator|->
name|name
argument_list|)
expr_stmt|;
name|tp
operator|+=
name|strlen
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|strcpy
argument_list|(
name|tp
argument_list|,
literal|"???"
argument_list|)
expr_stmt|;
name|tp
operator|+=
literal|3
expr_stmt|;
block|}
block|}
operator|*
name|tp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prefix_opcodep
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|" (OOPS unused prefix \"%s: %s\")"
argument_list|,
name|prefix_opcodep
operator|->
name|name
argument_list|,
name|prefix_opcodep
operator|->
name|args
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* Get info for matching case-tables, if we don't have any active.      We assume that the last constant seen is used; either in the insn      itself or in a "move.d const,rN, sub.d rN,rM"-like sequence.  */
if|if
condition|(
name|TRACE_CASE
operator|&&
name|case_offset_counter
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|opcodep
operator|->
name|name
argument_list|,
literal|"sub"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|case_offset
operator|=
name|last_immediate
expr_stmt|;
comment|/* It could also be an "add", if there are negative case-values.  */
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|opcodep
operator|->
name|name
argument_list|,
literal|"add"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
comment|/* The first case is the negated operand to the add.  */
name|case_offset
operator|=
operator|-
name|last_immediate
expr_stmt|;
comment|/* A bound insn will tell us the number of cases.  */
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|opcodep
operator|->
name|name
argument_list|,
literal|"bound"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|no_of_case_offsets
operator|=
name|last_immediate
operator|+
literal|1
expr_stmt|;
comment|/* A jump or jsr or branch breaks the chain of insns for a 	 case-table, so assume default first-case again.  */
elseif|else
if|if
condition|(
name|info
operator|->
name|insn_type
operator|==
name|dis_jsr
operator|||
name|info
operator|->
name|insn_type
operator|==
name|dis_branch
operator|||
name|info
operator|->
name|insn_type
operator|==
name|dis_condbranch
condition|)
name|case_offset
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the CRIS instruction at address memaddr on stream.  Returns    length of the instruction, in bytes.  Prefix register names with `$' if    WITH_REG_PREFIX.  */
end_comment

begin_function
specifier|static
name|int
name|print_insn_cris_generic
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|bfd_boolean
name|with_reg_prefix
parameter_list|)
block|{
name|int
name|nbytes
decl_stmt|;
name|unsigned
name|int
name|insn
decl_stmt|;
specifier|const
name|struct
name|cris_opcode
modifier|*
name|matchedp
decl_stmt|;
name|int
name|advance
init|=
literal|0
decl_stmt|;
name|struct
name|cris_disasm_data
modifier|*
name|disdata
init|=
operator|(
expr|struct
name|cris_disasm_data
operator|*
operator|)
name|info
operator|->
name|private_data
decl_stmt|;
comment|/* No instruction will be disassembled as longer than this number of      bytes; stacked prefixes will not be expanded.  */
name|unsigned
name|char
name|buffer
index|[
name|MAX_BYTES_PER_CRIS_INSN
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bufp
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
comment|/* There will be an "out of range" error after the last instruction.      Reading pairs of bytes in decreasing number, we hope that we will get      at least the amount that we will consume.       If we can't get any data, or we do not get enough data, we print      the error message.  */
for|for
control|(
name|nbytes
operator|=
name|MAX_BYTES_PER_CRIS_INSN
init|;
name|nbytes
operator|>
literal|0
condition|;
name|nbytes
operator|-=
literal|2
control|)
block|{
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|memaddr
argument_list|,
name|buffer
argument_list|,
name|nbytes
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* If we did not get all we asked for, then clear the rest.      Hopefully this makes a reproducible result in case of errors.  */
if|if
condition|(
name|nbytes
operator|!=
name|MAX_BYTES_PER_CRIS_INSN
condition|)
name|memset
argument_list|(
name|buffer
operator|+
name|nbytes
argument_list|,
literal|0
argument_list|,
name|MAX_BYTES_PER_CRIS_INSN
operator|-
name|nbytes
argument_list|)
expr_stmt|;
name|addr
operator|=
name|memaddr
expr_stmt|;
name|bufp
operator|=
name|buffer
expr_stmt|;
comment|/* Set some defaults for the insn info.  */
name|info
operator|->
name|insn_info_valid
operator|=
literal|1
expr_stmt|;
name|info
operator|->
name|branch_delay_insns
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|data_size
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|insn_type
operator|=
name|dis_nonbranch
expr_stmt|;
name|info
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|target
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|target2
operator|=
literal|0
expr_stmt|;
comment|/* If we got any data, disassemble it.  */
if|if
condition|(
name|nbytes
operator|!=
literal|0
condition|)
block|{
name|matchedp
operator|=
name|NULL
expr_stmt|;
name|insn
operator|=
name|bufp
index|[
literal|0
index|]
operator|+
name|bufp
index|[
literal|1
index|]
operator|*
literal|256
expr_stmt|;
comment|/* If we're in a case-table, don't disassemble the offsets.  */
if|if
condition|(
name|TRACE_CASE
operator|&&
name|case_offset_counter
operator|!=
literal|0
condition|)
block|{
name|info
operator|->
name|insn_type
operator|=
name|dis_noninsn
expr_stmt|;
name|advance
operator|+=
literal|2
expr_stmt|;
comment|/* If to print data as offsets, then shortcut here.  */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"case %ld%s: -> "
argument_list|,
name|case_offset
operator|+
name|no_of_case_offsets
operator|-
name|case_offset_counter
argument_list|,
name|case_offset_counter
operator|==
literal|1
condition|?
literal|"/default"
else|:
literal|""
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
call|(
name|bfd_vma
call|)
argument_list|(
call|(
name|short
call|)
argument_list|(
name|insn
argument_list|)
operator|+
call|(
name|long
call|)
argument_list|(
name|addr
operator|-
operator|(
name|no_of_case_offsets
operator|-
name|case_offset_counter
operator|)
operator|*
literal|2
argument_list|)
argument_list|)
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|case_offset_counter
operator|--
expr_stmt|;
comment|/* The default case start (without a "sub" or "add") must be 	     zero.  */
if|if
condition|(
name|case_offset_counter
operator|==
literal|0
condition|)
name|case_offset
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn
operator|==
literal|0
condition|)
block|{
comment|/* We're often called to disassemble zeroes.  While this is a 	     valid "bcc .+2" insn, it is also useless enough and enough 	     of a nuiscance that we will just output "bcc .+2" for it 	     and signal it as a noninsn.  */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
name|disdata
operator|->
name|distype
operator|==
name|cris_dis_v32
condition|?
literal|"bcc ."
else|:
literal|"bcc .+2"
argument_list|)
expr_stmt|;
name|info
operator|->
name|insn_type
operator|=
name|dis_noninsn
expr_stmt|;
name|advance
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|struct
name|cris_opcode
modifier|*
name|prefix_opcodep
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
name|prefix_buffer
init|=
name|bufp
decl_stmt|;
name|unsigned
name|int
name|prefix_insn
init|=
name|insn
decl_stmt|;
name|int
name|prefix_size
init|=
literal|0
decl_stmt|;
name|matchedp
operator|=
name|get_opcode_entry
argument_list|(
name|insn
argument_list|,
name|NO_CRIS_PREFIX
argument_list|,
name|disdata
argument_list|)
expr_stmt|;
comment|/* Check if we're supposed to write out prefixes as address 	     modes and if this was a prefix.  */
if|if
condition|(
name|matchedp
operator|!=
name|NULL
operator|&&
name|PARSE_PREFIX
operator|&&
name|matchedp
operator|->
name|args
index|[
literal|0
index|]
operator|==
literal|'p'
condition|)
block|{
comment|/* If it's a prefix, put it into the prefix vars and get the 		 main insn.  */
name|prefix_size
operator|=
name|bytes_to_skip
argument_list|(
name|prefix_insn
argument_list|,
name|matchedp
argument_list|,
name|disdata
operator|->
name|distype
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|prefix_opcodep
operator|=
name|matchedp
expr_stmt|;
name|insn
operator|=
name|bufp
index|[
name|prefix_size
index|]
operator|+
name|bufp
index|[
name|prefix_size
operator|+
literal|1
index|]
operator|*
literal|256
expr_stmt|;
name|matchedp
operator|=
name|get_opcode_entry
argument_list|(
name|insn
argument_list|,
name|prefix_insn
argument_list|,
name|disdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|matchedp
operator|!=
name|NULL
condition|)
block|{
name|addr
operator|+=
name|prefix_size
expr_stmt|;
name|bufp
operator|+=
name|prefix_size
expr_stmt|;
name|advance
operator|+=
name|prefix_size
expr_stmt|;
block|}
else|else
block|{
comment|/* The "main" insn wasn't valid, at least not when 		     prefixed.  Put back things enough to output the 		     prefix insn only, as a normal insn.  */
name|matchedp
operator|=
name|prefix_opcodep
expr_stmt|;
name|insn
operator|=
name|prefix_insn
expr_stmt|;
name|prefix_opcodep
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|matchedp
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"??0x%x"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|advance
operator|+=
literal|2
expr_stmt|;
name|info
operator|->
name|insn_type
operator|=
name|dis_noninsn
expr_stmt|;
block|}
else|else
block|{
name|advance
operator|+=
name|bytes_to_skip
argument_list|(
name|insn
argument_list|,
name|matchedp
argument_list|,
name|disdata
operator|->
name|distype
argument_list|,
name|prefix_opcodep
argument_list|)
expr_stmt|;
comment|/* The info_type and assorted fields will be set according 		 to the operands.   */
name|print_with_operands
argument_list|(
name|matchedp
argument_list|,
name|insn
argument_list|,
name|bufp
argument_list|,
name|addr
argument_list|,
name|info
argument_list|,
name|prefix_opcodep
argument_list|,
name|prefix_insn
argument_list|,
name|prefix_buffer
argument_list|,
name|with_reg_prefix
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|info
operator|->
name|insn_type
operator|=
name|dis_noninsn
expr_stmt|;
comment|/* If we read less than MAX_BYTES_PER_CRIS_INSN, i.e. we got an error      status when reading that much, and the insn decoding indicated a      length exceeding what we read, there is an error.  */
if|if
condition|(
name|status
operator|!=
literal|0
operator|&&
operator|(
name|nbytes
operator|==
literal|0
operator|||
name|advance
operator|>
name|nbytes
operator|)
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|memory_error_func
call|)
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Max supported insn size with one folded prefix insn.  */
name|info
operator|->
name|bytes_per_line
operator|=
name|MAX_BYTES_PER_CRIS_INSN
expr_stmt|;
comment|/* I would like to set this to a fixed value larger than the actual      number of bytes to print in order to avoid spaces between bytes,      but objdump.c (2.9.1) does not like that, so we print 16-bit      chunks, which is the next choice.  */
name|info
operator|->
name|bytes_per_chunk
operator|=
literal|2
expr_stmt|;
comment|/* Printing bytes in order of increasing addresses makes sense,      especially on a little-endian target.      This is completely the opposite of what you think; setting this to      BFD_ENDIAN_LITTLE will print bytes in order N..0 rather than the 0..N      we want.  */
name|info
operator|->
name|display_endian
operator|=
name|BFD_ENDIAN_BIG
expr_stmt|;
return|return
name|advance
return|;
block|}
end_function

begin_comment
comment|/* Disassemble, prefixing register names with `$'.  CRIS v0..v10.  */
end_comment

begin_function
specifier|static
name|int
name|print_insn_cris_with_register_prefix
parameter_list|(
name|bfd_vma
name|vma
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|info
operator|->
name|private_data
operator|==
name|NULL
operator|&&
operator|!
name|cris_parse_disassembler_options
argument_list|(
name|info
argument_list|,
name|cris_dis_v0_v10
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|print_insn_cris_generic
argument_list|(
name|vma
argument_list|,
name|info
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Disassemble, prefixing register names with `$'.  CRIS v32.  */
end_comment

begin_function
specifier|static
name|int
name|print_insn_crisv32_with_register_prefix
parameter_list|(
name|bfd_vma
name|vma
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|info
operator|->
name|private_data
operator|==
name|NULL
operator|&&
operator|!
name|cris_parse_disassembler_options
argument_list|(
name|info
argument_list|,
name|cris_dis_v32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|print_insn_cris_generic
argument_list|(
name|vma
argument_list|,
name|info
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Disassemble, prefixing register names with `$'.    Common v10 and v32 subset.  */
end_comment

begin_function
specifier|static
name|int
name|print_insn_crisv10_v32_with_register_prefix
parameter_list|(
name|bfd_vma
name|vma
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|info
operator|->
name|private_data
operator|==
name|NULL
operator|&&
operator|!
name|cris_parse_disassembler_options
argument_list|(
name|info
argument_list|,
name|cris_dis_common_v10_v32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|print_insn_cris_generic
argument_list|(
name|vma
argument_list|,
name|info
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Disassemble, no prefixes on register names.  CRIS v0..v10.  */
end_comment

begin_function
specifier|static
name|int
name|print_insn_cris_without_register_prefix
parameter_list|(
name|bfd_vma
name|vma
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|info
operator|->
name|private_data
operator|==
name|NULL
operator|&&
operator|!
name|cris_parse_disassembler_options
argument_list|(
name|info
argument_list|,
name|cris_dis_v0_v10
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|print_insn_cris_generic
argument_list|(
name|vma
argument_list|,
name|info
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Disassemble, no prefixes on register names.  CRIS v32.  */
end_comment

begin_function
specifier|static
name|int
name|print_insn_crisv32_without_register_prefix
parameter_list|(
name|bfd_vma
name|vma
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|info
operator|->
name|private_data
operator|==
name|NULL
operator|&&
operator|!
name|cris_parse_disassembler_options
argument_list|(
name|info
argument_list|,
name|cris_dis_v32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|print_insn_cris_generic
argument_list|(
name|vma
argument_list|,
name|info
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Disassemble, no prefixes on register names.    Common v10 and v32 subset.  */
end_comment

begin_function
specifier|static
name|int
name|print_insn_crisv10_v32_without_register_prefix
parameter_list|(
name|bfd_vma
name|vma
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|info
operator|->
name|private_data
operator|==
name|NULL
operator|&&
operator|!
name|cris_parse_disassembler_options
argument_list|(
name|info
argument_list|,
name|cris_dis_common_v10_v32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|print_insn_cris_generic
argument_list|(
name|vma
argument_list|,
name|info
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a disassembler-function that prints registers with a `$' prefix,    or one that prints registers without a prefix.    FIXME: We should improve the solution to avoid the multitude of    functions seen above.  */
end_comment

begin_function
name|disassembler_ftype
name|cris_get_disassembler
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
comment|/* If there's no bfd in sight, we return what is valid as input in all      contexts if fed back to the assembler: disassembly *with* register      prefix.  Unfortunately this will be totally wrong for v32.  */
if|if
condition|(
name|abfd
operator|==
name|NULL
condition|)
return|return
name|print_insn_cris_with_register_prefix
return|;
if|if
condition|(
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_mach_cris_v32
condition|)
return|return
name|print_insn_crisv32_with_register_prefix
return|;
if|if
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_mach_cris_v10_v32
condition|)
return|return
name|print_insn_crisv10_v32_with_register_prefix
return|;
comment|/* We default to v10.  This may be specifically specified in the 	 bfd mach, but is also the default setting.  */
return|return
name|print_insn_cris_with_register_prefix
return|;
block|}
if|if
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_mach_cris_v32
condition|)
return|return
name|print_insn_crisv32_without_register_prefix
return|;
if|if
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_mach_cris_v10_v32
condition|)
return|return
name|print_insn_crisv10_v32_without_register_prefix
return|;
return|return
name|print_insn_cris_without_register_prefix
return|;
block|}
end_function

begin_comment
comment|/* Local variables:    eval: (c-set-style "gnu")    indent-tabs-mode: t    End:  */
end_comment

end_unit

