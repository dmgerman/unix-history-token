begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Disassemble i80960 instructions.    Copyright 1990, 1991, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2003    Free Software Foundation, Inc.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|reg_names
index|[]
init|=
block|{
comment|/*  0 */
literal|"pfp"
block|,
literal|"sp"
block|,
literal|"rip"
block|,
literal|"r3"
block|,
literal|"r4"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
comment|/*  8 */
literal|"r8"
block|,
literal|"r9"
block|,
literal|"r10"
block|,
literal|"r11"
block|,
literal|"r12"
block|,
literal|"r13"
block|,
literal|"r14"
block|,
literal|"r15"
block|,
comment|/* 16 */
literal|"g0"
block|,
literal|"g1"
block|,
literal|"g2"
block|,
literal|"g3"
block|,
literal|"g4"
block|,
literal|"g5"
block|,
literal|"g6"
block|,
literal|"g7"
block|,
comment|/* 24 */
literal|"g8"
block|,
literal|"g9"
block|,
literal|"g10"
block|,
literal|"g11"
block|,
literal|"g12"
block|,
literal|"g13"
block|,
literal|"g14"
block|,
literal|"fp"
block|,
comment|/* 32 */
literal|"pc"
block|,
literal|"ac"
block|,
literal|"ip"
block|,
literal|"tc"
block|,
literal|"fp0"
block|,
literal|"fp1"
block|,
literal|"fp2"
block|,
literal|"fp3"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|stream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output goes here */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|print_addr
parameter_list|(
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctrl
parameter_list|(
name|bfd_vma
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cobr
parameter_list|(
name|bfd_vma
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reg
parameter_list|(
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mem
parameter_list|(
name|bfd_vma
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ea
parameter_list|(
name|bfd_vma
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dstop
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|regop
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|invalid
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pinsn
parameter_list|(
name|bfd_vma
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|put_abs
parameter_list|(
name|unsigned
name|long
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Print the i960 instruction at address 'memaddr' in debugged memory,    on INFO->STREAM.  Returns length of the instruction, in bytes.  */
end_comment

begin_function
name|int
name|print_insn_i960
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info_arg
parameter_list|)
block|{
name|unsigned
name|int
name|word1
decl_stmt|,
name|word2
init|=
literal|0xdeadbeef
decl_stmt|;
name|bfd_byte
name|buffer
index|[
literal|8
index|]
decl_stmt|;
name|int
name|status
decl_stmt|;
name|info
operator|=
name|info_arg
expr_stmt|;
name|stream
operator|=
name|info
operator|->
name|stream
expr_stmt|;
comment|/* Read word1.  Only read word2 if the instruction      needs it, to prevent reading past the end of a section.  */
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|memaddr
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buffer
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|memory_error_func
call|)
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|word1
operator|=
name|bfd_getl32
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* Divide instruction set into classes based on high 4 bits of opcode.  */
switch|switch
condition|(
operator|(
name|word1
operator|>>
literal|28
operator|)
operator|&
literal|0xf
condition|)
block|{
default|default:
break|break;
case|case
literal|0x8
case|:
case|case
literal|0x9
case|:
case|case
literal|0xa
case|:
case|case
literal|0xb
case|:
case|case
literal|0xc
case|:
comment|/* Read word2.  */
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|memaddr
operator|+
literal|4
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|(
name|buffer
operator|+
literal|4
operator|)
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|memory_error_func
call|)
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|word2
operator|=
name|bfd_getl32
argument_list|(
name|buffer
operator|+
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|pinsn
argument_list|(
name|memaddr
argument_list|,
name|word1
argument_list|,
name|word2
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|IN_GDB
end_define

begin_comment
comment|/*****************************************************************************  *	All code below this point should be identical with that of  *	the disassembler in gdmp960.   A noble sentiment, but at least in cosmetic ways (info->fprintf_func), it  just ain't so. -kingdon, 31 Mar 93  *****************************************************************************/
end_comment

begin_struct
struct|struct
name|tabent
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|short
name|numops
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sparse_tabent
block|{
name|int
name|opcode
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|short
name|numops
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|pinsn
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|unsigned
name|long
name|word1
parameter_list|,
name|unsigned
name|long
name|word2
parameter_list|)
block|{
name|int
name|instr_len
decl_stmt|;
name|instr_len
operator|=
literal|4
expr_stmt|;
name|put_abs
argument_list|(
name|word1
argument_list|,
name|word2
argument_list|)
expr_stmt|;
comment|/* Divide instruction set into classes based on high 4 bits of opcode.  */
switch|switch
condition|(
operator|(
name|word1
operator|>>
literal|28
operator|)
operator|&
literal|0xf
condition|)
block|{
case|case
literal|0x0
case|:
case|case
literal|0x1
case|:
name|ctrl
argument_list|(
name|memaddr
argument_list|,
name|word1
argument_list|,
name|word2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x2
case|:
case|case
literal|0x3
case|:
name|cobr
argument_list|(
name|memaddr
argument_list|,
name|word1
argument_list|,
name|word2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x5
case|:
case|case
literal|0x6
case|:
case|case
literal|0x7
case|:
name|reg
argument_list|(
name|word1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x8
case|:
case|case
literal|0x9
case|:
case|case
literal|0xa
case|:
case|case
literal|0xb
case|:
case|case
literal|0xc
case|:
name|instr_len
operator|=
name|mem
argument_list|(
name|memaddr
argument_list|,
name|word1
argument_list|,
name|word2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Invalid instruction, print as data word.  */
name|invalid
argument_list|(
name|word1
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|instr_len
return|;
block|}
end_function

begin_comment
comment|/* CTRL format.. */
end_comment

begin_function
specifier|static
name|void
name|ctrl
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|unsigned
name|long
name|word1
parameter_list|,
name|unsigned
name|long
name|word2
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
name|struct
name|tabent
name|ctrl_tab
index|[]
init|=
block|{
block|{
name|NULL
block|,
literal|0
block|, }
block|,
comment|/* 0x00 */
block|{
name|NULL
block|,
literal|0
block|, }
block|,
comment|/* 0x01 */
block|{
name|NULL
block|,
literal|0
block|, }
block|,
comment|/* 0x02 */
block|{
name|NULL
block|,
literal|0
block|, }
block|,
comment|/* 0x03 */
block|{
name|NULL
block|,
literal|0
block|, }
block|,
comment|/* 0x04 */
block|{
name|NULL
block|,
literal|0
block|, }
block|,
comment|/* 0x05 */
block|{
name|NULL
block|,
literal|0
block|, }
block|,
comment|/* 0x06 */
block|{
name|NULL
block|,
literal|0
block|, }
block|,
comment|/* 0x07 */
block|{
literal|"b"
block|,
literal|1
block|, }
block|,
comment|/* 0x08 */
block|{
literal|"call"
block|,
literal|1
block|, }
block|,
comment|/* 0x09 */
block|{
literal|"ret"
block|,
literal|0
block|, }
block|,
comment|/* 0x0a */
block|{
literal|"bal"
block|,
literal|1
block|, }
block|,
comment|/* 0x0b */
block|{
name|NULL
block|,
literal|0
block|, }
block|,
comment|/* 0x0c */
block|{
name|NULL
block|,
literal|0
block|, }
block|,
comment|/* 0x0d */
block|{
name|NULL
block|,
literal|0
block|, }
block|,
comment|/* 0x0e */
block|{
name|NULL
block|,
literal|0
block|, }
block|,
comment|/* 0x0f */
block|{
literal|"bno"
block|,
literal|1
block|, }
block|,
comment|/* 0x10 */
block|{
literal|"bg"
block|,
literal|1
block|, }
block|,
comment|/* 0x11 */
block|{
literal|"be"
block|,
literal|1
block|, }
block|,
comment|/* 0x12 */
block|{
literal|"bge"
block|,
literal|1
block|, }
block|,
comment|/* 0x13 */
block|{
literal|"bl"
block|,
literal|1
block|, }
block|,
comment|/* 0x14 */
block|{
literal|"bne"
block|,
literal|1
block|, }
block|,
comment|/* 0x15 */
block|{
literal|"ble"
block|,
literal|1
block|, }
block|,
comment|/* 0x16 */
block|{
literal|"bo"
block|,
literal|1
block|, }
block|,
comment|/* 0x17 */
block|{
literal|"faultno"
block|,
literal|0
block|, }
block|,
comment|/* 0x18 */
block|{
literal|"faultg"
block|,
literal|0
block|, }
block|,
comment|/* 0x19 */
block|{
literal|"faulte"
block|,
literal|0
block|, }
block|,
comment|/* 0x1a */
block|{
literal|"faultge"
block|,
literal|0
block|, }
block|,
comment|/* 0x1b */
block|{
literal|"faultl"
block|,
literal|0
block|, }
block|,
comment|/* 0x1c */
block|{
literal|"faultne"
block|,
literal|0
block|, }
block|,
comment|/* 0x1d */
block|{
literal|"faultle"
block|,
literal|0
block|, }
block|,
comment|/* 0x1e */
block|{
literal|"faulto"
block|,
literal|0
block|, }
block|,
comment|/* 0x1f */
block|}
decl_stmt|;
name|i
operator|=
operator|(
name|word1
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
name|ctrl_tab
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|word1
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|invalid
argument_list|(
name|word1
argument_list|)
expr_stmt|;
return|return;
block|}
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
name|ctrl_tab
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|word1
operator|&
literal|2
condition|)
comment|/* Predicts branch not taken.  */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|".f"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctrl_tab
index|[
name|i
index|]
operator|.
name|numops
operator|==
literal|1
condition|)
block|{
comment|/* Extract displacement and convert to address.  */
name|word1
operator|&=
literal|0x00ffffff
expr_stmt|;
if|if
condition|(
name|word1
operator|&
literal|0x00800000
condition|)
block|{
comment|/* Sign bit is set.  */
name|word1
operator||=
operator|(
operator|-
literal|1
operator|&
operator|~
literal|0xffffff
operator|)
expr_stmt|;
comment|/* Sign extend.  */
block|}
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
name|print_addr
argument_list|(
name|word1
operator|+
name|memaddr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* COBR format.  */
end_comment

begin_function
specifier|static
name|void
name|cobr
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|unsigned
name|long
name|word1
parameter_list|,
name|unsigned
name|long
name|word2
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|src1
decl_stmt|;
name|int
name|src2
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
name|struct
name|tabent
name|cobr_tab
index|[]
init|=
block|{
block|{
literal|"testno"
block|,
literal|1
block|, }
block|,
comment|/* 0x20 */
block|{
literal|"testg"
block|,
literal|1
block|, }
block|,
comment|/* 0x21 */
block|{
literal|"teste"
block|,
literal|1
block|, }
block|,
comment|/* 0x22 */
block|{
literal|"testge"
block|,
literal|1
block|, }
block|,
comment|/* 0x23 */
block|{
literal|"testl"
block|,
literal|1
block|, }
block|,
comment|/* 0x24 */
block|{
literal|"testne"
block|,
literal|1
block|, }
block|,
comment|/* 0x25 */
block|{
literal|"testle"
block|,
literal|1
block|, }
block|,
comment|/* 0x26 */
block|{
literal|"testo"
block|,
literal|1
block|, }
block|,
comment|/* 0x27 */
block|{
name|NULL
block|,
literal|0
block|, }
block|,
comment|/* 0x28 */
block|{
name|NULL
block|,
literal|0
block|, }
block|,
comment|/* 0x29 */
block|{
name|NULL
block|,
literal|0
block|, }
block|,
comment|/* 0x2a */
block|{
name|NULL
block|,
literal|0
block|, }
block|,
comment|/* 0x2b */
block|{
name|NULL
block|,
literal|0
block|, }
block|,
comment|/* 0x2c */
block|{
name|NULL
block|,
literal|0
block|, }
block|,
comment|/* 0x2d */
block|{
name|NULL
block|,
literal|0
block|, }
block|,
comment|/* 0x2e */
block|{
name|NULL
block|,
literal|0
block|, }
block|,
comment|/* 0x2f */
block|{
literal|"bbc"
block|,
literal|3
block|, }
block|,
comment|/* 0x30 */
block|{
literal|"cmpobg"
block|,
literal|3
block|, }
block|,
comment|/* 0x31 */
block|{
literal|"cmpobe"
block|,
literal|3
block|, }
block|,
comment|/* 0x32 */
block|{
literal|"cmpobge"
block|,
literal|3
block|, }
block|,
comment|/* 0x33 */
block|{
literal|"cmpobl"
block|,
literal|3
block|, }
block|,
comment|/* 0x34 */
block|{
literal|"cmpobne"
block|,
literal|3
block|, }
block|,
comment|/* 0x35 */
block|{
literal|"cmpoble"
block|,
literal|3
block|, }
block|,
comment|/* 0x36 */
block|{
literal|"bbs"
block|,
literal|3
block|, }
block|,
comment|/* 0x37 */
block|{
literal|"cmpibno"
block|,
literal|3
block|, }
block|,
comment|/* 0x38 */
block|{
literal|"cmpibg"
block|,
literal|3
block|, }
block|,
comment|/* 0x39 */
block|{
literal|"cmpibe"
block|,
literal|3
block|, }
block|,
comment|/* 0x3a */
block|{
literal|"cmpibge"
block|,
literal|3
block|, }
block|,
comment|/* 0x3b */
block|{
literal|"cmpibl"
block|,
literal|3
block|, }
block|,
comment|/* 0x3c */
block|{
literal|"cmpibne"
block|,
literal|3
block|, }
block|,
comment|/* 0x3d */
block|{
literal|"cmpible"
block|,
literal|3
block|, }
block|,
comment|/* 0x3e */
block|{
literal|"cmpibo"
block|,
literal|3
block|, }
block|,
comment|/* 0x3f */
block|}
decl_stmt|;
name|i
operator|=
operator|(
operator|(
name|word1
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
operator|-
literal|0x20
expr_stmt|;
if|if
condition|(
name|cobr_tab
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
name|invalid
argument_list|(
name|word1
argument_list|)
expr_stmt|;
return|return;
block|}
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
name|cobr_tab
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* Predicts branch not taken.  */
if|if
condition|(
name|word1
operator|&
literal|2
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|".f"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
name|src1
operator|=
operator|(
name|word1
operator|>>
literal|19
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|src2
operator|=
operator|(
name|word1
operator|>>
literal|14
operator|)
operator|&
literal|0x1f
expr_stmt|;
if|if
condition|(
name|word1
operator|&
literal|0x02000
condition|)
comment|/* M1 is 1 */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|src1
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
name|reg_names
index|[
name|src1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cobr_tab
index|[
name|i
index|]
operator|.
name|numops
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|word1
operator|&
literal|1
condition|)
comment|/* S2 is 1.  */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|",sf%d,"
argument_list|,
name|src2
argument_list|)
expr_stmt|;
else|else
comment|/* S1 is 0.  */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|",%s,"
argument_list|,
name|reg_names
index|[
name|src2
index|]
argument_list|)
expr_stmt|;
comment|/* Extract displacement and convert to address.  */
name|word1
operator|&=
literal|0x00001ffc
expr_stmt|;
if|if
condition|(
name|word1
operator|&
literal|0x00001000
condition|)
comment|/* Negative displacement.  */
name|word1
operator||=
operator|(
operator|-
literal|1
operator|&
operator|~
literal|0x1fff
operator|)
expr_stmt|;
comment|/* Sign extend.  */
name|print_addr
argument_list|(
name|memaddr
operator|+
name|word1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* MEM format.  */
end_comment

begin_comment
comment|/* Returns instruction length: 4 or 8.  */
end_comment

begin_function
specifier|static
name|int
name|mem
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|unsigned
name|long
name|word1
parameter_list|,
name|unsigned
name|long
name|word2
parameter_list|,
name|int
name|noprint
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|offset
decl_stmt|;
specifier|const
name|char
modifier|*
name|reg1
decl_stmt|,
modifier|*
name|reg2
decl_stmt|,
modifier|*
name|reg3
decl_stmt|;
comment|/* This lookup table is too sparse to make it worth typing in, but not      so large as to make a sparse array necessary.  We create the table      at runtime.  */
comment|/* NOTE: In this table, the meaning of 'numops' is:       1: single operand       2: 2 operands, load instruction      -2: 2 operands, store instruction.  */
specifier|static
name|struct
name|tabent
modifier|*
name|mem_tab
decl_stmt|;
comment|/* Opcodes of 0x8X, 9X, aX, bX, and cX must be in the table.  */
define|#
directive|define
name|MEM_MIN
value|0x80
define|#
directive|define
name|MEM_MAX
value|0xcf
define|#
directive|define
name|MEM_SIZ
value|( * sizeof(struct tabent))
specifier|static
specifier|const
name|struct
name|sparse_tabent
name|mem_init
index|[]
init|=
block|{
block|{
literal|0x80
block|,
literal|"ldob"
block|,
literal|2
block|}
block|,
block|{
literal|0x82
block|,
literal|"stob"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x84
block|,
literal|"bx"
block|,
literal|1
block|}
block|,
block|{
literal|0x85
block|,
literal|"balx"
block|,
literal|2
block|}
block|,
block|{
literal|0x86
block|,
literal|"callx"
block|,
literal|1
block|}
block|,
block|{
literal|0x88
block|,
literal|"ldos"
block|,
literal|2
block|}
block|,
block|{
literal|0x8a
block|,
literal|"stos"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x8c
block|,
literal|"lda"
block|,
literal|2
block|}
block|,
block|{
literal|0x90
block|,
literal|"ld"
block|,
literal|2
block|}
block|,
block|{
literal|0x92
block|,
literal|"st"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x98
block|,
literal|"ldl"
block|,
literal|2
block|}
block|,
block|{
literal|0x9a
block|,
literal|"stl"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0xa0
block|,
literal|"ldt"
block|,
literal|2
block|}
block|,
block|{
literal|0xa2
block|,
literal|"stt"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0xac
block|,
literal|"dcinva"
block|,
literal|1
block|}
block|,
block|{
literal|0xb0
block|,
literal|"ldq"
block|,
literal|2
block|}
block|,
block|{
literal|0xb2
block|,
literal|"stq"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0xc0
block|,
literal|"ldib"
block|,
literal|2
block|}
block|,
block|{
literal|0xc2
block|,
literal|"stib"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0xc8
block|,
literal|"ldis"
block|,
literal|2
block|}
block|,
block|{
literal|0xca
block|,
literal|"stis"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|struct
name|tabent
name|mem_tab_buf
index|[
name|MEM_MAX
operator|-
name|MEM_MIN
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|mem_tab
operator|==
name|NULL
condition|)
block|{
name|mem_tab
operator|=
name|mem_tab_buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mem_init
index|[
name|i
index|]
operator|.
name|opcode
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|mem_init
index|[
name|i
index|]
operator|.
name|opcode
operator|-
name|MEM_MIN
expr_stmt|;
name|mem_tab
index|[
name|j
index|]
operator|.
name|name
operator|=
name|mem_init
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|mem_tab
index|[
name|j
index|]
operator|.
name|numops
operator|=
name|mem_init
index|[
name|i
index|]
operator|.
name|numops
expr_stmt|;
block|}
block|}
name|i
operator|=
operator|(
operator|(
name|word1
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
operator|-
name|MEM_MIN
expr_stmt|;
name|mode
operator|=
operator|(
name|word1
operator|>>
literal|10
operator|)
operator|&
literal|0xf
expr_stmt|;
if|if
condition|(
operator|(
name|mem_tab
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|)
comment|/* Valid instruction */
operator|&&
operator|(
operator|(
name|mode
operator|==
literal|5
operator|)
operator|||
operator|(
name|mode
operator|>=
literal|12
operator|)
operator|)
condition|)
comment|/* With 32-bit displacement.  */
name|len
operator|=
literal|8
expr_stmt|;
else|else
name|len
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|noprint
condition|)
return|return
name|len
return|;
if|if
condition|(
operator|(
name|mem_tab
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mode
operator|==
literal|6
operator|)
condition|)
block|{
name|invalid
argument_list|(
name|word1
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%s\t"
argument_list|,
name|mem_tab
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|reg1
operator|=
name|reg_names
index|[
operator|(
name|word1
operator|>>
literal|19
operator|)
operator|&
literal|0x1f
index|]
expr_stmt|;
comment|/* MEMB only */
name|reg2
operator|=
name|reg_names
index|[
operator|(
name|word1
operator|>>
literal|14
operator|)
operator|&
literal|0x1f
index|]
expr_stmt|;
name|reg3
operator|=
name|reg_names
index|[
name|word1
operator|&
literal|0x1f
index|]
expr_stmt|;
comment|/* MEMB only */
name|offset
operator|=
name|word1
operator|&
literal|0xfff
expr_stmt|;
comment|/* MEMA only  */
switch|switch
condition|(
name|mem_tab
index|[
name|i
index|]
operator|.
name|numops
condition|)
block|{
case|case
literal|2
case|:
comment|/* LOAD INSTRUCTION */
if|if
condition|(
name|mode
operator|&
literal|4
condition|)
block|{
comment|/* MEMB FORMAT */
name|ea
argument_list|(
name|memaddr
argument_list|,
name|mode
argument_list|,
name|reg2
argument_list|,
name|reg3
argument_list|,
name|word1
argument_list|,
name|word2
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|",%s"
argument_list|,
name|reg1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* MEMA FORMAT */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
operator|(
name|unsigned
operator|)
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
literal|8
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"(%s)"
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|",%s"
argument_list|,
name|reg1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|-
literal|2
case|:
comment|/* STORE INSTRUCTION */
if|if
condition|(
name|mode
operator|&
literal|4
condition|)
block|{
comment|/* MEMB FORMAT */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%s,"
argument_list|,
name|reg1
argument_list|)
expr_stmt|;
name|ea
argument_list|(
name|memaddr
argument_list|,
name|mode
argument_list|,
name|reg2
argument_list|,
name|reg3
argument_list|,
name|word1
argument_list|,
name|word2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* MEMA FORMAT */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%s,0x%x"
argument_list|,
name|reg1
argument_list|,
operator|(
name|unsigned
operator|)
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
literal|8
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"(%s)"
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
comment|/* BX/CALLX INSTRUCTION */
if|if
condition|(
name|mode
operator|&
literal|4
condition|)
block|{
comment|/* MEMB FORMAT */
name|ea
argument_list|(
name|memaddr
argument_list|,
name|mode
argument_list|,
name|reg2
argument_list|,
name|reg3
argument_list|,
name|word1
argument_list|,
name|word2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* MEMA FORMAT */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
operator|(
name|unsigned
operator|)
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
literal|8
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"(%s)"
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* REG format.  */
end_comment

begin_function
specifier|static
name|void
name|reg
parameter_list|(
name|unsigned
name|long
name|word1
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|opcode
decl_stmt|;
name|int
name|fp
decl_stmt|;
name|int
name|m1
decl_stmt|,
name|m2
decl_stmt|,
name|m3
decl_stmt|;
name|int
name|s1
decl_stmt|,
name|s2
decl_stmt|;
name|int
name|src
decl_stmt|,
name|src2
decl_stmt|,
name|dst
decl_stmt|;
name|char
modifier|*
name|mnemp
decl_stmt|;
comment|/* This lookup table is too sparse to make it worth typing in, but not      so large as to make a sparse array necessary.  We create the table      at runtime.  */
comment|/* NOTE: In this table, the meaning of 'numops' is: 	 1: single operand, which is NOT a destination. 	-1: single operand, which IS a destination. 	 2: 2 operands, the 2nd of which is NOT a destination. 	-2: 2 operands, the 2nd of which IS a destination. 	 3: 3 operands  	If an opcode mnemonic begins with "F", it is a floating-point 	opcode (the "F" is not printed).  */
specifier|static
name|struct
name|tabent
modifier|*
name|reg_tab
decl_stmt|;
specifier|static
specifier|const
name|struct
name|sparse_tabent
name|reg_init
index|[]
init|=
block|{
define|#
directive|define
name|REG_MIN
value|0x580
block|{
literal|0x580
block|,
literal|"notbit"
block|,
literal|3
block|}
block|,
block|{
literal|0x581
block|,
literal|"and"
block|,
literal|3
block|}
block|,
block|{
literal|0x582
block|,
literal|"andnot"
block|,
literal|3
block|}
block|,
block|{
literal|0x583
block|,
literal|"setbit"
block|,
literal|3
block|}
block|,
block|{
literal|0x584
block|,
literal|"notand"
block|,
literal|3
block|}
block|,
block|{
literal|0x586
block|,
literal|"xor"
block|,
literal|3
block|}
block|,
block|{
literal|0x587
block|,
literal|"or"
block|,
literal|3
block|}
block|,
block|{
literal|0x588
block|,
literal|"nor"
block|,
literal|3
block|}
block|,
block|{
literal|0x589
block|,
literal|"xnor"
block|,
literal|3
block|}
block|,
block|{
literal|0x58a
block|,
literal|"not"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x58b
block|,
literal|"ornot"
block|,
literal|3
block|}
block|,
block|{
literal|0x58c
block|,
literal|"clrbit"
block|,
literal|3
block|}
block|,
block|{
literal|0x58d
block|,
literal|"notor"
block|,
literal|3
block|}
block|,
block|{
literal|0x58e
block|,
literal|"nand"
block|,
literal|3
block|}
block|,
block|{
literal|0x58f
block|,
literal|"alterbit"
block|,
literal|3
block|}
block|,
block|{
literal|0x590
block|,
literal|"addo"
block|,
literal|3
block|}
block|,
block|{
literal|0x591
block|,
literal|"addi"
block|,
literal|3
block|}
block|,
block|{
literal|0x592
block|,
literal|"subo"
block|,
literal|3
block|}
block|,
block|{
literal|0x593
block|,
literal|"subi"
block|,
literal|3
block|}
block|,
block|{
literal|0x594
block|,
literal|"cmpob"
block|,
literal|2
block|}
block|,
block|{
literal|0x595
block|,
literal|"cmpib"
block|,
literal|2
block|}
block|,
block|{
literal|0x596
block|,
literal|"cmpos"
block|,
literal|2
block|}
block|,
block|{
literal|0x597
block|,
literal|"cmpis"
block|,
literal|2
block|}
block|,
block|{
literal|0x598
block|,
literal|"shro"
block|,
literal|3
block|}
block|,
block|{
literal|0x59a
block|,
literal|"shrdi"
block|,
literal|3
block|}
block|,
block|{
literal|0x59b
block|,
literal|"shri"
block|,
literal|3
block|}
block|,
block|{
literal|0x59c
block|,
literal|"shlo"
block|,
literal|3
block|}
block|,
block|{
literal|0x59d
block|,
literal|"rotate"
block|,
literal|3
block|}
block|,
block|{
literal|0x59e
block|,
literal|"shli"
block|,
literal|3
block|}
block|,
block|{
literal|0x5a0
block|,
literal|"cmpo"
block|,
literal|2
block|}
block|,
block|{
literal|0x5a1
block|,
literal|"cmpi"
block|,
literal|2
block|}
block|,
block|{
literal|0x5a2
block|,
literal|"concmpo"
block|,
literal|2
block|}
block|,
block|{
literal|0x5a3
block|,
literal|"concmpi"
block|,
literal|2
block|}
block|,
block|{
literal|0x5a4
block|,
literal|"cmpinco"
block|,
literal|3
block|}
block|,
block|{
literal|0x5a5
block|,
literal|"cmpinci"
block|,
literal|3
block|}
block|,
block|{
literal|0x5a6
block|,
literal|"cmpdeco"
block|,
literal|3
block|}
block|,
block|{
literal|0x5a7
block|,
literal|"cmpdeci"
block|,
literal|3
block|}
block|,
block|{
literal|0x5ac
block|,
literal|"scanbyte"
block|,
literal|2
block|}
block|,
block|{
literal|0x5ad
block|,
literal|"bswap"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x5ae
block|,
literal|"chkbit"
block|,
literal|2
block|}
block|,
block|{
literal|0x5b0
block|,
literal|"addc"
block|,
literal|3
block|}
block|,
block|{
literal|0x5b2
block|,
literal|"subc"
block|,
literal|3
block|}
block|,
block|{
literal|0x5b4
block|,
literal|"intdis"
block|,
literal|0
block|}
block|,
block|{
literal|0x5b5
block|,
literal|"inten"
block|,
literal|0
block|}
block|,
block|{
literal|0x5cc
block|,
literal|"mov"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x5d8
block|,
literal|"eshro"
block|,
literal|3
block|}
block|,
block|{
literal|0x5dc
block|,
literal|"movl"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x5ec
block|,
literal|"movt"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x5fc
block|,
literal|"movq"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x600
block|,
literal|"synmov"
block|,
literal|2
block|}
block|,
block|{
literal|0x601
block|,
literal|"synmovl"
block|,
literal|2
block|}
block|,
block|{
literal|0x602
block|,
literal|"synmovq"
block|,
literal|2
block|}
block|,
block|{
literal|0x603
block|,
literal|"cmpstr"
block|,
literal|3
block|}
block|,
block|{
literal|0x604
block|,
literal|"movqstr"
block|,
literal|3
block|}
block|,
block|{
literal|0x605
block|,
literal|"movstr"
block|,
literal|3
block|}
block|,
block|{
literal|0x610
block|,
literal|"atmod"
block|,
literal|3
block|}
block|,
block|{
literal|0x612
block|,
literal|"atadd"
block|,
literal|3
block|}
block|,
block|{
literal|0x613
block|,
literal|"inspacc"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x614
block|,
literal|"ldphy"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x615
block|,
literal|"synld"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x617
block|,
literal|"fill"
block|,
literal|3
block|}
block|,
block|{
literal|0x630
block|,
literal|"sdma"
block|,
literal|3
block|}
block|,
block|{
literal|0x631
block|,
literal|"udma"
block|,
literal|0
block|}
block|,
block|{
literal|0x640
block|,
literal|"spanbit"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x641
block|,
literal|"scanbit"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x642
block|,
literal|"daddc"
block|,
literal|3
block|}
block|,
block|{
literal|0x643
block|,
literal|"dsubc"
block|,
literal|3
block|}
block|,
block|{
literal|0x644
block|,
literal|"dmovt"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x645
block|,
literal|"modac"
block|,
literal|3
block|}
block|,
block|{
literal|0x646
block|,
literal|"condrec"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x650
block|,
literal|"modify"
block|,
literal|3
block|}
block|,
block|{
literal|0x651
block|,
literal|"extract"
block|,
literal|3
block|}
block|,
block|{
literal|0x654
block|,
literal|"modtc"
block|,
literal|3
block|}
block|,
block|{
literal|0x655
block|,
literal|"modpc"
block|,
literal|3
block|}
block|,
block|{
literal|0x656
block|,
literal|"receive"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x658
block|,
literal|"intctl"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x659
block|,
literal|"sysctl"
block|,
literal|3
block|}
block|,
block|{
literal|0x65b
block|,
literal|"icctl"
block|,
literal|3
block|}
block|,
block|{
literal|0x65c
block|,
literal|"dcctl"
block|,
literal|3
block|}
block|,
block|{
literal|0x65d
block|,
literal|"halt"
block|,
literal|0
block|}
block|,
block|{
literal|0x660
block|,
literal|"calls"
block|,
literal|1
block|}
block|,
block|{
literal|0x662
block|,
literal|"send"
block|,
literal|3
block|}
block|,
block|{
literal|0x663
block|,
literal|"sendserv"
block|,
literal|1
block|}
block|,
block|{
literal|0x664
block|,
literal|"resumprcs"
block|,
literal|1
block|}
block|,
block|{
literal|0x665
block|,
literal|"schedprcs"
block|,
literal|1
block|}
block|,
block|{
literal|0x666
block|,
literal|"saveprcs"
block|,
literal|0
block|}
block|,
block|{
literal|0x668
block|,
literal|"condwait"
block|,
literal|1
block|}
block|,
block|{
literal|0x669
block|,
literal|"wait"
block|,
literal|1
block|}
block|,
block|{
literal|0x66a
block|,
literal|"signal"
block|,
literal|1
block|}
block|,
block|{
literal|0x66b
block|,
literal|"mark"
block|,
literal|0
block|}
block|,
block|{
literal|0x66c
block|,
literal|"fmark"
block|,
literal|0
block|}
block|,
block|{
literal|0x66d
block|,
literal|"flushreg"
block|,
literal|0
block|}
block|,
block|{
literal|0x66f
block|,
literal|"syncf"
block|,
literal|0
block|}
block|,
block|{
literal|0x670
block|,
literal|"emul"
block|,
literal|3
block|}
block|,
block|{
literal|0x671
block|,
literal|"ediv"
block|,
literal|3
block|}
block|,
block|{
literal|0x673
block|,
literal|"ldtime"
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|0x674
block|,
literal|"Fcvtir"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x675
block|,
literal|"Fcvtilr"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x676
block|,
literal|"Fscalerl"
block|,
literal|3
block|}
block|,
block|{
literal|0x677
block|,
literal|"Fscaler"
block|,
literal|3
block|}
block|,
block|{
literal|0x680
block|,
literal|"Fatanr"
block|,
literal|3
block|}
block|,
block|{
literal|0x681
block|,
literal|"Flogepr"
block|,
literal|3
block|}
block|,
block|{
literal|0x682
block|,
literal|"Flogr"
block|,
literal|3
block|}
block|,
block|{
literal|0x683
block|,
literal|"Fremr"
block|,
literal|3
block|}
block|,
block|{
literal|0x684
block|,
literal|"Fcmpor"
block|,
literal|2
block|}
block|,
block|{
literal|0x685
block|,
literal|"Fcmpr"
block|,
literal|2
block|}
block|,
block|{
literal|0x688
block|,
literal|"Fsqrtr"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x689
block|,
literal|"Fexpr"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x68a
block|,
literal|"Flogbnr"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x68b
block|,
literal|"Froundr"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x68c
block|,
literal|"Fsinr"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x68d
block|,
literal|"Fcosr"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x68e
block|,
literal|"Ftanr"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x68f
block|,
literal|"Fclassr"
block|,
literal|1
block|}
block|,
block|{
literal|0x690
block|,
literal|"Fatanrl"
block|,
literal|3
block|}
block|,
block|{
literal|0x691
block|,
literal|"Flogeprl"
block|,
literal|3
block|}
block|,
block|{
literal|0x692
block|,
literal|"Flogrl"
block|,
literal|3
block|}
block|,
block|{
literal|0x693
block|,
literal|"Fremrl"
block|,
literal|3
block|}
block|,
block|{
literal|0x694
block|,
literal|"Fcmporl"
block|,
literal|2
block|}
block|,
block|{
literal|0x695
block|,
literal|"Fcmprl"
block|,
literal|2
block|}
block|,
block|{
literal|0x698
block|,
literal|"Fsqrtrl"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x699
block|,
literal|"Fexprl"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x69a
block|,
literal|"Flogbnrl"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x69b
block|,
literal|"Froundrl"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x69c
block|,
literal|"Fsinrl"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x69d
block|,
literal|"Fcosrl"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x69e
block|,
literal|"Ftanrl"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x69f
block|,
literal|"Fclassrl"
block|,
literal|1
block|}
block|,
block|{
literal|0x6c0
block|,
literal|"Fcvtri"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x6c1
block|,
literal|"Fcvtril"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x6c2
block|,
literal|"Fcvtzri"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x6c3
block|,
literal|"Fcvtzril"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x6c9
block|,
literal|"Fmovr"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x6d9
block|,
literal|"Fmovrl"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x6e1
block|,
literal|"Fmovre"
block|,
operator|-
literal|2
block|}
block|,
block|{
literal|0x6e2
block|,
literal|"Fcpysre"
block|,
literal|3
block|}
block|,
block|{
literal|0x6e3
block|,
literal|"Fcpyrsre"
block|,
literal|3
block|}
block|,
block|{
literal|0x701
block|,
literal|"mulo"
block|,
literal|3
block|}
block|,
block|{
literal|0x708
block|,
literal|"remo"
block|,
literal|3
block|}
block|,
block|{
literal|0x70b
block|,
literal|"divo"
block|,
literal|3
block|}
block|,
block|{
literal|0x741
block|,
literal|"muli"
block|,
literal|3
block|}
block|,
block|{
literal|0x748
block|,
literal|"remi"
block|,
literal|3
block|}
block|,
block|{
literal|0x749
block|,
literal|"modi"
block|,
literal|3
block|}
block|,
block|{
literal|0x74b
block|,
literal|"divi"
block|,
literal|3
block|}
block|,
block|{
literal|0x780
block|,
literal|"addono"
block|,
literal|3
block|}
block|,
block|{
literal|0x781
block|,
literal|"addino"
block|,
literal|3
block|}
block|,
block|{
literal|0x782
block|,
literal|"subono"
block|,
literal|3
block|}
block|,
block|{
literal|0x783
block|,
literal|"subino"
block|,
literal|3
block|}
block|,
block|{
literal|0x784
block|,
literal|"selno"
block|,
literal|3
block|}
block|,
block|{
literal|0x78b
block|,
literal|"Fdivr"
block|,
literal|3
block|}
block|,
block|{
literal|0x78c
block|,
literal|"Fmulr"
block|,
literal|3
block|}
block|,
block|{
literal|0x78d
block|,
literal|"Fsubr"
block|,
literal|3
block|}
block|,
block|{
literal|0x78f
block|,
literal|"Faddr"
block|,
literal|3
block|}
block|,
block|{
literal|0x790
block|,
literal|"addog"
block|,
literal|3
block|}
block|,
block|{
literal|0x791
block|,
literal|"addig"
block|,
literal|3
block|}
block|,
block|{
literal|0x792
block|,
literal|"subog"
block|,
literal|3
block|}
block|,
block|{
literal|0x793
block|,
literal|"subig"
block|,
literal|3
block|}
block|,
block|{
literal|0x794
block|,
literal|"selg"
block|,
literal|3
block|}
block|,
block|{
literal|0x79b
block|,
literal|"Fdivrl"
block|,
literal|3
block|}
block|,
block|{
literal|0x79c
block|,
literal|"Fmulrl"
block|,
literal|3
block|}
block|,
block|{
literal|0x79d
block|,
literal|"Fsubrl"
block|,
literal|3
block|}
block|,
block|{
literal|0x79f
block|,
literal|"Faddrl"
block|,
literal|3
block|}
block|,
block|{
literal|0x7a0
block|,
literal|"addoe"
block|,
literal|3
block|}
block|,
block|{
literal|0x7a1
block|,
literal|"addie"
block|,
literal|3
block|}
block|,
block|{
literal|0x7a2
block|,
literal|"suboe"
block|,
literal|3
block|}
block|,
block|{
literal|0x7a3
block|,
literal|"subie"
block|,
literal|3
block|}
block|,
block|{
literal|0x7a4
block|,
literal|"sele"
block|,
literal|3
block|}
block|,
block|{
literal|0x7b0
block|,
literal|"addoge"
block|,
literal|3
block|}
block|,
block|{
literal|0x7b1
block|,
literal|"addige"
block|,
literal|3
block|}
block|,
block|{
literal|0x7b2
block|,
literal|"suboge"
block|,
literal|3
block|}
block|,
block|{
literal|0x7b3
block|,
literal|"subige"
block|,
literal|3
block|}
block|,
block|{
literal|0x7b4
block|,
literal|"selge"
block|,
literal|3
block|}
block|,
block|{
literal|0x7c0
block|,
literal|"addol"
block|,
literal|3
block|}
block|,
block|{
literal|0x7c1
block|,
literal|"addil"
block|,
literal|3
block|}
block|,
block|{
literal|0x7c2
block|,
literal|"subol"
block|,
literal|3
block|}
block|,
block|{
literal|0x7c3
block|,
literal|"subil"
block|,
literal|3
block|}
block|,
block|{
literal|0x7c4
block|,
literal|"sell"
block|,
literal|3
block|}
block|,
block|{
literal|0x7d0
block|,
literal|"addone"
block|,
literal|3
block|}
block|,
block|{
literal|0x7d1
block|,
literal|"addine"
block|,
literal|3
block|}
block|,
block|{
literal|0x7d2
block|,
literal|"subone"
block|,
literal|3
block|}
block|,
block|{
literal|0x7d3
block|,
literal|"subine"
block|,
literal|3
block|}
block|,
block|{
literal|0x7d4
block|,
literal|"selne"
block|,
literal|3
block|}
block|,
block|{
literal|0x7e0
block|,
literal|"addole"
block|,
literal|3
block|}
block|,
block|{
literal|0x7e1
block|,
literal|"addile"
block|,
literal|3
block|}
block|,
block|{
literal|0x7e2
block|,
literal|"subole"
block|,
literal|3
block|}
block|,
block|{
literal|0x7e3
block|,
literal|"subile"
block|,
literal|3
block|}
block|,
block|{
literal|0x7e4
block|,
literal|"selle"
block|,
literal|3
block|}
block|,
block|{
literal|0x7f0
block|,
literal|"addoo"
block|,
literal|3
block|}
block|,
block|{
literal|0x7f1
block|,
literal|"addio"
block|,
literal|3
block|}
block|,
block|{
literal|0x7f2
block|,
literal|"suboo"
block|,
literal|3
block|}
block|,
block|{
literal|0x7f3
block|,
literal|"subio"
block|,
literal|3
block|}
block|,
block|{
literal|0x7f4
block|,
literal|"selo"
block|,
literal|3
block|}
block|,
define|#
directive|define
name|REG_MAX
value|0x7f4
block|{
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|struct
name|tabent
name|reg_tab_buf
index|[
name|REG_MAX
operator|-
name|REG_MIN
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|reg_tab
operator|==
name|NULL
condition|)
block|{
name|reg_tab
operator|=
name|reg_tab_buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|reg_init
index|[
name|i
index|]
operator|.
name|opcode
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|reg_init
index|[
name|i
index|]
operator|.
name|opcode
operator|-
name|REG_MIN
expr_stmt|;
name|reg_tab
index|[
name|j
index|]
operator|.
name|name
operator|=
name|reg_init
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|reg_tab
index|[
name|j
index|]
operator|.
name|numops
operator|=
name|reg_init
index|[
name|i
index|]
operator|.
name|numops
expr_stmt|;
block|}
block|}
name|opcode
operator|=
operator|(
operator|(
name|word1
operator|>>
literal|20
operator|)
operator|&
literal|0xff0
operator|)
operator||
operator|(
operator|(
name|word1
operator|>>
literal|7
operator|)
operator|&
literal|0xf
operator|)
expr_stmt|;
name|i
operator|=
name|opcode
operator|-
name|REG_MIN
expr_stmt|;
if|if
condition|(
operator|(
name|opcode
operator|<
name|REG_MIN
operator|)
operator|||
operator|(
name|opcode
operator|>
name|REG_MAX
operator|)
operator|||
operator|(
name|reg_tab
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
operator|)
condition|)
block|{
name|invalid
argument_list|(
name|word1
argument_list|)
expr_stmt|;
return|return;
block|}
name|mnemp
operator|=
name|reg_tab
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
if|if
condition|(
operator|*
name|mnemp
operator|==
literal|'F'
condition|)
block|{
name|fp
operator|=
literal|1
expr_stmt|;
name|mnemp
operator|++
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
literal|0
expr_stmt|;
block|}
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
name|mnemp
argument_list|)
expr_stmt|;
name|s1
operator|=
operator|(
name|word1
operator|>>
literal|5
operator|)
operator|&
literal|1
expr_stmt|;
name|s2
operator|=
operator|(
name|word1
operator|>>
literal|6
operator|)
operator|&
literal|1
expr_stmt|;
name|m1
operator|=
operator|(
name|word1
operator|>>
literal|11
operator|)
operator|&
literal|1
expr_stmt|;
name|m2
operator|=
operator|(
name|word1
operator|>>
literal|12
operator|)
operator|&
literal|1
expr_stmt|;
name|m3
operator|=
operator|(
name|word1
operator|>>
literal|13
operator|)
operator|&
literal|1
expr_stmt|;
name|src
operator|=
name|word1
operator|&
literal|0x1f
expr_stmt|;
name|src2
operator|=
operator|(
name|word1
operator|>>
literal|14
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|dst
operator|=
operator|(
name|word1
operator|>>
literal|19
operator|)
operator|&
literal|0x1f
expr_stmt|;
if|if
condition|(
name|reg_tab
index|[
name|i
index|]
operator|.
name|numops
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reg_tab
index|[
name|i
index|]
operator|.
name|numops
condition|)
block|{
case|case
literal|1
case|:
name|regop
argument_list|(
name|m1
argument_list|,
name|s1
argument_list|,
name|src
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
name|dstop
argument_list|(
name|m3
argument_list|,
name|dst
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|regop
argument_list|(
name|m1
argument_list|,
name|s1
argument_list|,
name|src
argument_list|,
name|fp
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|regop
argument_list|(
name|m2
argument_list|,
name|s2
argument_list|,
name|src2
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
operator|-
literal|2
case|:
name|regop
argument_list|(
name|m1
argument_list|,
name|s1
argument_list|,
name|src
argument_list|,
name|fp
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|dstop
argument_list|(
name|m3
argument_list|,
name|dst
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|regop
argument_list|(
name|m1
argument_list|,
name|s1
argument_list|,
name|src
argument_list|,
name|fp
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|regop
argument_list|(
name|m2
argument_list|,
name|s2
argument_list|,
name|src2
argument_list|,
name|fp
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|dstop
argument_list|(
name|m3
argument_list|,
name|dst
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Print out effective address for memb instructions.  */
end_comment

begin_function
specifier|static
name|void
name|ea
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|int
name|mode
parameter_list|,
specifier|const
name|char
modifier|*
name|reg2
parameter_list|,
specifier|const
name|char
modifier|*
name|reg3
parameter_list|,
name|int
name|word1
parameter_list|,
name|unsigned
name|int
name|word2
parameter_list|)
block|{
name|int
name|scale
decl_stmt|;
specifier|static
specifier|const
name|int
name|scale_tab
index|[]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|8
block|,
literal|16
block|}
decl_stmt|;
name|scale
operator|=
operator|(
name|word1
operator|>>
literal|7
operator|)
operator|&
literal|0x07
expr_stmt|;
if|if
condition|(
operator|(
name|scale
operator|>
literal|4
operator|)
operator|||
operator|(
operator|(
operator|(
name|word1
operator|>>
literal|5
operator|)
operator|&
literal|0x03
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|invalid
argument_list|(
name|word1
argument_list|)
expr_stmt|;
return|return;
block|}
name|scale
operator|=
name|scale_tab
index|[
name|scale
index|]
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|4
case|:
comment|/* (reg) */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"(%s)"
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* displ+8(ip) */
name|print_addr
argument_list|(
name|word2
operator|+
literal|8
operator|+
name|memaddr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* (reg)[index*scale] */
if|if
condition|(
name|scale
operator|==
literal|1
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"(%s)[%s]"
argument_list|,
name|reg2
argument_list|,
name|reg3
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"(%s)[%s*%d]"
argument_list|,
name|reg2
argument_list|,
name|reg3
argument_list|,
name|scale
argument_list|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
comment|/* displacement */
name|print_addr
argument_list|(
operator|(
name|bfd_vma
operator|)
name|word2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|13
case|:
comment|/* displ(reg) */
name|print_addr
argument_list|(
operator|(
name|bfd_vma
operator|)
name|word2
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"(%s)"
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|14
case|:
comment|/* displ[index*scale] */
name|print_addr
argument_list|(
operator|(
name|bfd_vma
operator|)
name|word2
argument_list|)
expr_stmt|;
if|if
condition|(
name|scale
operator|==
literal|1
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"[%s]"
argument_list|,
name|reg3
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"[%s*%d]"
argument_list|,
name|reg3
argument_list|,
name|scale
argument_list|)
expr_stmt|;
break|break;
case|case
literal|15
case|:
comment|/* displ(reg)[index*scale] */
name|print_addr
argument_list|(
operator|(
name|bfd_vma
operator|)
name|word2
argument_list|)
expr_stmt|;
if|if
condition|(
name|scale
operator|==
literal|1
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"(%s)[%s]"
argument_list|,
name|reg2
argument_list|,
name|reg3
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"(%s)[%s*%d]"
argument_list|,
name|reg2
argument_list|,
name|reg3
argument_list|,
name|scale
argument_list|)
expr_stmt|;
break|break;
default|default:
name|invalid
argument_list|(
name|word1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Register Instruction Operand.  */
end_comment

begin_function
specifier|static
name|void
name|regop
parameter_list|(
name|int
name|mode
parameter_list|,
name|int
name|spec
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|fp
parameter_list|)
block|{
if|if
condition|(
name|fp
condition|)
block|{
comment|/* Floating point instruction.  */
if|if
condition|(
name|mode
operator|==
literal|1
condition|)
block|{
comment|/* FP operand.  */
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
literal|0
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"fp0"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"fp1"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"fp2"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"fp3"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"0f0.0"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|22
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"0f1.0"
argument_list|)
expr_stmt|;
break|break;
default|default:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* Non-FP register.  */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
name|reg_names
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Not floating point.  */
if|if
condition|(
name|mode
operator|==
literal|1
condition|)
block|{
comment|/* Literal.  */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Register.  */
if|if
condition|(
name|spec
operator|==
literal|0
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
name|reg_names
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"sf%d"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Register Instruction Destination Operand.  */
end_comment

begin_function
specifier|static
name|void
name|dstop
parameter_list|(
name|int
name|mode
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|fp
parameter_list|)
block|{
comment|/* 'dst' operand can't be a literal. On non-FP instructions,  register      mode is assumed and "m3" acts as if were "s3";  on FP-instructions,      sf registers are not allowed so m3 acts normally.  */
if|if
condition|(
name|fp
condition|)
name|regop
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
name|regop
argument_list|(
literal|0
argument_list|,
name|mode
argument_list|,
name|reg
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|invalid
parameter_list|(
name|int
name|word1
parameter_list|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|".word\t0x%08x"
argument_list|,
operator|(
name|unsigned
operator|)
name|word1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_addr
parameter_list|(
name|bfd_vma
name|a
parameter_list|)
block|{
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|a
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|put_abs
parameter_list|(
name|unsigned
name|long
name|word1
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|long
name|word2
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|IN_GDB
return|return;
else|#
directive|else
name|int
name|len
decl_stmt|;
switch|switch
condition|(
operator|(
name|word1
operator|>>
literal|28
operator|)
operator|&
literal|0xf
condition|)
block|{
case|case
literal|0x8
case|:
case|case
literal|0x9
case|:
case|case
literal|0xa
case|:
case|case
literal|0xb
case|:
case|case
literal|0xc
case|:
comment|/* MEM format instruction.  */
name|len
operator|=
name|mem
argument_list|(
literal|0
argument_list|,
name|word1
argument_list|,
name|word2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|len
operator|=
literal|4
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|len
operator|==
literal|8
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%08x %08x\t"
argument_list|,
name|word1
argument_list|,
name|word2
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%08x         \t"
argument_list|,
name|word1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

