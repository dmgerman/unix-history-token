begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Disassemble h8500 instructions.    Copyright 1993, 1998, 2000, 2001, 2002, 2004, 2005    Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,    MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|DISASSEMBLER_TABLE
end_define

begin_define
define|#
directive|define
name|DEFINE_TABLE
end_define

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"h8500-opc.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"opintl.h"
end_include

begin_comment
comment|/* Maximum length of an instruction.  */
end_comment

begin_define
define|#
directive|define
name|MAXLEN
value|8
end_define

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_struct
struct|struct
name|private
block|{
comment|/* Points to first byte not fetched.  */
name|bfd_byte
modifier|*
name|max_fetched
decl_stmt|;
name|bfd_byte
name|the_buffer
index|[
name|MAXLEN
index|]
decl_stmt|;
name|bfd_vma
name|insn_start
decl_stmt|;
name|jmp_buf
name|bailout
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Make sure that bytes from INFO->PRIVATE_DATA->BUFFER (inclusive)    to ADDR (exclusive) are valid.  Returns 1 for success, longjmps    on error.  */
end_comment

begin_define
define|#
directive|define
name|FETCH_DATA
parameter_list|(
name|info
parameter_list|,
name|addr
parameter_list|)
define|\
value|((addr)<= ((struct private *)(info->private_data))->max_fetched \    ? 1 : fetch_data ((info), (addr)))
end_define

begin_function
specifier|static
name|int
name|fetch_data
parameter_list|(
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|bfd_byte
modifier|*
name|addr
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|struct
name|private
modifier|*
name|priv
init|=
operator|(
expr|struct
name|private
operator|*
operator|)
name|info
operator|->
name|private_data
decl_stmt|;
name|bfd_vma
name|start
init|=
name|priv
operator|->
name|insn_start
operator|+
operator|(
name|priv
operator|->
name|max_fetched
operator|-
name|priv
operator|->
name|the_buffer
operator|)
decl_stmt|;
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|start
argument_list|,
name|priv
operator|->
name|max_fetched
argument_list|,
name|addr
operator|-
name|priv
operator|->
name|max_fetched
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|memory_error_func
call|)
argument_list|(
name|status
argument_list|,
name|start
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|priv
operator|->
name|bailout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|priv
operator|->
name|max_fetched
operator|=
name|addr
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|crname
index|[]
init|=
block|{
literal|"sr"
block|,
literal|"ccr"
block|,
literal|"*"
block|,
literal|"br"
block|,
literal|"ep"
block|,
literal|"dp"
block|,
literal|"*"
block|,
literal|"tp"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|print_insn_h8500
parameter_list|(
name|bfd_vma
name|addr
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
specifier|const
name|h8500_opcode_info
modifier|*
name|opcode
decl_stmt|;
name|void
modifier|*
name|stream
init|=
name|info
operator|->
name|stream
decl_stmt|;
name|fprintf_ftype
name|func
init|=
name|info
operator|->
name|fprintf_func
decl_stmt|;
name|struct
name|private
name|priv
decl_stmt|;
name|bfd_byte
modifier|*
name|buffer
init|=
name|priv
operator|.
name|the_buffer
decl_stmt|;
name|info
operator|->
name|private_data
operator|=
operator|(
name|PTR
operator|)
operator|&
name|priv
expr_stmt|;
name|priv
operator|.
name|max_fetched
operator|=
name|priv
operator|.
name|the_buffer
expr_stmt|;
name|priv
operator|.
name|insn_start
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|priv
operator|.
name|bailout
argument_list|)
operator|!=
literal|0
condition|)
comment|/* Error return.  */
return|return
operator|-
literal|1
return|;
comment|/* Run down the table to find the one which matches.  */
for|for
control|(
name|opcode
operator|=
name|h8500_table
init|;
name|opcode
operator|->
name|name
condition|;
name|opcode
operator|++
control|)
block|{
name|int
name|byte
decl_stmt|;
name|int
name|rn
init|=
literal|0
decl_stmt|;
name|int
name|rd
init|=
literal|0
decl_stmt|;
name|int
name|rs
init|=
literal|0
decl_stmt|;
name|int
name|disp
init|=
literal|0
decl_stmt|;
name|int
name|abs
init|=
literal|0
decl_stmt|;
name|int
name|imm
init|=
literal|0
decl_stmt|;
name|int
name|pcrel
init|=
literal|0
decl_stmt|;
name|int
name|qim
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|cr
init|=
literal|0
decl_stmt|;
for|for
control|(
name|byte
operator|=
literal|0
init|;
name|byte
operator|<
name|opcode
operator|->
name|length
condition|;
name|byte
operator|++
control|)
block|{
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
name|byte
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|buffer
index|[
name|byte
index|]
operator|&
name|opcode
operator|->
name|bytes
index|[
name|byte
index|]
operator|.
name|mask
operator|)
operator|!=
operator|(
name|opcode
operator|->
name|bytes
index|[
name|byte
index|]
operator|.
name|contents
operator|)
condition|)
goto|goto
name|next
goto|;
else|else
block|{
comment|/* Extract any info parts.  */
switch|switch
condition|(
name|opcode
operator|->
name|bytes
index|[
name|byte
index|]
operator|.
name|insert
condition|)
block|{
case|case
literal|0
case|:
case|case
name|FP
case|:
break|break;
default|default:
comment|/* xgettext:c-format */
name|func
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"can't cope with insert %d\n"
argument_list|)
argument_list|,
name|opcode
operator|->
name|bytes
index|[
name|byte
index|]
operator|.
name|insert
argument_list|)
expr_stmt|;
break|break;
case|case
name|RN
case|:
name|rn
operator|=
name|buffer
index|[
name|byte
index|]
operator|&
literal|0x7
expr_stmt|;
break|break;
case|case
name|RS
case|:
name|rs
operator|=
name|buffer
index|[
name|byte
index|]
operator|&
literal|0x7
expr_stmt|;
break|break;
case|case
name|CRB
case|:
name|cr
operator|=
name|buffer
index|[
name|byte
index|]
operator|&
literal|0x7
expr_stmt|;
if|if
condition|(
name|cr
operator|==
literal|0
condition|)
goto|goto
name|next
goto|;
break|break;
case|case
name|CRW
case|:
name|cr
operator|=
name|buffer
index|[
name|byte
index|]
operator|&
literal|0x7
expr_stmt|;
if|if
condition|(
name|cr
operator|!=
literal|0
condition|)
goto|goto
name|next
goto|;
break|break;
case|case
name|DISP16
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
name|byte
operator|+
literal|2
argument_list|)
expr_stmt|;
name|disp
operator|=
operator|(
name|buffer
index|[
name|byte
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|buffer
index|[
name|byte
operator|+
literal|1
index|]
operator|)
expr_stmt|;
break|break;
case|case
name|FPIND_D8
case|:
case|case
name|DISP8
case|:
name|disp
operator|=
operator|(
call|(
name|char
call|)
argument_list|(
name|buffer
index|[
name|byte
index|]
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|RD
case|:
case|case
name|RDIND
case|:
name|rd
operator|=
name|buffer
index|[
name|byte
index|]
operator|&
literal|0x7
expr_stmt|;
break|break;
case|case
name|ABS24
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
name|byte
operator|+
literal|3
argument_list|)
expr_stmt|;
name|abs
operator|=
operator|(
name|buffer
index|[
name|byte
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|buffer
index|[
name|byte
operator|+
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|buffer
index|[
name|byte
operator|+
literal|2
index|]
operator|)
expr_stmt|;
break|break;
case|case
name|ABS16
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
name|byte
operator|+
literal|2
argument_list|)
expr_stmt|;
name|abs
operator|=
operator|(
name|buffer
index|[
name|byte
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|buffer
index|[
name|byte
operator|+
literal|1
index|]
operator|)
expr_stmt|;
break|break;
case|case
name|ABS8
case|:
name|abs
operator|=
operator|(
name|buffer
index|[
name|byte
index|]
operator|)
expr_stmt|;
break|break;
case|case
name|IMM16
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
name|byte
operator|+
literal|2
argument_list|)
expr_stmt|;
name|imm
operator|=
operator|(
name|buffer
index|[
name|byte
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|buffer
index|[
name|byte
operator|+
literal|1
index|]
operator|)
expr_stmt|;
break|break;
case|case
name|IMM4
case|:
name|imm
operator|=
operator|(
name|buffer
index|[
name|byte
index|]
operator|)
operator|&
literal|0xf
expr_stmt|;
break|break;
case|case
name|IMM8
case|:
case|case
name|RLIST
case|:
name|imm
operator|=
operator|(
name|buffer
index|[
name|byte
index|]
operator|)
expr_stmt|;
break|break;
case|case
name|PCREL16
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
name|byte
operator|+
literal|2
argument_list|)
expr_stmt|;
name|pcrel
operator|=
operator|(
name|buffer
index|[
name|byte
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|buffer
index|[
name|byte
operator|+
literal|1
index|]
operator|)
expr_stmt|;
break|break;
case|case
name|PCREL8
case|:
name|pcrel
operator|=
operator|(
name|buffer
index|[
name|byte
index|]
operator|)
expr_stmt|;
break|break;
case|case
name|QIM
case|:
switch|switch
condition|(
name|buffer
index|[
name|byte
index|]
operator|&
literal|0x7
condition|)
block|{
case|case
literal|0
case|:
name|qim
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|qim
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|qim
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|qim
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
block|}
comment|/* We get here when all the masks have passed so we can output 	 the operands.  */
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
name|opcode
operator|->
name|length
argument_list|)
expr_stmt|;
call|(
name|func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%s\t"
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opcode
operator|->
name|nargs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
call|(
name|func
call|)
argument_list|(
name|stream
argument_list|,
literal|","
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opcode
operator|->
name|arg_type
index|[
name|i
index|]
condition|)
block|{
case|case
name|FP
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"fp"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RNIND_D16
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"@(0x%x:16,r%d)"
argument_list|,
name|disp
argument_list|,
name|rn
argument_list|)
expr_stmt|;
break|break;
case|case
name|RNIND_D8
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"@(0x%x:8 (%d),r%d)"
argument_list|,
name|disp
operator|&
literal|0xff
argument_list|,
name|disp
argument_list|,
name|rn
argument_list|)
expr_stmt|;
break|break;
case|case
name|RDIND_D16
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"@(0x%x:16,r%d)"
argument_list|,
name|disp
argument_list|,
name|rd
argument_list|)
expr_stmt|;
break|break;
case|case
name|RDIND_D8
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"@(0x%x:8 (%d), r%d)"
argument_list|,
name|disp
operator|&
literal|0xff
argument_list|,
name|disp
argument_list|,
name|rd
argument_list|)
expr_stmt|;
break|break;
case|case
name|FPIND_D8
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"@(0x%x:8 (%d), fp)"
argument_list|,
name|disp
operator|&
literal|0xff
argument_list|,
name|disp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CRB
case|:
case|case
name|CRW
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|crname
index|[
name|cr
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|RN
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"r%d"
argument_list|,
name|rn
argument_list|)
expr_stmt|;
break|break;
case|case
name|RD
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"r%d"
argument_list|,
name|rd
argument_list|)
expr_stmt|;
break|break;
case|case
name|RS
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"r%d"
argument_list|,
name|rs
argument_list|)
expr_stmt|;
break|break;
case|case
name|RNDEC
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"@-r%d"
argument_list|,
name|rn
argument_list|)
expr_stmt|;
break|break;
case|case
name|RNINC
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"@r%d+"
argument_list|,
name|rn
argument_list|)
expr_stmt|;
break|break;
case|case
name|RNIND
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"@r%d"
argument_list|,
name|rn
argument_list|)
expr_stmt|;
break|break;
case|case
name|RDIND
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"@r%d"
argument_list|,
name|rd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPINC
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"@sp+"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPDEC
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"@-sp"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS24
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"@0x%0x:24"
argument_list|,
name|abs
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS16
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"@0x%0x:16"
argument_list|,
name|abs
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS8
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"@0x%0x:8"
argument_list|,
name|abs
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMM16
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"#0x%0x:16"
argument_list|,
name|imm
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
break|break;
case|case
name|RLIST
case|:
block|{
name|int
name|i
decl_stmt|;
name|int
name|nc
init|=
literal|0
decl_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|imm
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|func
argument_list|(
name|stream
argument_list|,
literal|"r%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|nc
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|nc
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|func
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IMM8
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"#0x%0x:8"
argument_list|,
name|imm
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCREL16
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"0x%0x:16"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|pcrel
operator|+
name|addr
operator|+
name|opcode
operator|->
name|length
argument_list|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCREL8
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"#0x%0x:8"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|char
operator|)
name|pcrel
operator|+
name|addr
operator|+
name|opcode
operator|->
name|length
argument_list|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
break|break;
case|case
name|QIM
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"#%d:q"
argument_list|,
name|qim
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMM4
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"#%d:4"
argument_list|,
name|imm
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|opcode
operator|->
name|length
return|;
name|next
label|:
empty_stmt|;
block|}
comment|/* Couldn't understand anything.  */
comment|/* xgettext:c-format */
name|func
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"%02x\t\t*unknown*"
argument_list|)
argument_list|,
name|buffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

