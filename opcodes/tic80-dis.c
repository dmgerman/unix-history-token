begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print TI TMS320C80 (MVP) instructions    Copyright 1996, 1997, 1998, 2000, 2005 Free Software Foundation, Inc.     This file is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,    MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"opcode/tic80.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Print an integer operand.  Try to be somewhat smart about the    format by assuming that small positive or negative integers are    probably loop increment values, structure offsets, or similar    values that are more meaningful printed as signed decimal values.    Larger numbers are probably better printed as hex values.  */
end_comment

begin_function
specifier|static
name|void
name|print_operand_integer
parameter_list|(
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|long
name|value
parameter_list|)
block|{
if|if
condition|(
operator|(
name|value
operator|>
literal|9999
operator|||
name|value
operator|<
operator|-
literal|9999
operator|)
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%#lx"
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%ld"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* FIXME: depends upon sizeof (long) == sizeof (float) and    also upon host floating point format matching target    floating point format.  */
end_comment

begin_function
specifier|static
name|void
name|print_operand_float
parameter_list|(
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|long
name|value
parameter_list|)
block|{
union|union
block|{
name|float
name|f
decl_stmt|;
name|long
name|l
decl_stmt|;
block|}
name|fval
union|;
name|fval
operator|.
name|l
operator|=
name|value
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%g"
argument_list|,
name|fval
operator|.
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_operand_control_register
parameter_list|(
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|long
name|value
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|tic80_value_to_symbol
argument_list|(
name|value
argument_list|,
name|TIC80_OPERAND_CR
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%#lx"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_operand_condition_code
parameter_list|(
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|long
name|value
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|tic80_value_to_symbol
argument_list|(
name|value
argument_list|,
name|TIC80_OPERAND_CC
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%ld"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_operand_bitnum
parameter_list|(
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|long
name|value
parameter_list|)
block|{
name|int
name|bitnum
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp
decl_stmt|;
name|bitnum
operator|=
operator|~
name|value
operator|&
literal|0x1F
expr_stmt|;
name|tmp
operator|=
name|tic80_value_to_symbol
argument_list|(
name|bitnum
argument_list|,
name|TIC80_OPERAND_BITNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|bitnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the operand as directed by the flags.  */
end_comment

begin_define
define|#
directive|define
name|M_SI
parameter_list|(
name|insn
parameter_list|,
name|op
parameter_list|)
value|((((op)->flags& TIC80_OPERAND_M_SI) != 0)&& ((insn)& (1<< 17)))
end_define

begin_define
define|#
directive|define
name|M_LI
parameter_list|(
name|insn
parameter_list|,
name|op
parameter_list|)
value|((((op)->flags& TIC80_OPERAND_M_LI) != 0)&& ((insn)& (1<< 15)))
end_define

begin_define
define|#
directive|define
name|R_SCALED
parameter_list|(
name|insn
parameter_list|,
name|op
parameter_list|)
value|((((op)->flags& TIC80_OPERAND_SCALED) != 0)&& ((insn)& (1<< 11)))
end_define

begin_function
specifier|static
name|void
name|print_operand
parameter_list|(
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|long
name|value
parameter_list|,
name|unsigned
name|long
name|insn
parameter_list|,
specifier|const
name|struct
name|tic80_operand
modifier|*
name|operand
parameter_list|,
name|bfd_vma
name|memaddr
parameter_list|)
block|{
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|TIC80_OPERAND_GPR
operator|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"r%ld"
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_SI
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|)
operator|||
name|M_LI
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|)
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|":m"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|TIC80_OPERAND_FPA
operator|)
operator|!=
literal|0
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"a%ld"
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|TIC80_OPERAND_PCREL
operator|)
operator|!=
literal|0
condition|)
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|memaddr
operator|+
literal|4
operator|*
name|value
argument_list|,
name|info
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|TIC80_OPERAND_BASEREL
operator|)
operator|!=
literal|0
condition|)
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|value
argument_list|,
name|info
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|TIC80_OPERAND_BITNUM
operator|)
operator|!=
literal|0
condition|)
name|print_operand_bitnum
argument_list|(
name|info
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|TIC80_OPERAND_CC
operator|)
operator|!=
literal|0
condition|)
name|print_operand_condition_code
argument_list|(
name|info
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|TIC80_OPERAND_CR
operator|)
operator|!=
literal|0
condition|)
name|print_operand_control_register
argument_list|(
name|info
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|TIC80_OPERAND_FLOAT
operator|)
operator|!=
literal|0
condition|)
name|print_operand_float
argument_list|(
name|info
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|TIC80_OPERAND_BITFIELD
operator|)
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%#lx"
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|print_operand_integer
argument_list|(
name|info
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* If this is a scaled operand, then print the modifier.  */
if|if
condition|(
name|R_SCALED
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|)
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|":s"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the next 32 bit word from the instruction stream and convert it    into internal format in the unsigned long INSN, for which we are    passed the address.  Return 0 on success, -1 on error.  */
end_comment

begin_function
specifier|static
name|int
name|fill_instruction
parameter_list|(
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|bfd_vma
name|memaddr
parameter_list|,
name|unsigned
name|long
modifier|*
name|insnp
parameter_list|)
block|{
name|bfd_byte
name|buffer
index|[
literal|4
index|]
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* Get the bits for the next 32 bit word and put in buffer.  */
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|memaddr
operator|+
name|length
argument_list|,
name|buffer
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|memory_error_func
call|)
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Read was successful, so increment count of bytes read and convert      the bits into internal format.  */
name|length
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|endian
operator|==
name|BFD_ENDIAN_LITTLE
condition|)
operator|*
name|insnp
operator|=
name|bfd_getl32
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|endian
operator|==
name|BFD_ENDIAN_BIG
condition|)
operator|*
name|insnp
operator|=
name|bfd_getb32
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
else|else
comment|/* FIXME: Should probably just default to one or the other.  */
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* We have chosen an opcode table entry.  */
end_comment

begin_function
specifier|static
name|int
name|print_one_instruction
parameter_list|(
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|bfd_vma
name|memaddr
parameter_list|,
name|unsigned
name|long
name|insn
parameter_list|,
specifier|const
name|struct
name|tic80_opcode
modifier|*
name|opcode
parameter_list|)
block|{
specifier|const
name|struct
name|tic80_operand
modifier|*
name|operand
decl_stmt|;
name|long
name|value
decl_stmt|;
name|int
name|status
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|opindex
decl_stmt|;
name|int
name|close_paren
decl_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%-10s"
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|opindex
operator|=
name|opcode
operator|->
name|operands
init|;
operator|*
name|opindex
operator|!=
literal|0
condition|;
name|opindex
operator|++
control|)
block|{
name|operand
operator|=
name|tic80_operands
operator|+
operator|*
name|opindex
expr_stmt|;
comment|/* Extract the value from the instruction.  */
if|if
condition|(
name|operand
operator|->
name|extract
condition|)
name|value
operator|=
call|(
modifier|*
name|operand
operator|->
name|extract
call|)
argument_list|(
name|insn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
literal|32
condition|)
block|{
name|status
operator|=
name|fill_instruction
argument_list|(
name|info
argument_list|,
name|memaddr
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
return|return
name|status
return|;
block|}
else|else
block|{
name|value
operator|=
operator|(
name|insn
operator|>>
name|operand
operator|->
name|shift
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|TIC80_OPERAND_SIGNED
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|value
operator|&
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
name|value
operator|-=
literal|1
operator|<<
name|operand
operator|->
name|bits
expr_stmt|;
block|}
comment|/* If this operand is enclosed in parenthesis, then print 	 the open paren, otherwise just print the regular comma 	 separator, except for the first operand.  */
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|TIC80_OPERAND_PARENS
operator|)
operator|==
literal|0
condition|)
block|{
name|close_paren
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opindex
operator|!=
name|opcode
operator|->
name|operands
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|close_paren
operator|=
literal|1
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
block|}
name|print_operand
argument_list|(
name|info
argument_list|,
name|value
argument_list|,
name|insn
argument_list|,
name|operand
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
comment|/* If we printed an open paren before printing this operand, close 	 it now. The flag gets reset on each loop.  */
if|if
condition|(
name|close_paren
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
return|return
name|length
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* There are no specific bits that tell us for certain whether a vector    instruction opcode contains one or two instructions.  However since    a destination register of r0 is illegal, we can check for nonzero    values in both destination register fields.  Only opcodes that have    two valid instructions will have non-zero in both.  */
end_comment

begin_define
define|#
directive|define
name|TWO_INSN
parameter_list|(
name|insn
parameter_list|)
value|((((insn)& (0x1F<< 27)) != 0)&& (((insn)& (0x1F<< 22)) != 0))
end_define

begin_function
specifier|static
name|int
name|print_instruction
parameter_list|(
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|bfd_vma
name|memaddr
parameter_list|,
name|unsigned
name|long
name|insn
parameter_list|,
specifier|const
name|struct
name|tic80_opcode
modifier|*
name|vec_opcode
parameter_list|)
block|{
specifier|const
name|struct
name|tic80_opcode
modifier|*
name|opcode
decl_stmt|;
specifier|const
name|struct
name|tic80_opcode
modifier|*
name|opcode_end
decl_stmt|;
comment|/* Find the first opcode match in the opcodes table.  For vector      opcodes (vec_opcode != NULL) find the first match that is not the      previously found match.  FIXME: there should be faster ways to      search (hash table or binary search), but don't worry too much      about it until other TIc80 support is finished.  */
name|opcode_end
operator|=
name|tic80_opcodes
operator|+
name|tic80_num_opcodes
expr_stmt|;
for|for
control|(
name|opcode
operator|=
name|tic80_opcodes
init|;
name|opcode
operator|<
name|opcode_end
condition|;
name|opcode
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|insn
operator|&
name|opcode
operator|->
name|mask
operator|)
operator|==
name|opcode
operator|->
name|opcode
operator|&&
name|opcode
operator|!=
name|vec_opcode
condition|)
break|break;
block|}
if|if
condition|(
name|opcode
operator|==
name|opcode_end
condition|)
block|{
comment|/* No match found, just print the bits as a .word directive.  */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|".word %#08lx"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Match found, decode the instruction.  */
name|length
operator|=
name|print_one_instruction
argument_list|(
name|info
argument_list|,
name|memaddr
argument_list|,
name|insn
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|flags
operator|&
name|TIC80_VECTOR
operator|&&
name|vec_opcode
operator|==
name|NULL
operator|&&
name|TWO_INSN
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* There is another instruction to print from the same opcode. 	     Print the separator and then find and print the other 	     instruction.  */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"   ||   "
argument_list|)
expr_stmt|;
name|length
operator|=
name|print_instruction
argument_list|(
name|info
argument_list|,
name|memaddr
argument_list|,
name|insn
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|length
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|print_insn_tic80
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
name|int
name|status
decl_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|bytes_per_line
operator|=
literal|8
expr_stmt|;
name|status
operator|=
name|fill_instruction
argument_list|(
name|info
argument_list|,
name|memaddr
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
operator|-
literal|1
condition|)
name|status
operator|=
name|print_instruction
argument_list|(
name|info
argument_list|,
name|memaddr
argument_list|,
name|insn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

end_unit

