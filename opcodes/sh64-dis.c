begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Disassemble SH64 instructions.    Copyright 2000, 2001, 2002, 2003, 2005 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"sh64-opc.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_comment
comment|/* We need to refer to the ELF header structure.  */
end_comment

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/sh.h"
end_include

begin_include
include|#
directive|include
file|"elf32-sh64.h"
end_include

begin_define
define|#
directive|define
name|ELF_MODE32_CODE_LABEL_P
parameter_list|(
name|SYM
parameter_list|)
define|\
value|(((elf_symbol_type *) (SYM))->internal_elf_sym.st_other& STO_SH5_ISA32)
end_define

begin_define
define|#
directive|define
name|SAVED_MOVI_R
parameter_list|(
name|INFO
parameter_list|)
define|\
value|(((struct sh64_disassemble_info *) ((INFO)->private_data))->address_reg)
end_define

begin_define
define|#
directive|define
name|SAVED_MOVI_IMM
parameter_list|(
name|INFO
parameter_list|)
define|\
value|(((struct sh64_disassemble_info *) ((INFO)->private_data))->built_address)
end_define

begin_struct
struct|struct
name|sh64_disassemble_info
block|{
comment|/* When we see a MOVI, we save the register and the value, and merge a       subsequent SHORI and display the address, if there is one.  */
name|unsigned
name|int
name|address_reg
decl_stmt|;
name|bfd_signed_vma
name|built_address
decl_stmt|;
comment|/* This is the range decriptor for the current address.  It is kept       around for the next call.  */
name|sh64_elf_crange
name|crange
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Each item in the table is a mask to indicate which bits to be set    to determine an instruction's operator.    The index is as same as the instruction in the opcode table.    Note that some archs have this as a field in the opcode table.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
modifier|*
name|shmedia_opcode_mask_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the SH64 opcode mask table for each instruction in SHmedia    mode.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_shmedia_opcode_mask_table
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|n_opc
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* Calculate number of opcodes.  */
for|for
control|(
name|n_opc
operator|=
literal|0
init|;
name|shmedia_table
index|[
name|n_opc
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|n_opc
operator|++
control|)
empty_stmt|;
name|shmedia_opcode_mask_table
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|shmedia_opcode_mask_table
index|[
literal|0
index|]
argument_list|)
operator|*
name|n_opc
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_opc
condition|;
name|n
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|mask
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|shmedia_table
index|[
name|n
index|]
operator|.
name|arg
index|[
name|i
index|]
operator|!=
name|A_NONE
condition|;
name|i
operator|++
control|)
block|{
name|int
name|offset
init|=
name|shmedia_table
index|[
name|n
index|]
operator|.
name|nibbles
index|[
name|i
index|]
decl_stmt|;
name|int
name|length
decl_stmt|;
switch|switch
condition|(
name|shmedia_table
index|[
name|n
index|]
operator|.
name|arg
index|[
name|i
index|]
condition|)
block|{
case|case
name|A_GREG_M
case|:
case|case
name|A_GREG_N
case|:
case|case
name|A_GREG_D
case|:
case|case
name|A_CREG_K
case|:
case|case
name|A_CREG_J
case|:
case|case
name|A_FREG_G
case|:
case|case
name|A_FREG_H
case|:
case|case
name|A_FREG_F
case|:
case|case
name|A_DREG_G
case|:
case|case
name|A_DREG_H
case|:
case|case
name|A_DREG_F
case|:
case|case
name|A_FMREG_G
case|:
case|case
name|A_FMREG_H
case|:
case|case
name|A_FMREG_F
case|:
case|case
name|A_FPREG_G
case|:
case|case
name|A_FPREG_H
case|:
case|case
name|A_FPREG_F
case|:
case|case
name|A_FVREG_G
case|:
case|case
name|A_FVREG_H
case|:
case|case
name|A_FVREG_F
case|:
case|case
name|A_REUSE_PREV
case|:
name|length
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|A_TREG_A
case|:
case|case
name|A_TREG_B
case|:
name|length
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|A_IMMM
case|:
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|A_IMMU5
case|:
name|length
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|A_IMMS6
case|:
case|case
name|A_IMMU6
case|:
case|case
name|A_IMMS6BY32
case|:
name|length
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|A_IMMS10
case|:
case|case
name|A_IMMS10BY1
case|:
case|case
name|A_IMMS10BY2
case|:
case|case
name|A_IMMS10BY4
case|:
case|case
name|A_IMMS10BY8
case|:
name|length
operator|=
literal|10
expr_stmt|;
break|break;
case|case
name|A_IMMU16
case|:
case|case
name|A_IMMS16
case|:
case|case
name|A_PCIMMS16BY4
case|:
case|case
name|A_PCIMMS16BY4_PT
case|:
name|length
operator|=
literal|16
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|length
operator|!=
literal|0
condition|)
name|mask
operator||=
operator|(
literal|0xffffffff
operator|>>
operator|(
literal|32
operator|-
name|length
operator|)
operator|)
operator|<<
name|offset
expr_stmt|;
block|}
name|shmedia_opcode_mask_table
index|[
name|n
index|]
operator|=
literal|0xffffffff
operator|&
operator|~
name|mask
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get a predefined control-register-name, or return NULL.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|creg_name
parameter_list|(
name|int
name|cregno
parameter_list|)
block|{
specifier|const
name|shmedia_creg_info
modifier|*
name|cregp
decl_stmt|;
comment|/* If control register usage is common enough, change this to search a      hash-table.  */
for|for
control|(
name|cregp
operator|=
name|shmedia_creg_table
init|;
name|cregp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|cregp
operator|++
control|)
if|if
condition|(
name|cregp
operator|->
name|cregno
operator|==
name|cregno
condition|)
return|return
name|cregp
operator|->
name|name
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Main function to disassemble SHmedia instructions.  */
end_comment

begin_function
specifier|static
name|int
name|print_insn_shmedia
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|fprintf_ftype
name|fprintf_fn
init|=
name|info
operator|->
name|fprintf_func
decl_stmt|;
name|void
modifier|*
name|stream
init|=
name|info
operator|->
name|stream
decl_stmt|;
name|unsigned
name|char
name|insn
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|long
name|instruction
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|n
decl_stmt|;
specifier|const
name|shmedia_opcode_info
modifier|*
name|op
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|r
init|=
literal|0
decl_stmt|;
name|long
name|imm
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|disp_pc_addr
decl_stmt|;
name|status
operator|=
name|info
operator|->
name|read_memory_func
argument_list|(
name|memaddr
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* If we can't read four bytes, something is wrong.  Display any data we      can get as .byte:s.  */
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|info
operator|->
name|read_memory_func
argument_list|(
name|memaddr
operator|+
name|i
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
break|break;
call|(
modifier|*
name|fprintf_fn
call|)
argument_list|(
name|stream
argument_list|,
literal|"%s0x%02x"
argument_list|,
name|i
operator|==
literal|0
condition|?
literal|".byte "
else|:
literal|", "
argument_list|,
name|insn
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|i
condition|?
name|i
else|:
operator|-
literal|1
return|;
block|}
comment|/* Rearrange the bytes to make up an instruction.  */
if|if
condition|(
name|info
operator|->
name|endian
operator|==
name|BFD_ENDIAN_LITTLE
condition|)
name|instruction
operator|=
name|bfd_getl32
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
name|instruction
operator|=
name|bfd_getb32
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* FIXME: Searching could be implemented using a hash on relevant      fields.  */
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|op
operator|=
name|shmedia_table
init|;
name|op
operator|->
name|name
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|instruction
operator|&
name|shmedia_opcode_mask_table
index|[
name|n
index|]
operator|)
operator|!=
name|op
operator|->
name|opcode_base
operator|)
condition|;
name|n
operator|++
operator|,
name|op
operator|++
control|)
empty_stmt|;
comment|/* FIXME: We should also check register number constraints.  */
if|if
condition|(
name|op
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|".long 0x%08lx"
argument_list|,
name|instruction
argument_list|)
expr_stmt|;
return|return
literal|4
return|;
block|}
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"%s\t"
argument_list|,
name|op
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
operator|&&
name|op
operator|->
name|arg
index|[
name|i
index|]
operator|!=
name|A_NONE
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|long
name|temp
init|=
name|instruction
operator|>>
name|op
operator|->
name|nibbles
index|[
name|i
index|]
decl_stmt|;
name|int
name|by_number
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|op
operator|->
name|arg
index|[
name|i
index|]
operator|!=
name|A_REUSE_PREV
condition|)
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|","
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
operator|->
name|arg
index|[
name|i
index|]
condition|)
block|{
case|case
name|A_REUSE_PREV
case|:
continue|continue;
case|case
name|A_GREG_M
case|:
case|case
name|A_GREG_N
case|:
case|case
name|A_GREG_D
case|:
name|r
operator|=
name|temp
operator|&
literal|0x3f
expr_stmt|;
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"r%d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_FVREG_F
case|:
case|case
name|A_FVREG_G
case|:
case|case
name|A_FVREG_H
case|:
name|r
operator|=
name|temp
operator|&
literal|0x3f
expr_stmt|;
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"fv%d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_FPREG_F
case|:
case|case
name|A_FPREG_G
case|:
case|case
name|A_FPREG_H
case|:
name|r
operator|=
name|temp
operator|&
literal|0x3f
expr_stmt|;
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"fp%d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_FMREG_F
case|:
case|case
name|A_FMREG_G
case|:
case|case
name|A_FMREG_H
case|:
name|r
operator|=
name|temp
operator|&
literal|0x3f
expr_stmt|;
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"mtrx%d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_CREG_K
case|:
case|case
name|A_CREG_J
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|r
operator|=
name|temp
operator|&
literal|0x3f
expr_stmt|;
name|name
operator|=
name|creg_name
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"cr%d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|A_FREG_G
case|:
case|case
name|A_FREG_H
case|:
case|case
name|A_FREG_F
case|:
name|r
operator|=
name|temp
operator|&
literal|0x3f
expr_stmt|;
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"fr%d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_DREG_G
case|:
case|case
name|A_DREG_H
case|:
case|case
name|A_DREG_F
case|:
name|r
operator|=
name|temp
operator|&
literal|0x3f
expr_stmt|;
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"dr%d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_TREG_A
case|:
case|case
name|A_TREG_B
case|:
name|r
operator|=
name|temp
operator|&
literal|0x7
expr_stmt|;
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"tr%d"
argument_list|,
name|r
argument_list|)
expr_stmt|;
break|break;
comment|/* A signed 6-bit number.  */
case|case
name|A_IMMS6
case|:
name|imm
operator|=
name|temp
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|imm
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x20
condition|)
name|imm
operator||=
operator|~
operator|(
name|unsigned
name|long
operator|)
literal|0x3f
expr_stmt|;
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"%ld"
argument_list|,
name|imm
argument_list|)
expr_stmt|;
break|break;
comment|/* A signed 6-bit number, multiplied by 32 when used.  */
case|case
name|A_IMMS6BY32
case|:
name|imm
operator|=
name|temp
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|imm
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x20
condition|)
name|imm
operator||=
operator|~
operator|(
name|unsigned
name|long
operator|)
literal|0x3f
expr_stmt|;
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"%ld"
argument_list|,
name|imm
operator|*
literal|32
argument_list|)
expr_stmt|;
break|break;
comment|/* A signed 10-bit number, multiplied by 8 when used.  */
case|case
name|A_IMMS10BY8
case|:
name|by_number
operator|++
expr_stmt|;
comment|/* Fall through.  */
comment|/* A signed 10-bit number, multiplied by 4 when used.  */
case|case
name|A_IMMS10BY4
case|:
name|by_number
operator|++
expr_stmt|;
comment|/* Fall through.  */
comment|/* A signed 10-bit number, multiplied by 2 when used.  */
case|case
name|A_IMMS10BY2
case|:
name|by_number
operator|++
expr_stmt|;
comment|/* Fall through.  */
comment|/* A signed 10-bit number.  */
case|case
name|A_IMMS10
case|:
case|case
name|A_IMMS10BY1
case|:
name|imm
operator|=
name|temp
operator|&
literal|0x3ff
expr_stmt|;
if|if
condition|(
name|imm
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x200
condition|)
name|imm
operator||=
operator|~
operator|(
name|unsigned
name|long
operator|)
literal|0x3ff
expr_stmt|;
name|imm
operator|<<=
name|by_number
expr_stmt|;
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"%ld"
argument_list|,
name|imm
argument_list|)
expr_stmt|;
break|break;
comment|/* A signed 16-bit number.  */
case|case
name|A_IMMS16
case|:
name|imm
operator|=
name|temp
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|imm
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x8000
condition|)
name|imm
operator||=
operator|~
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|0xffff
operator|)
expr_stmt|;
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"%ld"
argument_list|,
name|imm
argument_list|)
expr_stmt|;
break|break;
comment|/* A PC-relative signed 16-bit number, multiplied by 4 when 	     used.  */
case|case
name|A_PCIMMS16BY4
case|:
name|imm
operator|=
name|temp
operator|&
literal|0xffff
expr_stmt|;
comment|/* 16 bits */
if|if
condition|(
name|imm
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x8000
condition|)
name|imm
operator||=
operator|~
operator|(
name|unsigned
name|long
operator|)
literal|0xffff
expr_stmt|;
name|imm
operator|<<=
literal|2
expr_stmt|;
name|disp_pc_addr
operator|=
operator|(
name|bfd_vma
operator|)
name|imm
operator|+
name|memaddr
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|disp_pc_addr
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
comment|/* An unsigned 5-bit number.  */
case|case
name|A_IMMU5
case|:
name|imm
operator|=
name|temp
operator|&
literal|0x1f
expr_stmt|;
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"%ld"
argument_list|,
name|imm
argument_list|)
expr_stmt|;
break|break;
comment|/* An unsigned 6-bit number.  */
case|case
name|A_IMMU6
case|:
name|imm
operator|=
name|temp
operator|&
literal|0x3f
expr_stmt|;
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"%ld"
argument_list|,
name|imm
argument_list|)
expr_stmt|;
break|break;
comment|/* An unsigned 16-bit number.  */
case|case
name|A_IMMU16
case|:
name|imm
operator|=
name|temp
operator|&
literal|0xffff
expr_stmt|;
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"%ld"
argument_list|,
name|imm
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
comment|/* FIXME: Looks like 32-bit values only are handled.      FIXME: PC-relative numbers aren't handled correctly.  */
if|if
condition|(
name|op
operator|->
name|opcode_base
operator|==
operator|(
name|unsigned
name|long
operator|)
name|SHMEDIA_SHORI_OPC
operator|&&
name|SAVED_MOVI_R
argument_list|(
name|info
argument_list|)
operator|==
name|r
condition|)
block|{
name|asection
modifier|*
name|section
init|=
name|info
operator|->
name|section
decl_stmt|;
comment|/* Most callers do not set the section field correctly yet.  Revert 	 to getting the section from symbols, if any. */
if|if
condition|(
name|section
operator|==
name|NULL
operator|&&
name|info
operator|->
name|symbols
operator|!=
name|NULL
operator|&&
name|bfd_asymbol_flavour
argument_list|(
name|info
operator|->
name|symbols
index|[
literal|0
index|]
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|&&
operator|!
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|info
operator|->
name|symbols
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|bfd_get_section
argument_list|(
name|info
operator|->
name|symbols
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
name|section
operator|=
name|bfd_get_section
argument_list|(
name|info
operator|->
name|symbols
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Only guess addresses when the contents of this section is fully 	 relocated.  Otherwise, the value will be zero or perhaps even 	 bogus.  */
if|if
condition|(
name|section
operator|==
name|NULL
operator|||
name|section
operator|->
name|owner
operator|==
name|NULL
operator|||
name|elf_elfheader
argument_list|(
name|section
operator|->
name|owner
argument_list|)
operator|->
name|e_type
operator|==
name|ET_EXEC
condition|)
block|{
name|bfd_signed_vma
name|shori_addr
decl_stmt|;
name|shori_addr
operator|=
name|SAVED_MOVI_IMM
argument_list|(
name|info
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|shori_addr
operator||=
name|imm
expr_stmt|;
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"\t! 0x"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|shori_addr
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|op
operator|->
name|opcode_base
operator|==
name|SHMEDIA_MOVI_OPC
condition|)
block|{
name|SAVED_MOVI_IMM
argument_list|(
name|info
argument_list|)
operator|=
name|imm
expr_stmt|;
name|SAVED_MOVI_R
argument_list|(
name|info
argument_list|)
operator|=
name|r
expr_stmt|;
block|}
else|else
block|{
name|SAVED_MOVI_IMM
argument_list|(
name|info
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SAVED_MOVI_R
argument_list|(
name|info
argument_list|)
operator|=
literal|255
expr_stmt|;
block|}
return|return
literal|4
return|;
block|}
end_function

begin_comment
comment|/* Check the type of contents about to be disassembled.  This is like    sh64_get_contents_type (which may be called from here), except that it    takes the same arguments as print_insn_* and does what can be done if    no section is available.  */
end_comment

begin_function
specifier|static
name|enum
name|sh64_elf_cr_type
name|sh64_get_contents_type_disasm
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|sh64_disassemble_info
modifier|*
name|sh64_infop
init|=
name|info
operator|->
name|private_data
decl_stmt|;
comment|/* Perhaps we have a region from a previous probe and it still counts      for this address?  */
if|if
condition|(
name|sh64_infop
operator|->
name|crange
operator|.
name|cr_type
operator|!=
name|CRT_NONE
operator|&&
name|memaddr
operator|>=
name|sh64_infop
operator|->
name|crange
operator|.
name|cr_addr
operator|&&
name|memaddr
operator|<
name|sh64_infop
operator|->
name|crange
operator|.
name|cr_addr
operator|+
name|sh64_infop
operator|->
name|crange
operator|.
name|cr_size
condition|)
return|return
name|sh64_infop
operator|->
name|crange
operator|.
name|cr_type
return|;
comment|/* If we have a section, try and use it.  */
if|if
condition|(
name|info
operator|->
name|section
operator|&&
name|bfd_get_flavour
argument_list|(
name|info
operator|->
name|section
operator|->
name|owner
argument_list|)
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
name|enum
name|sh64_elf_cr_type
name|cr_type
init|=
name|sh64_get_contents_type
argument_list|(
name|info
operator|->
name|section
argument_list|,
name|memaddr
argument_list|,
operator|&
name|sh64_infop
operator|->
name|crange
argument_list|)
decl_stmt|;
if|if
condition|(
name|cr_type
operator|!=
name|CRT_NONE
condition|)
return|return
name|cr_type
return|;
block|}
comment|/* If we have symbols, we can try and get at a section from *that*.  */
if|if
condition|(
name|info
operator|->
name|symbols
operator|!=
name|NULL
operator|&&
name|bfd_asymbol_flavour
argument_list|(
name|info
operator|->
name|symbols
index|[
literal|0
index|]
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|&&
operator|!
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|info
operator|->
name|symbols
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|bfd_get_section
argument_list|(
name|info
operator|->
name|symbols
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|enum
name|sh64_elf_cr_type
name|cr_type
init|=
name|sh64_get_contents_type
argument_list|(
name|bfd_get_section
argument_list|(
name|info
operator|->
name|symbols
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|memaddr
argument_list|,
operator|&
name|sh64_infop
operator|->
name|crange
argument_list|)
decl_stmt|;
if|if
condition|(
name|cr_type
operator|!=
name|CRT_NONE
condition|)
return|return
name|cr_type
return|;
block|}
comment|/* We can make a reasonable guess based on the st_other field of a      symbol; for a BranchTarget this is marked as STO_SH5_ISA32 and then      it's most probably code there.  */
if|if
condition|(
name|info
operator|->
name|symbols
operator|&&
name|bfd_asymbol_flavour
argument_list|(
name|info
operator|->
name|symbols
index|[
literal|0
index|]
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|&&
name|elf_symbol_from
argument_list|(
name|bfd_asymbol_bfd
argument_list|(
name|info
operator|->
name|symbols
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|info
operator|->
name|symbols
index|[
literal|0
index|]
argument_list|)
operator|->
name|internal_elf_sym
operator|.
name|st_other
operator|==
name|STO_SH5_ISA32
condition|)
return|return
name|CRT_SH5_ISA32
return|;
comment|/* If all else fails, guess this is code and guess on the low bit set.  */
return|return
operator|(
name|memaddr
operator|&
literal|1
operator|)
operator|==
literal|1
condition|?
name|CRT_SH5_ISA32
else|:
name|CRT_SH5_ISA16
return|;
block|}
end_function

begin_comment
comment|/* Initialize static and dynamic disassembly state.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|init_sh64_disasm_info
parameter_list|(
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|sh64_disassemble_info
modifier|*
name|sh64_infop
init|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sh64_infop
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|sh64_infop
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|info
operator|->
name|private_data
operator|=
name|sh64_infop
expr_stmt|;
name|SAVED_MOVI_IMM
argument_list|(
name|info
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SAVED_MOVI_R
argument_list|(
name|info
argument_list|)
operator|=
literal|255
expr_stmt|;
if|if
condition|(
name|shmedia_opcode_mask_table
operator|==
name|NULL
condition|)
name|initialize_shmedia_opcode_mask_table
argument_list|()
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Main entry to disassemble SHmedia instructions, given an endian set in    INFO.  Note that the simulator uses this as the main entry and does not    use any of the functions further below.  */
end_comment

begin_function
name|int
name|print_insn_sh64x_media
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|info
operator|->
name|private_data
operator|==
name|NULL
operator|&&
operator|!
name|init_sh64_disasm_info
argument_list|(
name|info
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Make reasonable output.  */
name|info
operator|->
name|bytes_per_line
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|bytes_per_chunk
operator|=
literal|4
expr_stmt|;
return|return
name|print_insn_shmedia
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Main entry to disassemble SHmedia insns.    If we see an SHcompact instruction, return -2.  */
end_comment

begin_function
name|int
name|print_insn_sh64
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|enum
name|bfd_endian
name|endian
init|=
name|info
operator|->
name|endian
decl_stmt|;
name|enum
name|sh64_elf_cr_type
name|cr_type
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|private_data
operator|==
name|NULL
operator|&&
operator|!
name|init_sh64_disasm_info
argument_list|(
name|info
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|cr_type
operator|=
name|sh64_get_contents_type_disasm
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr_type
operator|!=
name|CRT_SH5_ISA16
condition|)
block|{
name|int
name|length
init|=
literal|4
operator|-
operator|(
name|memaddr
operator|%
literal|4
operator|)
decl_stmt|;
name|info
operator|->
name|display_endian
operator|=
name|endian
expr_stmt|;
comment|/* If we got an uneven address to indicate SHmedia, adjust it.  */
if|if
condition|(
name|cr_type
operator|==
name|CRT_SH5_ISA32
operator|&&
name|length
operator|==
literal|3
condition|)
name|memaddr
operator|--
operator|,
name|length
operator|=
literal|4
expr_stmt|;
comment|/* Only disassemble on four-byte boundaries.  Addresses that are not 	 a multiple of four can happen after a data region.  */
if|if
condition|(
name|cr_type
operator|==
name|CRT_SH5_ISA32
operator|&&
name|length
operator|==
literal|4
condition|)
return|return
name|print_insn_sh64x_media
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
return|;
comment|/* We get CRT_DATA *only* for data regions in a mixed-contents 	 section.  For sections with data only, we get indication of one 	 of the ISA:s.  You may think that we shouldn't disassemble 	 section with only data if we can figure that out.  However, the 	 disassembly function is by default not called for data-only 	 sections, so if the user explicitly specified disassembly of a 	 data section, that's what we should do.  */
if|if
condition|(
name|cr_type
operator|==
name|CRT_DATA
operator|||
name|length
operator|!=
literal|4
condition|)
block|{
name|int
name|status
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|sh64_disassemble_info
modifier|*
name|sh64_infop
init|=
name|info
operator|->
name|private_data
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|4
operator|&&
name|sh64_infop
operator|->
name|crange
operator|.
name|cr_type
operator|!=
name|CRT_NONE
operator|&&
name|memaddr
operator|>=
name|sh64_infop
operator|->
name|crange
operator|.
name|cr_addr
operator|&&
name|memaddr
operator|<
operator|(
name|sh64_infop
operator|->
name|crange
operator|.
name|cr_addr
operator|+
name|sh64_infop
operator|->
name|crange
operator|.
name|cr_size
operator|)
condition|)
name|length
operator|=
operator|(
name|sh64_infop
operator|->
name|crange
operator|.
name|cr_addr
operator|+
name|sh64_infop
operator|->
name|crange
operator|.
name|cr_size
operator|-
name|memaddr
operator|)
expr_stmt|;
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|memaddr
argument_list|,
name|data
argument_list|,
name|length
operator|>=
literal|4
condition|?
literal|4
else|:
name|length
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
operator|&&
name|length
operator|>=
literal|4
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|".long 0x%08lx"
argument_list|,
name|endian
operator|==
name|BFD_ENDIAN_BIG
condition|?
call|(
name|long
call|)
argument_list|(
name|bfd_getb32
argument_list|(
name|data
argument_list|)
argument_list|)
else|:
call|(
name|long
call|)
argument_list|(
name|bfd_getl32
argument_list|(
name|data
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|4
return|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|info
operator|->
name|read_memory_func
argument_list|(
name|memaddr
operator|+
name|i
argument_list|,
name|data
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
break|break;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s0x%02x"
argument_list|,
name|i
operator|==
literal|0
condition|?
literal|".byte "
else|:
literal|", "
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|i
condition|?
name|i
else|:
operator|-
literal|1
return|;
block|}
block|}
block|}
comment|/* SH1 .. SH4 instruction, let caller handle it.  */
return|return
operator|-
literal|2
return|;
block|}
end_function

end_unit

