begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print Motorola 68k instructions.    Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997,    1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.     This file is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,    MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"opintl.h"
end_include

begin_include
include|#
directive|include
file|"opcode/m68k.h"
end_include

begin_comment
comment|/* Local function prototypes.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|fpcr_names
index|[]
init|=
block|{
literal|""
block|,
literal|"%fpiar"
block|,
literal|"%fpsr"
block|,
literal|"%fpiar/%fpsr"
block|,
literal|"%fpcr"
block|,
literal|"%fpiar/%fpcr"
block|,
literal|"%fpsr/%fpcr"
block|,
literal|"%fpiar/%fpsr/%fpcr"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
specifier|const
name|reg_names
index|[]
init|=
block|{
literal|"%d0"
block|,
literal|"%d1"
block|,
literal|"%d2"
block|,
literal|"%d3"
block|,
literal|"%d4"
block|,
literal|"%d5"
block|,
literal|"%d6"
block|,
literal|"%d7"
block|,
literal|"%a0"
block|,
literal|"%a1"
block|,
literal|"%a2"
block|,
literal|"%a3"
block|,
literal|"%a4"
block|,
literal|"%a5"
block|,
literal|"%fp"
block|,
literal|"%sp"
block|,
literal|"%ps"
block|,
literal|"%pc"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of register halves for MAC/EMAC.    Seperate from reg_names since 'spu', 'fpl' look weird.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
specifier|const
name|reg_half_names
index|[]
init|=
block|{
literal|"%d0"
block|,
literal|"%d1"
block|,
literal|"%d2"
block|,
literal|"%d3"
block|,
literal|"%d4"
block|,
literal|"%d5"
block|,
literal|"%d6"
block|,
literal|"%d7"
block|,
literal|"%a0"
block|,
literal|"%a1"
block|,
literal|"%a2"
block|,
literal|"%a3"
block|,
literal|"%a4"
block|,
literal|"%a5"
block|,
literal|"%a6"
block|,
literal|"%a7"
block|,
literal|"%ps"
block|,
literal|"%pc"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sign-extend an (unsigned char).  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
operator|==
literal|1
end_if

begin_define
define|#
directive|define
name|COERCE_SIGNED_CHAR
parameter_list|(
name|ch
parameter_list|)
value|((signed char) (ch))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|COERCE_SIGNED_CHAR
parameter_list|(
name|ch
parameter_list|)
value|((int) (((ch) ^ 0x80)& 0xFF) - 128)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Get a 1 byte signed integer.  */
end_comment

begin_define
define|#
directive|define
name|NEXTBYTE
parameter_list|(
name|p
parameter_list|)
value|(p += 2, FETCH_DATA (info, p), COERCE_SIGNED_CHAR(p[-1]))
end_define

begin_comment
comment|/* Get a 2 byte signed integer.  */
end_comment

begin_define
define|#
directive|define
name|COERCE16
parameter_list|(
name|x
parameter_list|)
value|((int) (((x) ^ 0x8000) - 0x8000))
end_define

begin_define
define|#
directive|define
name|NEXTWORD
parameter_list|(
name|p
parameter_list|)
define|\
value|(p += 2, FETCH_DATA (info, p), \    COERCE16 ((p[-2]<< 8) + p[-1]))
end_define

begin_comment
comment|/* Get a 4 byte signed integer.  */
end_comment

begin_define
define|#
directive|define
name|COERCE32
parameter_list|(
name|x
parameter_list|)
value|((bfd_signed_vma) ((x) ^ 0x80000000) - 0x80000000)
end_define

begin_define
define|#
directive|define
name|NEXTLONG
parameter_list|(
name|p
parameter_list|)
define|\
value|(p += 4, FETCH_DATA (info, p), \    (COERCE32 ((((((p[-4]<< 8) + p[-3])<< 8) + p[-2])<< 8) + p[-1])))
end_define

begin_comment
comment|/* Get a 4 byte unsigned integer.  */
end_comment

begin_define
define|#
directive|define
name|NEXTULONG
parameter_list|(
name|p
parameter_list|)
define|\
value|(p += 4, FETCH_DATA (info, p), \    (unsigned int) ((((((p[-4]<< 8) + p[-3])<< 8) + p[-2])<< 8) + p[-1]))
end_define

begin_comment
comment|/* Get a single precision float.  */
end_comment

begin_define
define|#
directive|define
name|NEXTSINGLE
parameter_list|(
name|val
parameter_list|,
name|p
parameter_list|)
define|\
value|(p += 4, FETCH_DATA (info, p), \    floatformat_to_double (&floatformat_ieee_single_big, (char *) p - 4,&val))
end_define

begin_comment
comment|/* Get a double precision float.  */
end_comment

begin_define
define|#
directive|define
name|NEXTDOUBLE
parameter_list|(
name|val
parameter_list|,
name|p
parameter_list|)
define|\
value|(p += 8, FETCH_DATA (info, p), \    floatformat_to_double (&floatformat_ieee_double_big, (char *) p - 8,&val))
end_define

begin_comment
comment|/* Get an extended precision float.  */
end_comment

begin_define
define|#
directive|define
name|NEXTEXTEND
parameter_list|(
name|val
parameter_list|,
name|p
parameter_list|)
define|\
value|(p += 12, FETCH_DATA (info, p), \    floatformat_to_double (&floatformat_m68881_ext, (char *) p - 12,&val))
end_define

begin_comment
comment|/* Need a function to convert from packed to double    precision.   Actually, it's easier to print a    packed number than a double anyway, so maybe    there should be a special case to handle this... */
end_comment

begin_define
define|#
directive|define
name|NEXTPACKED
parameter_list|(
name|p
parameter_list|)
define|\
value|(p += 12, FETCH_DATA (info, p), 0.0)
end_define

begin_escape
end_escape

begin_comment
comment|/* Maximum length of an instruction.  */
end_comment

begin_define
define|#
directive|define
name|MAXLEN
value|22
end_define

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_struct
struct|struct
name|private
block|{
comment|/* Points to first byte not fetched.  */
name|bfd_byte
modifier|*
name|max_fetched
decl_stmt|;
name|bfd_byte
name|the_buffer
index|[
name|MAXLEN
index|]
decl_stmt|;
name|bfd_vma
name|insn_start
decl_stmt|;
name|jmp_buf
name|bailout
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Make sure that bytes from INFO->PRIVATE_DATA->BUFFER (inclusive)    to ADDR (exclusive) are valid.  Returns 1 for success, longjmps    on error.  */
end_comment

begin_define
define|#
directive|define
name|FETCH_DATA
parameter_list|(
name|info
parameter_list|,
name|addr
parameter_list|)
define|\
value|((addr)<= ((struct private *) (info->private_data))->max_fetched \    ? 1 : fetch_data ((info), (addr)))
end_define

begin_function
specifier|static
name|int
name|fetch_data
parameter_list|(
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|bfd_byte
modifier|*
name|addr
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|struct
name|private
modifier|*
name|priv
init|=
operator|(
expr|struct
name|private
operator|*
operator|)
name|info
operator|->
name|private_data
decl_stmt|;
name|bfd_vma
name|start
init|=
name|priv
operator|->
name|insn_start
operator|+
operator|(
name|priv
operator|->
name|max_fetched
operator|-
name|priv
operator|->
name|the_buffer
operator|)
decl_stmt|;
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|start
argument_list|,
name|priv
operator|->
name|max_fetched
argument_list|,
name|addr
operator|-
name|priv
operator|->
name|max_fetched
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|memory_error_func
call|)
argument_list|(
name|status
argument_list|,
name|start
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|priv
operator|->
name|bailout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|priv
operator|->
name|max_fetched
operator|=
name|addr
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function is used to print to the bit-bucket.  */
end_comment

begin_function
specifier|static
name|int
name|dummy_printer
parameter_list|(
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|format
name|ATTRIBUTE_UNUSED
parameter_list|,
modifier|...
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dummy_print_address
parameter_list|(
name|bfd_vma
name|vma
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Fetch BITS bits from a position in the instruction specified by CODE.    CODE is a "place to put an argument", or 'x' for a destination    that is a general address (mode and register).    BUFFER contains the instruction.  */
end_comment

begin_function
specifier|static
name|int
name|fetch_arg
parameter_list|(
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|bits
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|int
name|val
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'/'
case|:
comment|/* MAC/EMAC mask bit.  */
name|val
operator|=
name|buffer
index|[
literal|3
index|]
operator|>>
literal|5
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
comment|/* EMAC ACC load.  */
name|val
operator|=
operator|(
operator|(
name|buffer
index|[
literal|3
index|]
operator|>>
literal|3
operator|)
operator|&
literal|0x2
operator|)
operator||
operator|(
operator|(
operator|~
name|buffer
index|[
literal|1
index|]
operator|>>
literal|7
operator|)
operator|&
literal|0x1
operator|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* EMAC ACC !load.  */
name|val
operator|=
operator|(
operator|(
name|buffer
index|[
literal|3
index|]
operator|>>
literal|3
operator|)
operator|&
literal|0x2
operator|)
operator||
operator|(
operator|(
name|buffer
index|[
literal|1
index|]
operator|>>
literal|7
operator|)
operator|&
literal|0x1
operator|)
expr_stmt|;
break|break;
case|case
literal|']'
case|:
comment|/* EMAC ACCEXT bit.  */
name|val
operator|=
name|buffer
index|[
literal|0
index|]
operator|>>
literal|2
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* MAC/EMAC scale factor.  */
name|val
operator|=
name|buffer
index|[
literal|2
index|]
operator|>>
literal|1
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* EMAC ACCx.  */
name|val
operator|=
name|buffer
index|[
literal|0
index|]
operator|>>
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|val
operator|=
name|buffer
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|val
operator|=
name|buffer
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* Destination, for register or quick.  */
name|val
operator|=
operator|(
name|buffer
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|1
index|]
expr_stmt|;
name|val
operator|>>=
literal|9
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* Destination, for general arg.  */
name|val
operator|=
operator|(
name|buffer
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|1
index|]
expr_stmt|;
name|val
operator|>>=
literal|6
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|3
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|buffer
index|[
literal|3
index|]
operator|>>
literal|4
operator|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|3
argument_list|)
expr_stmt|;
name|val
operator|=
name|buffer
index|[
literal|3
index|]
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|3
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|buffer
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|3
index|]
expr_stmt|;
name|val
operator|>>=
literal|12
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|3
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|buffer
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|3
index|]
expr_stmt|;
name|val
operator|>>=
literal|6
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
case|case
literal|'j'
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|3
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|buffer
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|3
index|]
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|5
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|buffer
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|5
index|]
expr_stmt|;
name|val
operator|>>=
literal|12
expr_stmt|;
break|break;
case|case
literal|'5'
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|5
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|buffer
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|5
index|]
expr_stmt|;
name|val
operator|>>=
literal|6
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|5
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|buffer
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|5
index|]
expr_stmt|;
break|break;
case|case
literal|'7'
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|3
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|buffer
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|3
index|]
expr_stmt|;
name|val
operator|>>=
literal|7
expr_stmt|;
break|break;
case|case
literal|'8'
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|3
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|buffer
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|3
index|]
expr_stmt|;
name|val
operator|>>=
literal|10
expr_stmt|;
break|break;
case|case
literal|'9'
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|3
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|buffer
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|3
index|]
expr_stmt|;
name|val
operator|>>=
literal|5
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|val
operator|=
operator|(
name|buffer
index|[
literal|1
index|]
operator|>>
literal|6
operator|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|val
operator|=
operator|(
name|buffer
index|[
literal|1
index|]
operator|&
literal|0x40
condition|?
literal|0x8
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|buffer
index|[
literal|0
index|]
operator|>>
literal|1
operator|)
operator|&
literal|0x7
operator|)
operator||
operator|(
name|buffer
index|[
literal|3
index|]
operator|&
literal|0x80
condition|?
literal|0x10
else|:
literal|0
operator|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|val
operator|=
operator|(
name|buffer
index|[
literal|1
index|]
operator|&
literal|0x40
condition|?
literal|0x8
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|buffer
index|[
literal|0
index|]
operator|>>
literal|1
operator|)
operator|&
literal|0x7
operator|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|val
operator|=
operator|(
name|buffer
index|[
literal|2
index|]
operator|>>
literal|4
operator|)
operator||
operator|(
name|buffer
index|[
literal|3
index|]
operator|&
literal|0x80
condition|?
literal|0x10
else|:
literal|0
operator|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|val
operator|=
operator|(
name|buffer
index|[
literal|1
index|]
operator|&
literal|0xf
operator|)
operator||
operator|(
name|buffer
index|[
literal|3
index|]
operator|&
literal|0x40
condition|?
literal|0x10
else|:
literal|0
operator|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|val
operator|=
operator|(
name|buffer
index|[
literal|3
index|]
operator|&
literal|0xf
operator|)
operator||
operator|(
name|buffer
index|[
literal|3
index|]
operator|&
literal|0x40
condition|?
literal|0x10
else|:
literal|0
operator|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|val
operator|=
name|buffer
index|[
literal|2
index|]
operator|>>
literal|2
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|bits
condition|)
block|{
case|case
literal|1
case|:
return|return
name|val
operator|&
literal|1
return|;
case|case
literal|2
case|:
return|return
name|val
operator|&
literal|3
return|;
case|case
literal|3
case|:
return|return
name|val
operator|&
literal|7
return|;
case|case
literal|4
case|:
return|return
name|val
operator|&
literal|017
return|;
case|case
literal|5
case|:
return|return
name|val
operator|&
literal|037
return|;
case|case
literal|6
case|:
return|return
name|val
operator|&
literal|077
return|;
case|case
literal|7
case|:
return|return
name|val
operator|&
literal|0177
return|;
case|case
literal|8
case|:
return|return
name|val
operator|&
literal|0377
return|;
case|case
literal|12
case|:
return|return
name|val
operator|&
literal|07777
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check if an EA is valid for a particular code.  This is required    for the EMAC instructions since the type of source address determines    if it is a EMAC-load instruciton if the EA is mode 2-5, otherwise it    is a non-load EMAC instruction and the bits mean register Ry.    A similar case exists for the movem instructions where the register    mask is interpreted differently for different EAs.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m68k_valid_ea
parameter_list|(
name|char
name|code
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|int
name|mode
decl_stmt|,
name|mask
decl_stmt|;
define|#
directive|define
name|M
parameter_list|(
name|n0
parameter_list|,
name|n1
parameter_list|,
name|n2
parameter_list|,
name|n3
parameter_list|,
name|n4
parameter_list|,
name|n5
parameter_list|,
name|n6
parameter_list|,
name|n70
parameter_list|,
name|n71
parameter_list|,
name|n72
parameter_list|,
name|n73
parameter_list|,
name|n74
parameter_list|)
define|\
value|(n0 | n1<< 1 | n2<< 2 | n3<< 3 | n4<< 4 | n5<< 5 | n6<< 6 \    | n70<< 7 | n71<< 8 | n72<< 9 | n73<< 10 | n74<< 11)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'*'
case|:
name|mask
operator|=
name|M
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
name|mask
operator|=
name|M
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|mask
operator|=
name|M
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|';'
case|:
name|mask
operator|=
name|M
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
name|mask
operator|=
name|M
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|mask
operator|=
name|M
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|mask
operator|=
name|M
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
name|mask
operator|=
name|M
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|mask
operator|=
name|M
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|mask
operator|=
name|M
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
name|mask
operator|=
name|M
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|mask
operator|=
name|M
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|mask
operator|=
name|M
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|mask
operator|=
name|M
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|mask
operator|=
name|M
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|mask
operator|=
name|M
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|mask
operator|=
name|M
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|mask
operator|=
name|M
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|mask
operator|=
name|M
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|mask
operator|=
name|M
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|mask
operator|=
name|M
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|mask
operator|=
name|M
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|mask
operator|=
name|M
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
name|mask
operator|=
name|M
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
undef|#
directive|undef
name|M
name|mode
operator|=
operator|(
name|val
operator|>>
literal|3
operator|)
operator|&
literal|7
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|7
condition|)
name|mode
operator|+=
name|val
operator|&
literal|7
expr_stmt|;
return|return
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|mode
operator|)
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Print a base register REGNO and displacement DISP, on INFO->STREAM.    REGNO = -1 for pc, -2 for none (suppressed).  */
end_comment

begin_function
specifier|static
name|void
name|print_base
parameter_list|(
name|int
name|regno
parameter_list|,
name|bfd_vma
name|disp
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%pc@("
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|disp
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
if|if
condition|(
name|regno
operator|==
operator|-
literal|2
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"@("
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
operator|-
literal|3
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%zpc@("
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s@("
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|sprintf_vma
argument_list|(
name|buf
argument_list|,
name|disp
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print an indexed argument.  The base register is BASEREG (-1 for pc).    P points to extension word, in buffer.    ADDR is the nominal core address of that extension word.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|print_indexed
parameter_list|(
name|int
name|basereg
parameter_list|,
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|int
name|word
decl_stmt|;
specifier|static
name|char
modifier|*
specifier|const
name|scales
index|[]
init|=
block|{
literal|""
block|,
literal|":2"
block|,
literal|":4"
block|,
literal|":8"
block|}
decl_stmt|;
name|bfd_vma
name|base_disp
decl_stmt|;
name|bfd_vma
name|outer_disp
decl_stmt|;
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|char
name|vmabuf
index|[
literal|50
index|]
decl_stmt|;
name|word
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Generate the text for the index register.      Where this will be output is not yet determined.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s:%c%s"
argument_list|,
name|reg_names
index|[
operator|(
name|word
operator|>>
literal|12
operator|)
operator|&
literal|0xf
index|]
argument_list|,
operator|(
name|word
operator|&
literal|0x800
operator|)
condition|?
literal|'l'
else|:
literal|'w'
argument_list|,
name|scales
index|[
operator|(
name|word
operator|>>
literal|9
operator|)
operator|&
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* Handle the 68000 style of indexing.  */
if|if
condition|(
operator|(
name|word
operator|&
literal|0x100
operator|)
operator|==
literal|0
condition|)
block|{
name|base_disp
operator|=
name|word
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
name|base_disp
operator|&
literal|0x80
operator|)
operator|!=
literal|0
condition|)
name|base_disp
operator|-=
literal|0x100
expr_stmt|;
if|if
condition|(
name|basereg
operator|==
operator|-
literal|1
condition|)
name|base_disp
operator|+=
name|addr
expr_stmt|;
name|print_base
argument_list|(
name|basereg
argument_list|,
name|base_disp
argument_list|,
name|info
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|",%s)"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
comment|/* Handle the generalized kind.  */
comment|/* First, compute the displacement to add to the base register.  */
if|if
condition|(
name|word
operator|&
literal|0200
condition|)
block|{
if|if
condition|(
name|basereg
operator|==
operator|-
literal|1
condition|)
name|basereg
operator|=
operator|-
literal|3
expr_stmt|;
else|else
name|basereg
operator|=
operator|-
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|word
operator|&
literal|0100
condition|)
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|base_disp
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|(
name|word
operator|>>
literal|4
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|2
case|:
name|base_disp
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|base_disp
operator|=
name|NEXTLONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|basereg
operator|==
operator|-
literal|1
condition|)
name|base_disp
operator|+=
name|addr
expr_stmt|;
comment|/* Handle single-level case (not indirect).  */
if|if
condition|(
operator|(
name|word
operator|&
literal|7
operator|)
operator|==
literal|0
condition|)
block|{
name|print_base
argument_list|(
name|basereg
argument_list|,
name|base_disp
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|",%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
comment|/* Two level.  Compute displacement to add after indirection.  */
name|outer_disp
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|word
operator|&
literal|3
condition|)
block|{
case|case
literal|2
case|:
name|outer_disp
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|outer_disp
operator|=
name|NEXTLONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|print_base
argument_list|(
name|basereg
argument_list|,
name|base_disp
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|word
operator|&
literal|4
operator|)
operator|==
literal|0
operator|&&
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|",%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|sprintf_vma
argument_list|(
name|vmabuf
argument_list|,
name|outer_disp
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|")@(%s"
argument_list|,
name|vmabuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|",%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Returns number of bytes "eaten" by the operand, or    return -1 if an invalid operand was found, or -2 if    an opcode tabe error was found.    ADDR is the pc for this arg to be relative to.  */
end_comment

begin_function
specifier|static
name|int
name|print_insn_arg
parameter_list|(
specifier|const
name|char
modifier|*
name|d
parameter_list|,
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|,
name|unsigned
name|char
modifier|*
name|p0
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|int
name|val
init|=
literal|0
decl_stmt|;
name|int
name|place
init|=
name|d
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
init|=
name|p0
decl_stmt|;
name|int
name|regno
decl_stmt|;
specifier|const
name|char
modifier|*
name|regname
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|;
name|double
name|flval
decl_stmt|;
name|int
name|flt_p
decl_stmt|;
name|bfd_signed_vma
name|disp
decl_stmt|;
name|unsigned
name|int
name|uval
decl_stmt|;
switch|switch
condition|(
operator|*
name|d
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* Cache identifier.  */
block|{
specifier|static
name|char
modifier|*
specifier|const
name|cacheFieldName
index|[]
init|=
block|{
literal|"nc"
block|,
literal|"dc"
block|,
literal|"ic"
block|,
literal|"bc"
block|}
decl_stmt|;
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|2
argument_list|,
name|info
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
name|cacheFieldName
index|[
name|val
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'a'
case|:
comment|/* Address register indirect only. Cf. case '+'.  */
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s@"
argument_list|,
name|reg_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
operator|+
literal|8
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'_'
case|:
comment|/* 32-bit absolute address for move16.  */
block|{
name|uval
operator|=
name|NEXTULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|uval
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'C'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%ccr"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%sr"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%usp"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%acc"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%macsr"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%mask"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
block|{
comment|/* FIXME: There's a problem here, different m68k processors call the 	   same address different names. This table can't get it right 	   because it doesn't know which processor it's disassembling for.  */
specifier|static
specifier|const
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
name|names
index|[]
init|=
block|{
block|{
literal|"%sfc"
block|,
literal|0x000
block|}
block|,
block|{
literal|"%dfc"
block|,
literal|0x001
block|}
block|,
block|{
literal|"%cacr"
block|,
literal|0x002
block|}
block|,
block|{
literal|"%tc"
block|,
literal|0x003
block|}
block|,
block|{
literal|"%itt0"
block|,
literal|0x004
block|}
block|,
block|{
literal|"%itt1"
block|,
literal|0x005
block|}
block|,
block|{
literal|"%dtt0"
block|,
literal|0x006
block|}
block|,
block|{
literal|"%dtt1"
block|,
literal|0x007
block|}
block|,
block|{
literal|"%buscr"
block|,
literal|0x008
block|}
block|,
block|{
literal|"%usp"
block|,
literal|0x800
block|}
block|,
block|{
literal|"%vbr"
block|,
literal|0x801
block|}
block|,
block|{
literal|"%caar"
block|,
literal|0x802
block|}
block|,
block|{
literal|"%msp"
block|,
literal|0x803
block|}
block|,
block|{
literal|"%isp"
block|,
literal|0x804
block|}
block|,
block|{
literal|"%flashbar"
block|,
literal|0xc04
block|}
block|,
block|{
literal|"%rambar"
block|,
literal|0xc05
block|}
block|,
comment|/* mcf528x added these.  */
comment|/* Should we be calling this psr like we do in case 'Y'?  */
block|{
literal|"%mmusr"
block|,
literal|0x805
block|}
block|,
block|{
literal|"%urp"
block|,
literal|0x806
block|}
block|,
block|{
literal|"%srp"
block|,
literal|0x807
block|}
block|,
block|{
literal|"%pcr"
block|,
literal|0x808
block|}
block|}
struct|;
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|12
argument_list|,
name|info
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
sizeof|sizeof
name|names
operator|/
sizeof|sizeof
name|names
index|[
literal|0
index|]
operator|-
literal|1
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|names
index|[
name|regno
index|]
operator|.
name|value
operator|==
name|val
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|names
index|[
name|regno
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|regno
operator|<
literal|0
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'Q'
case|:
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* 0 means 8, except for the bkpt instruction... */
if|if
condition|(
name|val
operator|==
literal|0
operator|&&
name|d
index|[
literal|1
index|]
operator|!=
literal|'s'
condition|)
name|val
operator|=
literal|8
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"#%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* 0 means -1.  */
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|val
operator|=
operator|-
literal|1
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"#%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|place
operator|==
literal|'h'
condition|)
block|{
specifier|static
name|char
modifier|*
specifier|const
name|scalefactor_name
index|[]
init|=
block|{
literal|"<<"
block|,
literal|">>"
block|}
decl_stmt|;
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
name|scalefactor_name
index|[
name|val
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|8
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|0x80
condition|)
name|val
operator|=
name|val
operator|-
literal|0x100
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"#%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'T'
case|:
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"#%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
operator|+
literal|010
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|regno
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>
literal|7
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s@"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"@(%s)"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%fp%d"
argument_list|,
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|6
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|0x20
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|val
operator|&
literal|7
index|]
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s@+"
argument_list|,
name|reg_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
operator|+
literal|8
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s@-"
argument_list|,
name|reg_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
operator|+
literal|8
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
name|place
operator|==
literal|'k'
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"{%s}"
argument_list|,
name|reg_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'C'
condition|)
block|{
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|7
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|63
condition|)
comment|/* This is a signed constant.  */
name|val
operator|-=
literal|128
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"{#%d}"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|-
literal|2
return|;
break|break;
case|case
literal|'#'
case|:
case|case
literal|'^'
case|:
name|p1
operator|=
name|buffer
operator|+
operator|(
operator|*
name|d
operator|==
literal|'#'
condition|?
literal|2
else|:
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|place
operator|==
literal|'s'
condition|)
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'C'
condition|)
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|7
argument_list|,
name|info
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'8'
condition|)
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'3'
condition|)
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|8
argument_list|,
name|info
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'b'
condition|)
name|val
operator|=
name|NEXTBYTE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'w'
operator|||
name|place
operator|==
literal|'W'
condition|)
name|val
operator|=
name|NEXTWORD
argument_list|(
name|p1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'l'
condition|)
name|val
operator|=
name|NEXTLONG
argument_list|(
name|p1
argument_list|)
expr_stmt|;
else|else
return|return
operator|-
literal|2
return|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"#%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
if|if
condition|(
name|place
operator|==
literal|'b'
condition|)
name|disp
operator|=
name|NEXTBYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'B'
condition|)
name|disp
operator|=
name|COERCE_SIGNED_CHAR
argument_list|(
name|buffer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'w'
operator|||
name|place
operator|==
literal|'W'
condition|)
name|disp
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'l'
operator|||
name|place
operator|==
literal|'L'
operator|||
name|place
operator|==
literal|'C'
condition|)
name|disp
operator|=
name|NEXTLONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'g'
condition|)
block|{
name|disp
operator|=
name|NEXTBYTE
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
operator|==
literal|0
condition|)
name|disp
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|disp
operator|==
operator|-
literal|1
condition|)
name|disp
operator|=
name|NEXTLONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|place
operator|==
literal|'c'
condition|)
block|{
if|if
condition|(
name|buffer
index|[
literal|1
index|]
operator|&
literal|0x40
condition|)
comment|/* If bit six is one, long offset.  */
name|disp
operator|=
name|NEXTLONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|disp
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|-
literal|2
return|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|addr
operator|+
name|disp
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|val
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s@(%d)"
argument_list|,
name|reg_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
operator|+
literal|8
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|fpcr_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|2
argument_list|,
name|info
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%acc%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%accext%s"
argument_list|,
name|val
operator|==
literal|0
condition|?
literal|"01"
else|:
literal|"23"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|2
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|1
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"<<"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|==
literal|3
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|">>"
argument_list|)
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
break|break;
case|case
literal|'I'
case|:
comment|/* Get coprocessor ID... */
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
literal|'d'
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|1
condition|)
comment|/* Unusual coprocessor ID?  */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"(cpid=%d) "
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
case|case
literal|'*'
case|:
case|case
literal|'~'
case|:
case|case
literal|'%'
case|:
case|case
literal|';'
case|:
case|case
literal|'@'
case|:
case|case
literal|'!'
case|:
case|case
literal|'$'
case|:
case|case
literal|'?'
case|:
case|case
literal|'/'
case|:
case|case
literal|'&'
case|:
case|case
literal|'|'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'v'
case|:
case|case
literal|'b'
case|:
case|case
literal|'w'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
if|if
condition|(
name|place
operator|==
literal|'d'
condition|)
block|{
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
literal|'x'
argument_list|,
literal|6
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|&
literal|7
operator|)
operator|<<
literal|3
operator|)
operator|+
operator|(
operator|(
name|val
operator|>>
literal|3
operator|)
operator|&
literal|7
operator|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
literal|'s'
argument_list|,
literal|6
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* If the<ea> is invalid for *d, then reject this match.  */
if|if
condition|(
operator|!
name|m68k_valid_ea
argument_list|(
operator|*
name|d
argument_list|,
name|val
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Get register number assuming address register.  */
name|regno
operator|=
operator|(
name|val
operator|&
literal|7
operator|)
operator|+
literal|8
expr_stmt|;
name|regname
operator|=
name|reg_names
index|[
name|regno
index|]
expr_stmt|;
switch|switch
condition|(
name|val
operator|>>
literal|3
condition|)
block|{
case|case
literal|0
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|val
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|regname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s@"
argument_list|,
name|regname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s@+"
argument_list|,
name|regname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s@-"
argument_list|,
name|regname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|val
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s@(%d)"
argument_list|,
name|regname
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|p
operator|=
name|print_indexed
argument_list|(
name|regno
argument_list|,
name|p
argument_list|,
name|addr
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
switch|switch
condition|(
name|val
operator|&
literal|7
condition|)
block|{
case|case
literal|0
case|:
name|val
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|val
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|uval
operator|=
name|NEXTULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|uval
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|val
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%pc@("
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|addr
operator|+
name|val
argument_list|,
name|info
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|p
operator|=
name|print_indexed
argument_list|(
operator|-
literal|1
argument_list|,
name|p
argument_list|,
name|addr
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|flt_p
operator|=
literal|1
expr_stmt|;
comment|/* Assume it's a float... */
switch|switch
condition|(
name|place
condition|)
block|{
case|case
literal|'b'
case|:
name|val
operator|=
name|NEXTBYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|flt_p
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|val
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|flt_p
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|val
operator|=
name|NEXTLONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|flt_p
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|NEXTSINGLE
argument_list|(
name|flval
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|NEXTDOUBLE
argument_list|(
name|flval
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|NEXTEXTEND
argument_list|(
name|flval
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|flval
operator|=
name|NEXTPACKED
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|flt_p
condition|)
comment|/* Print a float? */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"#%g"
argument_list|,
name|flval
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"#%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* If place is '/', then this is the case of the mask bit for 	 mac/emac loads. Now that the arg has been printed, grab the 	 mask bit and if set, add a '&' to the arg.  */
if|if
condition|(
name|place
operator|==
literal|'/'
condition|)
block|{
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'L'
case|:
case|case
literal|'l'
case|:
if|if
condition|(
name|place
operator|==
literal|'w'
condition|)
block|{
name|char
name|doneany
decl_stmt|;
name|p1
operator|=
name|buffer
operator|+
literal|2
expr_stmt|;
name|val
operator|=
name|NEXTWORD
argument_list|(
name|p1
argument_list|)
expr_stmt|;
comment|/* Move the pointer ahead if this point is farther ahead 	       than the last.  */
name|p
operator|=
name|p1
operator|>
name|p
condition|?
name|p1
else|:
name|p
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"#0"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|d
operator|==
literal|'l'
condition|)
block|{
name|int
name|newval
init|=
literal|0
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|16
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|val
operator|&
operator|(
literal|0x8000
operator|>>
name|regno
operator|)
condition|)
name|newval
operator||=
literal|1
operator|<<
name|regno
expr_stmt|;
name|val
operator|=
name|newval
expr_stmt|;
block|}
name|val
operator|&=
literal|0xffff
expr_stmt|;
name|doneany
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|16
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
name|regno
operator|)
condition|)
block|{
name|int
name|first_regno
decl_stmt|;
if|if
condition|(
name|doneany
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|doneany
operator|=
literal|1
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|first_regno
operator|=
name|regno
expr_stmt|;
while|while
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
operator|(
name|regno
operator|+
literal|1
operator|)
operator|)
condition|)
operator|++
name|regno
expr_stmt|;
if|if
condition|(
name|regno
operator|>
name|first_regno
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"-%s"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|place
operator|==
literal|'3'
condition|)
block|{
comment|/* `fmovem' insn.  */
name|char
name|doneany
decl_stmt|;
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|8
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"#0"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|d
operator|==
literal|'l'
condition|)
block|{
name|int
name|newval
init|=
literal|0
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|8
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|val
operator|&
operator|(
literal|0x80
operator|>>
name|regno
operator|)
condition|)
name|newval
operator||=
literal|1
operator|<<
name|regno
expr_stmt|;
name|val
operator|=
name|newval
expr_stmt|;
block|}
name|val
operator|&=
literal|0xff
expr_stmt|;
name|doneany
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|8
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
name|regno
operator|)
condition|)
block|{
name|int
name|first_regno
decl_stmt|;
if|if
condition|(
name|doneany
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|doneany
operator|=
literal|1
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%fp%d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|first_regno
operator|=
name|regno
expr_stmt|;
while|while
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
operator|(
name|regno
operator|+
literal|1
operator|)
operator|)
condition|)
operator|++
name|regno
expr_stmt|;
if|if
condition|(
name|regno
operator|>
name|first_regno
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"-%%fp%d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|place
operator|==
literal|'8'
condition|)
block|{
comment|/* fmoveml for FP status registers.  */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|fpcr_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|-
literal|2
return|;
break|break;
case|case
literal|'X'
case|:
name|place
operator|=
literal|'8'
expr_stmt|;
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'W'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
block|{
name|int
name|val
init|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|5
argument_list|,
name|info
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
literal|2
case|:
name|name
operator|=
literal|"%tt0"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|name
operator|=
literal|"%tt1"
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
name|name
operator|=
literal|"%tc"
expr_stmt|;
break|break;
case|case
literal|0x11
case|:
name|name
operator|=
literal|"%drp"
expr_stmt|;
break|break;
case|case
literal|0x12
case|:
name|name
operator|=
literal|"%srp"
expr_stmt|;
break|break;
case|case
literal|0x13
case|:
name|name
operator|=
literal|"%crp"
expr_stmt|;
break|break;
case|case
literal|0x14
case|:
name|name
operator|=
literal|"%cal"
expr_stmt|;
break|break;
case|case
literal|0x15
case|:
name|name
operator|=
literal|"%val"
expr_stmt|;
break|break;
case|case
literal|0x16
case|:
name|name
operator|=
literal|"%scc"
expr_stmt|;
break|break;
case|case
literal|0x17
case|:
name|name
operator|=
literal|"%ac"
expr_stmt|;
break|break;
case|case
literal|0x18
case|:
name|name
operator|=
literal|"%psr"
expr_stmt|;
break|break;
case|case
literal|0x19
case|:
name|name
operator|=
literal|"%pcsr"
expr_stmt|;
break|break;
case|case
literal|0x1c
case|:
case|case
literal|0x1d
case|:
block|{
name|int
name|break_reg
init|=
operator|(
operator|(
name|buffer
index|[
literal|3
index|]
operator|>>
literal|2
operator|)
operator|&
literal|7
operator|)
decl_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
name|val
operator|==
literal|0x1c
condition|?
literal|"%%bad%d"
else|:
literal|"%%bac%d"
argument_list|,
name|break_reg
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"<mmu register %d>"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
block|{
name|int
name|fc
init|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|5
argument_list|,
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|fc
operator|==
literal|1
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%dfc"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fc
operator|==
literal|0
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%sfc"
argument_list|)
expr_stmt|;
else|else
comment|/* xgettext:c-format */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
name|_
argument_list|(
literal|"<function code %d>"
argument_list|)
argument_list|,
name|fc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'V'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%val"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
block|{
name|int
name|level
init|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
decl_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'u'
case|:
block|{
name|short
name|is_upper
init|=
literal|0
decl_stmt|;
name|int
name|reg
init|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|5
argument_list|,
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|&
literal|0x10
condition|)
block|{
name|is_upper
operator|=
literal|1
expr_stmt|;
name|reg
operator|&=
literal|0xf
expr_stmt|;
block|}
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s%s"
argument_list|,
name|reg_half_names
index|[
name|reg
index|]
argument_list|,
name|is_upper
condition|?
literal|"u"
else|:
literal|"l"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
return|return
operator|-
literal|2
return|;
block|}
return|return
name|p
operator|-
name|p0
return|;
block|}
end_function

begin_comment
comment|/* Try to match the current instruction to best and if so, return the    number of bytes consumed from the instruction stream, else zero.  */
end_comment

begin_function
specifier|static
name|int
name|match_insn_m68k
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|,
specifier|const
name|struct
name|m68k_opcode
modifier|*
name|best
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|save_p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|d
decl_stmt|;
name|struct
name|private
modifier|*
name|priv
init|=
operator|(
expr|struct
name|private
operator|*
operator|)
name|info
operator|->
name|private_data
decl_stmt|;
name|bfd_byte
modifier|*
name|buffer
init|=
name|priv
operator|->
name|the_buffer
decl_stmt|;
name|fprintf_ftype
name|save_printer
init|=
name|info
operator|->
name|fprintf_func
decl_stmt|;
name|void
function_decl|(
modifier|*
name|save_print_address
function_decl|)
parameter_list|(
name|bfd_vma
parameter_list|,
name|struct
name|disassemble_info
modifier|*
parameter_list|)
init|=
name|info
operator|->
name|print_address_func
function_decl|;
comment|/* Point at first word of argument data,      and at descriptor for first argument.  */
name|p
operator|=
name|buffer
operator|+
literal|2
expr_stmt|;
comment|/* Figure out how long the fixed-size portion of the instruction is.      The only place this is stored in the opcode table is      in the arguments--look for arguments which specify fields in the 2nd      or 3rd words of the instruction.  */
for|for
control|(
name|d
operator|=
name|best
operator|->
name|args
init|;
operator|*
name|d
condition|;
name|d
operator|+=
literal|2
control|)
block|{
comment|/* I don't think it is necessary to be checking d[0] here; 	 I suspect all this could be moved to the case statement below.  */
if|if
condition|(
name|d
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
if|if
condition|(
name|d
index|[
literal|1
index|]
operator|==
literal|'l'
operator|&&
name|p
operator|-
name|buffer
operator|<
literal|6
condition|)
name|p
operator|=
name|buffer
operator|+
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|-
name|buffer
operator|<
literal|4
operator|&&
name|d
index|[
literal|1
index|]
operator|!=
literal|'C'
operator|&&
name|d
index|[
literal|1
index|]
operator|!=
literal|'8'
condition|)
name|p
operator|=
name|buffer
operator|+
literal|4
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|d
index|[
literal|0
index|]
operator|==
literal|'L'
operator|||
name|d
index|[
literal|0
index|]
operator|==
literal|'l'
operator|)
operator|&&
name|d
index|[
literal|1
index|]
operator|==
literal|'w'
operator|&&
name|p
operator|-
name|buffer
operator|<
literal|4
condition|)
name|p
operator|=
name|buffer
operator|+
literal|4
expr_stmt|;
switch|switch
condition|(
name|d
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'i'
case|:
if|if
condition|(
name|p
operator|-
name|buffer
operator|<
literal|4
condition|)
name|p
operator|=
name|buffer
operator|+
literal|4
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
if|if
condition|(
name|p
operator|-
name|buffer
operator|<
literal|6
condition|)
name|p
operator|=
name|buffer
operator|+
literal|6
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* pflusha is an exceptions.  It takes no arguments but is two words      long.  Recognize it by looking at the lower 16 bits of the mask.  */
if|if
condition|(
name|p
operator|-
name|buffer
operator|<
literal|4
operator|&&
operator|(
name|best
operator|->
name|match
operator|&
literal|0xFFFF
operator|)
operator|!=
literal|0
condition|)
name|p
operator|=
name|buffer
operator|+
literal|4
expr_stmt|;
comment|/* lpstop is another exception.  It takes a one word argument but is      three words long.  */
if|if
condition|(
name|p
operator|-
name|buffer
operator|<
literal|6
operator|&&
operator|(
name|best
operator|->
name|match
operator|&
literal|0xffff
operator|)
operator|==
literal|0xffff
operator|&&
name|best
operator|->
name|args
index|[
literal|0
index|]
operator|==
literal|'#'
operator|&&
name|best
operator|->
name|args
index|[
literal|1
index|]
operator|==
literal|'w'
condition|)
block|{
comment|/* Copy the one word argument into the usual location for a one 	 word argument, to simplify printing it.  We can get away with 	 this because we know exactly what the second word is, and we 	 aren't going to print anything based on it.  */
name|p
operator|=
name|buffer
operator|+
literal|6
expr_stmt|;
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|buffer
index|[
literal|2
index|]
operator|=
name|buffer
index|[
literal|4
index|]
expr_stmt|;
name|buffer
index|[
literal|3
index|]
operator|=
name|buffer
index|[
literal|5
index|]
expr_stmt|;
block|}
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|d
operator|=
name|best
operator|->
name|args
expr_stmt|;
name|save_p
operator|=
name|p
expr_stmt|;
name|info
operator|->
name|print_address_func
operator|=
name|dummy_print_address
expr_stmt|;
name|info
operator|->
name|fprintf_func
operator|=
operator|(
name|fprintf_ftype
operator|)
name|dummy_printer
expr_stmt|;
comment|/* We scan the operands twice.  The first time we don't print anything,      but look for errors.  */
for|for
control|(
init|;
operator|*
name|d
condition|;
name|d
operator|+=
literal|2
control|)
block|{
name|int
name|eaten
init|=
name|print_insn_arg
argument_list|(
name|d
argument_list|,
name|buffer
argument_list|,
name|p
argument_list|,
name|memaddr
operator|+
operator|(
name|p
operator|-
name|buffer
operator|)
argument_list|,
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|eaten
operator|>=
literal|0
condition|)
name|p
operator|+=
name|eaten
expr_stmt|;
elseif|else
if|if
condition|(
name|eaten
operator|==
operator|-
literal|1
condition|)
block|{
name|info
operator|->
name|fprintf_func
operator|=
name|save_printer
expr_stmt|;
name|info
operator|->
name|print_address_func
operator|=
name|save_print_address
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
comment|/* xgettext:c-format */
name|_
argument_list|(
literal|"<internal error in opcode table: %s %s>\n"
argument_list|)
argument_list|,
name|best
operator|->
name|name
argument_list|,
name|best
operator|->
name|args
argument_list|)
expr_stmt|;
name|info
operator|->
name|fprintf_func
operator|=
name|save_printer
expr_stmt|;
name|info
operator|->
name|print_address_func
operator|=
name|save_print_address
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
name|p
operator|=
name|save_p
expr_stmt|;
name|info
operator|->
name|fprintf_func
operator|=
name|save_printer
expr_stmt|;
name|info
operator|->
name|print_address_func
operator|=
name|save_print_address
expr_stmt|;
name|d
operator|=
name|best
operator|->
name|args
expr_stmt|;
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|best
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|d
condition|)
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|d
condition|)
block|{
name|p
operator|+=
name|print_insn_arg
argument_list|(
name|d
argument_list|,
name|buffer
argument_list|,
name|p
argument_list|,
name|memaddr
operator|+
operator|(
name|p
operator|-
name|buffer
operator|)
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|d
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|d
operator|&&
operator|*
operator|(
name|d
operator|-
literal|2
operator|)
operator|!=
literal|'I'
operator|&&
operator|*
name|d
operator|!=
literal|'k'
condition|)
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
return|return
name|p
operator|-
name|buffer
return|;
block|}
end_function

begin_comment
comment|/* Try to interpret the instruction at address MEMADDR as one that    can execute on a processor with the features given by ARCH_MASK.    If successful, print the instruction to INFO->STREAM and return    its length in bytes.  Return 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|m68k_scan_mask
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|unsigned
name|int
name|arch_mask
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|d
decl_stmt|;
specifier|static
specifier|const
name|struct
name|m68k_opcode
modifier|*
modifier|*
name|opcodes
index|[
literal|16
index|]
decl_stmt|;
specifier|static
name|int
name|numopcodes
index|[
literal|16
index|]
decl_stmt|;
name|int
name|val
decl_stmt|;
name|int
name|major_opcode
decl_stmt|;
name|struct
name|private
modifier|*
name|priv
init|=
operator|(
expr|struct
name|private
operator|*
operator|)
name|info
operator|->
name|private_data
decl_stmt|;
name|bfd_byte
modifier|*
name|buffer
init|=
name|priv
operator|->
name|the_buffer
decl_stmt|;
if|if
condition|(
operator|!
name|opcodes
index|[
literal|0
index|]
condition|)
block|{
comment|/* Speed up the matching by sorting the opcode 	 table on the upper four bits of the opcode.  */
specifier|const
name|struct
name|m68k_opcode
modifier|*
modifier|*
name|opc_pointer
index|[
literal|16
index|]
decl_stmt|;
comment|/* First count how many opcodes are in each of the sixteen buckets.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m68k_numopcodes
condition|;
name|i
operator|++
control|)
name|numopcodes
index|[
operator|(
name|m68k_opcodes
index|[
name|i
index|]
operator|.
name|opcode
operator|>>
literal|28
operator|)
operator|&
literal|15
index|]
operator|++
expr_stmt|;
comment|/* Then create a sorted table of pointers 	 that point into the unsorted table.  */
name|opc_pointer
index|[
literal|0
index|]
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|m68k_opcode
operator|*
argument_list|)
operator|*
name|m68k_numopcodes
argument_list|)
expr_stmt|;
name|opcodes
index|[
literal|0
index|]
operator|=
name|opc_pointer
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|opc_pointer
index|[
name|i
index|]
operator|=
name|opc_pointer
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|numopcodes
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|opcodes
index|[
name|i
index|]
operator|=
name|opc_pointer
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m68k_numopcodes
condition|;
name|i
operator|++
control|)
operator|*
name|opc_pointer
index|[
operator|(
name|m68k_opcodes
index|[
name|i
index|]
operator|.
name|opcode
operator|>>
literal|28
operator|)
operator|&
literal|15
index|]
operator|++
operator|=
operator|&
name|m68k_opcodes
index|[
name|i
index|]
expr_stmt|;
block|}
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|2
argument_list|)
expr_stmt|;
name|major_opcode
operator|=
operator|(
name|buffer
index|[
literal|0
index|]
operator|>>
literal|4
operator|)
operator|&
literal|15
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numopcodes
index|[
name|major_opcode
index|]
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|m68k_opcode
modifier|*
name|opc
init|=
name|opcodes
index|[
name|major_opcode
index|]
index|[
name|i
index|]
decl_stmt|;
name|unsigned
name|long
name|opcode
init|=
name|opc
operator|->
name|opcode
decl_stmt|;
name|unsigned
name|long
name|match
init|=
name|opc
operator|->
name|match
decl_stmt|;
if|if
condition|(
operator|(
operator|(
literal|0xff
operator|&
name|buffer
index|[
literal|0
index|]
operator|&
operator|(
name|match
operator|>>
literal|24
operator|)
operator|)
operator|==
operator|(
literal|0xff
operator|&
operator|(
name|opcode
operator|>>
literal|24
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
literal|0xff
operator|&
name|buffer
index|[
literal|1
index|]
operator|&
operator|(
name|match
operator|>>
literal|16
operator|)
operator|)
operator|==
operator|(
literal|0xff
operator|&
operator|(
name|opcode
operator|>>
literal|16
operator|)
operator|)
operator|)
comment|/* Only fetch the next two bytes if we need to.  */
operator|&&
operator|(
operator|(
operator|(
literal|0xffff
operator|&
name|match
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|4
argument_list|)
operator|&&
operator|(
operator|(
literal|0xff
operator|&
name|buffer
index|[
literal|2
index|]
operator|&
operator|(
name|match
operator|>>
literal|8
operator|)
operator|)
operator|==
operator|(
literal|0xff
operator|&
operator|(
name|opcode
operator|>>
literal|8
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
literal|0xff
operator|&
name|buffer
index|[
literal|3
index|]
operator|&
name|match
operator|)
operator|==
operator|(
literal|0xff
operator|&
name|opcode
operator|)
operator|)
operator|)
operator|)
operator|&&
operator|(
name|opc
operator|->
name|arch
operator|&
name|arch_mask
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Don't use for printout the variants of divul and divsl 	     that have the same register number in two places. 	     The more general variants will match instead.  */
for|for
control|(
name|d
operator|=
name|opc
operator|->
name|args
init|;
operator|*
name|d
condition|;
name|d
operator|+=
literal|2
control|)
if|if
condition|(
name|d
index|[
literal|1
index|]
operator|==
literal|'D'
condition|)
break|break;
comment|/* Don't use for printout the variants of most floating 	     point coprocessor instructions which use the same 	     register number in two places, as above.  */
if|if
condition|(
operator|*
name|d
operator|==
literal|'\0'
condition|)
for|for
control|(
name|d
operator|=
name|opc
operator|->
name|args
init|;
operator|*
name|d
condition|;
name|d
operator|+=
literal|2
control|)
if|if
condition|(
name|d
index|[
literal|1
index|]
operator|==
literal|'t'
condition|)
break|break;
comment|/* Don't match fmovel with more than one register; 	     wait for fmoveml.  */
if|if
condition|(
operator|*
name|d
operator|==
literal|'\0'
condition|)
block|{
for|for
control|(
name|d
operator|=
name|opc
operator|->
name|args
init|;
operator|*
name|d
condition|;
name|d
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|d
index|[
literal|0
index|]
operator|==
literal|'s'
operator|&&
name|d
index|[
literal|1
index|]
operator|==
literal|'8'
condition|)
block|{
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|d
index|[
literal|1
index|]
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
operator|(
name|val
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
block|}
comment|/* Don't match FPU insns with non-default coprocessor ID.  */
if|if
condition|(
operator|*
name|d
operator|==
literal|'\0'
condition|)
block|{
for|for
control|(
name|d
operator|=
name|opc
operator|->
name|args
init|;
operator|*
name|d
condition|;
name|d
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|d
index|[
literal|0
index|]
operator|==
literal|'I'
condition|)
block|{
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
literal|'d'
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|1
condition|)
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|*
name|d
operator|==
literal|'\0'
condition|)
if|if
condition|(
operator|(
name|val
operator|=
name|match_insn_m68k
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|,
name|opc
argument_list|)
operator|)
condition|)
return|return
name|val
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Print the m68k instruction at address MEMADDR in debugged memory,    on INFO->STREAM.  Returns length of the instruction, in bytes.  */
end_comment

begin_function
name|int
name|print_insn_m68k
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|unsigned
name|int
name|arch_mask
decl_stmt|;
name|struct
name|private
name|priv
decl_stmt|;
name|int
name|val
decl_stmt|;
name|bfd_byte
modifier|*
name|buffer
init|=
name|priv
operator|.
name|the_buffer
decl_stmt|;
name|info
operator|->
name|private_data
operator|=
operator|(
name|PTR
operator|)
operator|&
name|priv
expr_stmt|;
comment|/* Tell objdump to use two bytes per chunk      and six bytes per line for displaying raw data.  */
name|info
operator|->
name|bytes_per_chunk
operator|=
literal|2
expr_stmt|;
name|info
operator|->
name|bytes_per_line
operator|=
literal|6
expr_stmt|;
name|info
operator|->
name|display_endian
operator|=
name|BFD_ENDIAN_BIG
expr_stmt|;
name|priv
operator|.
name|max_fetched
operator|=
name|priv
operator|.
name|the_buffer
expr_stmt|;
name|priv
operator|.
name|insn_start
operator|=
name|memaddr
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|priv
operator|.
name|bailout
argument_list|)
operator|!=
literal|0
condition|)
comment|/* Error return.  */
return|return
operator|-
literal|1
return|;
name|arch_mask
operator|=
name|bfd_m68k_mach_to_features
argument_list|(
name|info
operator|->
name|mach
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arch_mask
condition|)
block|{
comment|/* First try printing an m680x0 instruction.  Try printing a Coldfire 	 one if that fails.  */
name|val
operator|=
name|m68k_scan_mask
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|,
name|m68k_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
name|val
operator|=
name|m68k_scan_mask
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|,
name|mcf_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
block|}
else|else
block|{
name|val
operator|=
name|m68k_scan_mask
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|,
name|arch_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
block|}
comment|/* Handle undefined instructions.  */
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0%o"
argument_list|,
operator|(
name|buffer
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
end_function

end_unit

