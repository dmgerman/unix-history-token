begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print Motorola 68k instructions.    Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997,    1998, 1999, 2000, 2001, 2002, 2003    Free Software Foundation, Inc.     This file is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"opintl.h"
end_include

begin_include
include|#
directive|include
file|"opcode/m68k.h"
end_include

begin_comment
comment|/* Local function prototypes */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fetch_data
name|PARAMS
argument_list|(
operator|(
expr|struct
name|disassemble_info
operator|*
operator|,
name|bfd_byte
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dummy_print_address
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
expr|struct
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fetch_arg
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_base
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|print_indexed
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|unsigned
name|char
operator|*
operator|,
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|print_insn_arg
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|fpcr_names
index|[]
init|=
block|{
literal|""
block|,
literal|"%fpiar"
block|,
literal|"%fpsr"
block|,
literal|"%fpiar/%fpsr"
block|,
literal|"%fpcr"
block|,
literal|"%fpiar/%fpcr"
block|,
literal|"%fpsr/%fpcr"
block|,
literal|"%fpiar/%fpsr/%fpcr"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
specifier|const
name|reg_names
index|[]
init|=
block|{
literal|"%d0"
block|,
literal|"%d1"
block|,
literal|"%d2"
block|,
literal|"%d3"
block|,
literal|"%d4"
block|,
literal|"%d5"
block|,
literal|"%d6"
block|,
literal|"%d7"
block|,
literal|"%a0"
block|,
literal|"%a1"
block|,
literal|"%a2"
block|,
literal|"%a3"
block|,
literal|"%a4"
block|,
literal|"%a5"
block|,
literal|"%fp"
block|,
literal|"%sp"
block|,
literal|"%ps"
block|,
literal|"%pc"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sign-extend an (unsigned char). */
end_comment

begin_if
if|#
directive|if
name|__STDC__
operator|==
literal|1
end_if

begin_define
define|#
directive|define
name|COERCE_SIGNED_CHAR
parameter_list|(
name|ch
parameter_list|)
value|((signed char) (ch))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|COERCE_SIGNED_CHAR
parameter_list|(
name|ch
parameter_list|)
value|((int) (((ch) ^ 0x80)& 0xFF) - 128)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Get a 1 byte signed integer.  */
end_comment

begin_define
define|#
directive|define
name|NEXTBYTE
parameter_list|(
name|p
parameter_list|)
value|(p += 2, FETCH_DATA (info, p), COERCE_SIGNED_CHAR(p[-1]))
end_define

begin_comment
comment|/* Get a 2 byte signed integer.  */
end_comment

begin_define
define|#
directive|define
name|COERCE16
parameter_list|(
name|x
parameter_list|)
value|((int) (((x) ^ 0x8000) - 0x8000))
end_define

begin_define
define|#
directive|define
name|NEXTWORD
parameter_list|(
name|p
parameter_list|)
define|\
value|(p += 2, FETCH_DATA (info, p), \    COERCE16 ((p[-2]<< 8) + p[-1]))
end_define

begin_comment
comment|/* Get a 4 byte signed integer.  */
end_comment

begin_define
define|#
directive|define
name|COERCE32
parameter_list|(
name|x
parameter_list|)
value|((bfd_signed_vma) ((x) ^ 0x80000000) - 0x80000000)
end_define

begin_define
define|#
directive|define
name|NEXTLONG
parameter_list|(
name|p
parameter_list|)
define|\
value|(p += 4, FETCH_DATA (info, p), \    (COERCE32 ((((((p[-4]<< 8) + p[-3])<< 8) + p[-2])<< 8) + p[-1])))
end_define

begin_comment
comment|/* Get a 4 byte unsigned integer.  */
end_comment

begin_define
define|#
directive|define
name|NEXTULONG
parameter_list|(
name|p
parameter_list|)
define|\
value|(p += 4, FETCH_DATA (info, p), \    (unsigned int) ((((((p[-4]<< 8) + p[-3])<< 8) + p[-2])<< 8) + p[-1]))
end_define

begin_comment
comment|/* Get a single precision float.  */
end_comment

begin_define
define|#
directive|define
name|NEXTSINGLE
parameter_list|(
name|val
parameter_list|,
name|p
parameter_list|)
define|\
value|(p += 4, FETCH_DATA (info, p), \    floatformat_to_double (&floatformat_ieee_single_big, (char *) p - 4,&val))
end_define

begin_comment
comment|/* Get a double precision float.  */
end_comment

begin_define
define|#
directive|define
name|NEXTDOUBLE
parameter_list|(
name|val
parameter_list|,
name|p
parameter_list|)
define|\
value|(p += 8, FETCH_DATA (info, p), \    floatformat_to_double (&floatformat_ieee_double_big, (char *) p - 8,&val))
end_define

begin_comment
comment|/* Get an extended precision float.  */
end_comment

begin_define
define|#
directive|define
name|NEXTEXTEND
parameter_list|(
name|val
parameter_list|,
name|p
parameter_list|)
define|\
value|(p += 12, FETCH_DATA (info, p), \    floatformat_to_double (&floatformat_m68881_ext, (char *) p - 12,&val))
end_define

begin_comment
comment|/* Need a function to convert from packed to double    precision.   Actually, it's easier to print a    packed number than a double anyway, so maybe    there should be a special case to handle this... */
end_comment

begin_define
define|#
directive|define
name|NEXTPACKED
parameter_list|(
name|p
parameter_list|)
define|\
value|(p += 12, FETCH_DATA (info, p), 0.0)
end_define

begin_escape
end_escape

begin_comment
comment|/* Maximum length of an instruction.  */
end_comment

begin_define
define|#
directive|define
name|MAXLEN
value|22
end_define

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_struct
struct|struct
name|private
block|{
comment|/* Points to first byte not fetched.  */
name|bfd_byte
modifier|*
name|max_fetched
decl_stmt|;
name|bfd_byte
name|the_buffer
index|[
name|MAXLEN
index|]
decl_stmt|;
name|bfd_vma
name|insn_start
decl_stmt|;
name|jmp_buf
name|bailout
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Make sure that bytes from INFO->PRIVATE_DATA->BUFFER (inclusive)    to ADDR (exclusive) are valid.  Returns 1 for success, longjmps    on error.  */
end_comment

begin_define
define|#
directive|define
name|FETCH_DATA
parameter_list|(
name|info
parameter_list|,
name|addr
parameter_list|)
define|\
value|((addr)<= ((struct private *) (info->private_data))->max_fetched \    ? 1 : fetch_data ((info), (addr)))
end_define

begin_function
specifier|static
name|int
name|fetch_data
parameter_list|(
name|info
parameter_list|,
name|addr
parameter_list|)
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|struct
name|private
modifier|*
name|priv
init|=
operator|(
expr|struct
name|private
operator|*
operator|)
name|info
operator|->
name|private_data
decl_stmt|;
name|bfd_vma
name|start
init|=
name|priv
operator|->
name|insn_start
operator|+
operator|(
name|priv
operator|->
name|max_fetched
operator|-
name|priv
operator|->
name|the_buffer
operator|)
decl_stmt|;
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|start
argument_list|,
name|priv
operator|->
name|max_fetched
argument_list|,
name|addr
operator|-
name|priv
operator|->
name|max_fetched
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|memory_error_func
call|)
argument_list|(
name|status
argument_list|,
name|start
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|priv
operator|->
name|bailout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|priv
operator|->
name|max_fetched
operator|=
name|addr
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function is used to print to the bit-bucket. */
end_comment

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|dummy_printer
parameter_list|(
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|format
name|ATTRIBUTE_UNUSED
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|dummy_printer
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
endif|#
directive|endif
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dummy_print_address
parameter_list|(
name|vma
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|vma
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* Print the m68k instruction at address MEMADDR in debugged memory,    on INFO->STREAM.  Returns length of the instruction, in bytes.  */
end_comment

begin_function
name|int
name|print_insn_m68k
parameter_list|(
name|memaddr
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|memaddr
decl_stmt|;
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|save_p
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|unsigned
name|long
name|bestmask
decl_stmt|;
specifier|const
name|struct
name|m68k_opcode
modifier|*
name|best
decl_stmt|;
name|unsigned
name|int
name|arch_mask
decl_stmt|;
name|struct
name|private
name|priv
decl_stmt|;
name|bfd_byte
modifier|*
name|buffer
init|=
name|priv
operator|.
name|the_buffer
decl_stmt|;
name|fprintf_ftype
name|save_printer
init|=
name|info
operator|->
name|fprintf_func
decl_stmt|;
name|void
argument_list|(
argument|*save_print_address
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
expr|struct
name|disassemble_info
operator|*
operator|)
argument_list|)
operator|=
name|info
operator|->
name|print_address_func
expr_stmt|;
name|int
name|major_opcode
decl_stmt|;
specifier|static
name|int
name|numopcodes
index|[
literal|16
index|]
decl_stmt|;
specifier|static
specifier|const
name|struct
name|m68k_opcode
modifier|*
modifier|*
name|opcodes
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|opcodes
index|[
literal|0
index|]
condition|)
block|{
comment|/* Speed up the matching by sorting the opcode table on the upper 	 four bits of the opcode.  */
specifier|const
name|struct
name|m68k_opcode
modifier|*
modifier|*
name|opc_pointer
index|[
literal|16
index|]
decl_stmt|;
comment|/* First count how many opcodes are in each of the sixteen buckets.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m68k_numopcodes
condition|;
name|i
operator|++
control|)
name|numopcodes
index|[
operator|(
name|m68k_opcodes
index|[
name|i
index|]
operator|.
name|opcode
operator|>>
literal|28
operator|)
operator|&
literal|15
index|]
operator|++
expr_stmt|;
comment|/* Then create a sorted table of pointers that point into the 	 unsorted table.  */
name|opc_pointer
index|[
literal|0
index|]
operator|=
operator|(
operator|(
specifier|const
expr|struct
name|m68k_opcode
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|m68k_opcode
operator|*
argument_list|)
operator|*
name|m68k_numopcodes
argument_list|)
operator|)
expr_stmt|;
name|opcodes
index|[
literal|0
index|]
operator|=
name|opc_pointer
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|opc_pointer
index|[
name|i
index|]
operator|=
name|opc_pointer
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|numopcodes
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|opcodes
index|[
name|i
index|]
operator|=
name|opc_pointer
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m68k_numopcodes
condition|;
name|i
operator|++
control|)
operator|*
name|opc_pointer
index|[
operator|(
name|m68k_opcodes
index|[
name|i
index|]
operator|.
name|opcode
operator|>>
literal|28
operator|)
operator|&
literal|15
index|]
operator|++
operator|=
operator|&
name|m68k_opcodes
index|[
name|i
index|]
expr_stmt|;
block|}
name|info
operator|->
name|private_data
operator|=
operator|(
name|PTR
operator|)
operator|&
name|priv
expr_stmt|;
comment|/* Tell objdump to use two bytes per chunk and six bytes per line for      displaying raw data.  */
name|info
operator|->
name|bytes_per_chunk
operator|=
literal|2
expr_stmt|;
name|info
operator|->
name|bytes_per_line
operator|=
literal|6
expr_stmt|;
name|info
operator|->
name|display_endian
operator|=
name|BFD_ENDIAN_BIG
expr_stmt|;
name|priv
operator|.
name|max_fetched
operator|=
name|priv
operator|.
name|the_buffer
expr_stmt|;
name|priv
operator|.
name|insn_start
operator|=
name|memaddr
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|priv
operator|.
name|bailout
argument_list|)
operator|!=
literal|0
condition|)
comment|/* Error return.  */
return|return
operator|-
literal|1
return|;
name|best
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|info
operator|->
name|mach
condition|)
block|{
default|default:
case|case
literal|0
case|:
name|arch_mask
operator|=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|bfd_mach_m68000
case|:
name|arch_mask
operator|=
name|m68000
expr_stmt|;
break|break;
case|case
name|bfd_mach_m68008
case|:
name|arch_mask
operator|=
name|m68008
expr_stmt|;
break|break;
case|case
name|bfd_mach_m68010
case|:
name|arch_mask
operator|=
name|m68010
expr_stmt|;
break|break;
case|case
name|bfd_mach_m68020
case|:
name|arch_mask
operator|=
name|m68020
expr_stmt|;
break|break;
case|case
name|bfd_mach_m68030
case|:
name|arch_mask
operator|=
name|m68030
expr_stmt|;
break|break;
case|case
name|bfd_mach_m68040
case|:
name|arch_mask
operator|=
name|m68040
expr_stmt|;
break|break;
case|case
name|bfd_mach_m68060
case|:
name|arch_mask
operator|=
name|m68060
expr_stmt|;
break|break;
case|case
name|bfd_mach_mcf5200
case|:
name|arch_mask
operator|=
name|mcf5200
expr_stmt|;
break|break;
case|case
name|bfd_mach_mcf528x
case|:
name|arch_mask
operator|=
name|mcf528x
expr_stmt|;
break|break;
case|case
name|bfd_mach_mcf5206e
case|:
name|arch_mask
operator|=
name|mcf5206e
expr_stmt|;
break|break;
case|case
name|bfd_mach_mcf5307
case|:
name|arch_mask
operator|=
name|mcf5307
expr_stmt|;
break|break;
case|case
name|bfd_mach_mcf5407
case|:
name|arch_mask
operator|=
name|mcf5407
expr_stmt|;
break|break;
block|}
name|arch_mask
operator||=
name|m68881
operator||
name|m68851
expr_stmt|;
name|bestmask
operator|=
literal|0
expr_stmt|;
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|2
argument_list|)
expr_stmt|;
name|major_opcode
operator|=
operator|(
name|buffer
index|[
literal|0
index|]
operator|>>
literal|4
operator|)
operator|&
literal|15
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numopcodes
index|[
name|major_opcode
index|]
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|m68k_opcode
modifier|*
name|opc
init|=
name|opcodes
index|[
name|major_opcode
index|]
index|[
name|i
index|]
decl_stmt|;
name|unsigned
name|long
name|opcode
init|=
name|opc
operator|->
name|opcode
decl_stmt|;
name|unsigned
name|long
name|match
init|=
name|opc
operator|->
name|match
decl_stmt|;
if|if
condition|(
operator|(
operator|(
literal|0xff
operator|&
name|buffer
index|[
literal|0
index|]
operator|&
operator|(
name|match
operator|>>
literal|24
operator|)
operator|)
operator|==
operator|(
literal|0xff
operator|&
operator|(
name|opcode
operator|>>
literal|24
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
literal|0xff
operator|&
name|buffer
index|[
literal|1
index|]
operator|&
operator|(
name|match
operator|>>
literal|16
operator|)
operator|)
operator|==
operator|(
literal|0xff
operator|&
operator|(
name|opcode
operator|>>
literal|16
operator|)
operator|)
operator|)
comment|/* Only fetch the next two bytes if we need to.  */
operator|&&
operator|(
operator|(
operator|(
literal|0xffff
operator|&
name|match
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|4
argument_list|)
operator|&&
operator|(
operator|(
literal|0xff
operator|&
name|buffer
index|[
literal|2
index|]
operator|&
operator|(
name|match
operator|>>
literal|8
operator|)
operator|)
operator|==
operator|(
literal|0xff
operator|&
operator|(
name|opcode
operator|>>
literal|8
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
literal|0xff
operator|&
name|buffer
index|[
literal|3
index|]
operator|&
name|match
operator|)
operator|==
operator|(
literal|0xff
operator|&
name|opcode
operator|)
operator|)
operator|)
operator|)
operator|&&
operator|(
name|opc
operator|->
name|arch
operator|&
name|arch_mask
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Don't use for printout the variants of divul and divsl 	     that have the same register number in two places. 	     The more general variants will match instead.  */
for|for
control|(
name|d
operator|=
name|opc
operator|->
name|args
init|;
operator|*
name|d
condition|;
name|d
operator|+=
literal|2
control|)
if|if
condition|(
name|d
index|[
literal|1
index|]
operator|==
literal|'D'
condition|)
break|break;
comment|/* Don't use for printout the variants of most floating 	     point coprocessor instructions which use the same 	     register number in two places, as above. */
if|if
condition|(
operator|*
name|d
operator|==
literal|'\0'
condition|)
for|for
control|(
name|d
operator|=
name|opc
operator|->
name|args
init|;
operator|*
name|d
condition|;
name|d
operator|+=
literal|2
control|)
if|if
condition|(
name|d
index|[
literal|1
index|]
operator|==
literal|'t'
condition|)
break|break;
comment|/* Don't match fmovel with more than one register; wait for              fmoveml.  */
if|if
condition|(
operator|*
name|d
operator|==
literal|'\0'
condition|)
block|{
for|for
control|(
name|d
operator|=
name|opc
operator|->
name|args
init|;
operator|*
name|d
condition|;
name|d
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|d
index|[
literal|0
index|]
operator|==
literal|'s'
operator|&&
name|d
index|[
literal|1
index|]
operator|==
literal|'8'
condition|)
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|d
index|[
literal|1
index|]
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
operator|(
name|val
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|*
name|d
operator|==
literal|'\0'
operator|&&
name|match
operator|>
name|bestmask
condition|)
block|{
name|best
operator|=
name|opc
expr_stmt|;
name|bestmask
operator|=
name|match
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|best
operator|==
name|NULL
condition|)
goto|goto
name|invalid
goto|;
comment|/* Point at first word of argument data,      and at descriptor for first argument.  */
name|p
operator|=
name|buffer
operator|+
literal|2
expr_stmt|;
comment|/* Figure out how long the fixed-size portion of the instruction is.      The only place this is stored in the opcode table is      in the arguments--look for arguments which specify fields in the 2nd      or 3rd words of the instruction.  */
for|for
control|(
name|d
operator|=
name|best
operator|->
name|args
init|;
operator|*
name|d
condition|;
name|d
operator|+=
literal|2
control|)
block|{
comment|/* I don't think it is necessary to be checking d[0] here; I suspect 	 all this could be moved to the case statement below.  */
if|if
condition|(
name|d
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
if|if
condition|(
name|d
index|[
literal|1
index|]
operator|==
literal|'l'
operator|&&
name|p
operator|-
name|buffer
operator|<
literal|6
condition|)
name|p
operator|=
name|buffer
operator|+
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|-
name|buffer
operator|<
literal|4
operator|&&
name|d
index|[
literal|1
index|]
operator|!=
literal|'C'
operator|&&
name|d
index|[
literal|1
index|]
operator|!=
literal|'8'
condition|)
name|p
operator|=
name|buffer
operator|+
literal|4
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|d
index|[
literal|0
index|]
operator|==
literal|'L'
operator|||
name|d
index|[
literal|0
index|]
operator|==
literal|'l'
operator|)
operator|&&
name|d
index|[
literal|1
index|]
operator|==
literal|'w'
operator|&&
name|p
operator|-
name|buffer
operator|<
literal|4
condition|)
name|p
operator|=
name|buffer
operator|+
literal|4
expr_stmt|;
switch|switch
condition|(
name|d
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'i'
case|:
if|if
condition|(
name|p
operator|-
name|buffer
operator|<
literal|4
condition|)
name|p
operator|=
name|buffer
operator|+
literal|4
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
if|if
condition|(
name|p
operator|-
name|buffer
operator|<
literal|6
condition|)
name|p
operator|=
name|buffer
operator|+
literal|6
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* pflusha is an exceptions.  It takes no arguments but is two words      long.  Recognize it by looking at the lower 16 bits of the mask.  */
if|if
condition|(
name|p
operator|-
name|buffer
operator|<
literal|4
operator|&&
operator|(
name|best
operator|->
name|match
operator|&
literal|0xFFFF
operator|)
operator|!=
literal|0
condition|)
name|p
operator|=
name|buffer
operator|+
literal|4
expr_stmt|;
comment|/* lpstop is another exception.  It takes a one word argument but is      three words long.  */
if|if
condition|(
name|p
operator|-
name|buffer
operator|<
literal|6
operator|&&
operator|(
name|best
operator|->
name|match
operator|&
literal|0xffff
operator|)
operator|==
literal|0xffff
operator|&&
name|best
operator|->
name|args
index|[
literal|0
index|]
operator|==
literal|'#'
operator|&&
name|best
operator|->
name|args
index|[
literal|1
index|]
operator|==
literal|'w'
condition|)
block|{
comment|/* Copy the one word argument into the usual location for a one 	 word argument, to simplify printing it.  We can get away with 	 this because we know exactly what the second word is, and we 	 aren't going to print anything based on it.  */
name|p
operator|=
name|buffer
operator|+
literal|6
expr_stmt|;
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|buffer
index|[
literal|2
index|]
operator|=
name|buffer
index|[
literal|4
index|]
expr_stmt|;
name|buffer
index|[
literal|3
index|]
operator|=
name|buffer
index|[
literal|5
index|]
expr_stmt|;
block|}
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|d
operator|=
name|best
operator|->
name|args
expr_stmt|;
comment|/* We scan the operands twice.  The first time we don't print anything,      but look for errors. */
name|save_p
operator|=
name|p
expr_stmt|;
name|info
operator|->
name|print_address_func
operator|=
name|dummy_print_address
expr_stmt|;
name|info
operator|->
name|fprintf_func
operator|=
operator|(
name|fprintf_ftype
operator|)
name|dummy_printer
expr_stmt|;
for|for
control|(
init|;
operator|*
name|d
condition|;
name|d
operator|+=
literal|2
control|)
block|{
name|int
name|eaten
init|=
name|print_insn_arg
argument_list|(
name|d
argument_list|,
name|buffer
argument_list|,
name|p
argument_list|,
name|memaddr
operator|+
operator|(
name|p
operator|-
name|buffer
operator|)
argument_list|,
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|eaten
operator|>=
literal|0
condition|)
name|p
operator|+=
name|eaten
expr_stmt|;
elseif|else
if|if
condition|(
name|eaten
operator|==
operator|-
literal|1
condition|)
goto|goto
name|invalid
goto|;
else|else
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
comment|/* xgettext:c-format */
name|_
argument_list|(
literal|"<internal error in opcode table: %s %s>\n"
argument_list|)
argument_list|,
name|best
operator|->
name|name
argument_list|,
name|best
operator|->
name|args
argument_list|)
expr_stmt|;
goto|goto
name|invalid
goto|;
block|}
block|}
name|p
operator|=
name|save_p
expr_stmt|;
name|info
operator|->
name|fprintf_func
operator|=
name|save_printer
expr_stmt|;
name|info
operator|->
name|print_address_func
operator|=
name|save_print_address
expr_stmt|;
name|d
operator|=
name|best
operator|->
name|args
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|best
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|d
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|d
condition|)
block|{
name|p
operator|+=
name|print_insn_arg
argument_list|(
name|d
argument_list|,
name|buffer
argument_list|,
name|p
argument_list|,
name|memaddr
operator|+
operator|(
name|p
operator|-
name|buffer
operator|)
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|d
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|d
operator|&&
operator|*
operator|(
name|d
operator|-
literal|2
operator|)
operator|!=
literal|'I'
operator|&&
operator|*
name|d
operator|!=
literal|'k'
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
return|return
name|p
operator|-
name|buffer
return|;
name|invalid
label|:
comment|/* Handle undefined instructions.  */
name|info
operator|->
name|fprintf_func
operator|=
name|save_printer
expr_stmt|;
name|info
operator|->
name|print_address_func
operator|=
name|save_print_address
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0%o"
argument_list|,
operator|(
name|buffer
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Returns number of bytes "eaten" by the operand, or    return -1 if an invalid operand was found, or -2 if    an opcode tabe error was found. */
end_comment

begin_function
specifier|static
name|int
name|print_insn_arg
parameter_list|(
name|d
parameter_list|,
name|buffer
parameter_list|,
name|p0
parameter_list|,
name|addr
parameter_list|,
name|info
parameter_list|)
specifier|const
name|char
modifier|*
name|d
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p0
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
comment|/* PC for this arg to be relative to */
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
specifier|register
name|int
name|val
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|place
init|=
name|d
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
init|=
name|p0
decl_stmt|;
name|int
name|regno
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|regname
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|;
name|double
name|flval
decl_stmt|;
name|int
name|flt_p
decl_stmt|;
name|bfd_signed_vma
name|disp
decl_stmt|;
name|unsigned
name|int
name|uval
decl_stmt|;
switch|switch
condition|(
operator|*
name|d
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* cache identifier */
block|{
specifier|static
name|char
modifier|*
specifier|const
name|cacheFieldName
index|[]
init|=
block|{
literal|"nc"
block|,
literal|"dc"
block|,
literal|"ic"
block|,
literal|"bc"
block|}
decl_stmt|;
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|2
argument_list|,
name|info
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
name|cacheFieldName
index|[
name|val
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'a'
case|:
comment|/* address register indirect only. Cf. case '+'. */
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s@"
argument_list|,
name|reg_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
operator|+
literal|8
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'_'
case|:
comment|/* 32-bit absolute address for move16. */
block|{
name|uval
operator|=
name|NEXTULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|uval
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'C'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%ccr"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%sr"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%usp"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%acc"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%macsr"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%mask"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
block|{
comment|/* FIXME: There's a problem here, different m68k processors call the 	   same address different names. This table can't get it right 	   because it doesn't know which processor it's disassembling for.  */
specifier|static
specifier|const
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
name|names
index|[]
init|=
block|{
block|{
literal|"%sfc"
block|,
literal|0x000
block|}
block|,
block|{
literal|"%dfc"
block|,
literal|0x001
block|}
block|,
block|{
literal|"%cacr"
block|,
literal|0x002
block|}
block|,
block|{
literal|"%tc"
block|,
literal|0x003
block|}
block|,
block|{
literal|"%itt0"
block|,
literal|0x004
block|}
block|,
block|{
literal|"%itt1"
block|,
literal|0x005
block|}
block|,
block|{
literal|"%dtt0"
block|,
literal|0x006
block|}
block|,
block|{
literal|"%dtt1"
block|,
literal|0x007
block|}
block|,
block|{
literal|"%buscr"
block|,
literal|0x008
block|}
block|,
block|{
literal|"%usp"
block|,
literal|0x800
block|}
block|,
block|{
literal|"%vbr"
block|,
literal|0x801
block|}
block|,
block|{
literal|"%caar"
block|,
literal|0x802
block|}
block|,
block|{
literal|"%msp"
block|,
literal|0x803
block|}
block|,
block|{
literal|"%isp"
block|,
literal|0x804
block|}
block|,
block|{
literal|"%flashbar"
block|,
literal|0xc04
block|}
block|,
block|{
literal|"%rambar"
block|,
literal|0xc05
block|}
block|,
comment|/* mcf528x added these.  */
comment|/* Should we be calling this psr like we do in case 'Y'?  */
block|{
literal|"%mmusr"
block|,
literal|0x805
block|}
block|,
block|{
literal|"%urp"
block|,
literal|0x806
block|}
block|,
block|{
literal|"%srp"
block|,
literal|0x807
block|}
block|,
block|{
literal|"%pcr"
block|,
literal|0x808
block|}
block|}
struct|;
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|12
argument_list|,
name|info
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
sizeof|sizeof
name|names
operator|/
sizeof|sizeof
name|names
index|[
literal|0
index|]
operator|-
literal|1
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|names
index|[
name|regno
index|]
operator|.
name|value
operator|==
name|val
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|names
index|[
name|regno
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|regno
operator|<
literal|0
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'Q'
case|:
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* 0 means 8, except for the bkpt instruction... */
if|if
condition|(
name|val
operator|==
literal|0
operator|&&
name|d
index|[
literal|1
index|]
operator|!=
literal|'s'
condition|)
name|val
operator|=
literal|8
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"#%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* 0 means -1.  */
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|val
operator|=
operator|-
literal|1
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"#%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|place
operator|==
literal|'h'
condition|)
block|{
specifier|static
name|char
modifier|*
specifier|const
name|scalefactor_name
index|[]
init|=
block|{
literal|"<<"
block|,
literal|">>"
block|}
decl_stmt|;
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
name|scalefactor_name
index|[
name|val
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|8
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|0x80
condition|)
name|val
operator|=
name|val
operator|-
literal|0x100
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"#%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'T'
case|:
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"#%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
operator|+
literal|010
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|regno
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>
literal|7
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s@"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"@(%s)"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%fp%d"
argument_list|,
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|6
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|0x20
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|val
operator|&
literal|7
index|]
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s@+"
argument_list|,
name|reg_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
operator|+
literal|8
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s@-"
argument_list|,
name|reg_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
operator|+
literal|8
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
name|place
operator|==
literal|'k'
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"{%s}"
argument_list|,
name|reg_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'C'
condition|)
block|{
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|7
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|63
condition|)
comment|/* This is a signed constant. */
name|val
operator|-=
literal|128
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"{#%d}"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|-
literal|2
return|;
break|break;
case|case
literal|'#'
case|:
case|case
literal|'^'
case|:
name|p1
operator|=
name|buffer
operator|+
operator|(
operator|*
name|d
operator|==
literal|'#'
condition|?
literal|2
else|:
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|place
operator|==
literal|'s'
condition|)
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'C'
condition|)
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|7
argument_list|,
name|info
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'8'
condition|)
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'3'
condition|)
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|8
argument_list|,
name|info
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'b'
condition|)
name|val
operator|=
name|NEXTBYTE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'w'
operator|||
name|place
operator|==
literal|'W'
condition|)
name|val
operator|=
name|NEXTWORD
argument_list|(
name|p1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'l'
condition|)
name|val
operator|=
name|NEXTLONG
argument_list|(
name|p1
argument_list|)
expr_stmt|;
else|else
return|return
operator|-
literal|2
return|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"#%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
if|if
condition|(
name|place
operator|==
literal|'b'
condition|)
name|disp
operator|=
name|NEXTBYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'B'
condition|)
name|disp
operator|=
name|COERCE_SIGNED_CHAR
argument_list|(
name|buffer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'w'
operator|||
name|place
operator|==
literal|'W'
condition|)
name|disp
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'l'
operator|||
name|place
operator|==
literal|'L'
operator|||
name|place
operator|==
literal|'C'
condition|)
name|disp
operator|=
name|NEXTLONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|place
operator|==
literal|'g'
condition|)
block|{
name|disp
operator|=
name|NEXTBYTE
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
operator|==
literal|0
condition|)
name|disp
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|disp
operator|==
operator|-
literal|1
condition|)
name|disp
operator|=
name|NEXTLONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|place
operator|==
literal|'c'
condition|)
block|{
if|if
condition|(
name|buffer
index|[
literal|1
index|]
operator|&
literal|0x40
condition|)
comment|/* If bit six is one, long offset */
name|disp
operator|=
name|NEXTLONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|disp
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|-
literal|2
return|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|addr
operator|+
name|disp
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|val
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s@(%d)"
argument_list|,
name|reg_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
operator|+
literal|8
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|fpcr_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* Get coprocessor ID... */
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
literal|'d'
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|1
condition|)
comment|/* Unusual coprocessor ID? */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"(cpid=%d) "
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
case|case
literal|'~'
case|:
case|case
literal|'%'
case|:
case|case
literal|';'
case|:
case|case
literal|'@'
case|:
case|case
literal|'!'
case|:
case|case
literal|'$'
case|:
case|case
literal|'?'
case|:
case|case
literal|'/'
case|:
case|case
literal|'&'
case|:
case|case
literal|'|'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'v'
case|:
case|case
literal|'b'
case|:
case|case
literal|'w'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
if|if
condition|(
name|place
operator|==
literal|'d'
condition|)
block|{
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
literal|'x'
argument_list|,
literal|6
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|&
literal|7
operator|)
operator|<<
literal|3
operator|)
operator|+
operator|(
operator|(
name|val
operator|>>
literal|3
operator|)
operator|&
literal|7
operator|)
expr_stmt|;
block|}
else|else
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
literal|'s'
argument_list|,
literal|6
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* Get register number assuming address register.  */
name|regno
operator|=
operator|(
name|val
operator|&
literal|7
operator|)
operator|+
literal|8
expr_stmt|;
name|regname
operator|=
name|reg_names
index|[
name|regno
index|]
expr_stmt|;
switch|switch
condition|(
name|val
operator|>>
literal|3
condition|)
block|{
case|case
literal|0
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|val
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|regname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s@"
argument_list|,
name|regname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s@+"
argument_list|,
name|regname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s@-"
argument_list|,
name|regname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|val
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s@(%d)"
argument_list|,
name|regname
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|p
operator|=
name|print_indexed
argument_list|(
name|regno
argument_list|,
name|p
argument_list|,
name|addr
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
switch|switch
condition|(
name|val
operator|&
literal|7
condition|)
block|{
case|case
literal|0
case|:
name|val
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|val
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|uval
operator|=
name|NEXTULONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|uval
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|val
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%pc@("
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|addr
operator|+
name|val
argument_list|,
name|info
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|p
operator|=
name|print_indexed
argument_list|(
operator|-
literal|1
argument_list|,
name|p
argument_list|,
name|addr
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|flt_p
operator|=
literal|1
expr_stmt|;
comment|/* Assume it's a float... */
switch|switch
condition|(
name|place
condition|)
block|{
case|case
literal|'b'
case|:
name|val
operator|=
name|NEXTBYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|flt_p
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|val
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|flt_p
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|val
operator|=
name|NEXTLONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|flt_p
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|NEXTSINGLE
argument_list|(
name|flval
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|NEXTDOUBLE
argument_list|(
name|flval
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|NEXTEXTEND
argument_list|(
name|flval
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|flval
operator|=
name|NEXTPACKED
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|flt_p
condition|)
comment|/* Print a float? */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"#%g"
argument_list|,
name|flval
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"#%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
break|break;
case|case
literal|'L'
case|:
case|case
literal|'l'
case|:
if|if
condition|(
name|place
operator|==
literal|'w'
condition|)
block|{
name|char
name|doneany
decl_stmt|;
name|p1
operator|=
name|buffer
operator|+
literal|2
expr_stmt|;
name|val
operator|=
name|NEXTWORD
argument_list|(
name|p1
argument_list|)
expr_stmt|;
comment|/* Move the pointer ahead if this point is farther ahead 	       than the last.  */
name|p
operator|=
name|p1
operator|>
name|p
condition|?
name|p1
else|:
name|p
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"#0"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|d
operator|==
literal|'l'
condition|)
block|{
specifier|register
name|int
name|newval
init|=
literal|0
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|16
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|val
operator|&
operator|(
literal|0x8000
operator|>>
name|regno
operator|)
condition|)
name|newval
operator||=
literal|1
operator|<<
name|regno
expr_stmt|;
name|val
operator|=
name|newval
expr_stmt|;
block|}
name|val
operator|&=
literal|0xffff
expr_stmt|;
name|doneany
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|16
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
name|regno
operator|)
condition|)
block|{
name|int
name|first_regno
decl_stmt|;
if|if
condition|(
name|doneany
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|doneany
operator|=
literal|1
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|first_regno
operator|=
name|regno
expr_stmt|;
while|while
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
operator|(
name|regno
operator|+
literal|1
operator|)
operator|)
condition|)
operator|++
name|regno
expr_stmt|;
if|if
condition|(
name|regno
operator|>
name|first_regno
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"-%s"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|place
operator|==
literal|'3'
condition|)
block|{
comment|/* `fmovem' insn.  */
name|char
name|doneany
decl_stmt|;
name|val
operator|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|8
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"#0"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|d
operator|==
literal|'l'
condition|)
block|{
specifier|register
name|int
name|newval
init|=
literal|0
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|8
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|val
operator|&
operator|(
literal|0x80
operator|>>
name|regno
operator|)
condition|)
name|newval
operator||=
literal|1
operator|<<
name|regno
expr_stmt|;
name|val
operator|=
name|newval
expr_stmt|;
block|}
name|val
operator|&=
literal|0xff
expr_stmt|;
name|doneany
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|8
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
name|regno
operator|)
condition|)
block|{
name|int
name|first_regno
decl_stmt|;
if|if
condition|(
name|doneany
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|doneany
operator|=
literal|1
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%fp%d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|first_regno
operator|=
name|regno
expr_stmt|;
while|while
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
operator|(
name|regno
operator|+
literal|1
operator|)
operator|)
condition|)
operator|++
name|regno
expr_stmt|;
if|if
condition|(
name|regno
operator|>
name|first_regno
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"-%%fp%d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|place
operator|==
literal|'8'
condition|)
block|{
comment|/* fmoveml for FP status registers */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|fpcr_names
index|[
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|-
literal|2
return|;
break|break;
case|case
literal|'X'
case|:
name|place
operator|=
literal|'8'
expr_stmt|;
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'W'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
block|{
name|int
name|val
init|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|5
argument_list|,
name|info
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
literal|2
case|:
name|name
operator|=
literal|"%tt0"
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|name
operator|=
literal|"%tt1"
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
name|name
operator|=
literal|"%tc"
expr_stmt|;
break|break;
case|case
literal|0x11
case|:
name|name
operator|=
literal|"%drp"
expr_stmt|;
break|break;
case|case
literal|0x12
case|:
name|name
operator|=
literal|"%srp"
expr_stmt|;
break|break;
case|case
literal|0x13
case|:
name|name
operator|=
literal|"%crp"
expr_stmt|;
break|break;
case|case
literal|0x14
case|:
name|name
operator|=
literal|"%cal"
expr_stmt|;
break|break;
case|case
literal|0x15
case|:
name|name
operator|=
literal|"%val"
expr_stmt|;
break|break;
case|case
literal|0x16
case|:
name|name
operator|=
literal|"%scc"
expr_stmt|;
break|break;
case|case
literal|0x17
case|:
name|name
operator|=
literal|"%ac"
expr_stmt|;
break|break;
case|case
literal|0x18
case|:
name|name
operator|=
literal|"%psr"
expr_stmt|;
break|break;
case|case
literal|0x19
case|:
name|name
operator|=
literal|"%pcsr"
expr_stmt|;
break|break;
case|case
literal|0x1c
case|:
case|case
literal|0x1d
case|:
block|{
name|int
name|break_reg
init|=
operator|(
operator|(
name|buffer
index|[
literal|3
index|]
operator|>>
literal|2
operator|)
operator|&
literal|7
operator|)
decl_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
name|val
operator|==
literal|0x1c
condition|?
literal|"%%bad%d"
else|:
literal|"%%bac%d"
argument_list|,
name|break_reg
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"<mmu register %d>"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
block|{
name|int
name|fc
init|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|5
argument_list|,
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|fc
operator|==
literal|1
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%dfc"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fc
operator|==
literal|0
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%sfc"
argument_list|)
expr_stmt|;
else|else
comment|/* xgettext:c-format */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
name|_
argument_list|(
literal|"<function code %d>"
argument_list|)
argument_list|,
name|fc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'V'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%val"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
block|{
name|int
name|level
init|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|3
argument_list|,
name|info
argument_list|)
decl_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'u'
case|:
block|{
name|short
name|is_upper
init|=
literal|0
decl_stmt|;
name|int
name|reg
init|=
name|fetch_arg
argument_list|(
name|buffer
argument_list|,
name|place
argument_list|,
literal|5
argument_list|,
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|&
literal|0x10
condition|)
block|{
name|is_upper
operator|=
literal|1
expr_stmt|;
name|reg
operator|&=
literal|0xf
expr_stmt|;
block|}
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s%s"
argument_list|,
name|reg_names
index|[
name|reg
index|]
argument_list|,
name|is_upper
condition|?
literal|"u"
else|:
literal|"l"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
return|return
operator|-
literal|2
return|;
block|}
return|return
name|p
operator|-
name|p0
return|;
block|}
end_function

begin_comment
comment|/* Fetch BITS bits from a position in the instruction specified by CODE.    CODE is a "place to put an argument", or 'x' for a destination    that is a general address (mode and register).    BUFFER contains the instruction.  */
end_comment

begin_function
specifier|static
name|int
name|fetch_arg
parameter_list|(
name|buffer
parameter_list|,
name|code
parameter_list|,
name|bits
parameter_list|,
name|info
parameter_list|)
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|code
decl_stmt|;
name|int
name|bits
decl_stmt|;
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
specifier|register
name|int
name|val
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'s'
case|:
name|val
operator|=
name|buffer
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* Destination, for register or quick.  */
name|val
operator|=
operator|(
name|buffer
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|1
index|]
expr_stmt|;
name|val
operator|>>=
literal|9
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* Destination, for general arg */
name|val
operator|=
operator|(
name|buffer
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|1
index|]
expr_stmt|;
name|val
operator|>>=
literal|6
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|3
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|buffer
index|[
literal|3
index|]
operator|>>
literal|4
operator|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|3
argument_list|)
expr_stmt|;
name|val
operator|=
name|buffer
index|[
literal|3
index|]
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|3
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|buffer
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|3
index|]
expr_stmt|;
name|val
operator|>>=
literal|12
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|3
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|buffer
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|3
index|]
expr_stmt|;
name|val
operator|>>=
literal|6
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
case|case
literal|'j'
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|3
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|buffer
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|3
index|]
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|5
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|buffer
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|5
index|]
expr_stmt|;
name|val
operator|>>=
literal|12
expr_stmt|;
break|break;
case|case
literal|'5'
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|5
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|buffer
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|5
index|]
expr_stmt|;
name|val
operator|>>=
literal|6
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|5
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|buffer
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|5
index|]
expr_stmt|;
break|break;
case|case
literal|'7'
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|3
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|buffer
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|3
index|]
expr_stmt|;
name|val
operator|>>=
literal|7
expr_stmt|;
break|break;
case|case
literal|'8'
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|3
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|buffer
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|3
index|]
expr_stmt|;
name|val
operator|>>=
literal|10
expr_stmt|;
break|break;
case|case
literal|'9'
case|:
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|3
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|buffer
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|3
index|]
expr_stmt|;
name|val
operator|>>=
literal|5
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|val
operator|=
operator|(
name|buffer
index|[
literal|1
index|]
operator|>>
literal|6
operator|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|val
operator|=
operator|(
name|buffer
index|[
literal|1
index|]
operator|&
literal|0x40
condition|?
literal|0x8
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|buffer
index|[
literal|0
index|]
operator|>>
literal|1
operator|)
operator|&
literal|0x7
operator|)
operator||
operator|(
name|buffer
index|[
literal|3
index|]
operator|&
literal|0x80
condition|?
literal|0x10
else|:
literal|0
operator|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|val
operator|=
operator|(
name|buffer
index|[
literal|1
index|]
operator|&
literal|0x40
condition|?
literal|0x8
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|buffer
index|[
literal|0
index|]
operator|>>
literal|1
operator|)
operator|&
literal|0x7
operator|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|val
operator|=
operator|(
name|buffer
index|[
literal|2
index|]
operator|>>
literal|4
operator|)
operator||
operator|(
name|buffer
index|[
literal|3
index|]
operator|&
literal|0x80
condition|?
literal|0x10
else|:
literal|0
operator|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|val
operator|=
name|buffer
index|[
literal|1
index|]
operator||
operator|(
name|buffer
index|[
literal|3
index|]
operator|&
literal|0x40
condition|?
literal|0x10
else|:
literal|0
operator|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|val
operator|=
name|buffer
index|[
literal|3
index|]
operator||
operator|(
name|buffer
index|[
literal|3
index|]
operator|&
literal|0x40
condition|?
literal|0x10
else|:
literal|0
operator|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|val
operator|=
name|buffer
index|[
literal|2
index|]
operator|>>
literal|2
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|bits
condition|)
block|{
case|case
literal|1
case|:
return|return
name|val
operator|&
literal|1
return|;
case|case
literal|2
case|:
return|return
name|val
operator|&
literal|3
return|;
case|case
literal|3
case|:
return|return
name|val
operator|&
literal|7
return|;
case|case
literal|4
case|:
return|return
name|val
operator|&
literal|017
return|;
case|case
literal|5
case|:
return|return
name|val
operator|&
literal|037
return|;
case|case
literal|6
case|:
return|return
name|val
operator|&
literal|077
return|;
case|case
literal|7
case|:
return|return
name|val
operator|&
literal|0177
return|;
case|case
literal|8
case|:
return|return
name|val
operator|&
literal|0377
return|;
case|case
literal|12
case|:
return|return
name|val
operator|&
literal|07777
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print an indexed argument.  The base register is BASEREG (-1 for pc).    P points to extension word, in buffer.    ADDR is the nominal core address of that extension word.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|print_indexed
parameter_list|(
name|basereg
parameter_list|,
name|p
parameter_list|,
name|addr
parameter_list|,
name|info
parameter_list|)
name|int
name|basereg
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
specifier|register
name|int
name|word
decl_stmt|;
specifier|static
name|char
modifier|*
specifier|const
name|scales
index|[]
init|=
block|{
literal|""
block|,
literal|":2"
block|,
literal|":4"
block|,
literal|":8"
block|}
decl_stmt|;
name|bfd_vma
name|base_disp
decl_stmt|;
name|bfd_vma
name|outer_disp
decl_stmt|;
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|char
name|vmabuf
index|[
literal|50
index|]
decl_stmt|;
name|word
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Generate the text for the index register.      Where this will be output is not yet determined.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s:%c%s"
argument_list|,
name|reg_names
index|[
operator|(
name|word
operator|>>
literal|12
operator|)
operator|&
literal|0xf
index|]
argument_list|,
operator|(
name|word
operator|&
literal|0x800
operator|)
condition|?
literal|'l'
else|:
literal|'w'
argument_list|,
name|scales
index|[
operator|(
name|word
operator|>>
literal|9
operator|)
operator|&
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* Handle the 68000 style of indexing.  */
if|if
condition|(
operator|(
name|word
operator|&
literal|0x100
operator|)
operator|==
literal|0
condition|)
block|{
name|base_disp
operator|=
name|word
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
name|base_disp
operator|&
literal|0x80
operator|)
operator|!=
literal|0
condition|)
name|base_disp
operator|-=
literal|0x100
expr_stmt|;
if|if
condition|(
name|basereg
operator|==
operator|-
literal|1
condition|)
name|base_disp
operator|+=
name|addr
expr_stmt|;
name|print_base
argument_list|(
name|basereg
argument_list|,
name|base_disp
argument_list|,
name|info
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|",%s)"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
comment|/* Handle the generalized kind.  */
comment|/* First, compute the displacement to add to the base register.  */
if|if
condition|(
name|word
operator|&
literal|0200
condition|)
block|{
if|if
condition|(
name|basereg
operator|==
operator|-
literal|1
condition|)
name|basereg
operator|=
operator|-
literal|3
expr_stmt|;
else|else
name|basereg
operator|=
operator|-
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|word
operator|&
literal|0100
condition|)
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|base_disp
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|(
name|word
operator|>>
literal|4
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|2
case|:
name|base_disp
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|base_disp
operator|=
name|NEXTLONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|basereg
operator|==
operator|-
literal|1
condition|)
name|base_disp
operator|+=
name|addr
expr_stmt|;
comment|/* Handle single-level case (not indirect) */
if|if
condition|(
operator|(
name|word
operator|&
literal|7
operator|)
operator|==
literal|0
condition|)
block|{
name|print_base
argument_list|(
name|basereg
argument_list|,
name|base_disp
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|",%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
comment|/* Two level.  Compute displacement to add after indirection.  */
name|outer_disp
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|word
operator|&
literal|3
condition|)
block|{
case|case
literal|2
case|:
name|outer_disp
operator|=
name|NEXTWORD
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|outer_disp
operator|=
name|NEXTLONG
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|print_base
argument_list|(
name|basereg
argument_list|,
name|base_disp
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|word
operator|&
literal|4
operator|)
operator|==
literal|0
operator|&&
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|",%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|sprintf_vma
argument_list|(
name|vmabuf
argument_list|,
name|outer_disp
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|")@(%s"
argument_list|,
name|vmabuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|",%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Print a base register REGNO and displacement DISP, on INFO->STREAM.    REGNO = -1 for pc, -2 for none (suppressed).  */
end_comment

begin_function
specifier|static
name|void
name|print_base
parameter_list|(
name|regno
parameter_list|,
name|disp
parameter_list|,
name|info
parameter_list|)
name|int
name|regno
decl_stmt|;
name|bfd_vma
name|disp
decl_stmt|;
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%pc@("
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|disp
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
if|if
condition|(
name|regno
operator|==
operator|-
literal|2
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"@("
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
operator|-
literal|3
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%%zpc@("
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s@("
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|sprintf_vma
argument_list|(
name|buf
argument_list|,
name|disp
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

