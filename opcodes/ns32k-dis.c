begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print National Semiconductor 32000 instructions.    Copyright 1986, 1988, 1991, 1992, 1994, 1998, 2001, 2002    Free Software Foundation, Inc.  This file is part of opcodes library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
specifier|const
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|const
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"opcode/ns32k.h"
end_include

begin_include
include|#
directive|include
file|"opintl.h"
end_include

begin_decl_stmt
specifier|static
name|disassemble_info
modifier|*
name|dis_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Hacks to get it to compile<= READ THESE AS FIXES NEEDED  */
end_comment

begin_define
define|#
directive|define
name|INVALID_FLOAT
parameter_list|(
name|val
parameter_list|,
name|size
parameter_list|)
value|invalid_float((char *)val, size)
end_define

begin_decl_stmt
specifier|static
name|int
name|print_insn_arg
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|,
name|char
operator|*
operator|,
name|bfd_vma
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_displacement
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|invalid_float
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|int
name|read_memory_integer
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fetch_data
name|PARAMS
argument_list|(
operator|(
expr|struct
name|disassemble_info
operator|*
operator|,
name|bfd_byte
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|ns32k_option
struct_decl|;
end_struct_decl

begin_decl_stmt
specifier|static
name|void
name|optlist
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
specifier|const
expr|struct
name|ns32k_option
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|list_search
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
specifier|const
expr|struct
name|ns32k_option
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bit_extract
name|PARAMS
argument_list|(
operator|(
name|bfd_byte
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bit_extract_simple
name|PARAMS
argument_list|(
operator|(
name|bfd_byte
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bit_copy
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sign_extend
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|flip_bytes
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|long
name|read_memory_integer
parameter_list|(
name|addr
parameter_list|,
name|nr
parameter_list|)
name|unsigned
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|nr
decl_stmt|;
block|{
name|long
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|val
operator|=
literal|0
operator|,
name|i
operator|=
name|nr
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|val
operator|=
operator|(
name|val
operator|<<
literal|8
operator|)
expr_stmt|;
name|val
operator||=
operator|(
literal|0xff
operator|&
operator|*
operator|(
name|addr
operator|+
name|i
operator|)
operator|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* 32000 instructions are never longer than this.  */
end_comment

begin_define
define|#
directive|define
name|MAXLEN
value|62
end_define

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_struct
struct|struct
name|private
block|{
comment|/* Points to first byte not fetched.  */
name|bfd_byte
modifier|*
name|max_fetched
decl_stmt|;
name|bfd_byte
name|the_buffer
index|[
name|MAXLEN
index|]
decl_stmt|;
name|bfd_vma
name|insn_start
decl_stmt|;
name|jmp_buf
name|bailout
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Make sure that bytes from INFO->PRIVATE_DATA->BUFFER (inclusive)    to ADDR (exclusive) are valid.  Returns 1 for success, longjmps    on error.  */
end_comment

begin_define
define|#
directive|define
name|FETCH_DATA
parameter_list|(
name|info
parameter_list|,
name|addr
parameter_list|)
define|\
value|((addr)<= ((struct private *)(info->private_data))->max_fetched \    ? 1 : fetch_data ((info), (addr)))
end_define

begin_function
specifier|static
name|int
name|fetch_data
parameter_list|(
name|info
parameter_list|,
name|addr
parameter_list|)
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|struct
name|private
modifier|*
name|priv
init|=
operator|(
expr|struct
name|private
operator|*
operator|)
name|info
operator|->
name|private_data
decl_stmt|;
name|bfd_vma
name|start
init|=
name|priv
operator|->
name|insn_start
operator|+
operator|(
name|priv
operator|->
name|max_fetched
operator|-
name|priv
operator|->
name|the_buffer
operator|)
decl_stmt|;
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|start
argument_list|,
name|priv
operator|->
name|max_fetched
argument_list|,
name|addr
operator|-
name|priv
operator|->
name|max_fetched
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|memory_error_func
call|)
argument_list|(
name|status
argument_list|,
name|start
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|priv
operator|->
name|bailout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|priv
operator|->
name|max_fetched
operator|=
name|addr
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Number of elements in the opcode table.  */
end_comment

begin_define
define|#
directive|define
name|NOPCODES
value|(sizeof ns32k_opcodes / sizeof ns32k_opcodes[0])
end_define

begin_define
define|#
directive|define
name|NEXT_IS_ADDR
value|'|'
end_define

begin_escape
end_escape

begin_struct
struct|struct
name|ns32k_option
block|{
name|char
modifier|*
name|pattern
decl_stmt|;
comment|/* the option itself */
name|unsigned
name|long
name|value
decl_stmt|;
comment|/* binary value of the option */
name|unsigned
name|long
name|match
decl_stmt|;
comment|/* these bits must match */
block|}
struct|;
end_struct

begin_escape
end_escape

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ns32k_option
name|opt_u
index|[]
init|=
comment|/* restore, exit */
block|{
block|{
literal|"r0"
block|,
literal|0x80
block|,
literal|0x80
block|}
block|,
block|{
literal|"r1"
block|,
literal|0x40
block|,
literal|0x40
block|}
block|,
block|{
literal|"r2"
block|,
literal|0x20
block|,
literal|0x20
block|}
block|,
block|{
literal|"r3"
block|,
literal|0x10
block|,
literal|0x10
block|}
block|,
block|{
literal|"r4"
block|,
literal|0x08
block|,
literal|0x08
block|}
block|,
block|{
literal|"r5"
block|,
literal|0x04
block|,
literal|0x04
block|}
block|,
block|{
literal|"r6"
block|,
literal|0x02
block|,
literal|0x02
block|}
block|,
block|{
literal|"r7"
block|,
literal|0x01
block|,
literal|0x01
block|}
block|,
block|{
literal|0
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ns32k_option
name|opt_U
index|[]
init|=
comment|/* save, enter */
block|{
block|{
literal|"r0"
block|,
literal|0x01
block|,
literal|0x01
block|}
block|,
block|{
literal|"r1"
block|,
literal|0x02
block|,
literal|0x02
block|}
block|,
block|{
literal|"r2"
block|,
literal|0x04
block|,
literal|0x04
block|}
block|,
block|{
literal|"r3"
block|,
literal|0x08
block|,
literal|0x08
block|}
block|,
block|{
literal|"r4"
block|,
literal|0x10
block|,
literal|0x10
block|}
block|,
block|{
literal|"r5"
block|,
literal|0x20
block|,
literal|0x20
block|}
block|,
block|{
literal|"r6"
block|,
literal|0x40
block|,
literal|0x40
block|}
block|,
block|{
literal|"r7"
block|,
literal|0x80
block|,
literal|0x80
block|}
block|,
block|{
literal|0
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ns32k_option
name|opt_O
index|[]
init|=
comment|/* setcfg */
block|{
block|{
literal|"c"
block|,
literal|0x8
block|,
literal|0x8
block|}
block|,
block|{
literal|"m"
block|,
literal|0x4
block|,
literal|0x4
block|}
block|,
block|{
literal|"f"
block|,
literal|0x2
block|,
literal|0x2
block|}
block|,
block|{
literal|"i"
block|,
literal|0x1
block|,
literal|0x1
block|}
block|,
block|{
literal|0
block|,
literal|0x0
block|,
literal|0x0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ns32k_option
name|opt_C
index|[]
init|=
comment|/* cinv */
block|{
block|{
literal|"a"
block|,
literal|0x4
block|,
literal|0x4
block|}
block|,
block|{
literal|"i"
block|,
literal|0x2
block|,
literal|0x2
block|}
block|,
block|{
literal|"d"
block|,
literal|0x1
block|,
literal|0x1
block|}
block|,
block|{
literal|0
block|,
literal|0x0
block|,
literal|0x0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ns32k_option
name|opt_S
index|[]
init|=
comment|/* string inst */
block|{
block|{
literal|"b"
block|,
literal|0x1
block|,
literal|0x1
block|}
block|,
block|{
literal|"u"
block|,
literal|0x6
block|,
literal|0x6
block|}
block|,
block|{
literal|"w"
block|,
literal|0x2
block|,
literal|0x2
block|}
block|,
block|{
literal|0
block|,
literal|0x0
block|,
literal|0x0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ns32k_option
name|list_P532
index|[]
init|=
comment|/* lpr spr */
block|{
block|{
literal|"us"
block|,
literal|0x0
block|,
literal|0xf
block|}
block|,
block|{
literal|"dcr"
block|,
literal|0x1
block|,
literal|0xf
block|}
block|,
block|{
literal|"bpc"
block|,
literal|0x2
block|,
literal|0xf
block|}
block|,
block|{
literal|"dsr"
block|,
literal|0x3
block|,
literal|0xf
block|}
block|,
block|{
literal|"car"
block|,
literal|0x4
block|,
literal|0xf
block|}
block|,
block|{
literal|"fp"
block|,
literal|0x8
block|,
literal|0xf
block|}
block|,
block|{
literal|"sp"
block|,
literal|0x9
block|,
literal|0xf
block|}
block|,
block|{
literal|"sb"
block|,
literal|0xa
block|,
literal|0xf
block|}
block|,
block|{
literal|"usp"
block|,
literal|0xb
block|,
literal|0xf
block|}
block|,
block|{
literal|"cfg"
block|,
literal|0xc
block|,
literal|0xf
block|}
block|,
block|{
literal|"psr"
block|,
literal|0xd
block|,
literal|0xf
block|}
block|,
block|{
literal|"intbase"
block|,
literal|0xe
block|,
literal|0xf
block|}
block|,
block|{
literal|"mod"
block|,
literal|0xf
block|,
literal|0xf
block|}
block|,
block|{
literal|0
block|,
literal|0x00
block|,
literal|0xf
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ns32k_option
name|list_M532
index|[]
init|=
comment|/* lmr smr */
block|{
block|{
literal|"mcr"
block|,
literal|0x9
block|,
literal|0xf
block|}
block|,
block|{
literal|"msr"
block|,
literal|0xa
block|,
literal|0xf
block|}
block|,
block|{
literal|"tear"
block|,
literal|0xb
block|,
literal|0xf
block|}
block|,
block|{
literal|"ptb0"
block|,
literal|0xc
block|,
literal|0xf
block|}
block|,
block|{
literal|"ptb1"
block|,
literal|0xd
block|,
literal|0xf
block|}
block|,
block|{
literal|"ivar0"
block|,
literal|0xe
block|,
literal|0xf
block|}
block|,
block|{
literal|"ivar1"
block|,
literal|0xf
block|,
literal|0xf
block|}
block|,
block|{
literal|0
block|,
literal|0x0
block|,
literal|0xf
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ns32k_option
name|list_P032
index|[]
init|=
comment|/* lpr spr */
block|{
block|{
literal|"upsr"
block|,
literal|0x0
block|,
literal|0xf
block|}
block|,
block|{
literal|"fp"
block|,
literal|0x8
block|,
literal|0xf
block|}
block|,
block|{
literal|"sp"
block|,
literal|0x9
block|,
literal|0xf
block|}
block|,
block|{
literal|"sb"
block|,
literal|0xa
block|,
literal|0xf
block|}
block|,
block|{
literal|"psr"
block|,
literal|0xb
block|,
literal|0xf
block|}
block|,
block|{
literal|"intbase"
block|,
literal|0xe
block|,
literal|0xf
block|}
block|,
block|{
literal|"mod"
block|,
literal|0xf
block|,
literal|0xf
block|}
block|,
block|{
literal|0
block|,
literal|0x0
block|,
literal|0xf
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ns32k_option
name|list_M032
index|[]
init|=
comment|/* lmr smr */
block|{
block|{
literal|"bpr0"
block|,
literal|0x0
block|,
literal|0xf
block|}
block|,
block|{
literal|"bpr1"
block|,
literal|0x1
block|,
literal|0xf
block|}
block|,
block|{
literal|"pf0"
block|,
literal|0x4
block|,
literal|0xf
block|}
block|,
block|{
literal|"pf1"
block|,
literal|0x5
block|,
literal|0xf
block|}
block|,
block|{
literal|"sc"
block|,
literal|0x8
block|,
literal|0xf
block|}
block|,
block|{
literal|"msr"
block|,
literal|0xa
block|,
literal|0xf
block|}
block|,
block|{
literal|"bcnt"
block|,
literal|0xb
block|,
literal|0xf
block|}
block|,
block|{
literal|"ptb0"
block|,
literal|0xc
block|,
literal|0xf
block|}
block|,
block|{
literal|"ptb1"
block|,
literal|0xd
block|,
literal|0xf
block|}
block|,
block|{
literal|"eia"
block|,
literal|0xf
block|,
literal|0xf
block|}
block|,
block|{
literal|0
block|,
literal|0x0
block|,
literal|0xf
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * figure out which options are present  */
end_comment

begin_function
specifier|static
name|void
name|optlist
parameter_list|(
name|options
parameter_list|,
name|optionP
parameter_list|,
name|result
parameter_list|)
name|int
name|options
decl_stmt|;
specifier|const
name|struct
name|ns32k_option
modifier|*
name|optionP
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
block|{
if|if
condition|(
name|options
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"[]"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|options
operator|!=
literal|0
operator|)
operator|&&
name|optionP
operator|->
name|pattern
condition|;
name|optionP
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|options
operator|&
name|optionP
operator|->
name|match
operator|)
operator|==
name|optionP
operator|->
name|value
condition|)
block|{
comment|/* we found a match, update result and options */
name|strcat
argument_list|(
name|result
argument_list|,
name|optionP
operator|->
name|pattern
argument_list|)
expr_stmt|;
name|options
operator|&=
operator|~
name|optionP
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|options
operator|!=
literal|0
condition|)
comment|/* more options to come */
name|strcat
argument_list|(
name|result
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|options
operator|!=
literal|0
condition|)
name|strcat
argument_list|(
name|result
argument_list|,
literal|"undefined"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|result
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|list_search
parameter_list|(
name|reg_value
parameter_list|,
name|optionP
parameter_list|,
name|result
parameter_list|)
name|int
name|reg_value
decl_stmt|;
specifier|const
name|struct
name|ns32k_option
modifier|*
name|optionP
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
block|{
for|for
control|(
init|;
name|optionP
operator|->
name|pattern
condition|;
name|optionP
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|reg_value
operator|&
name|optionP
operator|->
name|match
operator|)
operator|==
name|optionP
operator|->
name|value
condition|)
block|{
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"%s"
argument_list|,
name|optionP
operator|->
name|pattern
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"undefined"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * extract "count" bits starting "offset" bits  * into buffer  */
end_comment

begin_function
specifier|static
name|int
name|bit_extract
parameter_list|(
name|buffer
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd_byte
modifier|*
name|buffer
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|int
name|bit
decl_stmt|;
name|buffer
operator|+=
name|offset
operator|>>
literal|3
expr_stmt|;
name|offset
operator|&=
literal|7
expr_stmt|;
name|bit
operator|=
literal|1
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|FETCH_DATA
argument_list|(
name|dis_info
argument_list|,
name|buffer
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|buffer
operator|&
operator|(
literal|1
operator|<<
name|offset
operator|)
operator|)
condition|)
name|result
operator||=
name|bit
expr_stmt|;
if|if
condition|(
operator|++
name|offset
operator|==
literal|8
condition|)
block|{
name|offset
operator|=
literal|0
expr_stmt|;
name|buffer
operator|++
expr_stmt|;
block|}
name|bit
operator|<<=
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Like bit extract but the buffer is valid and doen't need to be  * fetched  */
end_comment

begin_function
specifier|static
name|int
name|bit_extract_simple
parameter_list|(
name|buffer
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd_byte
modifier|*
name|buffer
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|int
name|bit
decl_stmt|;
name|buffer
operator|+=
name|offset
operator|>>
literal|3
expr_stmt|;
name|offset
operator|&=
literal|7
expr_stmt|;
name|bit
operator|=
literal|1
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|buffer
operator|&
operator|(
literal|1
operator|<<
name|offset
operator|)
operator|)
condition|)
name|result
operator||=
name|bit
expr_stmt|;
if|if
condition|(
operator|++
name|offset
operator|==
literal|8
condition|)
block|{
name|offset
operator|=
literal|0
expr_stmt|;
name|buffer
operator|++
expr_stmt|;
block|}
name|bit
operator|<<=
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bit_copy
parameter_list|(
name|buffer
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|,
name|to
parameter_list|)
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
block|{
for|for
control|(
init|;
name|count
operator|>
literal|8
condition|;
name|count
operator|-=
literal|8
operator|,
name|to
operator|++
operator|,
name|offset
operator|+=
literal|8
control|)
operator|*
name|to
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
literal|8
argument_list|)
expr_stmt|;
operator|*
name|to
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sign_extend
parameter_list|(
name|value
parameter_list|,
name|bits
parameter_list|)
name|int
name|value
decl_stmt|,
name|bits
decl_stmt|;
block|{
name|value
operator|=
name|value
operator|&
operator|(
operator|(
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|value
operator|&
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
condition|?
name|value
operator||
operator|(
operator|~
operator|(
operator|(
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
else|:
name|value
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|flip_bytes
parameter_list|(
name|ptr
parameter_list|,
name|count
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|char
name|tmp
decl_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|tmp
operator|=
name|ptr
index|[
literal|0
index|]
expr_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
name|ptr
index|[
name|count
operator|-
literal|1
index|]
expr_stmt|;
name|ptr
index|[
name|count
operator|-
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
name|count
operator|-=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a character C, does it represent a general addressing mode?  */
end_comment

begin_define
define|#
directive|define
name|Is_gen
parameter_list|(
name|c
parameter_list|)
define|\
value|((c) == 'F' || (c) == 'L' || (c) == 'B' \    || (c) == 'W' || (c) == 'D' || (c) == 'A' || (c) == 'I' || (c) == 'Z')
end_define

begin_comment
comment|/* Adressing modes.  */
end_comment

begin_define
define|#
directive|define
name|Adrmod_index_byte
value|0x1c
end_define

begin_define
define|#
directive|define
name|Adrmod_index_word
value|0x1d
end_define

begin_define
define|#
directive|define
name|Adrmod_index_doubleword
value|0x1e
end_define

begin_define
define|#
directive|define
name|Adrmod_index_quadword
value|0x1f
end_define

begin_comment
comment|/* Is MODE an indexed addressing mode?  */
end_comment

begin_define
define|#
directive|define
name|Adrmod_is_index
parameter_list|(
name|mode
parameter_list|)
define|\
value|(mode == Adrmod_index_byte \    || mode == Adrmod_index_word \    || mode == Adrmod_index_doubleword \    || mode == Adrmod_index_quadword)
end_define

begin_escape
end_escape

begin_comment
comment|/* Print the 32000 instruction at address MEMADDR in debugged memory,    on STREAM.  Returns length of the instruction, in bytes.  */
end_comment

begin_function
name|int
name|print_insn_ns32k
parameter_list|(
name|memaddr
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|memaddr
decl_stmt|;
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|d
decl_stmt|;
name|unsigned
name|short
name|first_word
decl_stmt|;
name|int
name|ioffset
decl_stmt|;
comment|/* bits into instruction */
name|int
name|aoffset
decl_stmt|;
comment|/* bits into arguments */
name|char
name|arg_bufs
index|[
name|MAX_ARGS
operator|+
literal|1
index|]
index|[
name|ARG_LEN
index|]
decl_stmt|;
name|int
name|argnum
decl_stmt|;
name|int
name|maxarg
decl_stmt|;
name|struct
name|private
name|priv
decl_stmt|;
name|bfd_byte
modifier|*
name|buffer
init|=
name|priv
operator|.
name|the_buffer
decl_stmt|;
name|dis_info
operator|=
name|info
expr_stmt|;
name|info
operator|->
name|private_data
operator|=
operator|(
name|PTR
operator|)
operator|&
name|priv
expr_stmt|;
name|priv
operator|.
name|max_fetched
operator|=
name|priv
operator|.
name|the_buffer
expr_stmt|;
name|priv
operator|.
name|insn_start
operator|=
name|memaddr
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|priv
operator|.
name|bailout
argument_list|)
operator|!=
literal|0
condition|)
comment|/* Error return.  */
return|return
operator|-
literal|1
return|;
comment|/* Look for 8bit opcodes first. Other wise, fetching two bytes could take    * us over the end of accessible data unnecessarilly    */
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOPCODES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ns32k_opcodes
index|[
name|i
index|]
operator|.
name|opcode_id_size
operator|<=
literal|8
operator|&&
operator|(
operator|(
name|buffer
index|[
literal|0
index|]
operator|&
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
name|ns32k_opcodes
index|[
name|i
index|]
operator|.
name|opcode_id_size
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
name|ns32k_opcodes
index|[
name|i
index|]
operator|.
name|opcode_seed
operator|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|NOPCODES
condition|)
block|{
comment|/* Maybe it is 9 to 16 bits big */
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|2
argument_list|)
expr_stmt|;
name|first_word
operator|=
name|read_memory_integer
argument_list|(
name|buffer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOPCODES
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|first_word
operator|&
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
name|ns32k_opcodes
index|[
name|i
index|]
operator|.
name|opcode_id_size
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
name|ns32k_opcodes
index|[
name|i
index|]
operator|.
name|opcode_seed
condition|)
break|break;
comment|/* Handle undefined instructions.  */
if|if
condition|(
name|i
operator|==
name|NOPCODES
condition|)
block|{
call|(
modifier|*
name|dis_info
operator|->
name|fprintf_func
call|)
argument_list|(
name|dis_info
operator|->
name|stream
argument_list|,
literal|"0%o"
argument_list|,
name|buffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
call|(
modifier|*
name|dis_info
operator|->
name|fprintf_func
call|)
argument_list|(
name|dis_info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|ns32k_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|ioffset
operator|=
name|ns32k_opcodes
index|[
name|i
index|]
operator|.
name|opcode_size
expr_stmt|;
name|aoffset
operator|=
name|ns32k_opcodes
index|[
name|i
index|]
operator|.
name|opcode_size
expr_stmt|;
name|d
operator|=
name|ns32k_opcodes
index|[
name|i
index|]
operator|.
name|operands
expr_stmt|;
if|if
condition|(
operator|*
name|d
condition|)
block|{
comment|/* Offset in bits of the first thing beyond each index byte. 	 Element 0 is for operand A and element 1 is for operand B. 	 The rest are irrelevant, but we put them here so we don't 	 index outside the array.  */
name|int
name|index_offset
index|[
name|MAX_ARGS
index|]
decl_stmt|;
comment|/* 0 for operand A, 1 for operand B, greater for other args.  */
name|int
name|whicharg
init|=
literal|0
decl_stmt|;
call|(
modifier|*
name|dis_info
operator|->
name|fprintf_func
call|)
argument_list|(
name|dis_info
operator|->
name|stream
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
name|maxarg
operator|=
literal|0
expr_stmt|;
comment|/* First we have to find and keep track of the index bytes, 	 if we are using scaled indexed addressing mode, since the index 	 bytes occur right after the basic instruction, not as part 	 of the addressing extension.  */
if|if
condition|(
name|Is_gen
argument_list|(
name|d
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|int
name|addr_mode
init|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
name|ioffset
operator|-
literal|5
argument_list|,
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
name|Adrmod_is_index
argument_list|(
name|addr_mode
argument_list|)
condition|)
block|{
name|aoffset
operator|+=
literal|8
expr_stmt|;
name|index_offset
index|[
literal|0
index|]
operator|=
name|aoffset
expr_stmt|;
block|}
block|}
if|if
condition|(
name|d
index|[
literal|2
index|]
operator|&&
name|Is_gen
argument_list|(
name|d
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|int
name|addr_mode
init|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
name|ioffset
operator|-
literal|10
argument_list|,
literal|5
argument_list|)
decl_stmt|;
if|if
condition|(
name|Adrmod_is_index
argument_list|(
name|addr_mode
argument_list|)
condition|)
block|{
name|aoffset
operator|+=
literal|8
expr_stmt|;
name|index_offset
index|[
literal|1
index|]
operator|=
name|aoffset
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|*
name|d
condition|)
block|{
name|argnum
operator|=
operator|*
name|d
operator|-
literal|'1'
expr_stmt|;
name|d
operator|++
expr_stmt|;
if|if
condition|(
name|argnum
operator|>
name|maxarg
operator|&&
name|argnum
operator|<
name|MAX_ARGS
condition|)
name|maxarg
operator|=
name|argnum
expr_stmt|;
name|ioffset
operator|=
name|print_insn_arg
argument_list|(
operator|*
name|d
argument_list|,
name|ioffset
argument_list|,
operator|&
name|aoffset
argument_list|,
name|buffer
argument_list|,
name|memaddr
argument_list|,
name|arg_bufs
index|[
name|argnum
index|]
argument_list|,
name|index_offset
index|[
name|whicharg
index|]
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
name|whicharg
operator|++
expr_stmt|;
block|}
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<=
name|maxarg
condition|;
name|argnum
operator|++
control|)
block|{
name|bfd_vma
name|addr
decl_stmt|;
name|char
modifier|*
name|ch
decl_stmt|;
for|for
control|(
name|ch
operator|=
name|arg_bufs
index|[
name|argnum
index|]
init|;
operator|*
name|ch
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|ch
operator|==
name|NEXT_IS_ADDR
condition|)
block|{
operator|++
name|ch
expr_stmt|;
name|addr
operator|=
name|bfd_scan_vma
argument_list|(
name|ch
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
call|(
modifier|*
name|dis_info
operator|->
name|print_address_func
call|)
argument_list|(
name|addr
argument_list|,
name|dis_info
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|ch
operator|&&
operator|*
name|ch
operator|!=
name|NEXT_IS_ADDR
condition|)
operator|++
name|ch
expr_stmt|;
if|if
condition|(
operator|*
name|ch
condition|)
operator|++
name|ch
expr_stmt|;
block|}
else|else
call|(
modifier|*
name|dis_info
operator|->
name|fprintf_func
call|)
argument_list|(
name|dis_info
operator|->
name|stream
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|ch
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argnum
operator|<
name|maxarg
condition|)
call|(
modifier|*
name|dis_info
operator|->
name|fprintf_func
call|)
argument_list|(
name|dis_info
operator|->
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|aoffset
operator|/
literal|8
return|;
block|}
end_function

begin_comment
comment|/* Print an instruction operand of category given by d.  IOFFSET is    the bit position below which small (<1 byte) parts of the operand can    be found (usually in the basic instruction, but for indexed    addressing it can be in the index byte).  AOFFSETP is a pointer to the    bit position of the addressing extension.  BUFFER contains the    instruction.  ADDR is where BUFFER was read from.  Put the disassembled    version of the operand in RESULT.  INDEX_OFFSET is the bit position    of the index byte (it contains garbage if this operand is not a    general operand using scaled indexed addressing mode).  */
end_comment

begin_function
specifier|static
name|int
name|print_insn_arg
parameter_list|(
name|d
parameter_list|,
name|ioffset
parameter_list|,
name|aoffsetp
parameter_list|,
name|buffer
parameter_list|,
name|addr
parameter_list|,
name|result
parameter_list|,
name|index_offset
parameter_list|)
name|int
name|d
decl_stmt|;
name|int
name|ioffset
decl_stmt|,
decl|*
name|aoffsetp
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_vma
name|addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|result
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|index_offset
decl_stmt|;
end_decl_stmt

begin_block
block|{
union|union
block|{
name|float
name|f
decl_stmt|;
name|double
name|d
decl_stmt|;
name|int
name|i
index|[
literal|2
index|]
decl_stmt|;
block|}
name|value
union|;
name|int
name|Ivalue
decl_stmt|;
name|int
name|addr_mode
decl_stmt|;
name|int
name|disp1
decl_stmt|,
name|disp2
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|size
decl_stmt|;
switch|switch
condition|(
name|d
condition|)
block|{
case|case
literal|'f'
case|:
comment|/* a "gen" operand but 5 bits from the end of instruction */
name|ioffset
operator|-=
literal|5
expr_stmt|;
case|case
literal|'Z'
case|:
case|case
literal|'F'
case|:
case|case
literal|'L'
case|:
case|case
literal|'I'
case|:
case|case
literal|'B'
case|:
case|case
literal|'W'
case|:
case|case
literal|'D'
case|:
case|case
literal|'A'
case|:
name|addr_mode
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
name|ioffset
operator|-
literal|5
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|ioffset
operator|-=
literal|5
expr_stmt|;
switch|switch
condition|(
name|addr_mode
condition|)
block|{
case|case
literal|0x0
case|:
case|case
literal|0x1
case|:
case|case
literal|0x2
case|:
case|case
literal|0x3
case|:
case|case
literal|0x4
case|:
case|case
literal|0x5
case|:
case|case
literal|0x6
case|:
case|case
literal|0x7
case|:
comment|/* register mode R0 -- R7 */
switch|switch
condition|(
name|d
condition|)
block|{
case|case
literal|'F'
case|:
case|case
literal|'L'
case|:
case|case
literal|'Z'
case|:
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"f%d"
argument_list|,
name|addr_mode
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"r%d"
argument_list|,
name|addr_mode
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0x8
case|:
case|case
literal|0x9
case|:
case|case
literal|0xa
case|:
case|case
literal|0xb
case|:
case|case
literal|0xc
case|:
case|case
literal|0xd
case|:
case|case
literal|0xe
case|:
case|case
literal|0xf
case|:
comment|/* Register relative disp(R0 -- R7) */
name|disp1
operator|=
name|get_displacement
argument_list|(
name|buffer
argument_list|,
name|aoffsetp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"%d(r%d)"
argument_list|,
name|disp1
argument_list|,
name|addr_mode
operator|&
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
case|case
literal|0x11
case|:
case|case
literal|0x12
case|:
comment|/* Memory relative disp2(disp1(FP, SP, SB)) */
name|disp1
operator|=
name|get_displacement
argument_list|(
name|buffer
argument_list|,
name|aoffsetp
argument_list|)
expr_stmt|;
name|disp2
operator|=
name|get_displacement
argument_list|(
name|buffer
argument_list|,
name|aoffsetp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"%d(%d(%s))"
argument_list|,
name|disp2
argument_list|,
name|disp1
argument_list|,
name|addr_mode
operator|==
literal|0x10
condition|?
literal|"fp"
else|:
name|addr_mode
operator|==
literal|0x11
condition|?
literal|"sp"
else|:
literal|"sb"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x13
case|:
comment|/* reserved */
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"reserved"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x14
case|:
comment|/* Immediate */
switch|switch
condition|(
name|d
condition|)
block|{
case|case
literal|'I'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'A'
case|:
comment|/* I and Z are output operands and can`t be immediate 	       * A is an address and we can`t have the address of 	       * an immediate either. We don't know how much to increase 	       * aoffsetp by since whatever generated this is broken 	       * anyway! 	       */
name|sprintf
argument_list|(
name|result
argument_list|,
name|_
argument_list|(
literal|"$<undefined>"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
operator|*
name|aoffsetp
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|Ivalue
operator|=
name|sign_extend
argument_list|(
name|Ivalue
argument_list|,
literal|8
argument_list|)
expr_stmt|;
operator|*
name|aoffsetp
operator|+=
literal|8
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"$%d"
argument_list|,
name|Ivalue
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
operator|*
name|aoffsetp
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|flip_bytes
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|Ivalue
argument_list|,
literal|2
argument_list|)
expr_stmt|;
operator|*
name|aoffsetp
operator|+=
literal|16
expr_stmt|;
name|Ivalue
operator|=
name|sign_extend
argument_list|(
name|Ivalue
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"$%d"
argument_list|,
name|Ivalue
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
operator|*
name|aoffsetp
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|flip_bytes
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|Ivalue
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|*
name|aoffsetp
operator|+=
literal|32
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"$%d"
argument_list|,
name|Ivalue
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|bit_copy
argument_list|(
name|buffer
argument_list|,
operator|*
name|aoffsetp
argument_list|,
literal|32
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|value
operator|.
name|f
argument_list|)
expr_stmt|;
name|flip_bytes
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|value
operator|.
name|f
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|*
name|aoffsetp
operator|+=
literal|32
expr_stmt|;
if|if
condition|(
name|INVALID_FLOAT
argument_list|(
operator|&
name|value
operator|.
name|f
argument_list|,
literal|4
argument_list|)
condition|)
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"<<invalid float 0x%.8x>>"
argument_list|,
name|value
operator|.
name|i
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
comment|/* assume host has ieee float */
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"$%g"
argument_list|,
name|value
operator|.
name|f
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|bit_copy
argument_list|(
name|buffer
argument_list|,
operator|*
name|aoffsetp
argument_list|,
literal|64
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|value
operator|.
name|d
argument_list|)
expr_stmt|;
name|flip_bytes
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|value
operator|.
name|d
argument_list|,
literal|8
argument_list|)
expr_stmt|;
operator|*
name|aoffsetp
operator|+=
literal|64
expr_stmt|;
if|if
condition|(
name|INVALID_FLOAT
argument_list|(
operator|&
name|value
operator|.
name|d
argument_list|,
literal|8
argument_list|)
condition|)
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"<<invalid double 0x%.8x%.8x>>"
argument_list|,
name|value
operator|.
name|i
index|[
literal|1
index|]
argument_list|,
name|value
operator|.
name|i
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
comment|/* assume host has ieee float */
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"$%g"
argument_list|,
name|value
operator|.
name|d
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|0x15
case|:
comment|/* Absolute @disp */
name|disp1
operator|=
name|get_displacement
argument_list|(
name|buffer
argument_list|,
name|aoffsetp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"@|%d|"
argument_list|,
name|disp1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x16
case|:
comment|/* External EXT(disp1) + disp2 (Mod table stuff) */
name|disp1
operator|=
name|get_displacement
argument_list|(
name|buffer
argument_list|,
name|aoffsetp
argument_list|)
expr_stmt|;
name|disp2
operator|=
name|get_displacement
argument_list|(
name|buffer
argument_list|,
name|aoffsetp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"EXT(%d) + %d"
argument_list|,
name|disp1
argument_list|,
name|disp2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x17
case|:
comment|/* Top of stack tos */
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"tos"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x18
case|:
comment|/* Memory space disp(FP) */
name|disp1
operator|=
name|get_displacement
argument_list|(
name|buffer
argument_list|,
name|aoffsetp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"%d(fp)"
argument_list|,
name|disp1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x19
case|:
comment|/* Memory space disp(SP) */
name|disp1
operator|=
name|get_displacement
argument_list|(
name|buffer
argument_list|,
name|aoffsetp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"%d(sp)"
argument_list|,
name|disp1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x1a
case|:
comment|/* Memory space disp(SB) */
name|disp1
operator|=
name|get_displacement
argument_list|(
name|buffer
argument_list|,
name|aoffsetp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"%d(sb)"
argument_list|,
name|disp1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x1b
case|:
comment|/* Memory space disp(PC) */
name|disp1
operator|=
name|get_displacement
argument_list|(
name|buffer
argument_list|,
name|aoffsetp
argument_list|)
expr_stmt|;
operator|*
name|result
operator|++
operator|=
name|NEXT_IS_ADDR
expr_stmt|;
name|sprintf_vma
argument_list|(
name|result
argument_list|,
name|addr
operator|+
name|disp1
argument_list|)
expr_stmt|;
name|result
operator|+=
name|strlen
argument_list|(
name|result
argument_list|)
expr_stmt|;
operator|*
name|result
operator|++
operator|=
name|NEXT_IS_ADDR
expr_stmt|;
operator|*
name|result
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|0x1c
case|:
case|case
literal|0x1d
case|:
case|case
literal|0x1e
case|:
case|case
literal|0x1f
case|:
comment|/* Scaled index basemode[R0 -- R7:B,W,D,Q] */
name|index
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
name|index_offset
operator|-
literal|8
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|print_insn_arg
argument_list|(
name|d
argument_list|,
name|index_offset
argument_list|,
name|aoffsetp
argument_list|,
name|buffer
argument_list|,
name|addr
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
name|ind
init|=
literal|"bwdq"
decl_stmt|;
name|char
modifier|*
name|off
decl_stmt|;
name|off
operator|=
name|result
operator|+
name|strlen
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|off
argument_list|,
literal|"[r%d:%c]"
argument_list|,
name|index
argument_list|,
name|ind
index|[
name|addr_mode
operator|&
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
break|break;
case|case
literal|'H'
case|:
case|case
literal|'q'
case|:
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
name|ioffset
operator|-
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|Ivalue
operator|=
name|sign_extend
argument_list|(
name|Ivalue
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"%d"
argument_list|,
name|Ivalue
argument_list|)
expr_stmt|;
name|ioffset
operator|-=
literal|4
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
name|ioffset
operator|-
literal|3
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"r%d"
argument_list|,
name|Ivalue
operator|&
literal|7
argument_list|)
expr_stmt|;
name|ioffset
operator|-=
literal|3
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"%d"
argument_list|,
name|get_displacement
argument_list|(
name|buffer
argument_list|,
name|aoffsetp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|Ivalue
operator|=
name|get_displacement
argument_list|(
name|buffer
argument_list|,
name|aoffsetp
argument_list|)
expr_stmt|;
comment|/*        * Warning!!  HACK ALERT!        * Operand type 'b' is only used by the cmp{b,w,d} and        * movm{b,w,d} instructions; we need to know whether        * it's a `b' or `w' or `d' instruction; and for both        * cmpm and movm it's stored at the same place so we        * just grab two bits of the opcode and look at it...        *         */
name|size
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
name|ioffset
operator|-
literal|6
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
comment|/* 00 => b */
name|size
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|1
condition|)
comment|/* 01 => w */
name|size
operator|=
literal|2
expr_stmt|;
else|else
name|size
operator|=
literal|4
expr_stmt|;
comment|/* 11 => d */
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|Ivalue
operator|/
name|size
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
operator|*
name|result
operator|++
operator|=
name|NEXT_IS_ADDR
expr_stmt|;
name|sprintf_vma
argument_list|(
name|result
argument_list|,
name|addr
operator|+
name|get_displacement
argument_list|(
name|buffer
argument_list|,
name|aoffsetp
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|+=
name|strlen
argument_list|(
name|result
argument_list|)
expr_stmt|;
operator|*
name|result
operator|++
operator|=
name|NEXT_IS_ADDR
expr_stmt|;
operator|*
name|result
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
operator|*
name|aoffsetp
argument_list|,
literal|8
argument_list|)
expr_stmt|;
operator|*
name|aoffsetp
operator|+=
literal|8
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"0x%x"
argument_list|,
name|Ivalue
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
operator|*
name|aoffsetp
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|optlist
argument_list|(
name|Ivalue
argument_list|,
name|opt_u
argument_list|,
name|result
argument_list|)
expr_stmt|;
operator|*
name|aoffsetp
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
operator|*
name|aoffsetp
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|optlist
argument_list|(
name|Ivalue
argument_list|,
name|opt_U
argument_list|,
name|result
argument_list|)
expr_stmt|;
operator|*
name|aoffsetp
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
name|ioffset
operator|-
literal|9
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|optlist
argument_list|(
name|Ivalue
argument_list|,
name|opt_O
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|ioffset
operator|-=
literal|9
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
name|ioffset
operator|-
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|optlist
argument_list|(
name|Ivalue
argument_list|,
name|opt_C
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|ioffset
operator|-=
literal|4
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
name|ioffset
operator|-
literal|8
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|optlist
argument_list|(
name|Ivalue
argument_list|,
name|opt_S
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|ioffset
operator|-=
literal|8
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
name|ioffset
operator|-
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|list_search
argument_list|(
name|Ivalue
argument_list|,
literal|0
condition|?
name|list_M032
else|:
name|list_M532
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|ioffset
operator|-=
literal|4
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
name|ioffset
operator|-
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|list_search
argument_list|(
name|Ivalue
argument_list|,
literal|0
condition|?
name|list_P032
else|:
name|list_P532
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|ioffset
operator|-=
literal|4
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
operator|*
name|aoffsetp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"%d"
argument_list|,
name|Ivalue
argument_list|)
expr_stmt|;
operator|*
name|aoffsetp
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
operator|*
name|aoffsetp
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|result
argument_list|,
literal|"%d"
argument_list|,
name|Ivalue
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|aoffsetp
operator|+=
literal|5
expr_stmt|;
break|break;
block|}
return|return
name|ioffset
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|get_displacement
parameter_list|(
name|buffer
parameter_list|,
name|aoffsetp
parameter_list|)
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
modifier|*
name|aoffsetp
decl_stmt|;
block|{
name|int
name|Ivalue
decl_stmt|;
name|short
name|Ivalue2
decl_stmt|;
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
operator|*
name|aoffsetp
argument_list|,
literal|8
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|Ivalue
operator|&
literal|0xc0
condition|)
block|{
case|case
literal|0x00
case|:
case|case
literal|0x40
case|:
name|Ivalue
operator|=
name|sign_extend
argument_list|(
name|Ivalue
argument_list|,
literal|7
argument_list|)
expr_stmt|;
operator|*
name|aoffsetp
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
literal|0x80
case|:
name|Ivalue2
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
operator|*
name|aoffsetp
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|flip_bytes
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|Ivalue2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|Ivalue
operator|=
name|sign_extend
argument_list|(
name|Ivalue2
argument_list|,
literal|14
argument_list|)
expr_stmt|;
operator|*
name|aoffsetp
operator|+=
literal|16
expr_stmt|;
break|break;
case|case
literal|0xc0
case|:
name|Ivalue
operator|=
name|bit_extract
argument_list|(
name|buffer
argument_list|,
operator|*
name|aoffsetp
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|flip_bytes
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|Ivalue
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|Ivalue
operator|=
name|sign_extend
argument_list|(
name|Ivalue
argument_list|,
literal|30
argument_list|)
expr_stmt|;
operator|*
name|aoffsetp
operator|+=
literal|32
expr_stmt|;
break|break;
block|}
return|return
name|Ivalue
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|1
end_if

begin_comment
comment|/* a version that should work on ns32k f's&d's on any machine */
end_comment

begin_function
specifier|static
name|int
name|invalid_float
parameter_list|(
name|p
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|val
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|4
condition|)
name|val
operator|=
operator|(
name|bit_extract_simple
argument_list|(
name|p
argument_list|,
literal|23
argument_list|,
literal|8
argument_list|)
comment|/*exponent*/
operator|==
literal|0xff
operator|||
operator|(
name|bit_extract_simple
argument_list|(
name|p
argument_list|,
literal|23
argument_list|,
literal|8
argument_list|)
comment|/*exponent*/
operator|==
literal|0
operator|&&
name|bit_extract_simple
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|23
argument_list|)
comment|/*mantisa*/
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
literal|8
condition|)
name|val
operator|=
operator|(
name|bit_extract_simple
argument_list|(
name|p
argument_list|,
literal|52
argument_list|,
literal|11
argument_list|)
comment|/*exponent*/
operator|==
literal|0x7ff
operator|||
operator|(
name|bit_extract_simple
argument_list|(
name|p
argument_list|,
literal|52
argument_list|,
literal|11
argument_list|)
comment|/*exponent*/
operator|==
literal|0
operator|&&
operator|(
name|bit_extract_simple
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|32
argument_list|)
comment|/*low mantisa*/
operator|!=
literal|0
operator|||
name|bit_extract_simple
argument_list|(
name|p
argument_list|,
literal|32
argument_list|,
literal|20
argument_list|)
comment|/*high mantisa*/
operator|!=
literal|0
operator|)
operator|)
operator|)
expr_stmt|;
else|else
name|val
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* assumes the bytes have been swapped to local order */
end_comment

begin_typedef
typedef|typedef
union|union
block|{
name|double
name|d
decl_stmt|;
name|float
name|f
decl_stmt|;
struct|struct
block|{
name|unsigned
name|m
range|:
literal|23
decl_stmt|,
name|e
range|:
literal|8
decl_stmt|,
range|:
literal|1
decl_stmt|;
block|}
name|sf
struct|;
struct|struct
block|{
name|unsigned
name|lm
decl_stmt|;
name|unsigned
name|m
range|:
literal|20
decl_stmt|,
name|e
range|:
literal|11
decl_stmt|,
range|:
literal|1
decl_stmt|;
block|}
name|sd
struct|;
block|}
name|float_type_u
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|invalid_float
parameter_list|(
name|p
parameter_list|,
name|len
parameter_list|)
specifier|register
name|float_type_u
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|val
decl_stmt|;
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|float
argument_list|)
condition|)
name|val
operator|=
operator|(
name|p
operator|->
name|sf
operator|.
name|e
operator|==
literal|0xff
operator|||
operator|(
name|p
operator|->
name|sf
operator|.
name|e
operator|==
literal|0
operator|&&
name|p
operator|->
name|sf
operator|.
name|m
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|double
argument_list|)
condition|)
name|val
operator|=
operator|(
name|p
operator|->
name|sd
operator|.
name|e
operator|==
literal|0x7ff
operator|||
operator|(
name|p
operator|->
name|sd
operator|.
name|e
operator|==
literal|0
operator|&&
operator|(
name|p
operator|->
name|sd
operator|.
name|m
operator|!=
literal|0
operator|||
name|p
operator|->
name|sd
operator|.
name|lm
operator|!=
literal|0
operator|)
operator|)
operator|)
expr_stmt|;
else|else
name|val
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

