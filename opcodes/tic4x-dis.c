begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print instructions for the Texas TMS320C[34]X, for GDB and GNU Binutils.     Copyright 2002, 2003 Free Software Foundation, Inc.     Contributed by Michael P. Hayes (m.hayes@elec.canterbury.ac.nz)        This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"opcode/tic4x.h"
end_include

begin_define
define|#
directive|define
name|TIC4X_DEBUG
value|0
end_define

begin_define
define|#
directive|define
name|TIC4X_HASH_SIZE
value|11
end_define

begin_comment
comment|/* 11 (bits) and above should give unique entries.  */
end_comment

begin_define
define|#
directive|define
name|TIC4X_SPESOP_SIZE
value|8
end_define

begin_comment
comment|/* Max 8. ops for special instructions */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|IMMED_SINT
block|,
name|IMMED_SUINT
block|,
name|IMMED_SFLOAT
block|,
name|IMMED_INT
block|,
name|IMMED_UINT
block|,
name|IMMED_FLOAT
block|}
name|immed_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|INDIRECT_SHORT
block|,
name|INDIRECT_LONG
block|,
name|INDIRECT_TIC4X
block|}
name|indirect_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|tic4x_version
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tic4x_dp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tic4x_pc_offset
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tic4x_print_char
name|PARAMS
argument_list|(
operator|(
expr|struct
name|disassemble_info
operator|*
operator|,
name|char
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tic4x_print_str
name|PARAMS
argument_list|(
operator|(
expr|struct
name|disassemble_info
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tic4x_print_register
name|PARAMS
argument_list|(
operator|(
expr|struct
name|disassemble_info
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tic4x_print_addr
name|PARAMS
argument_list|(
operator|(
expr|struct
name|disassemble_info
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tic4x_print_relative
name|PARAMS
argument_list|(
operator|(
expr|struct
name|disassemble_info
operator|*
operator|,
name|unsigned
name|long
operator|,
name|long
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|tic4x_print_ftoa
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|FILE
operator|*
operator|,
name|fprintf_ftype
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tic4x_print_direct
name|PARAMS
argument_list|(
operator|(
expr|struct
name|disassemble_info
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tic4x_print_immed
name|PARAMS
argument_list|(
operator|(
expr|struct
name|disassemble_info
operator|*
operator|,
name|immed_t
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tic4x_print_cond
name|PARAMS
argument_list|(
operator|(
expr|struct
name|disassemble_info
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tic4x_print_indirect
name|PARAMS
argument_list|(
operator|(
expr|struct
name|disassemble_info
operator|*
operator|,
name|indirect_t
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tic4x_print_op
name|PARAMS
argument_list|(
operator|(
expr|struct
name|disassemble_info
operator|*
operator|,
name|unsigned
name|long
operator|,
name|tic4x_inst_t
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic4x_hash_opcode_special
name|PARAMS
argument_list|(
operator|(
name|tic4x_inst_t
operator|*
operator|*
operator|,
specifier|const
name|tic4x_inst_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tic4x_hash_opcode
name|PARAMS
argument_list|(
operator|(
name|tic4x_inst_t
operator|*
operator|*
operator|,
name|tic4x_inst_t
operator|*
operator|*
operator|,
specifier|const
name|tic4x_inst_t
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tic4x_disassemble
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|,
expr|struct
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|print_insn_tic4x
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
expr|struct
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|tic4x_pc_offset
parameter_list|(
name|op
parameter_list|)
name|unsigned
name|int
name|op
decl_stmt|;
block|{
comment|/* Determine the PC offset for a C[34]x instruction.      This could be simplified using some boolean algebra      but at the expense of readability.  */
switch|switch
condition|(
name|op
operator|>>
literal|24
condition|)
block|{
case|case
literal|0x60
case|:
comment|/* br */
case|case
literal|0x62
case|:
comment|/* call  (C4x) */
case|case
literal|0x64
case|:
comment|/* rptb  (C4x) */
return|return
literal|1
return|;
case|case
literal|0x61
case|:
comment|/* brd */
case|case
literal|0x63
case|:
comment|/* laj */
case|case
literal|0x65
case|:
comment|/* rptbd (C4x) */
return|return
literal|3
return|;
case|case
literal|0x66
case|:
comment|/* swi */
case|case
literal|0x67
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
switch|switch
condition|(
operator|(
name|op
operator|&
literal|0xffe00000
operator|)
operator|>>
literal|20
condition|)
block|{
case|case
literal|0x6a0
case|:
comment|/* bB */
case|case
literal|0x720
case|:
comment|/* callB */
case|case
literal|0x740
case|:
comment|/* trapB */
return|return
literal|1
return|;
case|case
literal|0x6a2
case|:
comment|/* bBd */
case|case
literal|0x6a6
case|:
comment|/* bBat */
case|case
literal|0x6aa
case|:
comment|/* bBaf */
case|case
literal|0x722
case|:
comment|/* lajB */
case|case
literal|0x748
case|:
comment|/* latB */
case|case
literal|0x798
case|:
comment|/* rptbd */
return|return
literal|3
return|;
default|default:
break|break;
block|}
switch|switch
condition|(
operator|(
name|op
operator|&
literal|0xfe200000
operator|)
operator|>>
literal|20
condition|)
block|{
case|case
literal|0x6e0
case|:
comment|/* dbB */
return|return
literal|1
return|;
case|case
literal|0x6e2
case|:
comment|/* dbBd */
return|return
literal|3
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tic4x_print_char
parameter_list|(
name|info
parameter_list|,
name|ch
parameter_list|)
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
name|char
name|ch
decl_stmt|;
block|{
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%c"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tic4x_print_str
parameter_list|(
name|info
parameter_list|,
name|str
parameter_list|)
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tic4x_print_register
parameter_list|(
name|info
parameter_list|,
name|regno
parameter_list|)
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
name|unsigned
name|long
name|regno
decl_stmt|;
block|{
specifier|static
name|tic4x_register_t
modifier|*
modifier|*
name|registertable
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|registertable
operator|==
name|NULL
condition|)
block|{
name|registertable
operator|=
operator|(
name|tic4x_register_t
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tic4x_register_t
operator|*
argument_list|)
operator|*
name|REG_TABLE_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tic3x_num_registers
condition|;
name|i
operator|++
control|)
name|registertable
index|[
name|tic3x_registers
index|[
name|i
index|]
operator|.
name|regno
index|]
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|tic3x_registers
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|IS_CPU_TIC4X
argument_list|(
name|tic4x_version
argument_list|)
condition|)
block|{
comment|/* Add C4x additional registers, overwriting 	     any C3x registers if necessary.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tic4x_num_registers
condition|;
name|i
operator|++
control|)
name|registertable
index|[
name|tic4x_registers
index|[
name|i
index|]
operator|.
name|regno
index|]
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|tic4x_registers
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|regno
operator|>
operator|(
name|IS_CPU_TIC4X
argument_list|(
name|tic4x_version
argument_list|)
condition|?
name|TIC4X_REG_MAX
else|:
name|TIC3X_REG_MAX
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|registertable
index|[
name|regno
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tic4x_print_addr
parameter_list|(
name|info
parameter_list|,
name|addr
parameter_list|)
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
name|unsigned
name|long
name|addr
decl_stmt|;
block|{
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|addr
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tic4x_print_relative
parameter_list|(
name|info
parameter_list|,
name|pc
parameter_list|,
name|offset
parameter_list|,
name|opcode
parameter_list|)
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
name|unsigned
name|long
name|pc
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|unsigned
name|long
name|opcode
decl_stmt|;
block|{
return|return
name|tic4x_print_addr
argument_list|(
name|info
argument_list|,
name|pc
operator|+
name|offset
operator|+
name|tic4x_pc_offset
argument_list|(
name|opcode
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tic4x_print_direct
parameter_list|(
name|info
parameter_list|,
name|arg
parameter_list|)
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
name|unsigned
name|long
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
name|tic4x_print_addr
argument_list|(
name|info
argument_list|,
name|arg
operator|+
operator|(
name|tic4x_dp
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* FIXME: make the floating point stuff not rely on host    floating point arithmetic.  */
end_comment

begin_function
name|void
name|tic4x_print_ftoa
parameter_list|(
name|val
parameter_list|,
name|stream
parameter_list|,
name|pfunc
parameter_list|)
name|unsigned
name|int
name|val
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|fprintf_ftype
name|pfunc
decl_stmt|;
block|{
name|int
name|e
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|f
decl_stmt|;
name|double
name|num
init|=
literal|0.0
decl_stmt|;
name|e
operator|=
name|EXTRS
argument_list|(
name|val
argument_list|,
literal|31
argument_list|,
literal|24
argument_list|)
expr_stmt|;
comment|/* exponent */
if|if
condition|(
name|e
operator|!=
operator|-
literal|128
condition|)
block|{
name|s
operator|=
name|EXTRU
argument_list|(
name|val
argument_list|,
literal|23
argument_list|,
literal|23
argument_list|)
expr_stmt|;
comment|/* sign bit */
name|f
operator|=
name|EXTRU
argument_list|(
name|val
argument_list|,
literal|22
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* mantissa */
if|if
condition|(
name|s
condition|)
name|f
operator|+=
operator|-
literal|2
operator|*
operator|(
literal|1
operator|<<
literal|23
operator|)
expr_stmt|;
else|else
name|f
operator|+=
operator|(
literal|1
operator|<<
literal|23
operator|)
expr_stmt|;
name|num
operator|=
name|f
operator|/
call|(
name|double
call|)
argument_list|(
literal|1
operator|<<
literal|23
argument_list|)
expr_stmt|;
name|num
operator|=
name|ldexp
argument_list|(
name|num
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|pfunc
call|)
argument_list|(
name|stream
argument_list|,
literal|"%.9g"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tic4x_print_immed
parameter_list|(
name|info
parameter_list|,
name|type
parameter_list|,
name|arg
parameter_list|)
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
name|immed_t
name|type
decl_stmt|;
name|unsigned
name|long
name|arg
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|int
name|f
decl_stmt|;
name|int
name|e
decl_stmt|;
name|double
name|num
init|=
literal|0.0
decl_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|IMMED_SINT
case|:
case|case
name|IMMED_INT
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|long
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMMED_SUINT
case|:
case|case
name|IMMED_UINT
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%u"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMMED_SFLOAT
case|:
name|e
operator|=
name|EXTRS
argument_list|(
name|arg
argument_list|,
literal|15
argument_list|,
literal|12
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|!=
operator|-
literal|8
condition|)
block|{
name|s
operator|=
name|EXTRU
argument_list|(
name|arg
argument_list|,
literal|11
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|f
operator|=
name|EXTRU
argument_list|(
name|arg
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|f
operator|+=
operator|-
literal|2
operator|*
operator|(
literal|1
operator|<<
literal|11
operator|)
expr_stmt|;
else|else
name|f
operator|+=
operator|(
literal|1
operator|<<
literal|11
operator|)
expr_stmt|;
name|num
operator|=
name|f
operator|/
call|(
name|double
call|)
argument_list|(
literal|1
operator|<<
literal|11
argument_list|)
expr_stmt|;
name|num
operator|=
name|ldexp
argument_list|(
name|num
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%f"
argument_list|,
name|num
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMMED_FLOAT
case|:
name|e
operator|=
name|EXTRS
argument_list|(
name|arg
argument_list|,
literal|31
argument_list|,
literal|24
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|!=
operator|-
literal|128
condition|)
block|{
name|s
operator|=
name|EXTRU
argument_list|(
name|arg
argument_list|,
literal|23
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|f
operator|=
name|EXTRU
argument_list|(
name|arg
argument_list|,
literal|22
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|f
operator|+=
operator|-
literal|2
operator|*
operator|(
literal|1
operator|<<
literal|23
operator|)
expr_stmt|;
else|else
name|f
operator|+=
operator|(
literal|1
operator|<<
literal|23
operator|)
expr_stmt|;
name|num
operator|=
name|f
operator|/
call|(
name|double
call|)
argument_list|(
literal|1
operator|<<
literal|23
argument_list|)
expr_stmt|;
name|num
operator|=
name|ldexp
argument_list|(
name|num
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%f"
argument_list|,
name|num
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tic4x_print_cond
parameter_list|(
name|info
parameter_list|,
name|cond
parameter_list|)
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
name|unsigned
name|int
name|cond
decl_stmt|;
block|{
specifier|static
name|tic4x_cond_t
modifier|*
modifier|*
name|condtable
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|condtable
operator|==
name|NULL
condition|)
block|{
name|condtable
operator|=
operator|(
name|tic4x_cond_t
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tic4x_cond_t
operator|*
argument_list|)
operator|*
literal|32
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tic4x_num_conds
condition|;
name|i
operator|++
control|)
name|condtable
index|[
name|tic4x_conds
index|[
name|i
index|]
operator|.
name|cond
index|]
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|tic4x_conds
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|cond
operator|>
literal|31
operator|||
name|condtable
index|[
name|cond
index|]
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|condtable
index|[
name|cond
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tic4x_print_indirect
parameter_list|(
name|info
parameter_list|,
name|type
parameter_list|,
name|arg
parameter_list|)
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
name|indirect_t
name|type
decl_stmt|;
name|unsigned
name|long
name|arg
decl_stmt|;
block|{
name|unsigned
name|int
name|aregno
decl_stmt|;
name|unsigned
name|int
name|modn
decl_stmt|;
name|unsigned
name|int
name|disp
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|;
name|aregno
operator|=
literal|0
expr_stmt|;
name|modn
operator|=
literal|0
expr_stmt|;
name|disp
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|INDIRECT_TIC4X
case|:
comment|/* *+ARn(disp) */
name|disp
operator|=
name|EXTRU
argument_list|(
name|arg
argument_list|,
literal|7
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|aregno
operator|=
name|EXTRU
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
operator|+
name|REG_AR0
expr_stmt|;
name|modn
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|INDIRECT_SHORT
case|:
name|disp
operator|=
literal|1
expr_stmt|;
name|aregno
operator|=
name|EXTRU
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
operator|+
name|REG_AR0
expr_stmt|;
name|modn
operator|=
name|EXTRU
argument_list|(
name|arg
argument_list|,
literal|7
argument_list|,
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDIRECT_LONG
case|:
name|disp
operator|=
name|EXTRU
argument_list|(
name|arg
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aregno
operator|=
name|EXTRU
argument_list|(
name|arg
argument_list|,
literal|10
argument_list|,
literal|8
argument_list|)
operator|+
name|REG_AR0
expr_stmt|;
name|modn
operator|=
name|EXTRU
argument_list|(
name|arg
argument_list|,
literal|15
argument_list|,
literal|11
argument_list|)
expr_stmt|;
if|if
condition|(
name|modn
operator|>
literal|7
operator|&&
name|disp
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
break|break;
default|default:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"# internal error: Unknown indirect type %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|modn
operator|>
name|TIC3X_MODN_MAX
condition|)
return|return
literal|0
return|;
name|a
operator|=
name|tic4x_indirects
index|[
name|modn
index|]
operator|.
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|a
condition|)
block|{
switch|switch
condition|(
operator|*
name|a
condition|)
block|{
case|case
literal|'a'
case|:
name|tic4x_print_register
argument_list|(
name|info
argument_list|,
name|aregno
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|tic4x_print_immed
argument_list|(
name|info
argument_list|,
name|IMMED_UINT
argument_list|,
name|disp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|tic4x_print_str
argument_list|(
name|info
argument_list|,
literal|"ir0"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|tic4x_print_str
argument_list|(
name|info
argument_list|,
literal|"ir1"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|tic4x_print_char
argument_list|(
name|info
argument_list|,
operator|*
name|a
argument_list|)
expr_stmt|;
break|break;
block|}
name|a
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tic4x_print_op
parameter_list|(
name|info
parameter_list|,
name|instruction
parameter_list|,
name|p
parameter_list|,
name|pc
parameter_list|)
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
name|unsigned
name|long
name|instruction
decl_stmt|;
name|tic4x_inst_t
modifier|*
name|p
decl_stmt|;
name|unsigned
name|long
name|pc
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|parallel
init|=
name|NULL
decl_stmt|;
comment|/* Print instruction name.  */
name|s
operator|=
name|p
operator|->
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
name|parallel
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'B'
case|:
if|if
condition|(
operator|!
name|tic4x_print_cond
argument_list|(
name|info
argument_list|,
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|20
argument_list|,
literal|16
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
operator|!
name|tic4x_print_cond
argument_list|(
name|info
argument_list|,
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|27
argument_list|,
literal|23
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'_'
case|:
name|parallel
operator|=
name|s
operator|+
literal|1
expr_stmt|;
comment|/* Skip past `_' in name */
break|break;
default|default:
name|tic4x_print_char
argument_list|(
name|info
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
name|s
operator|++
expr_stmt|;
block|}
comment|/* Print arguments.  */
name|s
operator|=
name|p
operator|->
name|args
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
name|tic4x_print_char
argument_list|(
name|info
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'*'
case|:
comment|/* indirect 0--15 */
if|if
condition|(
operator|!
name|tic4x_print_indirect
argument_list|(
name|info
argument_list|,
name|INDIRECT_LONG
argument_list|,
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|15
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'#'
case|:
comment|/* only used for ldp, ldpk */
name|tic4x_print_immed
argument_list|(
name|info
argument_list|,
name|IMMED_UINT
argument_list|,
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|15
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
comment|/* direct 0--15 */
name|tic4x_print_direct
argument_list|(
name|info
argument_list|,
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|15
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
comment|/* address register 24--22 */
if|if
condition|(
operator|!
name|tic4x_print_register
argument_list|(
name|info
argument_list|,
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|24
argument_list|,
literal|22
argument_list|)
operator|+
name|REG_AR0
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'B'
case|:
comment|/* 24-bit unsigned int immediate br(d)/call/rptb 		     address 0--23.  */
if|if
condition|(
name|IS_CPU_TIC4X
argument_list|(
name|tic4x_version
argument_list|)
condition|)
name|tic4x_print_relative
argument_list|(
name|info
argument_list|,
name|pc
argument_list|,
name|EXTRS
argument_list|(
name|instruction
argument_list|,
literal|23
argument_list|,
literal|0
argument_list|)
argument_list|,
name|p
operator|->
name|opcode
argument_list|)
expr_stmt|;
else|else
name|tic4x_print_addr
argument_list|(
name|info
argument_list|,
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|23
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* indirect (short C4x) 0--7 */
if|if
condition|(
operator|!
name|IS_CPU_TIC4X
argument_list|(
name|tic4x_version
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|tic4x_print_indirect
argument_list|(
name|info
argument_list|,
name|INDIRECT_TIC4X
argument_list|,
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'D'
case|:
comment|/* Cockup if get here...  */
break|break;
case|case
literal|'E'
case|:
comment|/* register 0--7 */
case|case
literal|'e'
case|:
if|if
condition|(
operator|!
name|tic4x_print_register
argument_list|(
name|info
argument_list|,
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'F'
case|:
comment|/* 16-bit float immediate 0--15 */
name|tic4x_print_immed
argument_list|(
name|info
argument_list|,
name|IMMED_SFLOAT
argument_list|,
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|15
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* Extended indirect 0--7 */
if|if
condition|(
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|7
argument_list|,
literal|5
argument_list|)
operator|==
literal|7
condition|)
block|{
if|if
condition|(
operator|!
name|tic4x_print_register
argument_list|(
name|info
argument_list|,
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
block|}
comment|/* Fallthrough */
case|case
literal|'I'
case|:
comment|/* indirect (short) 0--7 */
if|if
condition|(
operator|!
name|tic4x_print_indirect
argument_list|(
name|info
argument_list|,
name|INDIRECT_SHORT
argument_list|,
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'j'
case|:
comment|/* Extended indirect 8--15 */
if|if
condition|(
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|15
argument_list|,
literal|13
argument_list|)
operator|==
literal|7
condition|)
block|{
if|if
condition|(
operator|!
name|tic4x_print_register
argument_list|(
name|info
argument_list|,
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|12
argument_list|,
literal|8
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
block|}
case|case
literal|'J'
case|:
comment|/* indirect (short) 8--15 */
if|if
condition|(
operator|!
name|tic4x_print_indirect
argument_list|(
name|info
argument_list|,
name|INDIRECT_SHORT
argument_list|,
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|15
argument_list|,
literal|8
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'G'
case|:
comment|/* register 8--15 */
case|case
literal|'g'
case|:
if|if
condition|(
operator|!
name|tic4x_print_register
argument_list|(
name|info
argument_list|,
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|15
argument_list|,
literal|8
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'H'
case|:
comment|/* register 16--18 */
if|if
condition|(
operator|!
name|tic4x_print_register
argument_list|(
name|info
argument_list|,
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|18
argument_list|,
literal|16
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'K'
case|:
comment|/* register 19--21 */
if|if
condition|(
operator|!
name|tic4x_print_register
argument_list|(
name|info
argument_list|,
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|21
argument_list|,
literal|19
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'L'
case|:
comment|/* register 22--24 */
if|if
condition|(
operator|!
name|tic4x_print_register
argument_list|(
name|info
argument_list|,
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|24
argument_list|,
literal|22
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'M'
case|:
comment|/* register 22--22 */
name|tic4x_print_register
argument_list|(
name|info
argument_list|,
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|22
argument_list|,
literal|22
argument_list|)
operator|+
name|REG_R2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* register 23--23 */
name|tic4x_print_register
argument_list|(
name|info
argument_list|,
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|23
argument_list|,
literal|23
argument_list|)
operator|+
name|REG_R0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
comment|/* indirect (short C4x) 8--15 */
if|if
condition|(
operator|!
name|IS_CPU_TIC4X
argument_list|(
name|tic4x_version
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|tic4x_print_indirect
argument_list|(
name|info
argument_list|,
name|INDIRECT_TIC4X
argument_list|,
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|15
argument_list|,
literal|8
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'P'
case|:
comment|/* displacement 0--15 (used by Bcond and BcondD) */
name|tic4x_print_relative
argument_list|(
name|info
argument_list|,
name|pc
argument_list|,
name|EXTRS
argument_list|(
name|instruction
argument_list|,
literal|15
argument_list|,
literal|0
argument_list|)
argument_list|,
name|p
operator|->
name|opcode
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
comment|/* register 0--15 */
case|case
literal|'q'
case|:
if|if
condition|(
operator|!
name|tic4x_print_register
argument_list|(
name|info
argument_list|,
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|15
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'R'
case|:
comment|/* register 16--20 */
case|case
literal|'r'
case|:
if|if
condition|(
operator|!
name|tic4x_print_register
argument_list|(
name|info
argument_list|,
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|20
argument_list|,
literal|16
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'S'
case|:
comment|/* 16-bit signed immediate 0--15 */
name|tic4x_print_immed
argument_list|(
name|info
argument_list|,
name|IMMED_SINT
argument_list|,
name|EXTRS
argument_list|(
name|instruction
argument_list|,
literal|15
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* 5-bit signed immediate 16--20  (C4x stik) */
if|if
condition|(
operator|!
name|IS_CPU_TIC4X
argument_list|(
name|tic4x_version
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|tic4x_print_immed
argument_list|(
name|info
argument_list|,
name|IMMED_SUINT
argument_list|,
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|20
argument_list|,
literal|16
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'U'
case|:
comment|/* 16-bit unsigned int immediate 0--15 */
name|tic4x_print_immed
argument_list|(
name|info
argument_list|,
name|IMMED_SUINT
argument_list|,
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|15
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* 5/9-bit unsigned vector 0--4/8 */
name|tic4x_print_immed
argument_list|(
name|info
argument_list|,
name|IMMED_SUINT
argument_list|,
name|IS_CPU_TIC4X
argument_list|(
name|tic4x_version
argument_list|)
condition|?
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
else|:
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
operator|&
operator|~
literal|0x20
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
comment|/* 8-bit signed immediate 0--7 */
if|if
condition|(
operator|!
name|IS_CPU_TIC4X
argument_list|(
name|tic4x_version
argument_list|)
condition|)
return|return
literal|0
return|;
name|tic4x_print_immed
argument_list|(
name|info
argument_list|,
name|IMMED_SINT
argument_list|,
name|EXTRS
argument_list|(
name|instruction
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* expansion register 4--0 */
name|val
operator|=
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
operator|+
name|REG_IVTP
expr_stmt|;
if|if
condition|(
name|val
operator|<
name|REG_IVTP
operator|||
name|val
operator|>
name|REG_TVTP
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|tic4x_print_register
argument_list|(
name|info
argument_list|,
name|val
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'Y'
case|:
comment|/* address register 16--20 */
name|val
operator|=
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|20
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
name|REG_AR0
operator|||
name|val
operator|>
name|REG_SP
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|tic4x_print_register
argument_list|(
name|info
argument_list|,
name|val
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'Z'
case|:
comment|/* expansion register 16--20 */
name|val
operator|=
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|20
argument_list|,
literal|16
argument_list|)
operator|+
name|REG_IVTP
expr_stmt|;
if|if
condition|(
name|val
operator|<
name|REG_IVTP
operator|||
name|val
operator|>
name|REG_TVTP
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|tic4x_print_register
argument_list|(
name|info
argument_list|,
name|val
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'|'
case|:
comment|/* Parallel instruction */
name|tic4x_print_str
argument_list|(
name|info
argument_list|,
literal|" || "
argument_list|)
expr_stmt|;
name|tic4x_print_str
argument_list|(
name|info
argument_list|,
name|parallel
argument_list|)
expr_stmt|;
name|tic4x_print_char
argument_list|(
name|info
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
break|break;
case|case
literal|';'
case|:
name|tic4x_print_char
argument_list|(
name|info
argument_list|,
literal|','
argument_list|)
expr_stmt|;
break|break;
default|default:
name|tic4x_print_char
argument_list|(
name|info
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
name|s
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tic4x_hash_opcode_special
parameter_list|(
name|optable_special
parameter_list|,
name|inst
parameter_list|)
name|tic4x_inst_t
modifier|*
modifier|*
name|optable_special
decl_stmt|;
specifier|const
name|tic4x_inst_t
modifier|*
name|inst
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TIC4X_SPESOP_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|optable_special
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|optable_special
index|[
name|i
index|]
operator|->
name|opcode
operator|==
name|inst
operator|->
name|opcode
condition|)
block|{
comment|/* Collision (we have it already) - overwrite */
name|optable_special
index|[
name|i
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|inst
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TIC4X_SPESOP_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|optable_special
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* Add the new opcode */
name|optable_special
index|[
name|i
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|inst
expr_stmt|;
return|return;
block|}
comment|/* This should never occur. This happens if the number of special      instructions exceeds TIC4X_SPESOP_SIZE. Please increase the variable      of this variable */
if|#
directive|if
name|TIC4X_DEBUG
name|printf
argument_list|(
literal|"optable_special[] is full, please increase TIC4X_SPESOP_SIZE!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|tic4x_hash_opcode
parameter_list|(
name|optable
parameter_list|,
name|optable_special
parameter_list|,
name|inst
parameter_list|,
name|tic4x_oplevel
parameter_list|)
name|tic4x_inst_t
modifier|*
modifier|*
name|optable
decl_stmt|;
name|tic4x_inst_t
modifier|*
modifier|*
name|optable_special
decl_stmt|;
specifier|const
name|tic4x_inst_t
modifier|*
name|inst
decl_stmt|;
specifier|const
name|unsigned
name|long
name|tic4x_oplevel
decl_stmt|;
block|{
name|int
name|j
decl_stmt|;
name|int
name|opcode
init|=
name|inst
operator|->
name|opcode
operator|>>
operator|(
literal|32
operator|-
name|TIC4X_HASH_SIZE
operator|)
decl_stmt|;
name|int
name|opmask
init|=
name|inst
operator|->
name|opmask
operator|>>
operator|(
literal|32
operator|-
name|TIC4X_HASH_SIZE
operator|)
decl_stmt|;
comment|/* Use a TIC4X_HASH_SIZE bit index as a hash index.  We should      have unique entries so there's no point having a linked list      for each entry? */
for|for
control|(
name|j
operator|=
name|opcode
init|;
name|j
operator|<
name|opmask
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|j
operator|&
name|opmask
operator|)
operator|==
name|opcode
operator|&&
name|inst
operator|->
name|oplevel
operator|&
name|tic4x_oplevel
condition|)
block|{
if|#
directive|if
name|TIC4X_DEBUG
comment|/* We should only have collisions for synonyms like 	   ldp for ldi.  */
if|if
condition|(
name|optable
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"Collision at index %d, %s and %s\n"
argument_list|,
name|j
argument_list|,
name|optable
index|[
name|j
index|]
operator|->
name|name
argument_list|,
name|inst
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Catch those ops that collide with others already inside the            hash, and have a opmask greater than the one we use in the            hash. Store them in a special-list, that will handle full            32-bit INSN, not only the first 11-bit (or so). */
if|if
condition|(
name|optable
index|[
name|j
index|]
operator|!=
name|NULL
operator|&&
name|inst
operator|->
name|opmask
operator|&
operator|~
operator|(
name|opmask
operator|<<
operator|(
literal|32
operator|-
name|TIC4X_HASH_SIZE
operator|)
operator|)
condition|)
block|{
comment|/* Add the instruction already on the list */
name|tic4x_hash_opcode_special
argument_list|(
name|optable_special
argument_list|,
name|optable
index|[
name|j
index|]
argument_list|)
expr_stmt|;
comment|/* Add the new instruction */
name|tic4x_hash_opcode_special
argument_list|(
name|optable_special
argument_list|,
name|inst
argument_list|)
expr_stmt|;
block|}
name|optable
index|[
name|j
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|inst
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Disassemble the instruction in 'instruction'.    'pc' should be the address of this instruction, it will    be used to print the target address if this is a relative jump or call    the disassembled instruction is written to 'info'.    The function returns the length of this instruction in words.  */
end_comment

begin_function
specifier|static
name|int
name|tic4x_disassemble
parameter_list|(
name|pc
parameter_list|,
name|instruction
parameter_list|,
name|info
parameter_list|)
name|unsigned
name|long
name|pc
decl_stmt|;
name|unsigned
name|long
name|instruction
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
specifier|static
name|tic4x_inst_t
modifier|*
modifier|*
name|optable
init|=
name|NULL
decl_stmt|;
specifier|static
name|tic4x_inst_t
modifier|*
modifier|*
name|optable_special
init|=
name|NULL
decl_stmt|;
name|tic4x_inst_t
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|tic4x_oplevel
decl_stmt|;
name|tic4x_version
operator|=
name|info
operator|->
name|mach
expr_stmt|;
name|tic4x_oplevel
operator|=
operator|(
name|IS_CPU_TIC4X
argument_list|(
name|tic4x_version
argument_list|)
operator|)
condition|?
name|OP_C4X
else|:
literal|0
expr_stmt|;
name|tic4x_oplevel
operator||=
name|OP_C3X
operator||
name|OP_LPWR
operator||
name|OP_IDLE2
operator||
name|OP_ENH
expr_stmt|;
if|if
condition|(
name|optable
operator|==
name|NULL
condition|)
block|{
name|optable
operator|=
operator|(
name|tic4x_inst_t
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tic4x_inst_t
operator|*
argument_list|)
argument_list|,
operator|(
literal|1
operator|<<
name|TIC4X_HASH_SIZE
operator|)
argument_list|)
expr_stmt|;
name|optable_special
operator|=
operator|(
name|tic4x_inst_t
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tic4x_inst_t
operator|*
argument_list|)
argument_list|,
name|TIC4X_SPESOP_SIZE
argument_list|)
expr_stmt|;
comment|/* Install opcodes in reverse order so that preferred 	 forms overwrite synonyms.  */
for|for
control|(
name|i
operator|=
name|tic4x_num_insts
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|tic4x_hash_opcode
argument_list|(
name|optable
argument_list|,
name|optable_special
argument_list|,
operator|&
name|tic4x_insts
index|[
name|i
index|]
argument_list|,
name|tic4x_oplevel
argument_list|)
expr_stmt|;
comment|/* We now need to remove the insn that are special from the          "normal" optable, to make the disasm search this extra list          for them.       */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TIC4X_SPESOP_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|optable_special
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|optable
index|[
name|optable_special
index|[
name|i
index|]
operator|->
name|opcode
operator|>>
operator|(
literal|32
operator|-
name|TIC4X_HASH_SIZE
operator|)
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* See if we can pick up any loading of the DP register...  */
if|if
condition|(
operator|(
name|instruction
operator|>>
literal|16
operator|)
operator|==
literal|0x5070
operator|||
operator|(
name|instruction
operator|>>
literal|16
operator|)
operator|==
literal|0x1f70
condition|)
name|tic4x_dp
operator|=
name|EXTRU
argument_list|(
name|instruction
argument_list|,
literal|15
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|optable
index|[
name|instruction
operator|>>
operator|(
literal|32
operator|-
name|TIC4X_HASH_SIZE
operator|)
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|instruction
operator|&
name|p
operator|->
name|opmask
operator|)
operator|==
name|p
operator|->
name|opcode
operator|)
operator|&&
name|tic4x_print_op
argument_list|(
name|NULL
argument_list|,
name|instruction
argument_list|,
name|p
argument_list|,
name|pc
argument_list|)
condition|)
name|tic4x_print_op
argument_list|(
name|info
argument_list|,
name|instruction
argument_list|,
name|p
argument_list|,
name|pc
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%08x"
argument_list|,
name|instruction
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TIC4X_SPESOP_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|optable_special
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|optable_special
index|[
name|i
index|]
operator|->
name|opcode
operator|==
name|instruction
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|optable_special
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|TIC4X_SPESOP_SIZE
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%08x"
argument_list|,
name|instruction
argument_list|)
expr_stmt|;
block|}
comment|/* Return size of insn in words.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The entry point from objdump and gdb.  */
end_comment

begin_function
name|int
name|print_insn_tic4x
parameter_list|(
name|memaddr
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|memaddr
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|unsigned
name|long
name|pc
decl_stmt|;
name|unsigned
name|long
name|op
decl_stmt|;
name|bfd_byte
name|buffer
index|[
literal|4
index|]
decl_stmt|;
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|memaddr
argument_list|,
name|buffer
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|memory_error_func
call|)
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pc
operator|=
name|memaddr
expr_stmt|;
name|op
operator|=
name|bfd_getl32
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|info
operator|->
name|bytes_per_line
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|bytes_per_chunk
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|octets_per_byte
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|display_endian
operator|=
name|BFD_ENDIAN_LITTLE
expr_stmt|;
return|return
name|tic4x_disassemble
argument_list|(
name|pc
argument_list|,
name|op
argument_list|,
name|info
argument_list|)
operator|*
literal|4
return|;
block|}
end_function

end_unit

