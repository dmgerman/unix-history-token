begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* xtensa-dis.c.  Disassembly functions for Xtensa.    Copyright 2003, 2004 Free Software Foundation, Inc.    Contributed by Bob Wilson at Tensilica, Inc. (bwilson@tensilica.com)     This file is part of GDB, GAS, and the GNU binutils.     GDB, GAS, and the GNU binutils are free software; you can redistribute    them and/or modify them under the terms of the GNU General Public    License as published by the Free Software Foundation; either version 2,    or (at your option) any later version.     GDB, GAS, and the GNU binutils are distributed in the hope that they    will be useful, but WITHOUT ANY WARRANTY; without even the implied    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See    the GNU General Public License for more details.     You should have received a copy of the GNU General Public License along    with this file; see the file COPYING.  If not, write to the Free    Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301,    USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"xtensa-isa.h"
end_include

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_decl_stmt
specifier|extern
name|xtensa_isa
name|xtensa_default_isa
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MAX
end_ifndef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(a> b ? a : b)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|show_raw_fields
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|dis_private
block|{
name|bfd_byte
modifier|*
name|byte_buf
decl_stmt|;
name|jmp_buf
name|bailout
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|fetch_data
parameter_list|(
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|bfd_vma
name|memaddr
parameter_list|)
block|{
name|int
name|length
decl_stmt|,
name|status
init|=
literal|0
decl_stmt|;
name|struct
name|dis_private
modifier|*
name|priv
init|=
operator|(
expr|struct
name|dis_private
operator|*
operator|)
name|info
operator|->
name|private_data
decl_stmt|;
name|int
name|insn_size
init|=
name|xtensa_isa_maxlength
argument_list|(
name|xtensa_default_isa
argument_list|)
decl_stmt|;
comment|/* Read the maximum instruction size, padding with zeros if we go past      the end of the text section.  This code will automatically adjust      length when we hit the end of the buffer.  */
name|memset
argument_list|(
name|priv
operator|->
name|byte_buf
argument_list|,
literal|0
argument_list|,
name|insn_size
argument_list|)
expr_stmt|;
for|for
control|(
name|length
operator|=
name|insn_size
init|;
name|length
operator|>
literal|0
condition|;
name|length
operator|--
control|)
block|{
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|memaddr
argument_list|,
name|priv
operator|->
name|byte_buf
argument_list|,
name|length
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
return|return
name|length
return|;
block|}
call|(
modifier|*
name|info
operator|->
name|memory_error_func
call|)
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|priv
operator|->
name|bailout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_function
specifier|static
name|void
name|print_xtensa_operand
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|,
name|unsigned
name|operand_val
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|int
name|signed_operand_val
decl_stmt|;
if|if
condition|(
name|show_raw_fields
condition|)
block|{
if|if
condition|(
name|operand_val
operator|<
literal|0xa
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%u"
argument_list|,
name|operand_val
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
name|operand_val
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|xtensa_operand_decode
argument_list|(
name|isa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|,
operator|&
name|operand_val
argument_list|)
expr_stmt|;
name|signed_operand_val
operator|=
operator|(
name|int
operator|)
name|operand_val
expr_stmt|;
if|if
condition|(
name|xtensa_operand_is_register
argument_list|(
name|isa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|xtensa_operand_is_PCrelative
argument_list|(
name|isa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|)
operator|==
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|xtensa_operand_undo_reloc
argument_list|(
name|isa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|,
operator|&
name|operand_val
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
name|info
operator|->
name|target
operator|=
name|operand_val
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|info
operator|->
name|target
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|signed_operand_val
operator|>
operator|-
literal|256
operator|)
operator|&&
operator|(
name|signed_operand_val
operator|<
literal|256
operator|)
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|signed_operand_val
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
name|signed_operand_val
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|i
init|=
literal|1
decl_stmt|;
name|xtensa_regfile
name|opnd_rf
init|=
name|xtensa_operand_regfile
argument_list|(
name|isa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|)
decl_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s%u"
argument_list|,
name|xtensa_regfile_shortname
argument_list|(
name|isa
argument_list|,
name|opnd_rf
argument_list|)
argument_list|,
name|operand_val
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|xtensa_operand_num_regs
argument_list|(
name|isa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|)
condition|)
block|{
name|operand_val
operator|++
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|":%s%u"
argument_list|,
name|xtensa_regfile_shortname
argument_list|(
name|isa
argument_list|,
name|opnd_rf
argument_list|)
argument_list|,
name|operand_val
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Print the Xtensa instruction at address MEMADDR on info->stream.    Returns length of the instruction in bytes.  */
end_comment

begin_function
name|int
name|print_insn_xtensa
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|unsigned
name|operand_val
decl_stmt|;
name|int
name|bytes_fetched
decl_stmt|,
name|size
decl_stmt|,
name|maxsize
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|,
name|noperands
decl_stmt|,
name|nslots
decl_stmt|;
name|xtensa_isa
name|isa
decl_stmt|;
name|xtensa_opcode
name|opc
decl_stmt|;
name|xtensa_format
name|fmt
decl_stmt|;
name|struct
name|dis_private
name|priv
decl_stmt|;
specifier|static
name|bfd_byte
modifier|*
name|byte_buf
init|=
name|NULL
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|insn_buffer
init|=
name|NULL
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|slot_buffer
init|=
name|NULL
decl_stmt|;
name|int
name|first
decl_stmt|,
name|first_slot
decl_stmt|,
name|valid_insn
decl_stmt|;
if|if
condition|(
operator|!
name|xtensa_default_isa
condition|)
name|xtensa_default_isa
operator|=
name|xtensa_isa_init
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|info
operator|->
name|target
operator|=
literal|0
expr_stmt|;
name|maxsize
operator|=
name|xtensa_isa_maxlength
argument_list|(
name|xtensa_default_isa
argument_list|)
expr_stmt|;
comment|/* Set bytes_per_line to control the amount of whitespace between the hex      values and the opcode.  For Xtensa, we always print one "chunk" and we      vary bytes_per_chunk to determine how many bytes to print.  (objdump      would apparently prefer that we set bytes_per_chunk to 1 and vary      bytes_per_line but that makes it hard to fit 64-bit instructions on      an 80-column screen.)  The value of bytes_per_line here is not exactly      right, because objdump adds an extra space for each chunk so that the      amount of whitespace depends on the chunk size.  Oh well, it's good      enough....  Note that we set the minimum size to 4 to accomodate      literal pools.  */
name|info
operator|->
name|bytes_per_line
operator|=
name|MAX
argument_list|(
name|maxsize
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Allocate buffers the first time through.  */
if|if
condition|(
operator|!
name|insn_buffer
condition|)
block|{
name|insn_buffer
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|xtensa_default_isa
argument_list|)
expr_stmt|;
name|slot_buffer
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|xtensa_default_isa
argument_list|)
expr_stmt|;
name|byte_buf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|xmalloc
argument_list|(
name|MAX
argument_list|(
name|maxsize
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|priv
operator|.
name|byte_buf
operator|=
name|byte_buf
expr_stmt|;
name|info
operator|->
name|private_data
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|priv
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|priv
operator|.
name|bailout
argument_list|)
operator|!=
literal|0
condition|)
comment|/* Error return.  */
return|return
operator|-
literal|1
return|;
comment|/* Don't set "isa" before the setjmp to keep the compiler from griping.  */
name|isa
operator|=
name|xtensa_default_isa
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
name|nslots
operator|=
literal|0
expr_stmt|;
comment|/* Fetch the maximum size instruction.  */
name|bytes_fetched
operator|=
name|fetch_data
argument_list|(
name|info
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
comment|/* Copy the bytes into the decode buffer.  */
name|memset
argument_list|(
name|insn_buffer
argument_list|,
literal|0
argument_list|,
operator|(
name|xtensa_insnbuf_size
argument_list|(
name|isa
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|xtensa_insnbuf_word
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insn_buffer
argument_list|,
name|priv
operator|.
name|byte_buf
argument_list|,
name|bytes_fetched
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|xtensa_format_decode
argument_list|(
name|isa
argument_list|,
name|insn_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|XTENSA_UNDEFINED
operator|||
operator|(
operator|(
name|size
operator|=
name|xtensa_format_length
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
operator|)
operator|>
name|bytes_fetched
operator|)
condition|)
name|valid_insn
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Make sure all the opcodes are valid.  */
name|valid_insn
operator|=
literal|1
expr_stmt|;
name|nslots
operator|=
name|xtensa_format_num_slots
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nslots
condition|;
name|n
operator|++
control|)
block|{
name|xtensa_format_get_slot
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|n
argument_list|,
name|insn_buffer
argument_list|,
name|slot_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|xtensa_opcode_decode
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|n
argument_list|,
name|slot_buffer
argument_list|)
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
name|valid_insn
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|valid_insn
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|".byte %#02x"
argument_list|,
name|priv
operator|.
name|byte_buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|nslots
operator|>
literal|1
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"{ "
argument_list|)
expr_stmt|;
name|first_slot
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nslots
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|first_slot
condition|)
name|first_slot
operator|=
literal|0
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"; "
argument_list|)
expr_stmt|;
name|xtensa_format_get_slot
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|n
argument_list|,
name|insn_buffer
argument_list|,
name|slot_buffer
argument_list|)
expr_stmt|;
name|opc
operator|=
name|xtensa_opcode_decode
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|n
argument_list|,
name|slot_buffer
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|opc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Print the operands (if any).  */
name|noperands
operator|=
name|xtensa_opcode_num_operands
argument_list|(
name|isa
argument_list|,
name|opc
argument_list|)
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|xtensa_operand_is_visible
argument_list|(
name|isa
argument_list|,
name|opc
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|first
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xtensa_operand_get_field
argument_list|(
name|isa
argument_list|,
name|opc
argument_list|,
name|i
argument_list|,
name|fmt
argument_list|,
name|n
argument_list|,
name|slot_buffer
argument_list|,
operator|&
name|operand_val
argument_list|)
expr_stmt|;
name|print_xtensa_operand
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|,
name|opc
argument_list|,
name|i
argument_list|,
name|operand_val
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nslots
operator|>
literal|1
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|" }"
argument_list|)
expr_stmt|;
name|info
operator|->
name|bytes_per_chunk
operator|=
name|size
expr_stmt|;
name|info
operator|->
name|display_endian
operator|=
name|info
operator|->
name|endian
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

end_unit

