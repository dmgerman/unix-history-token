begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Instruction printing code for the AMD 29000    Copyright 1990, 1993, 1994, 1995, 1998, 2000, 2001, 2002    Free Software Foundation, Inc.    Contributed by Cygnus Support.  Written by Jim Kingdon.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"opcode/a29k.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|print_general
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_special
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
expr|struct
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_delayed_branch
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_bytes_little
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_bytes_big
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|print_insn
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
expr|struct
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print a symbolic representation of a general-purpose    register number NUM on STREAM.    NUM is a number as found in the instruction, not as found in    debugging symbols; it must be in the range 0-255.  */
end_comment

begin_function
specifier|static
name|void
name|print_general
parameter_list|(
name|num
parameter_list|,
name|info
parameter_list|)
name|int
name|num
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
if|if
condition|(
name|num
operator|<
literal|128
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"gr%d"
argument_list|,
name|num
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"lr%d"
argument_list|,
name|num
operator|-
literal|128
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like print_general but a special-purpose register.     The mnemonics used by the AMD assembler are not quite the same    as the ones in the User's Manual.  We use the ones that the    assembler uses.  */
end_comment

begin_function
specifier|static
name|void
name|print_special
parameter_list|(
name|num
parameter_list|,
name|info
parameter_list|)
name|unsigned
name|int
name|num
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
comment|/* Register names of registers 0-SPEC0_NUM-1.  */
specifier|static
name|char
modifier|*
name|spec0_names
index|[]
init|=
block|{
literal|"vab"
block|,
literal|"ops"
block|,
literal|"cps"
block|,
literal|"cfg"
block|,
literal|"cha"
block|,
literal|"chd"
block|,
literal|"chc"
block|,
literal|"rbp"
block|,
literal|"tmc"
block|,
literal|"tmr"
block|,
literal|"pc0"
block|,
literal|"pc1"
block|,
literal|"pc2"
block|,
literal|"mmu"
block|,
literal|"lru"
block|,
literal|"rsn"
block|,
literal|"rma0"
block|,
literal|"rmc0"
block|,
literal|"rma1"
block|,
literal|"rmc1"
block|,
literal|"spc0"
block|,
literal|"spc1"
block|,
literal|"spc2"
block|,
literal|"iba0"
block|,
literal|"ibc0"
block|,
literal|"iba1"
block|,
literal|"ibc1"
block|,
literal|"dba"
block|,
literal|"dbc"
block|,
literal|"cir"
block|,
literal|"cdr"
block|}
decl_stmt|;
define|#
directive|define
name|SPEC0_NUM
value|((sizeof spec0_names) / (sizeof spec0_names[0]))
comment|/* Register names of registers 128-128+SPEC128_NUM-1.  */
specifier|static
name|char
modifier|*
name|spec128_names
index|[]
init|=
block|{
literal|"ipc"
block|,
literal|"ipa"
block|,
literal|"ipb"
block|,
literal|"q"
block|,
literal|"alu"
block|,
literal|"bp"
block|,
literal|"fc"
block|,
literal|"cr"
block|}
decl_stmt|;
define|#
directive|define
name|SPEC128_NUM
value|((sizeof spec128_names) / (sizeof spec128_names[0]))
comment|/* Register names of registers 160-160+SPEC160_NUM-1.  */
specifier|static
name|char
modifier|*
name|spec160_names
index|[]
init|=
block|{
literal|"fpe"
block|,
literal|"inte"
block|,
literal|"fps"
block|,
literal|"sr163"
block|,
literal|"exop"
block|}
decl_stmt|;
define|#
directive|define
name|SPEC160_NUM
value|((sizeof spec160_names) / (sizeof spec160_names[0]))
if|if
condition|(
name|num
operator|<
name|SPEC0_NUM
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
name|spec0_names
index|[
name|num
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|>=
literal|128
operator|&&
name|num
operator|<
literal|128
operator|+
name|SPEC128_NUM
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
name|spec128_names
index|[
name|num
operator|-
literal|128
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num
operator|>=
literal|160
operator|&&
name|num
operator|<
literal|160
operator|+
name|SPEC160_NUM
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
name|spec160_names
index|[
name|num
operator|-
literal|160
index|]
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"sr%d"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Is an instruction with OPCODE a delayed branch?  */
end_comment

begin_function
specifier|static
name|int
name|is_delayed_branch
parameter_list|(
name|opcode
parameter_list|)
name|int
name|opcode
decl_stmt|;
block|{
return|return
operator|(
name|opcode
operator|==
literal|0xa8
operator|||
name|opcode
operator|==
literal|0xa9
operator|||
name|opcode
operator|==
literal|0xa0
operator|||
name|opcode
operator|==
literal|0xa1
operator|||
name|opcode
operator|==
literal|0xa4
operator|||
name|opcode
operator|==
literal|0xa5
operator|||
name|opcode
operator|==
literal|0xb4
operator|||
name|opcode
operator|==
literal|0xb5
operator|||
name|opcode
operator|==
literal|0xc4
operator|||
name|opcode
operator|==
literal|0xc0
operator|||
name|opcode
operator|==
literal|0xac
operator|||
name|opcode
operator|==
literal|0xad
operator|||
name|opcode
operator|==
literal|0xcc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Now find the four bytes of INSN and put them in *INSN{0,8,16,24}.  */
end_comment

begin_function
specifier|static
name|void
name|find_bytes_big
parameter_list|(
name|insn
parameter_list|,
name|insn0
parameter_list|,
name|insn8
parameter_list|,
name|insn16
parameter_list|,
name|insn24
parameter_list|)
name|char
modifier|*
name|insn
decl_stmt|;
name|unsigned
name|char
modifier|*
name|insn0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|insn8
decl_stmt|;
name|unsigned
name|char
modifier|*
name|insn16
decl_stmt|;
name|unsigned
name|char
modifier|*
name|insn24
decl_stmt|;
block|{
operator|*
name|insn24
operator|=
name|insn
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|insn16
operator|=
name|insn
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|insn8
operator|=
name|insn
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|insn0
operator|=
name|insn
index|[
literal|3
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|find_bytes_little
parameter_list|(
name|insn
parameter_list|,
name|insn0
parameter_list|,
name|insn8
parameter_list|,
name|insn16
parameter_list|,
name|insn24
parameter_list|)
name|char
modifier|*
name|insn
decl_stmt|;
name|unsigned
name|char
modifier|*
name|insn0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|insn8
decl_stmt|;
name|unsigned
name|char
modifier|*
name|insn16
decl_stmt|;
name|unsigned
name|char
modifier|*
name|insn24
decl_stmt|;
block|{
operator|*
name|insn24
operator|=
name|insn
index|[
literal|3
index|]
expr_stmt|;
operator|*
name|insn16
operator|=
name|insn
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|insn8
operator|=
name|insn
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|insn0
operator|=
name|insn
index|[
literal|0
index|]
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
name|void
argument_list|(
argument|*find_byte_func_type
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_comment
comment|/* Print one instruction from MEMADDR on INFO->STREAM.    Return the size of the instruction (always 4 on a29k).  */
end_comment

begin_function
specifier|static
name|int
name|print_insn
parameter_list|(
name|memaddr
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|memaddr
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
comment|/* The raw instruction.  */
name|char
name|insn
index|[
literal|4
index|]
decl_stmt|;
comment|/* The four bytes of the instruction.  */
name|unsigned
name|char
name|insn24
decl_stmt|,
name|insn16
decl_stmt|,
name|insn8
decl_stmt|,
name|insn0
decl_stmt|;
name|find_byte_func_type
name|find_byte_func
init|=
operator|(
name|find_byte_func_type
operator|)
name|info
operator|->
name|private_data
decl_stmt|;
name|struct
name|a29k_opcode
specifier|const
modifier|*
name|opcode
decl_stmt|;
block|{
name|int
name|status
init|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|memaddr
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|&
name|insn
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|memory_error_func
call|)
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
call|(
modifier|*
name|find_byte_func
call|)
argument_list|(
name|insn
argument_list|,
operator|&
name|insn0
argument_list|,
operator|&
name|insn8
argument_list|,
operator|&
name|insn16
argument_list|,
operator|&
name|insn24
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%02x%02x%02x%02x "
argument_list|,
name|insn24
argument_list|,
name|insn16
argument_list|,
name|insn8
argument_list|,
name|insn0
argument_list|)
expr_stmt|;
comment|/* Handle the nop (aseq 0x40,gr1,gr1) specially */
if|if
condition|(
operator|(
name|insn24
operator|==
literal|0x70
operator|)
operator|&&
operator|(
name|insn16
operator|==
literal|0x40
operator|)
operator|&&
operator|(
name|insn8
operator|==
literal|0x01
operator|)
operator|&&
operator|(
name|insn0
operator|==
literal|0x01
operator|)
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"nop"
argument_list|)
expr_stmt|;
return|return
literal|4
return|;
block|}
comment|/* The opcode is always in insn24.  */
for|for
control|(
name|opcode
operator|=
operator|&
name|a29k_opcodes
index|[
literal|0
index|]
init|;
name|opcode
operator|<
operator|&
name|a29k_opcodes
index|[
name|num_opcodes
index|]
condition|;
operator|++
name|opcode
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|insn24
operator|<<
literal|24
operator|)
operator|==
name|opcode
operator|->
name|opcode
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s "
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|opcode
operator|->
name|args
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
operator|++
name|s
control|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'a'
case|:
name|print_general
argument_list|(
name|insn8
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|print_general
argument_list|(
name|insn0
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|print_general
argument_list|(
name|insn16
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|insn0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
operator|(
name|insn16
operator|<<
literal|8
operator|)
operator|+
name|insn0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* This used to be %x for binutils.  */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
operator|(
name|insn16
operator|<<
literal|24
operator|)
operator|+
operator|(
name|insn0
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
operator|(
operator|(
name|insn16
operator|<<
literal|8
operator|)
operator|+
name|insn0
operator|)
operator||
literal|0xffff0000
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* This output looks just like absolute addressing, but 		     maybe that's OK (it's what the GDB m68k and EBMON 		     a29k disassemblers do).  */
comment|/* All the shifting is to sign-extend it.  p*/
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|memaddr
operator|+
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
operator|(
name|insn16
operator|<<
literal|10
operator|)
operator|+
operator|(
name|insn0
operator|<<
literal|2
operator|)
argument_list|)
operator|<<
literal|14
operator|)
operator|>>
literal|14
operator|)
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
operator|(
name|insn16
operator|<<
literal|10
operator|)
operator|+
operator|(
name|insn0
operator|<<
literal|2
operator|)
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|insn16
operator|>>
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
name|insn16
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
name|insn16
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|print_special
argument_list|(
name|insn8
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|insn0
operator|>>
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|insn0
operator|>>
literal|4
operator|)
operator|&
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
operator|(
name|insn16
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|insn16
operator|&
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|insn0
operator|>>
literal|2
operator|)
operator|&
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|insn0
operator|&
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|insn16
operator|>>
literal|2
operator|)
operator|&
literal|15
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|insn16
operator|&
literal|3
argument_list|)
expr_stmt|;
break|break;
default|default:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now we look for a const,consth pair of instructions, 	     in which case we try to print the symbolic address.  */
if|if
condition|(
name|insn24
operator|==
literal|2
condition|)
comment|/* consth */
block|{
name|int
name|errcode
decl_stmt|;
name|char
name|prev_insn
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|char
name|prev_insn0
decl_stmt|,
name|prev_insn8
decl_stmt|,
name|prev_insn16
decl_stmt|,
name|prev_insn24
decl_stmt|;
name|errcode
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|memaddr
operator|-
literal|4
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|&
name|prev_insn
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|==
literal|0
condition|)
block|{
comment|/* If it is a delayed branch, we need to look at the 		     instruction before the delayed brach to handle 		     things like  		     const _foo 		     call _printf 		     consth _foo 		     */
call|(
modifier|*
name|find_byte_func
call|)
argument_list|(
name|prev_insn
argument_list|,
operator|&
name|prev_insn0
argument_list|,
operator|&
name|prev_insn8
argument_list|,
operator|&
name|prev_insn16
argument_list|,
operator|&
name|prev_insn24
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_delayed_branch
argument_list|(
name|prev_insn24
argument_list|)
condition|)
block|{
name|errcode
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|memaddr
operator|-
literal|8
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|&
name|prev_insn
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
call|(
modifier|*
name|find_byte_func
call|)
argument_list|(
name|prev_insn
argument_list|,
operator|&
name|prev_insn0
argument_list|,
operator|&
name|prev_insn8
argument_list|,
operator|&
name|prev_insn16
argument_list|,
operator|&
name|prev_insn24
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If there was a problem reading memory, then assume 		 the previous instruction was not const.  */
if|if
condition|(
name|errcode
operator|==
literal|0
condition|)
block|{
comment|/* Is it const to the same register?  */
if|if
condition|(
name|prev_insn24
operator|==
literal|3
operator|&&
name|prev_insn8
operator|==
name|insn8
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"\t; "
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
operator|(
operator|(
name|insn16
operator|<<
literal|24
operator|)
operator|+
operator|(
name|insn0
operator|<<
literal|16
operator|)
operator|+
operator|(
name|prev_insn16
operator|<<
literal|8
operator|)
operator|+
operator|(
name|prev_insn0
operator|)
operator|)
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|4
return|;
block|}
block|}
comment|/* This used to be %8x for binutils.  */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|".word 0x%08x"
argument_list|,
operator|(
name|insn24
operator|<<
literal|24
operator|)
operator|+
operator|(
name|insn16
operator|<<
literal|16
operator|)
operator|+
operator|(
name|insn8
operator|<<
literal|8
operator|)
operator|+
name|insn0
argument_list|)
expr_stmt|;
return|return
literal|4
return|;
block|}
end_function

begin_comment
comment|/* Disassemble an big-endian a29k instruction.  */
end_comment

begin_function
name|int
name|print_insn_big_a29k
parameter_list|(
name|memaddr
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|memaddr
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
name|info
operator|->
name|private_data
operator|=
operator|(
name|PTR
operator|)
name|find_bytes_big
expr_stmt|;
return|return
name|print_insn
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Disassemble a little-endian a29k instruction.  */
end_comment

begin_function
name|int
name|print_insn_little_a29k
parameter_list|(
name|memaddr
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|memaddr
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
name|info
operator|->
name|private_data
operator|=
operator|(
name|PTR
operator|)
name|find_bytes_little
expr_stmt|;
return|return
name|print_insn
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
return|;
block|}
end_function

end_unit

