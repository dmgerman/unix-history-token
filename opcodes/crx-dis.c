begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Disassembler code for CRX.    Copyright 2004, 2005 Free Software Foundation, Inc.    Contributed by Tomer Levi, NSC, Israel.    Written by Tomer Levi.     This file is part of the GNU binutils and GDB, the GNU debugger.     This program is free software; you can redistribute it and/or modify it under    the terms of the GNU General Public License as published by the Free    Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for    more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"opcode/crx.h"
end_include

begin_comment
comment|/* String to print when opcode was not matched.  */
end_comment

begin_define
define|#
directive|define
name|ILLEGAL
value|"illegal"
end_define

begin_comment
comment|/* Escape to 16-bit immediate.  */
end_comment

begin_define
define|#
directive|define
name|ESCAPE_16_BIT
value|0xE
end_define

begin_comment
comment|/* Extract 'n_bits' from 'a' starting from offset 'offs'.  */
end_comment

begin_define
define|#
directive|define
name|EXTRACT
parameter_list|(
name|a
parameter_list|,
name|offs
parameter_list|,
name|n_bits
parameter_list|)
define|\
value|(n_bits == 32 ? (((a)>> (offs))& 0xffffffffL)   \   : (((a)>> (offs))& ((1<< (n_bits)) -1)))
end_define

begin_comment
comment|/* Set Bit Mask - a mask to set all bits starting from offset 'offs'.  */
end_comment

begin_define
define|#
directive|define
name|SBM
parameter_list|(
name|offs
parameter_list|)
value|((((1<< (32 - offs)) -1)<< (offs)))
end_define

begin_typedef
typedef|typedef
name|unsigned
name|long
name|dwordU
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|short
name|wordU
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|dwordU
name|val
decl_stmt|;
name|int
name|nbits
decl_stmt|;
block|}
name|parameter
typedef|;
end_typedef

begin_comment
comment|/* Structure to hold valid 'cinv' instruction options.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* Cinv printed string.  */
name|char
modifier|*
name|str
decl_stmt|;
comment|/* Value corresponding to the string.  */
name|unsigned
name|int
name|value
decl_stmt|;
block|}
name|cinv_entry
typedef|;
end_typedef

begin_comment
comment|/* CRX 'cinv' options.  */
end_comment

begin_decl_stmt
specifier|const
name|cinv_entry
name|crx_cinvs
index|[]
init|=
block|{
block|{
literal|"[i]"
block|,
literal|2
block|}
block|,
block|{
literal|"[i,u]"
block|,
literal|3
block|}
block|,
block|{
literal|"[d]"
block|,
literal|4
block|}
block|,
block|{
literal|"[d,u]"
block|,
literal|5
block|}
block|,
block|{
literal|"[d,i]"
block|,
literal|6
block|}
block|,
block|{
literal|"[d,i,u]"
block|,
literal|7
block|}
block|,
block|{
literal|"[b]"
block|,
literal|8
block|}
block|,
block|{
literal|"[b,i]"
block|,
literal|10
block|}
block|,
block|{
literal|"[b,i,u]"
block|,
literal|11
block|}
block|,
block|{
literal|"[b,d]"
block|,
literal|12
block|}
block|,
block|{
literal|"[b,d,u]"
block|,
literal|13
block|}
block|,
block|{
literal|"[b,d,i]"
block|,
literal|14
block|}
block|,
block|{
literal|"[b,d,i,u]"
block|,
literal|15
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Enum to distinguish different registers argument types.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|REG_ARG_TYPE
block|{
comment|/* General purpose register (r<N>).  */
name|REG_ARG
init|=
literal|0
block|,
comment|/* User register (u<N>).  */
name|USER_REG_ARG
block|,
comment|/* CO-Processor register (c<N>).  */
name|COP_ARG
block|,
comment|/* CO-Processor special register (cs<N>).  */
name|COPS_ARG
block|}
name|REG_ARG_TYPE
typedef|;
end_typedef

begin_comment
comment|/* Number of valid 'cinv' instruction options.  */
end_comment

begin_decl_stmt
name|int
name|NUMCINVS
init|=
operator|(
operator|(
sizeof|sizeof
name|crx_cinvs
operator|)
operator|/
operator|(
sizeof|sizeof
name|crx_cinvs
index|[
literal|0
index|]
operator|)
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current opcode table entry we're disassembling.  */
end_comment

begin_decl_stmt
specifier|const
name|inst
modifier|*
name|instruction
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current instruction we're disassembling.  */
end_comment

begin_decl_stmt
name|ins
name|currInsn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current instruction is read into 3 consecutive words.  */
end_comment

begin_decl_stmt
name|wordU
name|words
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Contains all words in appropriate order.  */
end_comment

begin_decl_stmt
name|ULONGLONG
name|allWords
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds the current processed argument number.  */
end_comment

begin_decl_stmt
name|int
name|processing_argument_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means a CST4 instruction.  */
end_comment

begin_decl_stmt
name|int
name|cst4flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means the instruction's original size is    incremented (escape sequence is used).  */
end_comment

begin_decl_stmt
name|int
name|size_changed
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|get_number_of_operands
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|argtype
name|getargtype
parameter_list|(
name|operand_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getbits
parameter_list|(
name|operand_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|getregname
parameter_list|(
name|reg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|getcopregname
parameter_list|(
name|copreg
parameter_list|,
name|reg_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|getprocregname
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|gettrapstring
parameter_list|(
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|getcinvstring
parameter_list|(
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|getregliststring
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|enum
name|REG_ARG_TYPE
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|wordU
name|get_word_at_PC
parameter_list|(
name|bfd_vma
parameter_list|,
name|struct
name|disassemble_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_words_at_PC
parameter_list|(
name|bfd_vma
parameter_list|,
name|struct
name|disassemble_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|build_mask
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|powerof2
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|match_opcode
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_instruction
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_arguments
parameter_list|(
name|ins
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|struct
name|disassemble_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_arg
parameter_list|(
name|argument
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|struct
name|disassemble_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Retrieve the number of operands for the current assembled instruction.  */
end_comment

begin_function
specifier|static
name|int
name|get_number_of_operands
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|instruction
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|op_type
operator|&&
name|i
operator|<
name|MAX_OPERANDS
condition|;
name|i
operator|++
control|)
empty_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Return the bit size for a given operand.  */
end_comment

begin_function
specifier|static
name|int
name|getbits
parameter_list|(
name|operand_type
name|op
parameter_list|)
block|{
if|if
condition|(
name|op
operator|<
name|MAX_OPRD
condition|)
return|return
name|crx_optab
index|[
name|op
index|]
operator|.
name|bit_size
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the argument type of a given operand.  */
end_comment

begin_function
specifier|static
name|argtype
name|getargtype
parameter_list|(
name|operand_type
name|op
parameter_list|)
block|{
if|if
condition|(
name|op
operator|<
name|MAX_OPRD
condition|)
return|return
name|crx_optab
index|[
name|op
index|]
operator|.
name|arg_type
return|;
else|else
return|return
name|nullargs
return|;
block|}
end_function

begin_comment
comment|/* Given the trap index in dispatch table, return its name.    This routine is used when disassembling the 'excp' instruction.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|gettrapstring
parameter_list|(
name|unsigned
name|int
name|index
parameter_list|)
block|{
specifier|const
name|trap_entry
modifier|*
name|trap
decl_stmt|;
for|for
control|(
name|trap
operator|=
name|crx_traps
init|;
name|trap
operator|<
name|crx_traps
operator|+
name|NUMTRAPS
condition|;
name|trap
operator|++
control|)
if|if
condition|(
name|trap
operator|->
name|entry
operator|==
name|index
condition|)
return|return
name|trap
operator|->
name|name
return|;
return|return
name|ILLEGAL
return|;
block|}
end_function

begin_comment
comment|/* Given a 'cinv' instruction constant operand, return its corresponding string.    This routine is used when disassembling the 'cinv' instruction.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|getcinvstring
parameter_list|(
name|unsigned
name|int
name|num
parameter_list|)
block|{
specifier|const
name|cinv_entry
modifier|*
name|cinv
decl_stmt|;
for|for
control|(
name|cinv
operator|=
name|crx_cinvs
init|;
name|cinv
operator|<
operator|(
name|crx_cinvs
operator|+
name|NUMCINVS
operator|)
condition|;
name|cinv
operator|++
control|)
if|if
condition|(
name|cinv
operator|->
name|value
operator|==
name|num
condition|)
return|return
name|cinv
operator|->
name|str
return|;
return|return
name|ILLEGAL
return|;
block|}
end_function

begin_comment
comment|/* Given a register enum value, retrieve its name.  */
end_comment

begin_function
name|char
modifier|*
name|getregname
parameter_list|(
name|reg
name|r
parameter_list|)
block|{
specifier|const
name|reg_entry
modifier|*
name|reg
init|=
operator|&
name|crx_regtab
index|[
name|r
index|]
decl_stmt|;
if|if
condition|(
name|reg
operator|->
name|type
operator|!=
name|CRX_R_REGTYPE
condition|)
return|return
name|ILLEGAL
return|;
else|else
return|return
name|reg
operator|->
name|name
return|;
block|}
end_function

begin_comment
comment|/* Given a coprocessor register enum value, retrieve its name.  */
end_comment

begin_function
name|char
modifier|*
name|getcopregname
parameter_list|(
name|copreg
name|r
parameter_list|,
name|reg_type
name|type
parameter_list|)
block|{
specifier|const
name|reg_entry
modifier|*
name|reg
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|CRX_C_REGTYPE
condition|)
name|reg
operator|=
operator|&
name|crx_copregtab
index|[
name|r
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|CRX_CS_REGTYPE
condition|)
name|reg
operator|=
operator|&
name|crx_copregtab
index|[
name|r
operator|+
operator|(
name|cs0
operator|-
name|c0
operator|)
index|]
expr_stmt|;
else|else
return|return
name|ILLEGAL
return|;
return|return
name|reg
operator|->
name|name
return|;
block|}
end_function

begin_comment
comment|/* Getting a processor register name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|getprocregname
parameter_list|(
name|int
name|index
parameter_list|)
block|{
specifier|const
name|reg_entry
modifier|*
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
name|crx_regtab
init|;
name|r
operator|<
name|crx_regtab
operator|+
name|NUMREGS
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|r
operator|->
name|image
operator|==
name|index
condition|)
return|return
name|r
operator|->
name|name
return|;
return|return
literal|"ILLEGAL REGISTER"
return|;
block|}
end_function

begin_comment
comment|/* Get the power of two for a given integer.  */
end_comment

begin_function
specifier|static
name|int
name|powerof2
parameter_list|(
name|int
name|x
parameter_list|)
block|{
name|int
name|product
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|product
operator|=
literal|1
init|;
name|i
operator|<
name|x
condition|;
name|i
operator|++
control|)
name|product
operator|*=
literal|2
expr_stmt|;
return|return
name|product
return|;
block|}
end_function

begin_comment
comment|/* Transform a register bit mask to a register list.  */
end_comment

begin_function
name|void
name|getregliststring
parameter_list|(
name|int
name|mask
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|enum
name|REG_ARG_TYPE
name|core_cop
parameter_list|)
block|{
name|char
name|temp_string
index|[
literal|5
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|string
index|[
literal|0
index|]
operator|=
literal|'{'
expr_stmt|;
name|string
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* A zero mask means HI/LO registers.  */
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|core_cop
operator|==
name|USER_REG_ARG
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|"ulo,uhi"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|string
argument_list|,
literal|"lo,hi"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
literal|0x1
condition|)
block|{
switch|switch
condition|(
name|core_cop
condition|)
block|{
case|case
name|REG_ARG
case|:
name|sprintf
argument_list|(
name|temp_string
argument_list|,
literal|"r%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|USER_REG_ARG
case|:
name|sprintf
argument_list|(
name|temp_string
argument_list|,
literal|"u%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|COP_ARG
case|:
name|sprintf
argument_list|(
name|temp_string
argument_list|,
literal|"c%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|COPS_ARG
case|:
name|sprintf
argument_list|(
name|temp_string
argument_list|,
literal|"cs%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|strcat
argument_list|(
name|string
argument_list|,
name|temp_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
literal|0xfffe
condition|)
name|strcat
argument_list|(
name|string
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
name|strcat
argument_list|(
name|string
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* START and END are relating 'allWords' struct, which is 48 bits size.  			  START|--------|END 	    +---------+---------+---------+---------+ 	    |	      |	   V    |     A	  |   L	    | 	    +---------+---------+---------+---------+ 	    	      0		16	  32	    48     words		  [0]	    [1]	      [2]	*/
end_comment

begin_function
specifier|static
name|parameter
name|makelongparameter
parameter_list|(
name|ULONGLONG
name|val
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|parameter
name|p
decl_stmt|;
name|p
operator|.
name|val
operator|=
operator|(
name|dwordU
operator|)
name|EXTRACT
argument_list|(
name|val
argument_list|,
literal|48
operator|-
name|end
argument_list|,
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|p
operator|.
name|nbits
operator|=
name|end
operator|-
name|start
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Build a mask of the instruction's 'constant' opcode,    based on the instruction's printing flags.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|build_mask
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|print_flags
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
name|print_flags
operator|=
name|instruction
operator|->
name|flags
operator|&
name|FMT_CRX
expr_stmt|;
switch|switch
condition|(
name|print_flags
condition|)
block|{
case|case
name|FMT_1
case|:
name|mask
operator|=
literal|0xF0F00000
expr_stmt|;
break|break;
case|case
name|FMT_2
case|:
name|mask
operator|=
literal|0xFFF0FF00
expr_stmt|;
break|break;
case|case
name|FMT_3
case|:
name|mask
operator|=
literal|0xFFF00F00
expr_stmt|;
break|break;
case|case
name|FMT_4
case|:
name|mask
operator|=
literal|0xFFF0F000
expr_stmt|;
break|break;
case|case
name|FMT_5
case|:
name|mask
operator|=
literal|0xFFF0FFF0
expr_stmt|;
break|break;
default|default:
name|mask
operator|=
name|SBM
argument_list|(
name|instruction
operator|->
name|match_bits
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|mask
return|;
block|}
end_function

begin_comment
comment|/* Search for a matching opcode. Return 1 for success, 0 for failure.  */
end_comment

begin_function
specifier|static
name|int
name|match_opcode
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|mask
decl_stmt|;
comment|/* The instruction 'constant' opcode doewsn't exceed 32 bits.  */
name|unsigned
name|long
name|doubleWord
init|=
name|words
index|[
literal|1
index|]
operator|+
operator|(
name|words
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
decl_stmt|;
comment|/* Start searching from end of instruction table.  */
name|instruction
operator|=
operator|&
name|crx_instruction
index|[
name|NUMOPCODES
operator|-
literal|2
index|]
expr_stmt|;
comment|/* Loop over instruction table until a full match is found.  */
while|while
condition|(
name|instruction
operator|>=
name|crx_instruction
condition|)
block|{
name|mask
operator|=
name|build_mask
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|doubleWord
operator|&
name|mask
operator|)
operator|==
name|BIN
argument_list|(
name|instruction
operator|->
name|match
argument_list|,
name|instruction
operator|->
name|match_bits
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
name|instruction
operator|--
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Set the proper parameter value for different type of arguments.  */
end_comment

begin_function
specifier|static
name|void
name|make_argument
parameter_list|(
name|argument
modifier|*
name|a
parameter_list|,
name|int
name|start_bits
parameter_list|)
block|{
name|int
name|inst_bit_size
decl_stmt|,
name|total_size
decl_stmt|;
name|parameter
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|instruction
operator|->
name|size
operator|==
literal|3
operator|)
operator|&&
name|a
operator|->
name|size
operator|>=
literal|16
condition|)
name|inst_bit_size
operator|=
literal|48
expr_stmt|;
else|else
name|inst_bit_size
operator|=
literal|32
expr_stmt|;
switch|switch
condition|(
name|a
operator|->
name|type
condition|)
block|{
case|case
name|arg_copr
case|:
case|case
name|arg_copsr
case|:
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
operator|-
operator|(
name|start_bits
operator|+
name|a
operator|->
name|size
operator|)
argument_list|,
name|inst_bit_size
operator|-
name|start_bits
argument_list|)
expr_stmt|;
name|a
operator|->
name|cr
operator|=
name|p
operator|.
name|val
expr_stmt|;
break|break;
case|case
name|arg_r
case|:
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
operator|-
operator|(
name|start_bits
operator|+
name|a
operator|->
name|size
operator|)
argument_list|,
name|inst_bit_size
operator|-
name|start_bits
argument_list|)
expr_stmt|;
name|a
operator|->
name|r
operator|=
name|p
operator|.
name|val
expr_stmt|;
break|break;
case|case
name|arg_ic
case|:
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
operator|-
operator|(
name|start_bits
operator|+
name|a
operator|->
name|size
operator|)
argument_list|,
name|inst_bit_size
operator|-
name|start_bits
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|.
name|nbits
operator|==
literal|4
operator|)
operator|&&
name|cst4flag
condition|)
block|{
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|CMPBR_INS
argument_list|)
operator|&&
operator|(
name|p
operator|.
name|val
operator|==
name|ESCAPE_16_BIT
operator|)
condition|)
block|{
comment|/* A special case, where the value is actually stored 		 in the last 4 bits.  */
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
literal|44
argument_list|,
literal|48
argument_list|)
expr_stmt|;
comment|/* The size of the instruction should be incremented.  */
name|size_changed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|.
name|val
operator|==
literal|6
condition|)
name|p
operator|.
name|val
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|.
name|val
operator|==
literal|13
condition|)
name|p
operator|.
name|val
operator|=
literal|48
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|.
name|val
operator|==
literal|5
condition|)
name|p
operator|.
name|val
operator|=
operator|-
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|.
name|val
operator|==
literal|10
condition|)
name|p
operator|.
name|val
operator|=
literal|32
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|.
name|val
operator|==
literal|11
condition|)
name|p
operator|.
name|val
operator|=
literal|20
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|.
name|val
operator|==
literal|9
condition|)
name|p
operator|.
name|val
operator|=
literal|16
expr_stmt|;
block|}
name|a
operator|->
name|constant
operator|=
name|p
operator|.
name|val
expr_stmt|;
break|break;
case|case
name|arg_idxr
case|:
name|a
operator|->
name|scale
operator|=
literal|0
expr_stmt|;
name|total_size
operator|=
name|a
operator|->
name|size
operator|+
literal|10
expr_stmt|;
comment|/* sizeof(rbase + ridx + scl2) = 10.  */
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
operator|-
name|total_size
argument_list|,
name|inst_bit_size
operator|-
operator|(
name|total_size
operator|-
literal|4
operator|)
argument_list|)
expr_stmt|;
name|a
operator|->
name|r
operator|=
name|p
operator|.
name|val
expr_stmt|;
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
operator|-
operator|(
name|total_size
operator|-
literal|4
operator|)
argument_list|,
name|inst_bit_size
operator|-
operator|(
name|total_size
operator|-
literal|8
operator|)
argument_list|)
expr_stmt|;
name|a
operator|->
name|i_r
operator|=
name|p
operator|.
name|val
expr_stmt|;
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
operator|-
operator|(
name|total_size
operator|-
literal|8
operator|)
argument_list|,
name|inst_bit_size
operator|-
operator|(
name|total_size
operator|-
literal|10
operator|)
argument_list|)
expr_stmt|;
name|a
operator|->
name|scale
operator|=
name|p
operator|.
name|val
expr_stmt|;
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
operator|-
operator|(
name|total_size
operator|-
literal|10
operator|)
argument_list|,
name|inst_bit_size
argument_list|)
expr_stmt|;
name|a
operator|->
name|constant
operator|=
name|p
operator|.
name|val
expr_stmt|;
break|break;
case|case
name|arg_rbase
case|:
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
operator|-
operator|(
name|start_bits
operator|+
literal|4
operator|)
argument_list|,
name|inst_bit_size
operator|-
name|start_bits
argument_list|)
expr_stmt|;
name|a
operator|->
name|r
operator|=
name|p
operator|.
name|val
expr_stmt|;
break|break;
case|case
name|arg_cr
case|:
if|if
condition|(
name|a
operator|->
name|size
operator|<=
literal|8
condition|)
block|{
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
operator|-
operator|(
name|start_bits
operator|+
literal|4
operator|)
argument_list|,
name|inst_bit_size
operator|-
name|start_bits
argument_list|)
expr_stmt|;
name|a
operator|->
name|r
operator|=
name|p
operator|.
name|val
expr_stmt|;
comment|/* Case for opc4 r dispu rbase.  */
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
operator|-
operator|(
name|start_bits
operator|+
literal|8
operator|)
argument_list|,
name|inst_bit_size
operator|-
operator|(
name|start_bits
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The 'rbase' start_bits is always relative to a 32-bit data type.  */
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
literal|32
operator|-
operator|(
name|start_bits
operator|+
literal|4
operator|)
argument_list|,
literal|32
operator|-
name|start_bits
argument_list|)
expr_stmt|;
name|a
operator|->
name|r
operator|=
name|p
operator|.
name|val
expr_stmt|;
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
literal|32
operator|-
name|start_bits
argument_list|,
name|inst_bit_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p
operator|.
name|nbits
operator|==
literal|4
operator|)
operator|&&
name|cst4flag
condition|)
block|{
if|if
condition|(
name|instruction
operator|->
name|flags
operator|&
name|DISPUW4
condition|)
name|p
operator|.
name|val
operator|*=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|instruction
operator|->
name|flags
operator|&
name|DISPUD4
condition|)
name|p
operator|.
name|val
operator|*=
literal|4
expr_stmt|;
block|}
name|a
operator|->
name|constant
operator|=
name|p
operator|.
name|val
expr_stmt|;
break|break;
case|case
name|arg_c
case|:
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
operator|-
operator|(
name|start_bits
operator|+
name|a
operator|->
name|size
operator|)
argument_list|,
name|inst_bit_size
operator|-
name|start_bits
argument_list|)
expr_stmt|;
name|a
operator|->
name|constant
operator|=
name|p
operator|.
name|val
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  Print a single argument.  */
end_comment

begin_function
specifier|static
name|void
name|print_arg
parameter_list|(
name|argument
modifier|*
name|a
parameter_list|,
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|LONGLONG
name|longdisp
decl_stmt|,
name|mask
decl_stmt|;
name|int
name|sign_flag
init|=
literal|0
decl_stmt|;
name|int
name|relative
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|number
decl_stmt|;
name|int
name|op_index
init|=
literal|0
decl_stmt|;
name|char
name|string
index|[
literal|200
index|]
decl_stmt|;
name|PTR
name|stream
init|=
name|info
operator|->
name|stream
decl_stmt|;
name|fprintf_ftype
name|func
init|=
name|info
operator|->
name|fprintf_func
decl_stmt|;
switch|switch
condition|(
name|a
operator|->
name|type
condition|)
block|{
case|case
name|arg_copr
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|getcopregname
argument_list|(
name|a
operator|->
name|cr
argument_list|,
name|CRX_C_REGTYPE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_copsr
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|getcopregname
argument_list|(
name|a
operator|->
name|cr
argument_list|,
name|CRX_CS_REGTYPE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_r
case|:
if|if
condition|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"mtpr"
argument_list|)
operator|||
name|IS_INSN_MNEMONIC
argument_list|(
literal|"mfpr"
argument_list|)
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|getprocregname
argument_list|(
name|a
operator|->
name|r
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|getregname
argument_list|(
name|a
operator|->
name|r
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_ic
case|:
if|if
condition|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"excp"
argument_list|)
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|gettrapstring
argument_list|(
name|a
operator|->
name|constant
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"cinv"
argument_list|)
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|getcinvstring
argument_list|(
name|a
operator|->
name|constant
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|INST_HAS_REG_LIST
condition|)
block|{
name|REG_ARG_TYPE
name|reg_arg_type
init|=
name|IS_INSN_TYPE
argument_list|(
name|COP_REG_INS
argument_list|)
condition|?
name|COP_ARG
else|:
name|IS_INSN_TYPE
argument_list|(
name|COPS_REG_INS
argument_list|)
condition|?
name|COPS_ARG
else|:
operator|(
name|instruction
operator|->
name|flags
operator|&
name|USER_REG
operator|)
condition|?
name|USER_REG_ARG
else|:
name|REG_ARG
decl_stmt|;
if|if
condition|(
operator|(
name|reg_arg_type
operator|==
name|COP_ARG
operator|)
operator|||
operator|(
name|reg_arg_type
operator|==
name|COPS_ARG
operator|)
condition|)
block|{
comment|/*  Check for proper argument number.  */
if|if
condition|(
name|processing_argument_number
operator|==
literal|2
condition|)
block|{
name|getregliststring
argument_list|(
name|a
operator|->
name|constant
argument_list|,
name|string
argument_list|,
name|reg_arg_type
argument_list|)
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
else|else
name|func
argument_list|(
name|stream
argument_list|,
literal|"$0x%lx"
argument_list|,
name|a
operator|->
name|constant
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|getregliststring
argument_list|(
name|a
operator|->
name|constant
argument_list|,
name|string
argument_list|,
name|reg_arg_type
argument_list|)
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|func
argument_list|(
name|stream
argument_list|,
literal|"$0x%lx"
argument_list|,
name|a
operator|->
name|constant
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_idxr
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"0x%lx(%s,%s,%d)"
argument_list|,
name|a
operator|->
name|constant
argument_list|,
name|getregname
argument_list|(
name|a
operator|->
name|r
argument_list|)
argument_list|,
name|getregname
argument_list|(
name|a
operator|->
name|i_r
argument_list|)
argument_list|,
name|powerof2
argument_list|(
name|a
operator|->
name|scale
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_rbase
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"(%s)"
argument_list|,
name|getregname
argument_list|(
name|a
operator|->
name|r
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_cr
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"0x%lx(%s)"
argument_list|,
name|a
operator|->
name|constant
argument_list|,
name|getregname
argument_list|(
name|a
operator|->
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|LD_STOR_INS_INC
argument_list|)
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_c
case|:
comment|/* Removed the *2 part as because implicit zeros are no more required. 	 Have to fix this as this needs a bit of extension in terms of branchins. 	 Have to add support for cmp and branch instructions.  */
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|BRANCH_INS
argument_list|)
operator|||
name|IS_INSN_MNEMONIC
argument_list|(
literal|"bal"
argument_list|)
operator|||
name|IS_INSN_TYPE
argument_list|(
name|CMPBR_INS
argument_list|)
operator|||
name|IS_INSN_TYPE
argument_list|(
name|DCR_BRANCH_INS
argument_list|)
operator|||
name|IS_INSN_TYPE
argument_list|(
name|COP_BRANCH_INS
argument_list|)
condition|)
block|{
name|relative
operator|=
literal|1
expr_stmt|;
name|longdisp
operator|=
name|a
operator|->
name|constant
expr_stmt|;
name|longdisp
operator|<<=
literal|1
expr_stmt|;
switch|switch
condition|(
name|a
operator|->
name|size
condition|)
block|{
case|case
literal|8
case|:
case|case
literal|16
case|:
case|case
literal|24
case|:
case|case
literal|32
case|:
name|mask
operator|=
operator|(
operator|(
name|LONGLONG
operator|)
literal|1
operator|<<
name|a
operator|->
name|size
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|longdisp
operator|&
operator|(
operator|(
name|LONGLONG
operator|)
literal|1
operator|<<
name|a
operator|->
name|size
operator|)
condition|)
block|{
name|sign_flag
operator|=
literal|1
expr_stmt|;
name|longdisp
operator|=
operator|~
operator|(
name|longdisp
operator|)
operator|+
literal|1
expr_stmt|;
block|}
name|a
operator|->
name|constant
operator|=
call|(
name|unsigned
name|long
name|int
call|)
argument_list|(
name|longdisp
operator|&
name|mask
argument_list|)
expr_stmt|;
break|break;
default|default:
name|func
argument_list|(
name|stream
argument_list|,
literal|"Wrong offset used in branch/bal instruction"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* For branch Neq instruction it is 2*offset + 2.  */
elseif|else
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|BRANCH_NEQ_INS
argument_list|)
condition|)
name|a
operator|->
name|constant
operator|=
literal|2
operator|*
name|a
operator|->
name|constant
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|LD_STOR_INS_INC
argument_list|)
operator|||
name|IS_INSN_TYPE
argument_list|(
name|LD_STOR_INS
argument_list|)
operator|||
name|IS_INSN_TYPE
argument_list|(
name|STOR_IMM_INS
argument_list|)
operator|||
name|IS_INSN_TYPE
argument_list|(
name|CSTBIT_INS
argument_list|)
condition|)
block|{
name|op_index
operator|=
name|instruction
operator|->
name|flags
operator|&
name|REVERSE_MATCH
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|instruction
operator|->
name|operands
index|[
name|op_index
index|]
operator|.
name|op_type
operator|==
name|abs16
condition|)
name|a
operator|->
name|constant
operator||=
literal|0xFFFF0000
expr_stmt|;
block|}
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
literal|"0x"
argument_list|)
expr_stmt|;
name|number
operator|=
operator|(
name|relative
condition|?
name|memaddr
else|:
literal|0
operator|)
operator|+
operator|(
name|sign_flag
condition|?
operator|-
name|a
operator|->
name|constant
else|:
name|a
operator|->
name|constant
operator|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|number
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Print all the arguments of CURRINSN instruction.  */
end_comment

begin_function
specifier|static
name|void
name|print_arguments
parameter_list|(
name|ins
modifier|*
name|currInsn
parameter_list|,
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|currInsn
operator|->
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|processing_argument_number
operator|=
name|i
expr_stmt|;
name|print_arg
argument_list|(
operator|&
name|currInsn
operator|->
name|arg
index|[
name|i
index|]
argument_list|,
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|currInsn
operator|->
name|nargs
operator|-
literal|1
condition|)
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build the instruction's arguments.  */
end_comment

begin_function
specifier|static
name|void
name|make_instruction
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|shift
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|currInsn
operator|.
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|argument
name|a
decl_stmt|;
name|memset
argument_list|(
operator|&
name|a
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|.
name|type
operator|=
name|getargtype
argument_list|(
name|instruction
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|op_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|instruction
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|op_type
operator|==
name|cst4
operator|||
name|instruction
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|op_type
operator|==
name|rbase_dispu4
condition|)
name|cst4flag
operator|=
literal|1
expr_stmt|;
name|a
operator|.
name|size
operator|=
name|getbits
argument_list|(
name|instruction
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|op_type
argument_list|)
expr_stmt|;
name|shift
operator|=
name|instruction
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|shift
expr_stmt|;
name|make_argument
argument_list|(
operator|&
name|a
argument_list|,
name|shift
argument_list|)
expr_stmt|;
name|currInsn
operator|.
name|arg
index|[
name|i
index|]
operator|=
name|a
expr_stmt|;
block|}
comment|/* Calculate instruction size (in bytes).  */
name|currInsn
operator|.
name|size
operator|=
name|instruction
operator|->
name|size
operator|+
operator|(
name|size_changed
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
comment|/* Now in bits.  */
name|currInsn
operator|.
name|size
operator|*=
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Retrieve a single word from a given memory address.  */
end_comment

begin_function
specifier|static
name|wordU
name|get_word_at_PC
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd_byte
name|buffer
index|[
literal|4
index|]
decl_stmt|;
name|int
name|status
decl_stmt|;
name|wordU
name|insn
init|=
literal|0
decl_stmt|;
name|status
operator|=
name|info
operator|->
name|read_memory_func
argument_list|(
name|memaddr
argument_list|,
name|buffer
argument_list|,
literal|2
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|insn
operator|=
operator|(
name|wordU
operator|)
name|bfd_getl16
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Retrieve multiple words (3) from a given memory address.  */
end_comment

begin_function
specifier|static
name|void
name|get_words_at_PC
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bfd_vma
name|mem
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|mem
operator|=
name|memaddr
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
operator|,
name|mem
operator|+=
literal|2
control|)
name|words
index|[
name|i
index|]
operator|=
name|get_word_at_PC
argument_list|(
name|mem
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|allWords
operator|=
operator|(
operator|(
name|ULONGLONG
operator|)
name|words
index|[
literal|0
index|]
operator|<<
literal|32
operator|)
operator|+
operator|(
operator|(
name|unsigned
name|long
operator|)
name|words
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator|+
name|words
index|[
literal|2
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prints the instruction by calling print_arguments after proper matching.  */
end_comment

begin_function
name|int
name|print_insn_crx
parameter_list|(
name|memaddr
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|memaddr
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
name|int
name|is_decoded
decl_stmt|;
comment|/* Nonzero means instruction has a match.  */
comment|/* Initialize global variables.  */
name|cst4flag
operator|=
literal|0
expr_stmt|;
name|size_changed
operator|=
literal|0
expr_stmt|;
comment|/* Retrieve the encoding from current memory location.  */
name|get_words_at_PC
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* Find a matching opcode in table.  */
name|is_decoded
operator|=
name|match_opcode
argument_list|()
expr_stmt|;
comment|/* If found, print the instruction's mnemonic and arguments.  */
if|if
condition|(
name|is_decoded
operator|>
literal|0
operator|&&
operator|(
name|words
index|[
literal|0
index|]
operator|<<
literal|16
operator|||
name|words
index|[
literal|1
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|instruction
operator|->
name|mnemonic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|currInsn
operator|.
name|nargs
operator|=
name|get_number_of_operands
argument_list|()
operator|)
operator|!=
literal|0
condition|)
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
name|make_instruction
argument_list|()
expr_stmt|;
name|print_arguments
argument_list|(
operator|&
name|currInsn
argument_list|,
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
name|currInsn
operator|.
name|size
return|;
block|}
comment|/* No match found.  */
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s "
argument_list|,
name|ILLEGAL
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
end_function

end_unit

