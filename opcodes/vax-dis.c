begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print VAX instructions.    Copyright 1995, 1998, 2000, 2001, 2002, 2005    Free Software Foundation, Inc.    Contributed by Pauline Middelink<middelin@polyware.iaf.nl>     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,    MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"opcode/vax.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reg_names
index|[]
init|=
block|{
literal|"r0"
block|,
literal|"r1"
block|,
literal|"r2"
block|,
literal|"r3"
block|,
literal|"r4"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
literal|"r8"
block|,
literal|"r9"
block|,
literal|"r10"
block|,
literal|"r11"
block|,
literal|"ap"
block|,
literal|"fp"
block|,
literal|"sp"
block|,
literal|"pc"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Definitions for the function entry mask bits.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|entry_mask_bit
index|[]
init|=
block|{
comment|/* Registers 0 and 1 shall not be saved, since they're used to pass back      a function's result to its caller...  */
literal|"~r0~"
block|,
literal|"~r1~"
block|,
comment|/* Registers 2 .. 11 are normal registers.  */
literal|"r2"
block|,
literal|"r3"
block|,
literal|"r4"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
literal|"r8"
block|,
literal|"r9"
block|,
literal|"r10"
block|,
literal|"r11"
block|,
comment|/* Registers 12 and 13 are argument and frame pointer and must not      be saved by using the entry mask.  */
literal|"~ap~"
block|,
literal|"~fp~"
block|,
comment|/* Bits 14 and 15 control integer and decimal overflow.  */
literal|"IntOvfl"
block|,
literal|"DecOvfl"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sign-extend an (unsigned char). */
end_comment

begin_define
define|#
directive|define
name|COERCE_SIGNED_CHAR
parameter_list|(
name|ch
parameter_list|)
value|((signed char)(ch))
end_define

begin_comment
comment|/* Get a 1 byte signed integer.  */
end_comment

begin_define
define|#
directive|define
name|NEXTBYTE
parameter_list|(
name|p
parameter_list|)
define|\
value|(p += 1, FETCH_DATA (info, p), \   COERCE_SIGNED_CHAR(p[-1]))
end_define

begin_comment
comment|/* Get a 2 byte signed integer.  */
end_comment

begin_define
define|#
directive|define
name|COERCE16
parameter_list|(
name|x
parameter_list|)
value|((int) (((x) ^ 0x8000) - 0x8000))
end_define

begin_define
define|#
directive|define
name|NEXTWORD
parameter_list|(
name|p
parameter_list|)
define|\
value|(p += 2, FETCH_DATA (info, p), \    COERCE16 ((p[-1]<< 8) + p[-2]))
end_define

begin_comment
comment|/* Get a 4 byte signed integer.  */
end_comment

begin_define
define|#
directive|define
name|COERCE32
parameter_list|(
name|x
parameter_list|)
value|((int) (((x) ^ 0x80000000) - 0x80000000))
end_define

begin_define
define|#
directive|define
name|NEXTLONG
parameter_list|(
name|p
parameter_list|)
define|\
value|(p += 4, FETCH_DATA (info, p), \    (COERCE32 ((((((p[-1]<< 8) + p[-2])<< 8) + p[-3])<< 8) + p[-4])))
end_define

begin_comment
comment|/* Maximum length of an instruction.  */
end_comment

begin_define
define|#
directive|define
name|MAXLEN
value|25
end_define

begin_struct
struct|struct
name|private
block|{
comment|/* Points to first byte not fetched.  */
name|bfd_byte
modifier|*
name|max_fetched
decl_stmt|;
name|bfd_byte
name|the_buffer
index|[
name|MAXLEN
index|]
decl_stmt|;
name|bfd_vma
name|insn_start
decl_stmt|;
name|jmp_buf
name|bailout
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Make sure that bytes from INFO->PRIVATE_DATA->BUFFER (inclusive)    to ADDR (exclusive) are valid.  Returns 1 for success, longjmps    on error.  */
end_comment

begin_define
define|#
directive|define
name|FETCH_DATA
parameter_list|(
name|info
parameter_list|,
name|addr
parameter_list|)
define|\
value|((addr)<= ((struct private *)(info->private_data))->max_fetched \    ? 1 : fetch_data ((info), (addr)))
end_define

begin_function
specifier|static
name|int
name|fetch_data
parameter_list|(
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|bfd_byte
modifier|*
name|addr
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|struct
name|private
modifier|*
name|priv
init|=
operator|(
expr|struct
name|private
operator|*
operator|)
name|info
operator|->
name|private_data
decl_stmt|;
name|bfd_vma
name|start
init|=
name|priv
operator|->
name|insn_start
operator|+
operator|(
name|priv
operator|->
name|max_fetched
operator|-
name|priv
operator|->
name|the_buffer
operator|)
decl_stmt|;
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|start
argument_list|,
name|priv
operator|->
name|max_fetched
argument_list|,
name|addr
operator|-
name|priv
operator|->
name|max_fetched
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|memory_error_func
call|)
argument_list|(
name|status
argument_list|,
name|start
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|priv
operator|->
name|bailout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|priv
operator|->
name|max_fetched
operator|=
name|addr
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Entry mask handling.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|entry_addr_occupied_slots
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|entry_addr_total_slots
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
modifier|*
name|entry_addr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse the VAX specific disassembler options.  These contain function    entry addresses, which can be useful to disassemble ROM images, since    there's no symbol table.  Returns TRUE upon success, FALSE otherwise.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|parse_disassembler_options
parameter_list|(
name|char
modifier|*
name|options
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|entry_switch
init|=
literal|"entry:"
decl_stmt|;
while|while
condition|(
operator|(
name|options
operator|=
name|strstr
argument_list|(
name|options
argument_list|,
name|entry_switch
argument_list|)
operator|)
condition|)
block|{
name|options
operator|+=
name|strlen
argument_list|(
name|entry_switch
argument_list|)
expr_stmt|;
comment|/* The greater-than part of the test below is paranoia.  */
if|if
condition|(
name|entry_addr_occupied_slots
operator|>=
name|entry_addr_total_slots
condition|)
block|{
comment|/* A guesstimate of the number of entries we will have to create.  */
name|entry_addr_total_slots
operator|+=
name|strlen
argument_list|(
name|options
argument_list|)
operator|/
operator|(
name|strlen
argument_list|(
name|entry_switch
argument_list|)
operator|+
literal|5
operator|)
expr_stmt|;
name|entry_addr
operator|=
name|realloc
argument_list|(
name|entry_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
operator|*
name|entry_addr_total_slots
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry_addr
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|entry_addr
index|[
name|entry_addr_occupied_slots
index|]
operator|=
name|bfd_scan_vma
argument_list|(
name|options
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|entry_addr_occupied_slots
operator|++
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* FIXME:  Ideally the disassembler should have target specific 	 initialisation and termination function pointers.  Then 	 parse_disassembler_options could be the init function and 	 free_entry_array (below) could be the termination routine. 	 Until then there is no way for the disassembler to tell us 	 that it has finished and that we no longer need the entry 	 array, so this routine is suppressed for now.  It does mean 	 that we leak memory, but only to the extent that we do not 	 free it just before the disassembler is about to terminate 	 anyway.  */
end_comment

begin_comment
comment|/* Free memory allocated to our entry array.  */
end_comment

begin_endif
unit|static void free_entry_array (void) {   if (entry_addr)     {       free (entry_addr);       entry_addr = NULL;       entry_addr_occupied_slots = entry_addr_total_slots = 0;     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Check if the given address is a known function entry. Either there must    be a symbol of function type at this address, or the address must be    a forced entry point.  The later helps in disassembling ROM images, because    there's no symbol table at all.  Forced entry points can be given by    supplying several -M options to objdump: -M entry:0xffbb7730.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_function_entry
parameter_list|(
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|bfd_vma
name|addr
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Check if there's a BSF_FUNCTION symbol at our address.  */
if|if
condition|(
name|info
operator|->
name|symbols
operator|&&
name|info
operator|->
name|symbols
index|[
literal|0
index|]
operator|&&
operator|(
name|info
operator|->
name|symbols
index|[
literal|0
index|]
operator|->
name|flags
operator|&
name|BSF_FUNCTION
operator|)
operator|&&
name|addr
operator|==
name|bfd_asymbol_value
argument_list|(
name|info
operator|->
name|symbols
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* Check for forced function entry address.  */
for|for
control|(
name|i
operator|=
name|entry_addr_occupied_slots
init|;
name|i
operator|--
condition|;
control|)
if|if
condition|(
name|entry_addr
index|[
name|i
index|]
operator|==
name|addr
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|print_insn_mode
parameter_list|(
specifier|const
name|char
modifier|*
name|d
parameter_list|,
name|int
name|size
parameter_list|,
name|unsigned
name|char
modifier|*
name|p0
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
comment|/* PC for this arg to be relative to.  */
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
name|p0
decl_stmt|;
name|unsigned
name|char
name|mode
decl_stmt|,
name|reg
decl_stmt|;
comment|/* Fetch and interpret mode byte.  */
name|mode
operator|=
operator|(
name|unsigned
name|char
operator|)
name|NEXTBYTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|reg
operator|=
name|mode
operator|&
literal|0xF
expr_stmt|;
switch|switch
condition|(
name|mode
operator|&
literal|0xF0
condition|)
block|{
case|case
literal|0x00
case|:
case|case
literal|0x10
case|:
case|case
literal|0x20
case|:
case|case
literal|0x30
case|:
comment|/* Literal mode			$number.  */
if|if
condition|(
name|d
index|[
literal|1
index|]
operator|==
literal|'d'
operator|||
name|d
index|[
literal|1
index|]
operator|==
literal|'f'
operator|||
name|d
index|[
literal|1
index|]
operator|==
literal|'g'
operator|||
name|d
index|[
literal|1
index|]
operator|==
literal|'h'
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"$0x%x [%c-float]"
argument_list|,
name|mode
argument_list|,
name|d
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"$0x%x"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x40
case|:
comment|/* Index:			base-addr[Rn] */
name|p
operator|+=
name|print_insn_mode
argument_list|(
name|d
argument_list|,
name|size
argument_list|,
name|p0
operator|+
literal|1
argument_list|,
name|addr
operator|+
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"[%s]"
argument_list|,
name|reg_names
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x50
case|:
comment|/* Register:			Rn */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x60
case|:
comment|/* Register deferred:		(Rn) */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x70
case|:
comment|/* Autodecrement:		-(Rn) */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"-(%s)"
argument_list|,
name|reg_names
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x80
case|:
comment|/* Autoincrement:		(Rn)+ */
if|if
condition|(
name|reg
operator|==
literal|0xF
condition|)
block|{
comment|/* Immediate?  */
name|int
name|i
decl_stmt|;
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|p
operator|+
name|size
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"$0x"
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
index|[
literal|1
index|]
operator|==
literal|'d'
operator|||
name|d
index|[
literal|1
index|]
operator|==
literal|'f'
operator|||
name|d
index|[
literal|1
index|]
operator|==
literal|'g'
operator|||
name|d
index|[
literal|1
index|]
operator|==
literal|'h'
condition|)
block|{
name|int
name|float_word
decl_stmt|;
name|float_word
operator|=
name|p
index|[
literal|0
index|]
operator||
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
index|[
literal|1
index|]
operator|==
literal|'d'
operator|||
name|d
index|[
literal|1
index|]
operator|==
literal|'f'
operator|)
operator|&&
operator|(
name|float_word
operator|&
literal|0xff80
operator|)
operator|==
literal|0x8000
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"[invalid %c-float]"
argument_list|,
name|d
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%02x"
argument_list|,
name|p
index|[
name|size
operator|-
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|" [%c-float]"
argument_list|,
name|d
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%02x"
argument_list|,
name|p
index|[
name|size
operator|-
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|p
operator|+=
name|size
expr_stmt|;
block|}
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"(%s)+"
argument_list|,
name|reg_names
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x90
case|:
comment|/* Autoincrement deferred:	@(Rn)+ */
if|if
condition|(
name|reg
operator|==
literal|0xF
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"*0x%x"
argument_list|,
name|NEXTLONG
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"@(%s)+"
argument_list|,
name|reg_names
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xB0
case|:
comment|/* Displacement byte deferred:	*displ(Rn).  */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
case|case
literal|0xA0
case|:
comment|/* Displacement byte:		displ(Rn).  */
if|if
condition|(
name|reg
operator|==
literal|0xF
condition|)
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|addr
operator|+
literal|2
operator|+
name|NEXTBYTE
argument_list|(
name|p
argument_list|)
argument_list|,
name|info
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%x(%s)"
argument_list|,
name|NEXTBYTE
argument_list|(
name|p
argument_list|)
argument_list|,
name|reg_names
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xD0
case|:
comment|/* Displacement word deferred:	*displ(Rn).  */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
case|case
literal|0xC0
case|:
comment|/* Displacement word:		displ(Rn).  */
if|if
condition|(
name|reg
operator|==
literal|0xF
condition|)
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|addr
operator|+
literal|3
operator|+
name|NEXTWORD
argument_list|(
name|p
argument_list|)
argument_list|,
name|info
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%x(%s)"
argument_list|,
name|NEXTWORD
argument_list|(
name|p
argument_list|)
argument_list|,
name|reg_names
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xF0
case|:
comment|/* Displacement long deferred:	*displ(Rn).  */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
case|case
literal|0xE0
case|:
comment|/* Displacement long:		displ(Rn).  */
if|if
condition|(
name|reg
operator|==
literal|0xF
condition|)
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|addr
operator|+
literal|5
operator|+
name|NEXTLONG
argument_list|(
name|p
argument_list|)
argument_list|,
name|info
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%x(%s)"
argument_list|,
name|NEXTLONG
argument_list|(
name|p
argument_list|)
argument_list|,
name|reg_names
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|p
operator|-
name|p0
return|;
block|}
end_function

begin_comment
comment|/* Returns number of bytes "eaten" by the operand, or return -1 if an    invalid operand was found, or -2 if an opcode tabel error was    found. */
end_comment

begin_function
specifier|static
name|int
name|print_insn_arg
parameter_list|(
specifier|const
name|char
modifier|*
name|d
parameter_list|,
name|unsigned
name|char
modifier|*
name|p0
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
comment|/* PC for this arg to be relative to.  */
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|int
name|arg_len
decl_stmt|;
comment|/* Check validity of addressing length.  */
switch|switch
condition|(
name|d
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'b'
case|:
name|arg_len
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|arg_len
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|arg_len
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|arg_len
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|arg_len
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|arg_len
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|arg_len
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|arg_len
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|arg_len
operator|=
literal|8
expr_stmt|;
break|break;
default|default  :
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Branches have no mode byte.  */
if|if
condition|(
name|d
index|[
literal|0
index|]
operator|==
literal|'b'
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
name|p0
decl_stmt|;
if|if
condition|(
name|arg_len
operator|==
literal|1
condition|)
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|addr
operator|+
literal|1
operator|+
name|NEXTBYTE
argument_list|(
name|p
argument_list|)
argument_list|,
name|info
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|addr
operator|+
literal|2
operator|+
name|NEXTWORD
argument_list|(
name|p
argument_list|)
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
name|p
operator|-
name|p0
return|;
block|}
return|return
name|print_insn_mode
argument_list|(
name|d
argument_list|,
name|arg_len
argument_list|,
name|p0
argument_list|,
name|addr
argument_list|,
name|info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Print the vax instruction at address MEMADDR in debugged memory,    on INFO->STREAM.  Returns length of the instruction, in bytes.  */
end_comment

begin_function
name|int
name|print_insn_vax
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
specifier|static
name|bfd_boolean
name|parsed_disassembler_options
init|=
name|FALSE
decl_stmt|;
specifier|const
name|struct
name|vot
modifier|*
name|votp
decl_stmt|;
specifier|const
name|char
modifier|*
name|argp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|arg
decl_stmt|;
name|struct
name|private
name|priv
decl_stmt|;
name|bfd_byte
modifier|*
name|buffer
init|=
name|priv
operator|.
name|the_buffer
decl_stmt|;
name|info
operator|->
name|private_data
operator|=
operator|&
name|priv
expr_stmt|;
name|priv
operator|.
name|max_fetched
operator|=
name|priv
operator|.
name|the_buffer
expr_stmt|;
name|priv
operator|.
name|insn_start
operator|=
name|memaddr
expr_stmt|;
if|if
condition|(
operator|!
name|parsed_disassembler_options
operator|&&
name|info
operator|->
name|disassembler_options
operator|!=
name|NULL
condition|)
block|{
name|parse_disassembler_options
argument_list|(
name|info
operator|->
name|disassembler_options
argument_list|)
expr_stmt|;
comment|/* To avoid repeated parsing of these options.  */
name|parsed_disassembler_options
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|priv
operator|.
name|bailout
argument_list|)
operator|!=
literal|0
condition|)
comment|/* Error return.  */
return|return
operator|-
literal|1
return|;
name|argp
operator|=
name|NULL
expr_stmt|;
comment|/* Check if the info buffer has more than one byte left since      the last opcode might be a single byte with no argument data.  */
if|if
condition|(
name|info
operator|->
name|buffer_length
operator|-
operator|(
name|memaddr
operator|-
name|info
operator|->
name|buffer_vma
operator|)
operator|>
literal|1
condition|)
block|{
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|buffer
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buffer
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Decode function entry mask.  */
if|if
condition|(
name|is_function_entry
argument_list|(
name|info
argument_list|,
name|memaddr
argument_list|)
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|register_mask
init|=
name|buffer
index|[
literal|1
index|]
operator|<<
literal|8
operator||
name|buffer
index|[
literal|0
index|]
decl_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|".word 0x%04x # Entry mask:<"
argument_list|,
name|register_mask
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|15
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|register_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|" %s"
argument_list|,
name|entry_mask_bit
index|[
name|i
index|]
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
for|for
control|(
name|votp
operator|=
operator|&
name|votstrs
index|[
literal|0
index|]
init|;
name|votp
operator|->
name|name
index|[
literal|0
index|]
condition|;
name|votp
operator|++
control|)
block|{
name|vax_opcodeT
name|opcode
init|=
name|votp
operator|->
name|detail
operator|.
name|code
decl_stmt|;
comment|/* 2 byte codes match 2 buffer pos. */
if|if
condition|(
operator|(
name|bfd_byte
operator|)
name|opcode
operator|==
name|buffer
index|[
literal|0
index|]
operator|&&
operator|(
name|opcode
operator|>>
literal|8
operator|==
literal|0
operator|||
name|opcode
operator|>>
literal|8
operator|==
name|buffer
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|argp
operator|=
name|votp
operator|->
name|detail
operator|.
name|args
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|argp
operator|==
name|NULL
condition|)
block|{
comment|/* Handle undefined instructions. */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|".word 0x%x"
argument_list|,
operator|(
name|buffer
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator|+
name|buffer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
comment|/* Point at first byte of argument data, and at descriptor for first      argument.  */
name|arg
operator|=
name|buffer
operator|+
operator|(
operator|(
name|votp
operator|->
name|detail
operator|.
name|code
operator|>>
literal|8
operator|)
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
comment|/* Make sure we have it in mem */
name|FETCH_DATA
argument_list|(
name|info
argument_list|,
name|arg
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|votp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|argp
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|argp
condition|)
block|{
name|arg
operator|+=
name|print_insn_arg
argument_list|(
name|argp
argument_list|,
name|arg
argument_list|,
name|memaddr
operator|+
name|arg
operator|-
name|buffer
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|argp
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|argp
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
return|return
name|arg
operator|-
name|buffer
return|;
block|}
end_function

end_unit

