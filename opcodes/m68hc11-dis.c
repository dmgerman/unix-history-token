begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* m68hc11-dis.c -- Motorola 68HC11& 68HC12 disassembly    Copyright 1999, 2000, 2001, 2002, 2003, 2006    Free Software Foundation, Inc.    Written by Stephane Carrez (stcarrez@nerim.fr)  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"opcode/m68hc11.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_define
define|#
directive|define
name|PC_REGNUM
value|3
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|reg_name
index|[]
init|=
block|{
literal|"X"
block|,
literal|"Y"
block|,
literal|"SP"
block|,
literal|"PC"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|reg_src_table
index|[]
init|=
block|{
literal|"A"
block|,
literal|"B"
block|,
literal|"CCR"
block|,
literal|"TMP3"
block|,
literal|"D"
block|,
literal|"X"
block|,
literal|"Y"
block|,
literal|"SP"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|reg_dst_table
index|[]
init|=
block|{
literal|"A"
block|,
literal|"B"
block|,
literal|"CCR"
block|,
literal|"TMP2"
block|,
literal|"D"
block|,
literal|"X"
block|,
literal|"Y"
block|,
literal|"SP"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OP_PAGE_MASK
value|(M6811_OP_PAGE2|M6811_OP_PAGE3|M6811_OP_PAGE4)
end_define

begin_comment
comment|/* Prototypes for local functions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|read_memory
parameter_list|(
name|bfd_vma
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|disassemble_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|print_indexed_operand
parameter_list|(
name|bfd_vma
parameter_list|,
name|struct
name|disassemble_info
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|print_insn
parameter_list|(
name|bfd_vma
parameter_list|,
name|struct
name|disassemble_info
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|read_memory
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|bfd_byte
modifier|*
name|buffer
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
comment|/* Get first byte.  Only one at a time because we don't know the      size of the insn.  */
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|memaddr
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|memory_error_func
call|)
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Read the 68HC12 indexed operand byte and print the corresponding mode.    Returns the number of bytes read or -1 if failure.  */
end_comment

begin_function
specifier|static
name|int
name|print_indexed_operand
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|int
modifier|*
name|indirect
parameter_list|,
name|int
name|mov_insn
parameter_list|,
name|int
name|pc_offset
parameter_list|,
name|bfd_vma
name|endaddr
parameter_list|)
block|{
name|bfd_byte
name|buffer
index|[
literal|4
index|]
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|int
name|status
decl_stmt|;
name|short
name|sval
decl_stmt|;
name|int
name|pos
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|indirect
condition|)
operator|*
name|indirect
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|read_memory
argument_list|(
name|memaddr
argument_list|,
operator|&
name|buffer
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
return|return
name|status
return|;
block|}
comment|/* n,r with 5-bits signed constant.  */
if|if
condition|(
operator|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|0x20
operator|)
operator|==
literal|0
condition|)
block|{
name|reg
operator|=
operator|(
name|buffer
index|[
literal|0
index|]
operator|>>
literal|6
operator|)
operator|&
literal|3
expr_stmt|;
name|sval
operator|=
operator|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|0x1f
operator|)
expr_stmt|;
if|if
condition|(
name|sval
operator|&
literal|0x10
condition|)
name|sval
operator||=
literal|0xfff0
expr_stmt|;
comment|/* 68HC12 requires an adjustment for movb/movw pc relative modes.  */
if|if
condition|(
name|reg
operator|==
name|PC_REGNUM
operator|&&
name|info
operator|->
name|mach
operator|==
name|bfd_mach_m6812
operator|&&
name|mov_insn
condition|)
name|sval
operator|+=
name|pc_offset
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d,%s"
argument_list|,
operator|(
name|int
operator|)
name|sval
argument_list|,
name|reg_name
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|PC_REGNUM
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|" {"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|endaddr
operator|+
name|sval
argument_list|,
name|info
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Auto pre/post increment/decrement.  */
elseif|else
if|if
condition|(
operator|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0xc0
condition|)
block|{
specifier|const
name|char
modifier|*
name|mode
decl_stmt|;
name|reg
operator|=
operator|(
name|buffer
index|[
literal|0
index|]
operator|>>
literal|6
operator|)
operator|&
literal|3
expr_stmt|;
name|sval
operator|=
operator|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|0x0f
operator|)
expr_stmt|;
if|if
condition|(
name|sval
operator|&
literal|0x8
condition|)
block|{
name|sval
operator||=
literal|0xfff0
expr_stmt|;
name|sval
operator|=
operator|-
name|sval
expr_stmt|;
name|mode
operator|=
literal|"-"
expr_stmt|;
block|}
else|else
block|{
name|sval
operator|=
name|sval
operator|+
literal|1
expr_stmt|;
name|mode
operator|=
literal|"+"
expr_stmt|;
block|}
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d,%s%s%s"
argument_list|,
operator|(
name|int
operator|)
name|sval
argument_list|,
operator|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|0x10
condition|?
literal|""
else|:
name|mode
operator|)
argument_list|,
name|reg_name
index|[
name|reg
index|]
argument_list|,
operator|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|0x10
condition|?
name|mode
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* [n,r] 16-bits offset indexed indirect.  */
elseif|else
if|if
condition|(
operator|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|0x07
operator|)
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|mov_insn
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"<invalid op: 0x%x>"
argument_list|,
name|buffer
index|[
literal|0
index|]
operator|&
literal|0x0ff
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|reg
operator|=
operator|(
name|buffer
index|[
literal|0
index|]
operator|>>
literal|3
operator|)
operator|&
literal|0x03
expr_stmt|;
name|status
operator|=
name|read_memory
argument_list|(
name|memaddr
operator|+
name|pos
argument_list|,
operator|&
name|buffer
index|[
literal|0
index|]
argument_list|,
literal|2
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
return|return
name|status
return|;
block|}
name|pos
operator|+=
literal|2
expr_stmt|;
name|sval
operator|=
operator|(
operator|(
name|buffer
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|buffer
index|[
literal|1
index|]
operator|&
literal|0x0FF
operator|)
operator|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"[%u,%s]"
argument_list|,
name|sval
operator|&
literal|0x0ffff
argument_list|,
name|reg_name
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirect
condition|)
operator|*
name|indirect
operator|=
literal|1
expr_stmt|;
block|}
comment|/* n,r with 9 and 16 bit signed constant.  */
elseif|else
if|if
condition|(
operator|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|0x4
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mov_insn
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"<invalid op: 0x%x>"
argument_list|,
name|buffer
index|[
literal|0
index|]
operator|&
literal|0x0ff
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|reg
operator|=
operator|(
name|buffer
index|[
literal|0
index|]
operator|>>
literal|3
operator|)
operator|&
literal|0x03
expr_stmt|;
name|status
operator|=
name|read_memory
argument_list|(
name|memaddr
operator|+
name|pos
argument_list|,
operator|&
name|buffer
index|[
literal|1
index|]
argument_list|,
operator|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|0x2
condition|?
literal|2
else|:
literal|1
operator|)
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
return|return
name|status
return|;
block|}
if|if
condition|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|2
condition|)
block|{
name|sval
operator|=
operator|(
operator|(
name|buffer
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|buffer
index|[
literal|2
index|]
operator|&
literal|0x0FF
operator|)
operator|)
expr_stmt|;
name|sval
operator|&=
literal|0x0FFFF
expr_stmt|;
name|pos
operator|+=
literal|2
expr_stmt|;
name|endaddr
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|sval
operator|=
name|buffer
index|[
literal|1
index|]
operator|&
literal|0x00ff
expr_stmt|;
if|if
condition|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|0x01
condition|)
name|sval
operator||=
literal|0xff00
expr_stmt|;
name|pos
operator|++
expr_stmt|;
name|endaddr
operator|++
expr_stmt|;
block|}
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d,%s"
argument_list|,
operator|(
name|int
operator|)
name|sval
argument_list|,
name|reg_name
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|PC_REGNUM
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|" {"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|endaddr
operator|+
name|sval
argument_list|,
name|info
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|reg
operator|=
operator|(
name|buffer
index|[
literal|0
index|]
operator|>>
literal|3
operator|)
operator|&
literal|0x03
expr_stmt|;
switch|switch
condition|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"A,%s"
argument_list|,
name|reg_name
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"B,%s"
argument_list|,
name|reg_name
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"D,%s"
argument_list|,
name|reg_name
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
default|default:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"[D,%s]"
argument_list|,
name|reg_name
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirect
condition|)
operator|*
name|indirect
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
return|return
name|pos
return|;
block|}
end_function

begin_comment
comment|/* Disassemble one instruction at address 'memaddr'.  Returns the number    of bytes used by that instruction.  */
end_comment

begin_function
specifier|static
name|int
name|print_insn
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|int
name|arch
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|bfd_byte
name|buffer
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|char
name|code
decl_stmt|;
name|long
name|format
decl_stmt|,
name|pos
decl_stmt|,
name|i
decl_stmt|;
name|short
name|sval
decl_stmt|;
specifier|const
name|struct
name|m68hc11_opcode
modifier|*
name|opcode
decl_stmt|;
comment|/* Get first byte.  Only one at a time because we don't know the      size of the insn.  */
name|status
operator|=
name|read_memory
argument_list|(
name|memaddr
argument_list|,
name|buffer
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
return|return
name|status
return|;
block|}
name|format
operator|=
literal|0
expr_stmt|;
name|code
operator|=
name|buffer
index|[
literal|0
index|]
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
comment|/* Look for page2,3,4 opcodes.  */
if|if
condition|(
name|code
operator|==
name|M6811_OPCODE_PAGE2
condition|)
block|{
name|pos
operator|++
expr_stmt|;
name|format
operator|=
name|M6811_OP_PAGE2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|M6811_OPCODE_PAGE3
operator|&&
name|arch
operator|==
name|cpu6811
condition|)
block|{
name|pos
operator|++
expr_stmt|;
name|format
operator|=
name|M6811_OP_PAGE3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|M6811_OPCODE_PAGE4
operator|&&
name|arch
operator|==
name|cpu6811
condition|)
block|{
name|pos
operator|++
expr_stmt|;
name|format
operator|=
name|M6811_OP_PAGE4
expr_stmt|;
block|}
comment|/* We are in page2,3,4; get the real opcode.  */
if|if
condition|(
name|pos
operator|==
literal|1
condition|)
block|{
name|status
operator|=
name|read_memory
argument_list|(
name|memaddr
operator|+
name|pos
argument_list|,
operator|&
name|buffer
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
return|return
name|status
return|;
block|}
name|code
operator|=
name|buffer
index|[
literal|1
index|]
expr_stmt|;
block|}
comment|/* Look first for a 68HC12 alias.  All of them are 2-bytes long and      in page 1.  There is no operand to print.  We read the second byte      only when we have a possible match.  */
if|if
condition|(
operator|(
name|arch
operator|&
name|cpu6812
operator|)
operator|&&
name|format
operator|==
literal|0
condition|)
block|{
name|int
name|must_read
init|=
literal|1
decl_stmt|;
comment|/* Walk the alias table to find a code1+code2 match.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m68hc12_num_alias
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|m68hc12_alias
index|[
name|i
index|]
operator|.
name|code1
operator|==
name|code
condition|)
block|{
if|if
condition|(
name|must_read
condition|)
block|{
name|status
operator|=
name|read_memory
argument_list|(
name|memaddr
operator|+
name|pos
operator|+
literal|1
argument_list|,
operator|&
name|buffer
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
break|break;
name|must_read
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|m68hc12_alias
index|[
name|i
index|]
operator|.
name|code2
operator|==
operator|(
name|unsigned
name|char
operator|)
name|buffer
index|[
literal|1
index|]
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|m68hc12_alias
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
block|}
block|}
name|pos
operator|++
expr_stmt|;
comment|/* Scan the opcode table until we find the opcode      with the corresponding page.  */
name|opcode
operator|=
name|m68hc11_opcodes
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m68hc11_num_opcodes
condition|;
name|i
operator|++
operator|,
name|opcode
operator|++
control|)
block|{
name|int
name|offset
decl_stmt|;
name|int
name|pc_src_offset
decl_stmt|;
name|int
name|pc_dst_offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|opcode
operator|->
name|arch
operator|&
name|arch
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|opcode
operator|->
name|opcode
operator|!=
name|code
condition|)
continue|continue;
if|if
condition|(
operator|(
name|opcode
operator|->
name|format
operator|&
name|OP_PAGE_MASK
operator|)
operator|!=
name|format
condition|)
continue|continue;
if|if
condition|(
name|opcode
operator|->
name|format
operator|&
name|M6812_OP_REG
condition|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|is_jump
decl_stmt|;
if|if
condition|(
name|opcode
operator|->
name|format
operator|&
name|M6811_OP_JUMP_REL
condition|)
name|is_jump
operator|=
literal|1
expr_stmt|;
else|else
name|is_jump
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|read_memory
argument_list|(
name|memaddr
operator|+
name|pos
argument_list|,
operator|&
name|buffer
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
return|return
name|status
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|i
operator|+
name|j
operator|<
name|m68hc11_num_opcodes
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|opcode
index|[
name|j
index|]
operator|.
name|arch
operator|&
name|arch
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|opcode
index|[
name|j
index|]
operator|.
name|opcode
operator|!=
name|code
condition|)
continue|continue;
if|if
condition|(
name|is_jump
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|opcode
index|[
name|j
index|]
operator|.
name|format
operator|&
name|M6811_OP_JUMP_REL
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|opcode
index|[
name|j
index|]
operator|.
name|format
operator|&
name|M6812_OP_IBCC_MARKER
operator|)
operator|&&
operator|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
continue|continue;
if|if
condition|(
operator|(
name|opcode
index|[
name|j
index|]
operator|.
name|format
operator|&
name|M6812_OP_TBCC_MARKER
operator|)
operator|&&
operator|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x40
condition|)
continue|continue;
if|if
condition|(
operator|(
name|opcode
index|[
name|j
index|]
operator|.
name|format
operator|&
name|M6812_OP_DBCC_MARKER
operator|)
operator|&&
operator|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|opcode
index|[
name|j
index|]
operator|.
name|format
operator|&
name|M6812_OP_EQ_MARKER
operator|)
operator|&&
operator|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|0x20
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|opcode
index|[
name|j
index|]
operator|.
name|format
operator|&
name|M6812_OP_EQ_MARKER
operator|)
operator|&&
operator|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|0x20
operator|)
operator|!=
literal|0
condition|)
break|break;
continue|continue;
block|}
if|if
condition|(
name|opcode
index|[
name|j
index|]
operator|.
name|format
operator|&
name|M6812_OP_EXG_MARKER
operator|&&
name|buffer
index|[
literal|0
index|]
operator|&
literal|0x80
condition|)
break|break;
if|if
condition|(
operator|(
name|opcode
index|[
name|j
index|]
operator|.
name|format
operator|&
name|M6812_OP_SEX_MARKER
operator|)
operator|&&
operator|(
operator|(
operator|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|0x07
operator|)
operator|>=
literal|3
operator|&&
operator|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|7
operator|)
operator|<=
literal|7
operator|)
operator|)
operator|&&
operator|(
operator|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|0x0f0
operator|)
operator|<=
literal|0x20
operator|)
condition|)
break|break;
if|if
condition|(
name|opcode
index|[
name|j
index|]
operator|.
name|format
operator|&
name|M6812_OP_TFR_MARKER
operator|&&
operator|!
operator|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|0x80
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|+
name|j
operator|<
name|m68hc11_num_opcodes
condition|)
name|opcode
operator|=
operator|&
name|opcode
index|[
name|j
index|]
expr_stmt|;
block|}
comment|/* We have found the opcode.  Extract the operand and print it.  */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
expr_stmt|;
name|format
operator|=
name|opcode
operator|->
name|format
expr_stmt|;
if|if
condition|(
name|format
operator|&
operator|(
name|M6811_OP_MASK
operator||
name|M6811_OP_BITMASK
operator||
name|M6811_OP_JUMP_REL
operator||
name|M6812_OP_JUMP_REL16
operator|)
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
block|}
comment|/* The movb and movw must be handled in a special way...          The source constant 'ii' is not always at the same place.          This is the same for the destination for the post-indexed byte.          The 'offset' is used to do the appropriate correction.                                     offset          offset                               for constant     for destination          movb   18 OB ii hh ll       0          0                 18 08 xb ii          1          -1                 18 0C hh ll hh ll    0          0                 18 09 xb hh ll       1          -1                 18 0D xb hh ll       0          0                 18 0A xb xb          0          0           movw   18 03 jj kk hh ll    0          0                 18 00 xb jj kk       1          -1                 18 04 hh ll hh ll    0          0                 18 01 xb hh ll       1          -1                 18 05 xb hh ll       0          0                 18 02 xb xb          0          0           After the source operand is read, the position 'pos' is incremented          this explains the negative offset for destination.           movb/movw above are the only instructions with this matching          format.  */
name|offset
operator|=
operator|(
operator|(
name|format
operator|&
name|M6812_OP_IDX_P2
operator|)
operator|&&
operator|(
name|format
operator|&
operator|(
name|M6811_OP_IMM8
operator||
name|M6811_OP_IMM16
operator||
name|M6811_OP_IND16
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* Operand with one more byte: - immediate, offset,          direct-low address.  */
if|if
condition|(
name|format
operator|&
operator|(
name|M6811_OP_IMM8
operator||
name|M6811_OP_IX
operator||
name|M6811_OP_IY
operator||
name|M6811_OP_DIRECT
operator|)
condition|)
block|{
name|status
operator|=
name|read_memory
argument_list|(
name|memaddr
operator|+
name|pos
operator|+
name|offset
argument_list|,
operator|&
name|buffer
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
return|return
name|status
return|;
block|}
name|pos
operator|++
expr_stmt|;
comment|/* This movb/movw is special (see above).  */
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
name|pc_dst_offset
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|M6811_OP_IMM8
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"#%d"
argument_list|,
operator|(
name|int
operator|)
name|buffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|format
operator|&=
operator|~
name|M6811_OP_IMM8
expr_stmt|;
comment|/* Set PC destination offset.  */
name|pc_dst_offset
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|format
operator|&
name|M6811_OP_IX
condition|)
block|{
comment|/* Offsets are in range 0..255, print them unsigned.  */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%u,x"
argument_list|,
name|buffer
index|[
literal|0
index|]
operator|&
literal|0x0FF
argument_list|)
expr_stmt|;
name|format
operator|&=
operator|~
name|M6811_OP_IX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|format
operator|&
name|M6811_OP_IY
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%u,y"
argument_list|,
name|buffer
index|[
literal|0
index|]
operator|&
literal|0x0FF
argument_list|)
expr_stmt|;
name|format
operator|&=
operator|~
name|M6811_OP_IY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|format
operator|&
name|M6811_OP_DIRECT
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|0x0FF
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|format
operator|&=
operator|~
name|M6811_OP_DIRECT
expr_stmt|;
block|}
block|}
define|#
directive|define
name|M6812_DST_MOVE
value|(M6812_OP_IND16_P2 | M6812_OP_IDX_P2)
define|#
directive|define
name|M6812_INDEXED_FLAGS
value|(M6812_OP_IDX|M6812_OP_IDX_1|M6812_OP_IDX_2)
comment|/* Analyze the 68HC12 indexed byte.  */
if|if
condition|(
name|format
operator|&
name|M6812_INDEXED_FLAGS
condition|)
block|{
name|int
name|indirect
decl_stmt|;
name|bfd_vma
name|endaddr
decl_stmt|;
name|endaddr
operator|=
name|memaddr
operator|+
name|pos
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|M6811_OP_IND16
condition|)
name|endaddr
operator|+=
literal|2
expr_stmt|;
name|pc_src_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|pc_dst_offset
operator|=
literal|1
expr_stmt|;
name|status
operator|=
name|print_indexed_operand
argument_list|(
name|memaddr
operator|+
name|pos
argument_list|,
name|info
argument_list|,
operator|&
name|indirect
argument_list|,
operator|(
name|format
operator|&
name|M6812_DST_MOVE
operator|)
argument_list|,
name|pc_src_offset
argument_list|,
name|endaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
block|{
return|return
name|status
return|;
block|}
name|pos
operator|+=
name|status
expr_stmt|;
comment|/* The indirect addressing mode of the call instruction does              not need the page code.  */
if|if
condition|(
operator|(
name|format
operator|&
name|M6812_OP_PAGE
operator|)
operator|&&
name|indirect
condition|)
name|format
operator|&=
operator|~
name|M6812_OP_PAGE
expr_stmt|;
block|}
comment|/* 68HC12 dbcc/ibcc/tbcc operands.  */
if|if
condition|(
operator|(
name|format
operator|&
name|M6812_OP_REG
operator|)
operator|&&
operator|(
name|format
operator|&
name|M6811_OP_JUMP_REL
operator|)
condition|)
block|{
name|status
operator|=
name|read_memory
argument_list|(
name|memaddr
operator|+
name|pos
argument_list|,
operator|&
name|buffer
index|[
literal|0
index|]
argument_list|,
literal|2
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
return|return
name|status
return|;
block|}
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s,"
argument_list|,
name|reg_src_table
index|[
name|buffer
index|[
literal|0
index|]
operator|&
literal|0x07
index|]
argument_list|)
expr_stmt|;
name|sval
operator|=
name|buffer
index|[
literal|1
index|]
operator|&
literal|0x0ff
expr_stmt|;
if|if
condition|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|0x10
condition|)
name|sval
operator||=
literal|0xff00
expr_stmt|;
name|pos
operator|+=
literal|2
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|memaddr
operator|+
name|pos
operator|+
name|sval
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|format
operator|&=
operator|~
operator|(
name|M6812_OP_REG
operator||
name|M6811_OP_JUMP_REL
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|format
operator|&
operator|(
name|M6812_OP_REG
operator||
name|M6812_OP_REG_2
operator|)
condition|)
block|{
name|status
operator|=
name|read_memory
argument_list|(
name|memaddr
operator|+
name|pos
argument_list|,
operator|&
name|buffer
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
return|return
name|status
return|;
block|}
name|pos
operator|++
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s,%s"
argument_list|,
name|reg_src_table
index|[
operator|(
name|buffer
index|[
literal|0
index|]
operator|>>
literal|4
operator|)
operator|&
literal|7
index|]
argument_list|,
name|reg_dst_table
index|[
operator|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|7
operator|)
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
operator|(
name|M6811_OP_IMM16
operator||
name|M6811_OP_IND16
operator|)
condition|)
block|{
name|int
name|val
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|unsigned
name|page
init|=
literal|0
decl_stmt|;
name|status
operator|=
name|read_memory
argument_list|(
name|memaddr
operator|+
name|pos
operator|+
name|offset
argument_list|,
operator|&
name|buffer
index|[
literal|0
index|]
argument_list|,
literal|2
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
return|return
name|status
return|;
block|}
if|if
condition|(
name|format
operator|&
name|M6812_OP_IDX_P2
condition|)
name|offset
operator|=
operator|-
literal|2
expr_stmt|;
else|else
name|offset
operator|=
literal|0
expr_stmt|;
name|pos
operator|+=
literal|2
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|buffer
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|buffer
index|[
literal|1
index|]
operator|&
literal|0x0FF
operator|)
operator|)
expr_stmt|;
name|val
operator|&=
literal|0x0FFFF
expr_stmt|;
name|addr
operator|=
name|val
expr_stmt|;
name|pc_dst_offset
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|M6812_OP_PAGE
condition|)
block|{
name|status
operator|=
name|read_memory
argument_list|(
name|memaddr
operator|+
name|pos
operator|+
name|offset
argument_list|,
name|buffer
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|status
return|;
name|page
operator|=
operator|(
name|unsigned
operator|)
name|buffer
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|addr
operator|>=
name|M68HC12_BANK_BASE
operator|&&
name|addr
operator|<
literal|0x0c000
condition|)
name|addr
operator|=
operator|(
operator|(
name|val
operator|-
name|M68HC12_BANK_BASE
operator|)
operator||
operator|(
name|page
operator|<<
name|M68HC12_BANK_SHIFT
operator|)
operator|)
operator|+
name|M68HC12_BANK_VIRT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|arch
operator|&
name|cpu6812
operator|)
operator|&&
name|addr
operator|>=
name|M68HC12_BANK_BASE
operator|&&
name|addr
operator|<
literal|0x0c000
condition|)
block|{
name|int
name|cur_page
decl_stmt|;
name|bfd_vma
name|vaddr
decl_stmt|;
if|if
condition|(
name|memaddr
operator|>=
name|M68HC12_BANK_VIRT
condition|)
name|cur_page
operator|=
operator|(
operator|(
name|memaddr
operator|-
name|M68HC12_BANK_VIRT
operator|)
operator|>>
name|M68HC12_BANK_SHIFT
operator|)
expr_stmt|;
else|else
name|cur_page
operator|=
literal|0
expr_stmt|;
name|vaddr
operator|=
operator|(
operator|(
name|addr
operator|-
name|M68HC12_BANK_BASE
operator|)
operator|+
operator|(
name|cur_page
operator|<<
name|M68HC12_BANK_SHIFT
operator|)
operator|)
operator|+
name|M68HC12_BANK_VIRT
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|symbol_at_address_func
argument_list|(
name|addr
argument_list|,
name|info
argument_list|)
operator|&&
name|info
operator|->
name|symbol_at_address_func
argument_list|(
name|vaddr
argument_list|,
name|info
argument_list|)
condition|)
name|addr
operator|=
name|vaddr
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
name|M6811_OP_IMM16
condition|)
block|{
name|format
operator|&=
operator|~
name|M6811_OP_IMM16
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"#"
argument_list|)
expr_stmt|;
block|}
else|else
name|format
operator|&=
operator|~
name|M6811_OP_IND16
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|addr
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|&
name|M6812_OP_PAGE
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|" {"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|val
argument_list|,
name|info
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|", %d}"
argument_list|,
name|page
argument_list|)
expr_stmt|;
name|format
operator|&=
operator|~
name|M6812_OP_PAGE
expr_stmt|;
name|pos
operator|+=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|format
operator|&
name|M6812_OP_IDX_P2
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|status
operator|=
name|print_indexed_operand
argument_list|(
name|memaddr
operator|+
name|pos
operator|+
name|offset
argument_list|,
name|info
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|pc_dst_offset
argument_list|,
name|memaddr
operator|+
name|pos
operator|+
name|offset
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
return|return
name|status
return|;
name|pos
operator|+=
name|status
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
name|M6812_OP_IND16_P2
condition|)
block|{
name|int
name|val
decl_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|status
operator|=
name|read_memory
argument_list|(
name|memaddr
operator|+
name|pos
operator|+
name|offset
argument_list|,
operator|&
name|buffer
index|[
literal|0
index|]
argument_list|,
literal|2
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
return|return
name|status
return|;
block|}
name|pos
operator|+=
literal|2
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|buffer
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|buffer
index|[
literal|1
index|]
operator|&
literal|0x0FF
operator|)
operator|)
expr_stmt|;
name|val
operator|&=
literal|0x0FFFF
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|val
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
comment|/* M6811_OP_BITMASK and M6811_OP_JUMP_REL must be treated separately          and in that order.  The brset/brclr insn have a bitmask and then          a relative branch offset.  */
if|if
condition|(
name|format
operator|&
name|M6811_OP_BITMASK
condition|)
block|{
name|status
operator|=
name|read_memory
argument_list|(
name|memaddr
operator|+
name|pos
argument_list|,
operator|&
name|buffer
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
return|return
name|status
return|;
block|}
name|pos
operator|++
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|" #$%02x%s"
argument_list|,
name|buffer
index|[
literal|0
index|]
operator|&
literal|0x0FF
argument_list|,
operator|(
name|format
operator|&
name|M6811_OP_JUMP_REL
condition|?
literal|" "
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|format
operator|&=
operator|~
name|M6811_OP_BITMASK
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
name|M6811_OP_JUMP_REL
condition|)
block|{
name|int
name|val
decl_stmt|;
name|status
operator|=
name|read_memory
argument_list|(
name|memaddr
operator|+
name|pos
argument_list|,
operator|&
name|buffer
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
return|return
name|status
return|;
block|}
name|pos
operator|++
expr_stmt|;
name|val
operator|=
operator|(
name|buffer
index|[
literal|0
index|]
operator|&
literal|0x80
operator|)
condition|?
name|buffer
index|[
literal|0
index|]
operator||
literal|0xFFFFFF00
else|:
name|buffer
index|[
literal|0
index|]
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|memaddr
operator|+
name|pos
operator|+
name|val
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|format
operator|&=
operator|~
name|M6811_OP_JUMP_REL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|format
operator|&
name|M6812_OP_JUMP_REL16
condition|)
block|{
name|int
name|val
decl_stmt|;
name|status
operator|=
name|read_memory
argument_list|(
name|memaddr
operator|+
name|pos
argument_list|,
operator|&
name|buffer
index|[
literal|0
index|]
argument_list|,
literal|2
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
return|return
name|status
return|;
block|}
name|pos
operator|+=
literal|2
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|buffer
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|buffer
index|[
literal|1
index|]
operator|&
literal|0x0FF
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|0x8000
condition|)
name|val
operator||=
literal|0xffff0000
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|memaddr
operator|+
name|pos
operator|+
name|val
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|format
operator|&=
operator|~
name|M6812_OP_JUMP_REL16
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|&
name|M6812_OP_PAGE
condition|)
block|{
name|int
name|val
decl_stmt|;
name|status
operator|=
name|read_memory
argument_list|(
name|memaddr
operator|+
name|pos
operator|+
name|offset
argument_list|,
operator|&
name|buffer
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
return|return
name|status
return|;
block|}
name|pos
operator|+=
literal|1
expr_stmt|;
name|val
operator|=
name|buffer
index|[
literal|0
index|]
operator|&
literal|0x0ff
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|", %d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
comment|/* Consistency check.  'format' must be 0, so that we have handled          all formats; and the computed size of the insn must match the          opcode table content.  */
if|if
condition|(
name|format
operator|&
operator|~
operator|(
name|M6811_OP_PAGE4
operator||
name|M6811_OP_PAGE3
operator||
name|M6811_OP_PAGE2
operator|)
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"; Error, format: %lx"
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|!=
name|opcode
operator|->
name|size
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"; Error, size: %ld expect %d"
argument_list|,
name|pos
argument_list|,
name|opcode
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|pos
return|;
block|}
comment|/* Opcode not recognized.  */
if|if
condition|(
name|format
operator|==
name|M6811_OP_PAGE2
operator|&&
name|arch
operator|&
name|cpu6812
operator|&&
operator|(
operator|(
name|code
operator|>=
literal|0x30
operator|&&
name|code
operator|<=
literal|0x39
operator|)
operator|||
operator|(
name|code
operator|>=
literal|0x40
operator|)
operator|)
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"trap\t#%d"
argument_list|,
name|code
operator|&
literal|0x0ff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|format
operator|==
name|M6811_OP_PAGE2
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|".byte\t0x%02x, 0x%02x"
argument_list|,
name|M6811_OPCODE_PAGE2
argument_list|,
name|code
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|format
operator|==
name|M6811_OP_PAGE3
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|".byte\t0x%02x, 0x%02x"
argument_list|,
name|M6811_OPCODE_PAGE3
argument_list|,
name|code
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|format
operator|==
name|M6811_OP_PAGE4
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|".byte\t0x%02x, 0x%02x"
argument_list|,
name|M6811_OPCODE_PAGE4
argument_list|,
name|code
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|".byte\t0x%02x"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
name|pos
return|;
block|}
end_function

begin_comment
comment|/* Disassemble one instruction at address 'memaddr'.  Returns the number    of bytes used by that instruction.  */
end_comment

begin_function
name|int
name|print_insn_m68hc11
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
return|return
name|print_insn
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|,
name|cpu6811
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|print_insn_m68hc12
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
return|return
name|print_insn
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|,
name|cpu6812
argument_list|)
return|;
block|}
end_function

end_unit

