begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Disassembler code for CR16.    Copyright 2007 Free Software Foundation, Inc.    Contributed by M R Swami Reddy (MR.Swami.Reddy@nsc.com).     This file is part of GAS, GDB and the GNU binutils.     This program is free software; you can redistribute it and/or modify it under    the terms of the GNU General Public License as published by the Free    Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for    more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"opcode/cr16.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_comment
comment|/* String to print when opcode was not matched.  */
end_comment

begin_define
define|#
directive|define
name|ILLEGAL
value|"illegal"
end_define

begin_comment
comment|/* Escape to 16-bit immediate.  */
end_comment

begin_define
define|#
directive|define
name|ESCAPE_16_BIT
value|0xB
end_define

begin_comment
comment|/* Extract 'n_bits' from 'a' starting from offset 'offs'.  */
end_comment

begin_define
define|#
directive|define
name|EXTRACT
parameter_list|(
name|a
parameter_list|,
name|offs
parameter_list|,
name|n_bits
parameter_list|)
define|\
value|(n_bits == 32 ? (((a)>> (offs))& 0xffffffffL)   \   : (((a)>> (offs))& ((1<< (n_bits)) -1)))
end_define

begin_comment
comment|/* Set Bit Mask - a mask to set all bits starting from offset 'offs'.  */
end_comment

begin_define
define|#
directive|define
name|SBM
parameter_list|(
name|offs
parameter_list|)
value|((((1<< (32 - offs)) -1)<< (offs)))
end_define

begin_typedef
typedef|typedef
name|unsigned
name|long
name|dwordU
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|short
name|wordU
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|dwordU
name|val
decl_stmt|;
name|int
name|nbits
decl_stmt|;
block|}
name|parameter
typedef|;
end_typedef

begin_comment
comment|/* Structure to map valid 'cinv' instruction options.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* Cinv printed string.  */
name|char
modifier|*
name|istr
decl_stmt|;
comment|/* Value corresponding to the string.  */
name|char
modifier|*
name|ostr
decl_stmt|;
block|}
name|cinv_entry
typedef|;
end_typedef

begin_comment
comment|/* CR16 'cinv' options mapping.  */
end_comment

begin_decl_stmt
specifier|const
name|cinv_entry
name|cr16_cinvs
index|[]
init|=
block|{
block|{
literal|"cinv[i]"
block|,
literal|"cinv    [i]"
block|}
block|,
block|{
literal|"cinv[i,u]"
block|,
literal|"cinv    [i,u]"
block|}
block|,
block|{
literal|"cinv[d]"
block|,
literal|"cinv    [d]"
block|}
block|,
block|{
literal|"cinv[d,u]"
block|,
literal|"cinv    [d,u]"
block|}
block|,
block|{
literal|"cinv[d,i]"
block|,
literal|"cinv    [d,i]"
block|}
block|,
block|{
literal|"cinv[d,i,u]"
block|,
literal|"cinv    [d,i,u]"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of valid 'cinv' instruction options.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|NUMCINVS
init|=
name|ARRAY_SIZE
argument_list|(
name|cr16_cinvs
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Enum to distinguish different registers argument types.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|REG_ARG_TYPE
block|{
comment|/* General purpose register (r<N>).  */
name|REG_ARG
init|=
literal|0
block|,
comment|/*Processor register   */
name|P_ARG
block|,   }
name|REG_ARG_TYPE
typedef|;
end_typedef

begin_comment
comment|/* Current opcode table entry we're disassembling.  */
end_comment

begin_decl_stmt
specifier|const
name|inst
modifier|*
name|instruction
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current instruction we're disassembling.  */
end_comment

begin_decl_stmt
name|ins
name|currInsn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current instruction is read into 3 consecutive words.  */
end_comment

begin_decl_stmt
name|wordU
name|words
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Contains all words in appropriate order.  */
end_comment

begin_decl_stmt
name|ULONGLONG
name|allWords
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds the current processed argument number.  */
end_comment

begin_decl_stmt
name|int
name|processing_argument_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means a IMM4 instruction.  */
end_comment

begin_decl_stmt
name|int
name|imm4flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means the instruction's original size is    incremented (escape sequence is used).  */
end_comment

begin_decl_stmt
name|int
name|size_changed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print the constant expression length.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|print_exp_len
parameter_list|(
name|int
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|4
case|:
case|case
literal|5
case|:
case|case
literal|6
case|:
case|case
literal|8
case|:
case|case
literal|14
case|:
case|case
literal|16
case|:
return|return
literal|":s"
return|;
case|case
literal|20
case|:
case|case
literal|24
case|:
case|case
literal|32
case|:
return|return
literal|":m"
return|;
case|case
literal|48
case|:
return|return
literal|":l"
return|;
default|default:
return|return
literal|""
return|;
block|}
block|}
end_function

begin_comment
comment|/* Retrieve the number of operands for the current assembled instruction.  */
end_comment

begin_function
specifier|static
name|int
name|get_number_of_operands
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|instruction
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|op_type
operator|&&
name|i
operator|<
name|MAX_OPERANDS
condition|;
name|i
operator|++
control|)
empty_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Return the bit size for a given operand.  */
end_comment

begin_function
specifier|static
name|int
name|getbits
parameter_list|(
name|operand_type
name|op
parameter_list|)
block|{
if|if
condition|(
name|op
operator|<
name|MAX_OPRD
condition|)
return|return
name|cr16_optab
index|[
name|op
index|]
operator|.
name|bit_size
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the argument type of a given operand.  */
end_comment

begin_function
specifier|static
name|argtype
name|getargtype
parameter_list|(
name|operand_type
name|op
parameter_list|)
block|{
if|if
condition|(
name|op
operator|<
name|MAX_OPRD
condition|)
return|return
name|cr16_optab
index|[
name|op
index|]
operator|.
name|arg_type
return|;
return|return
name|nullargs
return|;
block|}
end_function

begin_comment
comment|/* Given a 'CC' instruction constant operand, return its corresponding    string. This routine is used when disassembling the 'CC' instruction.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|getccstring
parameter_list|(
name|unsigned
name|cc
parameter_list|)
block|{
return|return
operator|(
name|char
operator|*
operator|)
name|cr16_b_cond_tab
index|[
name|cc
index|]
return|;
block|}
end_function

begin_comment
comment|/* Given a 'cinv' instruction constant operand, return its corresponding    string. This routine is used when disassembling the 'cinv' instruction. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|getcinvstring
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|const
name|cinv_entry
modifier|*
name|cinv
decl_stmt|;
for|for
control|(
name|cinv
operator|=
name|cr16_cinvs
init|;
name|cinv
operator|<
operator|(
name|cr16_cinvs
operator|+
name|NUMCINVS
operator|)
condition|;
name|cinv
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|cinv
operator|->
name|istr
argument_list|,
name|str
argument_list|)
operator|==
literal|0
condition|)
return|return
name|cinv
operator|->
name|ostr
return|;
return|return
name|ILLEGAL
return|;
block|}
end_function

begin_comment
comment|/* Given the trap index in dispatch table, return its name.    This routine is used when disassembling the 'excp' instruction.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|gettrapstring
parameter_list|(
name|unsigned
name|int
name|index
parameter_list|)
block|{
specifier|const
name|trap_entry
modifier|*
name|trap
decl_stmt|;
for|for
control|(
name|trap
operator|=
name|cr16_traps
init|;
name|trap
operator|<
name|cr16_traps
operator|+
name|NUMTRAPS
condition|;
name|trap
operator|++
control|)
if|if
condition|(
name|trap
operator|->
name|entry
operator|==
name|index
condition|)
return|return
name|trap
operator|->
name|name
return|;
return|return
name|ILLEGAL
return|;
block|}
end_function

begin_comment
comment|/* Given a register enum value, retrieve its name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|getregname
parameter_list|(
name|reg
name|r
parameter_list|)
block|{
specifier|const
name|reg_entry
modifier|*
name|reg
init|=
name|cr16_regtab
operator|+
name|r
decl_stmt|;
if|if
condition|(
name|reg
operator|->
name|type
operator|!=
name|CR16_R_REGTYPE
condition|)
return|return
name|ILLEGAL
return|;
return|return
name|reg
operator|->
name|name
return|;
block|}
end_function

begin_comment
comment|/* Given a register pair enum value, retrieve its name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|getregpname
parameter_list|(
name|reg
name|r
parameter_list|)
block|{
specifier|const
name|reg_entry
modifier|*
name|reg
init|=
name|cr16_regptab
operator|+
name|r
decl_stmt|;
if|if
condition|(
name|reg
operator|->
name|type
operator|!=
name|CR16_RP_REGTYPE
condition|)
return|return
name|ILLEGAL
return|;
return|return
name|reg
operator|->
name|name
return|;
block|}
end_function

begin_comment
comment|/* Given a index register pair enum value, retrieve its name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|getidxregpname
parameter_list|(
name|reg
name|r
parameter_list|)
block|{
specifier|const
name|reg_entry
modifier|*
name|reg
decl_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
literal|0
case|:
name|r
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|r
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|r
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|r
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|r
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|r
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|r
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|r
operator|=
literal|5
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|reg
operator|=
name|cr16_regptab
operator|+
name|r
expr_stmt|;
if|if
condition|(
name|reg
operator|->
name|type
operator|!=
name|CR16_RP_REGTYPE
condition|)
return|return
name|ILLEGAL
return|;
return|return
name|reg
operator|->
name|name
return|;
block|}
end_function

begin_comment
comment|/* Getting a processor register name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|getprocregname
parameter_list|(
name|int
name|index
parameter_list|)
block|{
specifier|const
name|reg_entry
modifier|*
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
name|cr16_pregtab
init|;
name|r
operator|<
name|cr16_pregtab
operator|+
name|NUMPREGS
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|r
operator|->
name|image
operator|==
name|index
condition|)
return|return
name|r
operator|->
name|name
return|;
return|return
literal|"ILLEGAL REGISTER"
return|;
block|}
end_function

begin_comment
comment|/* Getting a processor register name - 32 bit size.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|getprocpregname
parameter_list|(
name|int
name|index
parameter_list|)
block|{
specifier|const
name|reg_entry
modifier|*
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
name|cr16_pregptab
init|;
name|r
operator|<
name|cr16_pregptab
operator|+
name|NUMPREGPS
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|r
operator|->
name|image
operator|==
name|index
condition|)
return|return
name|r
operator|->
name|name
return|;
return|return
literal|"ILLEGAL REGISTER"
return|;
block|}
end_function

begin_comment
comment|/* START and END are relating 'allWords' struct, which is 48 bits size.                            START|--------|END              +---------+---------+---------+---------+              |         |   V    |     A    |   L     |              +---------+---------+---------+---------+                        0         16        32        48     words                  [0]       [1]       [2]      */
end_comment

begin_function
specifier|static
name|parameter
name|makelongparameter
parameter_list|(
name|ULONGLONG
name|val
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|parameter
name|p
decl_stmt|;
name|p
operator|.
name|val
operator|=
operator|(
name|dwordU
operator|)
name|EXTRACT
argument_list|(
name|val
argument_list|,
literal|48
operator|-
name|end
argument_list|,
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|p
operator|.
name|nbits
operator|=
name|end
operator|-
name|start
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Build a mask of the instruction's 'constant' opcode,    based on the instruction's printing flags.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|build_mask
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|mask
init|=
name|SBM
argument_list|(
name|instruction
operator|->
name|match_bits
argument_list|)
decl_stmt|;
return|return
name|mask
return|;
block|}
end_function

begin_comment
comment|/* Search for a matching opcode. Return 1 for success, 0 for failure.  */
end_comment

begin_function
specifier|static
name|int
name|match_opcode
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|mask
decl_stmt|;
comment|/* The instruction 'constant' opcode doewsn't exceed 32 bits.  */
name|unsigned
name|long
name|doubleWord
init|=
name|words
index|[
literal|1
index|]
operator|+
operator|(
name|words
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
decl_stmt|;
comment|/* Start searching from end of instruction table.  */
name|instruction
operator|=
operator|&
name|cr16_instruction
index|[
name|NUMOPCODES
operator|-
literal|2
index|]
expr_stmt|;
comment|/* Loop over instruction table until a full match is found.  */
while|while
condition|(
name|instruction
operator|>=
name|cr16_instruction
condition|)
block|{
name|mask
operator|=
name|build_mask
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|doubleWord
operator|&
name|mask
operator|)
operator|==
name|BIN
argument_list|(
name|instruction
operator|->
name|match
argument_list|,
name|instruction
operator|->
name|match_bits
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
name|instruction
operator|--
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Set the proper parameter value for different type of arguments.  */
end_comment

begin_function
specifier|static
name|void
name|make_argument
parameter_list|(
name|argument
modifier|*
name|a
parameter_list|,
name|int
name|start_bits
parameter_list|)
block|{
name|int
name|inst_bit_size
decl_stmt|;
name|parameter
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|instruction
operator|->
name|size
operator|==
literal|3
operator|)
operator|&&
name|a
operator|->
name|size
operator|>=
literal|16
condition|)
name|inst_bit_size
operator|=
literal|48
expr_stmt|;
else|else
name|inst_bit_size
operator|=
literal|32
expr_stmt|;
switch|switch
condition|(
name|a
operator|->
name|type
condition|)
block|{
case|case
name|arg_r
case|:
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
operator|-
operator|(
name|start_bits
operator|+
name|a
operator|->
name|size
operator|)
argument_list|,
name|inst_bit_size
operator|-
name|start_bits
argument_list|)
expr_stmt|;
name|a
operator|->
name|r
operator|=
name|p
operator|.
name|val
expr_stmt|;
break|break;
case|case
name|arg_rp
case|:
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
operator|-
operator|(
name|start_bits
operator|+
name|a
operator|->
name|size
operator|)
argument_list|,
name|inst_bit_size
operator|-
name|start_bits
argument_list|)
expr_stmt|;
name|a
operator|->
name|rp
operator|=
name|p
operator|.
name|val
expr_stmt|;
break|break;
case|case
name|arg_pr
case|:
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
operator|-
operator|(
name|start_bits
operator|+
name|a
operator|->
name|size
operator|)
argument_list|,
name|inst_bit_size
operator|-
name|start_bits
argument_list|)
expr_stmt|;
name|a
operator|->
name|pr
operator|=
name|p
operator|.
name|val
expr_stmt|;
break|break;
case|case
name|arg_prp
case|:
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
operator|-
operator|(
name|start_bits
operator|+
name|a
operator|->
name|size
operator|)
argument_list|,
name|inst_bit_size
operator|-
name|start_bits
argument_list|)
expr_stmt|;
name|a
operator|->
name|prp
operator|=
name|p
operator|.
name|val
expr_stmt|;
break|break;
case|case
name|arg_ic
case|:
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
operator|-
operator|(
name|start_bits
operator|+
name|a
operator|->
name|size
operator|)
argument_list|,
name|inst_bit_size
operator|-
name|start_bits
argument_list|)
expr_stmt|;
name|a
operator|->
name|constant
operator|=
name|p
operator|.
name|val
expr_stmt|;
break|break;
case|case
name|arg_cc
case|:
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
operator|-
operator|(
name|start_bits
operator|+
name|a
operator|->
name|size
operator|)
argument_list|,
name|inst_bit_size
operator|-
name|start_bits
argument_list|)
expr_stmt|;
name|a
operator|->
name|cc
operator|=
name|p
operator|.
name|val
expr_stmt|;
break|break;
case|case
name|arg_idxr
case|:
if|if
condition|(
operator|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"cbitb"
argument_list|)
operator|)
operator|||
operator|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"sbitb"
argument_list|)
operator|)
operator|||
operator|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"tbitb"
argument_list|)
operator|)
condition|)
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
literal|8
argument_list|,
literal|9
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
literal|9
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|a
operator|->
name|i_r
operator|=
name|p
operator|.
name|val
expr_stmt|;
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
operator|-
name|a
operator|->
name|size
argument_list|,
name|inst_bit_size
argument_list|)
expr_stmt|;
name|a
operator|->
name|constant
operator|=
name|p
operator|.
name|val
expr_stmt|;
break|break;
case|case
name|arg_idxrp
case|:
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|start_bits
operator|+
literal|12
argument_list|,
name|start_bits
operator|+
literal|13
argument_list|)
expr_stmt|;
name|a
operator|->
name|i_r
operator|=
name|p
operator|.
name|val
expr_stmt|;
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|start_bits
operator|+
literal|13
argument_list|,
name|start_bits
operator|+
literal|16
argument_list|)
expr_stmt|;
name|a
operator|->
name|rp
operator|=
name|p
operator|.
name|val
expr_stmt|;
if|if
condition|(
name|inst_bit_size
operator|>
literal|32
condition|)
block|{
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
operator|-
name|start_bits
operator|-
literal|12
argument_list|,
name|inst_bit_size
argument_list|)
expr_stmt|;
name|a
operator|->
name|constant
operator|=
operator|(
operator|(
name|p
operator|.
name|val
operator|&
literal|0xffff
operator|)
operator||
operator|(
name|p
operator|.
name|val
operator|>>
literal|8
operator|&
literal|0xf0000
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instruction
operator|->
name|size
operator|==
literal|2
condition|)
block|{
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
operator|-
literal|22
argument_list|,
name|inst_bit_size
argument_list|)
expr_stmt|;
name|a
operator|->
name|constant
operator|=
operator|(
name|p
operator|.
name|val
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
operator|(
name|p
operator|.
name|val
operator|>>
literal|20
operator|)
operator|&
literal|0x3
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|p
operator|.
name|val
operator|>>
literal|14
operator|&
literal|0x3
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
operator|(
operator|(
name|p
operator|.
name|val
operator|>>
literal|7
operator|)
operator|&
literal|0x1f
operator|)
operator|<<
literal|7
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instruction
operator|->
name|size
operator|==
literal|1
operator|&&
name|a
operator|->
name|size
operator|==
literal|0
condition|)
name|a
operator|->
name|constant
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|arg_rbase
case|:
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
argument_list|,
name|inst_bit_size
argument_list|)
expr_stmt|;
name|a
operator|->
name|constant
operator|=
name|p
operator|.
name|val
expr_stmt|;
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
operator|-
operator|(
name|start_bits
operator|+
literal|4
operator|)
argument_list|,
name|inst_bit_size
operator|-
name|start_bits
argument_list|)
expr_stmt|;
name|a
operator|->
name|r
operator|=
name|p
operator|.
name|val
expr_stmt|;
break|break;
case|case
name|arg_cr
case|:
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|start_bits
operator|+
literal|12
argument_list|,
name|start_bits
operator|+
literal|16
argument_list|)
expr_stmt|;
name|a
operator|->
name|r
operator|=
name|p
operator|.
name|val
expr_stmt|;
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
operator|-
literal|16
argument_list|,
name|inst_bit_size
argument_list|)
expr_stmt|;
name|a
operator|->
name|constant
operator|=
name|p
operator|.
name|val
expr_stmt|;
break|break;
case|case
name|arg_crp
case|:
if|if
condition|(
name|instruction
operator|->
name|size
operator|==
literal|1
condition|)
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
literal|12
argument_list|,
literal|16
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|start_bits
operator|+
literal|12
argument_list|,
name|start_bits
operator|+
literal|16
argument_list|)
expr_stmt|;
name|a
operator|->
name|rp
operator|=
name|p
operator|.
name|val
expr_stmt|;
if|if
condition|(
name|inst_bit_size
operator|>
literal|32
condition|)
block|{
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
operator|-
name|start_bits
operator|-
literal|12
argument_list|,
name|inst_bit_size
argument_list|)
expr_stmt|;
name|a
operator|->
name|constant
operator|=
operator|(
operator|(
name|p
operator|.
name|val
operator|&
literal|0xffff
operator|)
operator||
operator|(
name|p
operator|.
name|val
operator|>>
literal|8
operator|&
literal|0xf0000
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instruction
operator|->
name|size
operator|==
literal|2
condition|)
block|{
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
operator|-
literal|16
argument_list|,
name|inst_bit_size
argument_list|)
expr_stmt|;
name|a
operator|->
name|constant
operator|=
name|p
operator|.
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instruction
operator|->
name|size
operator|==
literal|1
operator|&&
name|a
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
literal|4
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"loadw"
argument_list|)
operator|||
name|IS_INSN_MNEMONIC
argument_list|(
literal|"loadd"
argument_list|)
operator|||
name|IS_INSN_MNEMONIC
argument_list|(
literal|"storw"
argument_list|)
operator|||
name|IS_INSN_MNEMONIC
argument_list|(
literal|"stord"
argument_list|)
condition|)
name|a
operator|->
name|constant
operator|=
operator|(
name|p
operator|.
name|val
operator|*
literal|2
operator|)
expr_stmt|;
else|else
name|a
operator|->
name|constant
operator|=
name|p
operator|.
name|val
expr_stmt|;
block|}
else|else
comment|/* below case for 0x0(reg pair) */
name|a
operator|->
name|constant
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|arg_c
case|:
if|if
condition|(
operator|(
name|IS_INSN_TYPE
argument_list|(
name|BRANCH_INS
argument_list|)
operator|)
operator|||
operator|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"bal"
argument_list|)
operator|)
operator|||
operator|(
name|IS_INSN_TYPE
argument_list|(
name|CSTBIT_INS
argument_list|)
operator|)
operator|||
operator|(
name|IS_INSN_TYPE
argument_list|(
name|LD_STOR_INS
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|a
operator|->
name|size
condition|)
block|{
case|case
literal|8
case|:
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
literal|0
argument_list|,
name|start_bits
argument_list|)
expr_stmt|;
name|a
operator|->
name|constant
operator|=
operator|(
operator|(
operator|(
operator|(
name|p
operator|.
name|val
operator|&
literal|0xf00
operator|)
operator|>>
literal|4
operator|)
operator|)
operator||
operator|(
name|p
operator|.
name|val
operator|&
literal|0xf
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|24
case|:
if|if
condition|(
name|instruction
operator|->
name|size
operator|==
literal|3
condition|)
block|{
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
literal|16
argument_list|,
name|inst_bit_size
argument_list|)
expr_stmt|;
name|a
operator|->
name|constant
operator|=
operator|(
operator|(
operator|(
operator|(
name|p
operator|.
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|20
operator|)
operator||
operator|(
operator|(
operator|(
name|p
operator|.
name|val
operator|>>
literal|24
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|p
operator|.
name|val
operator|&
literal|0xffff
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instruction
operator|->
name|size
operator|==
literal|2
condition|)
block|{
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
literal|8
argument_list|,
name|inst_bit_size
argument_list|)
expr_stmt|;
name|a
operator|->
name|constant
operator|=
name|p
operator|.
name|val
expr_stmt|;
block|}
break|break;
default|default:
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
operator|-
operator|(
name|start_bits
operator|+
name|a
operator|->
name|size
operator|)
argument_list|,
name|inst_bit_size
operator|-
name|start_bits
argument_list|)
expr_stmt|;
name|a
operator|->
name|constant
operator|=
name|p
operator|.
name|val
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|p
operator|=
name|makelongparameter
argument_list|(
name|allWords
argument_list|,
name|inst_bit_size
operator|-
operator|(
name|start_bits
operator|+
name|a
operator|->
name|size
operator|)
argument_list|,
name|inst_bit_size
operator|-
name|start_bits
argument_list|)
expr_stmt|;
name|a
operator|->
name|constant
operator|=
name|p
operator|.
name|val
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  Print a single argument.  */
end_comment

begin_function
specifier|static
name|void
name|print_arg
parameter_list|(
name|argument
modifier|*
name|a
parameter_list|,
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|LONGLONG
name|longdisp
decl_stmt|,
name|mask
decl_stmt|;
name|int
name|sign_flag
init|=
literal|0
decl_stmt|;
name|int
name|relative
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|number
decl_stmt|;
name|PTR
name|stream
init|=
name|info
operator|->
name|stream
decl_stmt|;
name|fprintf_ftype
name|func
init|=
name|info
operator|->
name|fprintf_func
decl_stmt|;
switch|switch
condition|(
name|a
operator|->
name|type
condition|)
block|{
case|case
name|arg_r
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|getregname
argument_list|(
name|a
operator|->
name|r
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_rp
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|getregpname
argument_list|(
name|a
operator|->
name|rp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_pr
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|getprocregname
argument_list|(
name|a
operator|->
name|pr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_prp
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|getprocpregname
argument_list|(
name|a
operator|->
name|prp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_cc
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|getccstring
argument_list|(
name|a
operator|->
name|cc
argument_list|)
argument_list|)
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_ic
case|:
if|if
condition|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"excp"
argument_list|)
condition|)
block|{
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|gettrapstring
argument_list|(
name|a
operator|->
name|constant
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|IS_INSN_TYPE
argument_list|(
name|ARITH_INS
argument_list|)
operator|||
name|IS_INSN_TYPE
argument_list|(
name|ARITH_BYTE_INS
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|instruction
operator|->
name|size
operator|==
literal|1
operator|)
operator|&&
operator|(
name|a
operator|->
name|constant
operator|==
literal|9
operator|)
operator|)
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"$%d"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|INST_HAS_REG_LIST
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"$0x%lx"
argument_list|,
name|a
operator|->
name|constant
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|SHIFT_INS
argument_list|)
condition|)
block|{
name|longdisp
operator|=
name|a
operator|->
name|constant
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
name|LONGLONG
operator|)
literal|1
operator|<<
name|a
operator|->
name|size
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|longdisp
operator|&
operator|(
operator|(
name|LONGLONG
operator|)
literal|1
operator|<<
operator|(
name|a
operator|->
name|size
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|sign_flag
operator|=
literal|1
expr_stmt|;
name|longdisp
operator|=
operator|~
operator|(
name|longdisp
operator|)
operator|+
literal|1
expr_stmt|;
block|}
name|a
operator|->
name|constant
operator|=
call|(
name|unsigned
name|long
name|int
call|)
argument_list|(
name|longdisp
operator|&
name|mask
argument_list|)
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"$%d"
argument_list|,
operator|(
call|(
name|int
call|)
argument_list|(
name|sign_flag
condition|?
operator|-
name|a
operator|->
name|constant
else|:
name|a
operator|->
name|constant
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|func
argument_list|(
name|stream
argument_list|,
literal|"$0x%lx"
argument_list|,
name|a
operator|->
name|constant
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|a
operator|->
name|size
condition|)
block|{
case|case
literal|4
case|:
case|case
literal|5
case|:
case|case
literal|6
case|:
case|case
literal|8
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
literal|":s"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
case|case
literal|20
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
literal|":m"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|24
case|:
case|case
literal|32
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
literal|":l"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|arg_idxr
case|:
if|if
condition|(
name|a
operator|->
name|i_r
operator|==
literal|0
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"[r12]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|i_r
operator|==
literal|1
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"[r13]"
argument_list|)
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
name|a
operator|->
name|constant
argument_list|)
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|print_exp_len
argument_list|(
name|instruction
operator|->
name|size
operator|*
literal|16
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_idxrp
case|:
if|if
condition|(
name|a
operator|->
name|i_r
operator|==
literal|0
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"[r12]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|i_r
operator|==
literal|1
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"[r13]"
argument_list|)
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
name|a
operator|->
name|constant
argument_list|)
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|print_exp_len
argument_list|(
name|instruction
operator|->
name|size
operator|*
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|getidxregpname
argument_list|(
name|a
operator|->
name|rp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_rbase
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"(%s)"
argument_list|,
name|getregname
argument_list|(
name|a
operator|->
name|r
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_cr
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
name|a
operator|->
name|constant
argument_list|)
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|print_exp_len
argument_list|(
name|instruction
operator|->
name|size
operator|*
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"(%s)"
argument_list|,
name|getregname
argument_list|(
name|a
operator|->
name|r
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_crp
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
name|a
operator|->
name|constant
argument_list|)
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|print_exp_len
argument_list|(
name|instruction
operator|->
name|size
operator|*
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|getregpname
argument_list|(
name|a
operator|->
name|rp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|arg_c
case|:
comment|/*Removed the *2 part as because implicit zeros are no more required. 	Have to fix this as this needs a bit of extension in terms of branch 	instructions. */
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|BRANCH_INS
argument_list|)
operator|||
name|IS_INSN_MNEMONIC
argument_list|(
literal|"bal"
argument_list|)
condition|)
block|{
name|relative
operator|=
literal|1
expr_stmt|;
name|longdisp
operator|=
name|a
operator|->
name|constant
expr_stmt|;
comment|/* REVISIT: To sync with WinIDEA and CR16 4.1tools, the below 	     line commented */
comment|/* longdisp<<= 1; */
name|mask
operator|=
operator|(
operator|(
name|LONGLONG
operator|)
literal|1
operator|<<
name|a
operator|->
name|size
operator|)
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|a
operator|->
name|size
condition|)
block|{
case|case
literal|8
case|:
block|{
name|longdisp
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|longdisp
operator|&
operator|(
operator|(
name|LONGLONG
operator|)
literal|1
operator|<<
name|a
operator|->
name|size
operator|)
condition|)
block|{
name|sign_flag
operator|=
literal|1
expr_stmt|;
name|longdisp
operator|=
operator|~
operator|(
name|longdisp
operator|)
operator|+
literal|1
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|16
case|:
case|case
literal|24
case|:
block|{
if|if
condition|(
name|longdisp
operator|&
literal|1
condition|)
block|{
name|sign_flag
operator|=
literal|1
expr_stmt|;
name|longdisp
operator|=
operator|~
operator|(
name|longdisp
operator|)
operator|+
literal|1
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|func
argument_list|(
name|stream
argument_list|,
literal|"Wrong offset used in branch/bal instruction"
argument_list|)
expr_stmt|;
break|break;
block|}
name|a
operator|->
name|constant
operator|=
call|(
name|unsigned
name|long
name|int
call|)
argument_list|(
name|longdisp
operator|&
name|mask
argument_list|)
expr_stmt|;
block|}
comment|/* For branch Neq instruction it is 2*offset + 2.  */
elseif|else
if|if
condition|(
name|IS_INSN_TYPE
argument_list|(
name|BRANCH_NEQ_INS
argument_list|)
condition|)
name|a
operator|->
name|constant
operator|=
literal|2
operator|*
name|a
operator|->
name|constant
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|IS_INSN_TYPE
argument_list|(
name|CSTBIT_INS
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|IS_INSN_TYPE
argument_list|(
name|LD_STOR_INS
argument_list|)
operator|)
condition|)
operator|(
name|sign_flag
operator|)
condition|?
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
literal|"*-"
argument_list|)
else|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
literal|"*+"
argument_list|)
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
literal|"0x"
argument_list|)
expr_stmt|;
name|number
operator|=
operator|(
operator|(
name|relative
condition|?
name|memaddr
else|:
literal|0
operator|)
operator|+
operator|(
name|sign_flag
condition|?
operator|(
operator|(
operator|-
name|a
operator|->
name|constant
operator|)
operator|&
literal|0xffffffe
operator|)
else|:
name|a
operator|->
name|constant
operator|)
operator|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
operator|(
name|number
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|24
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|print_exp_len
argument_list|(
name|instruction
operator|->
name|size
operator|*
literal|16
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Print all the arguments of CURRINSN instruction.  */
end_comment

begin_function
specifier|static
name|void
name|print_arguments
parameter_list|(
name|ins
modifier|*
name|currInsn
parameter_list|,
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* For "pop/push/popret RA instruction only.  */
if|if
condition|(
operator|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"pop"
argument_list|)
operator|||
operator|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"popret"
argument_list|)
operator|||
operator|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"push"
argument_list|)
operator|)
operator|)
operator|)
operator|&&
name|currInsn
operator|->
name|nargs
operator|==
literal|1
condition|)
block|{
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"RA"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|currInsn
operator|->
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|processing_argument_number
operator|=
name|i
expr_stmt|;
comment|/* For "bal (ra), disp17" instruction only.  */
if|if
condition|(
operator|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"bal"
argument_list|)
operator|)
operator|&&
operator|(
name|i
operator|==
literal|0
operator|)
operator|&&
name|instruction
operator|->
name|size
operator|==
literal|2
condition|)
block|{
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"(ra),"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|INST_HAS_REG_LIST
operator|)
operator|&&
operator|(
name|i
operator|==
literal|2
operator|)
condition|)
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"RA"
argument_list|)
expr_stmt|;
else|else
name|print_arg
argument_list|(
operator|&
name|currInsn
operator|->
name|arg
index|[
name|i
index|]
argument_list|,
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|!=
name|currInsn
operator|->
name|nargs
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|!
name|IS_INSN_MNEMONIC
argument_list|(
literal|"b"
argument_list|)
operator|)
condition|)
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build the instruction's arguments.  */
end_comment

begin_function
specifier|static
name|void
name|make_instruction
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|shift
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|currInsn
operator|.
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|argument
name|a
decl_stmt|;
name|memset
argument_list|(
operator|&
name|a
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|.
name|type
operator|=
name|getargtype
argument_list|(
name|instruction
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|op_type
argument_list|)
expr_stmt|;
name|a
operator|.
name|size
operator|=
name|getbits
argument_list|(
name|instruction
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|op_type
argument_list|)
expr_stmt|;
name|shift
operator|=
name|instruction
operator|->
name|operands
index|[
name|i
index|]
operator|.
name|shift
expr_stmt|;
name|make_argument
argument_list|(
operator|&
name|a
argument_list|,
name|shift
argument_list|)
expr_stmt|;
name|currInsn
operator|.
name|arg
index|[
name|i
index|]
operator|=
name|a
expr_stmt|;
block|}
comment|/* Calculate instruction size (in bytes).  */
name|currInsn
operator|.
name|size
operator|=
name|instruction
operator|->
name|size
operator|+
operator|(
name|size_changed
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
comment|/* Now in bits.  */
name|currInsn
operator|.
name|size
operator|*=
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Retrieve a single word from a given memory address.  */
end_comment

begin_function
specifier|static
name|wordU
name|get_word_at_PC
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd_byte
name|buffer
index|[
literal|4
index|]
decl_stmt|;
name|int
name|status
decl_stmt|;
name|wordU
name|insn
init|=
literal|0
decl_stmt|;
name|status
operator|=
name|info
operator|->
name|read_memory_func
argument_list|(
name|memaddr
argument_list|,
name|buffer
argument_list|,
literal|2
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|insn
operator|=
operator|(
name|wordU
operator|)
name|bfd_getl16
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Retrieve multiple words (3) from a given memory address.  */
end_comment

begin_function
specifier|static
name|void
name|get_words_at_PC
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bfd_vma
name|mem
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|mem
operator|=
name|memaddr
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
operator|,
name|mem
operator|+=
literal|2
control|)
name|words
index|[
name|i
index|]
operator|=
name|get_word_at_PC
argument_list|(
name|mem
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|allWords
operator|=
operator|(
operator|(
name|ULONGLONG
operator|)
name|words
index|[
literal|0
index|]
operator|<<
literal|32
operator|)
operator|+
operator|(
operator|(
name|unsigned
name|long
operator|)
name|words
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator|+
name|words
index|[
literal|2
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prints the instruction by calling print_arguments after proper matching.  */
end_comment

begin_function
name|int
name|print_insn_cr16
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|int
name|is_decoded
decl_stmt|;
comment|/* Nonzero means instruction has a match.  */
comment|/* Initialize global variables.  */
name|imm4flag
operator|=
literal|0
expr_stmt|;
name|size_changed
operator|=
literal|0
expr_stmt|;
comment|/* Retrieve the encoding from current memory location.  */
name|get_words_at_PC
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* Find a matching opcode in table.  */
name|is_decoded
operator|=
name|match_opcode
argument_list|()
expr_stmt|;
comment|/* If found, print the instruction's mnemonic and arguments.  */
if|if
condition|(
name|is_decoded
operator|>
literal|0
operator|&&
operator|(
name|words
index|[
literal|0
index|]
operator|<<
literal|16
operator|||
name|words
index|[
literal|1
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strneq
argument_list|(
name|instruction
operator|->
name|mnemonic
argument_list|,
literal|"cinv"
argument_list|,
literal|4
argument_list|)
condition|)
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|getcinvstring
argument_list|(
operator|(
name|char
operator|*
operator|)
name|instruction
operator|->
name|mnemonic
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|instruction
operator|->
name|mnemonic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|currInsn
operator|.
name|nargs
operator|=
name|get_number_of_operands
argument_list|()
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|!
operator|(
name|IS_INSN_MNEMONIC
argument_list|(
literal|"b"
argument_list|)
operator|)
condition|)
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
name|make_instruction
argument_list|()
expr_stmt|;
comment|/* For push/pop/pushrtn with RA instructions.  */
if|if
condition|(
operator|(
name|INST_HAS_REG_LIST
operator|)
operator|&&
operator|(
operator|(
name|words
index|[
literal|0
index|]
operator|>>
literal|7
operator|)
operator|&
literal|0x1
operator|)
condition|)
name|currInsn
operator|.
name|nargs
operator|+=
literal|1
expr_stmt|;
name|print_arguments
argument_list|(
operator|&
name|currInsn
argument_list|,
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
name|currInsn
operator|.
name|size
return|;
block|}
comment|/* No match found.  */
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s "
argument_list|,
name|ILLEGAL
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
end_function

end_unit

