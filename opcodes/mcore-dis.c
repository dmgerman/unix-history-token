begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Disassemble Motorola M*Core instructions.    Copyright 1993, 1999, 2000, 2002 Free Software Foundation, Inc.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|STATIC_TABLE
end_define

begin_define
define|#
directive|define
name|DEFINE_TABLE
end_define

begin_include
include|#
directive|include
file|"mcore-opc.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_comment
comment|/* Mask for each mcore_opclass: */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|short
name|imsk
index|[]
init|=
block|{
comment|/* O0  */
literal|0xFFFF
block|,
comment|/* OT  */
literal|0xFFFC
block|,
comment|/* O1  */
literal|0xFFF0
block|,
comment|/* OC  */
literal|0xFE00
block|,
comment|/* O2  */
literal|0xFF00
block|,
comment|/* X1  */
literal|0xFFF0
block|,
comment|/* OI  */
literal|0xFE00
block|,
comment|/* OB  */
literal|0xFE00
block|,
comment|/* OMa */
literal|0xFFF0
block|,
comment|/* SI  */
literal|0xFE00
block|,
comment|/* I7  */
literal|0xF800
block|,
comment|/* LS  */
literal|0xF000
block|,
comment|/* BR  */
literal|0xF800
block|,
comment|/* BL  */
literal|0xFF00
block|,
comment|/* LR  */
literal|0xF000
block|,
comment|/* LJ  */
literal|0xFF00
block|,
comment|/* RM  */
literal|0xFFF0
block|,
comment|/* RQ  */
literal|0xFFF0
block|,
comment|/* JSR */
literal|0xFFF0
block|,
comment|/* JMP */
literal|0xFFF0
block|,
comment|/* OBRa*/
literal|0xFFF0
block|,
comment|/* OBRb*/
literal|0xFF80
block|,
comment|/* OBRc*/
literal|0xFF00
block|,
comment|/* OBR2*/
literal|0xFE00
block|,
comment|/* O1R1*/
literal|0xFFF0
block|,
comment|/* OMb */
literal|0xFF80
block|,
comment|/* OMc */
literal|0xFF00
block|,
comment|/* SIa */
literal|0xFE00
block|,
comment|/* MULSH */
literal|0xFF00
block|,
comment|/* OPSR  */
literal|0xFFF8
block|,
comment|/* psrset/psrclr */
comment|/* JC  */
literal|0
block|,
comment|/* JC,JU,JL don't appear in object */
comment|/* JU  */
literal|0
block|,
comment|/* JL  */
literal|0
block|,
comment|/* RSI */
literal|0
block|,
comment|/* DO21*/
literal|0
block|,
comment|/* OB2 */
literal|0
comment|/* OB2 won't appear in object.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|grname
index|[]
init|=
block|{
literal|"r0"
block|,
literal|"r1"
block|,
literal|"r2"
block|,
literal|"r3"
block|,
literal|"r4"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
literal|"r8"
block|,
literal|"r9"
block|,
literal|"r10"
block|,
literal|"r11"
block|,
literal|"r12"
block|,
literal|"r13"
block|,
literal|"r14"
block|,
literal|"r15"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|X
index|[]
init|=
literal|"??"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|crname
index|[]
init|=
block|{
literal|"psr"
block|,
literal|"vbr"
block|,
literal|"epsr"
block|,
literal|"fpsr"
block|,
literal|"epc"
block|,
literal|"fpc"
block|,
literal|"ss0"
block|,
literal|"ss1"
block|,
literal|"ss2"
block|,
literal|"ss3"
block|,
literal|"ss4"
block|,
literal|"gcr"
block|,
literal|"gsr"
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|,
name|X
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|isiz
index|[]
init|=
block|{
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|print_insn_mcore
parameter_list|(
name|memaddr
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|memaddr
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
name|unsigned
name|char
name|ibytes
index|[
literal|4
index|]
decl_stmt|;
name|fprintf_ftype
name|fprintf
init|=
name|info
operator|->
name|fprintf_func
decl_stmt|;
name|void
modifier|*
name|stream
init|=
name|info
operator|->
name|stream
decl_stmt|;
name|unsigned
name|short
name|inst
decl_stmt|;
specifier|const
name|mcore_opcode_info
modifier|*
name|op
decl_stmt|;
name|int
name|status
decl_stmt|;
name|info
operator|->
name|bytes_per_chunk
operator|=
literal|2
expr_stmt|;
name|status
operator|=
name|info
operator|->
name|read_memory_func
argument_list|(
name|memaddr
argument_list|,
name|ibytes
argument_list|,
literal|2
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|info
operator|->
name|memory_error_func
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|info
operator|->
name|endian
operator|==
name|BFD_ENDIAN_BIG
condition|)
name|inst
operator|=
operator|(
name|ibytes
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|ibytes
index|[
literal|1
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|endian
operator|==
name|BFD_ENDIAN_LITTLE
condition|)
name|inst
operator|=
operator|(
name|ibytes
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|ibytes
index|[
literal|0
index|]
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Just a linear search of the table.  */
for|for
control|(
name|op
operator|=
name|mcore_table
init|;
name|op
operator|->
name|name
operator|!=
literal|0
condition|;
name|op
operator|++
control|)
if|if
condition|(
name|op
operator|->
name|inst
operator|==
operator|(
name|inst
operator|&
name|imsk
index|[
name|op
operator|->
name|opclass
index|]
operator|)
condition|)
break|break;
if|if
condition|(
name|op
operator|->
name|name
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|".short 0x%04x"
argument_list|,
name|inst
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|grname
index|[
name|inst
operator|&
literal|0x0F
index|]
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|op
operator|->
name|name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
operator|->
name|opclass
condition|)
block|{
case|case
name|O0
case|:
break|break;
case|case
name|OT
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t%d"
argument_list|,
name|inst
operator|&
literal|0x3
argument_list|)
expr_stmt|;
break|break;
case|case
name|O1
case|:
case|case
name|JMP
case|:
case|case
name|JSR
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OC
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t%s, %s"
argument_list|,
name|name
argument_list|,
name|crname
index|[
operator|(
name|inst
operator|>>
literal|4
operator|)
operator|&
literal|0x1F
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|O1R1
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t%s, r1"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULSH
case|:
case|case
name|O2
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t%s, %s"
argument_list|,
name|name
argument_list|,
name|grname
index|[
operator|(
name|inst
operator|>>
literal|4
operator|)
operator|&
literal|0xF
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|X1
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tr1, %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OI
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t%s, %d"
argument_list|,
name|name
argument_list|,
operator|(
operator|(
name|inst
operator|>>
literal|4
operator|)
operator|&
literal|0x1F
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|RM
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t%s-r15, (r0)"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|RQ
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tr4-r7, (%s)"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OB
case|:
case|case
name|OBRa
case|:
case|case
name|OBRb
case|:
case|case
name|OBRc
case|:
case|case
name|SI
case|:
case|case
name|SIa
case|:
case|case
name|OMa
case|:
case|case
name|OMb
case|:
case|case
name|OMc
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t%s, %d"
argument_list|,
name|name
argument_list|,
operator|(
name|inst
operator|>>
literal|4
operator|)
operator|&
literal|0x1F
argument_list|)
expr_stmt|;
break|break;
case|case
name|I7
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t%s, %d"
argument_list|,
name|name
argument_list|,
operator|(
name|inst
operator|>>
literal|4
operator|)
operator|&
literal|0x7F
argument_list|)
expr_stmt|;
break|break;
case|case
name|LS
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t%s, (%s, %d)"
argument_list|,
name|grname
index|[
operator|(
name|inst
operator|>>
literal|8
operator|)
operator|&
literal|0xF
index|]
argument_list|,
name|name
argument_list|,
operator|(
operator|(
name|inst
operator|>>
literal|4
operator|)
operator|&
literal|0xF
operator|)
operator|<<
name|isiz
index|[
operator|(
name|inst
operator|>>
literal|13
operator|)
operator|&
literal|3
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|BR
case|:
block|{
name|long
name|val
init|=
name|inst
operator|&
literal|0x3FF
decl_stmt|;
if|if
condition|(
name|inst
operator|&
literal|0x400
condition|)
name|val
operator||=
literal|0xFFFFFC00
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t0x%x"
argument_list|,
name|memaddr
operator|+
literal|2
operator|+
operator|(
name|val
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|op
operator|->
name|name
argument_list|,
literal|"bsr"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* For bsr, we'll try to get a symbol for the target.  */
name|val
operator|=
name|memaddr
operator|+
literal|2
operator|+
operator|(
name|val
operator|<<
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|print_address_func
operator|&&
name|val
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t// "
argument_list|)
expr_stmt|;
name|info
operator|->
name|print_address_func
argument_list|(
name|val
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|BL
case|:
block|{
name|long
name|val
decl_stmt|;
name|val
operator|=
operator|(
name|inst
operator|&
literal|0x000F
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t%s, 0x%x"
argument_list|,
name|grname
index|[
operator|(
name|inst
operator|>>
literal|4
operator|)
operator|&
literal|0xF
index|]
argument_list|,
name|memaddr
operator|-
operator|(
name|val
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LR
case|:
block|{
name|unsigned
name|long
name|val
decl_stmt|;
name|val
operator|=
operator|(
name|memaddr
operator|+
literal|2
operator|+
operator|(
operator|(
name|inst
operator|&
literal|0xFF
operator|)
operator|<<
literal|2
operator|)
operator|)
operator|&
literal|0xFFFFFFFC
expr_stmt|;
name|status
operator|=
name|info
operator|->
name|read_memory_func
argument_list|(
name|val
argument_list|,
name|ibytes
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|info
operator|->
name|memory_error_func
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|info
operator|->
name|endian
operator|==
name|BFD_ENDIAN_LITTLE
condition|)
name|val
operator|=
operator|(
name|ibytes
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|ibytes
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|ibytes
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|ibytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
else|else
name|val
operator|=
operator|(
name|ibytes
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|ibytes
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|ibytes
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|ibytes
index|[
literal|3
index|]
operator|)
expr_stmt|;
comment|/* Removed [] around literal value to match ABI syntax 12/95.  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t%s, 0x%X"
argument_list|,
name|grname
index|[
operator|(
name|inst
operator|>>
literal|8
operator|)
operator|&
literal|0xF
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t// from address pool at 0x%x"
argument_list|,
operator|(
name|memaddr
operator|+
literal|2
operator|+
operator|(
operator|(
name|inst
operator|&
literal|0xFF
operator|)
operator|<<
literal|2
operator|)
operator|)
operator|&
literal|0xFFFFFFFC
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LJ
case|:
block|{
name|unsigned
name|long
name|val
decl_stmt|;
name|val
operator|=
operator|(
name|memaddr
operator|+
literal|2
operator|+
operator|(
operator|(
name|inst
operator|&
literal|0xFF
operator|)
operator|<<
literal|2
operator|)
operator|)
operator|&
literal|0xFFFFFFFC
expr_stmt|;
name|status
operator|=
name|info
operator|->
name|read_memory_func
argument_list|(
name|val
argument_list|,
name|ibytes
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|info
operator|->
name|memory_error_func
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|info
operator|->
name|endian
operator|==
name|BFD_ENDIAN_LITTLE
condition|)
name|val
operator|=
operator|(
name|ibytes
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|ibytes
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|ibytes
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|ibytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
else|else
name|val
operator|=
operator|(
name|ibytes
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|ibytes
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|ibytes
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|ibytes
index|[
literal|3
index|]
operator|)
expr_stmt|;
comment|/* Removed [] around literal value to match ABI syntax 12/95.  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t0x%X"
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* For jmpi/jsri, we'll try to get a symbol for the target.  */
if|if
condition|(
name|info
operator|->
name|print_address_func
operator|&&
name|val
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t// "
argument_list|)
expr_stmt|;
name|info
operator|->
name|print_address_func
argument_list|(
name|val
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t// from address pool at 0x%x"
argument_list|,
operator|(
name|memaddr
operator|+
literal|2
operator|+
operator|(
operator|(
name|inst
operator|&
literal|0xFF
operator|)
operator|<<
literal|2
operator|)
operator|)
operator|&
literal|0xFFFFFFFC
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OPSR
case|:
block|{
specifier|static
name|char
modifier|*
name|fields
index|[]
init|=
block|{
literal|"af"
block|,
literal|"ie"
block|,
literal|"fe"
block|,
literal|"fe,ie"
block|,
literal|"ee"
block|,
literal|"ee,ie"
block|,
literal|"ee,fe"
block|,
literal|"ee,fe,ie"
block|}
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t%s"
argument_list|,
name|fields
index|[
name|inst
operator|&
literal|0x7
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* If the disassembler lags the instruction set.  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tundecoded operands, inst is 0x%04x"
argument_list|,
name|inst
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Say how many bytes we consumed.  */
return|return
literal|2
return|;
block|}
end_function

end_unit

