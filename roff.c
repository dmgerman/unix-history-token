begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: roff.c,v 1.288 2017/01/12 18:02:20 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2008-2012, 2014 Kristaps Dzonsons<kristaps@bsd.lv>  * Copyright (c) 2010-2015, 2017 Ingo Schwarze<schwarze@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"mandoc.h"
end_include

begin_include
include|#
directive|include
file|"mandoc_aux.h"
end_include

begin_include
include|#
directive|include
file|"roff.h"
end_include

begin_include
include|#
directive|include
file|"libmandoc.h"
end_include

begin_include
include|#
directive|include
file|"roff_int.h"
end_include

begin_include
include|#
directive|include
file|"libroff.h"
end_include

begin_comment
comment|/* Maximum number of string expansions per line, to break infinite loops. */
end_comment

begin_define
define|#
directive|define
name|EXPAND_LIMIT
value|1000
end_define

begin_comment
comment|/* --- data types --------------------------------------------------------- */
end_comment

begin_enum
enum|enum
name|rofft
block|{
name|ROFF_ab
block|,
name|ROFF_ad
block|,
name|ROFF_af
block|,
name|ROFF_aln
block|,
name|ROFF_als
block|,
name|ROFF_am
block|,
name|ROFF_am1
block|,
name|ROFF_ami
block|,
name|ROFF_ami1
block|,
name|ROFF_as
block|,
name|ROFF_as1
block|,
name|ROFF_asciify
block|,
name|ROFF_backtrace
block|,
name|ROFF_bd
block|,
name|ROFF_bleedat
block|,
name|ROFF_blm
block|,
name|ROFF_box
block|,
name|ROFF_boxa
block|,
name|ROFF_bp
block|,
name|ROFF_BP
block|,
comment|/* MAN_br, MDOC_br */
name|ROFF_break
block|,
name|ROFF_breakchar
block|,
name|ROFF_brnl
block|,
name|ROFF_brp
block|,
name|ROFF_brpnl
block|,
name|ROFF_c2
block|,
name|ROFF_cc
block|,
name|ROFF_ce
block|,
name|ROFF_cf
block|,
name|ROFF_cflags
block|,
name|ROFF_ch
block|,
name|ROFF_char
block|,
name|ROFF_chop
block|,
name|ROFF_class
block|,
name|ROFF_close
block|,
name|ROFF_CL
block|,
name|ROFF_color
block|,
name|ROFF_composite
block|,
name|ROFF_continue
block|,
name|ROFF_cp
block|,
name|ROFF_cropat
block|,
name|ROFF_cs
block|,
name|ROFF_cu
block|,
name|ROFF_da
block|,
name|ROFF_dch
block|,
name|ROFF_Dd
block|,
name|ROFF_de
block|,
name|ROFF_de1
block|,
name|ROFF_defcolor
block|,
name|ROFF_dei
block|,
name|ROFF_dei1
block|,
name|ROFF_device
block|,
name|ROFF_devicem
block|,
name|ROFF_di
block|,
name|ROFF_do
block|,
name|ROFF_ds
block|,
name|ROFF_ds1
block|,
name|ROFF_dwh
block|,
name|ROFF_dt
block|,
name|ROFF_ec
block|,
name|ROFF_ecr
block|,
name|ROFF_ecs
block|,
name|ROFF_el
block|,
name|ROFF_em
block|,
name|ROFF_EN
block|,
name|ROFF_eo
block|,
name|ROFF_EP
block|,
name|ROFF_EQ
block|,
name|ROFF_errprint
block|,
name|ROFF_ev
block|,
name|ROFF_evc
block|,
name|ROFF_ex
block|,
name|ROFF_fallback
block|,
name|ROFF_fam
block|,
name|ROFF_fc
block|,
name|ROFF_fchar
block|,
name|ROFF_fcolor
block|,
name|ROFF_fdeferlig
block|,
name|ROFF_feature
block|,
comment|/* MAN_fi; ignored in mdoc(7) */
name|ROFF_fkern
block|,
name|ROFF_fl
block|,
name|ROFF_flig
block|,
name|ROFF_fp
block|,
name|ROFF_fps
block|,
name|ROFF_fschar
block|,
name|ROFF_fspacewidth
block|,
name|ROFF_fspecial
block|,
comment|/* MAN_ft; ignored in mdoc(7) */
name|ROFF_ftr
block|,
name|ROFF_fzoom
block|,
name|ROFF_gcolor
block|,
name|ROFF_hc
block|,
name|ROFF_hcode
block|,
name|ROFF_hidechar
block|,
name|ROFF_hla
block|,
name|ROFF_hlm
block|,
name|ROFF_hpf
block|,
name|ROFF_hpfa
block|,
name|ROFF_hpfcode
block|,
name|ROFF_hw
block|,
name|ROFF_hy
block|,
name|ROFF_hylang
block|,
name|ROFF_hylen
block|,
name|ROFF_hym
block|,
name|ROFF_hypp
block|,
name|ROFF_hys
block|,
name|ROFF_ie
block|,
name|ROFF_if
block|,
name|ROFF_ig
block|,
comment|/* MAN_in; ignored in mdoc(7) */
name|ROFF_index
block|,
name|ROFF_it
block|,
name|ROFF_itc
block|,
name|ROFF_IX
block|,
name|ROFF_kern
block|,
name|ROFF_kernafter
block|,
name|ROFF_kernbefore
block|,
name|ROFF_kernpair
block|,
name|ROFF_lc
block|,
name|ROFF_lc_ctype
block|,
name|ROFF_lds
block|,
name|ROFF_length
block|,
name|ROFF_letadj
block|,
name|ROFF_lf
block|,
name|ROFF_lg
block|,
name|ROFF_lhang
block|,
name|ROFF_linetabs
block|,
comment|/* MAN_ll, MDOC_ll */
name|ROFF_lnr
block|,
name|ROFF_lnrf
block|,
name|ROFF_lpfx
block|,
name|ROFF_ls
block|,
name|ROFF_lsm
block|,
name|ROFF_lt
block|,
name|ROFF_mc
block|,
name|ROFF_mediasize
block|,
name|ROFF_minss
block|,
name|ROFF_mk
block|,
name|ROFF_mso
block|,
name|ROFF_na
block|,
name|ROFF_ne
block|,
comment|/* MAN_nf; ignored in mdoc(7) */
name|ROFF_nh
block|,
name|ROFF_nhychar
block|,
name|ROFF_nm
block|,
name|ROFF_nn
block|,
name|ROFF_nop
block|,
name|ROFF_nr
block|,
name|ROFF_nrf
block|,
name|ROFF_nroff
block|,
name|ROFF_ns
block|,
name|ROFF_nx
block|,
name|ROFF_open
block|,
name|ROFF_opena
block|,
name|ROFF_os
block|,
name|ROFF_output
block|,
name|ROFF_padj
block|,
name|ROFF_papersize
block|,
name|ROFF_pc
block|,
name|ROFF_pev
block|,
name|ROFF_pi
block|,
name|ROFF_PI
block|,
name|ROFF_pl
block|,
name|ROFF_pm
block|,
name|ROFF_pn
block|,
name|ROFF_pnr
block|,
name|ROFF_po
block|,
name|ROFF_ps
block|,
name|ROFF_psbb
block|,
name|ROFF_pshape
block|,
name|ROFF_pso
block|,
name|ROFF_ptr
block|,
name|ROFF_pvs
block|,
name|ROFF_rchar
block|,
name|ROFF_rd
block|,
name|ROFF_recursionlimit
block|,
name|ROFF_return
block|,
name|ROFF_rfschar
block|,
name|ROFF_rhang
block|,
name|ROFF_rj
block|,
name|ROFF_rm
block|,
name|ROFF_rn
block|,
name|ROFF_rnn
block|,
name|ROFF_rr
block|,
name|ROFF_rs
block|,
name|ROFF_rt
block|,
name|ROFF_schar
block|,
name|ROFF_sentchar
block|,
name|ROFF_shc
block|,
name|ROFF_shift
block|,
name|ROFF_sizes
block|,
name|ROFF_so
block|,
comment|/* MAN_sp, MDOC_sp */
name|ROFF_spacewidth
block|,
name|ROFF_special
block|,
name|ROFF_spreadwarn
block|,
name|ROFF_ss
block|,
name|ROFF_sty
block|,
name|ROFF_substring
block|,
name|ROFF_sv
block|,
name|ROFF_sy
block|,
name|ROFF_T_
block|,
name|ROFF_ta
block|,
name|ROFF_tc
block|,
name|ROFF_TE
block|,
name|ROFF_TH
block|,
name|ROFF_ti
block|,
name|ROFF_tkf
block|,
name|ROFF_tl
block|,
name|ROFF_tm
block|,
name|ROFF_tm1
block|,
name|ROFF_tmc
block|,
name|ROFF_tr
block|,
name|ROFF_track
block|,
name|ROFF_transchar
block|,
name|ROFF_trf
block|,
name|ROFF_trimat
block|,
name|ROFF_trin
block|,
name|ROFF_trnt
block|,
name|ROFF_troff
block|,
name|ROFF_TS
block|,
name|ROFF_uf
block|,
name|ROFF_ul
block|,
name|ROFF_unformat
block|,
name|ROFF_unwatch
block|,
name|ROFF_unwatchn
block|,
name|ROFF_vpt
block|,
name|ROFF_vs
block|,
name|ROFF_warn
block|,
name|ROFF_warnscale
block|,
name|ROFF_watch
block|,
name|ROFF_watchlength
block|,
name|ROFF_watchn
block|,
name|ROFF_wh
block|,
name|ROFF_while
block|,
name|ROFF_write
block|,
name|ROFF_writec
block|,
name|ROFF_writem
block|,
name|ROFF_xflag
block|,
name|ROFF_cblock
block|,
name|ROFF_USERDEF
block|,
name|ROFF_MAX
block|}
enum|;
end_enum

begin_comment
comment|/*  * An incredibly-simple string buffer.  */
end_comment

begin_struct
struct|struct
name|roffstr
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* nil-terminated buffer */
name|size_t
name|sz
decl_stmt|;
comment|/* saved strlen(p) */
block|}
struct|;
end_struct

begin_comment
comment|/*  * A key-value roffstr pair as part of a singly-linked list.  */
end_comment

begin_struct
struct|struct
name|roffkv
block|{
name|struct
name|roffstr
name|key
decl_stmt|;
name|struct
name|roffstr
name|val
decl_stmt|;
name|struct
name|roffkv
modifier|*
name|next
decl_stmt|;
comment|/* next in list */
block|}
struct|;
end_struct

begin_comment
comment|/*  * A single number register as part of a singly-linked list.  */
end_comment

begin_struct
struct|struct
name|roffreg
block|{
name|struct
name|roffstr
name|key
decl_stmt|;
name|int
name|val
decl_stmt|;
name|struct
name|roffreg
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|roff
block|{
name|struct
name|mparse
modifier|*
name|parse
decl_stmt|;
comment|/* parse point */
name|struct
name|roffnode
modifier|*
name|last
decl_stmt|;
comment|/* leaf of stack */
name|int
modifier|*
name|rstack
decl_stmt|;
comment|/* stack of inverted `ie' values */
name|struct
name|roffreg
modifier|*
name|regtab
decl_stmt|;
comment|/* number registers */
name|struct
name|roffkv
modifier|*
name|strtab
decl_stmt|;
comment|/* user-defined strings& macros */
name|struct
name|roffkv
modifier|*
name|xmbtab
decl_stmt|;
comment|/* multi-byte trans table (`tr') */
name|struct
name|roffstr
modifier|*
name|xtab
decl_stmt|;
comment|/* single-byte trans table (`tr') */
specifier|const
name|char
modifier|*
name|current_string
decl_stmt|;
comment|/* value of last called user macro */
name|struct
name|tbl_node
modifier|*
name|first_tbl
decl_stmt|;
comment|/* first table parsed */
name|struct
name|tbl_node
modifier|*
name|last_tbl
decl_stmt|;
comment|/* last table parsed */
name|struct
name|tbl_node
modifier|*
name|tbl
decl_stmt|;
comment|/* current table being parsed */
name|struct
name|eqn_node
modifier|*
name|last_eqn
decl_stmt|;
comment|/* last equation parsed */
name|struct
name|eqn_node
modifier|*
name|first_eqn
decl_stmt|;
comment|/* first equation parsed */
name|struct
name|eqn_node
modifier|*
name|eqn
decl_stmt|;
comment|/* current equation being parsed */
name|int
name|eqn_inline
decl_stmt|;
comment|/* current equation is inline */
name|int
name|options
decl_stmt|;
comment|/* parse options */
name|int
name|rstacksz
decl_stmt|;
comment|/* current size limit of rstack */
name|int
name|rstackpos
decl_stmt|;
comment|/* position in rstack */
name|int
name|format
decl_stmt|;
comment|/* current file in mdoc or man format */
name|int
name|argc
decl_stmt|;
comment|/* number of args of the last macro */
name|char
name|control
decl_stmt|;
comment|/* control character */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|roffnode
block|{
name|enum
name|rofft
name|tok
decl_stmt|;
comment|/* type of node */
name|struct
name|roffnode
modifier|*
name|parent
decl_stmt|;
comment|/* up one in stack */
name|int
name|line
decl_stmt|;
comment|/* parse line */
name|int
name|col
decl_stmt|;
comment|/* parse col */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* node name, e.g. macro name */
name|char
modifier|*
name|end
decl_stmt|;
comment|/* end-rules: custom token */
name|int
name|endspan
decl_stmt|;
comment|/* end-rules: next-line or infty */
name|int
name|rule
decl_stmt|;
comment|/* current evaluation rule */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ROFF_ARGS
value|struct roff *r,
comment|/* parse ctx */
value|\ 			 enum rofft tok,
comment|/* tok of macro */
value|\ 			 struct buf *buf,
comment|/* input buffer */
value|\ 			 int ln,
comment|/* parse line */
value|\ 			 int ppos,
comment|/* original pos in buffer */
value|\ 			 int pos,
comment|/* current pos in buffer */
value|\ 			 int *offs
end_define

begin_comment
comment|/* reset offset of buffer data */
end_comment

begin_typedef
typedef|typedef
name|enum
name|rofferr
function_decl|(
modifier|*
name|roffproc
function_decl|)
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|roffmac
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* macro name */
name|roffproc
name|proc
decl_stmt|;
comment|/* process new macro */
name|roffproc
name|text
decl_stmt|;
comment|/* process as child text of macro */
name|roffproc
name|sub
decl_stmt|;
comment|/* process as child of macro */
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|ROFFMAC_STRUCT
value|(1<< 0)
comment|/* always interpret */
name|struct
name|roffmac
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|predef
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* predefined input name */
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
comment|/* replacement symbol */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PREDEF
parameter_list|(
name|__name
parameter_list|,
name|__str
parameter_list|)
define|\
value|{ (__name), (__str) },
end_define

begin_comment
comment|/* --- function prototypes ------------------------------------------------ */
end_comment

begin_function_decl
specifier|static
name|enum
name|rofft
name|roffhash_find
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|roffhash_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|roffnode_cleanscope
parameter_list|(
name|struct
name|roff
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|roffnode_pop
parameter_list|(
name|struct
name|roff
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|roffnode_push
parameter_list|(
name|struct
name|roff
modifier|*
parameter_list|,
name|enum
name|rofft
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_block
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_block_text
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_block_sub
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_brp
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_cblock
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_cc
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|roff_ccond
parameter_list|(
name|struct
name|roff
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_cond
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_cond_text
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_cond_sub
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_ds
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_eqndelim
parameter_list|(
name|struct
name|roff
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|roff_evalcond
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|roff_evalnum
parameter_list|(
name|struct
name|roff
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|roff_evalpar
parameter_list|(
name|struct
name|roff
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|roff_evalstrcond
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|roff_free1
parameter_list|(
name|struct
name|roff
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|roff_freereg
parameter_list|(
name|struct
name|roffreg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|roff_freestr
parameter_list|(
name|struct
name|roffkv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|roff_getname
parameter_list|(
name|struct
name|roff
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|roff_getnum
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|roff_getop
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|roff_getregn
parameter_list|(
specifier|const
name|struct
name|roff
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|roff_getregro
parameter_list|(
specifier|const
name|struct
name|roff
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|roff_getstrn
parameter_list|(
specifier|const
name|struct
name|roff
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|roff_hasregn
parameter_list|(
specifier|const
name|struct
name|roff
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_insec
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_it
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_line_ignore
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|roff_man_alloc1
parameter_list|(
name|struct
name|roff_man
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|roff_man_free1
parameter_list|(
name|struct
name|roff_man
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_nr
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofft
name|roff_parse
parameter_list|(
name|struct
name|roff
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_parsetext
parameter_list|(
name|struct
name|buf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_res
parameter_list|(
name|struct
name|roff
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_rm
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_rr
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|roff_setstr
parameter_list|(
name|struct
name|roff
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|roff_setstrn
parameter_list|(
name|struct
name|roffkv
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_so
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_tr
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_Dd
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_TH
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_TE
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_TS
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_EQ
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_EN
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_T_
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_unsupp
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|roff_userdef
parameter_list|(
name|ROFF_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* --- constant data ------------------------------------------------------ */
end_comment

begin_comment
comment|/* See roffhash_find() */
end_comment

begin_define
define|#
directive|define
name|ASCII_HI
value|126
end_define

begin_define
define|#
directive|define
name|ASCII_LO
value|33
end_define

begin_define
define|#
directive|define
name|HASHWIDTH
value|(ASCII_HI - ASCII_LO + 1)
end_define

begin_define
define|#
directive|define
name|ROFFNUM_SCALE
value|(1<< 0)
end_define

begin_comment
comment|/* Honour scaling in roff_getnum(). */
end_comment

begin_define
define|#
directive|define
name|ROFFNUM_WHITE
value|(1<< 1)
end_define

begin_comment
comment|/* Skip whitespace in roff_evalnum(). */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|roffmac
modifier|*
name|hash
index|[
name|HASHWIDTH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|roffmac
name|roffs
index|[
name|ROFF_MAX
index|]
init|=
block|{
block|{
literal|"ab"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ad"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"af"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"aln"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"als"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"am"
block|,
name|roff_block
block|,
name|roff_block_text
block|,
name|roff_block_sub
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"am1"
block|,
name|roff_block
block|,
name|roff_block_text
block|,
name|roff_block_sub
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ami"
block|,
name|roff_block
block|,
name|roff_block_text
block|,
name|roff_block_sub
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ami1"
block|,
name|roff_block
block|,
name|roff_block_text
block|,
name|roff_block_sub
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"as"
block|,
name|roff_ds
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"as1"
block|,
name|roff_ds
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"asciify"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"backtrace"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"bd"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"bleedat"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"blm"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"box"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"boxa"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"bp"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"BP"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"break"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"breakchar"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"brnl"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"brp"
block|,
name|roff_brp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"brpnl"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"c2"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"cc"
block|,
name|roff_cc
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ce"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"cf"
block|,
name|roff_insec
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"cflags"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ch"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"char"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"chop"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"class"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"close"
block|,
name|roff_insec
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"CL"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"color"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"composite"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"continue"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"cp"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"cropat"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"cs"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"cu"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"da"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"dch"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"Dd"
block|,
name|roff_Dd
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"de"
block|,
name|roff_block
block|,
name|roff_block_text
block|,
name|roff_block_sub
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"de1"
block|,
name|roff_block
block|,
name|roff_block_text
block|,
name|roff_block_sub
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"defcolor"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"dei"
block|,
name|roff_block
block|,
name|roff_block_text
block|,
name|roff_block_sub
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"dei1"
block|,
name|roff_block
block|,
name|roff_block_text
block|,
name|roff_block_sub
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"device"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"devicem"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"di"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"do"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ds"
block|,
name|roff_ds
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ds1"
block|,
name|roff_ds
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"dwh"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"dt"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ec"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ecr"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ecs"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"el"
block|,
name|roff_cond
block|,
name|roff_cond_text
block|,
name|roff_cond_sub
block|,
name|ROFFMAC_STRUCT
block|,
name|NULL
block|}
block|,
block|{
literal|"em"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"EN"
block|,
name|roff_EN
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"eo"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"EP"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"EQ"
block|,
name|roff_EQ
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"errprint"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ev"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"evc"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ex"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"fallback"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"fam"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"fc"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"fchar"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"fcolor"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"fdeferlig"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"feature"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"fkern"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"fl"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"flig"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"fp"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"fps"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"fschar"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"fspacewidth"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"fspecial"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ftr"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"fzoom"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"gcolor"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"hc"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"hcode"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"hidechar"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"hla"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"hlm"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"hpf"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"hpfa"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"hpfcode"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"hw"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"hy"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"hylang"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"hylen"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"hym"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"hypp"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"hys"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ie"
block|,
name|roff_cond
block|,
name|roff_cond_text
block|,
name|roff_cond_sub
block|,
name|ROFFMAC_STRUCT
block|,
name|NULL
block|}
block|,
block|{
literal|"if"
block|,
name|roff_cond
block|,
name|roff_cond_text
block|,
name|roff_cond_sub
block|,
name|ROFFMAC_STRUCT
block|,
name|NULL
block|}
block|,
block|{
literal|"ig"
block|,
name|roff_block
block|,
name|roff_block_text
block|,
name|roff_block_sub
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"index"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"it"
block|,
name|roff_it
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"itc"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"IX"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"kern"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"kernafter"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"kernbefore"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"kernpair"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"lc"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"lc_ctype"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"lds"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"length"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"letadj"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"lf"
block|,
name|roff_insec
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"lg"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"lhang"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"linetabs"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"lnr"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"lnrf"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"lpfx"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ls"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"lsm"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"lt"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"mc"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"mediasize"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"minss"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"mk"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"mso"
block|,
name|roff_insec
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"na"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ne"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"nh"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"nhychar"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"nm"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"nn"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"nop"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"nr"
block|,
name|roff_nr
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"nrf"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"nroff"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ns"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"nx"
block|,
name|roff_insec
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"open"
block|,
name|roff_insec
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"opena"
block|,
name|roff_insec
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"os"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"output"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"padj"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"papersize"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"pc"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"pev"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"pi"
block|,
name|roff_insec
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"PI"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"pl"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"pm"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"pn"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"pnr"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"po"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ps"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"psbb"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"pshape"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"pso"
block|,
name|roff_insec
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ptr"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"pvs"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"rchar"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"rd"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"recursionlimit"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"return"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"rfschar"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"rhang"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"rj"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"rm"
block|,
name|roff_rm
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"rn"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"rnn"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"rr"
block|,
name|roff_rr
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"rs"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"rt"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"schar"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"sentchar"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"shc"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"shift"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"sizes"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"so"
block|,
name|roff_so
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"spacewidth"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"special"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"spreadwarn"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ss"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"sty"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"substring"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"sv"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"sy"
block|,
name|roff_insec
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"T&"
block|,
name|roff_T_
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ta"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"tc"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"TE"
block|,
name|roff_TE
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"TH"
block|,
name|roff_TH
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ti"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"tkf"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"tl"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"tm"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"tm1"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"tmc"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"tr"
block|,
name|roff_tr
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"track"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"transchar"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"trf"
block|,
name|roff_insec
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"trimat"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"trin"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"trnt"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"troff"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"TS"
block|,
name|roff_TS
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"uf"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"ul"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"unformat"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"unwatch"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"unwatchn"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"vpt"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"vs"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"warn"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"warnscale"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"watch"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"watchlength"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"watchn"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"wh"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"while"
block|,
name|roff_unsupp
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"write"
block|,
name|roff_insec
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"writec"
block|,
name|roff_insec
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"writem"
block|,
name|roff_insec
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"xflag"
block|,
name|roff_line_ignore
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"."
block|,
name|roff_cblock
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
name|roff_userdef
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* not currently implemented: Ds em Eq LP Me PP pp Or Rd Sf SH */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|__mdoc_reserved
index|[]
init|=
block|{
literal|"Ac"
block|,
literal|"Ad"
block|,
literal|"An"
block|,
literal|"Ao"
block|,
literal|"Ap"
block|,
literal|"Aq"
block|,
literal|"Ar"
block|,
literal|"At"
block|,
literal|"Bc"
block|,
literal|"Bd"
block|,
literal|"Bf"
block|,
literal|"Bk"
block|,
literal|"Bl"
block|,
literal|"Bo"
block|,
literal|"Bq"
block|,
literal|"Brc"
block|,
literal|"Bro"
block|,
literal|"Brq"
block|,
literal|"Bsx"
block|,
literal|"Bt"
block|,
literal|"Bx"
block|,
literal|"Cd"
block|,
literal|"Cm"
block|,
literal|"Db"
block|,
literal|"Dc"
block|,
literal|"Dd"
block|,
literal|"Dl"
block|,
literal|"Do"
block|,
literal|"Dq"
block|,
literal|"Dt"
block|,
literal|"Dv"
block|,
literal|"Dx"
block|,
literal|"D1"
block|,
literal|"Ec"
block|,
literal|"Ed"
block|,
literal|"Ef"
block|,
literal|"Ek"
block|,
literal|"El"
block|,
literal|"Em"
block|,
literal|"En"
block|,
literal|"Eo"
block|,
literal|"Er"
block|,
literal|"Es"
block|,
literal|"Ev"
block|,
literal|"Ex"
block|,
literal|"Fa"
block|,
literal|"Fc"
block|,
literal|"Fd"
block|,
literal|"Fl"
block|,
literal|"Fn"
block|,
literal|"Fo"
block|,
literal|"Fr"
block|,
literal|"Ft"
block|,
literal|"Fx"
block|,
literal|"Hf"
block|,
literal|"Ic"
block|,
literal|"In"
block|,
literal|"It"
block|,
literal|"Lb"
block|,
literal|"Li"
block|,
literal|"Lk"
block|,
literal|"Lp"
block|,
literal|"Ms"
block|,
literal|"Mt"
block|,
literal|"Nd"
block|,
literal|"Nm"
block|,
literal|"No"
block|,
literal|"Ns"
block|,
literal|"Nx"
block|,
literal|"Oc"
block|,
literal|"Oo"
block|,
literal|"Op"
block|,
literal|"Os"
block|,
literal|"Ot"
block|,
literal|"Ox"
block|,
literal|"Pa"
block|,
literal|"Pc"
block|,
literal|"Pf"
block|,
literal|"Po"
block|,
literal|"Pp"
block|,
literal|"Pq"
block|,
literal|"Qc"
block|,
literal|"Ql"
block|,
literal|"Qo"
block|,
literal|"Qq"
block|,
literal|"Re"
block|,
literal|"Rs"
block|,
literal|"Rv"
block|,
literal|"Sc"
block|,
literal|"Sh"
block|,
literal|"Sm"
block|,
literal|"So"
block|,
literal|"Sq"
block|,
literal|"Ss"
block|,
literal|"St"
block|,
literal|"Sx"
block|,
literal|"Sy"
block|,
literal|"Ta"
block|,
literal|"Tn"
block|,
literal|"Ud"
block|,
literal|"Ux"
block|,
literal|"Va"
block|,
literal|"Vt"
block|,
literal|"Xc"
block|,
literal|"Xo"
block|,
literal|"Xr"
block|,
literal|"%A"
block|,
literal|"%B"
block|,
literal|"%C"
block|,
literal|"%D"
block|,
literal|"%I"
block|,
literal|"%J"
block|,
literal|"%N"
block|,
literal|"%O"
block|,
literal|"%P"
block|,
literal|"%Q"
block|,
literal|"%R"
block|,
literal|"%T"
block|,
literal|"%U"
block|,
literal|"%V"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* not currently implemented: BT DE DS ME MT PT SY TQ YS */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|__man_reserved
index|[]
init|=
block|{
literal|"AT"
block|,
literal|"B"
block|,
literal|"BI"
block|,
literal|"BR"
block|,
literal|"DT"
block|,
literal|"EE"
block|,
literal|"EN"
block|,
literal|"EQ"
block|,
literal|"EX"
block|,
literal|"HP"
block|,
literal|"I"
block|,
literal|"IB"
block|,
literal|"IP"
block|,
literal|"IR"
block|,
literal|"LP"
block|,
literal|"OP"
block|,
literal|"P"
block|,
literal|"PD"
block|,
literal|"PP"
block|,
literal|"R"
block|,
literal|"RB"
block|,
literal|"RE"
block|,
literal|"RI"
block|,
literal|"RS"
block|,
literal|"SB"
block|,
literal|"SH"
block|,
literal|"SM"
block|,
literal|"SS"
block|,
literal|"TE"
block|,
literal|"TH"
block|,
literal|"TP"
block|,
literal|"TS"
block|,
literal|"T&"
block|,
literal|"UC"
block|,
literal|"UE"
block|,
literal|"UR"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of injected predefined strings. */
end_comment

begin_define
define|#
directive|define
name|PREDEFS_MAX
value|38
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|predef
name|predefs
index|[
name|PREDEFS_MAX
index|]
init|=
block|{
include|#
directive|include
file|"predefs.in"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* See roffhash_find() */
end_comment

begin_define
define|#
directive|define
name|ROFF_HASH
parameter_list|(
name|p
parameter_list|)
value|(p[0] - ASCII_LO)
end_define

begin_decl_stmt
specifier|static
name|int
name|roffit_lines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of lines to delay */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|roffit_macro
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nil-terminated macro line */
end_comment

begin_comment
comment|/* --- request table ------------------------------------------------------ */
end_comment

begin_function
specifier|static
name|void
name|roffhash_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|roffmac
modifier|*
name|n
decl_stmt|;
name|int
name|buc
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|ROFF_USERDEF
condition|;
name|i
operator|++
control|)
block|{
name|assert
argument_list|(
name|roffs
index|[
name|i
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|>=
name|ASCII_LO
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|roffs
index|[
name|i
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|<=
name|ASCII_HI
argument_list|)
expr_stmt|;
name|buc
operator|=
name|ROFF_HASH
argument_list|(
name|roffs
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|n
operator|=
name|hash
index|[
name|buc
index|]
operator|)
condition|)
block|{
for|for
control|(
init|;
name|n
operator|->
name|next
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
comment|/* Do nothing. */
empty_stmt|;
name|n
operator|->
name|next
operator|=
operator|&
name|roffs
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
name|hash
index|[
name|buc
index|]
operator|=
operator|&
name|roffs
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Look up a roff token by its name.  Returns ROFF_MAX if no macro by  * the nil-terminated string name could be found.  */
end_comment

begin_function
specifier|static
name|enum
name|rofft
name|roffhash_find
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|int
name|buc
decl_stmt|;
name|struct
name|roffmac
modifier|*
name|n
decl_stmt|;
comment|/* 	 * libroff has an extremely simple hashtable, for the time 	 * being, which simply keys on the first character, which must 	 * be printable, then walks a chain.  It works well enough until 	 * optimised. 	 */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|<
name|ASCII_LO
operator|||
name|p
index|[
literal|0
index|]
operator|>
name|ASCII_HI
condition|)
return|return
name|ROFF_MAX
return|;
name|buc
operator|=
name|ROFF_HASH
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|n
operator|=
name|hash
index|[
name|buc
index|]
operator|)
condition|)
return|return
name|ROFF_MAX
return|;
for|for
control|(
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|n
operator|->
name|name
argument_list|,
name|p
argument_list|,
name|s
argument_list|)
operator|&&
literal|'\0'
operator|==
name|n
operator|->
name|name
index|[
operator|(
name|int
operator|)
name|s
index|]
condition|)
return|return
operator|(
expr|enum
name|rofft
operator|)
operator|(
name|n
operator|-
name|roffs
operator|)
return|;
return|return
name|ROFF_MAX
return|;
block|}
end_function

begin_comment
comment|/* --- stack of request blocks -------------------------------------------- */
end_comment

begin_comment
comment|/*  * Pop the current node off of the stack of roff instructions currently  * pending.  */
end_comment

begin_function
specifier|static
name|void
name|roffnode_pop
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|roffnode
modifier|*
name|p
decl_stmt|;
name|assert
argument_list|(
name|r
operator|->
name|last
argument_list|)
expr_stmt|;
name|p
operator|=
name|r
operator|->
name|last
expr_stmt|;
name|r
operator|->
name|last
operator|=
name|r
operator|->
name|last
operator|->
name|parent
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|end
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Push a roff node onto the instruction stack.  This must later be  * removed with roffnode_pop().  */
end_comment

begin_function
specifier|static
name|void
name|roffnode_push
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|,
name|enum
name|rofft
name|tok
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|col
parameter_list|)
block|{
name|struct
name|roffnode
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|roffnode
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|tok
operator|=
name|tok
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|p
operator|->
name|name
operator|=
name|mandoc_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|r
operator|->
name|last
expr_stmt|;
name|p
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|p
operator|->
name|col
operator|=
name|col
expr_stmt|;
name|p
operator|->
name|rule
operator|=
name|p
operator|->
name|parent
condition|?
name|p
operator|->
name|parent
operator|->
name|rule
else|:
literal|0
expr_stmt|;
name|r
operator|->
name|last
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/* --- roff parser state data management ---------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|roff_free1
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|tbl_node
modifier|*
name|tbl
decl_stmt|;
name|struct
name|eqn_node
modifier|*
name|e
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|tbl
operator|=
name|r
operator|->
name|first_tbl
operator|)
condition|)
block|{
name|r
operator|->
name|first_tbl
operator|=
name|tbl
operator|->
name|next
expr_stmt|;
name|tbl_free
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
block|}
name|r
operator|->
name|first_tbl
operator|=
name|r
operator|->
name|last_tbl
operator|=
name|r
operator|->
name|tbl
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|e
operator|=
name|r
operator|->
name|first_eqn
operator|)
condition|)
block|{
name|r
operator|->
name|first_eqn
operator|=
name|e
operator|->
name|next
expr_stmt|;
name|eqn_free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|r
operator|->
name|first_eqn
operator|=
name|r
operator|->
name|last_eqn
operator|=
name|r
operator|->
name|eqn
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|r
operator|->
name|last
condition|)
name|roffnode_pop
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
operator|->
name|rstack
argument_list|)
expr_stmt|;
name|r
operator|->
name|rstack
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|rstacksz
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|rstackpos
operator|=
operator|-
literal|1
expr_stmt|;
name|roff_freereg
argument_list|(
name|r
operator|->
name|regtab
argument_list|)
expr_stmt|;
name|r
operator|->
name|regtab
operator|=
name|NULL
expr_stmt|;
name|roff_freestr
argument_list|(
name|r
operator|->
name|strtab
argument_list|)
expr_stmt|;
name|roff_freestr
argument_list|(
name|r
operator|->
name|xmbtab
argument_list|)
expr_stmt|;
name|r
operator|->
name|strtab
operator|=
name|r
operator|->
name|xmbtab
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|xtab
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|r
operator|->
name|xtab
index|[
name|i
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
operator|->
name|xtab
argument_list|)
expr_stmt|;
name|r
operator|->
name|xtab
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|roff_reset
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|)
block|{
name|roff_free1
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|format
operator|=
name|r
operator|->
name|options
operator|&
operator|(
name|MPARSE_MDOC
operator||
name|MPARSE_MAN
operator|)
expr_stmt|;
name|r
operator|->
name|control
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|roff_free
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|)
block|{
name|roff_free1
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|roff
modifier|*
name|roff_alloc
parameter_list|(
name|struct
name|mparse
modifier|*
name|parse
parameter_list|,
name|int
name|options
parameter_list|)
block|{
name|struct
name|roff
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|roff
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|parse
operator|=
name|parse
expr_stmt|;
name|r
operator|->
name|options
operator|=
name|options
expr_stmt|;
name|r
operator|->
name|format
operator|=
name|options
operator|&
operator|(
name|MPARSE_MDOC
operator||
name|MPARSE_MAN
operator|)
expr_stmt|;
name|r
operator|->
name|rstackpos
operator|=
operator|-
literal|1
expr_stmt|;
name|roffhash_init
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* --- syntax tree state data management ---------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|roff_man_free1
parameter_list|(
name|struct
name|roff_man
modifier|*
name|man
parameter_list|)
block|{
if|if
condition|(
name|man
operator|->
name|first
operator|!=
name|NULL
condition|)
name|roff_node_delete
argument_list|(
name|man
argument_list|,
name|man
operator|->
name|first
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|man
operator|->
name|meta
operator|.
name|msec
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|man
operator|->
name|meta
operator|.
name|vol
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|man
operator|->
name|meta
operator|.
name|os
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|man
operator|->
name|meta
operator|.
name|arch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|man
operator|->
name|meta
operator|.
name|title
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|man
operator|->
name|meta
operator|.
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|man
operator|->
name|meta
operator|.
name|date
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|roff_man_alloc1
parameter_list|(
name|struct
name|roff_man
modifier|*
name|man
parameter_list|)
block|{
name|memset
argument_list|(
operator|&
name|man
operator|->
name|meta
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|man
operator|->
name|meta
argument_list|)
argument_list|)
expr_stmt|;
name|man
operator|->
name|first
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|man
operator|->
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|man
operator|->
name|first
operator|->
name|type
operator|=
name|ROFFT_ROOT
expr_stmt|;
name|man
operator|->
name|last
operator|=
name|man
operator|->
name|first
expr_stmt|;
name|man
operator|->
name|last_es
operator|=
name|NULL
expr_stmt|;
name|man
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|man
operator|->
name|macroset
operator|=
name|MACROSET_NONE
expr_stmt|;
name|man
operator|->
name|lastsec
operator|=
name|man
operator|->
name|lastnamed
operator|=
name|SEC_NONE
expr_stmt|;
name|man
operator|->
name|next
operator|=
name|ROFF_NEXT_CHILD
expr_stmt|;
block|}
end_function

begin_function
name|void
name|roff_man_reset
parameter_list|(
name|struct
name|roff_man
modifier|*
name|man
parameter_list|)
block|{
name|roff_man_free1
argument_list|(
name|man
argument_list|)
expr_stmt|;
name|roff_man_alloc1
argument_list|(
name|man
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|roff_man_free
parameter_list|(
name|struct
name|roff_man
modifier|*
name|man
parameter_list|)
block|{
name|roff_man_free1
argument_list|(
name|man
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|man
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|roff_man
modifier|*
name|roff_man_alloc
parameter_list|(
name|struct
name|roff
modifier|*
name|roff
parameter_list|,
name|struct
name|mparse
modifier|*
name|parse
parameter_list|,
specifier|const
name|char
modifier|*
name|defos
parameter_list|,
name|int
name|quick
parameter_list|)
block|{
name|struct
name|roff_man
modifier|*
name|man
decl_stmt|;
name|man
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|man
argument_list|)
argument_list|)
expr_stmt|;
name|man
operator|->
name|parse
operator|=
name|parse
expr_stmt|;
name|man
operator|->
name|roff
operator|=
name|roff
expr_stmt|;
name|man
operator|->
name|defos
operator|=
name|defos
expr_stmt|;
name|man
operator|->
name|quick
operator|=
name|quick
expr_stmt|;
name|roff_man_alloc1
argument_list|(
name|man
argument_list|)
expr_stmt|;
return|return
name|man
return|;
block|}
end_function

begin_comment
comment|/* --- syntax tree handling ----------------------------------------------- */
end_comment

begin_function
name|struct
name|roff_node
modifier|*
name|roff_node_alloc
parameter_list|(
name|struct
name|roff_man
modifier|*
name|man
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|pos
parameter_list|,
name|enum
name|roff_type
name|type
parameter_list|,
name|int
name|tok
parameter_list|)
block|{
name|struct
name|roff_node
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|n
operator|->
name|pos
operator|=
name|pos
expr_stmt|;
name|n
operator|->
name|tok
operator|=
name|tok
expr_stmt|;
name|n
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|n
operator|->
name|sec
operator|=
name|man
operator|->
name|lastsec
expr_stmt|;
if|if
condition|(
name|man
operator|->
name|flags
operator|&
name|MDOC_SYNOPSIS
condition|)
name|n
operator|->
name|flags
operator||=
name|NODE_SYNPRETTY
expr_stmt|;
else|else
name|n
operator|->
name|flags
operator|&=
operator|~
name|NODE_SYNPRETTY
expr_stmt|;
if|if
condition|(
name|man
operator|->
name|flags
operator|&
name|MDOC_NEWLINE
condition|)
name|n
operator|->
name|flags
operator||=
name|NODE_LINE
expr_stmt|;
name|man
operator|->
name|flags
operator|&=
operator|~
name|MDOC_NEWLINE
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
name|void
name|roff_node_append
parameter_list|(
name|struct
name|roff_man
modifier|*
name|man
parameter_list|,
name|struct
name|roff_node
modifier|*
name|n
parameter_list|)
block|{
switch|switch
condition|(
name|man
operator|->
name|next
condition|)
block|{
case|case
name|ROFF_NEXT_SIBLING
case|:
if|if
condition|(
name|man
operator|->
name|last
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|n
operator|->
name|next
operator|=
name|man
operator|->
name|last
operator|->
name|next
expr_stmt|;
name|man
operator|->
name|last
operator|->
name|next
operator|->
name|prev
operator|=
name|n
expr_stmt|;
block|}
else|else
name|man
operator|->
name|last
operator|->
name|parent
operator|->
name|last
operator|=
name|n
expr_stmt|;
name|man
operator|->
name|last
operator|->
name|next
operator|=
name|n
expr_stmt|;
name|n
operator|->
name|prev
operator|=
name|man
operator|->
name|last
expr_stmt|;
name|n
operator|->
name|parent
operator|=
name|man
operator|->
name|last
operator|->
name|parent
expr_stmt|;
break|break;
case|case
name|ROFF_NEXT_CHILD
case|:
if|if
condition|(
name|man
operator|->
name|last
operator|->
name|child
operator|!=
name|NULL
condition|)
block|{
name|n
operator|->
name|next
operator|=
name|man
operator|->
name|last
operator|->
name|child
expr_stmt|;
name|man
operator|->
name|last
operator|->
name|child
operator|->
name|prev
operator|=
name|n
expr_stmt|;
block|}
else|else
name|man
operator|->
name|last
operator|->
name|last
operator|=
name|n
expr_stmt|;
name|man
operator|->
name|last
operator|->
name|child
operator|=
name|n
expr_stmt|;
name|n
operator|->
name|parent
operator|=
name|man
operator|->
name|last
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|man
operator|->
name|last
operator|=
name|n
expr_stmt|;
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|ROFFT_HEAD
case|:
name|n
operator|->
name|parent
operator|->
name|head
operator|=
name|n
expr_stmt|;
break|break;
case|case
name|ROFFT_BODY
case|:
if|if
condition|(
name|n
operator|->
name|end
operator|!=
name|ENDBODY_NOT
condition|)
return|return;
name|n
operator|->
name|parent
operator|->
name|body
operator|=
name|n
expr_stmt|;
break|break;
case|case
name|ROFFT_TAIL
case|:
name|n
operator|->
name|parent
operator|->
name|tail
operator|=
name|n
expr_stmt|;
break|break;
default|default:
return|return;
block|}
comment|/* 	 * Copy over the normalised-data pointer of our parent.  Not 	 * everybody has one, but copying a null pointer is fine. 	 */
name|n
operator|->
name|norm
operator|=
name|n
operator|->
name|parent
operator|->
name|norm
expr_stmt|;
name|assert
argument_list|(
name|n
operator|->
name|parent
operator|->
name|type
operator|==
name|ROFFT_BLOCK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|roff_word_alloc
parameter_list|(
name|struct
name|roff_man
modifier|*
name|man
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|pos
parameter_list|,
specifier|const
name|char
modifier|*
name|word
parameter_list|)
block|{
name|struct
name|roff_node
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|roff_node_alloc
argument_list|(
name|man
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|ROFFT_TEXT
argument_list|,
name|TOKEN_NONE
argument_list|)
expr_stmt|;
name|n
operator|->
name|string
operator|=
name|roff_strdup
argument_list|(
name|man
operator|->
name|roff
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|roff_node_append
argument_list|(
name|man
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|flags
operator||=
name|NODE_VALID
operator||
name|NODE_ENDED
expr_stmt|;
name|man
operator|->
name|next
operator|=
name|ROFF_NEXT_SIBLING
expr_stmt|;
block|}
end_function

begin_function
name|void
name|roff_word_append
parameter_list|(
name|struct
name|roff_man
modifier|*
name|man
parameter_list|,
specifier|const
name|char
modifier|*
name|word
parameter_list|)
block|{
name|struct
name|roff_node
modifier|*
name|n
decl_stmt|;
name|char
modifier|*
name|addstr
decl_stmt|,
modifier|*
name|newstr
decl_stmt|;
name|n
operator|=
name|man
operator|->
name|last
expr_stmt|;
name|addstr
operator|=
name|roff_strdup
argument_list|(
name|man
operator|->
name|roff
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|mandoc_asprintf
argument_list|(
operator|&
name|newstr
argument_list|,
literal|"%s %s"
argument_list|,
name|n
operator|->
name|string
argument_list|,
name|addstr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|addstr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n
operator|->
name|string
argument_list|)
expr_stmt|;
name|n
operator|->
name|string
operator|=
name|newstr
expr_stmt|;
name|man
operator|->
name|next
operator|=
name|ROFF_NEXT_SIBLING
expr_stmt|;
block|}
end_function

begin_function
name|void
name|roff_elem_alloc
parameter_list|(
name|struct
name|roff_man
modifier|*
name|man
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|pos
parameter_list|,
name|int
name|tok
parameter_list|)
block|{
name|struct
name|roff_node
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|roff_node_alloc
argument_list|(
name|man
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|ROFFT_ELEM
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|roff_node_append
argument_list|(
name|man
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|man
operator|->
name|next
operator|=
name|ROFF_NEXT_CHILD
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|roff_node
modifier|*
name|roff_block_alloc
parameter_list|(
name|struct
name|roff_man
modifier|*
name|man
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|pos
parameter_list|,
name|int
name|tok
parameter_list|)
block|{
name|struct
name|roff_node
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|roff_node_alloc
argument_list|(
name|man
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|ROFFT_BLOCK
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|roff_node_append
argument_list|(
name|man
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|man
operator|->
name|next
operator|=
name|ROFF_NEXT_CHILD
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
name|struct
name|roff_node
modifier|*
name|roff_head_alloc
parameter_list|(
name|struct
name|roff_man
modifier|*
name|man
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|pos
parameter_list|,
name|int
name|tok
parameter_list|)
block|{
name|struct
name|roff_node
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|roff_node_alloc
argument_list|(
name|man
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|ROFFT_HEAD
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|roff_node_append
argument_list|(
name|man
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|man
operator|->
name|next
operator|=
name|ROFF_NEXT_CHILD
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
name|struct
name|roff_node
modifier|*
name|roff_body_alloc
parameter_list|(
name|struct
name|roff_man
modifier|*
name|man
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|pos
parameter_list|,
name|int
name|tok
parameter_list|)
block|{
name|struct
name|roff_node
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|roff_node_alloc
argument_list|(
name|man
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|ROFFT_BODY
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|roff_node_append
argument_list|(
name|man
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|man
operator|->
name|next
operator|=
name|ROFF_NEXT_CHILD
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
name|void
name|roff_addeqn
parameter_list|(
name|struct
name|roff_man
modifier|*
name|man
parameter_list|,
specifier|const
name|struct
name|eqn
modifier|*
name|eqn
parameter_list|)
block|{
name|struct
name|roff_node
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|roff_node_alloc
argument_list|(
name|man
argument_list|,
name|eqn
operator|->
name|ln
argument_list|,
name|eqn
operator|->
name|pos
argument_list|,
name|ROFFT_EQN
argument_list|,
name|TOKEN_NONE
argument_list|)
expr_stmt|;
name|n
operator|->
name|eqn
operator|=
name|eqn
expr_stmt|;
if|if
condition|(
name|eqn
operator|->
name|ln
operator|>
name|man
operator|->
name|last
operator|->
name|line
condition|)
name|n
operator|->
name|flags
operator||=
name|NODE_LINE
expr_stmt|;
name|roff_node_append
argument_list|(
name|man
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|man
operator|->
name|next
operator|=
name|ROFF_NEXT_SIBLING
expr_stmt|;
block|}
end_function

begin_function
name|void
name|roff_addtbl
parameter_list|(
name|struct
name|roff_man
modifier|*
name|man
parameter_list|,
specifier|const
name|struct
name|tbl_span
modifier|*
name|tbl
parameter_list|)
block|{
name|struct
name|roff_node
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|man
operator|->
name|macroset
operator|==
name|MACROSET_MAN
condition|)
name|man_breakscope
argument_list|(
name|man
argument_list|,
name|TOKEN_NONE
argument_list|)
expr_stmt|;
name|n
operator|=
name|roff_node_alloc
argument_list|(
name|man
argument_list|,
name|tbl
operator|->
name|line
argument_list|,
literal|0
argument_list|,
name|ROFFT_TBL
argument_list|,
name|TOKEN_NONE
argument_list|)
expr_stmt|;
name|n
operator|->
name|span
operator|=
name|tbl
expr_stmt|;
name|roff_node_append
argument_list|(
name|man
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|flags
operator||=
name|NODE_VALID
operator||
name|NODE_ENDED
expr_stmt|;
name|man
operator|->
name|next
operator|=
name|ROFF_NEXT_SIBLING
expr_stmt|;
block|}
end_function

begin_function
name|void
name|roff_node_unlink
parameter_list|(
name|struct
name|roff_man
modifier|*
name|man
parameter_list|,
name|struct
name|roff_node
modifier|*
name|n
parameter_list|)
block|{
comment|/* Adjust siblings. */
if|if
condition|(
name|n
operator|->
name|prev
condition|)
name|n
operator|->
name|prev
operator|->
name|next
operator|=
name|n
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|next
condition|)
name|n
operator|->
name|next
operator|->
name|prev
operator|=
name|n
operator|->
name|prev
expr_stmt|;
comment|/* Adjust parent. */
if|if
condition|(
name|n
operator|->
name|parent
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|parent
operator|->
name|child
operator|==
name|n
condition|)
name|n
operator|->
name|parent
operator|->
name|child
operator|=
name|n
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|parent
operator|->
name|last
operator|==
name|n
condition|)
name|n
operator|->
name|parent
operator|->
name|last
operator|=
name|n
operator|->
name|prev
expr_stmt|;
block|}
comment|/* Adjust parse point. */
if|if
condition|(
name|man
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|man
operator|->
name|last
operator|==
name|n
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|prev
operator|==
name|NULL
condition|)
block|{
name|man
operator|->
name|last
operator|=
name|n
operator|->
name|parent
expr_stmt|;
name|man
operator|->
name|next
operator|=
name|ROFF_NEXT_CHILD
expr_stmt|;
block|}
else|else
block|{
name|man
operator|->
name|last
operator|=
name|n
operator|->
name|prev
expr_stmt|;
name|man
operator|->
name|next
operator|=
name|ROFF_NEXT_SIBLING
expr_stmt|;
block|}
block|}
if|if
condition|(
name|man
operator|->
name|first
operator|==
name|n
condition|)
name|man
operator|->
name|first
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|roff_node_free
parameter_list|(
name|struct
name|roff_node
modifier|*
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|args
operator|!=
name|NULL
condition|)
name|mdoc_argv_free
argument_list|(
name|n
operator|->
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_BLOCK
operator|||
name|n
operator|->
name|type
operator|==
name|ROFFT_ELEM
condition|)
name|free
argument_list|(
name|n
operator|->
name|norm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n
operator|->
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|roff_node_delete
parameter_list|(
name|struct
name|roff_man
modifier|*
name|man
parameter_list|,
name|struct
name|roff_node
modifier|*
name|n
parameter_list|)
block|{
while|while
condition|(
name|n
operator|->
name|child
operator|!=
name|NULL
condition|)
name|roff_node_delete
argument_list|(
name|man
argument_list|,
name|n
operator|->
name|child
argument_list|)
expr_stmt|;
name|roff_node_unlink
argument_list|(
name|man
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|roff_node_free
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|deroff
parameter_list|(
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
specifier|const
name|struct
name|roff_node
modifier|*
name|n
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|type
operator|!=
name|ROFFT_TEXT
condition|)
block|{
for|for
control|(
name|n
operator|=
name|n
operator|->
name|child
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
name|deroff
argument_list|(
name|dest
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Skip leading whitespace. */
for|for
control|(
name|cp
operator|=
name|n
operator|->
name|string
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|strchr
argument_list|(
literal|" %&0^|~"
argument_list|,
name|cp
index|[
literal|1
index|]
argument_list|)
operator|!=
name|NULL
condition|)
name|cp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
break|break;
block|}
comment|/* Skip trailing whitespace. */
for|for
control|(
name|sz
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
init|;
name|sz
condition|;
name|sz
operator|--
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|cp
index|[
name|sz
operator|-
literal|1
index|]
argument_list|)
condition|)
break|break;
comment|/* Skip empty strings. */
if|if
condition|(
name|sz
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|*
name|dest
operator|==
name|NULL
condition|)
block|{
operator|*
name|dest
operator|=
name|mandoc_strndup
argument_list|(
name|cp
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return;
block|}
name|mandoc_asprintf
argument_list|(
operator|&
name|cp
argument_list|,
literal|"%s %*s"
argument_list|,
operator|*
name|dest
argument_list|,
operator|(
name|int
operator|)
name|sz
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|dest
argument_list|)
expr_stmt|;
operator|*
name|dest
operator|=
name|cp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* --- main functions of the roff parser ---------------------------------- */
end_comment

begin_comment
comment|/*  * In the current line, expand escape sequences that tend to get  * used in numerical expressions and conditional requests.  * Also check the syntax of the remaining escape sequences.  */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_res
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|,
name|struct
name|buf
modifier|*
name|buf
parameter_list|,
name|int
name|ln
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
name|char
name|ubuf
index|[
literal|24
index|]
decl_stmt|;
comment|/* buffer to print the number */
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
comment|/* start of the string to process */
name|char
modifier|*
name|stesc
decl_stmt|;
comment|/* start of an escape sequence ('\\') */
specifier|const
name|char
modifier|*
name|stnam
decl_stmt|;
comment|/* start of the name, after "[(*" */
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* end of the name, e.g. before ']' */
specifier|const
name|char
modifier|*
name|res
decl_stmt|;
comment|/* the string to be substituted */
name|char
modifier|*
name|nbuf
decl_stmt|;
comment|/* new buffer to copy buf->buf to */
name|size_t
name|maxl
decl_stmt|;
comment|/* expected length of the escape name */
name|size_t
name|naml
decl_stmt|;
comment|/* actual length of the escape name */
name|enum
name|mandoc_esc
name|esc
decl_stmt|;
comment|/* type of the escape sequence */
name|int
name|inaml
decl_stmt|;
comment|/* length returned from mandoc_escape() */
name|int
name|expand_count
decl_stmt|;
comment|/* to avoid infinite loops */
name|int
name|npos
decl_stmt|;
comment|/* position in numeric expression */
name|int
name|arg_complete
decl_stmt|;
comment|/* argument not interrupted by eol */
name|char
name|term
decl_stmt|;
comment|/* character terminating the escape */
name|expand_count
operator|=
literal|0
expr_stmt|;
name|start
operator|=
name|buf
operator|->
name|buf
operator|+
name|pos
expr_stmt|;
name|stesc
operator|=
name|strchr
argument_list|(
name|start
argument_list|,
literal|'\0'
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|stesc
operator|--
operator|>
name|start
condition|)
block|{
comment|/* Search backwards for the next backslash. */
if|if
condition|(
operator|*
name|stesc
operator|!=
literal|'\\'
condition|)
continue|continue;
comment|/* If it is escaped, skip it. */
for|for
control|(
name|cp
operator|=
name|stesc
operator|-
literal|1
init|;
name|cp
operator|>=
name|start
condition|;
name|cp
operator|--
control|)
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\\'
condition|)
break|break;
if|if
condition|(
operator|(
name|stesc
operator|-
name|cp
operator|)
operator|%
literal|2
operator|==
literal|0
condition|)
block|{
name|stesc
operator|=
operator|(
name|char
operator|*
operator|)
name|cp
expr_stmt|;
continue|continue;
block|}
comment|/* Decide whether to expand or to check only. */
name|term
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|stesc
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'*'
case|:
name|res
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
case|case
literal|'w'
case|:
name|term
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'n'
case|:
name|res
operator|=
name|ubuf
expr_stmt|;
break|break;
default|default:
name|esc
operator|=
name|mandoc_escape
argument_list|(
operator|&
name|cp
argument_list|,
operator|&
name|stnam
argument_list|,
operator|&
name|inaml
argument_list|)
expr_stmt|;
if|if
condition|(
name|esc
operator|==
name|ESCAPE_ERROR
operator|||
operator|(
name|esc
operator|==
name|ESCAPE_SPECIAL
operator|&&
name|mchars_spec2cp
argument_list|(
name|stnam
argument_list|,
name|inaml
argument_list|)
operator|<
literal|0
operator|)
condition|)
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_ESC_BAD
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
call|(
name|int
call|)
argument_list|(
name|stesc
operator|-
name|buf
operator|->
name|buf
argument_list|)
argument_list|,
literal|"%.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cp
operator|-
name|stesc
argument_list|)
argument_list|,
name|stesc
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|EXPAND_LIMIT
operator|<
operator|++
name|expand_count
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_ROFFLOOP
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
call|(
name|int
call|)
argument_list|(
name|stesc
operator|-
name|buf
operator|->
name|buf
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|ROFF_IGN
return|;
block|}
comment|/* 		 * The third character decides the length 		 * of the name of the string or register. 		 * Save a pointer to the name. 		 */
if|if
condition|(
name|term
operator|==
literal|'\0'
condition|)
block|{
switch|switch
condition|(
operator|*
operator|++
name|cp
condition|)
block|{
case|case
literal|'\0'
case|:
name|maxl
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|cp
operator|++
expr_stmt|;
name|maxl
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|cp
operator|++
expr_stmt|;
name|term
operator|=
literal|']'
expr_stmt|;
name|maxl
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|maxl
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|cp
operator|+=
literal|2
expr_stmt|;
name|maxl
operator|=
literal|0
expr_stmt|;
block|}
name|stnam
operator|=
name|cp
expr_stmt|;
comment|/* Advance to the end of the name. */
name|naml
operator|=
literal|0
expr_stmt|;
name|arg_complete
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|maxl
operator|==
literal|0
operator|||
name|naml
operator|<
name|maxl
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_ESC_BAD
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
call|(
name|int
call|)
argument_list|(
name|stesc
operator|-
name|buf
operator|->
name|buf
argument_list|)
argument_list|,
name|stesc
argument_list|)
expr_stmt|;
name|arg_complete
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|maxl
operator|==
literal|0
operator|&&
operator|*
name|cp
operator|==
name|term
condition|)
block|{
name|cp
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'\\'
operator|||
name|stesc
index|[
literal|1
index|]
operator|!=
literal|'w'
condition|)
block|{
name|naml
operator|++
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|mandoc_escape
argument_list|(
operator|&
name|cp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
case|case
name|ESCAPE_SPECIAL
case|:
case|case
name|ESCAPE_UNICODE
case|:
case|case
name|ESCAPE_NUMBERED
case|:
case|case
name|ESCAPE_OVERSTRIKE
case|:
name|naml
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* 		 * Retrieve the replacement string; if it is 		 * undefined, resume searching for escapes. 		 */
switch|switch
condition|(
name|stesc
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'*'
case|:
if|if
condition|(
name|arg_complete
condition|)
name|res
operator|=
name|roff_getstrn
argument_list|(
name|r
argument_list|,
name|stnam
argument_list|,
name|naml
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|npos
operator|=
literal|0
expr_stmt|;
name|ubuf
index|[
literal|0
index|]
operator|=
name|arg_complete
operator|&&
name|roff_evalnum
argument_list|(
name|r
argument_list|,
name|ln
argument_list|,
name|stnam
argument_list|,
operator|&
name|npos
argument_list|,
name|NULL
argument_list|,
name|ROFFNUM_SCALE
argument_list|)
operator|&&
name|stnam
operator|+
name|npos
operator|+
literal|1
operator|==
name|cp
condition|?
literal|'1'
else|:
literal|'0'
expr_stmt|;
name|ubuf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|arg_complete
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|ubuf
argument_list|,
sizeof|sizeof
argument_list|(
name|ubuf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|roff_getregn
argument_list|(
name|r
argument_list|,
name|stnam
argument_list|,
name|naml
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ubuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* use even incomplete args */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|ubuf
argument_list|,
sizeof|sizeof
argument_list|(
name|ubuf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
literal|24
operator|*
operator|(
name|int
operator|)
name|naml
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_STR_UNDEF
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
call|(
name|int
call|)
argument_list|(
name|stesc
operator|-
name|buf
operator|->
name|buf
argument_list|)
argument_list|,
literal|"%.*s"
argument_list|,
operator|(
name|int
operator|)
name|naml
argument_list|,
name|stnam
argument_list|)
expr_stmt|;
name|res
operator|=
literal|""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buf
operator|->
name|sz
operator|+
name|strlen
argument_list|(
name|res
argument_list|)
operator|>
name|SHRT_MAX
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_ROFFLOOP
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
call|(
name|int
call|)
argument_list|(
name|stesc
operator|-
name|buf
operator|->
name|buf
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|ROFF_IGN
return|;
block|}
comment|/* Replace the escape sequence by the string. */
operator|*
name|stesc
operator|=
literal|'\0'
expr_stmt|;
name|buf
operator|->
name|sz
operator|=
name|mandoc_asprintf
argument_list|(
operator|&
name|nbuf
argument_list|,
literal|"%s%s%s"
argument_list|,
name|buf
operator|->
name|buf
argument_list|,
name|res
argument_list|,
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Prepare for the next replacement. */
name|start
operator|=
name|nbuf
operator|+
name|pos
expr_stmt|;
name|stesc
operator|=
name|nbuf
operator|+
operator|(
name|stesc
operator|-
name|buf
operator|->
name|buf
operator|)
operator|+
name|strlen
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
operator|->
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|->
name|buf
operator|=
name|nbuf
expr_stmt|;
block|}
return|return
name|ROFF_CONT
return|;
block|}
end_function

begin_comment
comment|/*  * Process text streams.  */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_parsetext
parameter_list|(
name|struct
name|buf
modifier|*
name|buf
parameter_list|,
name|int
name|pos
parameter_list|,
name|int
modifier|*
name|offs
parameter_list|)
block|{
name|size_t
name|sz
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|isz
decl_stmt|;
name|enum
name|mandoc_esc
name|esc
decl_stmt|;
comment|/* Spring the input line trap. */
if|if
condition|(
name|roffit_lines
operator|==
literal|1
condition|)
block|{
name|isz
operator|=
name|mandoc_asprintf
argument_list|(
operator|&
name|p
argument_list|,
literal|"%s\n.%s"
argument_list|,
name|buf
operator|->
name|buf
argument_list|,
name|roffit_macro
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
operator|->
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|->
name|buf
operator|=
name|p
expr_stmt|;
name|buf
operator|->
name|sz
operator|=
name|isz
operator|+
literal|1
expr_stmt|;
operator|*
name|offs
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|roffit_macro
argument_list|)
expr_stmt|;
name|roffit_lines
operator|=
literal|0
expr_stmt|;
return|return
name|ROFF_REPARSE
return|;
block|}
elseif|else
if|if
condition|(
name|roffit_lines
operator|>
literal|1
condition|)
operator|--
name|roffit_lines
expr_stmt|;
comment|/* Convert all breakable hyphens into ASCII_HYPH. */
name|start
operator|=
name|p
operator|=
name|buf
operator|->
name|buf
operator|+
name|pos
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|sz
operator|=
name|strcspn
argument_list|(
name|p
argument_list|,
literal|"-\\"
argument_list|)
expr_stmt|;
name|p
operator|+=
name|sz
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
comment|/* Skip over escapes. */
name|p
operator|++
expr_stmt|;
name|esc
operator|=
name|mandoc_escape
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|p
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|esc
operator|==
name|ESCAPE_ERROR
condition|)
break|break;
while|while
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|p
operator|==
name|start
condition|)
block|{
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
operator|&&
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|p
index|[
literal|1
index|]
argument_list|)
condition|)
operator|*
name|p
operator|=
name|ASCII_HYPH
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
return|return
name|ROFF_CONT
return|;
block|}
end_function

begin_function
name|enum
name|rofferr
name|roff_parseln
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|,
name|int
name|ln
parameter_list|,
name|struct
name|buf
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|offs
parameter_list|)
block|{
name|enum
name|rofft
name|t
decl_stmt|;
name|enum
name|rofferr
name|e
decl_stmt|;
name|int
name|pos
decl_stmt|;
comment|/* parse point */
name|int
name|spos
decl_stmt|;
comment|/* saved parse point for messages */
name|int
name|ppos
decl_stmt|;
comment|/* original offset in buf->buf */
name|int
name|ctl
decl_stmt|;
comment|/* macro line (boolean) */
name|ppos
operator|=
name|pos
operator|=
operator|*
name|offs
expr_stmt|;
comment|/* Handle in-line equation delimiters. */
if|if
condition|(
name|r
operator|->
name|tbl
operator|==
name|NULL
operator|&&
name|r
operator|->
name|last_eqn
operator|!=
name|NULL
operator|&&
name|r
operator|->
name|last_eqn
operator|->
name|delim
operator|&&
operator|(
name|r
operator|->
name|eqn
operator|==
name|NULL
operator|||
name|r
operator|->
name|eqn_inline
operator|)
condition|)
block|{
name|e
operator|=
name|roff_eqndelim
argument_list|(
name|r
argument_list|,
name|buf
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|ROFF_REPARSE
condition|)
return|return
name|e
return|;
name|assert
argument_list|(
name|e
operator|==
name|ROFF_CONT
argument_list|)
expr_stmt|;
block|}
comment|/* Expand some escape sequences. */
name|e
operator|=
name|roff_res
argument_list|(
name|r
argument_list|,
name|buf
argument_list|,
name|ln
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|ROFF_IGN
condition|)
return|return
name|e
return|;
name|assert
argument_list|(
name|e
operator|==
name|ROFF_CONT
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|roff_getcontrol
argument_list|(
name|r
argument_list|,
name|buf
operator|->
name|buf
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
comment|/* 	 * First, if a scope is open and we're not a macro, pass the 	 * text through the macro's filter. 	 * Equations process all content themselves. 	 * Tables process almost all content themselves, but we want 	 * to warn about macros before passing it there. 	 */
if|if
condition|(
name|r
operator|->
name|last
operator|!=
name|NULL
operator|&&
operator|!
name|ctl
condition|)
block|{
name|t
operator|=
name|r
operator|->
name|last
operator|->
name|tok
expr_stmt|;
name|assert
argument_list|(
name|roffs
index|[
name|t
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|e
operator|=
operator|(
operator|*
name|roffs
index|[
name|t
index|]
operator|.
name|text
operator|)
operator|(
name|r
operator|,
name|t
operator|,
name|buf
operator|,
name|ln
operator|,
name|pos
operator|,
name|pos
operator|,
name|offs
operator|)
expr_stmt|;
name|assert
argument_list|(
name|e
operator|==
name|ROFF_IGN
operator|||
name|e
operator|==
name|ROFF_CONT
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|!=
name|ROFF_CONT
condition|)
return|return
name|e
return|;
block|}
if|if
condition|(
name|r
operator|->
name|eqn
operator|!=
name|NULL
condition|)
return|return
name|eqn_read
argument_list|(
operator|&
name|r
operator|->
name|eqn
argument_list|,
name|ln
argument_list|,
name|buf
operator|->
name|buf
argument_list|,
name|ppos
argument_list|,
name|offs
argument_list|)
return|;
if|if
condition|(
name|r
operator|->
name|tbl
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|ctl
operator|||
name|buf
operator|->
name|buf
index|[
name|pos
index|]
operator|==
literal|'\0'
operator|)
condition|)
return|return
name|tbl_read
argument_list|(
name|r
operator|->
name|tbl
argument_list|,
name|ln
argument_list|,
name|buf
operator|->
name|buf
argument_list|,
name|ppos
argument_list|)
return|;
if|if
condition|(
operator|!
name|ctl
condition|)
return|return
name|roff_parsetext
argument_list|(
name|buf
argument_list|,
name|pos
argument_list|,
name|offs
argument_list|)
return|;
comment|/* Skip empty request lines. */
if|if
condition|(
name|buf
operator|->
name|buf
index|[
name|pos
index|]
operator|==
literal|'"'
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_COMMENT_BAD
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|pos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|ROFF_IGN
return|;
block|}
elseif|else
if|if
condition|(
name|buf
operator|->
name|buf
index|[
name|pos
index|]
operator|==
literal|'\0'
condition|)
return|return
name|ROFF_IGN
return|;
comment|/* 	 * If a scope is open, go to the child handler for that macro, 	 * as it may want to preprocess before doing anything with it. 	 * Don't do so if an equation is open. 	 */
if|if
condition|(
name|r
operator|->
name|last
condition|)
block|{
name|t
operator|=
name|r
operator|->
name|last
operator|->
name|tok
expr_stmt|;
name|assert
argument_list|(
name|roffs
index|[
name|t
index|]
operator|.
name|sub
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|roffs
index|[
name|t
index|]
operator|.
name|sub
operator|)
operator|(
name|r
operator|,
name|t
operator|,
name|buf
operator|,
name|ln
operator|,
name|ppos
operator|,
name|pos
operator|,
name|offs
operator|)
return|;
block|}
comment|/* No scope is open.  This is a new request or macro. */
name|spos
operator|=
name|pos
expr_stmt|;
name|t
operator|=
name|roff_parse
argument_list|(
name|r
argument_list|,
name|buf
operator|->
name|buf
argument_list|,
operator|&
name|pos
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
comment|/* Tables ignore most macros. */
if|if
condition|(
name|r
operator|->
name|tbl
operator|!=
name|NULL
operator|&&
operator|(
name|t
operator|==
name|ROFF_MAX
operator|||
name|t
operator|==
name|ROFF_TS
operator|)
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_TBLMACRO
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|pos
argument_list|,
name|buf
operator|->
name|buf
operator|+
name|spos
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|ROFF_TS
condition|)
return|return
name|ROFF_IGN
return|;
while|while
condition|(
name|buf
operator|->
name|buf
index|[
name|pos
index|]
operator|!=
literal|'\0'
operator|&&
name|buf
operator|->
name|buf
index|[
name|pos
index|]
operator|!=
literal|' '
condition|)
name|pos
operator|++
expr_stmt|;
while|while
condition|(
name|buf
operator|->
name|buf
index|[
name|pos
index|]
operator|!=
literal|'\0'
operator|&&
name|buf
operator|->
name|buf
index|[
name|pos
index|]
operator|==
literal|' '
condition|)
name|pos
operator|++
expr_stmt|;
return|return
name|tbl_read
argument_list|(
name|r
operator|->
name|tbl
argument_list|,
name|ln
argument_list|,
name|buf
operator|->
name|buf
argument_list|,
name|pos
argument_list|)
return|;
block|}
comment|/* 	 * This is neither a roff request nor a user-defined macro. 	 * Let the standard macro set parsers handle it. 	 */
if|if
condition|(
name|t
operator|==
name|ROFF_MAX
condition|)
return|return
name|ROFF_CONT
return|;
comment|/* Execute a roff request or a user defined macro. */
name|assert
argument_list|(
name|roffs
index|[
name|t
index|]
operator|.
name|proc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|roffs
index|[
name|t
index|]
operator|.
name|proc
operator|)
operator|(
name|r
operator|,
name|t
operator|,
name|buf
operator|,
name|ln
operator|,
name|ppos
operator|,
name|pos
operator|,
name|offs
operator|)
return|;
block|}
end_function

begin_function
name|void
name|roff_endparse
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|)
block|{
if|if
condition|(
name|r
operator|->
name|last
condition|)
name|mandoc_msg
argument_list|(
name|MANDOCERR_BLK_NOEND
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|r
operator|->
name|last
operator|->
name|line
argument_list|,
name|r
operator|->
name|last
operator|->
name|col
argument_list|,
name|roffs
index|[
name|r
operator|->
name|last
operator|->
name|tok
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|eqn
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_BLK_NOEND
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|r
operator|->
name|eqn
operator|->
name|eqn
operator|.
name|ln
argument_list|,
name|r
operator|->
name|eqn
operator|->
name|eqn
operator|.
name|pos
argument_list|,
literal|"EQ"
argument_list|)
expr_stmt|;
name|eqn_end
argument_list|(
operator|&
name|r
operator|->
name|eqn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|tbl
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_BLK_NOEND
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|r
operator|->
name|tbl
operator|->
name|line
argument_list|,
name|r
operator|->
name|tbl
operator|->
name|pos
argument_list|,
literal|"TS"
argument_list|)
expr_stmt|;
name|tbl_end
argument_list|(
operator|&
name|r
operator|->
name|tbl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Parse a roff node's type from the input buffer.  This must be in the  * form of ".foo xxx" in the usual way.  */
end_comment

begin_function
specifier|static
name|enum
name|rofft
name|roff_parse
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|int
name|ln
parameter_list|,
name|int
name|ppos
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
specifier|const
name|char
modifier|*
name|mac
decl_stmt|;
name|size_t
name|maclen
decl_stmt|;
name|enum
name|rofft
name|t
decl_stmt|;
name|cp
operator|=
name|buf
operator|+
operator|*
name|pos
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|cp
operator|||
literal|'"'
operator|==
operator|*
name|cp
operator|||
literal|'\t'
operator|==
operator|*
name|cp
operator|||
literal|' '
operator|==
operator|*
name|cp
condition|)
return|return
name|ROFF_MAX
return|;
name|mac
operator|=
name|cp
expr_stmt|;
name|maclen
operator|=
name|roff_getname
argument_list|(
name|r
argument_list|,
operator|&
name|cp
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
name|t
operator|=
operator|(
name|r
operator|->
name|current_string
operator|=
name|roff_getstrn
argument_list|(
name|r
argument_list|,
name|mac
argument_list|,
name|maclen
argument_list|)
operator|)
condition|?
name|ROFF_USERDEF
else|:
name|roffhash_find
argument_list|(
name|mac
argument_list|,
name|maclen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ROFF_MAX
operator|!=
name|t
condition|)
operator|*
name|pos
operator|=
name|cp
operator|-
name|buf
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* --- handling of request blocks ----------------------------------------- */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_cblock
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
comment|/* 	 * A block-close `..' should only be invoked as a child of an 	 * ignore macro, otherwise raise a warning and just ignore it. 	 */
if|if
condition|(
name|r
operator|->
name|last
operator|==
name|NULL
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_BLK_NOTOPEN
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
literal|".."
argument_list|)
expr_stmt|;
return|return
name|ROFF_IGN
return|;
block|}
switch|switch
condition|(
name|r
operator|->
name|last
operator|->
name|tok
condition|)
block|{
case|case
name|ROFF_am
case|:
comment|/* ROFF_am1 is remapped to ROFF_am in roff_block(). */
case|case
name|ROFF_ami
case|:
case|case
name|ROFF_de
case|:
comment|/* ROFF_de1 is remapped to ROFF_de in roff_block(). */
case|case
name|ROFF_dei
case|:
case|case
name|ROFF_ig
case|:
break|break;
default|default:
name|mandoc_msg
argument_list|(
name|MANDOCERR_BLK_NOTOPEN
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
literal|".."
argument_list|)
expr_stmt|;
return|return
name|ROFF_IGN
return|;
block|}
if|if
condition|(
name|buf
operator|->
name|buf
index|[
name|pos
index|]
operator|!=
literal|'\0'
condition|)
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_ARG_SKIP
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|pos
argument_list|,
literal|".. %s"
argument_list|,
name|buf
operator|->
name|buf
operator|+
name|pos
argument_list|)
expr_stmt|;
name|roffnode_pop
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|roffnode_cleanscope
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|ROFF_IGN
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|roffnode_cleanscope
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|)
block|{
while|while
condition|(
name|r
operator|->
name|last
condition|)
block|{
if|if
condition|(
operator|--
name|r
operator|->
name|last
operator|->
name|endspan
operator|!=
literal|0
condition|)
break|break;
name|roffnode_pop
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|roff_ccond
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|,
name|int
name|ln
parameter_list|,
name|int
name|ppos
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
name|r
operator|->
name|last
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_BLK_NOTOPEN
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
literal|"\\}"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|r
operator|->
name|last
operator|->
name|tok
condition|)
block|{
case|case
name|ROFF_el
case|:
case|case
name|ROFF_ie
case|:
case|case
name|ROFF_if
case|:
break|break;
default|default:
name|mandoc_msg
argument_list|(
name|MANDOCERR_BLK_NOTOPEN
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
literal|"\\}"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|r
operator|->
name|last
operator|->
name|endspan
operator|>
operator|-
literal|1
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_BLK_NOTOPEN
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
literal|"\\}"
argument_list|)
expr_stmt|;
return|return;
block|}
name|roffnode_pop
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|roffnode_cleanscope
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|enum
name|rofferr
name|roff_block
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|iname
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|size_t
name|namesz
decl_stmt|;
comment|/* Ignore groff compatibility mode for now. */
if|if
condition|(
name|tok
operator|==
name|ROFF_de1
condition|)
name|tok
operator|=
name|ROFF_de
expr_stmt|;
elseif|else
if|if
condition|(
name|tok
operator|==
name|ROFF_dei1
condition|)
name|tok
operator|=
name|ROFF_dei
expr_stmt|;
elseif|else
if|if
condition|(
name|tok
operator|==
name|ROFF_am1
condition|)
name|tok
operator|=
name|ROFF_am
expr_stmt|;
elseif|else
if|if
condition|(
name|tok
operator|==
name|ROFF_ami1
condition|)
name|tok
operator|=
name|ROFF_ami
expr_stmt|;
comment|/* Parse the macro name argument. */
name|cp
operator|=
name|buf
operator|->
name|buf
operator|+
name|pos
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|ROFF_ig
condition|)
block|{
name|iname
operator|=
name|NULL
expr_stmt|;
name|namesz
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|iname
operator|=
name|cp
expr_stmt|;
name|namesz
operator|=
name|roff_getname
argument_list|(
name|r
argument_list|,
operator|&
name|cp
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
name|iname
index|[
name|namesz
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Resolve the macro name argument if it is indirect. */
if|if
condition|(
name|namesz
operator|&&
operator|(
name|tok
operator|==
name|ROFF_dei
operator|||
name|tok
operator|==
name|ROFF_ami
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|name
operator|=
name|roff_getstrn
argument_list|(
name|r
argument_list|,
name|iname
argument_list|,
name|namesz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_STR_UNDEF
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
call|(
name|int
call|)
argument_list|(
name|iname
operator|-
name|buf
operator|->
name|buf
argument_list|)
argument_list|,
literal|"%.*s"
argument_list|,
operator|(
name|int
operator|)
name|namesz
argument_list|,
name|iname
argument_list|)
expr_stmt|;
name|namesz
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|namesz
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|name
operator|=
name|iname
expr_stmt|;
if|if
condition|(
name|namesz
operator|==
literal|0
operator|&&
name|tok
operator|!=
name|ROFF_ig
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_REQ_EMPTY
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
name|roffs
index|[
name|tok
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
name|ROFF_IGN
return|;
block|}
name|roffnode_push
argument_list|(
name|r
argument_list|,
name|tok
argument_list|,
name|name
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
comment|/* 	 * At the beginning of a `de' macro, clear the existing string 	 * with the same name, if there is one.  New content will be 	 * appended from roff_block_text() in multiline mode. 	 */
if|if
condition|(
name|tok
operator|==
name|ROFF_de
operator|||
name|tok
operator|==
name|ROFF_dei
condition|)
name|roff_setstrn
argument_list|(
operator|&
name|r
operator|->
name|strtab
argument_list|,
name|name
argument_list|,
name|namesz
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
return|return
name|ROFF_IGN
return|;
comment|/* Get the custom end marker. */
name|iname
operator|=
name|cp
expr_stmt|;
name|namesz
operator|=
name|roff_getname
argument_list|(
name|r
argument_list|,
operator|&
name|cp
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
comment|/* Resolve the end marker if it is indirect. */
if|if
condition|(
name|namesz
operator|&&
operator|(
name|tok
operator|==
name|ROFF_dei
operator|||
name|tok
operator|==
name|ROFF_ami
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|name
operator|=
name|roff_getstrn
argument_list|(
name|r
argument_list|,
name|iname
argument_list|,
name|namesz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_STR_UNDEF
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
call|(
name|int
call|)
argument_list|(
name|iname
operator|-
name|buf
operator|->
name|buf
argument_list|)
argument_list|,
literal|"%.*s"
argument_list|,
operator|(
name|int
operator|)
name|namesz
argument_list|,
name|iname
argument_list|)
expr_stmt|;
name|namesz
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|namesz
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|name
operator|=
name|iname
expr_stmt|;
if|if
condition|(
name|namesz
condition|)
name|r
operator|->
name|last
operator|->
name|end
operator|=
name|mandoc_strndup
argument_list|(
name|name
argument_list|,
name|namesz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_ARG_EXCESS
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|pos
argument_list|,
literal|".%s ... %s"
argument_list|,
name|roffs
index|[
name|tok
index|]
operator|.
name|name
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
name|ROFF_IGN
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|rofferr
name|roff_block_sub
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
name|enum
name|rofft
name|t
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* 	 * First check whether a custom macro exists at this level.  If 	 * it does, then check against it.  This is some of groff's 	 * stranger behaviours.  If we encountered a custom end-scope 	 * tag and that tag also happens to be a "real" macro, then we 	 * need to try interpreting it again as a real macro.  If it's 	 * not, then return ignore.  Else continue. 	 */
if|if
condition|(
name|r
operator|->
name|last
operator|->
name|end
condition|)
block|{
for|for
control|(
name|i
operator|=
name|pos
operator|,
name|j
operator|=
literal|0
init|;
name|r
operator|->
name|last
operator|->
name|end
index|[
name|j
index|]
condition|;
name|j
operator|++
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|buf
operator|->
name|buf
index|[
name|i
index|]
operator|!=
name|r
operator|->
name|last
operator|->
name|end
index|[
name|j
index|]
condition|)
break|break;
if|if
condition|(
name|r
operator|->
name|last
operator|->
name|end
index|[
name|j
index|]
operator|==
literal|'\0'
operator|&&
operator|(
name|buf
operator|->
name|buf
index|[
name|i
index|]
operator|==
literal|'\0'
operator|||
name|buf
operator|->
name|buf
index|[
name|i
index|]
operator|==
literal|' '
operator|||
name|buf
operator|->
name|buf
index|[
name|i
index|]
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|roffnode_pop
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|roffnode_cleanscope
argument_list|(
name|r
argument_list|)
expr_stmt|;
while|while
condition|(
name|buf
operator|->
name|buf
index|[
name|i
index|]
operator|==
literal|' '
operator|||
name|buf
operator|->
name|buf
index|[
name|i
index|]
operator|==
literal|'\t'
condition|)
name|i
operator|++
expr_stmt|;
name|pos
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|roff_parse
argument_list|(
name|r
argument_list|,
name|buf
operator|->
name|buf
argument_list|,
operator|&
name|pos
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|)
operator|!=
name|ROFF_MAX
condition|)
return|return
name|ROFF_RERUN
return|;
return|return
name|ROFF_IGN
return|;
block|}
block|}
comment|/* 	 * If we have no custom end-query or lookup failed, then try 	 * pulling it out of the hashtable. 	 */
name|t
operator|=
name|roff_parse
argument_list|(
name|r
argument_list|,
name|buf
operator|->
name|buf
argument_list|,
operator|&
name|pos
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|ROFF_cblock
condition|)
block|{
if|if
condition|(
name|tok
operator|!=
name|ROFF_ig
condition|)
name|roff_setstr
argument_list|(
name|r
argument_list|,
name|r
operator|->
name|last
operator|->
name|name
argument_list|,
name|buf
operator|->
name|buf
operator|+
name|ppos
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|ROFF_IGN
return|;
block|}
name|assert
argument_list|(
name|roffs
index|[
name|t
index|]
operator|.
name|proc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|roffs
index|[
name|t
index|]
operator|.
name|proc
operator|)
operator|(
name|r
operator|,
name|t
operator|,
name|buf
operator|,
name|ln
operator|,
name|ppos
operator|,
name|pos
operator|,
name|offs
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|rofferr
name|roff_block_text
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
if|if
condition|(
name|tok
operator|!=
name|ROFF_ig
condition|)
name|roff_setstr
argument_list|(
name|r
argument_list|,
name|r
operator|->
name|last
operator|->
name|name
argument_list|,
name|buf
operator|->
name|buf
operator|+
name|pos
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|ROFF_IGN
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|rofferr
name|roff_cond_sub
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
name|enum
name|rofft
name|t
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|int
name|rr
decl_stmt|;
name|rr
operator|=
name|r
operator|->
name|last
operator|->
name|rule
expr_stmt|;
name|roffnode_cleanscope
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|t
operator|=
name|roff_parse
argument_list|(
name|r
argument_list|,
name|buf
operator|->
name|buf
argument_list|,
operator|&
name|pos
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
comment|/* 	 * Fully handle known macros when they are structurally 	 * required or when the conditional evaluated to true. 	 */
if|if
condition|(
operator|(
name|t
operator|!=
name|ROFF_MAX
operator|)
operator|&&
operator|(
name|rr
operator|||
name|roffs
index|[
name|t
index|]
operator|.
name|flags
operator|&
name|ROFFMAC_STRUCT
operator|)
condition|)
block|{
name|assert
argument_list|(
name|roffs
index|[
name|t
index|]
operator|.
name|proc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|roffs
index|[
name|t
index|]
operator|.
name|proc
operator|)
operator|(
name|r
operator|,
name|t
operator|,
name|buf
operator|,
name|ln
operator|,
name|ppos
operator|,
name|pos
operator|,
name|offs
operator|)
return|;
block|}
comment|/* 	 * If `\}' occurs on a macro line without a preceding macro, 	 * drop the line completely. 	 */
name|ep
operator|=
name|buf
operator|->
name|buf
operator|+
name|pos
expr_stmt|;
if|if
condition|(
name|ep
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|ep
index|[
literal|1
index|]
operator|==
literal|'}'
condition|)
name|rr
operator|=
literal|0
expr_stmt|;
comment|/* Always check for the closing delimiter `\}'. */
while|while
condition|(
operator|(
name|ep
operator|=
name|strchr
argument_list|(
name|ep
argument_list|,
literal|'\\'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
operator|(
operator|++
name|ep
operator|)
operator|==
literal|'}'
condition|)
block|{
operator|*
name|ep
operator|=
literal|'&'
expr_stmt|;
name|roff_ccond
argument_list|(
name|r
argument_list|,
name|ln
argument_list|,
name|ep
operator|-
name|buf
operator|->
name|buf
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ep
operator|!=
literal|'\0'
condition|)
operator|++
name|ep
expr_stmt|;
block|}
return|return
name|rr
condition|?
name|ROFF_CONT
else|:
name|ROFF_IGN
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|rofferr
name|roff_cond_text
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
name|char
modifier|*
name|ep
decl_stmt|;
name|int
name|rr
decl_stmt|;
name|rr
operator|=
name|r
operator|->
name|last
operator|->
name|rule
expr_stmt|;
name|roffnode_cleanscope
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|ep
operator|=
name|buf
operator|->
name|buf
operator|+
name|pos
expr_stmt|;
while|while
condition|(
operator|(
name|ep
operator|=
name|strchr
argument_list|(
name|ep
argument_list|,
literal|'\\'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
operator|(
operator|++
name|ep
operator|)
operator|==
literal|'}'
condition|)
block|{
operator|*
name|ep
operator|=
literal|'&'
expr_stmt|;
name|roff_ccond
argument_list|(
name|r
argument_list|,
name|ln
argument_list|,
name|ep
operator|-
name|buf
operator|->
name|buf
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ep
operator|!=
literal|'\0'
condition|)
operator|++
name|ep
expr_stmt|;
block|}
return|return
name|rr
condition|?
name|ROFF_CONT
else|:
name|ROFF_IGN
return|;
block|}
end_function

begin_comment
comment|/* --- handling of numeric and conditional expressions -------------------- */
end_comment

begin_comment
comment|/*  * Parse a single signed integer number.  Stop at the first non-digit.  * If there is at least one digit, return success and advance the  * parse point, else return failure and let the parse point unchanged.  * Ignore overflows, treat them just like the C language.  */
end_comment

begin_function
specifier|static
name|int
name|roff_getnum
parameter_list|(
specifier|const
name|char
modifier|*
name|v
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|int
modifier|*
name|res
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|myres
decl_stmt|,
name|scaled
decl_stmt|,
name|n
decl_stmt|,
name|p
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|res
condition|)
name|res
operator|=
operator|&
name|myres
expr_stmt|;
name|p
operator|=
operator|*
name|pos
expr_stmt|;
name|n
operator|=
name|v
index|[
name|p
index|]
operator|==
literal|'-'
expr_stmt|;
if|if
condition|(
name|n
operator|||
name|v
index|[
name|p
index|]
operator|==
literal|'+'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ROFFNUM_WHITE
condition|)
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|v
index|[
name|p
index|]
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
for|for
control|(
operator|*
name|res
operator|=
literal|0
init|;
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|v
index|[
name|p
index|]
argument_list|)
condition|;
name|p
operator|++
control|)
operator|*
name|res
operator|=
literal|10
operator|*
operator|*
name|res
operator|+
name|v
index|[
name|p
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|p
operator|==
operator|*
name|pos
operator|+
name|n
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|n
condition|)
operator|*
name|res
operator|=
operator|-
operator|*
name|res
expr_stmt|;
comment|/* Each number may be followed by one optional scaling unit. */
switch|switch
condition|(
name|v
index|[
name|p
index|]
condition|)
block|{
case|case
literal|'f'
case|:
name|scaled
operator|=
operator|*
name|res
operator|*
literal|65536
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|scaled
operator|=
operator|*
name|res
operator|*
literal|240
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|scaled
operator|=
operator|*
name|res
operator|*
literal|240
operator|/
literal|2.54
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
case|case
literal|'P'
case|:
name|scaled
operator|=
operator|*
name|res
operator|*
literal|40
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
name|scaled
operator|=
operator|*
name|res
operator|*
literal|24
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|scaled
operator|=
operator|*
name|res
operator|*
literal|10
operator|/
literal|3
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|scaled
operator|=
operator|*
name|res
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|scaled
operator|=
operator|*
name|res
operator|*
literal|6
operator|/
literal|25
expr_stmt|;
break|break;
default|default:
name|scaled
operator|=
operator|*
name|res
expr_stmt|;
name|p
operator|--
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|flags
operator|&
name|ROFFNUM_SCALE
condition|)
operator|*
name|res
operator|=
name|scaled
expr_stmt|;
operator|*
name|pos
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Evaluate a string comparison condition.  * The first character is the delimiter.  * Succeed if the string up to its second occurrence  * matches the string up to its third occurence.  * Advance the cursor after the third occurrence  * or lacking that, to the end of the line.  */
end_comment

begin_function
specifier|static
name|int
name|roff_evalstrcond
parameter_list|(
specifier|const
name|char
modifier|*
name|v
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
name|int
name|match
decl_stmt|;
name|match
operator|=
literal|0
expr_stmt|;
name|s1
operator|=
name|v
operator|+
operator|*
name|pos
expr_stmt|;
comment|/* initial delimiter */
name|s2
operator|=
name|s1
operator|+
literal|1
expr_stmt|;
comment|/* for scanning the first string */
name|s3
operator|=
name|strchr
argument_list|(
name|s2
argument_list|,
operator|*
name|s1
argument_list|)
expr_stmt|;
comment|/* for scanning the second string */
if|if
condition|(
name|NULL
operator|==
name|s3
condition|)
comment|/* found no middle delimiter */
goto|goto
name|out
goto|;
while|while
condition|(
literal|'\0'
operator|!=
operator|*
operator|++
name|s3
condition|)
block|{
if|if
condition|(
operator|*
name|s2
operator|!=
operator|*
name|s3
condition|)
block|{
comment|/* mismatch */
name|s3
operator|=
name|strchr
argument_list|(
name|s3
argument_list|,
operator|*
name|s1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|s3
operator|==
operator|*
name|s1
condition|)
block|{
comment|/* found the final delimiter */
name|match
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|s2
operator|++
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|NULL
operator|==
name|s3
condition|)
name|s3
operator|=
name|strchr
argument_list|(
name|s2
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s3
operator|!=
literal|'\0'
condition|)
name|s3
operator|++
expr_stmt|;
operator|*
name|pos
operator|=
name|s3
operator|-
name|v
expr_stmt|;
return|return
name|match
return|;
block|}
end_function

begin_comment
comment|/*  * Evaluate an optionally negated single character, numerical,  * or string condition.  */
end_comment

begin_function
specifier|static
name|int
name|roff_evalcond
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|,
name|int
name|ln
parameter_list|,
name|char
modifier|*
name|v
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|int
name|number
decl_stmt|,
name|savepos
decl_stmt|,
name|wanttrue
decl_stmt|;
if|if
condition|(
literal|'!'
operator|==
name|v
index|[
operator|*
name|pos
index|]
condition|)
block|{
name|wanttrue
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
block|}
else|else
name|wanttrue
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|v
index|[
operator|*
name|pos
index|]
condition|)
block|{
case|case
literal|'\0'
case|:
return|return
literal|0
return|;
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
return|return
name|wanttrue
return|;
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'t'
case|:
case|case
literal|'v'
case|:
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
return|return
operator|!
name|wanttrue
return|;
case|case
literal|'r'
case|:
name|cp
operator|=
name|name
operator|=
name|v
operator|+
operator|++
operator|*
name|pos
expr_stmt|;
name|sz
operator|=
name|roff_getname
argument_list|(
name|r
argument_list|,
operator|&
name|cp
argument_list|,
name|ln
argument_list|,
operator|*
name|pos
argument_list|)
expr_stmt|;
operator|*
name|pos
operator|=
name|cp
operator|-
name|v
expr_stmt|;
return|return
operator|(
name|sz
operator|&&
name|roff_hasregn
argument_list|(
name|r
argument_list|,
name|name
argument_list|,
name|sz
argument_list|)
operator|)
operator|==
name|wanttrue
return|;
default|default:
break|break;
block|}
name|savepos
operator|=
operator|*
name|pos
expr_stmt|;
if|if
condition|(
name|roff_evalnum
argument_list|(
name|r
argument_list|,
name|ln
argument_list|,
name|v
argument_list|,
name|pos
argument_list|,
operator|&
name|number
argument_list|,
name|ROFFNUM_SCALE
argument_list|)
condition|)
return|return
operator|(
name|number
operator|>
literal|0
operator|)
operator|==
name|wanttrue
return|;
elseif|else
if|if
condition|(
operator|*
name|pos
operator|==
name|savepos
condition|)
return|return
name|roff_evalstrcond
argument_list|(
name|v
argument_list|,
name|pos
argument_list|)
operator|==
name|wanttrue
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|rofferr
name|roff_line_ignore
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
return|return
name|ROFF_IGN
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|rofferr
name|roff_insec
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_REQ_INSEC
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
name|roffs
index|[
name|tok
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
name|ROFF_IGN
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|rofferr
name|roff_unsupp
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_REQ_UNSUPP
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
name|roffs
index|[
name|tok
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
name|ROFF_IGN
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|rofferr
name|roff_cond
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
name|roffnode_push
argument_list|(
name|r
argument_list|,
name|tok
argument_list|,
name|NULL
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
comment|/* 	 * An `.el' has no conditional body: it will consume the value 	 * of the current rstack entry set in prior `ie' calls or 	 * defaults to DENY. 	 * 	 * If we're not an `el', however, then evaluate the conditional. 	 */
name|r
operator|->
name|last
operator|->
name|rule
operator|=
name|tok
operator|==
name|ROFF_el
condition|?
operator|(
name|r
operator|->
name|rstackpos
operator|<
literal|0
condition|?
literal|0
else|:
name|r
operator|->
name|rstack
index|[
name|r
operator|->
name|rstackpos
operator|--
index|]
operator|)
else|:
name|roff_evalcond
argument_list|(
name|r
argument_list|,
name|ln
argument_list|,
name|buf
operator|->
name|buf
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
comment|/* 	 * An if-else will put the NEGATION of the current evaluated 	 * conditional into the stack of rules. 	 */
if|if
condition|(
name|tok
operator|==
name|ROFF_ie
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|rstackpos
operator|+
literal|1
operator|==
name|r
operator|->
name|rstacksz
condition|)
block|{
name|r
operator|->
name|rstacksz
operator|+=
literal|16
expr_stmt|;
name|r
operator|->
name|rstack
operator|=
name|mandoc_reallocarray
argument_list|(
name|r
operator|->
name|rstack
argument_list|,
name|r
operator|->
name|rstacksz
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|r
operator|->
name|rstack
index|[
operator|++
name|r
operator|->
name|rstackpos
index|]
operator|=
operator|!
name|r
operator|->
name|last
operator|->
name|rule
expr_stmt|;
block|}
comment|/* If the parent has false as its rule, then so do we. */
if|if
condition|(
name|r
operator|->
name|last
operator|->
name|parent
operator|&&
operator|!
name|r
operator|->
name|last
operator|->
name|parent
operator|->
name|rule
condition|)
name|r
operator|->
name|last
operator|->
name|rule
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Determine scope. 	 * If there is nothing on the line after the conditional, 	 * not even whitespace, use next-line scope. 	 */
if|if
condition|(
name|buf
operator|->
name|buf
index|[
name|pos
index|]
operator|==
literal|'\0'
condition|)
block|{
name|r
operator|->
name|last
operator|->
name|endspan
operator|=
literal|2
expr_stmt|;
goto|goto
name|out
goto|;
block|}
while|while
condition|(
name|buf
operator|->
name|buf
index|[
name|pos
index|]
operator|==
literal|' '
condition|)
name|pos
operator|++
expr_stmt|;
comment|/* An opening brace requests multiline scope. */
if|if
condition|(
name|buf
operator|->
name|buf
index|[
name|pos
index|]
operator|==
literal|'\\'
operator|&&
name|buf
operator|->
name|buf
index|[
name|pos
operator|+
literal|1
index|]
operator|==
literal|'{'
condition|)
block|{
name|r
operator|->
name|last
operator|->
name|endspan
operator|=
operator|-
literal|1
expr_stmt|;
name|pos
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|buf
operator|->
name|buf
index|[
name|pos
index|]
operator|==
literal|' '
condition|)
name|pos
operator|++
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Anything else following the conditional causes 	 * single-line scope.  Warn if the scope contains 	 * nothing but trailing whitespace. 	 */
if|if
condition|(
name|buf
operator|->
name|buf
index|[
name|pos
index|]
operator|==
literal|'\0'
condition|)
name|mandoc_msg
argument_list|(
name|MANDOCERR_COND_EMPTY
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
name|roffs
index|[
name|tok
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|r
operator|->
name|last
operator|->
name|endspan
operator|=
literal|1
expr_stmt|;
name|out
label|:
operator|*
name|offs
operator|=
name|pos
expr_stmt|;
return|return
name|ROFF_RERUN
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|rofferr
name|roff_ds
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
name|char
modifier|*
name|string
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|namesz
decl_stmt|;
comment|/* Ignore groff compatibility mode for now. */
if|if
condition|(
name|tok
operator|==
name|ROFF_ds1
condition|)
name|tok
operator|=
name|ROFF_ds
expr_stmt|;
elseif|else
if|if
condition|(
name|tok
operator|==
name|ROFF_as1
condition|)
name|tok
operator|=
name|ROFF_as
expr_stmt|;
comment|/* 	 * The first word is the name of the string. 	 * If it is empty or terminated by an escape sequence, 	 * abort the `ds' request without defining anything. 	 */
name|name
operator|=
name|string
operator|=
name|buf
operator|->
name|buf
operator|+
name|pos
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
return|return
name|ROFF_IGN
return|;
name|namesz
operator|=
name|roff_getname
argument_list|(
name|r
argument_list|,
operator|&
name|string
argument_list|,
name|ln
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
name|namesz
index|]
operator|==
literal|'\\'
condition|)
return|return
name|ROFF_IGN
return|;
comment|/* Read past the initial double-quote, if any. */
if|if
condition|(
operator|*
name|string
operator|==
literal|'"'
condition|)
name|string
operator|++
expr_stmt|;
comment|/* The rest is the value. */
name|roff_setstrn
argument_list|(
operator|&
name|r
operator|->
name|strtab
argument_list|,
name|name
argument_list|,
name|namesz
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|,
name|ROFF_as
operator|==
name|tok
argument_list|)
expr_stmt|;
return|return
name|ROFF_IGN
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a single operator, one or two characters long.  * If the operator is recognized, return success and advance the  * parse point, else return failure and let the parse point unchanged.  */
end_comment

begin_function
specifier|static
name|int
name|roff_getop
parameter_list|(
specifier|const
name|char
modifier|*
name|v
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|char
modifier|*
name|res
parameter_list|)
block|{
operator|*
name|res
operator|=
name|v
index|[
operator|*
name|pos
index|]
expr_stmt|;
switch|switch
condition|(
operator|*
name|res
condition|)
block|{
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
literal|'*'
case|:
case|case
literal|'/'
case|:
case|case
literal|'%'
case|:
case|case
literal|'&'
case|:
case|case
literal|':'
case|:
break|break;
case|case
literal|'<'
case|:
switch|switch
condition|(
name|v
index|[
operator|*
name|pos
operator|+
literal|1
index|]
condition|)
block|{
case|case
literal|'='
case|:
operator|*
name|res
operator|=
literal|'l'
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
operator|*
name|res
operator|=
literal|'!'
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|*
name|res
operator|=
literal|'i'
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
literal|'>'
case|:
switch|switch
condition|(
name|v
index|[
operator|*
name|pos
operator|+
literal|1
index|]
condition|)
block|{
case|case
literal|'='
case|:
operator|*
name|res
operator|=
literal|'g'
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|*
name|res
operator|=
literal|'a'
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
literal|'='
case|:
if|if
condition|(
literal|'='
operator|==
name|v
index|[
operator|*
name|pos
operator|+
literal|1
index|]
condition|)
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
return|return
operator|*
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Evaluate either a parenthesized numeric expression  * or a single signed integer number.  */
end_comment

begin_function
specifier|static
name|int
name|roff_evalpar
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|,
name|int
name|ln
parameter_list|,
specifier|const
name|char
modifier|*
name|v
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|int
modifier|*
name|res
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
literal|'('
operator|!=
name|v
index|[
operator|*
name|pos
index|]
condition|)
return|return
name|roff_getnum
argument_list|(
name|v
argument_list|,
name|pos
argument_list|,
name|res
argument_list|,
name|flags
argument_list|)
return|;
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|roff_evalnum
argument_list|(
name|r
argument_list|,
name|ln
argument_list|,
name|v
argument_list|,
name|pos
argument_list|,
name|res
argument_list|,
name|flags
operator||
name|ROFFNUM_WHITE
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* 	 * Omission of the closing parenthesis 	 * is an error in validation mode, 	 * but ignored in evaluation mode. 	 */
if|if
condition|(
literal|')'
operator|==
name|v
index|[
operator|*
name|pos
index|]
condition|)
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|NULL
operator|==
name|res
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Evaluate a complete numeric expression.  * Proceed left to right, there is no concept of precedence.  */
end_comment

begin_function
specifier|static
name|int
name|roff_evalnum
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|,
name|int
name|ln
parameter_list|,
specifier|const
name|char
modifier|*
name|v
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|int
modifier|*
name|res
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|mypos
decl_stmt|,
name|operand2
decl_stmt|;
name|char
name|operator
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|pos
condition|)
block|{
name|mypos
operator|=
literal|0
expr_stmt|;
name|pos
operator|=
operator|&
name|mypos
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|ROFFNUM_WHITE
condition|)
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|v
index|[
operator|*
name|pos
index|]
argument_list|)
condition|)
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|roff_evalpar
argument_list|(
name|r
argument_list|,
name|ln
argument_list|,
name|v
argument_list|,
name|pos
argument_list|,
name|res
argument_list|,
name|flags
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|ROFFNUM_WHITE
condition|)
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|v
index|[
operator|*
name|pos
index|]
argument_list|)
condition|)
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|roff_getop
argument_list|(
name|v
argument_list|,
name|pos
argument_list|,
operator|&
name|operator
argument_list|)
condition|)
break|break;
if|if
condition|(
name|flags
operator|&
name|ROFFNUM_WHITE
condition|)
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|v
index|[
operator|*
name|pos
index|]
argument_list|)
condition|)
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|roff_evalpar
argument_list|(
name|r
argument_list|,
name|ln
argument_list|,
name|v
argument_list|,
name|pos
argument_list|,
operator|&
name|operand2
argument_list|,
name|flags
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|flags
operator|&
name|ROFFNUM_WHITE
condition|)
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|v
index|[
operator|*
name|pos
index|]
argument_list|)
condition|)
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|res
condition|)
continue|continue;
switch|switch
condition|(
name|operator
condition|)
block|{
case|case
literal|'+'
case|:
operator|*
name|res
operator|+=
name|operand2
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
operator|*
name|res
operator|-=
name|operand2
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
operator|*
name|res
operator|*=
name|operand2
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|operand2
operator|==
literal|0
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_DIVZERO
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
operator|*
name|pos
argument_list|,
name|v
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
literal|0
expr_stmt|;
break|break;
block|}
operator|*
name|res
operator|/=
name|operand2
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
if|if
condition|(
name|operand2
operator|==
literal|0
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_DIVZERO
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
operator|*
name|pos
argument_list|,
name|v
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
literal|0
expr_stmt|;
break|break;
block|}
operator|*
name|res
operator|%=
name|operand2
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
operator|*
name|res
operator|=
operator|*
name|res
operator|<
name|operand2
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
operator|*
name|res
operator|=
operator|*
name|res
operator|>
name|operand2
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
operator|*
name|res
operator|=
operator|*
name|res
operator|<=
name|operand2
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
operator|*
name|res
operator|=
operator|*
name|res
operator|>=
name|operand2
expr_stmt|;
break|break;
case|case
literal|'='
case|:
operator|*
name|res
operator|=
operator|*
name|res
operator|==
name|operand2
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
operator|*
name|res
operator|=
operator|*
name|res
operator|!=
name|operand2
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
operator|*
name|res
operator|=
operator|*
name|res
operator|&&
name|operand2
expr_stmt|;
break|break;
case|case
literal|':'
case|:
operator|*
name|res
operator|=
operator|*
name|res
operator|||
name|operand2
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|operand2
operator|<
operator|*
name|res
condition|)
operator|*
name|res
operator|=
name|operand2
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
if|if
condition|(
name|operand2
operator|>
operator|*
name|res
condition|)
operator|*
name|res
operator|=
name|operand2
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* --- register management ------------------------------------------------ */
end_comment

begin_function
name|void
name|roff_setreg
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|val
parameter_list|,
name|char
name|sign
parameter_list|)
block|{
name|struct
name|roffreg
modifier|*
name|reg
decl_stmt|;
comment|/* Search for an existing register with the same name. */
name|reg
operator|=
name|r
operator|->
name|regtab
expr_stmt|;
while|while
condition|(
name|reg
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|reg
operator|->
name|key
operator|.
name|p
argument_list|)
condition|)
name|reg
operator|=
name|reg
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|reg
condition|)
block|{
comment|/* Create a new register. */
name|reg
operator|=
name|mandoc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|roffreg
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|->
name|key
operator|.
name|p
operator|=
name|mandoc_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|reg
operator|->
name|key
operator|.
name|sz
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|reg
operator|->
name|val
operator|=
literal|0
expr_stmt|;
name|reg
operator|->
name|next
operator|=
name|r
operator|->
name|regtab
expr_stmt|;
name|r
operator|->
name|regtab
operator|=
name|reg
expr_stmt|;
block|}
if|if
condition|(
literal|'+'
operator|==
name|sign
condition|)
name|reg
operator|->
name|val
operator|+=
name|val
expr_stmt|;
elseif|else
if|if
condition|(
literal|'-'
operator|==
name|sign
condition|)
name|reg
operator|->
name|val
operator|-=
name|val
expr_stmt|;
else|else
name|reg
operator|->
name|val
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle some predefined read-only number registers.  * For now, return -1 if the requested register is not predefined;  * in case a predefined read-only register having the value -1  * were to turn up, another special value would have to be chosen.  */
end_comment

begin_function
specifier|static
name|int
name|roff_getregro
parameter_list|(
specifier|const
name|struct
name|roff
modifier|*
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
switch|switch
condition|(
operator|*
name|name
condition|)
block|{
case|case
literal|'$'
case|:
comment|/* Number of arguments of the last macro evaluated. */
return|return
name|r
operator|->
name|argc
return|;
case|case
literal|'A'
case|:
comment|/* ASCII approximation mode is always off. */
return|return
literal|0
return|;
case|case
literal|'g'
case|:
comment|/* Groff compatibility mode is always on. */
return|return
literal|1
return|;
case|case
literal|'H'
case|:
comment|/* Fixed horizontal resolution. */
return|return
literal|24
return|;
case|case
literal|'j'
case|:
comment|/* Always adjust left margin only. */
return|return
literal|0
return|;
case|case
literal|'T'
case|:
comment|/* Some output device is always defined. */
return|return
literal|1
return|;
case|case
literal|'V'
case|:
comment|/* Fixed vertical resolution. */
return|return
literal|40
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
name|int
name|roff_getreg
parameter_list|(
specifier|const
name|struct
name|roff
modifier|*
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|roffreg
modifier|*
name|reg
decl_stmt|;
name|int
name|val
decl_stmt|;
if|if
condition|(
literal|'.'
operator|==
name|name
index|[
literal|0
index|]
operator|&&
literal|'\0'
operator|!=
name|name
index|[
literal|1
index|]
operator|&&
literal|'\0'
operator|==
name|name
index|[
literal|2
index|]
condition|)
block|{
name|val
operator|=
name|roff_getregro
argument_list|(
name|r
argument_list|,
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|!=
name|val
condition|)
return|return
name|val
return|;
block|}
for|for
control|(
name|reg
operator|=
name|r
operator|->
name|regtab
init|;
name|reg
condition|;
name|reg
operator|=
name|reg
operator|->
name|next
control|)
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|name
argument_list|,
name|reg
operator|->
name|key
operator|.
name|p
argument_list|)
condition|)
return|return
name|reg
operator|->
name|val
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|roff_getregn
parameter_list|(
specifier|const
name|struct
name|roff
modifier|*
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|roffreg
modifier|*
name|reg
decl_stmt|;
name|int
name|val
decl_stmt|;
if|if
condition|(
literal|'.'
operator|==
name|name
index|[
literal|0
index|]
operator|&&
literal|2
operator|==
name|len
condition|)
block|{
name|val
operator|=
name|roff_getregro
argument_list|(
name|r
argument_list|,
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|!=
name|val
condition|)
return|return
name|val
return|;
block|}
for|for
control|(
name|reg
operator|=
name|r
operator|->
name|regtab
init|;
name|reg
condition|;
name|reg
operator|=
name|reg
operator|->
name|next
control|)
if|if
condition|(
name|len
operator|==
name|reg
operator|->
name|key
operator|.
name|sz
operator|&&
literal|0
operator|==
name|strncmp
argument_list|(
name|name
argument_list|,
name|reg
operator|->
name|key
operator|.
name|p
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|reg
operator|->
name|val
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|roff_hasregn
parameter_list|(
specifier|const
name|struct
name|roff
modifier|*
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|roffreg
modifier|*
name|reg
decl_stmt|;
name|int
name|val
decl_stmt|;
if|if
condition|(
literal|'.'
operator|==
name|name
index|[
literal|0
index|]
operator|&&
literal|2
operator|==
name|len
condition|)
block|{
name|val
operator|=
name|roff_getregro
argument_list|(
name|r
argument_list|,
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|!=
name|val
condition|)
return|return
literal|1
return|;
block|}
for|for
control|(
name|reg
operator|=
name|r
operator|->
name|regtab
init|;
name|reg
condition|;
name|reg
operator|=
name|reg
operator|->
name|next
control|)
if|if
condition|(
name|len
operator|==
name|reg
operator|->
name|key
operator|.
name|sz
operator|&&
literal|0
operator|==
name|strncmp
argument_list|(
name|name
argument_list|,
name|reg
operator|->
name|key
operator|.
name|p
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|roff_freereg
parameter_list|(
name|struct
name|roffreg
modifier|*
name|reg
parameter_list|)
block|{
name|struct
name|roffreg
modifier|*
name|old_reg
decl_stmt|;
while|while
condition|(
name|NULL
operator|!=
name|reg
condition|)
block|{
name|free
argument_list|(
name|reg
operator|->
name|key
operator|.
name|p
argument_list|)
expr_stmt|;
name|old_reg
operator|=
name|reg
expr_stmt|;
name|reg
operator|=
name|reg
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|old_reg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|rofferr
name|roff_nr
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|val
decl_stmt|;
name|size_t
name|keysz
decl_stmt|;
name|int
name|iv
decl_stmt|;
name|char
name|sign
decl_stmt|;
name|key
operator|=
name|val
operator|=
name|buf
operator|->
name|buf
operator|+
name|pos
expr_stmt|;
if|if
condition|(
operator|*
name|key
operator|==
literal|'\0'
condition|)
return|return
name|ROFF_IGN
return|;
name|keysz
operator|=
name|roff_getname
argument_list|(
name|r
argument_list|,
operator|&
name|val
argument_list|,
name|ln
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
index|[
name|keysz
index|]
operator|==
literal|'\\'
condition|)
return|return
name|ROFF_IGN
return|;
name|key
index|[
name|keysz
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sign
operator|=
operator|*
name|val
expr_stmt|;
if|if
condition|(
name|sign
operator|==
literal|'+'
operator|||
name|sign
operator|==
literal|'-'
condition|)
name|val
operator|++
expr_stmt|;
if|if
condition|(
name|roff_evalnum
argument_list|(
name|r
argument_list|,
name|ln
argument_list|,
name|val
argument_list|,
name|NULL
argument_list|,
operator|&
name|iv
argument_list|,
name|ROFFNUM_SCALE
argument_list|)
condition|)
name|roff_setreg
argument_list|(
name|r
argument_list|,
name|key
argument_list|,
name|iv
argument_list|,
name|sign
argument_list|)
expr_stmt|;
return|return
name|ROFF_IGN
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|rofferr
name|roff_rr
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
name|struct
name|roffreg
modifier|*
name|reg
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|size_t
name|namesz
decl_stmt|;
name|name
operator|=
name|cp
operator|=
name|buf
operator|->
name|buf
operator|+
name|pos
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
return|return
name|ROFF_IGN
return|;
name|namesz
operator|=
name|roff_getname
argument_list|(
name|r
argument_list|,
operator|&
name|cp
argument_list|,
name|ln
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|name
index|[
name|namesz
index|]
operator|=
literal|'\0'
expr_stmt|;
name|prev
operator|=
operator|&
name|r
operator|->
name|regtab
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|reg
operator|=
operator|*
name|prev
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|reg
operator|->
name|key
operator|.
name|p
argument_list|)
condition|)
break|break;
name|prev
operator|=
operator|&
name|reg
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|!=
name|NULL
condition|)
block|{
operator|*
name|prev
operator|=
name|reg
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|reg
operator|->
name|key
operator|.
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
return|return
name|ROFF_IGN
return|;
block|}
end_function

begin_comment
comment|/* --- handler functions for roff requests -------------------------------- */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_rm
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|namesz
decl_stmt|;
name|cp
operator|=
name|buf
operator|->
name|buf
operator|+
name|pos
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|name
operator|=
name|cp
expr_stmt|;
name|namesz
operator|=
name|roff_getname
argument_list|(
name|r
argument_list|,
operator|&
name|cp
argument_list|,
name|ln
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cp
operator|-
name|buf
operator|->
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|roff_setstrn
argument_list|(
operator|&
name|r
operator|->
name|strtab
argument_list|,
name|name
argument_list|,
name|namesz
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
name|namesz
index|]
operator|==
literal|'\\'
condition|)
break|break;
block|}
return|return
name|ROFF_IGN
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|rofferr
name|roff_it
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
name|int
name|iv
decl_stmt|;
comment|/* Parse the number of lines. */
if|if
condition|(
operator|!
name|roff_evalnum
argument_list|(
name|r
argument_list|,
name|ln
argument_list|,
name|buf
operator|->
name|buf
argument_list|,
operator|&
name|pos
argument_list|,
operator|&
name|iv
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_IT_NONUM
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
name|buf
operator|->
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|ROFF_IGN
return|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|buf
operator|->
name|buf
index|[
name|pos
index|]
argument_list|)
condition|)
name|pos
operator|++
expr_stmt|;
comment|/* 	 * Arm the input line trap. 	 * Special-casing "an-trap" is an ugly workaround to cope 	 * with DocBook stupidly fiddling with man(7) internals. 	 */
name|roffit_lines
operator|=
name|iv
expr_stmt|;
name|roffit_macro
operator|=
name|mandoc_strdup
argument_list|(
name|iv
operator|!=
literal|1
operator|||
name|strcmp
argument_list|(
name|buf
operator|->
name|buf
operator|+
name|pos
argument_list|,
literal|"an-trap"
argument_list|)
condition|?
name|buf
operator|->
name|buf
operator|+
name|pos
else|:
literal|"br"
argument_list|)
expr_stmt|;
return|return
name|ROFF_IGN
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|rofferr
name|roff_Dd
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|->
name|options
operator|&
operator|(
name|MPARSE_MDOC
operator||
name|MPARSE_QUICK
operator|)
operator|)
operator|==
literal|0
condition|)
for|for
control|(
name|cp
operator|=
name|__mdoc_reserved
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
name|roff_setstr
argument_list|(
name|r
argument_list|,
operator|*
name|cp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|format
operator|==
literal|0
condition|)
name|r
operator|->
name|format
operator|=
name|MPARSE_MDOC
expr_stmt|;
return|return
name|ROFF_CONT
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|rofferr
name|roff_TH
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|->
name|options
operator|&
name|MPARSE_QUICK
operator|)
operator|==
literal|0
condition|)
for|for
control|(
name|cp
operator|=
name|__man_reserved
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
name|roff_setstr
argument_list|(
name|r
argument_list|,
operator|*
name|cp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|format
operator|==
literal|0
condition|)
name|r
operator|->
name|format
operator|=
name|MPARSE_MAN
expr_stmt|;
return|return
name|ROFF_CONT
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|rofferr
name|roff_TE
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
name|r
operator|->
name|tbl
condition|)
name|mandoc_msg
argument_list|(
name|MANDOCERR_BLK_NOTOPEN
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
literal|"TE"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|tbl_end
argument_list|(
operator|&
name|r
operator|->
name|tbl
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|buf
operator|->
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|->
name|buf
operator|=
name|mandoc_strdup
argument_list|(
literal|".sp"
argument_list|)
expr_stmt|;
name|buf
operator|->
name|sz
operator|=
literal|4
expr_stmt|;
return|return
name|ROFF_REPARSE
return|;
block|}
return|return
name|ROFF_IGN
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|rofferr
name|roff_T_
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
name|r
operator|->
name|tbl
condition|)
name|mandoc_msg
argument_list|(
name|MANDOCERR_BLK_NOTOPEN
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
literal|"T&"
argument_list|)
expr_stmt|;
else|else
name|tbl_restart
argument_list|(
name|ppos
argument_list|,
name|ln
argument_list|,
name|r
operator|->
name|tbl
argument_list|)
expr_stmt|;
return|return
name|ROFF_IGN
return|;
block|}
end_function

begin_comment
comment|/*  * Handle in-line equation delimiters.  */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_eqndelim
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|,
name|struct
name|buf
modifier|*
name|buf
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
specifier|const
name|char
modifier|*
name|bef_pr
decl_stmt|,
modifier|*
name|bef_nl
decl_stmt|,
modifier|*
name|mac
decl_stmt|,
modifier|*
name|aft_nl
decl_stmt|,
modifier|*
name|aft_pr
decl_stmt|;
comment|/* 	 * Outside equations, look for an opening delimiter. 	 * If we are inside an equation, we already know it is 	 * in-line, or this function wouldn't have been called; 	 * so look for a closing delimiter. 	 */
name|cp1
operator|=
name|buf
operator|->
name|buf
operator|+
name|pos
expr_stmt|;
name|cp2
operator|=
name|strchr
argument_list|(
name|cp1
argument_list|,
name|r
operator|->
name|eqn
operator|==
name|NULL
condition|?
name|r
operator|->
name|last_eqn
operator|->
name|odelim
else|:
name|r
operator|->
name|last_eqn
operator|->
name|cdelim
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp2
operator|==
name|NULL
condition|)
return|return
name|ROFF_CONT
return|;
operator|*
name|cp2
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|bef_pr
operator|=
name|bef_nl
operator|=
name|aft_nl
operator|=
name|aft_pr
operator|=
literal|""
expr_stmt|;
comment|/* Handle preceding text, protecting whitespace. */
if|if
condition|(
operator|*
name|buf
operator|->
name|buf
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|eqn
operator|==
name|NULL
condition|)
name|bef_pr
operator|=
literal|"\\&"
expr_stmt|;
name|bef_nl
operator|=
literal|"\n"
expr_stmt|;
block|}
comment|/* 	 * Prepare replacing the delimiter with an equation macro 	 * and drop leading white space from the equation. 	 */
if|if
condition|(
name|r
operator|->
name|eqn
operator|==
name|NULL
condition|)
block|{
while|while
condition|(
operator|*
name|cp2
operator|==
literal|' '
condition|)
name|cp2
operator|++
expr_stmt|;
name|mac
operator|=
literal|".EQ"
expr_stmt|;
block|}
else|else
name|mac
operator|=
literal|".EN"
expr_stmt|;
comment|/* Handle following text, protecting whitespace. */
if|if
condition|(
operator|*
name|cp2
operator|!=
literal|'\0'
condition|)
block|{
name|aft_nl
operator|=
literal|"\n"
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|eqn
operator|!=
name|NULL
condition|)
name|aft_pr
operator|=
literal|"\\&"
expr_stmt|;
block|}
comment|/* Do the actual replacement. */
name|buf
operator|->
name|sz
operator|=
name|mandoc_asprintf
argument_list|(
operator|&
name|cp1
argument_list|,
literal|"%s%s%s%s%s%s%s"
argument_list|,
name|buf
operator|->
name|buf
argument_list|,
name|bef_pr
argument_list|,
name|bef_nl
argument_list|,
name|mac
argument_list|,
name|aft_nl
argument_list|,
name|aft_pr
argument_list|,
name|cp2
argument_list|)
operator|+
literal|1
expr_stmt|;
name|free
argument_list|(
name|buf
operator|->
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|->
name|buf
operator|=
name|cp1
expr_stmt|;
comment|/* Toggle the in-line state of the eqn subsystem. */
name|r
operator|->
name|eqn_inline
operator|=
name|r
operator|->
name|eqn
operator|==
name|NULL
expr_stmt|;
return|return
name|ROFF_REPARSE
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|rofferr
name|roff_EQ
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
name|struct
name|eqn_node
modifier|*
name|e
decl_stmt|;
name|assert
argument_list|(
name|r
operator|->
name|eqn
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|e
operator|=
name|eqn_alloc
argument_list|(
name|ppos
argument_list|,
name|ln
argument_list|,
name|r
operator|->
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|last_eqn
condition|)
block|{
name|r
operator|->
name|last_eqn
operator|->
name|next
operator|=
name|e
expr_stmt|;
name|e
operator|->
name|delim
operator|=
name|r
operator|->
name|last_eqn
operator|->
name|delim
expr_stmt|;
name|e
operator|->
name|odelim
operator|=
name|r
operator|->
name|last_eqn
operator|->
name|odelim
expr_stmt|;
name|e
operator|->
name|cdelim
operator|=
name|r
operator|->
name|last_eqn
operator|->
name|cdelim
expr_stmt|;
block|}
else|else
name|r
operator|->
name|first_eqn
operator|=
name|r
operator|->
name|last_eqn
operator|=
name|e
expr_stmt|;
name|r
operator|->
name|eqn
operator|=
name|r
operator|->
name|last_eqn
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|buf
index|[
name|pos
index|]
operator|!=
literal|'\0'
condition|)
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_ARG_SKIP
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|pos
argument_list|,
literal|".EQ %s"
argument_list|,
name|buf
operator|->
name|buf
operator|+
name|pos
argument_list|)
expr_stmt|;
return|return
name|ROFF_IGN
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|rofferr
name|roff_EN
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_BLK_NOTOPEN
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
literal|"EN"
argument_list|)
expr_stmt|;
return|return
name|ROFF_IGN
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|rofferr
name|roff_TS
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
name|struct
name|tbl_node
modifier|*
name|tbl
decl_stmt|;
if|if
condition|(
name|r
operator|->
name|tbl
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_BLK_BROKEN
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
literal|"TS breaks TS"
argument_list|)
expr_stmt|;
name|tbl_end
argument_list|(
operator|&
name|r
operator|->
name|tbl
argument_list|)
expr_stmt|;
block|}
name|tbl
operator|=
name|tbl_alloc
argument_list|(
name|ppos
argument_list|,
name|ln
argument_list|,
name|r
operator|->
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|last_tbl
condition|)
name|r
operator|->
name|last_tbl
operator|->
name|next
operator|=
name|tbl
expr_stmt|;
else|else
name|r
operator|->
name|first_tbl
operator|=
name|r
operator|->
name|last_tbl
operator|=
name|tbl
expr_stmt|;
name|r
operator|->
name|tbl
operator|=
name|r
operator|->
name|last_tbl
operator|=
name|tbl
expr_stmt|;
return|return
name|ROFF_IGN
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|rofferr
name|roff_brp
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
name|buf
operator|->
name|buf
index|[
name|pos
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ROFF_CONT
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|rofferr
name|roff_cc
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|buf
operator|->
name|buf
operator|+
name|pos
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|||
operator|(
name|r
operator|->
name|control
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
literal|'.'
condition|)
name|r
operator|->
name|control
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_ARG_EXCESS
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|p
operator|-
name|buf
operator|->
name|buf
argument_list|,
literal|"cc ... %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|ROFF_IGN
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|rofferr
name|roff_tr
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|first
decl_stmt|,
modifier|*
name|second
decl_stmt|;
name|size_t
name|fsz
decl_stmt|,
name|ssz
decl_stmt|;
name|enum
name|mandoc_esc
name|esc
decl_stmt|;
name|p
operator|=
name|buf
operator|->
name|buf
operator|+
name|pos
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_REQ_EMPTY
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
literal|"tr"
argument_list|)
expr_stmt|;
return|return
name|ROFF_IGN
return|;
block|}
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|fsz
operator|=
name|ssz
operator|=
literal|1
expr_stmt|;
name|first
operator|=
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|first
operator|==
literal|'\\'
condition|)
block|{
name|esc
operator|=
name|mandoc_escape
argument_list|(
operator|&
name|p
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|esc
operator|==
name|ESCAPE_ERROR
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_ESC_BAD
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|-
name|buf
operator|->
name|buf
argument_list|)
argument_list|,
name|first
argument_list|)
expr_stmt|;
return|return
name|ROFF_IGN
return|;
block|}
name|fsz
operator|=
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|first
argument_list|)
expr_stmt|;
block|}
name|second
operator|=
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|second
operator|==
literal|'\\'
condition|)
block|{
name|esc
operator|=
name|mandoc_escape
argument_list|(
operator|&
name|p
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|esc
operator|==
name|ESCAPE_ERROR
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_ESC_BAD
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|-
name|buf
operator|->
name|buf
argument_list|)
argument_list|,
name|second
argument_list|)
expr_stmt|;
return|return
name|ROFF_IGN
return|;
block|}
name|ssz
operator|=
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|second
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|second
operator|==
literal|'\0'
condition|)
block|{
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_TR_ODD
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|first
operator|-
name|buf
operator|->
name|buf
argument_list|,
literal|"tr %s"
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|second
operator|=
literal|" "
expr_stmt|;
name|p
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|fsz
operator|>
literal|1
condition|)
block|{
name|roff_setstrn
argument_list|(
operator|&
name|r
operator|->
name|xmbtab
argument_list|,
name|first
argument_list|,
name|fsz
argument_list|,
name|second
argument_list|,
name|ssz
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|r
operator|->
name|xtab
operator|==
name|NULL
condition|)
name|r
operator|->
name|xtab
operator|=
name|mandoc_calloc
argument_list|(
literal|128
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|roffstr
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
operator|->
name|xtab
index|[
operator|(
name|int
operator|)
operator|*
name|first
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
name|r
operator|->
name|xtab
index|[
operator|(
name|int
operator|)
operator|*
name|first
index|]
operator|.
name|p
operator|=
name|mandoc_strndup
argument_list|(
name|second
argument_list|,
name|ssz
argument_list|)
expr_stmt|;
name|r
operator|->
name|xtab
index|[
operator|(
name|int
operator|)
operator|*
name|first
index|]
operator|.
name|sz
operator|=
name|ssz
expr_stmt|;
block|}
return|return
name|ROFF_IGN
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|rofferr
name|roff_so
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|name
operator|=
name|buf
operator|->
name|buf
operator|+
name|pos
expr_stmt|;
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_SO
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
literal|"so %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Handle `so'.  Be EXTREMELY careful, as we shouldn't be 	 * opening anything that's not in our cwd or anything beneath 	 * it.  Thus, explicitly disallow traversing up the file-system 	 * or using absolute paths. 	 */
if|if
condition|(
operator|*
name|name
operator|==
literal|'/'
operator|||
name|strstr
argument_list|(
name|name
argument_list|,
literal|"../"
argument_list|)
operator|||
name|strstr
argument_list|(
name|name
argument_list|,
literal|"/.."
argument_list|)
condition|)
block|{
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_SO_PATH
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|ppos
argument_list|,
literal|".so %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|buf
operator|->
name|sz
operator|=
name|mandoc_asprintf
argument_list|(
operator|&
name|cp
argument_list|,
literal|".sp\nSee the file %s.\n.sp"
argument_list|,
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|free
argument_list|(
name|buf
operator|->
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|->
name|buf
operator|=
name|cp
expr_stmt|;
operator|*
name|offs
operator|=
literal|0
expr_stmt|;
return|return
name|ROFF_REPARSE
return|;
block|}
operator|*
name|offs
operator|=
name|pos
expr_stmt|;
return|return
name|ROFF_SO
return|;
block|}
end_function

begin_comment
comment|/* --- user defined strings and macros ------------------------------------ */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|roff_userdef
parameter_list|(
name|ROFF_ARGS
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|arg
index|[
literal|9
index|]
decl_stmt|,
modifier|*
name|ap
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|n1
decl_stmt|,
modifier|*
name|n2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ib
decl_stmt|,
name|ie
decl_stmt|;
name|size_t
name|asz
decl_stmt|,
name|rsz
decl_stmt|;
comment|/* 	 * Collect pointers to macro argument strings 	 * and NUL-terminate them. 	 */
name|r
operator|->
name|argc
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|buf
operator|->
name|buf
operator|+
name|pos
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
name|arg
index|[
name|i
index|]
operator|=
literal|""
expr_stmt|;
else|else
block|{
name|arg
index|[
name|i
index|]
operator|=
name|mandoc_getarg
argument_list|(
name|r
operator|->
name|parse
argument_list|,
operator|&
name|cp
argument_list|,
name|ln
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
name|r
operator|->
name|argc
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Expand macro arguments. 	 */
name|buf
operator|->
name|sz
operator|=
name|strlen
argument_list|(
name|r
operator|->
name|current_string
argument_list|)
operator|+
literal|1
expr_stmt|;
name|n1
operator|=
name|cp
operator|=
name|mandoc_malloc
argument_list|(
name|buf
operator|->
name|sz
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|n1
argument_list|,
name|r
operator|->
name|current_string
argument_list|,
name|buf
operator|->
name|sz
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Scan ahead for the next argument invocation. */
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'\\'
condition|)
continue|continue;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'$'
condition|)
continue|continue;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'*'
condition|)
block|{
comment|/* \\$* inserts all arguments */
name|ib
operator|=
literal|0
expr_stmt|;
name|ie
operator|=
name|r
operator|->
name|argc
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* \\$1 .. \\$9 insert one argument */
name|ib
operator|=
name|ie
operator|=
operator|*
name|cp
operator|-
literal|'1'
expr_stmt|;
if|if
condition|(
name|ib
operator|<
literal|0
operator|||
name|ib
operator|>
literal|8
condition|)
continue|continue;
block|}
name|cp
operator|-=
literal|2
expr_stmt|;
comment|/* 		 * Determine the size of the expanded argument, 		 * taking escaping of quotes into account. 		 */
name|asz
operator|=
name|ie
operator|>
name|ib
condition|?
name|ie
operator|-
name|ib
else|:
literal|0
expr_stmt|;
comment|/* for blanks */
for|for
control|(
name|i
operator|=
name|ib
init|;
name|i
operator|<=
name|ie
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|ap
operator|=
name|arg
index|[
name|i
index|]
init|;
operator|*
name|ap
operator|!=
literal|'\0'
condition|;
name|ap
operator|++
control|)
block|{
name|asz
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ap
operator|==
literal|'"'
condition|)
name|asz
operator|+=
literal|3
expr_stmt|;
block|}
block|}
if|if
condition|(
name|asz
operator|!=
literal|3
condition|)
block|{
comment|/* 			 * Determine the size of the rest of the 			 * unexpanded macro, including the NUL. 			 */
name|rsz
operator|=
name|buf
operator|->
name|sz
operator|-
operator|(
name|cp
operator|-
name|n1
operator|)
operator|-
literal|3
expr_stmt|;
comment|/* 			 * When shrinking, move before 			 * releasing the storage. 			 */
if|if
condition|(
name|asz
operator|<
literal|3
condition|)
name|memmove
argument_list|(
name|cp
operator|+
name|asz
argument_list|,
name|cp
operator|+
literal|3
argument_list|,
name|rsz
argument_list|)
expr_stmt|;
comment|/* 			 * Resize the storage for the macro 			 * and readjust the parse pointer. 			 */
name|buf
operator|->
name|sz
operator|+=
name|asz
operator|-
literal|3
expr_stmt|;
name|n2
operator|=
name|mandoc_realloc
argument_list|(
name|n1
argument_list|,
name|buf
operator|->
name|sz
argument_list|)
expr_stmt|;
name|cp
operator|=
name|n2
operator|+
operator|(
name|cp
operator|-
name|n1
operator|)
expr_stmt|;
name|n1
operator|=
name|n2
expr_stmt|;
comment|/* 			 * When growing, make room 			 * for the expanded argument. 			 */
if|if
condition|(
name|asz
operator|>
literal|3
condition|)
name|memmove
argument_list|(
name|cp
operator|+
name|asz
argument_list|,
name|cp
operator|+
literal|3
argument_list|,
name|rsz
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the expanded argument, escaping quotes. */
name|n2
operator|=
name|cp
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ib
init|;
name|i
operator|<=
name|ie
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|ap
operator|=
name|arg
index|[
name|i
index|]
init|;
operator|*
name|ap
operator|!=
literal|'\0'
condition|;
name|ap
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ap
operator|==
literal|'"'
condition|)
block|{
name|memcpy
argument_list|(
name|n2
argument_list|,
literal|"\\(dq"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|n2
operator|+=
literal|4
expr_stmt|;
block|}
else|else
operator|*
name|n2
operator|++
operator|=
operator|*
name|ap
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|ie
condition|)
operator|*
name|n2
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
block|}
comment|/* 	 * Replace the macro invocation 	 * by the expanded macro. 	 */
name|free
argument_list|(
name|buf
operator|->
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|->
name|buf
operator|=
name|n1
expr_stmt|;
operator|*
name|offs
operator|=
literal|0
expr_stmt|;
return|return
name|buf
operator|->
name|sz
operator|>
literal|1
operator|&&
name|buf
operator|->
name|buf
index|[
name|buf
operator|->
name|sz
operator|-
literal|2
index|]
operator|==
literal|'\n'
condition|?
name|ROFF_REPARSE
else|:
name|ROFF_APPEND
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|roff_getname
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|,
name|char
modifier|*
modifier|*
name|cpp
parameter_list|,
name|int
name|ln
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|size_t
name|namesz
decl_stmt|;
name|name
operator|=
operator|*
name|cpp
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|name
condition|)
return|return
literal|0
return|;
comment|/* Read until end of name and terminate it with NUL. */
for|for
control|(
name|cp
operator|=
name|name
init|;
literal|1
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|cp
operator|||
literal|' '
operator|==
operator|*
name|cp
condition|)
block|{
name|namesz
operator|=
name|cp
operator|-
name|name
expr_stmt|;
break|break;
block|}
if|if
condition|(
literal|'\\'
operator|!=
operator|*
name|cp
condition|)
continue|continue;
name|namesz
operator|=
name|cp
operator|-
name|name
expr_stmt|;
if|if
condition|(
literal|'{'
operator|==
name|cp
index|[
literal|1
index|]
operator|||
literal|'}'
operator|==
name|cp
index|[
literal|1
index|]
condition|)
break|break;
name|cp
operator|++
expr_stmt|;
if|if
condition|(
literal|'\\'
operator|==
operator|*
name|cp
condition|)
continue|continue;
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_NAMESC
argument_list|,
name|r
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|pos
argument_list|,
literal|"%.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cp
operator|-
name|name
operator|+
literal|1
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|mandoc_escape
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|cp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Read past spaces. */
while|while
condition|(
literal|' '
operator|==
operator|*
name|cp
condition|)
name|cp
operator|++
expr_stmt|;
operator|*
name|cpp
operator|=
name|cp
expr_stmt|;
return|return
name|namesz
return|;
block|}
end_function

begin_comment
comment|/*  * Store *string into the user-defined string called *name.  * To clear an existing entry, call with (*r, *name, NULL, 0).  * append == 0: replace mode  * append == 1: single-line append mode  * append == 2: multiline append mode, append '\n' after each call  */
end_comment

begin_function
specifier|static
name|void
name|roff_setstr
parameter_list|(
name|struct
name|roff
modifier|*
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
name|append
parameter_list|)
block|{
name|roff_setstrn
argument_list|(
operator|&
name|r
operator|->
name|strtab
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|string
argument_list|,
name|string
condition|?
name|strlen
argument_list|(
name|string
argument_list|)
else|:
literal|0
argument_list|,
name|append
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|roff_setstrn
parameter_list|(
name|struct
name|roffkv
modifier|*
modifier|*
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|namesz
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|size_t
name|stringsz
parameter_list|,
name|int
name|append
parameter_list|)
block|{
name|struct
name|roffkv
modifier|*
name|n
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|oldch
decl_stmt|,
name|newch
decl_stmt|;
comment|/* Search for an existing string with the same name. */
name|n
operator|=
operator|*
name|r
expr_stmt|;
while|while
condition|(
name|n
operator|&&
operator|(
name|namesz
operator|!=
name|n
operator|->
name|key
operator|.
name|sz
operator|||
name|strncmp
argument_list|(
name|n
operator|->
name|key
operator|.
name|p
argument_list|,
name|name
argument_list|,
name|namesz
argument_list|)
operator|)
condition|)
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|n
condition|)
block|{
comment|/* Create a new string table entry. */
name|n
operator|=
name|mandoc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|roffkv
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|key
operator|.
name|p
operator|=
name|mandoc_strndup
argument_list|(
name|name
argument_list|,
name|namesz
argument_list|)
expr_stmt|;
name|n
operator|->
name|key
operator|.
name|sz
operator|=
name|namesz
expr_stmt|;
name|n
operator|->
name|val
operator|.
name|p
operator|=
name|NULL
expr_stmt|;
name|n
operator|->
name|val
operator|.
name|sz
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|next
operator|=
operator|*
name|r
expr_stmt|;
operator|*
name|r
operator|=
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|append
condition|)
block|{
name|free
argument_list|(
name|n
operator|->
name|val
operator|.
name|p
argument_list|)
expr_stmt|;
name|n
operator|->
name|val
operator|.
name|p
operator|=
name|NULL
expr_stmt|;
name|n
operator|->
name|val
operator|.
name|sz
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|NULL
operator|==
name|string
condition|)
return|return;
comment|/* 	 * One additional byte for the '\n' in multiline mode, 	 * and one for the terminating '\0'. 	 */
name|newch
operator|=
name|stringsz
operator|+
operator|(
literal|1
operator|<
name|append
condition|?
literal|2u
else|:
literal|1u
operator|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|val
operator|.
name|p
condition|)
block|{
name|n
operator|->
name|val
operator|.
name|p
operator|=
name|mandoc_malloc
argument_list|(
name|newch
argument_list|)
expr_stmt|;
operator|*
name|n
operator|->
name|val
operator|.
name|p
operator|=
literal|'\0'
expr_stmt|;
name|oldch
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|oldch
operator|=
name|n
operator|->
name|val
operator|.
name|sz
expr_stmt|;
name|n
operator|->
name|val
operator|.
name|p
operator|=
name|mandoc_realloc
argument_list|(
name|n
operator|->
name|val
operator|.
name|p
argument_list|,
name|oldch
operator|+
name|newch
argument_list|)
expr_stmt|;
block|}
comment|/* Skip existing content in the destination buffer. */
name|c
operator|=
name|n
operator|->
name|val
operator|.
name|p
operator|+
operator|(
name|int
operator|)
name|oldch
expr_stmt|;
comment|/* Append new content to the destination buffer. */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
operator|(
name|int
operator|)
name|stringsz
condition|)
block|{
comment|/* 		 * Rudimentary roff copy mode: 		 * Handle escaped backslashes. 		 */
if|if
condition|(
literal|'\\'
operator|==
name|string
index|[
name|i
index|]
operator|&&
literal|'\\'
operator|==
name|string
index|[
name|i
operator|+
literal|1
index|]
condition|)
name|i
operator|++
expr_stmt|;
operator|*
name|c
operator|++
operator|=
name|string
index|[
name|i
operator|++
index|]
expr_stmt|;
block|}
comment|/* Append terminating bytes. */
if|if
condition|(
literal|1
operator|<
name|append
condition|)
operator|*
name|c
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|c
operator|=
literal|'\0'
expr_stmt|;
name|n
operator|->
name|val
operator|.
name|sz
operator|=
call|(
name|int
call|)
argument_list|(
name|c
operator|-
name|n
operator|->
name|val
operator|.
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|roff_getstrn
parameter_list|(
specifier|const
name|struct
name|roff
modifier|*
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|struct
name|roffkv
modifier|*
name|n
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|n
operator|=
name|r
operator|->
name|strtab
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|name
argument_list|,
name|n
operator|->
name|key
operator|.
name|p
argument_list|,
name|len
argument_list|)
operator|&&
literal|'\0'
operator|==
name|n
operator|->
name|key
operator|.
name|p
index|[
operator|(
name|int
operator|)
name|len
index|]
condition|)
return|return
name|n
operator|->
name|val
operator|.
name|p
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PREDEFS_MAX
condition|;
name|i
operator|++
control|)
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|name
argument_list|,
name|predefs
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|len
argument_list|)
operator|&&
literal|'\0'
operator|==
name|predefs
index|[
name|i
index|]
operator|.
name|name
index|[
operator|(
name|int
operator|)
name|len
index|]
condition|)
return|return
name|predefs
index|[
name|i
index|]
operator|.
name|str
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|roff_freestr
parameter_list|(
name|struct
name|roffkv
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|roffkv
modifier|*
name|n
decl_stmt|,
modifier|*
name|nn
decl_stmt|;
for|for
control|(
name|n
operator|=
name|r
init|;
name|n
condition|;
name|n
operator|=
name|nn
control|)
block|{
name|free
argument_list|(
name|n
operator|->
name|key
operator|.
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n
operator|->
name|val
operator|.
name|p
argument_list|)
expr_stmt|;
name|nn
operator|=
name|n
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* --- accessors and utility functions ------------------------------------ */
end_comment

begin_function
specifier|const
name|struct
name|tbl_span
modifier|*
name|roff_span
parameter_list|(
specifier|const
name|struct
name|roff
modifier|*
name|r
parameter_list|)
block|{
return|return
name|r
operator|->
name|tbl
condition|?
name|tbl_span
argument_list|(
name|r
operator|->
name|tbl
argument_list|)
else|:
name|NULL
return|;
block|}
end_function

begin_function
specifier|const
name|struct
name|eqn
modifier|*
name|roff_eqn
parameter_list|(
specifier|const
name|struct
name|roff
modifier|*
name|r
parameter_list|)
block|{
return|return
name|r
operator|->
name|last_eqn
condition|?
operator|&
name|r
operator|->
name|last_eqn
operator|->
name|eqn
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Duplicate an input string, making the appropriate character  * conversations (as stipulated by `tr') along the way.  * Returns a heap-allocated string with all the replacements made.  */
end_comment

begin_function
name|char
modifier|*
name|roff_strdup
parameter_list|(
specifier|const
name|struct
name|roff
modifier|*
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|struct
name|roffkv
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|res
decl_stmt|;
specifier|const
name|char
modifier|*
name|pp
decl_stmt|;
name|size_t
name|ssz
decl_stmt|,
name|sz
decl_stmt|;
name|enum
name|mandoc_esc
name|esc
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|r
operator|->
name|xmbtab
operator|&&
name|NULL
operator|==
name|r
operator|->
name|xtab
condition|)
return|return
name|mandoc_strdup
argument_list|(
name|p
argument_list|)
return|;
elseif|else
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|p
condition|)
return|return
name|mandoc_strdup
argument_list|(
literal|""
argument_list|)
return|;
comment|/* 	 * Step through each character looking for term matches 	 * (remember that a `tr' can be invoked with an escape, which is 	 * a glyph but the escape is multi-character). 	 * We only do this if the character hash has been initialised 	 * and the string is>0 length. 	 */
name|res
operator|=
name|NULL
expr_stmt|;
name|ssz
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|'\0'
operator|!=
operator|*
name|p
condition|)
block|{
if|if
condition|(
literal|'\\'
operator|!=
operator|*
name|p
operator|&&
name|r
operator|->
name|xtab
operator|&&
name|r
operator|->
name|xtab
index|[
operator|(
name|int
operator|)
operator|*
name|p
index|]
operator|.
name|p
condition|)
block|{
name|sz
operator|=
name|r
operator|->
name|xtab
index|[
operator|(
name|int
operator|)
operator|*
name|p
index|]
operator|.
name|sz
expr_stmt|;
name|res
operator|=
name|mandoc_realloc
argument_list|(
name|res
argument_list|,
name|ssz
operator|+
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|res
operator|+
name|ssz
argument_list|,
name|r
operator|->
name|xtab
index|[
operator|(
name|int
operator|)
operator|*
name|p
index|]
operator|.
name|p
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|ssz
operator|+=
name|sz
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
literal|'\\'
operator|!=
operator|*
name|p
condition|)
block|{
name|res
operator|=
name|mandoc_realloc
argument_list|(
name|res
argument_list|,
name|ssz
operator|+
literal|2
argument_list|)
expr_stmt|;
name|res
index|[
name|ssz
operator|++
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Search for term matches. */
for|for
control|(
name|cp
operator|=
name|r
operator|->
name|xmbtab
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|next
control|)
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|p
argument_list|,
name|cp
operator|->
name|key
operator|.
name|p
argument_list|,
name|cp
operator|->
name|key
operator|.
name|sz
argument_list|)
condition|)
break|break;
if|if
condition|(
name|NULL
operator|!=
name|cp
condition|)
block|{
comment|/* 			 * A match has been found. 			 * Append the match to the array and move 			 * forward by its keysize. 			 */
name|res
operator|=
name|mandoc_realloc
argument_list|(
name|res
argument_list|,
name|ssz
operator|+
name|cp
operator|->
name|val
operator|.
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|res
operator|+
name|ssz
argument_list|,
name|cp
operator|->
name|val
operator|.
name|p
argument_list|,
name|cp
operator|->
name|val
operator|.
name|sz
argument_list|)
expr_stmt|;
name|ssz
operator|+=
name|cp
operator|->
name|val
operator|.
name|sz
expr_stmt|;
name|p
operator|+=
operator|(
name|int
operator|)
name|cp
operator|->
name|key
operator|.
name|sz
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Handle escapes carefully: we need to copy 		 * over just the escape itself, or else we might 		 * do replacements within the escape itself. 		 * Make sure to pass along the bogus string. 		 */
name|pp
operator|=
name|p
operator|++
expr_stmt|;
name|esc
operator|=
name|mandoc_escape
argument_list|(
operator|&
name|p
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ESCAPE_ERROR
operator|==
name|esc
condition|)
block|{
name|sz
operator|=
name|strlen
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|res
operator|=
name|mandoc_realloc
argument_list|(
name|res
argument_list|,
name|ssz
operator|+
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|res
operator|+
name|ssz
argument_list|,
name|pp
argument_list|,
name|sz
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * We bail out on bad escapes. 		 * No need to warn: we already did so when 		 * roff_res() was called. 		 */
name|sz
operator|=
call|(
name|int
call|)
argument_list|(
name|p
operator|-
name|pp
argument_list|)
expr_stmt|;
name|res
operator|=
name|mandoc_realloc
argument_list|(
name|res
argument_list|,
name|ssz
operator|+
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|res
operator|+
name|ssz
argument_list|,
name|pp
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|ssz
operator|+=
name|sz
expr_stmt|;
block|}
name|res
index|[
operator|(
name|int
operator|)
name|ssz
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|int
name|roff_getformat
parameter_list|(
specifier|const
name|struct
name|roff
modifier|*
name|r
parameter_list|)
block|{
return|return
name|r
operator|->
name|format
return|;
block|}
end_function

begin_comment
comment|/*  * Find out whether a line is a macro line or not.  * If it is, adjust the current position and return one; if it isn't,  * return zero and don't change the current position.  * If the control character has been set with `.cc', then let that grain  * precedence.  * This is slighly contrary to groff, where using the non-breaking  * control character when `cc' has been invoked will cause the  * non-breaking macro contents to be printed verbatim.  */
end_comment

begin_function
name|int
name|roff_getcontrol
parameter_list|(
specifier|const
name|struct
name|roff
modifier|*
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|cp
parameter_list|,
name|int
modifier|*
name|ppos
parameter_list|)
block|{
name|int
name|pos
decl_stmt|;
name|pos
operator|=
operator|*
name|ppos
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|r
operator|->
name|control
operator|&&
name|cp
index|[
name|pos
index|]
operator|==
name|r
operator|->
name|control
condition|)
name|pos
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|!=
name|r
operator|->
name|control
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
literal|'\\'
operator|==
name|cp
index|[
name|pos
index|]
operator|&&
literal|'.'
operator|==
name|cp
index|[
name|pos
operator|+
literal|1
index|]
condition|)
name|pos
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
literal|'.'
operator|==
name|cp
index|[
name|pos
index|]
operator|||
literal|'\''
operator|==
name|cp
index|[
name|pos
index|]
condition|)
name|pos
operator|++
expr_stmt|;
else|else
return|return
literal|0
return|;
while|while
condition|(
literal|' '
operator|==
name|cp
index|[
name|pos
index|]
operator|||
literal|'\t'
operator|==
name|cp
index|[
name|pos
index|]
condition|)
name|pos
operator|++
expr_stmt|;
operator|*
name|ppos
operator|=
name|pos
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

