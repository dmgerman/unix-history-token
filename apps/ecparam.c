begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* apps/ecparam.c */
end_comment

begin_comment
comment|/*  * Written by Nils Larsch for the OpenSSL project.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1998-2005 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    openssl-core@openssl.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.  *  * Portions of the attached software ("Contribution") are developed by  * SUN MICROSYSTEMS, INC., and are contributed to the OpenSSL project.  *  * The Contribution is licensed pursuant to the OpenSSL open source  * license provided above.  *  * The elliptic curve binary polynomial software is originally written by  * Sheueling Chang Shantz and Douglas Stebila of Sun Microsystems Laboratories.  *  */
end_comment

begin_include
include|#
directive|include
file|<openssl/opensslconf.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPENSSL_NO_EC
end_ifndef

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"apps.h"
end_include

begin_include
include|#
directive|include
file|<openssl/bio.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|<openssl/bn.h>
end_include

begin_include
include|#
directive|include
file|<openssl/ec.h>
end_include

begin_include
include|#
directive|include
file|<openssl/x509.h>
end_include

begin_include
include|#
directive|include
file|<openssl/pem.h>
end_include

begin_undef
undef|#
directive|undef
name|PROG
end_undef

begin_define
define|#
directive|define
name|PROG
value|ecparam_main
end_define

begin_comment
comment|/*-  * -inform arg      - input format - default PEM (DER or PEM)  * -outform arg     - output format - default PEM  * -in  arg         - input file  - default stdin  * -out arg         - output file - default stdout  * -noout           - do not print the ec parameter  * -text            - print the ec parameters in text form  * -check           - validate the ec parameters  * -C               - print a 'C' function creating the parameters  * -name arg        - use the ec parameters with 'short name' name  * -list_curves     - prints a list of all currently available curve 'short names'  * -conv_form arg   - specifies the point conversion form  *                  - possible values: compressed  *                                     uncompressed (default)  *                                     hybrid  * -param_enc arg   - specifies the way the ec parameters are encoded  *                    in the asn1 der encoding  *                    possible values: named_curve (default)  *                                     explicit  * -no_seed         - if 'explicit' parameters are chosen do not use the seed  * -genkey          - generate ec key  * -rand file       - files to use for random number input  * -engine e        - use engine e, possibly a hardware device  */
end_comment

begin_function_decl
specifier|static
name|int
name|ecparam_print_var
parameter_list|(
name|BIO
modifier|*
parameter_list|,
name|BIGNUM
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|MAIN
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|MAIN
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|EC_GROUP
modifier|*
name|group
init|=
name|NULL
decl_stmt|;
name|point_conversion_form_t
name|form
init|=
name|POINT_CONVERSION_UNCOMPRESSED
decl_stmt|;
name|int
name|new_form
init|=
literal|0
decl_stmt|;
name|int
name|asn1_flag
init|=
name|OPENSSL_EC_NAMED_CURVE
decl_stmt|;
name|int
name|new_asn1_flag
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|curve_name
init|=
name|NULL
decl_stmt|,
modifier|*
name|inrand
init|=
name|NULL
decl_stmt|;
name|int
name|list_curves
init|=
literal|0
decl_stmt|,
name|no_seed
init|=
literal|0
decl_stmt|,
name|check
init|=
literal|0
decl_stmt|,
name|badops
init|=
literal|0
decl_stmt|,
name|text
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|need_rand
init|=
literal|0
decl_stmt|,
name|genkey
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|infile
init|=
name|NULL
decl_stmt|,
modifier|*
name|outfile
init|=
name|NULL
decl_stmt|,
modifier|*
name|prog
decl_stmt|;
name|BIO
modifier|*
name|in
init|=
name|NULL
decl_stmt|,
modifier|*
name|out
init|=
name|NULL
decl_stmt|;
name|int
name|informat
decl_stmt|,
name|outformat
decl_stmt|,
name|noout
init|=
literal|0
decl_stmt|,
name|C
init|=
literal|0
decl_stmt|,
name|ret
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|engine
init|=
name|NULL
decl_stmt|;
name|ENGINE
modifier|*
name|e
init|=
name|NULL
decl_stmt|;
name|BIGNUM
modifier|*
name|ec_p
init|=
name|NULL
decl_stmt|,
modifier|*
name|ec_a
init|=
name|NULL
decl_stmt|,
modifier|*
name|ec_b
init|=
name|NULL
decl_stmt|,
modifier|*
name|ec_gen
init|=
name|NULL
decl_stmt|,
modifier|*
name|ec_order
init|=
name|NULL
decl_stmt|,
modifier|*
name|ec_cofactor
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buffer
init|=
name|NULL
decl_stmt|;
name|apps_startup
argument_list|()
expr_stmt|;
if|if
condition|(
name|bio_err
operator|==
name|NULL
condition|)
if|if
condition|(
operator|(
name|bio_err
operator|=
name|BIO_new
argument_list|(
name|BIO_s_file
argument_list|()
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|BIO_set_fp
argument_list|(
name|bio_err
argument_list|,
name|stderr
argument_list|,
name|BIO_NOCLOSE
operator||
name|BIO_FP_TEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|load_config
argument_list|(
name|bio_err
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|end
goto|;
name|informat
operator|=
name|FORMAT_PEM
expr_stmt|;
name|outformat
operator|=
name|FORMAT_PEM
expr_stmt|;
name|prog
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
while|while
condition|(
name|argc
operator|>=
literal|1
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-inform"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|argc
operator|<
literal|1
condition|)
goto|goto
name|bad
goto|;
name|informat
operator|=
name|str2fmt
argument_list|(
operator|*
operator|(
operator|++
name|argv
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-outform"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|argc
operator|<
literal|1
condition|)
goto|goto
name|bad
goto|;
name|outformat
operator|=
name|str2fmt
argument_list|(
operator|*
operator|(
operator|++
name|argv
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-in"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|argc
operator|<
literal|1
condition|)
goto|goto
name|bad
goto|;
name|infile
operator|=
operator|*
operator|(
operator|++
name|argv
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-out"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|argc
operator|<
literal|1
condition|)
goto|goto
name|bad
goto|;
name|outfile
operator|=
operator|*
operator|(
operator|++
name|argv
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-text"
argument_list|)
operator|==
literal|0
condition|)
name|text
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-C"
argument_list|)
operator|==
literal|0
condition|)
name|C
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-check"
argument_list|)
operator|==
literal|0
condition|)
name|check
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-name"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|argc
operator|<
literal|1
condition|)
goto|goto
name|bad
goto|;
name|curve_name
operator|=
operator|*
operator|(
operator|++
name|argv
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-list_curves"
argument_list|)
operator|==
literal|0
condition|)
name|list_curves
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-conv_form"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|argc
operator|<
literal|1
condition|)
goto|goto
name|bad
goto|;
operator|++
name|argv
expr_stmt|;
name|new_form
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"compressed"
argument_list|)
operator|==
literal|0
condition|)
name|form
operator|=
name|POINT_CONVERSION_COMPRESSED
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"uncompressed"
argument_list|)
operator|==
literal|0
condition|)
name|form
operator|=
name|POINT_CONVERSION_UNCOMPRESSED
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"hybrid"
argument_list|)
operator|==
literal|0
condition|)
name|form
operator|=
name|POINT_CONVERSION_HYBRID
expr_stmt|;
else|else
goto|goto
name|bad
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-param_enc"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|argc
operator|<
literal|1
condition|)
goto|goto
name|bad
goto|;
operator|++
name|argv
expr_stmt|;
name|new_asn1_flag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"named_curve"
argument_list|)
operator|==
literal|0
condition|)
name|asn1_flag
operator|=
name|OPENSSL_EC_NAMED_CURVE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"explicit"
argument_list|)
operator|==
literal|0
condition|)
name|asn1_flag
operator|=
literal|0
expr_stmt|;
else|else
goto|goto
name|bad
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-no_seed"
argument_list|)
operator|==
literal|0
condition|)
name|no_seed
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-noout"
argument_list|)
operator|==
literal|0
condition|)
name|noout
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-genkey"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|genkey
operator|=
literal|1
expr_stmt|;
name|need_rand
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-rand"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|argc
operator|<
literal|1
condition|)
goto|goto
name|bad
goto|;
name|inrand
operator|=
operator|*
operator|(
operator|++
name|argv
operator|)
expr_stmt|;
name|need_rand
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-engine"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|argc
operator|<
literal|1
condition|)
goto|goto
name|bad
goto|;
name|engine
operator|=
operator|*
operator|(
operator|++
name|argv
operator|)
expr_stmt|;
block|}
else|else
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"unknown option %s\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|badops
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|badops
condition|)
block|{
name|bad
label|:
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"%s [options]<infile>outfile\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"where options are\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|" -inform arg       input format - "
literal|"default PEM (DER or PEM)\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|" -outform arg      output format - "
literal|"default PEM\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|" -in  arg          input file  - "
literal|"default stdin\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|" -out arg          output file - "
literal|"default stdout\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|" -noout            do not print the "
literal|"ec parameter\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|" -text             print the ec "
literal|"parameters in text form\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|" -check            validate the ec "
literal|"parameters\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|" -C                print a 'C' "
literal|"function creating the parameters\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|" -name arg         use the "
literal|"ec parameters with 'short name' name\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|" -list_curves      prints a list of "
literal|"all currently available curve 'short names'\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|" -conv_form arg    specifies the "
literal|"point conversion form \n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"                   possible values:"
literal|" compressed\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"                                   "
literal|" uncompressed (default)\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"                                   "
literal|" hybrid\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|" -param_enc arg    specifies the way"
literal|" the ec parameters are encoded\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"                   in the asn1 der "
literal|"encoding\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"                   possible values:"
literal|" named_curve (default)\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"                                   "
literal|" explicit\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|" -no_seed          if 'explicit'"
literal|" parameters are chosen do not"
literal|" use the seed\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|" -genkey           generate ec"
literal|" key\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|" -rand file        files to use for"
literal|" random number input\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|" -engine e         use engine e, "
literal|"possibly a hardware device\n"
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|ERR_load_crypto_strings
argument_list|()
expr_stmt|;
name|in
operator|=
name|BIO_new
argument_list|(
name|BIO_s_file
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|=
name|BIO_new
argument_list|(
name|BIO_s_file
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|in
operator|==
name|NULL
operator|)
operator|||
operator|(
name|out
operator|==
name|NULL
operator|)
condition|)
block|{
name|ERR_print_errors
argument_list|(
name|bio_err
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|infile
operator|==
name|NULL
condition|)
name|BIO_set_fp
argument_list|(
name|in
argument_list|,
name|stdin
argument_list|,
name|BIO_NOCLOSE
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|BIO_read_filename
argument_list|(
name|in
argument_list|,
name|infile
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|perror
argument_list|(
name|infile
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
block|}
if|if
condition|(
name|outfile
operator|==
name|NULL
condition|)
block|{
name|BIO_set_fp
argument_list|(
name|out
argument_list|,
name|stdout
argument_list|,
name|BIO_NOCLOSE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL_SYS_VMS
block|{
name|BIO
modifier|*
name|tmpbio
init|=
name|BIO_new
argument_list|(
name|BIO_f_linebuffer
argument_list|()
argument_list|)
decl_stmt|;
name|out
operator|=
name|BIO_push
argument_list|(
name|tmpbio
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|BIO_write_filename
argument_list|(
name|out
argument_list|,
name|outfile
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|perror
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
block|}
name|e
operator|=
name|setup_engine
argument_list|(
name|bio_err
argument_list|,
name|engine
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_curves
condition|)
block|{
name|EC_builtin_curve
modifier|*
name|curves
init|=
name|NULL
decl_stmt|;
name|size_t
name|crv_len
init|=
literal|0
decl_stmt|;
name|size_t
name|n
init|=
literal|0
decl_stmt|;
name|crv_len
operator|=
name|EC_get_builtin_curves
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|curves
operator|=
name|OPENSSL_malloc
argument_list|(
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|EC_builtin_curve
argument_list|)
operator|*
name|crv_len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|curves
operator|==
name|NULL
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|EC_get_builtin_curves
argument_list|(
name|curves
argument_list|,
name|crv_len
argument_list|)
condition|)
block|{
name|OPENSSL_free
argument_list|(
name|curves
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|crv_len
condition|;
name|n
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|comment
decl_stmt|;
specifier|const
name|char
modifier|*
name|sname
decl_stmt|;
name|comment
operator|=
name|curves
index|[
name|n
index|]
operator|.
name|comment
expr_stmt|;
name|sname
operator|=
name|OBJ_nid2sn
argument_list|(
name|curves
index|[
name|n
index|]
operator|.
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|comment
operator|==
name|NULL
condition|)
name|comment
operator|=
literal|"CURVE DESCRIPTION NOT AVAILABLE"
expr_stmt|;
if|if
condition|(
name|sname
operator|==
name|NULL
condition|)
name|sname
operator|=
literal|""
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"  %-10s: "
argument_list|,
name|sname
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"%s\n"
argument_list|,
name|comment
argument_list|)
expr_stmt|;
block|}
name|OPENSSL_free
argument_list|(
name|curves
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|curve_name
operator|!=
name|NULL
condition|)
block|{
name|int
name|nid
decl_stmt|;
comment|/*          * workaround for the SECG curve names secp192r1 and secp256r1 (which          * are the same as the curves prime192v1 and prime256v1 defined in          * X9.62)          */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|curve_name
argument_list|,
literal|"secp192r1"
argument_list|)
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"using curve name prime192v1 "
literal|"instead of secp192r1\n"
argument_list|)
expr_stmt|;
name|nid
operator|=
name|NID_X9_62_prime192v1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|curve_name
argument_list|,
literal|"secp256r1"
argument_list|)
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"using curve name prime256v1 "
literal|"instead of secp256r1\n"
argument_list|)
expr_stmt|;
name|nid
operator|=
name|NID_X9_62_prime256v1
expr_stmt|;
block|}
else|else
name|nid
operator|=
name|OBJ_sn2nid
argument_list|(
name|curve_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nid
operator|==
literal|0
condition|)
name|nid
operator|=
name|EC_curve_nist2nid
argument_list|(
name|curve_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nid
operator|==
literal|0
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"unknown curve name (%s)\n"
argument_list|,
name|curve_name
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|group
operator|=
name|EC_GROUP_new_by_curve_name
argument_list|(
name|nid
argument_list|)
expr_stmt|;
if|if
condition|(
name|group
operator|==
name|NULL
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"unable to create curve (%s)\n"
argument_list|,
name|curve_name
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|EC_GROUP_set_asn1_flag
argument_list|(
name|group
argument_list|,
name|asn1_flag
argument_list|)
expr_stmt|;
name|EC_GROUP_set_point_conversion_form
argument_list|(
name|group
argument_list|,
name|form
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|informat
operator|==
name|FORMAT_ASN1
condition|)
block|{
name|group
operator|=
name|d2i_ECPKParameters_bio
argument_list|(
name|in
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|informat
operator|==
name|FORMAT_PEM
condition|)
block|{
name|group
operator|=
name|PEM_read_bio_ECPKParameters
argument_list|(
name|in
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"bad input format specified\n"
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|group
operator|==
name|NULL
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"unable to load elliptic curve parameters\n"
argument_list|)
expr_stmt|;
name|ERR_print_errors
argument_list|(
name|bio_err
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|new_form
condition|)
name|EC_GROUP_set_point_conversion_form
argument_list|(
name|group
argument_list|,
name|form
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_asn1_flag
condition|)
name|EC_GROUP_set_asn1_flag
argument_list|(
name|group
argument_list|,
name|asn1_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_seed
condition|)
block|{
name|EC_GROUP_set_seed
argument_list|(
name|group
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|text
condition|)
block|{
if|if
condition|(
operator|!
name|ECPKParameters_print
argument_list|(
name|out
argument_list|,
name|group
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|check
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"checking elliptic curve parameters: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EC_GROUP_check
argument_list|(
name|group
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"failed\n"
argument_list|)
expr_stmt|;
name|ERR_print_errors
argument_list|(
name|bio_err
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"ok\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|C
condition|)
block|{
name|size_t
name|buf_len
init|=
literal|0
decl_stmt|,
name|tmp_len
init|=
literal|0
decl_stmt|;
specifier|const
name|EC_POINT
modifier|*
name|point
decl_stmt|;
name|int
name|is_prime
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|;
specifier|const
name|EC_METHOD
modifier|*
name|meth
init|=
name|EC_GROUP_method_of
argument_list|(
name|group
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ec_p
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|ec_a
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|ec_b
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|ec_gen
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|ec_order
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|(
name|ec_cofactor
operator|=
name|BN_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"OPENSSL_malloc"
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|is_prime
operator|=
operator|(
name|EC_METHOD_get_field_type
argument_list|(
name|meth
argument_list|)
operator|==
name|NID_X9_62_prime_field
operator|)
expr_stmt|;
if|if
condition|(
name|is_prime
condition|)
block|{
if|if
condition|(
operator|!
name|EC_GROUP_get_curve_GFp
argument_list|(
name|group
argument_list|,
name|ec_p
argument_list|,
name|ec_a
argument_list|,
name|ec_b
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|end
goto|;
block|}
else|else
block|{
comment|/* TODO */
goto|goto
name|end
goto|;
block|}
if|if
condition|(
operator|(
name|point
operator|=
name|EC_GROUP_get0_generator
argument_list|(
name|group
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|EC_POINT_point2bn
argument_list|(
name|group
argument_list|,
name|point
argument_list|,
name|EC_GROUP_get_point_conversion_form
argument_list|(
name|group
argument_list|)
argument_list|,
name|ec_gen
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|EC_GROUP_get_order
argument_list|(
name|group
argument_list|,
name|ec_order
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|EC_GROUP_get_cofactor
argument_list|(
name|group
argument_list|,
name|ec_cofactor
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|ec_p
operator|||
operator|!
name|ec_a
operator|||
operator|!
name|ec_b
operator|||
operator|!
name|ec_gen
operator|||
operator|!
name|ec_order
operator|||
operator|!
name|ec_cofactor
condition|)
goto|goto
name|end
goto|;
name|len
operator|=
name|BN_num_bits
argument_list|(
name|ec_order
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp_len
operator|=
operator|(
name|size_t
operator|)
name|BN_num_bytes
argument_list|(
name|ec_p
argument_list|)
operator|)
operator|>
name|buf_len
condition|)
name|buf_len
operator|=
name|tmp_len
expr_stmt|;
if|if
condition|(
operator|(
name|tmp_len
operator|=
operator|(
name|size_t
operator|)
name|BN_num_bytes
argument_list|(
name|ec_a
argument_list|)
operator|)
operator|>
name|buf_len
condition|)
name|buf_len
operator|=
name|tmp_len
expr_stmt|;
if|if
condition|(
operator|(
name|tmp_len
operator|=
operator|(
name|size_t
operator|)
name|BN_num_bytes
argument_list|(
name|ec_b
argument_list|)
operator|)
operator|>
name|buf_len
condition|)
name|buf_len
operator|=
name|tmp_len
expr_stmt|;
if|if
condition|(
operator|(
name|tmp_len
operator|=
operator|(
name|size_t
operator|)
name|BN_num_bytes
argument_list|(
name|ec_gen
argument_list|)
operator|)
operator|>
name|buf_len
condition|)
name|buf_len
operator|=
name|tmp_len
expr_stmt|;
if|if
condition|(
operator|(
name|tmp_len
operator|=
operator|(
name|size_t
operator|)
name|BN_num_bytes
argument_list|(
name|ec_order
argument_list|)
operator|)
operator|>
name|buf_len
condition|)
name|buf_len
operator|=
name|tmp_len
expr_stmt|;
if|if
condition|(
operator|(
name|tmp_len
operator|=
operator|(
name|size_t
operator|)
name|BN_num_bytes
argument_list|(
name|ec_cofactor
argument_list|)
operator|)
operator|>
name|buf_len
condition|)
name|buf_len
operator|=
name|tmp_len
expr_stmt|;
name|buffer
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|OPENSSL_malloc
argument_list|(
name|buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"OPENSSL_malloc"
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|ecparam_print_var
argument_list|(
name|out
argument_list|,
name|ec_p
argument_list|,
literal|"ec_p"
argument_list|,
name|len
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|ecparam_print_var
argument_list|(
name|out
argument_list|,
name|ec_a
argument_list|,
literal|"ec_a"
argument_list|,
name|len
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|ecparam_print_var
argument_list|(
name|out
argument_list|,
name|ec_b
argument_list|,
literal|"ec_b"
argument_list|,
name|len
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|ecparam_print_var
argument_list|(
name|out
argument_list|,
name|ec_gen
argument_list|,
literal|"ec_gen"
argument_list|,
name|len
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|ecparam_print_var
argument_list|(
name|out
argument_list|,
name|ec_order
argument_list|,
literal|"ec_order"
argument_list|,
name|len
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|ecparam_print_var
argument_list|(
name|out
argument_list|,
name|ec_cofactor
argument_list|,
literal|"ec_cofactor"
argument_list|,
name|len
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"EC_GROUP *get_ec_group_%d(void)\n\t{\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\tint ok=0;\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\tEC_GROUP *group = NULL;\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\tEC_POINT *point = NULL;\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\tBIGNUM   *tmp_1 = NULL, *tmp_2 = NULL, "
literal|"*tmp_3 = NULL;\n\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\tif ((tmp_1 = BN_bin2bn(ec_p_%d, "
literal|"sizeof(ec_p_%d), NULL)) == NULL)\n\t\t"
literal|"goto err;\n"
argument_list|,
name|len
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\tif ((tmp_2 = BN_bin2bn(ec_a_%d, "
literal|"sizeof(ec_a_%d), NULL)) == NULL)\n\t\t"
literal|"goto err;\n"
argument_list|,
name|len
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\tif ((tmp_3 = BN_bin2bn(ec_b_%d, "
literal|"sizeof(ec_b_%d), NULL)) == NULL)\n\t\t"
literal|"goto err;\n"
argument_list|,
name|len
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_prime
condition|)
block|{
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\tif ((group = EC_GROUP_new_curve_"
literal|"GFp(tmp_1, tmp_2, tmp_3, NULL)) == NULL)"
literal|"\n\t\tgoto err;\n\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* TODO */
goto|goto
name|end
goto|;
block|}
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\t/* build generator */\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\tif ((tmp_1 = BN_bin2bn(ec_gen_%d, "
literal|"sizeof(ec_gen_%d), tmp_1)) == NULL)"
literal|"\n\t\tgoto err;\n"
argument_list|,
name|len
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\tpoint = EC_POINT_bn2point(group, tmp_1, "
literal|"NULL, NULL);\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\tif (point == NULL)\n\t\tgoto err;\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\tif ((tmp_2 = BN_bin2bn(ec_order_%d, "
literal|"sizeof(ec_order_%d), tmp_2)) == NULL)"
literal|"\n\t\tgoto err;\n"
argument_list|,
name|len
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\tif ((tmp_3 = BN_bin2bn(ec_cofactor_%d, "
literal|"sizeof(ec_cofactor_%d), tmp_3)) == NULL)"
literal|"\n\t\tgoto err;\n"
argument_list|,
name|len
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\tif (!EC_GROUP_set_generator(group, point,"
literal|" tmp_2, tmp_3))\n\t\tgoto err;\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\n\tok=1;\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"err:\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\tif (tmp_1)\n\t\tBN_free(tmp_1);\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\tif (tmp_2)\n\t\tBN_free(tmp_2);\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\tif (tmp_3)\n\t\tBN_free(tmp_3);\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\tif (point)\n\t\tEC_POINT_free(point);\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\tif (!ok)\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\t\t{\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\t\tEC_GROUP_free(group);\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\t\tgroup = NULL;\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\t\t}\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\treturn(group);\n\t}\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|noout
condition|)
block|{
if|if
condition|(
name|outformat
operator|==
name|FORMAT_ASN1
condition|)
name|i
operator|=
name|i2d_ECPKParameters_bio
argument_list|(
name|out
argument_list|,
name|group
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|outformat
operator|==
name|FORMAT_PEM
condition|)
name|i
operator|=
name|PEM_write_bio_ECPKParameters
argument_list|(
name|out
argument_list|,
name|group
argument_list|)
expr_stmt|;
else|else
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"bad output format specified for"
literal|" outfile\n"
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"unable to write elliptic "
literal|"curve parameters\n"
argument_list|)
expr_stmt|;
name|ERR_print_errors
argument_list|(
name|bio_err
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
block|}
if|if
condition|(
name|need_rand
condition|)
block|{
name|app_RAND_load_file
argument_list|(
name|NULL
argument_list|,
name|bio_err
argument_list|,
operator|(
name|inrand
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inrand
operator|!=
name|NULL
condition|)
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"%ld semi-random bytes loaded\n"
argument_list|,
name|app_RAND_load_files
argument_list|(
name|inrand
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|genkey
condition|)
block|{
name|EC_KEY
modifier|*
name|eckey
init|=
name|EC_KEY_new
argument_list|()
decl_stmt|;
if|if
condition|(
name|eckey
operator|==
name|NULL
condition|)
goto|goto
name|end
goto|;
name|assert
argument_list|(
name|need_rand
argument_list|)
expr_stmt|;
if|if
condition|(
name|EC_KEY_set_group
argument_list|(
name|eckey
argument_list|,
name|group
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|EC_KEY_generate_key
argument_list|(
name|eckey
argument_list|)
condition|)
block|{
name|EC_KEY_free
argument_list|(
name|eckey
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|outformat
operator|==
name|FORMAT_ASN1
condition|)
name|i
operator|=
name|i2d_ECPrivateKey_bio
argument_list|(
name|out
argument_list|,
name|eckey
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|outformat
operator|==
name|FORMAT_PEM
condition|)
name|i
operator|=
name|PEM_write_bio_ECPrivateKey
argument_list|(
name|out
argument_list|,
name|eckey
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"bad output format specified "
literal|"for outfile\n"
argument_list|)
expr_stmt|;
name|EC_KEY_free
argument_list|(
name|eckey
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|EC_KEY_free
argument_list|(
name|eckey
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_rand
condition|)
name|app_RAND_write_file
argument_list|(
name|NULL
argument_list|,
name|bio_err
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|end
label|:
if|if
condition|(
name|ec_p
condition|)
name|BN_free
argument_list|(
name|ec_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ec_a
condition|)
name|BN_free
argument_list|(
name|ec_a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ec_b
condition|)
name|BN_free
argument_list|(
name|ec_b
argument_list|)
expr_stmt|;
if|if
condition|(
name|ec_gen
condition|)
name|BN_free
argument_list|(
name|ec_gen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ec_order
condition|)
name|BN_free
argument_list|(
name|ec_order
argument_list|)
expr_stmt|;
if|if
condition|(
name|ec_cofactor
condition|)
name|BN_free
argument_list|(
name|ec_cofactor
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
condition|)
name|OPENSSL_free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|group
operator|!=
name|NULL
condition|)
name|EC_GROUP_free
argument_list|(
name|group
argument_list|)
expr_stmt|;
name|release_engine
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|!=
name|NULL
condition|)
name|BIO_free
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|!=
name|NULL
condition|)
name|BIO_free_all
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|apps_shutdown
argument_list|()
expr_stmt|;
name|OPENSSL_EXIT
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecparam_print_var
parameter_list|(
name|BIO
modifier|*
name|out
parameter_list|,
name|BIGNUM
modifier|*
name|in
parameter_list|,
specifier|const
name|char
modifier|*
name|var
parameter_list|,
name|int
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"static unsigned char %s_%d[] = {"
argument_list|,
name|var
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_is_zero
argument_list|(
name|in
argument_list|)
condition|)
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\n\t0x00"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
name|l
operator|=
name|BN_bn2bin
argument_list|(
name|in
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|%
literal|12
operator|)
operator|==
literal|0
condition|)
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"0x%02X,"
argument_list|,
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|%
literal|12
operator|)
operator|==
literal|0
condition|)
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"0x%02X"
argument_list|,
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\n\t};\n\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !OPENSSL_NO_EC */
end_comment

begin_if
if|#
directive|if
name|PEDANTIC
end_if

begin_decl_stmt
specifier|static
name|void
modifier|*
name|dummy
init|=
operator|&
name|dummy
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

