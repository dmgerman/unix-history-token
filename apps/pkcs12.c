begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* pkcs12.c */
end_comment

begin_comment
comment|/*  * Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL  * project.  */
end_comment

begin_comment
comment|/* ====================================================================  * Copyright (c) 1999-2006 The OpenSSL Project.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * 3. All advertising materials mentioning features or use of this  *    software must display the following acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"  *  * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to  *    endorse or promote products derived from this software without  *    prior written permission. For written permission, please contact  *    licensing@OpenSSL.org.  *  * 5. Products derived from this software may not be called "OpenSSL"  *    nor may "OpenSSL" appear in their names without prior written  *    permission of the OpenSSL Project.  *  * 6. Redistributions of any form whatsoever must retain the following  *    acknowledgment:  *    "This product includes software developed by the OpenSSL Project  *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"  *  * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR  * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  * ====================================================================  *  * This product includes cryptographic software written by Eric Young  * (eay@cryptsoft.com).  This product includes software written by Tim  * Hudson (tjh@cryptsoft.com).  *  */
end_comment

begin_include
include|#
directive|include
file|<openssl/opensslconf.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OPENSSL_NO_DES
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OPENSSL_NO_SHA1
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"apps.h"
end_include

begin_include
include|#
directive|include
file|<openssl/crypto.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|<openssl/pem.h>
end_include

begin_include
include|#
directive|include
file|<openssl/pkcs12.h>
end_include

begin_define
define|#
directive|define
name|PROG
value|pkcs12_main
end_define

begin_decl_stmt
specifier|const
name|EVP_CIPHER
modifier|*
name|enc
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NOKEYS
value|0x1
end_define

begin_define
define|#
directive|define
name|NOCERTS
value|0x2
end_define

begin_define
define|#
directive|define
name|INFO
value|0x4
end_define

begin_define
define|#
directive|define
name|CLCERTS
value|0x8
end_define

begin_define
define|#
directive|define
name|CACERTS
value|0x10
end_define

begin_decl_stmt
specifier|static
name|int
name|get_cert_chain
argument_list|(
name|X509
operator|*
name|cert
argument_list|,
name|X509_STORE
operator|*
name|store
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
operator|*
name|chain
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|dump_certs_keys_p12
parameter_list|(
name|BIO
modifier|*
name|out
parameter_list|,
name|PKCS12
modifier|*
name|p12
parameter_list|,
name|char
modifier|*
name|pass
parameter_list|,
name|int
name|passlen
parameter_list|,
name|int
name|options
parameter_list|,
name|char
modifier|*
name|pempass
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|dump_certs_pkeys_bags
argument_list|(
name|BIO
operator|*
name|out
argument_list|,
name|STACK_OF
argument_list|(
name|PKCS12_SAFEBAG
argument_list|)
operator|*
name|bags
argument_list|,
name|char
operator|*
name|pass
argument_list|,
name|int
name|passlen
argument_list|,
name|int
name|options
argument_list|,
name|char
operator|*
name|pempass
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|dump_certs_pkeys_bag
parameter_list|(
name|BIO
modifier|*
name|out
parameter_list|,
name|PKCS12_SAFEBAG
modifier|*
name|bags
parameter_list|,
name|char
modifier|*
name|pass
parameter_list|,
name|int
name|passlen
parameter_list|,
name|int
name|options
parameter_list|,
name|char
modifier|*
name|pempass
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|print_attribs
argument_list|(
name|BIO
operator|*
name|out
argument_list|,
name|STACK_OF
argument_list|(
name|X509_ATTRIBUTE
argument_list|)
operator|*
name|attrlst
argument_list|,
specifier|const
name|char
operator|*
name|name
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|hex_prin
parameter_list|(
name|BIO
modifier|*
name|out
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|alg_print
parameter_list|(
name|BIO
modifier|*
name|x
parameter_list|,
name|X509_ALGOR
modifier|*
name|alg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|cert_load
argument_list|(
name|BIO
operator|*
name|in
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|sk
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|set_pbe
parameter_list|(
name|BIO
modifier|*
name|err
parameter_list|,
name|int
modifier|*
name|ppbe
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|MAIN
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|MAIN
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|ENGINE
modifier|*
name|e
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|infile
init|=
name|NULL
decl_stmt|,
modifier|*
name|outfile
init|=
name|NULL
decl_stmt|,
modifier|*
name|keyname
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|certfile
init|=
name|NULL
decl_stmt|;
name|BIO
modifier|*
name|in
init|=
name|NULL
decl_stmt|,
modifier|*
name|out
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|csp_name
init|=
name|NULL
decl_stmt|;
name|int
name|add_lmk
init|=
literal|0
decl_stmt|;
name|PKCS12
modifier|*
name|p12
init|=
name|NULL
decl_stmt|;
name|char
name|pass
index|[
literal|50
index|]
decl_stmt|,
name|macpass
index|[
literal|50
index|]
decl_stmt|;
name|int
name|export_cert
init|=
literal|0
decl_stmt|;
name|int
name|options
init|=
literal|0
decl_stmt|;
name|int
name|chain
init|=
literal|0
decl_stmt|;
name|int
name|badarg
init|=
literal|0
decl_stmt|;
name|int
name|iter
init|=
name|PKCS12_DEFAULT_ITER
decl_stmt|;
name|int
name|maciter
init|=
name|PKCS12_DEFAULT_ITER
decl_stmt|;
name|int
name|twopass
init|=
literal|0
decl_stmt|;
name|int
name|keytype
init|=
literal|0
decl_stmt|;
name|int
name|cert_pbe
decl_stmt|;
name|int
name|key_pbe
init|=
name|NID_pbe_WithSHA1And3_Key_TripleDES_CBC
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|int
name|macver
init|=
literal|1
decl_stmt|;
name|int
name|noprompt
init|=
literal|0
decl_stmt|;
name|STACK_OF
argument_list|(
name|OPENSSL_STRING
argument_list|)
operator|*
name|canames
operator|=
name|NULL
expr_stmt|;
name|char
modifier|*
name|cpass
init|=
name|NULL
decl_stmt|,
modifier|*
name|mpass
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|passargin
init|=
name|NULL
decl_stmt|,
modifier|*
name|passargout
init|=
name|NULL
decl_stmt|,
modifier|*
name|passarg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|passin
init|=
name|NULL
decl_stmt|,
modifier|*
name|passout
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|inrand
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|macalg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|CApath
init|=
name|NULL
decl_stmt|,
modifier|*
name|CAfile
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|engine
init|=
name|NULL
decl_stmt|;
name|apps_startup
argument_list|()
expr_stmt|;
name|enc
operator|=
name|EVP_des_ede3_cbc
argument_list|()
expr_stmt|;
if|if
condition|(
name|bio_err
operator|==
name|NULL
condition|)
name|bio_err
operator|=
name|BIO_new_fp
argument_list|(
name|stderr
argument_list|,
name|BIO_NOCLOSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|load_config
argument_list|(
name|bio_err
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|end
goto|;
ifdef|#
directive|ifdef
name|OPENSSL_FIPS
if|if
condition|(
name|FIPS_mode
argument_list|()
condition|)
name|cert_pbe
operator|=
name|NID_pbe_WithSHA1And3_Key_TripleDES_CBC
expr_stmt|;
else|else
endif|#
directive|endif
name|cert_pbe
operator|=
name|NID_pbe_WithSHA1And40BitRC2_CBC
expr_stmt|;
name|args
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|args
condition|)
block|{
if|if
condition|(
operator|*
name|args
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-nokeys"
argument_list|)
condition|)
name|options
operator||=
name|NOKEYS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-keyex"
argument_list|)
condition|)
name|keytype
operator|=
name|KEY_EX
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-keysig"
argument_list|)
condition|)
name|keytype
operator|=
name|KEY_SIG
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-nocerts"
argument_list|)
condition|)
name|options
operator||=
name|NOCERTS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-clcerts"
argument_list|)
condition|)
name|options
operator||=
name|CLCERTS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-cacerts"
argument_list|)
condition|)
name|options
operator||=
name|CACERTS
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-noout"
argument_list|)
condition|)
name|options
operator||=
operator|(
name|NOKEYS
operator||
name|NOCERTS
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-info"
argument_list|)
condition|)
name|options
operator||=
name|INFO
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-chain"
argument_list|)
condition|)
name|chain
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-twopass"
argument_list|)
condition|)
name|twopass
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-nomacver"
argument_list|)
condition|)
name|macver
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-descert"
argument_list|)
condition|)
name|cert_pbe
operator|=
name|NID_pbe_WithSHA1And3_Key_TripleDES_CBC
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-export"
argument_list|)
condition|)
name|export_cert
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-des"
argument_list|)
condition|)
name|enc
operator|=
name|EVP_des_cbc
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-des3"
argument_list|)
condition|)
name|enc
operator|=
name|EVP_des_ede3_cbc
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_IDEA
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-idea"
argument_list|)
condition|)
name|enc
operator|=
name|EVP_idea_cbc
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SEED
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-seed"
argument_list|)
condition|)
name|enc
operator|=
name|EVP_seed_cbc
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_AES
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-aes128"
argument_list|)
condition|)
name|enc
operator|=
name|EVP_aes_128_cbc
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-aes192"
argument_list|)
condition|)
name|enc
operator|=
name|EVP_aes_192_cbc
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-aes256"
argument_list|)
condition|)
name|enc
operator|=
name|EVP_aes_256_cbc
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_CAMELLIA
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-camellia128"
argument_list|)
condition|)
name|enc
operator|=
name|EVP_camellia_128_cbc
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-camellia192"
argument_list|)
condition|)
name|enc
operator|=
name|EVP_camellia_192_cbc
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-camellia256"
argument_list|)
condition|)
name|enc
operator|=
name|EVP_camellia_256_cbc
argument_list|()
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-noiter"
argument_list|)
condition|)
name|iter
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-maciter"
argument_list|)
condition|)
name|maciter
operator|=
name|PKCS12_DEFAULT_ITER
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-nomaciter"
argument_list|)
condition|)
name|maciter
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-nomac"
argument_list|)
condition|)
name|maciter
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-macalg"
argument_list|)
condition|)
if|if
condition|(
name|args
index|[
literal|1
index|]
condition|)
block|{
name|args
operator|++
expr_stmt|;
name|macalg
operator|=
operator|*
name|args
expr_stmt|;
block|}
else|else
name|badarg
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-nodes"
argument_list|)
condition|)
name|enc
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-certpbe"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|set_pbe
argument_list|(
name|bio_err
argument_list|,
operator|&
name|cert_pbe
argument_list|,
operator|*
operator|++
name|args
argument_list|)
condition|)
name|badarg
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-keypbe"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|set_pbe
argument_list|(
name|bio_err
argument_list|,
operator|&
name|key_pbe
argument_list|,
operator|*
operator|++
name|args
argument_list|)
condition|)
name|badarg
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-rand"
argument_list|)
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|1
index|]
condition|)
block|{
name|args
operator|++
expr_stmt|;
name|inrand
operator|=
operator|*
name|args
expr_stmt|;
block|}
else|else
name|badarg
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-inkey"
argument_list|)
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|1
index|]
condition|)
block|{
name|args
operator|++
expr_stmt|;
name|keyname
operator|=
operator|*
name|args
expr_stmt|;
block|}
else|else
name|badarg
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-certfile"
argument_list|)
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|1
index|]
condition|)
block|{
name|args
operator|++
expr_stmt|;
name|certfile
operator|=
operator|*
name|args
expr_stmt|;
block|}
else|else
name|badarg
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-name"
argument_list|)
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|1
index|]
condition|)
block|{
name|args
operator|++
expr_stmt|;
name|name
operator|=
operator|*
name|args
expr_stmt|;
block|}
else|else
name|badarg
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-LMK"
argument_list|)
condition|)
name|add_lmk
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-CSP"
argument_list|)
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|1
index|]
condition|)
block|{
name|args
operator|++
expr_stmt|;
name|csp_name
operator|=
operator|*
name|args
expr_stmt|;
block|}
else|else
name|badarg
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-caname"
argument_list|)
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|1
index|]
condition|)
block|{
name|args
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|canames
condition|)
name|canames
operator|=
name|sk_OPENSSL_STRING_new_null
argument_list|()
expr_stmt|;
name|sk_OPENSSL_STRING_push
argument_list|(
name|canames
argument_list|,
operator|*
name|args
argument_list|)
expr_stmt|;
block|}
else|else
name|badarg
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-in"
argument_list|)
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|1
index|]
condition|)
block|{
name|args
operator|++
expr_stmt|;
name|infile
operator|=
operator|*
name|args
expr_stmt|;
block|}
else|else
name|badarg
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-out"
argument_list|)
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|1
index|]
condition|)
block|{
name|args
operator|++
expr_stmt|;
name|outfile
operator|=
operator|*
name|args
expr_stmt|;
block|}
else|else
name|badarg
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-passin"
argument_list|)
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|1
index|]
condition|)
block|{
name|args
operator|++
expr_stmt|;
name|passargin
operator|=
operator|*
name|args
expr_stmt|;
block|}
else|else
name|badarg
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-passout"
argument_list|)
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|1
index|]
condition|)
block|{
name|args
operator|++
expr_stmt|;
name|passargout
operator|=
operator|*
name|args
expr_stmt|;
block|}
else|else
name|badarg
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-password"
argument_list|)
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|1
index|]
condition|)
block|{
name|args
operator|++
expr_stmt|;
name|passarg
operator|=
operator|*
name|args
expr_stmt|;
name|noprompt
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|badarg
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-CApath"
argument_list|)
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|1
index|]
condition|)
block|{
name|args
operator|++
expr_stmt|;
name|CApath
operator|=
operator|*
name|args
expr_stmt|;
block|}
else|else
name|badarg
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-CAfile"
argument_list|)
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|1
index|]
condition|)
block|{
name|args
operator|++
expr_stmt|;
name|CAfile
operator|=
operator|*
name|args
expr_stmt|;
block|}
else|else
name|badarg
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_ENGINE
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
literal|"-engine"
argument_list|)
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|1
index|]
condition|)
block|{
name|args
operator|++
expr_stmt|;
name|engine
operator|=
operator|*
name|args
expr_stmt|;
block|}
else|else
name|badarg
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|badarg
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|badarg
operator|=
literal|1
expr_stmt|;
name|args
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|badarg
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"Usage: pkcs12 [options]\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"where options are\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-export       output PKCS12 file\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-chain        add certificate chain\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-inkey file   private key if not infile\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-certfile f   add all certs in f\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-CApath arg   - PEM format directory of CA's\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-CAfile arg   - PEM format file of CA's\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-name \"name\"  use name as friendly name\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-caname \"nm\"  use nm as CA friendly name (can be used more than once).\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-in  infile   input filename\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-out outfile  output filename\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-noout        don't output anything, just verify.\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-nomacver     don't verify MAC.\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-nocerts      don't output certificates.\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-clcerts      only output client certificates.\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-cacerts      only output CA certificates.\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-nokeys       don't output private keys.\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-info         give info about PKCS#12 structure.\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-des          encrypt private keys with DES\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-des3         encrypt private keys with triple DES (default)\n"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_IDEA
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-idea         encrypt private keys with idea\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_SEED
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-seed         encrypt private keys with seed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_AES
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-aes128, -aes192, -aes256\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"              encrypt PEM output with cbc aes\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OPENSSL_NO_CAMELLIA
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-camellia128, -camellia192, -camellia256\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"              encrypt PEM output with cbc camellia\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-nodes        don't encrypt private keys\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-noiter       don't use encryption iteration\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-nomaciter    don't use MAC iteration\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-maciter      use MAC iteration\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-nomac        don't generate MAC\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-twopass      separate MAC, encryption passwords\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-descert      encrypt PKCS#12 certificates with triple DES (default RC2-40)\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-certpbe alg  specify certificate PBE algorithm (default RC2-40)\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-keypbe alg   specify private key PBE algorithm (default 3DES)\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-macalg alg   digest algorithm used in MAC (default SHA1)\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-keyex        set MS key exchange type\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-keysig       set MS key signature type\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-password p   set import/export password source\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-passin p     input file pass phrase source\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-passout p    output file pass phrase source\n"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OPENSSL_NO_ENGINE
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-engine e     use engine e, possibly a hardware device.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-rand file%cfile%c...\n"
argument_list|,
name|LIST_SEPARATOR_CHAR
argument_list|,
name|LIST_SEPARATOR_CHAR
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"              load the file (or the files in the directory) into\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"              the random number generator\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-CSP name     Microsoft CSP name\n"
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"-LMK          Add local machine keyset attribute to private key\n"
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|e
operator|=
name|setup_engine
argument_list|(
name|bio_err
argument_list|,
name|engine
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|passarg
condition|)
block|{
if|if
condition|(
name|export_cert
condition|)
name|passargout
operator|=
name|passarg
expr_stmt|;
else|else
name|passargin
operator|=
name|passarg
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|app_passwd
argument_list|(
name|bio_err
argument_list|,
name|passargin
argument_list|,
name|passargout
argument_list|,
operator|&
name|passin
argument_list|,
operator|&
name|passout
argument_list|)
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"Error getting passwords\n"
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
operator|!
name|cpass
condition|)
block|{
if|if
condition|(
name|export_cert
condition|)
name|cpass
operator|=
name|passout
expr_stmt|;
else|else
name|cpass
operator|=
name|passin
expr_stmt|;
block|}
if|if
condition|(
name|cpass
condition|)
block|{
name|mpass
operator|=
name|cpass
expr_stmt|;
name|noprompt
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cpass
operator|=
name|pass
expr_stmt|;
name|mpass
operator|=
name|macpass
expr_stmt|;
block|}
if|if
condition|(
name|export_cert
operator|||
name|inrand
condition|)
block|{
name|app_RAND_load_file
argument_list|(
name|NULL
argument_list|,
name|bio_err
argument_list|,
operator|(
name|inrand
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inrand
operator|!=
name|NULL
condition|)
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"%ld semi-random bytes loaded\n"
argument_list|,
name|app_RAND_load_files
argument_list|(
name|inrand
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ERR_load_crypto_strings
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CRYPTO_MDEBUG
name|CRYPTO_push_info
argument_list|(
literal|"read files"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|infile
condition|)
name|in
operator|=
name|BIO_new_fp
argument_list|(
name|stdin
argument_list|,
name|BIO_NOCLOSE
argument_list|)
expr_stmt|;
else|else
name|in
operator|=
name|BIO_new_file
argument_list|(
name|infile
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"Error opening input file %s\n"
argument_list|,
name|infile
condition|?
name|infile
else|:
literal|"<stdin>"
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|infile
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
ifdef|#
directive|ifdef
name|CRYPTO_MDEBUG
name|CRYPTO_pop_info
argument_list|()
expr_stmt|;
name|CRYPTO_push_info
argument_list|(
literal|"write files"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|outfile
condition|)
block|{
name|out
operator|=
name|BIO_new_fp
argument_list|(
name|stdout
argument_list|,
name|BIO_NOCLOSE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OPENSSL_SYS_VMS
block|{
name|BIO
modifier|*
name|tmpbio
init|=
name|BIO_new
argument_list|(
name|BIO_f_linebuffer
argument_list|()
argument_list|)
decl_stmt|;
name|out
operator|=
name|BIO_push
argument_list|(
name|tmpbio
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
name|out
operator|=
name|BIO_new_file
argument_list|(
name|outfile
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|out
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"Error opening output file %s\n"
argument_list|,
name|outfile
condition|?
name|outfile
else|:
literal|"<stdout>"
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|twopass
condition|)
block|{
ifdef|#
directive|ifdef
name|CRYPTO_MDEBUG
name|CRYPTO_push_info
argument_list|(
literal|"read MAC password"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|EVP_read_pw_string
argument_list|(
name|macpass
argument_list|,
sizeof|sizeof
name|macpass
argument_list|,
literal|"Enter MAC Password:"
argument_list|,
name|export_cert
argument_list|)
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"Can't read Password\n"
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
ifdef|#
directive|ifdef
name|CRYPTO_MDEBUG
name|CRYPTO_pop_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|export_cert
condition|)
block|{
name|EVP_PKEY
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
name|X509
modifier|*
name|ucert
init|=
name|NULL
decl_stmt|,
modifier|*
name|x
init|=
name|NULL
decl_stmt|;
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|certs
operator|=
name|NULL
expr_stmt|;
specifier|const
name|EVP_MD
modifier|*
name|macmd
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
name|catmp
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
operator|(
name|NOCERTS
operator||
name|NOKEYS
operator|)
operator|)
operator|==
operator|(
name|NOCERTS
operator||
name|NOKEYS
operator|)
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"Nothing to do!\n"
argument_list|)
expr_stmt|;
goto|goto
name|export_end
goto|;
block|}
if|if
condition|(
name|options
operator|&
name|NOCERTS
condition|)
name|chain
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|CRYPTO_MDEBUG
name|CRYPTO_push_info
argument_list|(
literal|"process -export_cert"
argument_list|)
expr_stmt|;
name|CRYPTO_push_info
argument_list|(
literal|"reading private key"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|NOKEYS
operator|)
condition|)
block|{
name|key
operator|=
name|load_key
argument_list|(
name|bio_err
argument_list|,
name|keyname
condition|?
name|keyname
else|:
name|infile
argument_list|,
name|FORMAT_PEM
argument_list|,
literal|1
argument_list|,
name|passin
argument_list|,
name|e
argument_list|,
literal|"private key"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key
condition|)
goto|goto
name|export_end
goto|;
block|}
ifdef|#
directive|ifdef
name|CRYPTO_MDEBUG
name|CRYPTO_pop_info
argument_list|()
expr_stmt|;
name|CRYPTO_push_info
argument_list|(
literal|"reading certs from input"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Load in all certs in input file */
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|NOCERTS
operator|)
condition|)
block|{
name|certs
operator|=
name|load_certs
argument_list|(
name|bio_err
argument_list|,
name|infile
argument_list|,
name|FORMAT_PEM
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
literal|"certificates"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|certs
condition|)
goto|goto
name|export_end
goto|;
if|if
condition|(
name|key
condition|)
block|{
comment|/* Look for matching private key */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_X509_num
argument_list|(
name|certs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|sk_X509_value
argument_list|(
name|certs
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|X509_check_private_key
argument_list|(
name|x
argument_list|,
name|key
argument_list|)
condition|)
block|{
name|ucert
operator|=
name|x
expr_stmt|;
comment|/* Zero keyid and alias */
name|X509_keyid_set1
argument_list|(
name|ucert
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|X509_alias_set1
argument_list|(
name|ucert
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Remove from list */
operator|(
name|void
operator|)
name|sk_X509_delete
argument_list|(
name|certs
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|ucert
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"No certificate matches private key\n"
argument_list|)
expr_stmt|;
goto|goto
name|export_end
goto|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|CRYPTO_MDEBUG
name|CRYPTO_pop_info
argument_list|()
expr_stmt|;
name|CRYPTO_push_info
argument_list|(
literal|"reading certs from input 2"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Add any more certificates asked for */
if|if
condition|(
name|certfile
condition|)
block|{
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|morecerts
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|morecerts
operator|=
name|load_certs
argument_list|(
name|bio_err
argument_list|,
name|certfile
argument_list|,
name|FORMAT_PEM
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
literal|"certificates from certfile"
argument_list|)
operator|)
condition|)
goto|goto
name|export_end
goto|;
while|while
condition|(
name|sk_X509_num
argument_list|(
name|morecerts
argument_list|)
operator|>
literal|0
condition|)
name|sk_X509_push
argument_list|(
name|certs
argument_list|,
name|sk_X509_shift
argument_list|(
name|morecerts
argument_list|)
argument_list|)
expr_stmt|;
name|sk_X509_free
argument_list|(
name|morecerts
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CRYPTO_MDEBUG
name|CRYPTO_pop_info
argument_list|()
expr_stmt|;
name|CRYPTO_push_info
argument_list|(
literal|"reading certs from certfile"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CRYPTO_MDEBUG
name|CRYPTO_pop_info
argument_list|()
expr_stmt|;
name|CRYPTO_push_info
argument_list|(
literal|"building chain"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If chaining get chain from user cert */
if|if
condition|(
name|chain
condition|)
block|{
name|int
name|vret
decl_stmt|;
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|chain2
expr_stmt|;
name|X509_STORE
modifier|*
name|store
init|=
name|X509_STORE_new
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|store
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"Memory allocation error\n"
argument_list|)
expr_stmt|;
goto|goto
name|export_end
goto|;
block|}
if|if
condition|(
operator|!
name|X509_STORE_load_locations
argument_list|(
name|store
argument_list|,
name|CAfile
argument_list|,
name|CApath
argument_list|)
condition|)
name|X509_STORE_set_default_paths
argument_list|(
name|store
argument_list|)
expr_stmt|;
name|vret
operator|=
name|get_cert_chain
argument_list|(
name|ucert
argument_list|,
name|store
argument_list|,
operator|&
name|chain2
argument_list|)
expr_stmt|;
name|X509_STORE_free
argument_list|(
name|store
argument_list|)
expr_stmt|;
if|if
condition|(
name|vret
operator|==
name|X509_V_OK
condition|)
block|{
comment|/* Exclude verified certificate */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sk_X509_num
argument_list|(
name|chain2
argument_list|)
condition|;
name|i
operator|++
control|)
name|sk_X509_push
argument_list|(
name|certs
argument_list|,
name|sk_X509_value
argument_list|(
name|chain2
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Free first certificate */
name|X509_free
argument_list|(
name|sk_X509_value
argument_list|(
name|chain2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|sk_X509_free
argument_list|(
name|chain2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vret
operator|!=
name|X509_V_ERR_UNSPECIFIED
condition|)
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"Error %s getting chain.\n"
argument_list|,
name|X509_verify_cert_error_string
argument_list|(
name|vret
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ERR_print_errors
argument_list|(
name|bio_err
argument_list|)
expr_stmt|;
goto|goto
name|export_end
goto|;
block|}
block|}
comment|/* Add any CA names */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_OPENSSL_STRING_num
argument_list|(
name|canames
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|catmp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sk_OPENSSL_STRING_value
argument_list|(
name|canames
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|X509_alias_set1
argument_list|(
name|sk_X509_value
argument_list|(
name|certs
argument_list|,
name|i
argument_list|)
argument_list|,
name|catmp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|csp_name
operator|&&
name|key
condition|)
name|EVP_PKEY_add1_attr_by_NID
argument_list|(
name|key
argument_list|,
name|NID_ms_csp_name
argument_list|,
name|MBSTRING_ASC
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|csp_name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_lmk
operator|&&
name|key
condition|)
name|EVP_PKEY_add1_attr_by_NID
argument_list|(
name|key
argument_list|,
name|NID_LocalKeySet
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CRYPTO_MDEBUG
name|CRYPTO_pop_info
argument_list|()
expr_stmt|;
name|CRYPTO_push_info
argument_list|(
literal|"reading password"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|noprompt
operator|&&
name|EVP_read_pw_string
argument_list|(
name|pass
argument_list|,
sizeof|sizeof
name|pass
argument_list|,
literal|"Enter Export Password:"
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"Can't read Password\n"
argument_list|)
expr_stmt|;
goto|goto
name|export_end
goto|;
block|}
if|if
condition|(
operator|!
name|twopass
condition|)
name|BUF_strlcpy
argument_list|(
name|macpass
argument_list|,
name|pass
argument_list|,
sizeof|sizeof
name|macpass
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CRYPTO_MDEBUG
name|CRYPTO_pop_info
argument_list|()
expr_stmt|;
name|CRYPTO_push_info
argument_list|(
literal|"creating PKCS#12 structure"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p12
operator|=
name|PKCS12_create
argument_list|(
name|cpass
argument_list|,
name|name
argument_list|,
name|key
argument_list|,
name|ucert
argument_list|,
name|certs
argument_list|,
name|key_pbe
argument_list|,
name|cert_pbe
argument_list|,
name|iter
argument_list|,
operator|-
literal|1
argument_list|,
name|keytype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p12
condition|)
block|{
name|ERR_print_errors
argument_list|(
name|bio_err
argument_list|)
expr_stmt|;
goto|goto
name|export_end
goto|;
block|}
if|if
condition|(
name|macalg
condition|)
block|{
name|macmd
operator|=
name|EVP_get_digestbyname
argument_list|(
name|macalg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|macmd
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"Unknown digest algorithm %s\n"
argument_list|,
name|macalg
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|maciter
operator|!=
operator|-
literal|1
condition|)
name|PKCS12_set_mac
argument_list|(
name|p12
argument_list|,
name|mpass
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|maciter
argument_list|,
name|macmd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CRYPTO_MDEBUG
name|CRYPTO_pop_info
argument_list|()
expr_stmt|;
name|CRYPTO_push_info
argument_list|(
literal|"writing pkcs12"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i2d_PKCS12_bio
argument_list|(
name|out
argument_list|,
name|p12
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|export_end
label|:
ifdef|#
directive|ifdef
name|CRYPTO_MDEBUG
name|CRYPTO_pop_info
argument_list|()
expr_stmt|;
name|CRYPTO_pop_info
argument_list|()
expr_stmt|;
name|CRYPTO_push_info
argument_list|(
literal|"process -export_cert: freeing"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|key
condition|)
name|EVP_PKEY_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|certs
condition|)
name|sk_X509_pop_free
argument_list|(
name|certs
argument_list|,
name|X509_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|ucert
condition|)
name|X509_free
argument_list|(
name|ucert
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CRYPTO_MDEBUG
name|CRYPTO_pop_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
goto|goto
name|end
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|p12
operator|=
name|d2i_PKCS12_bio
argument_list|(
name|in
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|ERR_print_errors
argument_list|(
name|bio_err
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
ifdef|#
directive|ifdef
name|CRYPTO_MDEBUG
name|CRYPTO_push_info
argument_list|(
literal|"read import password"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|noprompt
operator|&&
name|EVP_read_pw_string
argument_list|(
name|pass
argument_list|,
sizeof|sizeof
name|pass
argument_list|,
literal|"Enter Import Password:"
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"Can't read Password\n"
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
ifdef|#
directive|ifdef
name|CRYPTO_MDEBUG
name|CRYPTO_pop_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|twopass
condition|)
name|BUF_strlcpy
argument_list|(
name|macpass
argument_list|,
name|pass
argument_list|,
sizeof|sizeof
name|macpass
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|INFO
operator|)
operator|&&
name|p12
operator|->
name|mac
condition|)
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"MAC Iteration %ld\n"
argument_list|,
name|p12
operator|->
name|mac
operator|->
name|iter
condition|?
name|ASN1_INTEGER_get
argument_list|(
name|p12
operator|->
name|mac
operator|->
name|iter
argument_list|)
else|:
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|macver
condition|)
block|{
ifdef|#
directive|ifdef
name|CRYPTO_MDEBUG
name|CRYPTO_push_info
argument_list|(
literal|"verify MAC"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we enter empty password try no password first */
if|if
condition|(
operator|!
name|mpass
index|[
literal|0
index|]
operator|&&
name|PKCS12_verify_mac
argument_list|(
name|p12
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* If mac and crypto pass the same set it to NULL too */
if|if
condition|(
operator|!
name|twopass
condition|)
name|cpass
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|PKCS12_verify_mac
argument_list|(
name|p12
argument_list|,
name|mpass
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"Mac verify error: invalid password?\n"
argument_list|)
expr_stmt|;
name|ERR_print_errors
argument_list|(
name|bio_err
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"MAC verified OK\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CRYPTO_MDEBUG
name|CRYPTO_pop_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|CRYPTO_MDEBUG
name|CRYPTO_push_info
argument_list|(
literal|"output keys and certificates"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|dump_certs_keys_p12
argument_list|(
name|out
argument_list|,
name|p12
argument_list|,
name|cpass
argument_list|,
operator|-
literal|1
argument_list|,
name|options
argument_list|,
name|passout
argument_list|)
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"Error outputting keys and certificates\n"
argument_list|)
expr_stmt|;
name|ERR_print_errors
argument_list|(
name|bio_err
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
ifdef|#
directive|ifdef
name|CRYPTO_MDEBUG
name|CRYPTO_pop_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|ret
operator|=
literal|0
expr_stmt|;
name|end
label|:
if|if
condition|(
name|p12
condition|)
name|PKCS12_free
argument_list|(
name|p12
argument_list|)
expr_stmt|;
if|if
condition|(
name|export_cert
operator|||
name|inrand
condition|)
name|app_RAND_write_file
argument_list|(
name|NULL
argument_list|,
name|bio_err
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CRYPTO_MDEBUG
name|CRYPTO_remove_all_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|release_engine
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|BIO_free
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|BIO_free_all
argument_list|(
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|canames
condition|)
name|sk_OPENSSL_STRING_free
argument_list|(
name|canames
argument_list|)
expr_stmt|;
if|if
condition|(
name|passin
condition|)
name|OPENSSL_free
argument_list|(
name|passin
argument_list|)
expr_stmt|;
if|if
condition|(
name|passout
condition|)
name|OPENSSL_free
argument_list|(
name|passout
argument_list|)
expr_stmt|;
name|apps_shutdown
argument_list|()
expr_stmt|;
name|OPENSSL_EXIT
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dump_certs_keys_p12
parameter_list|(
name|BIO
modifier|*
name|out
parameter_list|,
name|PKCS12
modifier|*
name|p12
parameter_list|,
name|char
modifier|*
name|pass
parameter_list|,
name|int
name|passlen
parameter_list|,
name|int
name|options
parameter_list|,
name|char
modifier|*
name|pempass
parameter_list|)
block|{
name|STACK_OF
argument_list|(
name|PKCS7
argument_list|)
operator|*
name|asafes
operator|=
name|NULL
expr_stmt|;
name|STACK_OF
argument_list|(
name|PKCS12_SAFEBAG
argument_list|)
operator|*
name|bags
expr_stmt|;
name|int
name|i
decl_stmt|,
name|bagnid
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|PKCS7
modifier|*
name|p7
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|asafes
operator|=
name|PKCS12_unpack_authsafes
argument_list|(
name|p12
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_PKCS7_num
argument_list|(
name|asafes
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|p7
operator|=
name|sk_PKCS7_value
argument_list|(
name|asafes
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bagnid
operator|=
name|OBJ_obj2nid
argument_list|(
name|p7
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|bagnid
operator|==
name|NID_pkcs7_data
condition|)
block|{
name|bags
operator|=
name|PKCS12_unpack_p7data
argument_list|(
name|p7
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|INFO
condition|)
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"PKCS7 Data\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bagnid
operator|==
name|NID_pkcs7_encrypted
condition|)
block|{
if|if
condition|(
name|options
operator|&
name|INFO
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"PKCS7 Encrypted data: "
argument_list|)
expr_stmt|;
name|alg_print
argument_list|(
name|bio_err
argument_list|,
name|p7
operator|->
name|d
operator|.
name|encrypted
operator|->
name|enc_data
operator|->
name|algorithm
argument_list|)
expr_stmt|;
block|}
name|bags
operator|=
name|PKCS12_unpack_p7encdata
argument_list|(
name|p7
argument_list|,
name|pass
argument_list|,
name|passlen
argument_list|)
expr_stmt|;
block|}
else|else
continue|continue;
if|if
condition|(
operator|!
name|bags
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|dump_certs_pkeys_bags
argument_list|(
name|out
argument_list|,
name|bags
argument_list|,
name|pass
argument_list|,
name|passlen
argument_list|,
name|options
argument_list|,
name|pempass
argument_list|)
condition|)
block|{
name|sk_PKCS12_SAFEBAG_pop_free
argument_list|(
name|bags
argument_list|,
name|PKCS12_SAFEBAG_free
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|sk_PKCS12_SAFEBAG_pop_free
argument_list|(
name|bags
argument_list|,
name|PKCS12_SAFEBAG_free
argument_list|)
expr_stmt|;
name|bags
operator|=
name|NULL
expr_stmt|;
block|}
name|ret
operator|=
literal|1
expr_stmt|;
name|err
label|:
if|if
condition|(
name|asafes
condition|)
name|sk_PKCS7_pop_free
argument_list|(
name|asafes
argument_list|,
name|PKCS7_free
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_decl_stmt
name|int
name|dump_certs_pkeys_bags
argument_list|(
name|BIO
operator|*
name|out
argument_list|,
name|STACK_OF
argument_list|(
name|PKCS12_SAFEBAG
argument_list|)
operator|*
name|bags
argument_list|,
name|char
operator|*
name|pass
argument_list|,
name|int
name|passlen
argument_list|,
name|int
name|options
argument_list|,
name|char
operator|*
name|pempass
argument_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_PKCS12_SAFEBAG_num
argument_list|(
name|bags
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|dump_certs_pkeys_bag
argument_list|(
name|out
argument_list|,
name|sk_PKCS12_SAFEBAG_value
argument_list|(
name|bags
argument_list|,
name|i
argument_list|)
argument_list|,
name|pass
argument_list|,
name|passlen
argument_list|,
name|options
argument_list|,
name|pempass
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_decl_stmt

begin_function
name|int
name|dump_certs_pkeys_bag
parameter_list|(
name|BIO
modifier|*
name|out
parameter_list|,
name|PKCS12_SAFEBAG
modifier|*
name|bag
parameter_list|,
name|char
modifier|*
name|pass
parameter_list|,
name|int
name|passlen
parameter_list|,
name|int
name|options
parameter_list|,
name|char
modifier|*
name|pempass
parameter_list|)
block|{
name|EVP_PKEY
modifier|*
name|pkey
decl_stmt|;
name|PKCS8_PRIV_KEY_INFO
modifier|*
name|p8
decl_stmt|;
name|X509
modifier|*
name|x509
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|M_PKCS12_bag_type
argument_list|(
name|bag
argument_list|)
condition|)
block|{
case|case
name|NID_keyBag
case|:
if|if
condition|(
name|options
operator|&
name|INFO
condition|)
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"Key bag\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|NOKEYS
condition|)
return|return
literal|1
return|;
name|print_attribs
argument_list|(
name|out
argument_list|,
name|bag
operator|->
name|attrib
argument_list|,
literal|"Bag Attributes"
argument_list|)
expr_stmt|;
name|p8
operator|=
name|bag
operator|->
name|value
operator|.
name|keybag
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pkey
operator|=
name|EVP_PKCS82PKEY
argument_list|(
name|p8
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|print_attribs
argument_list|(
name|out
argument_list|,
name|p8
operator|->
name|attributes
argument_list|,
literal|"Key Attributes"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|PEM_write_bio_PrivateKey
argument_list|(
name|out
argument_list|,
name|pkey
argument_list|,
name|enc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|pempass
argument_list|)
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
break|break;
case|case
name|NID_pkcs8ShroudedKeyBag
case|:
if|if
condition|(
name|options
operator|&
name|INFO
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"Shrouded Keybag: "
argument_list|)
expr_stmt|;
name|alg_print
argument_list|(
name|bio_err
argument_list|,
name|bag
operator|->
name|value
operator|.
name|shkeybag
operator|->
name|algor
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|options
operator|&
name|NOKEYS
condition|)
return|return
literal|1
return|;
name|print_attribs
argument_list|(
name|out
argument_list|,
name|bag
operator|->
name|attrib
argument_list|,
literal|"Bag Attributes"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p8
operator|=
name|PKCS12_decrypt_skey
argument_list|(
name|bag
argument_list|,
name|pass
argument_list|,
name|passlen
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|pkey
operator|=
name|EVP_PKCS82PKEY
argument_list|(
name|p8
argument_list|)
operator|)
condition|)
block|{
name|PKCS8_PRIV_KEY_INFO_free
argument_list|(
name|p8
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|print_attribs
argument_list|(
name|out
argument_list|,
name|p8
operator|->
name|attributes
argument_list|,
literal|"Key Attributes"
argument_list|)
expr_stmt|;
name|PKCS8_PRIV_KEY_INFO_free
argument_list|(
name|p8
argument_list|)
expr_stmt|;
name|ret
operator|=
name|PEM_write_bio_PrivateKey
argument_list|(
name|out
argument_list|,
name|pkey
argument_list|,
name|enc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|pempass
argument_list|)
expr_stmt|;
name|EVP_PKEY_free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
break|break;
case|case
name|NID_certBag
case|:
if|if
condition|(
name|options
operator|&
name|INFO
condition|)
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"Certificate bag\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|NOCERTS
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|PKCS12_get_attr
argument_list|(
name|bag
argument_list|,
name|NID_localKeyID
argument_list|)
condition|)
block|{
if|if
condition|(
name|options
operator|&
name|CACERTS
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|options
operator|&
name|CLCERTS
condition|)
return|return
literal|1
return|;
name|print_attribs
argument_list|(
name|out
argument_list|,
name|bag
operator|->
name|attrib
argument_list|,
literal|"Bag Attributes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_PKCS12_cert_bag_type
argument_list|(
name|bag
argument_list|)
operator|!=
name|NID_x509Certificate
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
operator|(
name|x509
operator|=
name|PKCS12_certbag2x509
argument_list|(
name|bag
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|dump_cert_text
argument_list|(
name|out
argument_list|,
name|x509
argument_list|)
expr_stmt|;
name|ret
operator|=
name|PEM_write_bio_X509
argument_list|(
name|out
argument_list|,
name|x509
argument_list|)
expr_stmt|;
name|X509_free
argument_list|(
name|x509
argument_list|)
expr_stmt|;
break|break;
case|case
name|NID_safeContentsBag
case|:
if|if
condition|(
name|options
operator|&
name|INFO
condition|)
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"Safe Contents bag\n"
argument_list|)
expr_stmt|;
name|print_attribs
argument_list|(
name|out
argument_list|,
name|bag
operator|->
name|attrib
argument_list|,
literal|"Bag Attributes"
argument_list|)
expr_stmt|;
return|return
name|dump_certs_pkeys_bags
argument_list|(
name|out
argument_list|,
name|bag
operator|->
name|value
operator|.
name|safes
argument_list|,
name|pass
argument_list|,
name|passlen
argument_list|,
name|options
argument_list|,
name|pempass
argument_list|)
return|;
default|default:
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"Warning unsupported bag type: "
argument_list|)
expr_stmt|;
name|i2a_ASN1_OBJECT
argument_list|(
name|bio_err
argument_list|,
name|bag
operator|->
name|type
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Given a single certificate return a verified chain or NULL if error */
end_comment

begin_decl_stmt
specifier|static
name|int
name|get_cert_chain
argument_list|(
name|X509
operator|*
name|cert
argument_list|,
name|X509_STORE
operator|*
name|store
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
operator|*
name|chain
argument_list|)
block|{
name|X509_STORE_CTX
name|store_ctx
decl_stmt|;
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|chn
operator|=
name|NULL
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|X509_STORE_CTX_init
argument_list|(
operator|&
name|store_ctx
argument_list|,
name|store
argument_list|,
name|cert
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
operator|*
name|chain
operator|=
name|NULL
expr_stmt|;
return|return
name|X509_V_ERR_UNSPECIFIED
return|;
block|}
if|if
condition|(
name|X509_verify_cert
argument_list|(
operator|&
name|store_ctx
argument_list|)
operator|>
literal|0
condition|)
name|chn
operator|=
name|X509_STORE_CTX_get1_chain
argument_list|(
operator|&
name|store_ctx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|i
operator|=
name|X509_STORE_CTX_get_error
argument_list|(
operator|&
name|store_ctx
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|i
operator|=
name|X509_V_ERR_UNSPECIFIED
expr_stmt|;
name|X509_STORE_CTX_cleanup
argument_list|(
operator|&
name|store_ctx
argument_list|)
expr_stmt|;
operator|*
name|chain
operator|=
name|chn
expr_stmt|;
return|return
name|i
return|;
block|}
end_decl_stmt

begin_function
name|int
name|alg_print
parameter_list|(
name|BIO
modifier|*
name|x
parameter_list|,
name|X509_ALGOR
modifier|*
name|alg
parameter_list|)
block|{
name|int
name|pbenid
decl_stmt|,
name|aparamtype
decl_stmt|;
name|ASN1_OBJECT
modifier|*
name|aoid
decl_stmt|;
name|void
modifier|*
name|aparam
decl_stmt|;
name|PBEPARAM
modifier|*
name|pbe
init|=
name|NULL
decl_stmt|;
name|X509_ALGOR_get0
argument_list|(
operator|&
name|aoid
argument_list|,
operator|&
name|aparamtype
argument_list|,
operator|&
name|aparam
argument_list|,
name|alg
argument_list|)
expr_stmt|;
name|pbenid
operator|=
name|OBJ_obj2nid
argument_list|(
name|aoid
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|x
argument_list|,
literal|"%s"
argument_list|,
name|OBJ_nid2ln
argument_list|(
name|pbenid
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * If PBE algorithm is PBES2 decode algorithm parameters      * for additional details.      */
if|if
condition|(
name|pbenid
operator|==
name|NID_pbes2
condition|)
block|{
name|PBE2PARAM
modifier|*
name|pbe2
init|=
name|NULL
decl_stmt|;
name|int
name|encnid
decl_stmt|;
if|if
condition|(
name|aparamtype
operator|==
name|V_ASN1_SEQUENCE
condition|)
name|pbe2
operator|=
name|ASN1_item_unpack
argument_list|(
name|aparam
argument_list|,
name|ASN1_ITEM_rptr
argument_list|(
name|PBE2PARAM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pbe2
operator|==
name|NULL
condition|)
block|{
name|BIO_puts
argument_list|(
name|x
argument_list|,
literal|"<unsupported parameters>"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|X509_ALGOR_get0
argument_list|(
operator|&
name|aoid
argument_list|,
operator|&
name|aparamtype
argument_list|,
operator|&
name|aparam
argument_list|,
name|pbe2
operator|->
name|keyfunc
argument_list|)
expr_stmt|;
name|pbenid
operator|=
name|OBJ_obj2nid
argument_list|(
name|aoid
argument_list|)
expr_stmt|;
name|X509_ALGOR_get0
argument_list|(
operator|&
name|aoid
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pbe2
operator|->
name|encryption
argument_list|)
expr_stmt|;
name|encnid
operator|=
name|OBJ_obj2nid
argument_list|(
name|aoid
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|x
argument_list|,
literal|", %s, %s"
argument_list|,
name|OBJ_nid2ln
argument_list|(
name|pbenid
argument_list|)
argument_list|,
name|OBJ_nid2sn
argument_list|(
name|encnid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If KDF is PBKDF2 decode parameters */
if|if
condition|(
name|pbenid
operator|==
name|NID_id_pbkdf2
condition|)
block|{
name|PBKDF2PARAM
modifier|*
name|kdf
init|=
name|NULL
decl_stmt|;
name|int
name|prfnid
decl_stmt|;
if|if
condition|(
name|aparamtype
operator|==
name|V_ASN1_SEQUENCE
condition|)
name|kdf
operator|=
name|ASN1_item_unpack
argument_list|(
name|aparam
argument_list|,
name|ASN1_ITEM_rptr
argument_list|(
name|PBKDF2PARAM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kdf
operator|==
name|NULL
condition|)
block|{
name|BIO_puts
argument_list|(
name|x
argument_list|,
literal|"<unsupported parameters>"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|kdf
operator|->
name|prf
operator|==
name|NULL
condition|)
block|{
name|prfnid
operator|=
name|NID_hmacWithSHA1
expr_stmt|;
block|}
else|else
block|{
name|X509_ALGOR_get0
argument_list|(
operator|&
name|aoid
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|kdf
operator|->
name|prf
argument_list|)
expr_stmt|;
name|prfnid
operator|=
name|OBJ_obj2nid
argument_list|(
name|aoid
argument_list|)
expr_stmt|;
block|}
name|BIO_printf
argument_list|(
name|x
argument_list|,
literal|", Iteration %ld, PRF %s"
argument_list|,
name|ASN1_INTEGER_get
argument_list|(
name|kdf
operator|->
name|iter
argument_list|)
argument_list|,
name|OBJ_nid2sn
argument_list|(
name|prfnid
argument_list|)
argument_list|)
expr_stmt|;
name|PBKDF2PARAM_free
argument_list|(
name|kdf
argument_list|)
expr_stmt|;
block|}
name|PBE2PARAM_free
argument_list|(
name|pbe2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|aparamtype
operator|==
name|V_ASN1_SEQUENCE
condition|)
name|pbe
operator|=
name|ASN1_item_unpack
argument_list|(
name|aparam
argument_list|,
name|ASN1_ITEM_rptr
argument_list|(
name|PBEPARAM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pbe
operator|==
name|NULL
condition|)
block|{
name|BIO_puts
argument_list|(
name|x
argument_list|,
literal|"<unsupported parameters>"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|BIO_printf
argument_list|(
name|x
argument_list|,
literal|", Iteration %ld"
argument_list|,
name|ASN1_INTEGER_get
argument_list|(
name|pbe
operator|->
name|iter
argument_list|)
argument_list|)
expr_stmt|;
name|PBEPARAM_free
argument_list|(
name|pbe
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|BIO_puts
argument_list|(
name|x
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Load all certificates from a given file */
end_comment

begin_decl_stmt
name|int
name|cert_load
argument_list|(
name|BIO
operator|*
name|in
argument_list|,
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|sk
argument_list|)
block|{
name|int
name|ret
decl_stmt|;
name|X509
modifier|*
name|cert
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|CRYPTO_MDEBUG
name|CRYPTO_push_info
argument_list|(
literal|"cert_load(): reading one cert"
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|cert
operator|=
name|PEM_read_bio_X509
argument_list|(
name|in
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|CRYPTO_MDEBUG
name|CRYPTO_pop_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|ret
operator|=
literal|1
expr_stmt|;
name|sk_X509_push
argument_list|(
name|sk
argument_list|,
name|cert
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CRYPTO_MDEBUG
name|CRYPTO_push_info
argument_list|(
literal|"cert_load(): reading one cert"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|CRYPTO_MDEBUG
name|CRYPTO_pop_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ret
condition|)
name|ERR_clear_error
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Generalised attribute print: handle PKCS#8 and bag attributes */
end_comment

begin_decl_stmt
name|int
name|print_attribs
argument_list|(
name|BIO
operator|*
name|out
argument_list|,
name|STACK_OF
argument_list|(
name|X509_ATTRIBUTE
argument_list|)
operator|*
name|attrlst
argument_list|,
specifier|const
name|char
operator|*
name|name
argument_list|)
block|{
name|X509_ATTRIBUTE
modifier|*
name|attr
decl_stmt|;
name|ASN1_TYPE
modifier|*
name|av
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|i
decl_stmt|,
name|attr_nid
decl_stmt|;
if|if
condition|(
operator|!
name|attrlst
condition|)
block|{
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"%s:<No Attributes>\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|sk_X509_ATTRIBUTE_num
argument_list|(
name|attrlst
argument_list|)
condition|)
block|{
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"%s:<Empty Attributes>\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sk_X509_ATTRIBUTE_num
argument_list|(
name|attrlst
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|attr
operator|=
name|sk_X509_ATTRIBUTE_value
argument_list|(
name|attrlst
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|attr_nid
operator|=
name|OBJ_obj2nid
argument_list|(
name|attr
operator|->
name|object
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr_nid
operator|==
name|NID_undef
condition|)
block|{
name|i2a_ASN1_OBJECT
argument_list|(
name|out
argument_list|,
name|attr
operator|->
name|object
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
block|}
else|else
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"%s: "
argument_list|,
name|OBJ_nid2ln
argument_list|(
name|attr_nid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sk_ASN1_TYPE_num
argument_list|(
name|attr
operator|->
name|value
operator|.
name|set
argument_list|)
condition|)
block|{
name|av
operator|=
name|sk_ASN1_TYPE_value
argument_list|(
name|attr
operator|->
name|value
operator|.
name|set
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|av
operator|->
name|type
condition|)
block|{
case|case
name|V_ASN1_BMPSTRING
case|:
name|value
operator|=
name|OPENSSL_uni2asc
argument_list|(
name|av
operator|->
name|value
operator|.
name|bmpstring
operator|->
name|data
argument_list|,
name|av
operator|->
name|value
operator|.
name|bmpstring
operator|->
name|length
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"%s\n"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_ASN1_OCTET_STRING
case|:
name|hex_prin
argument_list|(
name|out
argument_list|,
name|av
operator|->
name|value
operator|.
name|octet_string
operator|->
name|data
argument_list|,
name|av
operator|->
name|value
operator|.
name|octet_string
operator|->
name|length
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_ASN1_BIT_STRING
case|:
name|hex_prin
argument_list|(
name|out
argument_list|,
name|av
operator|->
name|value
operator|.
name|bit_string
operator|->
name|data
argument_list|,
name|av
operator|->
name|value
operator|.
name|bit_string
operator|->
name|length
argument_list|)
expr_stmt|;
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"<Unsupported tag %d>\n"
argument_list|,
name|av
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"<No Values>\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_decl_stmt

begin_function
name|void
name|hex_prin
parameter_list|(
name|BIO
modifier|*
name|out
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|BIO_printf
argument_list|(
name|out
argument_list|,
literal|"%02X "
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_pbe
parameter_list|(
name|BIO
modifier|*
name|err
parameter_list|,
name|int
modifier|*
name|ppbe
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
operator|!
name|str
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"NONE"
argument_list|)
condition|)
block|{
operator|*
name|ppbe
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|ppbe
operator|=
name|OBJ_txt2nid
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ppbe
operator|==
name|NID_undef
condition|)
block|{
name|BIO_printf
argument_list|(
name|bio_err
argument_list|,
literal|"Unknown PBE algorithm %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|void
modifier|*
name|dummy
init|=
operator|&
name|dummy
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

