begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * unbound.c - unbound validating resolver public API implementation  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file contains functions to resolve DNS queries and   * validate the answers. Synchonously and asynchronously.  *  */
end_comment

begin_comment
comment|/* include the public api first, it should be able to stand alone */
end_comment

begin_include
include|#
directive|include
file|"libunbound/unbound.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"libunbound/context.h"
end_include

begin_include
include|#
directive|include
file|"libunbound/libworker.h"
end_include

begin_include
include|#
directive|include
file|"util/locks.h"
end_include

begin_include
include|#
directive|include
file|"util/config_file.h"
end_include

begin_include
include|#
directive|include
file|"util/alloc.h"
end_include

begin_include
include|#
directive|include
file|"util/module.h"
end_include

begin_include
include|#
directive|include
file|"util/regional.h"
end_include

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"util/random.h"
end_include

begin_include
include|#
directive|include
file|"util/net_help.h"
end_include

begin_include
include|#
directive|include
file|"util/tube.h"
end_include

begin_include
include|#
directive|include
file|"services/modstack.h"
end_include

begin_include
include|#
directive|include
file|"services/localzone.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/infra.h"
end_include

begin_include
include|#
directive|include
file|"services/cache/rrset.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PTHREAD
end_ifdef

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|UB_ON_WINDOWS
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_WINDOWS_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_include
include|#
directive|include
file|<iphlpapi.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UB_ON_WINDOWS */
end_comment

begin_function
name|struct
name|ub_ctx
modifier|*
name|ub_ctx_create
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ub_ctx
modifier|*
name|ctx
decl_stmt|;
name|unsigned
name|int
name|seed
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_WINSOCK
name|int
name|r
decl_stmt|;
name|WSADATA
name|wsa_data
decl_stmt|;
endif|#
directive|endif
name|log_init
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* logs to stderr */
name|log_ident_set
argument_list|(
literal|"libunbound"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_WINSOCK
if|if
condition|(
operator|(
name|r
operator|=
name|WSAStartup
argument_list|(
name|MAKEWORD
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
argument_list|,
operator|&
name|wsa_data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|log_err
argument_list|(
literal|"could not init winsock. WSAStartup: %s"
argument_list|,
name|wsa_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
name|verbosity
operator|=
literal|0
expr_stmt|;
comment|/* errors only */
name|checklock_start
argument_list|()
expr_stmt|;
name|ctx
operator|=
operator|(
expr|struct
name|ub_ctx
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|alloc_init
argument_list|(
operator|&
name|ctx
operator|->
name|superalloc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|seed
operator|=
operator|(
name|unsigned
name|int
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
operator|^
operator|(
name|unsigned
name|int
operator|)
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ctx
operator|->
name|seed_rnd
operator|=
name|ub_initstate
argument_list|(
name|seed
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|seed
operator|=
literal|0
expr_stmt|;
name|ub_randfree
argument_list|(
name|ctx
operator|->
name|seed_rnd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|seed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ctx
operator|->
name|qq_pipe
operator|=
name|tube_create
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|ub_randfree
argument_list|(
name|ctx
operator|->
name|seed_rnd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|ctx
operator|->
name|rr_pipe
operator|=
name|tube_create
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|tube_delete
argument_list|(
name|ctx
operator|->
name|qq_pipe
argument_list|)
expr_stmt|;
name|ub_randfree
argument_list|(
name|ctx
operator|->
name|seed_rnd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|lock_basic_init
argument_list|(
operator|&
name|ctx
operator|->
name|qqpipe_lock
argument_list|)
expr_stmt|;
name|lock_basic_init
argument_list|(
operator|&
name|ctx
operator|->
name|rrpipe_lock
argument_list|)
expr_stmt|;
name|lock_basic_init
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|env
operator|=
operator|(
expr|struct
name|module_env
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
operator|->
name|env
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|env
condition|)
block|{
name|tube_delete
argument_list|(
name|ctx
operator|->
name|qq_pipe
argument_list|)
expr_stmt|;
name|tube_delete
argument_list|(
name|ctx
operator|->
name|rr_pipe
argument_list|)
expr_stmt|;
name|ub_randfree
argument_list|(
name|ctx
operator|->
name|seed_rnd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ctx
operator|->
name|env
operator|->
name|cfg
operator|=
name|config_create_forlib
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|env
operator|->
name|cfg
condition|)
block|{
name|tube_delete
argument_list|(
name|ctx
operator|->
name|qq_pipe
argument_list|)
expr_stmt|;
name|tube_delete
argument_list|(
name|ctx
operator|->
name|rr_pipe
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
operator|->
name|env
argument_list|)
expr_stmt|;
name|ub_randfree
argument_list|(
name|ctx
operator|->
name|seed_rnd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ctx
operator|->
name|env
operator|->
name|alloc
operator|=
operator|&
name|ctx
operator|->
name|superalloc
expr_stmt|;
name|ctx
operator|->
name|env
operator|->
name|worker
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|env
operator|->
name|need_to_validate
operator|=
literal|0
expr_stmt|;
name|modstack_init
argument_list|(
operator|&
name|ctx
operator|->
name|mods
argument_list|)
expr_stmt|;
name|rbtree_init
argument_list|(
operator|&
name|ctx
operator|->
name|queries
argument_list|,
operator|&
name|context_query_cmp
argument_list|)
expr_stmt|;
return|return
name|ctx
return|;
block|}
end_function

begin_comment
comment|/** delete q */
end_comment

begin_function
specifier|static
name|void
name|delq
parameter_list|(
name|rbnode_t
modifier|*
name|n
parameter_list|,
name|void
modifier|*
name|ATTR_UNUSED
parameter_list|(
name|arg
parameter_list|)
parameter_list|)
block|{
name|struct
name|ctx_query
modifier|*
name|q
init|=
operator|(
expr|struct
name|ctx_query
operator|*
operator|)
name|n
decl_stmt|;
name|context_query_delete
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** stop the bg thread */
end_comment

begin_function
specifier|static
name|void
name|ub_stop_bg
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|)
block|{
comment|/* stop the bg thread */
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|created_bg
condition|)
block|{
name|uint8_t
modifier|*
name|msg
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|uint32_t
name|cmd
init|=
name|UB_LIBCMD_QUIT
decl_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|qqpipe_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tube_write_msg
argument_list|(
name|ctx
operator|->
name|qq_pipe
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|cmd
argument_list|,
operator|(
name|uint32_t
operator|)
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|qqpipe_lock
argument_list|)
expr_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|rrpipe_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|tube_read_msg
argument_list|(
name|ctx
operator|->
name|rr_pipe
argument_list|,
operator|&
name|msg
argument_list|,
operator|&
name|len
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* discard all results except a quit confirm */
if|if
condition|(
name|context_serial_getcmd
argument_list|(
name|msg
argument_list|,
name|len
argument_list|)
operator|==
name|UB_LIBCMD_QUIT
condition|)
block|{
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|rrpipe_lock
argument_list|)
expr_stmt|;
comment|/* if bg worker is a thread, wait for it to exit, so that all 	 	 * resources are really gone. */
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|dothread
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|ub_thread_join
argument_list|(
name|ctx
operator|->
name|bg_tid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ub_ctx_delete
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|alloc_cache
modifier|*
name|a
decl_stmt|,
modifier|*
name|na
decl_stmt|;
name|int
name|do_stop
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
return|return;
comment|/* see if bg thread is created and if threads have been killed */
comment|/* no locks, because those may be held by terminated threads */
comment|/* for processes the read pipe is closed and we see that on read */
ifdef|#
directive|ifdef
name|HAVE_PTHREAD
if|if
condition|(
name|ctx
operator|->
name|created_bg
operator|&&
name|ctx
operator|->
name|dothread
condition|)
block|{
if|if
condition|(
name|pthread_kill
argument_list|(
name|ctx
operator|->
name|bg_tid
argument_list|,
literal|0
argument_list|)
operator|==
name|ESRCH
condition|)
block|{
comment|/* thread has been killed */
name|do_stop
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_PTHREAD */
if|if
condition|(
name|do_stop
condition|)
name|ub_stop_bg
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|modstack_desetup
argument_list|(
operator|&
name|ctx
operator|->
name|mods
argument_list|,
name|ctx
operator|->
name|env
argument_list|)
expr_stmt|;
name|a
operator|=
name|ctx
operator|->
name|alloc_list
expr_stmt|;
while|while
condition|(
name|a
condition|)
block|{
name|na
operator|=
name|a
operator|->
name|super
expr_stmt|;
name|a
operator|->
name|super
operator|=
operator|&
name|ctx
operator|->
name|superalloc
expr_stmt|;
name|alloc_clear
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|a
operator|=
name|na
expr_stmt|;
block|}
name|local_zones_delete
argument_list|(
name|ctx
operator|->
name|local_zones
argument_list|)
expr_stmt|;
name|lock_basic_destroy
argument_list|(
operator|&
name|ctx
operator|->
name|qqpipe_lock
argument_list|)
expr_stmt|;
name|lock_basic_destroy
argument_list|(
operator|&
name|ctx
operator|->
name|rrpipe_lock
argument_list|)
expr_stmt|;
name|lock_basic_destroy
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|tube_delete
argument_list|(
name|ctx
operator|->
name|qq_pipe
argument_list|)
expr_stmt|;
name|tube_delete
argument_list|(
name|ctx
operator|->
name|rr_pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|env
condition|)
block|{
name|slabhash_delete
argument_list|(
name|ctx
operator|->
name|env
operator|->
name|msg_cache
argument_list|)
expr_stmt|;
name|rrset_cache_delete
argument_list|(
name|ctx
operator|->
name|env
operator|->
name|rrset_cache
argument_list|)
expr_stmt|;
name|infra_delete
argument_list|(
name|ctx
operator|->
name|env
operator|->
name|infra_cache
argument_list|)
expr_stmt|;
name|config_delete
argument_list|(
name|ctx
operator|->
name|env
operator|->
name|cfg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
operator|->
name|env
argument_list|)
expr_stmt|;
block|}
name|ub_randfree
argument_list|(
name|ctx
operator|->
name|seed_rnd
argument_list|)
expr_stmt|;
name|alloc_clear
argument_list|(
operator|&
name|ctx
operator|->
name|superalloc
argument_list|)
expr_stmt|;
name|traverse_postorder
argument_list|(
operator|&
name|ctx
operator|->
name|queries
argument_list|,
name|delq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_WINSOCK
name|WSACleanup
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|ub_ctx_set_option
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|opt
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|finalized
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
return|return
name|UB_AFTERFINAL
return|;
block|}
if|if
condition|(
operator|!
name|config_set_option
argument_list|(
name|ctx
operator|->
name|env
operator|->
name|cfg
argument_list|,
name|opt
argument_list|,
name|val
argument_list|)
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
return|return
name|UB_SYNTAX
return|;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
return|return
name|UB_NOERROR
return|;
block|}
end_function

begin_function
name|int
name|ub_ctx_get_option
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|opt
parameter_list|,
name|char
modifier|*
modifier|*
name|str
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|r
operator|=
name|config_get_option_collate
argument_list|(
name|ctx
operator|->
name|env
operator|->
name|cfg
argument_list|,
name|opt
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
name|r
operator|=
name|UB_NOERROR
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|==
literal|1
condition|)
name|r
operator|=
name|UB_SYNTAX
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|==
literal|2
condition|)
name|r
operator|=
name|UB_NOMEM
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|ub_ctx_config
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|finalized
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
return|return
name|UB_AFTERFINAL
return|;
block|}
if|if
condition|(
operator|!
name|config_read
argument_list|(
name|ctx
operator|->
name|env
operator|->
name|cfg
argument_list|,
name|fname
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
return|return
name|UB_SYNTAX
return|;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
return|return
name|UB_NOERROR
return|;
block|}
end_function

begin_function
name|int
name|ub_ctx_add_ta
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|ta
parameter_list|)
block|{
name|char
modifier|*
name|dup
init|=
name|strdup
argument_list|(
name|ta
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dup
condition|)
return|return
name|UB_NOMEM
return|;
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|finalized
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dup
argument_list|)
expr_stmt|;
return|return
name|UB_AFTERFINAL
return|;
block|}
if|if
condition|(
operator|!
name|cfg_strlist_insert
argument_list|(
operator|&
name|ctx
operator|->
name|env
operator|->
name|cfg
operator|->
name|trust_anchor_list
argument_list|,
name|dup
argument_list|)
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dup
argument_list|)
expr_stmt|;
return|return
name|UB_NOMEM
return|;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
return|return
name|UB_NOERROR
return|;
block|}
end_function

begin_function
name|int
name|ub_ctx_add_ta_file
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|char
modifier|*
name|dup
init|=
name|strdup
argument_list|(
name|fname
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dup
condition|)
return|return
name|UB_NOMEM
return|;
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|finalized
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dup
argument_list|)
expr_stmt|;
return|return
name|UB_AFTERFINAL
return|;
block|}
if|if
condition|(
operator|!
name|cfg_strlist_insert
argument_list|(
operator|&
name|ctx
operator|->
name|env
operator|->
name|cfg
operator|->
name|trust_anchor_file_list
argument_list|,
name|dup
argument_list|)
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dup
argument_list|)
expr_stmt|;
return|return
name|UB_NOMEM
return|;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
return|return
name|UB_NOERROR
return|;
block|}
end_function

begin_function
name|int
name|ub_ctx_trustedkeys
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|char
modifier|*
name|dup
init|=
name|strdup
argument_list|(
name|fname
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dup
condition|)
return|return
name|UB_NOMEM
return|;
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|finalized
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dup
argument_list|)
expr_stmt|;
return|return
name|UB_AFTERFINAL
return|;
block|}
if|if
condition|(
operator|!
name|cfg_strlist_insert
argument_list|(
operator|&
name|ctx
operator|->
name|env
operator|->
name|cfg
operator|->
name|trusted_keys_file_list
argument_list|,
name|dup
argument_list|)
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dup
argument_list|)
expr_stmt|;
return|return
name|UB_NOMEM
return|;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
return|return
name|UB_NOERROR
return|;
block|}
end_function

begin_function
name|int
name|ub_ctx_debuglevel
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
name|int
name|d
parameter_list|)
block|{
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|verbosity
operator|=
name|d
expr_stmt|;
name|ctx
operator|->
name|env
operator|->
name|cfg
operator|->
name|verbosity
operator|=
name|d
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
return|return
name|UB_NOERROR
return|;
block|}
end_function

begin_function
name|int
name|ub_ctx_debugout
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|out
parameter_list|)
block|{
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|log_file
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|out
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|logfile_override
operator|=
literal|1
expr_stmt|;
name|ctx
operator|->
name|log_out
operator|=
name|out
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
return|return
name|UB_NOERROR
return|;
block|}
end_function

begin_function
name|int
name|ub_ctx_async
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
name|int
name|dothread
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|THREADS_DISABLED
if|if
condition|(
name|dothread
condition|)
comment|/* cannot do threading */
return|return
name|UB_NOERROR
return|;
endif|#
directive|endif
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|finalized
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
return|return
name|UB_AFTERFINAL
return|;
block|}
name|ctx
operator|->
name|dothread
operator|=
name|dothread
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
return|return
name|UB_NOERROR
return|;
block|}
end_function

begin_function
name|int
name|ub_poll
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|)
block|{
comment|/* no need to hold lock while testing for readability. */
return|return
name|tube_poll
argument_list|(
name|ctx
operator|->
name|rr_pipe
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ub_fd
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|)
block|{
return|return
name|tube_read_fd
argument_list|(
name|ctx
operator|->
name|rr_pipe
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** process answer from bg worker */
end_comment

begin_function
specifier|static
name|int
name|process_answer_detail
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
name|uint8_t
modifier|*
name|msg
parameter_list|,
name|uint32_t
name|len
parameter_list|,
name|ub_callback_t
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
modifier|*
name|cbarg
parameter_list|,
name|int
modifier|*
name|err
parameter_list|,
name|struct
name|ub_result
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|ctx_query
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|context_serial_getcmd
argument_list|(
name|msg
argument_list|,
name|len
argument_list|)
operator|!=
name|UB_LIBCMD_ANSWER
condition|)
block|{
name|log_err
argument_list|(
literal|"error: bad data from bg worker %d"
argument_list|,
operator|(
name|int
operator|)
name|context_serial_getcmd
argument_list|(
name|msg
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|q
operator|=
name|context_deserialize_answer
argument_list|(
name|ctx
argument_list|,
name|msg
argument_list|,
name|len
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
comment|/* probably simply the lookup that failed, i.e. 		 * response returned before cancel was sent out, so noerror */
return|return
literal|1
return|;
block|}
name|log_assert
argument_list|(
name|q
operator|->
name|async
argument_list|)
expr_stmt|;
comment|/* grab cb while locked */
if|if
condition|(
name|q
operator|->
name|cancelled
condition|)
block|{
operator|*
name|cb
operator|=
name|NULL
expr_stmt|;
operator|*
name|cbarg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cb
operator|=
name|q
operator|->
name|cb
expr_stmt|;
operator|*
name|cbarg
operator|=
name|q
operator|->
name|cb_arg
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|err
condition|)
block|{
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
name|ub_resolve_free
argument_list|(
name|q
operator|->
name|res
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* parse the message, extract rcode, fill result */
name|ldns_buffer
modifier|*
name|buf
init|=
name|ldns_buffer_new
argument_list|(
name|q
operator|->
name|msg_len
argument_list|)
decl_stmt|;
name|struct
name|regional
modifier|*
name|region
init|=
name|regional_create
argument_list|()
decl_stmt|;
operator|*
name|res
operator|=
name|q
operator|->
name|res
expr_stmt|;
operator|(
operator|*
name|res
operator|)
operator|->
name|rcode
operator|=
name|LDNS_RCODE_SERVFAIL
expr_stmt|;
if|if
condition|(
name|region
operator|&&
name|buf
condition|)
block|{
name|ldns_buffer_clear
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ldns_buffer_write
argument_list|(
name|buf
argument_list|,
name|q
operator|->
name|msg
argument_list|,
name|q
operator|->
name|msg_len
argument_list|)
expr_stmt|;
name|ldns_buffer_flip
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|libworker_enter_result
argument_list|(
operator|*
name|res
argument_list|,
name|buf
argument_list|,
name|region
argument_list|,
name|q
operator|->
name|msg_security
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|res
operator|)
operator|->
name|answer_packet
operator|=
name|q
operator|->
name|msg
expr_stmt|;
operator|(
operator|*
name|res
operator|)
operator|->
name|answer_len
operator|=
operator|(
name|int
operator|)
name|q
operator|->
name|msg_len
expr_stmt|;
name|q
operator|->
name|msg
operator|=
name|NULL
expr_stmt|;
name|ldns_buffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|regional_destroy
argument_list|(
name|region
argument_list|)
expr_stmt|;
block|}
name|q
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
comment|/* delete the q from list */
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
operator|&
name|ctx
operator|->
name|queries
argument_list|,
name|q
operator|->
name|node
operator|.
name|key
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|num_async
operator|--
expr_stmt|;
name|context_query_delete
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cb
condition|)
return|return
literal|2
return|;
name|ub_resolve_free
argument_list|(
operator|*
name|res
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** process answer from bg worker */
end_comment

begin_function
specifier|static
name|int
name|process_answer
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
name|uint8_t
modifier|*
name|msg
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|ub_callback_t
name|cb
decl_stmt|;
name|void
modifier|*
name|cbarg
decl_stmt|;
name|struct
name|ub_result
modifier|*
name|res
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|process_answer_detail
argument_list|(
name|ctx
argument_list|,
name|msg
argument_list|,
name|len
argument_list|,
operator|&
name|cb
argument_list|,
operator|&
name|cbarg
argument_list|,
operator|&
name|err
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
comment|/* no locks held while calling callback, so that library is 	 * re-entrant. */
if|if
condition|(
name|r
operator|==
literal|2
condition|)
call|(
modifier|*
name|cb
call|)
argument_list|(
name|cbarg
argument_list|,
name|err
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|ub_process
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|uint8_t
modifier|*
name|msg
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|msg
operator|=
name|NULL
expr_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|rrpipe_lock
argument_list|)
expr_stmt|;
name|r
operator|=
name|tube_read_msg
argument_list|(
name|ctx
operator|->
name|rr_pipe
argument_list|,
operator|&
name|msg
argument_list|,
operator|&
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|rrpipe_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
return|return
name|UB_PIPE
return|;
elseif|else
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
operator|!
name|process_answer
argument_list|(
name|ctx
argument_list|,
name|msg
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|UB_PIPE
return|;
block|}
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
name|UB_NOERROR
return|;
block|}
end_function

begin_function
name|int
name|ub_wait
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|ub_callback_t
name|cb
decl_stmt|;
name|void
modifier|*
name|cbarg
decl_stmt|;
name|struct
name|ub_result
modifier|*
name|res
decl_stmt|;
name|int
name|r
decl_stmt|;
name|uint8_t
modifier|*
name|msg
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
comment|/* this is basically the same loop as _process(), but with changes. 	 * holds the rrpipe lock and waits with tube_wait */
while|while
condition|(
literal|1
condition|)
block|{
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|rrpipe_lock
argument_list|)
expr_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|num_async
operator|==
literal|0
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|rrpipe_lock
argument_list|)
expr_stmt|;
break|break;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
comment|/* keep rrpipe locked, while 		 * 	o waiting for pipe readable 		 * 	o parsing message 		 * 	o possibly decrementing num_async 		 * do callback without lock 		 */
name|r
operator|=
name|tube_wait
argument_list|(
name|ctx
operator|->
name|rr_pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|r
operator|=
name|tube_read_msg
argument_list|(
name|ctx
operator|->
name|rr_pipe
argument_list|,
operator|&
name|msg
argument_list|,
operator|&
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|rrpipe_lock
argument_list|)
expr_stmt|;
return|return
name|UB_PIPE
return|;
block|}
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|rrpipe_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|r
operator|=
name|process_answer_detail
argument_list|(
name|ctx
argument_list|,
name|msg
argument_list|,
name|len
argument_list|,
operator|&
name|cb
argument_list|,
operator|&
name|cbarg
argument_list|,
operator|&
name|err
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|rrpipe_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
return|return
name|UB_PIPE
return|;
if|if
condition|(
name|r
operator|==
literal|2
condition|)
call|(
modifier|*
name|cb
call|)
argument_list|(
name|cbarg
argument_list|,
name|err
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|rrpipe_lock
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|UB_NOERROR
return|;
block|}
end_function

begin_function
name|int
name|ub_resolve
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|rrtype
parameter_list|,
name|int
name|rrclass
parameter_list|,
name|struct
name|ub_result
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|ctx_query
modifier|*
name|q
decl_stmt|;
name|int
name|r
decl_stmt|;
operator|*
name|result
operator|=
name|NULL
expr_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|finalized
condition|)
block|{
name|r
operator|=
name|context_finalize
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
block|}
comment|/* create new ctx_query and attempt to add to the list */
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|q
operator|=
name|context_new
argument_list|(
name|ctx
argument_list|,
name|name
argument_list|,
name|rrtype
argument_list|,
name|rrclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
return|return
name|UB_NOMEM
return|;
comment|/* become a resolver thread for a bit */
name|r
operator|=
name|libworker_fg
argument_list|(
name|ctx
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
operator|&
name|ctx
operator|->
name|queries
argument_list|,
name|q
operator|->
name|node
operator|.
name|key
argument_list|)
expr_stmt|;
name|context_query_delete
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|q
operator|->
name|res
operator|->
name|answer_packet
operator|=
name|q
operator|->
name|msg
expr_stmt|;
name|q
operator|->
name|res
operator|->
name|answer_len
operator|=
operator|(
name|int
operator|)
name|q
operator|->
name|msg_len
expr_stmt|;
name|q
operator|->
name|msg
operator|=
name|NULL
expr_stmt|;
operator|*
name|result
operator|=
name|q
operator|->
name|res
expr_stmt|;
name|q
operator|->
name|res
operator|=
name|NULL
expr_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
operator|&
name|ctx
operator|->
name|queries
argument_list|,
name|q
operator|->
name|node
operator|.
name|key
argument_list|)
expr_stmt|;
name|context_query_delete
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
return|return
name|UB_NOERROR
return|;
block|}
end_function

begin_function
name|int
name|ub_resolve_async
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|rrtype
parameter_list|,
name|int
name|rrclass
parameter_list|,
name|void
modifier|*
name|mydata
parameter_list|,
name|ub_callback_t
name|callback
parameter_list|,
name|int
modifier|*
name|async_id
parameter_list|)
block|{
name|struct
name|ctx_query
modifier|*
name|q
decl_stmt|;
name|uint8_t
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|async_id
condition|)
operator|*
name|async_id
operator|=
literal|0
expr_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|finalized
condition|)
block|{
name|int
name|r
init|=
name|context_finalize
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
block|}
if|if
condition|(
operator|!
name|ctx
operator|->
name|created_bg
condition|)
block|{
name|int
name|r
decl_stmt|;
name|ctx
operator|->
name|created_bg
operator|=
literal|1
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|r
operator|=
name|libworker_bg
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|created_bg
operator|=
literal|0
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
block|}
else|else
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
block|}
comment|/* create new ctx_query and attempt to add to the list */
name|q
operator|=
name|context_new
argument_list|(
name|ctx
argument_list|,
name|name
argument_list|,
name|rrtype
argument_list|,
name|rrclass
argument_list|,
name|callback
argument_list|,
name|mydata
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
return|return
name|UB_NOMEM
return|;
comment|/* write over pipe to background worker */
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|msg
operator|=
name|context_serialize_new_query
argument_list|(
name|q
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
block|{
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
operator|&
name|ctx
operator|->
name|queries
argument_list|,
name|q
operator|->
name|node
operator|.
name|key
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|num_async
operator|--
expr_stmt|;
name|context_query_delete
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
return|return
name|UB_NOMEM
return|;
block|}
if|if
condition|(
name|async_id
condition|)
operator|*
name|async_id
operator|=
name|q
operator|->
name|querynum
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|qqpipe_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tube_write_msg
argument_list|(
name|ctx
operator|->
name|qq_pipe
argument_list|,
name|msg
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|qqpipe_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|UB_PIPE
return|;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|qqpipe_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|UB_NOERROR
return|;
block|}
end_function

begin_function
name|int
name|ub_cancel
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
name|int
name|async_id
parameter_list|)
block|{
name|struct
name|ctx_query
modifier|*
name|q
decl_stmt|;
name|uint8_t
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|len
init|=
literal|0
decl_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|q
operator|=
operator|(
expr|struct
name|ctx_query
operator|*
operator|)
name|rbtree_search
argument_list|(
operator|&
name|ctx
operator|->
name|queries
argument_list|,
operator|&
name|async_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|||
operator|!
name|q
operator|->
name|async
condition|)
block|{
comment|/* it is not there, so nothing to do */
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
return|return
name|UB_NOID
return|;
block|}
name|log_assert
argument_list|(
name|q
operator|->
name|async
argument_list|)
expr_stmt|;
name|q
operator|->
name|cancelled
operator|=
literal|1
expr_stmt|;
comment|/* delete it */
if|if
condition|(
operator|!
name|ctx
operator|->
name|dothread
condition|)
block|{
comment|/* if forked */
operator|(
name|void
operator|)
name|rbtree_delete
argument_list|(
operator|&
name|ctx
operator|->
name|queries
argument_list|,
name|q
operator|->
name|node
operator|.
name|key
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|num_async
operator|--
expr_stmt|;
name|msg
operator|=
name|context_serialize_cancel
argument_list|(
name|q
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|context_query_delete
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
block|{
return|return
name|UB_NOMEM
return|;
block|}
comment|/* send cancel to background worker */
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|qqpipe_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tube_write_msg
argument_list|(
name|ctx
operator|->
name|qq_pipe
argument_list|,
name|msg
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|qqpipe_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|UB_PIPE
return|;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|qqpipe_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
block|}
return|return
name|UB_NOERROR
return|;
block|}
end_function

begin_function
name|void
name|ub_resolve_free
parameter_list|(
name|struct
name|ub_result
modifier|*
name|result
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
return|return;
name|free
argument_list|(
name|result
operator|->
name|qname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|canonname
operator|!=
name|result
operator|->
name|qname
condition|)
name|free
argument_list|(
name|result
operator|->
name|canonname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|data
condition|)
for|for
control|(
name|p
operator|=
name|result
operator|->
name|data
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|free
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
operator|->
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
operator|->
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
operator|->
name|answer_packet
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
operator|->
name|why_bogus
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|ub_strerror
parameter_list|(
name|int
name|err
parameter_list|)
block|{
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|UB_NOERROR
case|:
return|return
literal|"no error"
return|;
case|case
name|UB_SOCKET
case|:
return|return
literal|"socket io error"
return|;
case|case
name|UB_NOMEM
case|:
return|return
literal|"out of memory"
return|;
case|case
name|UB_SYNTAX
case|:
return|return
literal|"syntax error"
return|;
case|case
name|UB_SERVFAIL
case|:
return|return
literal|"server failure"
return|;
case|case
name|UB_FORKFAIL
case|:
return|return
literal|"could not fork"
return|;
case|case
name|UB_INITFAIL
case|:
return|return
literal|"initialization failure"
return|;
case|case
name|UB_AFTERFINAL
case|:
return|return
literal|"setting change after finalize"
return|;
case|case
name|UB_PIPE
case|:
return|return
literal|"error in pipe communication with async"
return|;
case|case
name|UB_READFILE
case|:
return|return
literal|"error reading file"
return|;
case|case
name|UB_NOID
case|:
return|return
literal|"error async_id does not exist"
return|;
default|default:
return|return
literal|"unknown error"
return|;
block|}
block|}
end_function

begin_function
name|int
name|ub_ctx_set_fwd
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|sockaddr_storage
name|storage
decl_stmt|;
name|socklen_t
name|stlen
decl_stmt|;
name|struct
name|config_stub
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|dupl
decl_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|finalized
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|UB_AFTERFINAL
return|;
block|}
if|if
condition|(
operator|!
name|addr
condition|)
block|{
comment|/* disable fwd mode - the root stub should be first. */
if|if
condition|(
name|ctx
operator|->
name|env
operator|->
name|cfg
operator|->
name|forwards
operator|&&
name|strcmp
argument_list|(
name|ctx
operator|->
name|env
operator|->
name|cfg
operator|->
name|forwards
operator|->
name|name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|ctx
operator|->
name|env
operator|->
name|cfg
operator|->
name|forwards
expr_stmt|;
name|ctx
operator|->
name|env
operator|->
name|cfg
operator|->
name|forwards
operator|=
name|s
operator|->
name|next
expr_stmt|;
name|s
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|config_delstubs
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
return|return
name|UB_NOERROR
return|;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
comment|/* check syntax for addr */
if|if
condition|(
operator|!
name|extstrtoaddr
argument_list|(
name|addr
argument_list|,
operator|&
name|storage
argument_list|,
operator|&
name|stlen
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|UB_SYNTAX
return|;
block|}
comment|/* it parses, add root stub in front of list */
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|env
operator|->
name|cfg
operator|->
name|forwards
operator|||
name|strcmp
argument_list|(
name|ctx
operator|->
name|env
operator|->
name|cfg
operator|->
name|forwards
operator|->
name|name
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|s
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|UB_NOMEM
return|;
block|}
name|s
operator|->
name|name
operator|=
name|strdup
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|name
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|UB_NOMEM
return|;
block|}
name|s
operator|->
name|next
operator|=
name|ctx
operator|->
name|env
operator|->
name|cfg
operator|->
name|forwards
expr_stmt|;
name|ctx
operator|->
name|env
operator|->
name|cfg
operator|->
name|forwards
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|log_assert
argument_list|(
name|ctx
operator|->
name|env
operator|->
name|cfg
operator|->
name|forwards
argument_list|)
expr_stmt|;
name|s
operator|=
name|ctx
operator|->
name|env
operator|->
name|cfg
operator|->
name|forwards
expr_stmt|;
block|}
name|dupl
operator|=
name|strdup
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dupl
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|UB_NOMEM
return|;
block|}
if|if
condition|(
operator|!
name|cfg_strlist_insert
argument_list|(
operator|&
name|s
operator|->
name|addrs
argument_list|,
name|dupl
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|dupl
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|UB_NOMEM
return|;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
return|return
name|UB_NOERROR
return|;
block|}
end_function

begin_function
name|int
name|ub_ctx_resolvconf
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|FILE
modifier|*
name|in
decl_stmt|;
name|int
name|numserv
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|parse
decl_stmt|,
modifier|*
name|addr
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|UB_ON_WINDOWS
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAVE_WINDOWS_H
argument_list|)
name|fname
operator|=
literal|"/etc/resolv.conf"
expr_stmt|;
else|#
directive|else
name|FIXED_INFO
modifier|*
name|info
decl_stmt|;
name|ULONG
name|buflen
init|=
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
decl_stmt|;
name|IP_ADDR_STRING
modifier|*
name|ptr
decl_stmt|;
name|info
operator|=
operator|(
name|FIXED_INFO
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FIXED_INFO
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
return|return
name|UB_READFILE
return|;
if|if
condition|(
name|GetNetworkParams
argument_list|(
name|info
argument_list|,
operator|&
name|buflen
argument_list|)
operator|==
name|ERROR_BUFFER_OVERFLOW
condition|)
block|{
name|free
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|info
operator|=
operator|(
name|FIXED_INFO
operator|*
operator|)
name|malloc
argument_list|(
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
return|return
name|UB_READFILE
return|;
block|}
if|if
condition|(
name|GetNetworkParams
argument_list|(
name|info
argument_list|,
operator|&
name|buflen
argument_list|)
operator|==
name|NO_ERROR
condition|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|ptr
operator|=
operator|&
operator|(
name|info
operator|->
name|DnsServerList
operator|)
expr_stmt|;
while|while
condition|(
name|ptr
condition|)
block|{
name|numserv
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|ub_ctx_set_fwd
argument_list|(
name|ctx
argument_list|,
name|ptr
operator|->
name|IpAddress
operator|.
name|String
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|free
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
name|ptr
operator|=
name|ptr
operator|->
name|Next
expr_stmt|;
block|}
name|free
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|numserv
operator|==
literal|0
condition|)
return|return
name|UB_READFILE
return|;
return|return
name|UB_NOERROR
return|;
block|}
name|free
argument_list|(
name|info
argument_list|)
expr_stmt|;
return|return
name|UB_READFILE
return|;
endif|#
directive|endif
comment|/* WINDOWS */
block|}
name|in
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in
condition|)
block|{
comment|/* error in errno! perror(fname) */
return|return
name|UB_READFILE
return|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|in
argument_list|)
condition|)
block|{
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|parse
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|*
name|parse
operator|==
literal|' '
operator|||
operator|*
name|parse
operator|==
literal|'\t'
condition|)
name|parse
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|parse
argument_list|,
literal|"nameserver"
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
block|{
name|numserv
operator|++
expr_stmt|;
name|parse
operator|+=
literal|10
expr_stmt|;
comment|/* skip 'nameserver' */
comment|/* skip whitespace */
while|while
condition|(
operator|*
name|parse
operator|==
literal|' '
operator|||
operator|*
name|parse
operator|==
literal|'\t'
condition|)
name|parse
operator|++
expr_stmt|;
name|addr
operator|=
name|parse
expr_stmt|;
comment|/* skip [0-9a-fA-F.:]*, i.e. IP4 and IP6 address */
while|while
condition|(
name|isxdigit
argument_list|(
operator|*
name|parse
argument_list|)
operator|||
operator|*
name|parse
operator|==
literal|'.'
operator|||
operator|*
name|parse
operator|==
literal|':'
condition|)
name|parse
operator|++
expr_stmt|;
comment|/* terminate after the address, remove newline */
operator|*
name|parse
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|ub_ctx_set_fwd
argument_list|(
name|ctx
argument_list|,
name|addr
argument_list|)
operator|)
operator|!=
name|UB_NOERROR
condition|)
block|{
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
block|}
block|}
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|numserv
operator|==
literal|0
condition|)
block|{
comment|/* from resolv.conf(5) if none given, use localhost */
return|return
name|ub_ctx_set_fwd
argument_list|(
name|ctx
argument_list|,
literal|"127.0.0.1"
argument_list|)
return|;
block|}
return|return
name|UB_NOERROR
return|;
block|}
end_function

begin_function
name|int
name|ub_ctx_hosts
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|FILE
modifier|*
name|in
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|,
name|ldata
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|parse
decl_stmt|,
modifier|*
name|addr
decl_stmt|,
modifier|*
name|name
decl_stmt|,
modifier|*
name|ins
decl_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|finalized
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|UB_AFTERFINAL
return|;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|UB_ON_WINDOWS
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_WINDOWS_H
argument_list|)
comment|/* 		 * If this is Windows NT/XP/2K it's in 		 * %WINDIR%\system32\drivers\etc\hosts. 		 * If this is Windows 95/98/Me it's in %WINDIR%\hosts. 		 */
name|name
operator|=
name|getenv
argument_list|(
literal|"WINDIR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|name
argument_list|,
literal|"\\system32\\drivers\\etc\\hosts"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|ub_ctx_hosts
argument_list|(
name|ctx
argument_list|,
name|buf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|name
argument_list|,
literal|"\\hosts"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ub_ctx_hosts
argument_list|(
name|ctx
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
return|return
name|UB_READFILE
return|;
else|#
directive|else
name|fname
operator|=
literal|"/etc/hosts"
expr_stmt|;
endif|#
directive|endif
comment|/* WIN32 */
block|}
name|in
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in
condition|)
block|{
comment|/* error in errno! perror(fname) */
return|return
name|UB_READFILE
return|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|in
argument_list|)
condition|)
block|{
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|parse
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|*
name|parse
operator|==
literal|' '
operator|||
operator|*
name|parse
operator|==
literal|'\t'
condition|)
name|parse
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|parse
operator|==
literal|'#'
condition|)
continue|continue;
comment|/* skip comment */
comment|/* format:<addr> spaces<name> spaces<name> ... */
name|addr
operator|=
name|parse
expr_stmt|;
comment|/* skip addr */
while|while
condition|(
name|isxdigit
argument_list|(
operator|*
name|parse
argument_list|)
operator|||
operator|*
name|parse
operator|==
literal|'.'
operator|||
operator|*
name|parse
operator|==
literal|':'
condition|)
name|parse
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|parse
operator|==
literal|'\n'
operator|||
operator|*
name|parse
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|*
name|parse
operator|==
literal|'%'
condition|)
continue|continue;
comment|/* ignore macOSX fe80::1%lo0 localhost */
if|if
condition|(
operator|*
name|parse
operator|!=
literal|' '
operator|&&
operator|*
name|parse
operator|!=
literal|'\t'
condition|)
block|{
comment|/* must have whitespace after address */
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|UB_SYNTAX
return|;
block|}
operator|*
name|parse
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* end delimiter for addr ... */
comment|/* go to names and add them */
while|while
condition|(
operator|*
name|parse
condition|)
block|{
while|while
condition|(
operator|*
name|parse
operator|==
literal|' '
operator|||
operator|*
name|parse
operator|==
literal|'\t'
operator|||
operator|*
name|parse
operator|==
literal|'\n'
condition|)
name|parse
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|parse
operator|==
literal|0
operator|||
operator|*
name|parse
operator|==
literal|'#'
condition|)
break|break;
comment|/* skip name, allows (too) many printable characters */
name|name
operator|=
name|parse
expr_stmt|;
while|while
condition|(
literal|'!'
operator|<=
operator|*
name|parse
operator|&&
operator|*
name|parse
operator|<=
literal|'~'
condition|)
name|parse
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|parse
condition|)
operator|*
name|parse
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* end delimiter for name */
name|snprintf
argument_list|(
name|ldata
argument_list|,
sizeof|sizeof
argument_list|(
name|ldata
argument_list|)
argument_list|,
literal|"%s %s %s"
argument_list|,
name|name
argument_list|,
name|str_is_ip6
argument_list|(
name|addr
argument_list|)
condition|?
literal|"AAAA"
else|:
literal|"A"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ins
operator|=
name|strdup
argument_list|(
name|ldata
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ins
condition|)
block|{
comment|/* out of memory */
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|UB_NOMEM
return|;
block|}
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cfg_strlist_insert
argument_list|(
operator|&
name|ctx
operator|->
name|env
operator|->
name|cfg
operator|->
name|local_data
argument_list|,
name|ins
argument_list|)
condition|)
block|{
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ins
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|UB_NOMEM
return|;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|UB_NOERROR
return|;
block|}
end_function

begin_comment
comment|/** finalize the context, if not already finalized */
end_comment

begin_function
specifier|static
name|int
name|ub_ctx_finalize
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|res
init|=
literal|0
decl_stmt|;
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|finalized
condition|)
block|{
name|res
operator|=
name|context_finalize
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Print local zones and RR data */
end_comment

begin_function
name|int
name|ub_ctx_print_local_zones
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|int
name|res
init|=
name|ub_ctx_finalize
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
condition|)
return|return
name|res
return|;
name|local_zones_print
argument_list|(
name|ctx
operator|->
name|local_zones
argument_list|)
expr_stmt|;
return|return
name|UB_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Add a new zone */
end_comment

begin_function
name|int
name|ub_ctx_zone_add
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|zone_name
parameter_list|,
specifier|const
name|char
modifier|*
name|zone_type
parameter_list|)
block|{
name|enum
name|localzone_type
name|t
decl_stmt|;
name|struct
name|local_zone
modifier|*
name|z
decl_stmt|;
name|uint8_t
modifier|*
name|nm
decl_stmt|;
name|int
name|nmlabs
decl_stmt|;
name|size_t
name|nmlen
decl_stmt|;
name|int
name|res
init|=
name|ub_ctx_finalize
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
condition|)
return|return
name|res
return|;
if|if
condition|(
operator|!
name|local_zone_str2type
argument_list|(
name|zone_type
argument_list|,
operator|&
name|t
argument_list|)
condition|)
block|{
return|return
name|UB_SYNTAX
return|;
block|}
if|if
condition|(
operator|!
name|parse_dname
argument_list|(
name|zone_name
argument_list|,
operator|&
name|nm
argument_list|,
operator|&
name|nmlen
argument_list|,
operator|&
name|nmlabs
argument_list|)
condition|)
block|{
return|return
name|UB_SYNTAX
return|;
block|}
name|lock_quick_lock
argument_list|(
operator|&
name|ctx
operator|->
name|local_zones
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|z
operator|=
name|local_zones_find
argument_list|(
name|ctx
operator|->
name|local_zones
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|nmlabs
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
operator|)
condition|)
block|{
comment|/* already present in tree */
name|lock_rw_wrlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
name|z
operator|->
name|type
operator|=
name|t
expr_stmt|;
comment|/* update type anyway */
name|lock_rw_unlock
argument_list|(
operator|&
name|z
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lock_quick_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|local_zones
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
return|return
name|UB_NOERROR
return|;
block|}
if|if
condition|(
operator|!
name|local_zones_add_zone
argument_list|(
name|ctx
operator|->
name|local_zones
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|nmlabs
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|t
argument_list|)
condition|)
block|{
name|lock_quick_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|local_zones
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|UB_NOMEM
return|;
block|}
name|lock_quick_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|local_zones
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|UB_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Remove zone */
end_comment

begin_function
name|int
name|ub_ctx_zone_remove
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|zone_name
parameter_list|)
block|{
name|struct
name|local_zone
modifier|*
name|z
decl_stmt|;
name|uint8_t
modifier|*
name|nm
decl_stmt|;
name|int
name|nmlabs
decl_stmt|;
name|size_t
name|nmlen
decl_stmt|;
name|int
name|res
init|=
name|ub_ctx_finalize
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
condition|)
return|return
name|res
return|;
if|if
condition|(
operator|!
name|parse_dname
argument_list|(
name|zone_name
argument_list|,
operator|&
name|nm
argument_list|,
operator|&
name|nmlen
argument_list|,
operator|&
name|nmlabs
argument_list|)
condition|)
block|{
return|return
name|UB_SYNTAX
return|;
block|}
name|lock_quick_lock
argument_list|(
operator|&
name|ctx
operator|->
name|local_zones
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|z
operator|=
name|local_zones_find
argument_list|(
name|ctx
operator|->
name|local_zones
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|nmlabs
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
operator|)
condition|)
block|{
comment|/* present in tree */
name|local_zones_del_zone
argument_list|(
name|ctx
operator|->
name|local_zones
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
name|lock_quick_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|local_zones
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
return|return
name|UB_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Add new RR data */
end_comment

begin_function
name|int
name|ub_ctx_data_add
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|)
block|{
name|ldns_buffer
modifier|*
name|buf
decl_stmt|;
name|int
name|res
init|=
name|ub_ctx_finalize
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
condition|)
return|return
name|res
return|;
name|lock_basic_lock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
name|buf
operator|=
name|ldns_buffer_new
argument_list|(
name|ctx
operator|->
name|env
operator|->
name|cfg
operator|->
name|msg_buffer_size
argument_list|)
expr_stmt|;
name|lock_basic_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|cfglock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
name|UB_NOMEM
return|;
name|res
operator|=
name|local_zones_add_RR
argument_list|(
name|ctx
operator|->
name|local_zones
argument_list|,
name|data
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|ldns_buffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
name|res
operator|)
condition|?
name|UB_NOMEM
else|:
name|UB_NOERROR
return|;
block|}
end_function

begin_comment
comment|/* Remove RR data */
end_comment

begin_function
name|int
name|ub_ctx_data_remove
parameter_list|(
name|struct
name|ub_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|)
block|{
name|uint8_t
modifier|*
name|nm
decl_stmt|;
name|int
name|nmlabs
decl_stmt|;
name|size_t
name|nmlen
decl_stmt|;
name|int
name|res
init|=
name|ub_ctx_finalize
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
condition|)
return|return
name|res
return|;
if|if
condition|(
operator|!
name|parse_dname
argument_list|(
name|data
argument_list|,
operator|&
name|nm
argument_list|,
operator|&
name|nmlen
argument_list|,
operator|&
name|nmlabs
argument_list|)
condition|)
return|return
name|UB_SYNTAX
return|;
name|local_zones_del_data
argument_list|(
name|ctx
operator|->
name|local_zones
argument_list|,
name|nm
argument_list|,
name|nmlen
argument_list|,
name|nmlabs
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
return|return
name|UB_NOERROR
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|ub_version
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|PACKAGE_VERSION
return|;
block|}
end_function

end_unit

