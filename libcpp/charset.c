begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* CPP Library - charsets    Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2006    Free Software Foundation, Inc.     Broken out of c-lex.c Apr 2003, adding valid C99 UCN ranges.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"internal.h"
end_include

begin_comment
comment|/* Character set handling for C-family languages.     Terminological note: In what follows, "charset" or "character set"    will be taken to mean both an abstract set of characters and an    encoding for that set.     The C99 standard discusses two character sets: source and execution.    The source character set is used for internal processing in translation    phases 1 through 4; the execution character set is used thereafter.    Both are required by 5.2.1.2p1 to be multibyte encodings, not wide    character encodings (see 3.7.2, 3.7.3 for the standardese meanings    of these terms).  Furthermore, the "basic character set" (listed in    5.2.1p3) is to be encoded in each with values one byte wide, and is    to appear in the initial shift state.     It is not explicitly mentioned, but there is also a "wide execution    character set" used to encode wide character constants and wide    string literals; this is supposed to be the result of applying the    standard library function mbstowcs() to an equivalent narrow string    (6.4.5p5).  However, the behavior of hexadecimal and octal    \-escapes is at odds with this; they are supposed to be translated    directly to wchar_t values (6.4.4.4p5,6).     The source character set is not necessarily the character set used    to encode physical source files on disk; translation phase 1 converts    from whatever that encoding is to the source character set.     The presence of universal character names in C99 (6.4.3 et seq.)    forces the source character set to be isomorphic to ISO 10646,    that is, Unicode.  There is no such constraint on the execution    character set; note also that the conversion from source to    execution character set does not occur for identifiers (5.1.1.2p1#5).     For convenience of implementation, the source character set's    encoding of the basic character set should be identical to the    execution character set OF THE HOST SYSTEM's encoding of the basic    character set, and it should not be a state-dependent encoding.     cpplib uses UTF-8 or UTF-EBCDIC for the source character set,    depending on whether the host is based on ASCII or EBCDIC (see    respectively Unicode section 2.3/ISO10646 Amendment 2, and Unicode    Technical Report #16).  With limited exceptions, it relies on the    system library's iconv() primitive to do charset conversion    (specified in SUSv2).  */
end_comment

begin_if
if|#
directive|if
operator|!
name|HAVE_ICONV
end_if

begin_comment
comment|/* Make certain that the uses of iconv(), iconv_open(), iconv_close()    below, which are guarded only by if statements with compile-time    constant conditions, do not cause link errors.  */
end_comment

begin_define
define|#
directive|define
name|iconv_open
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(errno = EINVAL, (iconv_t)-1)
end_define

begin_define
define|#
directive|define
name|iconv
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|)
value|(errno = EINVAL, (size_t)-1)
end_define

begin_define
define|#
directive|define
name|iconv_close
parameter_list|(
name|x
parameter_list|)
value|(void)0
end_define

begin_define
define|#
directive|define
name|ICONV_CONST
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HOST_CHARSET
operator|==
name|HOST_CHARSET_ASCII
end_if

begin_define
define|#
directive|define
name|SOURCE_CHARSET
value|"UTF-8"
end_define

begin_define
define|#
directive|define
name|LAST_POSSIBLY_BASIC_SOURCE_CHAR
value|0x7e
end_define

begin_elif
elif|#
directive|elif
name|HOST_CHARSET
operator|==
name|HOST_CHARSET_EBCDIC
end_elif

begin_define
define|#
directive|define
name|SOURCE_CHARSET
value|"UTF-EBCDIC"
end_define

begin_define
define|#
directive|define
name|LAST_POSSIBLY_BASIC_SOURCE_CHAR
value|0xFF
end_define

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
literal|"Unrecognized basic host character set"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EILSEQ
end_ifndef

begin_define
define|#
directive|define
name|EILSEQ
value|EINVAL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This structure is used for a resizable string buffer throughout.  */
end_comment

begin_comment
comment|/* Don't call it strbuf, as that conflicts with unistd.h on systems    such as DYNIX/ptx where unistd.h includes stropts.h.  */
end_comment

begin_struct
struct|struct
name|_cpp_strbuf
block|{
name|uchar
modifier|*
name|text
decl_stmt|;
name|size_t
name|asize
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is enough to hold any string that fits on a single 80-column    line, even if iconv quadruples its size (e.g. conversion from    ASCII to UTF-32) rounded up to a power of two.  */
end_comment

begin_define
define|#
directive|define
name|OUTBUF_BLOCK_SIZE
value|256
end_define

begin_comment
comment|/* Conversions between UTF-8 and UTF-16/32 are implemented by custom    logic.  This is because a depressing number of systems lack iconv,    or have have iconv libraries that do not do these conversions, so    we need a fallback implementation for them.  To ensure the fallback    doesn't break due to neglect, it is used on all systems.     UTF-32 encoding is nice and simple: a four-byte binary number,    constrained to the range 00000000-7FFFFFFF to avoid questions of    signedness.  We do have to cope with big- and little-endian    variants.     UTF-16 encoding uses two-byte binary numbers, again in big- and    little-endian variants, for all values in the 00000000-0000FFFF    range.  Values in the 00010000-0010FFFF range are encoded as pairs    of two-byte numbers, called "surrogate pairs": given a number S in    this range, it is mapped to a pair (H, L) as follows:       H = (S - 0x10000) / 0x400 + 0xD800      L = (S - 0x10000) % 0x400 + 0xDC00     Two-byte values in the D800...DFFF range are ill-formed except as a    component of a surrogate pair.  Even if the encoding within a    two-byte value is little-endian, the H member of the surrogate pair    comes first.     There is no way to encode values in the 00110000-7FFFFFFF range,    which is not currently a problem as there are no assigned code    points in that range; however, the author expects that it will    eventually become necessary to abandon UTF-16 due to this    limitation.  Note also that, because of these pairs, UTF-16 does    not meet the requirements of the C standard for a wide character    encoding (see 3.7.3 and 6.4.4.4p11).     UTF-8 encoding looks like this:     value range	       encoded as    00000000-0000007F   0xxxxxxx    00000080-000007FF   110xxxxx 10xxxxxx    00000800-0000FFFF   1110xxxx 10xxxxxx 10xxxxxx    00010000-001FFFFF   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx    00200000-03FFFFFF   111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx    04000000-7FFFFFFF   1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx     Values in the 0000D800 ... 0000DFFF range (surrogates) are invalid,    which means that three-byte sequences ED xx yy, with A0<= xx<= BF,    never occur.  Note also that any value that can be encoded by a    given row of the table can also be encoded by all successive rows,    but this is not done; only the shortest possible encoding for any    given value is valid.  For instance, the character 07C0 could be    encoded as any of DF 80, E0 9F 80, F0 80 9F 80, F8 80 80 9F 80, or    FC 80 80 80 9F 80.  Only the first is valid.     An implementation note: the transformation from UTF-16 to UTF-8, or    vice versa, is easiest done by using UTF-32 as an intermediary.  */
end_comment

begin_comment
comment|/* Internal primitives which go from an UTF-8 byte stream to native-endian    UTF-32 in a cppchar_t, or vice versa; this avoids an extra marshal/unmarshal    operation in several places below.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|one_utf8_to_cppchar
parameter_list|(
specifier|const
name|uchar
modifier|*
modifier|*
name|inbufp
parameter_list|,
name|size_t
modifier|*
name|inbytesleftp
parameter_list|,
name|cppchar_t
modifier|*
name|cp
parameter_list|)
block|{
specifier|static
specifier|const
name|uchar
name|masks
index|[
literal|6
index|]
init|=
block|{
literal|0x7F
block|,
literal|0x1F
block|,
literal|0x0F
block|,
literal|0x07
block|,
literal|0x02
block|,
literal|0x01
block|}
decl_stmt|;
specifier|static
specifier|const
name|uchar
name|patns
index|[
literal|6
index|]
init|=
block|{
literal|0x00
block|,
literal|0xC0
block|,
literal|0xE0
block|,
literal|0xF0
block|,
literal|0xF8
block|,
literal|0xFC
block|}
decl_stmt|;
name|cppchar_t
name|c
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|inbuf
init|=
operator|*
name|inbufp
decl_stmt|;
name|size_t
name|nbytes
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|inbytesleftp
operator|<
literal|1
condition|)
return|return
name|EINVAL
return|;
name|c
operator|=
operator|*
name|inbuf
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0x80
condition|)
block|{
operator|*
name|cp
operator|=
name|c
expr_stmt|;
operator|*
name|inbytesleftp
operator|-=
literal|1
expr_stmt|;
operator|*
name|inbufp
operator|+=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* The number of leading 1-bits in the first byte indicates how many      bytes follow.  */
for|for
control|(
name|nbytes
operator|=
literal|2
init|;
name|nbytes
operator|<
literal|7
condition|;
name|nbytes
operator|++
control|)
if|if
condition|(
operator|(
name|c
operator|&
operator|~
name|masks
index|[
name|nbytes
operator|-
literal|1
index|]
operator|)
operator|==
name|patns
index|[
name|nbytes
operator|-
literal|1
index|]
condition|)
goto|goto
name|found
goto|;
return|return
name|EILSEQ
return|;
name|found
label|:
if|if
condition|(
operator|*
name|inbytesleftp
operator|<
name|nbytes
condition|)
return|return
name|EINVAL
return|;
name|c
operator|=
operator|(
name|c
operator|&
name|masks
index|[
name|nbytes
operator|-
literal|1
index|]
operator|)
expr_stmt|;
name|inbuf
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nbytes
condition|;
name|i
operator|++
control|)
block|{
name|cppchar_t
name|n
init|=
operator|*
name|inbuf
operator|++
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|&
literal|0xC0
operator|)
operator|!=
literal|0x80
condition|)
return|return
name|EILSEQ
return|;
name|c
operator|=
operator|(
operator|(
name|c
operator|<<
literal|6
operator|)
operator|+
operator|(
name|n
operator|&
literal|0x3F
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Make sure the shortest possible encoding was used.  */
if|if
condition|(
name|c
operator|<=
literal|0x7F
operator|&&
name|nbytes
operator|>
literal|1
condition|)
return|return
name|EILSEQ
return|;
if|if
condition|(
name|c
operator|<=
literal|0x7FF
operator|&&
name|nbytes
operator|>
literal|2
condition|)
return|return
name|EILSEQ
return|;
if|if
condition|(
name|c
operator|<=
literal|0xFFFF
operator|&&
name|nbytes
operator|>
literal|3
condition|)
return|return
name|EILSEQ
return|;
if|if
condition|(
name|c
operator|<=
literal|0x1FFFFF
operator|&&
name|nbytes
operator|>
literal|4
condition|)
return|return
name|EILSEQ
return|;
if|if
condition|(
name|c
operator|<=
literal|0x3FFFFFF
operator|&&
name|nbytes
operator|>
literal|5
condition|)
return|return
name|EILSEQ
return|;
comment|/* Make sure the character is valid.  */
if|if
condition|(
name|c
operator|>
literal|0x7FFFFFFF
operator|||
operator|(
name|c
operator|>=
literal|0xD800
operator|&&
name|c
operator|<=
literal|0xDFFF
operator|)
condition|)
return|return
name|EILSEQ
return|;
operator|*
name|cp
operator|=
name|c
expr_stmt|;
operator|*
name|inbufp
operator|=
name|inbuf
expr_stmt|;
operator|*
name|inbytesleftp
operator|-=
name|nbytes
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|one_cppchar_to_utf8
parameter_list|(
name|cppchar_t
name|c
parameter_list|,
name|uchar
modifier|*
modifier|*
name|outbufp
parameter_list|,
name|size_t
modifier|*
name|outbytesleftp
parameter_list|)
block|{
specifier|static
specifier|const
name|uchar
name|masks
index|[
literal|6
index|]
init|=
block|{
literal|0x00
block|,
literal|0xC0
block|,
literal|0xE0
block|,
literal|0xF0
block|,
literal|0xF8
block|,
literal|0xFC
block|}
decl_stmt|;
specifier|static
specifier|const
name|uchar
name|limits
index|[
literal|6
index|]
init|=
block|{
literal|0x80
block|,
literal|0xE0
block|,
literal|0xF0
block|,
literal|0xF8
block|,
literal|0xFC
block|,
literal|0xFE
block|}
decl_stmt|;
name|size_t
name|nbytes
decl_stmt|;
name|uchar
name|buf
index|[
literal|6
index|]
decl_stmt|,
modifier|*
name|p
init|=
operator|&
name|buf
index|[
literal|6
index|]
decl_stmt|;
name|uchar
modifier|*
name|outbuf
init|=
operator|*
name|outbufp
decl_stmt|;
name|nbytes
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0x80
condition|)
operator|*
operator|--
name|p
operator|=
name|c
expr_stmt|;
else|else
block|{
do|do
block|{
operator|*
operator|--
name|p
operator|=
operator|(
operator|(
name|c
operator|&
literal|0x3F
operator|)
operator||
literal|0x80
operator|)
expr_stmt|;
name|c
operator|>>=
literal|6
expr_stmt|;
name|nbytes
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|>=
literal|0x3F
operator|||
operator|(
name|c
operator|&
name|limits
index|[
name|nbytes
operator|-
literal|1
index|]
operator|)
condition|)
do|;
operator|*
operator|--
name|p
operator|=
operator|(
name|c
operator||
name|masks
index|[
name|nbytes
operator|-
literal|1
index|]
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|outbytesleftp
operator|<
name|nbytes
condition|)
return|return
name|E2BIG
return|;
while|while
condition|(
name|p
operator|<
operator|&
name|buf
index|[
literal|6
index|]
condition|)
operator|*
name|outbuf
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|outbytesleftp
operator|-=
name|nbytes
expr_stmt|;
operator|*
name|outbufp
operator|=
name|outbuf
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The following four functions transform one character between the two    encodings named in the function name.  All have the signature    int (*)(iconv_t bigend, const uchar **inbufp, size_t *inbytesleftp,            uchar **outbufp, size_t *outbytesleftp)     BIGEND must have the value 0 or 1, coerced to (iconv_t); it is    interpreted as a boolean indicating whether big-endian or    little-endian encoding is to be used for the member of the pair    that is not UTF-8.     INBUFP, INBYTESLEFTP, OUTBUFP, OUTBYTESLEFTP work exactly as they    do for iconv.     The return value is either 0 for success, or an errno value for    failure, which may be E2BIG (need more space), EILSEQ (ill-formed    input sequence), ir EINVAL (incomplete input sequence).  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|one_utf8_to_utf32
parameter_list|(
name|iconv_t
name|bigend
parameter_list|,
specifier|const
name|uchar
modifier|*
modifier|*
name|inbufp
parameter_list|,
name|size_t
modifier|*
name|inbytesleftp
parameter_list|,
name|uchar
modifier|*
modifier|*
name|outbufp
parameter_list|,
name|size_t
modifier|*
name|outbytesleftp
parameter_list|)
block|{
name|uchar
modifier|*
name|outbuf
decl_stmt|;
name|cppchar_t
name|s
init|=
literal|0
decl_stmt|;
name|int
name|rval
decl_stmt|;
comment|/* Check for space first, since we know exactly how much we need.  */
if|if
condition|(
operator|*
name|outbytesleftp
operator|<
literal|4
condition|)
return|return
name|E2BIG
return|;
name|rval
operator|=
name|one_utf8_to_cppchar
argument_list|(
name|inbufp
argument_list|,
name|inbytesleftp
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
name|outbuf
operator|=
operator|*
name|outbufp
expr_stmt|;
name|outbuf
index|[
name|bigend
condition|?
literal|3
else|:
literal|0
index|]
operator|=
operator|(
name|s
operator|&
literal|0x000000FF
operator|)
expr_stmt|;
name|outbuf
index|[
name|bigend
condition|?
literal|2
else|:
literal|1
index|]
operator|=
operator|(
name|s
operator|&
literal|0x0000FF00
operator|)
operator|>>
literal|8
expr_stmt|;
name|outbuf
index|[
name|bigend
condition|?
literal|1
else|:
literal|2
index|]
operator|=
operator|(
name|s
operator|&
literal|0x00FF0000
operator|)
operator|>>
literal|16
expr_stmt|;
name|outbuf
index|[
name|bigend
condition|?
literal|0
else|:
literal|3
index|]
operator|=
operator|(
name|s
operator|&
literal|0xFF000000
operator|)
operator|>>
literal|24
expr_stmt|;
operator|*
name|outbufp
operator|+=
literal|4
expr_stmt|;
operator|*
name|outbytesleftp
operator|-=
literal|4
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|one_utf32_to_utf8
parameter_list|(
name|iconv_t
name|bigend
parameter_list|,
specifier|const
name|uchar
modifier|*
modifier|*
name|inbufp
parameter_list|,
name|size_t
modifier|*
name|inbytesleftp
parameter_list|,
name|uchar
modifier|*
modifier|*
name|outbufp
parameter_list|,
name|size_t
modifier|*
name|outbytesleftp
parameter_list|)
block|{
name|cppchar_t
name|s
decl_stmt|;
name|int
name|rval
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|inbuf
decl_stmt|;
if|if
condition|(
operator|*
name|inbytesleftp
operator|<
literal|4
condition|)
return|return
name|EINVAL
return|;
name|inbuf
operator|=
operator|*
name|inbufp
expr_stmt|;
name|s
operator|=
name|inbuf
index|[
name|bigend
condition|?
literal|0
else|:
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
name|s
operator|+=
name|inbuf
index|[
name|bigend
condition|?
literal|1
else|:
literal|2
index|]
operator|<<
literal|16
expr_stmt|;
name|s
operator|+=
name|inbuf
index|[
name|bigend
condition|?
literal|2
else|:
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
name|s
operator|+=
name|inbuf
index|[
name|bigend
condition|?
literal|3
else|:
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|>=
literal|0x7FFFFFFF
operator|||
operator|(
name|s
operator|>=
literal|0xD800
operator|&&
name|s
operator|<=
literal|0xDFFF
operator|)
condition|)
return|return
name|EILSEQ
return|;
name|rval
operator|=
name|one_cppchar_to_utf8
argument_list|(
name|s
argument_list|,
name|outbufp
argument_list|,
name|outbytesleftp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
operator|*
name|inbufp
operator|+=
literal|4
expr_stmt|;
operator|*
name|inbytesleftp
operator|-=
literal|4
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|one_utf8_to_utf16
parameter_list|(
name|iconv_t
name|bigend
parameter_list|,
specifier|const
name|uchar
modifier|*
modifier|*
name|inbufp
parameter_list|,
name|size_t
modifier|*
name|inbytesleftp
parameter_list|,
name|uchar
modifier|*
modifier|*
name|outbufp
parameter_list|,
name|size_t
modifier|*
name|outbytesleftp
parameter_list|)
block|{
name|int
name|rval
decl_stmt|;
name|cppchar_t
name|s
init|=
literal|0
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|save_inbuf
init|=
operator|*
name|inbufp
decl_stmt|;
name|size_t
name|save_inbytesleft
init|=
operator|*
name|inbytesleftp
decl_stmt|;
name|uchar
modifier|*
name|outbuf
init|=
operator|*
name|outbufp
decl_stmt|;
name|rval
operator|=
name|one_utf8_to_cppchar
argument_list|(
name|inbufp
argument_list|,
name|inbytesleftp
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
if|if
condition|(
name|s
operator|>
literal|0x0010FFFF
condition|)
block|{
operator|*
name|inbufp
operator|=
name|save_inbuf
expr_stmt|;
operator|*
name|inbytesleftp
operator|=
name|save_inbytesleft
expr_stmt|;
return|return
name|EILSEQ
return|;
block|}
if|if
condition|(
name|s
operator|<
literal|0xFFFF
condition|)
block|{
if|if
condition|(
operator|*
name|outbytesleftp
operator|<
literal|2
condition|)
block|{
operator|*
name|inbufp
operator|=
name|save_inbuf
expr_stmt|;
operator|*
name|inbytesleftp
operator|=
name|save_inbytesleft
expr_stmt|;
return|return
name|E2BIG
return|;
block|}
name|outbuf
index|[
name|bigend
condition|?
literal|1
else|:
literal|0
index|]
operator|=
operator|(
name|s
operator|&
literal|0x00FF
operator|)
expr_stmt|;
name|outbuf
index|[
name|bigend
condition|?
literal|0
else|:
literal|1
index|]
operator|=
operator|(
name|s
operator|&
literal|0xFF00
operator|)
operator|>>
literal|8
expr_stmt|;
operator|*
name|outbufp
operator|+=
literal|2
expr_stmt|;
operator|*
name|outbytesleftp
operator|-=
literal|2
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|cppchar_t
name|hi
decl_stmt|,
name|lo
decl_stmt|;
if|if
condition|(
operator|*
name|outbytesleftp
operator|<
literal|4
condition|)
block|{
operator|*
name|inbufp
operator|=
name|save_inbuf
expr_stmt|;
operator|*
name|inbytesleftp
operator|=
name|save_inbytesleft
expr_stmt|;
return|return
name|E2BIG
return|;
block|}
name|hi
operator|=
operator|(
name|s
operator|-
literal|0x10000
operator|)
operator|/
literal|0x400
operator|+
literal|0xD800
expr_stmt|;
name|lo
operator|=
operator|(
name|s
operator|-
literal|0x10000
operator|)
operator|%
literal|0x400
operator|+
literal|0xDC00
expr_stmt|;
comment|/* Even if we are little-endian, put the high surrogate first. 	 ??? Matches practice?  */
name|outbuf
index|[
name|bigend
condition|?
literal|1
else|:
literal|0
index|]
operator|=
operator|(
name|hi
operator|&
literal|0x00FF
operator|)
expr_stmt|;
name|outbuf
index|[
name|bigend
condition|?
literal|0
else|:
literal|1
index|]
operator|=
operator|(
name|hi
operator|&
literal|0xFF00
operator|)
operator|>>
literal|8
expr_stmt|;
name|outbuf
index|[
name|bigend
condition|?
literal|3
else|:
literal|2
index|]
operator|=
operator|(
name|lo
operator|&
literal|0x00FF
operator|)
expr_stmt|;
name|outbuf
index|[
name|bigend
condition|?
literal|2
else|:
literal|3
index|]
operator|=
operator|(
name|lo
operator|&
literal|0xFF00
operator|)
operator|>>
literal|8
expr_stmt|;
operator|*
name|outbufp
operator|+=
literal|4
expr_stmt|;
operator|*
name|outbytesleftp
operator|-=
literal|4
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|one_utf16_to_utf8
parameter_list|(
name|iconv_t
name|bigend
parameter_list|,
specifier|const
name|uchar
modifier|*
modifier|*
name|inbufp
parameter_list|,
name|size_t
modifier|*
name|inbytesleftp
parameter_list|,
name|uchar
modifier|*
modifier|*
name|outbufp
parameter_list|,
name|size_t
modifier|*
name|outbytesleftp
parameter_list|)
block|{
name|cppchar_t
name|s
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|inbuf
init|=
operator|*
name|inbufp
decl_stmt|;
name|int
name|rval
decl_stmt|;
if|if
condition|(
operator|*
name|inbytesleftp
operator|<
literal|2
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|inbuf
index|[
name|bigend
condition|?
literal|0
else|:
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
name|s
operator|+=
name|inbuf
index|[
name|bigend
condition|?
literal|1
else|:
literal|0
index|]
expr_stmt|;
comment|/* Low surrogate without immediately preceding high surrogate is invalid.  */
if|if
condition|(
name|s
operator|>=
literal|0xDC00
operator|&&
name|s
operator|<=
literal|0xDFFF
condition|)
return|return
name|EILSEQ
return|;
comment|/* High surrogate must have a following low surrogate.  */
elseif|else
if|if
condition|(
name|s
operator|>=
literal|0xD800
operator|&&
name|s
operator|<=
literal|0xDBFF
condition|)
block|{
name|cppchar_t
name|hi
init|=
name|s
decl_stmt|,
name|lo
decl_stmt|;
if|if
condition|(
operator|*
name|inbytesleftp
operator|<
literal|4
condition|)
return|return
name|EINVAL
return|;
name|lo
operator|=
name|inbuf
index|[
name|bigend
condition|?
literal|2
else|:
literal|3
index|]
operator|<<
literal|8
expr_stmt|;
name|lo
operator|+=
name|inbuf
index|[
name|bigend
condition|?
literal|3
else|:
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|lo
operator|<
literal|0xDC00
operator|||
name|lo
operator|>
literal|0xDFFF
condition|)
return|return
name|EILSEQ
return|;
name|s
operator|=
operator|(
name|hi
operator|-
literal|0xD800
operator|)
operator|*
literal|0x400
operator|+
operator|(
name|lo
operator|-
literal|0xDC00
operator|)
operator|+
literal|0x10000
expr_stmt|;
block|}
name|rval
operator|=
name|one_cppchar_to_utf8
argument_list|(
name|s
argument_list|,
name|outbufp
argument_list|,
name|outbytesleftp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
comment|/* Success - update the input pointers (one_cppchar_to_utf8 has done      the output pointers for us).  */
if|if
condition|(
name|s
operator|<=
literal|0xFFFF
condition|)
block|{
operator|*
name|inbufp
operator|+=
literal|2
expr_stmt|;
operator|*
name|inbytesleftp
operator|-=
literal|2
expr_stmt|;
block|}
else|else
block|{
operator|*
name|inbufp
operator|+=
literal|4
expr_stmt|;
operator|*
name|inbytesleftp
operator|-=
literal|4
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Helper routine for the next few functions.  The 'const' on    one_conversion means that we promise not to modify what function is    pointed to, which lets the inliner see through it.  */
end_comment

begin_decl_stmt
specifier|static
specifier|inline
name|bool
name|conversion_loop
argument_list|(
name|int
argument_list|(
operator|*
specifier|const
name|one_conversion
argument_list|)
argument_list|(
name|iconv_t
argument_list|,
specifier|const
name|uchar
operator|*
operator|*
argument_list|,
name|size_t
operator|*
argument_list|,
name|uchar
operator|*
operator|*
argument_list|,
name|size_t
operator|*
argument_list|)
argument_list|,
name|iconv_t
name|cd
argument_list|,
specifier|const
name|uchar
operator|*
name|from
argument_list|,
name|size_t
name|flen
argument_list|,
expr|struct
name|_cpp_strbuf
operator|*
name|to
argument_list|)
block|{
specifier|const
name|uchar
modifier|*
name|inbuf
decl_stmt|;
name|uchar
modifier|*
name|outbuf
decl_stmt|;
name|size_t
name|inbytesleft
decl_stmt|,
name|outbytesleft
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|inbuf
operator|=
name|from
expr_stmt|;
name|inbytesleft
operator|=
name|flen
expr_stmt|;
name|outbuf
operator|=
name|to
operator|->
name|text
operator|+
name|to
operator|->
name|len
expr_stmt|;
name|outbytesleft
operator|=
name|to
operator|->
name|asize
operator|-
name|to
operator|->
name|len
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
do|do
name|rval
operator|=
name|one_conversion
argument_list|(
name|cd
argument_list|,
operator|&
name|inbuf
argument_list|,
operator|&
name|inbytesleft
argument_list|,
operator|&
name|outbuf
argument_list|,
operator|&
name|outbytesleft
argument_list|)
expr_stmt|;
do|while
condition|(
name|inbytesleft
operator|&&
operator|!
name|rval
condition|)
do|;
if|if
condition|(
name|__builtin_expect
argument_list|(
name|inbytesleft
operator|==
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|to
operator|->
name|len
operator|=
name|to
operator|->
name|asize
operator|-
name|outbytesleft
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|rval
operator|!=
name|E2BIG
condition|)
block|{
name|errno
operator|=
name|rval
expr_stmt|;
return|return
name|false
return|;
block|}
name|outbytesleft
operator|+=
name|OUTBUF_BLOCK_SIZE
expr_stmt|;
name|to
operator|->
name|asize
operator|+=
name|OUTBUF_BLOCK_SIZE
expr_stmt|;
name|to
operator|->
name|text
operator|=
name|XRESIZEVEC
argument_list|(
name|uchar
argument_list|,
name|to
operator|->
name|text
argument_list|,
name|to
operator|->
name|asize
argument_list|)
expr_stmt|;
name|outbuf
operator|=
name|to
operator|->
name|text
operator|+
name|to
operator|->
name|asize
operator|-
name|outbytesleft
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* These functions convert entire strings between character sets.    They all have the signature     bool (*)(iconv_t cd, const uchar *from, size_t flen, struct _cpp_strbuf *to);     The input string FROM is converted as specified by the function    name plus the iconv descriptor CD (which may be fake), and the    result appended to TO.  On any error, false is returned, otherwise true.  */
end_comment

begin_comment
comment|/* These four use the custom conversion code above.  */
end_comment

begin_function
specifier|static
name|bool
name|convert_utf8_utf16
parameter_list|(
name|iconv_t
name|cd
parameter_list|,
specifier|const
name|uchar
modifier|*
name|from
parameter_list|,
name|size_t
name|flen
parameter_list|,
name|struct
name|_cpp_strbuf
modifier|*
name|to
parameter_list|)
block|{
return|return
name|conversion_loop
argument_list|(
name|one_utf8_to_utf16
argument_list|,
name|cd
argument_list|,
name|from
argument_list|,
name|flen
argument_list|,
name|to
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|convert_utf8_utf32
parameter_list|(
name|iconv_t
name|cd
parameter_list|,
specifier|const
name|uchar
modifier|*
name|from
parameter_list|,
name|size_t
name|flen
parameter_list|,
name|struct
name|_cpp_strbuf
modifier|*
name|to
parameter_list|)
block|{
return|return
name|conversion_loop
argument_list|(
name|one_utf8_to_utf32
argument_list|,
name|cd
argument_list|,
name|from
argument_list|,
name|flen
argument_list|,
name|to
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|convert_utf16_utf8
parameter_list|(
name|iconv_t
name|cd
parameter_list|,
specifier|const
name|uchar
modifier|*
name|from
parameter_list|,
name|size_t
name|flen
parameter_list|,
name|struct
name|_cpp_strbuf
modifier|*
name|to
parameter_list|)
block|{
return|return
name|conversion_loop
argument_list|(
name|one_utf16_to_utf8
argument_list|,
name|cd
argument_list|,
name|from
argument_list|,
name|flen
argument_list|,
name|to
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|convert_utf32_utf8
parameter_list|(
name|iconv_t
name|cd
parameter_list|,
specifier|const
name|uchar
modifier|*
name|from
parameter_list|,
name|size_t
name|flen
parameter_list|,
name|struct
name|_cpp_strbuf
modifier|*
name|to
parameter_list|)
block|{
return|return
name|conversion_loop
argument_list|(
name|one_utf32_to_utf8
argument_list|,
name|cd
argument_list|,
name|from
argument_list|,
name|flen
argument_list|,
name|to
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Identity conversion, used when we have no alternative.  */
end_comment

begin_function
specifier|static
name|bool
name|convert_no_conversion
parameter_list|(
name|iconv_t
name|cd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|uchar
modifier|*
name|from
parameter_list|,
name|size_t
name|flen
parameter_list|,
name|struct
name|_cpp_strbuf
modifier|*
name|to
parameter_list|)
block|{
if|if
condition|(
name|to
operator|->
name|len
operator|+
name|flen
operator|>
name|to
operator|->
name|asize
condition|)
block|{
name|to
operator|->
name|asize
operator|=
name|to
operator|->
name|len
operator|+
name|flen
expr_stmt|;
name|to
operator|->
name|text
operator|=
name|XRESIZEVEC
argument_list|(
name|uchar
argument_list|,
name|to
operator|->
name|text
argument_list|,
name|to
operator|->
name|asize
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|to
operator|->
name|text
operator|+
name|to
operator|->
name|len
argument_list|,
name|from
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|to
operator|->
name|len
operator|+=
name|flen
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* And this one uses the system iconv primitive.  It's a little    different, since iconv's interface is a little different.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_ICONV
end_if

begin_define
define|#
directive|define
name|CONVERT_ICONV_GROW_BUFFER
define|\
value|do { \       outbytesleft += OUTBUF_BLOCK_SIZE; \       to->asize += OUTBUF_BLOCK_SIZE; \       to->text = XRESIZEVEC (uchar, to->text, to->asize); \       outbuf = (char *)to->text + to->asize - outbytesleft; \   } while (0)
end_define

begin_function
specifier|static
name|bool
name|convert_using_iconv
parameter_list|(
name|iconv_t
name|cd
parameter_list|,
specifier|const
name|uchar
modifier|*
name|from
parameter_list|,
name|size_t
name|flen
parameter_list|,
name|struct
name|_cpp_strbuf
modifier|*
name|to
parameter_list|)
block|{
name|ICONV_CONST
name|char
modifier|*
name|inbuf
decl_stmt|;
name|char
modifier|*
name|outbuf
decl_stmt|;
name|size_t
name|inbytesleft
decl_stmt|,
name|outbytesleft
decl_stmt|;
comment|/* Reset conversion descriptor and check that it is valid.  */
if|if
condition|(
name|iconv
argument_list|(
name|cd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
name|inbuf
operator|=
operator|(
name|ICONV_CONST
name|char
operator|*
operator|)
name|from
expr_stmt|;
name|inbytesleft
operator|=
name|flen
expr_stmt|;
name|outbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|to
operator|->
name|text
operator|+
name|to
operator|->
name|len
expr_stmt|;
name|outbytesleft
operator|=
name|to
operator|->
name|asize
operator|-
name|to
operator|->
name|len
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|iconv
argument_list|(
name|cd
argument_list|,
operator|&
name|inbuf
argument_list|,
operator|&
name|inbytesleft
argument_list|,
operator|&
name|outbuf
argument_list|,
operator|&
name|outbytesleft
argument_list|)
expr_stmt|;
if|if
condition|(
name|__builtin_expect
argument_list|(
name|inbytesleft
operator|==
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* Close out any shift states, returning to the initial state.  */
if|if
condition|(
name|iconv
argument_list|(
name|cd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|outbuf
argument_list|,
operator|&
name|outbytesleft
argument_list|)
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|E2BIG
condition|)
return|return
name|false
return|;
name|CONVERT_ICONV_GROW_BUFFER
expr_stmt|;
if|if
condition|(
name|iconv
argument_list|(
name|cd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|outbuf
argument_list|,
operator|&
name|outbytesleft
argument_list|)
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
block|}
name|to
operator|->
name|len
operator|=
name|to
operator|->
name|asize
operator|-
name|outbytesleft
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|errno
operator|!=
name|E2BIG
condition|)
return|return
name|false
return|;
name|CONVERT_ICONV_GROW_BUFFER
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|convert_using_iconv
value|0
end_define

begin_comment
comment|/* prevent undefined symbol error below */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Arrange for the above custom conversion logic to be used automatically    when conversion between a suitable pair of character sets is requested.  */
end_comment

begin_define
define|#
directive|define
name|APPLY_CONVERSION
parameter_list|(
name|CONVERTER
parameter_list|,
name|FROM
parameter_list|,
name|FLEN
parameter_list|,
name|TO
parameter_list|)
define|\
value|CONVERTER.func (CONVERTER.cd, FROM, FLEN, TO)
end_define

begin_struct
struct|struct
name|conversion
block|{
specifier|const
name|char
modifier|*
name|pair
decl_stmt|;
name|convert_f
name|func
decl_stmt|;
name|iconv_t
name|fake_cd
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|conversion
name|conversion_tab
index|[]
init|=
block|{
block|{
literal|"UTF-8/UTF-32LE"
block|,
name|convert_utf8_utf32
block|,
operator|(
name|iconv_t
operator|)
literal|0
block|}
block|,
block|{
literal|"UTF-8/UTF-32BE"
block|,
name|convert_utf8_utf32
block|,
operator|(
name|iconv_t
operator|)
literal|1
block|}
block|,
block|{
literal|"UTF-8/UTF-16LE"
block|,
name|convert_utf8_utf16
block|,
operator|(
name|iconv_t
operator|)
literal|0
block|}
block|,
block|{
literal|"UTF-8/UTF-16BE"
block|,
name|convert_utf8_utf16
block|,
operator|(
name|iconv_t
operator|)
literal|1
block|}
block|,
block|{
literal|"UTF-32LE/UTF-8"
block|,
name|convert_utf32_utf8
block|,
operator|(
name|iconv_t
operator|)
literal|0
block|}
block|,
block|{
literal|"UTF-32BE/UTF-8"
block|,
name|convert_utf32_utf8
block|,
operator|(
name|iconv_t
operator|)
literal|1
block|}
block|,
block|{
literal|"UTF-16LE/UTF-8"
block|,
name|convert_utf16_utf8
block|,
operator|(
name|iconv_t
operator|)
literal|0
block|}
block|,
block|{
literal|"UTF-16BE/UTF-8"
block|,
name|convert_utf16_utf8
block|,
operator|(
name|iconv_t
operator|)
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subroutine of cpp_init_iconv: initialize and return a    cset_converter structure for conversion from FROM to TO.  If    iconv_open() fails, issue an error and return an identity    converter.  Silently return an identity converter if FROM and TO    are identical.  */
end_comment

begin_function
specifier|static
name|struct
name|cset_converter
name|init_iconv_desc
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|to
parameter_list|,
specifier|const
name|char
modifier|*
name|from
parameter_list|)
block|{
name|struct
name|cset_converter
name|ret
decl_stmt|;
name|char
modifier|*
name|pair
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
condition|)
block|{
name|ret
operator|.
name|func
operator|=
name|convert_no_conversion
expr_stmt|;
name|ret
operator|.
name|cd
operator|=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|ret
return|;
block|}
name|pair
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|to
argument_list|)
operator|+
name|strlen
argument_list|(
name|from
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|pair
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pair
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pair
argument_list|,
name|to
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|conversion_tab
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|pair
argument_list|,
name|conversion_tab
index|[
name|i
index|]
operator|.
name|pair
argument_list|)
condition|)
block|{
name|ret
operator|.
name|func
operator|=
name|conversion_tab
index|[
name|i
index|]
operator|.
name|func
expr_stmt|;
name|ret
operator|.
name|cd
operator|=
name|conversion_tab
index|[
name|i
index|]
operator|.
name|fake_cd
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* No custom converter - try iconv.  */
if|if
condition|(
name|HAVE_ICONV
condition|)
block|{
name|ret
operator|.
name|func
operator|=
name|convert_using_iconv
expr_stmt|;
name|ret
operator|.
name|cd
operator|=
name|iconv_open
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|.
name|cd
operator|==
operator|(
name|iconv_t
operator|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINVAL
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
comment|/* FIXME should be DL_SORRY */
literal|"conversion from %s to %s not supported by iconv"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
else|else
name|cpp_errno
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"iconv_open"
argument_list|)
expr_stmt|;
name|ret
operator|.
name|func
operator|=
name|convert_no_conversion
expr_stmt|;
block|}
block|}
else|else
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
comment|/* FIXME: should be DL_SORRY */
literal|"no iconv implementation, cannot convert from %s to %s"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|ret
operator|.
name|func
operator|=
name|convert_no_conversion
expr_stmt|;
name|ret
operator|.
name|cd
operator|=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* If charset conversion is requested, initialize iconv(3) descriptors    for conversion from the source character set to the execution    character sets.  If iconv is not present in the C library, and    conversion is requested, issue an error.  */
end_comment

begin_function
name|void
name|cpp_init_iconv
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ncset
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|narrow_charset
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|wcset
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|wide_charset
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|default_wcset
decl_stmt|;
name|bool
name|be
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|bytes_big_endian
argument_list|)
decl_stmt|;
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|wchar_precision
argument_list|)
operator|>=
literal|32
condition|)
name|default_wcset
operator|=
name|be
condition|?
literal|"UTF-32BE"
else|:
literal|"UTF-32LE"
expr_stmt|;
elseif|else
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|wchar_precision
argument_list|)
operator|>=
literal|16
condition|)
name|default_wcset
operator|=
name|be
condition|?
literal|"UTF-16BE"
else|:
literal|"UTF-16LE"
expr_stmt|;
else|else
comment|/* This effectively means that wide strings are not supported,        so don't do any conversion at all.  */
name|default_wcset
operator|=
name|SOURCE_CHARSET
expr_stmt|;
if|if
condition|(
operator|!
name|ncset
condition|)
name|ncset
operator|=
name|SOURCE_CHARSET
expr_stmt|;
if|if
condition|(
operator|!
name|wcset
condition|)
name|wcset
operator|=
name|default_wcset
expr_stmt|;
name|pfile
operator|->
name|narrow_cset_desc
operator|=
name|init_iconv_desc
argument_list|(
name|pfile
argument_list|,
name|ncset
argument_list|,
name|SOURCE_CHARSET
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|wide_cset_desc
operator|=
name|init_iconv_desc
argument_list|(
name|pfile
argument_list|,
name|wcset
argument_list|,
name|SOURCE_CHARSET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Destroy iconv(3) descriptors set up by cpp_init_iconv, if necessary.  */
end_comment

begin_function
name|void
name|_cpp_destroy_iconv
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
if|if
condition|(
name|HAVE_ICONV
condition|)
block|{
if|if
condition|(
name|pfile
operator|->
name|narrow_cset_desc
operator|.
name|func
operator|==
name|convert_using_iconv
condition|)
name|iconv_close
argument_list|(
name|pfile
operator|->
name|narrow_cset_desc
operator|.
name|cd
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|wide_cset_desc
operator|.
name|func
operator|==
name|convert_using_iconv
condition|)
name|iconv_close
argument_list|(
name|pfile
operator|->
name|wide_cset_desc
operator|.
name|cd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Utility routine for use by a full compiler.  C is a character taken    from the *basic* source character set, encoded in the host's    execution encoding.  Convert it to (the target's) execution    encoding, and return that value.     Issues an internal error if C's representation in the narrow    execution character set fails to be a single-byte value (C99    5.2.1p3: "The representation of each member of the source and    execution character sets shall fit in a byte.")  May also issue an    internal error if C fails to be a member of the basic source    character set (testing this exactly is too hard, especially when    the host character set is EBCDIC).  */
end_comment

begin_function
name|cppchar_t
name|cpp_host_to_exec_charset
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cppchar_t
name|c
parameter_list|)
block|{
name|uchar
name|sbuf
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|_cpp_strbuf
name|tbuf
decl_stmt|;
comment|/* This test is merely an approximation, but it suffices to catch      the most important thing, which is that we don't get handed a      character outside the unibyte range of the host character set.  */
if|if
condition|(
name|c
operator|>
name|LAST_POSSIBLY_BASIC_SOURCE_CHAR
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ICE
argument_list|,
literal|"character 0x%lx is not in the basic source character set\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Being a character in the unibyte range of the host character set,      we can safely splat it into a one-byte buffer and trust that that      is a well-formed string.  */
name|sbuf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
comment|/* This should never need to reallocate, but just in case... */
name|tbuf
operator|.
name|asize
operator|=
literal|1
expr_stmt|;
name|tbuf
operator|.
name|text
operator|=
name|XNEWVEC
argument_list|(
name|uchar
argument_list|,
name|tbuf
operator|.
name|asize
argument_list|)
expr_stmt|;
name|tbuf
operator|.
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|APPLY_CONVERSION
argument_list|(
name|pfile
operator|->
name|narrow_cset_desc
argument_list|,
name|sbuf
argument_list|,
literal|1
argument_list|,
operator|&
name|tbuf
argument_list|)
condition|)
block|{
name|cpp_errno
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ICE
argument_list|,
literal|"converting to execution character set"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|tbuf
operator|.
name|len
operator|!=
literal|1
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ICE
argument_list|,
literal|"character 0x%lx is not unibyte in execution character set"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|c
operator|=
name|tbuf
operator|.
name|text
index|[
literal|0
index|]
expr_stmt|;
name|free
argument_list|(
name|tbuf
operator|.
name|text
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Utility routine that computes a mask of the form 0000...111... with    WIDTH 1-bits.  */
end_comment

begin_function
specifier|static
specifier|inline
name|size_t
name|width_to_mask
parameter_list|(
name|size_t
name|width
parameter_list|)
block|{
name|width
operator|=
name|MIN
argument_list|(
name|width
argument_list|,
name|BITS_PER_CPPCHAR_T
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>=
name|CHAR_BIT
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
condition|)
return|return
operator|~
operator|(
name|size_t
operator|)
literal|0
return|;
else|else
return|return
operator|(
operator|(
name|size_t
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* A large table of unicode character information.  */
end_comment

begin_enum
enum|enum
block|{
comment|/* Valid in a C99 identifier?  */
name|C99
init|=
literal|1
block|,
comment|/* Valid in a C99 identifier, but not as the first character?  */
name|DIG
init|=
literal|2
block|,
comment|/* Valid in a C++ identifier?  */
name|CXX
init|=
literal|4
block|,
comment|/* NFC representation is not valid in an identifier?  */
name|CID
init|=
literal|8
block|,
comment|/* Might be valid NFC form?  */
name|NFC
init|=
literal|16
block|,
comment|/* Might be valid NFKC form?  */
name|NKC
init|=
literal|32
block|,
comment|/* Certain preceding characters might make it not valid NFC/NKFC form?  */
name|CTX
init|=
literal|64
block|}
enum|;
end_enum

begin_struct
specifier|static
specifier|const
struct|struct
block|{
comment|/* Bitmap of flags above.  */
name|unsigned
name|char
name|flags
decl_stmt|;
comment|/* Combining class of the character.  */
name|unsigned
name|char
name|combine
decl_stmt|;
comment|/* Last character in the range described by this entry.  */
name|unsigned
name|short
name|end
decl_stmt|;
block|}
name|ucnranges
index|[]
init|=
block|{
include|#
directive|include
file|"ucnid.h"
block|}
struct|;
end_struct

begin_comment
comment|/* Returns 1 if C is valid in an identifier, 2 if C is valid except at    the start of an identifier, and 0 if C is not valid in an    identifier.  We assume C has already gone through the checks of    _cpp_valid_ucn.  Also update NST for C if returning nonzero.  The    algorithm is a simple binary search on the table defined in    ucnid.h.  */
end_comment

begin_function
specifier|static
name|int
name|ucn_valid_in_identifier
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cppchar_t
name|c
parameter_list|,
name|struct
name|normalize_state
modifier|*
name|nst
parameter_list|)
block|{
name|int
name|mn
decl_stmt|,
name|mx
decl_stmt|,
name|md
decl_stmt|;
if|if
condition|(
name|c
operator|>
literal|0xFFFF
condition|)
return|return
literal|0
return|;
name|mn
operator|=
literal|0
expr_stmt|;
name|mx
operator|=
name|ARRAY_SIZE
argument_list|(
name|ucnranges
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|mx
operator|!=
name|mn
condition|)
block|{
name|md
operator|=
operator|(
name|mn
operator|+
name|mx
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|c
operator|<=
name|ucnranges
index|[
name|md
index|]
operator|.
name|end
condition|)
name|mx
operator|=
name|md
expr_stmt|;
else|else
name|mn
operator|=
name|md
operator|+
literal|1
expr_stmt|;
block|}
comment|/* When -pedantic, we require the character to have been listed by      the standard for the current language.  Otherwise, we accept the      union of the acceptable sets for C++98 and C99.  */
if|if
condition|(
operator|!
operator|(
name|ucnranges
index|[
name|mn
index|]
operator|.
name|flags
operator|&
operator|(
name|C99
operator||
name|CXX
operator|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|(
operator|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|c99
argument_list|)
operator|&&
operator|!
operator|(
name|ucnranges
index|[
name|mn
index|]
operator|.
name|flags
operator|&
name|C99
operator|)
operator|)
operator|||
operator|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
operator|&&
operator|!
operator|(
name|ucnranges
index|[
name|mn
index|]
operator|.
name|flags
operator|&
name|CXX
operator|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Update NST.  */
if|if
condition|(
name|ucnranges
index|[
name|mn
index|]
operator|.
name|combine
operator|!=
literal|0
operator|&&
name|ucnranges
index|[
name|mn
index|]
operator|.
name|combine
operator|<
name|nst
operator|->
name|prev_class
condition|)
name|nst
operator|->
name|level
operator|=
name|normalized_none
expr_stmt|;
elseif|else
if|if
condition|(
name|ucnranges
index|[
name|mn
index|]
operator|.
name|flags
operator|&
name|CTX
condition|)
block|{
name|bool
name|safe
decl_stmt|;
name|cppchar_t
name|p
init|=
name|nst
operator|->
name|previous
decl_stmt|;
comment|/* Easy cases from Bengali, Oriya, Tamil, Jannada, and Malayalam.  */
if|if
condition|(
name|c
operator|==
literal|0x09BE
condition|)
name|safe
operator|=
name|p
operator|!=
literal|0x09C7
expr_stmt|;
comment|/* Use 09CB instead of 09C7 09BE.  */
elseif|else
if|if
condition|(
name|c
operator|==
literal|0x0B3E
condition|)
name|safe
operator|=
name|p
operator|!=
literal|0x0B47
expr_stmt|;
comment|/* Use 0B4B instead of 0B47 0B3E.  */
elseif|else
if|if
condition|(
name|c
operator|==
literal|0x0BBE
condition|)
name|safe
operator|=
name|p
operator|!=
literal|0x0BC6
operator|&&
name|p
operator|!=
literal|0x0BC7
expr_stmt|;
comment|/* Use 0BCA/0BCB instead.  */
elseif|else
if|if
condition|(
name|c
operator|==
literal|0x0CC2
condition|)
name|safe
operator|=
name|p
operator|!=
literal|0x0CC6
expr_stmt|;
comment|/* Use 0CCA instead of 0CC6 0CC2.  */
elseif|else
if|if
condition|(
name|c
operator|==
literal|0x0D3E
condition|)
name|safe
operator|=
name|p
operator|!=
literal|0x0D46
operator|&&
name|p
operator|!=
literal|0x0D47
expr_stmt|;
comment|/* Use 0D4A/0D4B instead.  */
comment|/* For Hangul, characters in the range AC00-D7A3 are NFC/NFKC, 	 and are combined algorithmically from a sequence of the form 	 1100-1112 1161-1175 11A8-11C2 	 (if the third is not present, it is treated as 11A7, which is not 	 really a valid character). 	 Unfortunately, C99 allows (only) the NFC form, but C++ allows 	 only the combining characters.  */
elseif|else
if|if
condition|(
name|c
operator|>=
literal|0x1161
operator|&&
name|c
operator|<=
literal|0x1175
condition|)
name|safe
operator|=
name|p
operator|<
literal|0x1100
operator|||
name|p
operator|>
literal|0x1112
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|0x11A8
operator|&&
name|c
operator|<=
literal|0x11C2
condition|)
name|safe
operator|=
operator|(
name|p
operator|<
literal|0xAC00
operator|||
name|p
operator|>
literal|0xD7A3
operator|||
operator|(
name|p
operator|-
literal|0xAC00
operator|)
operator|%
literal|28
operator|!=
literal|0
operator|)
expr_stmt|;
else|else
block|{
comment|/* Uh-oh, someone updated ucnid.h without updating this code.  */
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ICE
argument_list|,
literal|"Character %x might not be NFKC"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|safe
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|safe
operator|&&
name|c
operator|<
literal|0x1161
condition|)
name|nst
operator|->
name|level
operator|=
name|normalized_none
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|safe
condition|)
name|nst
operator|->
name|level
operator|=
name|MAX
argument_list|(
name|nst
operator|->
name|level
argument_list|,
name|normalized_identifier_C
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ucnranges
index|[
name|mn
index|]
operator|.
name|flags
operator|&
name|NKC
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|ucnranges
index|[
name|mn
index|]
operator|.
name|flags
operator|&
name|NFC
condition|)
name|nst
operator|->
name|level
operator|=
name|MAX
argument_list|(
name|nst
operator|->
name|level
argument_list|,
name|normalized_C
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ucnranges
index|[
name|mn
index|]
operator|.
name|flags
operator|&
name|CID
condition|)
name|nst
operator|->
name|level
operator|=
name|MAX
argument_list|(
name|nst
operator|->
name|level
argument_list|,
name|normalized_identifier_C
argument_list|)
expr_stmt|;
else|else
name|nst
operator|->
name|level
operator|=
name|normalized_none
expr_stmt|;
name|nst
operator|->
name|previous
operator|=
name|c
expr_stmt|;
name|nst
operator|->
name|prev_class
operator|=
name|ucnranges
index|[
name|mn
index|]
operator|.
name|combine
expr_stmt|;
comment|/* In C99, UCN digits may not begin identifiers.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|c99
argument_list|)
operator|&&
operator|(
name|ucnranges
index|[
name|mn
index|]
operator|.
name|flags
operator|&
name|DIG
operator|)
condition|)
return|return
literal|2
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* [lex.charset]: The character designated by the universal character    name \UNNNNNNNN is that character whose character short name in    ISO/IEC 10646 is NNNNNNNN; the character designated by the    universal character name \uNNNN is that character whose character    short name in ISO/IEC 10646 is 0000NNNN.  If the hexadecimal value    for a universal character name is less than 0x20 or in the range    0x7F-0x9F (inclusive), or if the universal character name    designates a character in the basic source character set, then the    program is ill-formed.     *PSTR must be preceded by "\u" or "\U"; it is assumed that the    buffer end is delimited by a non-hex digit.  Returns zero if the    UCN has not been consumed.     Otherwise the nonzero value of the UCN, whether valid or invalid,    is returned.  Diagnostics are emitted for invalid values.  PSTR    is updated to point one beyond the UCN, or to the syntactically    invalid character.     IDENTIFIER_POS is 0 when not in an identifier, 1 for the start of    an identifier, or 2 otherwise.  */
end_comment

begin_function
name|cppchar_t
name|_cpp_valid_ucn
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|uchar
modifier|*
modifier|*
name|pstr
parameter_list|,
specifier|const
name|uchar
modifier|*
name|limit
parameter_list|,
name|int
name|identifier_pos
parameter_list|,
name|struct
name|normalize_state
modifier|*
name|nst
parameter_list|)
block|{
name|cppchar_t
name|result
decl_stmt|,
name|c
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|str
init|=
operator|*
name|pstr
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|base
init|=
name|str
operator|-
literal|2
decl_stmt|;
if|if
condition|(
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|cplusplus
argument_list|)
operator|&&
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|c99
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"universal character names are only valid in C++ and C99"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CPP_WTRADITIONAL
argument_list|(
name|pfile
argument_list|)
operator|&&
name|identifier_pos
operator|==
literal|0
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"the meaning of '\\%c' is different in traditional C"
argument_list|,
operator|(
name|int
operator|)
name|str
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
index|[
operator|-
literal|1
index|]
operator|==
literal|'u'
condition|)
name|length
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|str
index|[
operator|-
literal|1
index|]
operator|==
literal|'U'
condition|)
name|length
operator|=
literal|8
expr_stmt|;
else|else
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ICE
argument_list|,
literal|"In _cpp_valid_ucn but not a UCN"
argument_list|)
expr_stmt|;
name|length
operator|=
literal|4
expr_stmt|;
block|}
name|result
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|c
operator|=
operator|*
name|str
expr_stmt|;
if|if
condition|(
operator|!
name|ISXDIGIT
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|str
operator|++
expr_stmt|;
name|result
operator|=
operator|(
name|result
operator|<<
literal|4
operator|)
operator|+
name|hex_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|length
operator|&&
name|str
operator|<
name|limit
condition|)
do|;
comment|/* Partial UCNs are not valid in strings, but decompose into      multiple tokens in identifiers, so we can't give a helpful      error message in that case.  */
if|if
condition|(
name|length
operator|&&
name|identifier_pos
condition|)
return|return
literal|0
return|;
operator|*
name|pstr
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|length
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"incomplete universal character name %.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|str
operator|-
name|base
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
comment|/* The standard permits $, @ and ` to be specified as UCNs.  We use      hex escapes so that this also works with EBCDIC hosts.  */
elseif|else
if|if
condition|(
operator|(
name|result
operator|<
literal|0xa0
operator|&&
operator|(
name|result
operator|!=
literal|0x24
operator|&&
name|result
operator|!=
literal|0x40
operator|&&
name|result
operator|!=
literal|0x60
operator|)
operator|)
operator|||
operator|(
name|result
operator|&
literal|0x80000000
operator|)
operator|||
operator|(
name|result
operator|>=
literal|0xD800
operator|&&
name|result
operator|<=
literal|0xDFFF
operator|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"%.*s is not a valid universal character"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|str
operator|-
name|base
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|identifier_pos
operator|&&
name|result
operator|==
literal|0x24
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|dollars_in_ident
argument_list|)
condition|)
block|{
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_dollars
argument_list|)
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|skipping
condition|)
block|{
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_dollars
argument_list|)
operator|=
literal|0
expr_stmt|;
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_PEDWARN
argument_list|,
literal|"'$' in identifier or number"
argument_list|)
expr_stmt|;
block|}
name|NORMALIZE_STATE_UPDATE_IDNUM
argument_list|(
name|nst
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|identifier_pos
condition|)
block|{
name|int
name|validity
init|=
name|ucn_valid_in_identifier
argument_list|(
name|pfile
argument_list|,
name|result
argument_list|,
name|nst
argument_list|)
decl_stmt|;
if|if
condition|(
name|validity
operator|==
literal|0
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"universal character %.*s is not valid in an identifier"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|str
operator|-
name|base
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|validity
operator|==
literal|2
operator|&&
name|identifier_pos
operator|==
literal|1
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"universal character %.*s is not valid at the start of an identifier"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|str
operator|-
name|base
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|result
operator|=
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Convert an UCN, pointed to by FROM, to UTF-8 encoding, then translate    it to the execution character set and write the result into TBUF.    An advanced pointer is returned.  Issues all relevant diagnostics.  */
end_comment

begin_function
specifier|static
specifier|const
name|uchar
modifier|*
name|convert_ucn
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|uchar
modifier|*
name|from
parameter_list|,
specifier|const
name|uchar
modifier|*
name|limit
parameter_list|,
name|struct
name|_cpp_strbuf
modifier|*
name|tbuf
parameter_list|,
name|bool
name|wide
parameter_list|)
block|{
name|cppchar_t
name|ucn
decl_stmt|;
name|uchar
name|buf
index|[
literal|6
index|]
decl_stmt|;
name|uchar
modifier|*
name|bufp
init|=
name|buf
decl_stmt|;
name|size_t
name|bytesleft
init|=
literal|6
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|struct
name|cset_converter
name|cvt
init|=
name|wide
condition|?
name|pfile
operator|->
name|wide_cset_desc
else|:
name|pfile
operator|->
name|narrow_cset_desc
decl_stmt|;
name|struct
name|normalize_state
name|nst
init|=
name|INITIAL_NORMALIZE_STATE
decl_stmt|;
name|from
operator|++
expr_stmt|;
comment|/* Skip u/U.  */
name|ucn
operator|=
name|_cpp_valid_ucn
argument_list|(
name|pfile
argument_list|,
operator|&
name|from
argument_list|,
name|limit
argument_list|,
literal|0
argument_list|,
operator|&
name|nst
argument_list|)
expr_stmt|;
name|rval
operator|=
name|one_cppchar_to_utf8
argument_list|(
name|ucn
argument_list|,
operator|&
name|bufp
argument_list|,
operator|&
name|bytesleft
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
name|errno
operator|=
name|rval
expr_stmt|;
name|cpp_errno
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"converting UCN to source character set"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|APPLY_CONVERSION
argument_list|(
name|cvt
argument_list|,
name|buf
argument_list|,
literal|6
operator|-
name|bytesleft
argument_list|,
name|tbuf
argument_list|)
condition|)
name|cpp_errno
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"converting UCN to execution character set"
argument_list|)
expr_stmt|;
return|return
name|from
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of convert_hex and convert_oct.  N is the representation    in the execution character set of a numeric escape; write it into the    string buffer TBUF and update the end-of-string pointer therein.  WIDE    is true if it's a wide string that's being assembled in TBUF.  This    function issues no diagnostics and never fails.  */
end_comment

begin_function
specifier|static
name|void
name|emit_numeric_escape
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cppchar_t
name|n
parameter_list|,
name|struct
name|_cpp_strbuf
modifier|*
name|tbuf
parameter_list|,
name|bool
name|wide
parameter_list|)
block|{
if|if
condition|(
name|wide
condition|)
block|{
comment|/* We have to render this into the target byte order, which may not 	 be our byte order.  */
name|bool
name|bigend
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|bytes_big_endian
argument_list|)
decl_stmt|;
name|size_t
name|width
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|wchar_precision
argument_list|)
decl_stmt|;
name|size_t
name|cwidth
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|char_precision
argument_list|)
decl_stmt|;
name|size_t
name|cmask
init|=
name|width_to_mask
argument_list|(
name|cwidth
argument_list|)
decl_stmt|;
name|size_t
name|nbwc
init|=
name|width
operator|/
name|cwidth
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|size_t
name|off
init|=
name|tbuf
operator|->
name|len
decl_stmt|;
name|cppchar_t
name|c
decl_stmt|;
if|if
condition|(
name|tbuf
operator|->
name|len
operator|+
name|nbwc
operator|>
name|tbuf
operator|->
name|asize
condition|)
block|{
name|tbuf
operator|->
name|asize
operator|+=
name|OUTBUF_BLOCK_SIZE
expr_stmt|;
name|tbuf
operator|->
name|text
operator|=
name|XRESIZEVEC
argument_list|(
name|uchar
argument_list|,
name|tbuf
operator|->
name|text
argument_list|,
name|tbuf
operator|->
name|asize
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbwc
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|n
operator|&
name|cmask
expr_stmt|;
name|n
operator|>>=
name|cwidth
expr_stmt|;
name|tbuf
operator|->
name|text
index|[
name|off
operator|+
operator|(
name|bigend
condition|?
name|nbwc
operator|-
name|i
operator|-
literal|1
else|:
name|i
operator|)
index|]
operator|=
name|c
expr_stmt|;
block|}
name|tbuf
operator|->
name|len
operator|+=
name|nbwc
expr_stmt|;
block|}
else|else
block|{
comment|/* Note: this code does not handle the case where the target 	 and host have a different number of bits in a byte.  */
if|if
condition|(
name|tbuf
operator|->
name|len
operator|+
literal|1
operator|>
name|tbuf
operator|->
name|asize
condition|)
block|{
name|tbuf
operator|->
name|asize
operator|+=
name|OUTBUF_BLOCK_SIZE
expr_stmt|;
name|tbuf
operator|->
name|text
operator|=
name|XRESIZEVEC
argument_list|(
name|uchar
argument_list|,
name|tbuf
operator|->
name|text
argument_list|,
name|tbuf
operator|->
name|asize
argument_list|)
expr_stmt|;
block|}
name|tbuf
operator|->
name|text
index|[
name|tbuf
operator|->
name|len
operator|++
index|]
operator|=
name|n
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a hexadecimal escape, pointed to by FROM, to the execution    character set and write it into the string buffer TBUF.  Returns an    advanced pointer, and issues diagnostics as necessary.    No character set translation occurs; this routine always produces the    execution-set character with numeric value equal to the given hex    number.  You can, e.g. generate surrogate pairs this way.  */
end_comment

begin_function
specifier|static
specifier|const
name|uchar
modifier|*
name|convert_hex
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|uchar
modifier|*
name|from
parameter_list|,
specifier|const
name|uchar
modifier|*
name|limit
parameter_list|,
name|struct
name|_cpp_strbuf
modifier|*
name|tbuf
parameter_list|,
name|bool
name|wide
parameter_list|)
block|{
name|cppchar_t
name|c
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|,
name|overflow
init|=
literal|0
decl_stmt|;
name|int
name|digits_found
init|=
literal|0
decl_stmt|;
name|size_t
name|width
init|=
operator|(
name|wide
condition|?
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|wchar_precision
argument_list|)
else|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|char_precision
argument_list|)
operator|)
decl_stmt|;
name|size_t
name|mask
init|=
name|width_to_mask
argument_list|(
name|width
argument_list|)
decl_stmt|;
if|if
condition|(
name|CPP_WTRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"the meaning of '\\x' is different in traditional C"
argument_list|)
expr_stmt|;
name|from
operator|++
expr_stmt|;
comment|/* Skip 'x'.  */
while|while
condition|(
name|from
operator|<
name|limit
condition|)
block|{
name|c
operator|=
operator|*
name|from
expr_stmt|;
if|if
condition|(
operator|!
name|hex_p
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|from
operator|++
expr_stmt|;
name|overflow
operator||=
name|n
operator|^
operator|(
name|n
operator|<<
literal|4
operator|>>
literal|4
operator|)
expr_stmt|;
name|n
operator|=
operator|(
name|n
operator|<<
literal|4
operator|)
operator|+
name|hex_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|digits_found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|digits_found
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"\\x used with no following hex digits"
argument_list|)
expr_stmt|;
return|return
name|from
return|;
block|}
if|if
condition|(
name|overflow
operator||
operator|(
name|n
operator|!=
operator|(
name|n
operator|&
name|mask
operator|)
operator|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_PEDWARN
argument_list|,
literal|"hex escape sequence out of range"
argument_list|)
expr_stmt|;
name|n
operator|&=
name|mask
expr_stmt|;
block|}
name|emit_numeric_escape
argument_list|(
name|pfile
argument_list|,
name|n
argument_list|,
name|tbuf
argument_list|,
name|wide
argument_list|)
expr_stmt|;
return|return
name|from
return|;
block|}
end_function

begin_comment
comment|/* Convert an octal escape, pointed to by FROM, to the execution    character set and write it into the string buffer TBUF.  Returns an    advanced pointer, and issues diagnostics as necessary.    No character set translation occurs; this routine always produces the    execution-set character with numeric value equal to the given octal    number.  */
end_comment

begin_function
specifier|static
specifier|const
name|uchar
modifier|*
name|convert_oct
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|uchar
modifier|*
name|from
parameter_list|,
specifier|const
name|uchar
modifier|*
name|limit
parameter_list|,
name|struct
name|_cpp_strbuf
modifier|*
name|tbuf
parameter_list|,
name|bool
name|wide
parameter_list|)
block|{
name|size_t
name|count
init|=
literal|0
decl_stmt|;
name|cppchar_t
name|c
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|;
name|size_t
name|width
init|=
operator|(
name|wide
condition|?
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|wchar_precision
argument_list|)
else|:
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|char_precision
argument_list|)
operator|)
decl_stmt|;
name|size_t
name|mask
init|=
name|width_to_mask
argument_list|(
name|width
argument_list|)
decl_stmt|;
name|bool
name|overflow
init|=
name|false
decl_stmt|;
while|while
condition|(
name|from
operator|<
name|limit
operator|&&
name|count
operator|++
operator|<
literal|3
condition|)
block|{
name|c
operator|=
operator|*
name|from
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|'0'
operator|||
name|c
operator|>
literal|'7'
condition|)
break|break;
name|from
operator|++
expr_stmt|;
name|overflow
operator||=
name|n
operator|^
operator|(
name|n
operator|<<
literal|3
operator|>>
literal|3
operator|)
expr_stmt|;
name|n
operator|=
operator|(
name|n
operator|<<
literal|3
operator|)
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|!=
operator|(
name|n
operator|&
name|mask
operator|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_PEDWARN
argument_list|,
literal|"octal escape sequence out of range"
argument_list|)
expr_stmt|;
name|n
operator|&=
name|mask
expr_stmt|;
block|}
name|emit_numeric_escape
argument_list|(
name|pfile
argument_list|,
name|n
argument_list|,
name|tbuf
argument_list|,
name|wide
argument_list|)
expr_stmt|;
return|return
name|from
return|;
block|}
end_function

begin_comment
comment|/* Convert an escape sequence (pointed to by FROM) to its value on    the target, and to the execution character set.  Do not scan past    LIMIT.  Write the converted value into TBUF.  Returns an advanced    pointer.  Handles all relevant diagnostics.  */
end_comment

begin_function
specifier|static
specifier|const
name|uchar
modifier|*
name|convert_escape
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|uchar
modifier|*
name|from
parameter_list|,
specifier|const
name|uchar
modifier|*
name|limit
parameter_list|,
name|struct
name|_cpp_strbuf
modifier|*
name|tbuf
parameter_list|,
name|bool
name|wide
parameter_list|)
block|{
comment|/* Values of \a \b \e \f \n \r \t \v respectively.  */
if|#
directive|if
name|HOST_CHARSET
operator|==
name|HOST_CHARSET_ASCII
specifier|static
specifier|const
name|uchar
name|charconsts
index|[]
init|=
block|{
literal|7
block|,
literal|8
block|,
literal|27
block|,
literal|12
block|,
literal|10
block|,
literal|13
block|,
literal|9
block|,
literal|11
block|}
decl_stmt|;
elif|#
directive|elif
name|HOST_CHARSET
operator|==
name|HOST_CHARSET_EBCDIC
specifier|static
specifier|const
name|uchar
name|charconsts
index|[]
init|=
block|{
literal|47
block|,
literal|22
block|,
literal|39
block|,
literal|12
block|,
literal|21
block|,
literal|13
block|,
literal|5
block|,
literal|11
block|}
decl_stmt|;
else|#
directive|else
error|#
directive|error
literal|"unknown host character set"
endif|#
directive|endif
name|uchar
name|c
decl_stmt|;
name|struct
name|cset_converter
name|cvt
init|=
name|wide
condition|?
name|pfile
operator|->
name|wide_cset_desc
else|:
name|pfile
operator|->
name|narrow_cset_desc
decl_stmt|;
name|c
operator|=
operator|*
name|from
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* UCNs, hex escapes, and octal escapes are processed separately.  */
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
return|return
name|convert_ucn
argument_list|(
name|pfile
argument_list|,
name|from
argument_list|,
name|limit
argument_list|,
name|tbuf
argument_list|,
name|wide
argument_list|)
return|;
case|case
literal|'x'
case|:
return|return
name|convert_hex
argument_list|(
name|pfile
argument_list|,
name|from
argument_list|,
name|limit
argument_list|,
name|tbuf
argument_list|,
name|wide
argument_list|)
return|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
return|return
name|convert_oct
argument_list|(
name|pfile
argument_list|,
name|from
argument_list|,
name|limit
argument_list|,
name|tbuf
argument_list|,
name|wide
argument_list|)
return|;
comment|/* Various letter escapes.  Get the appropriate host-charset 	 value into C.  */
case|case
literal|'\\'
case|:
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
case|case
literal|'?'
case|:
break|break;
case|case
literal|'('
case|:
case|case
literal|'{'
case|:
case|case
literal|'['
case|:
case|case
literal|'%'
case|:
comment|/* '\(', etc, can be used at the beginning of a line in a long 	 string split onto multiple lines with \-newline, to prevent 	 Emacs or other text editors from getting confused.  '\%' can 	 be used to prevent SCCS from mangling printf format strings.  */
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
goto|goto
name|unknown
goto|;
break|break;
case|case
literal|'b'
case|:
name|c
operator|=
name|charconsts
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|c
operator|=
name|charconsts
index|[
literal|3
index|]
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|c
operator|=
name|charconsts
index|[
literal|4
index|]
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|c
operator|=
name|charconsts
index|[
literal|5
index|]
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|c
operator|=
name|charconsts
index|[
literal|6
index|]
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|c
operator|=
name|charconsts
index|[
literal|7
index|]
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
if|if
condition|(
name|CPP_WTRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"the meaning of '\\a' is different in traditional C"
argument_list|)
expr_stmt|;
name|c
operator|=
name|charconsts
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_PEDWARN
argument_list|,
literal|"non-ISO-standard escape sequence, '\\%c'"
argument_list|,
operator|(
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|charconsts
index|[
literal|2
index|]
expr_stmt|;
break|break;
default|default:
name|unknown
label|:
if|if
condition|(
name|ISGRAPH
argument_list|(
name|c
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_PEDWARN
argument_list|,
literal|"unknown escape sequence '\\%c'"
argument_list|,
operator|(
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* diagnostic.c does not support "%03o".  When it does, this 	     code can use %03o directly in the diagnostic again.  */
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%03o"
argument_list|,
operator|(
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_PEDWARN
argument_list|,
literal|"unknown escape sequence: '\\%s'"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now convert what we have to the execution character set.  */
if|if
condition|(
operator|!
name|APPLY_CONVERSION
argument_list|(
name|cvt
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|,
name|tbuf
argument_list|)
condition|)
name|cpp_errno
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"converting escape sequence to execution character set"
argument_list|)
expr_stmt|;
return|return
name|from
operator|+
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* FROM is an array of cpp_string structures of length COUNT.  These    are to be converted from the source to the execution character set,    escape sequences translated, and finally all are to be    concatenated.  WIDE indicates whether or not to produce a wide    string.  The result is written into TO.  Returns true for success,    false for failure.  */
end_comment

begin_function
name|bool
name|cpp_interpret_string
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|cpp_string
modifier|*
name|from
parameter_list|,
name|size_t
name|count
parameter_list|,
name|cpp_string
modifier|*
name|to
parameter_list|,
name|bool
name|wide
parameter_list|)
block|{
name|struct
name|_cpp_strbuf
name|tbuf
decl_stmt|;
specifier|const
name|uchar
modifier|*
name|p
decl_stmt|,
modifier|*
name|base
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|struct
name|cset_converter
name|cvt
init|=
name|wide
condition|?
name|pfile
operator|->
name|wide_cset_desc
else|:
name|pfile
operator|->
name|narrow_cset_desc
decl_stmt|;
name|tbuf
operator|.
name|asize
operator|=
name|MAX
argument_list|(
name|OUTBUF_BLOCK_SIZE
argument_list|,
name|from
operator|->
name|len
argument_list|)
expr_stmt|;
name|tbuf
operator|.
name|text
operator|=
name|XNEWVEC
argument_list|(
name|uchar
argument_list|,
name|tbuf
operator|.
name|asize
argument_list|)
expr_stmt|;
name|tbuf
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|from
index|[
name|i
index|]
operator|.
name|text
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'L'
condition|)
name|p
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
comment|/* Skip leading quote.  */
name|limit
operator|=
name|from
index|[
name|i
index|]
operator|.
name|text
operator|+
name|from
index|[
name|i
index|]
operator|.
name|len
operator|-
literal|1
expr_stmt|;
comment|/* Skip trailing quote.  */
for|for
control|(
init|;
condition|;
control|)
block|{
name|base
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|limit
operator|&&
operator|*
name|p
operator|!=
literal|'\\'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|>
name|base
condition|)
block|{
comment|/* We have a run of normal characters; these can be fed 		 directly to convert_cset.  */
if|if
condition|(
operator|!
name|APPLY_CONVERSION
argument_list|(
name|cvt
argument_list|,
name|base
argument_list|,
name|p
operator|-
name|base
argument_list|,
operator|&
name|tbuf
argument_list|)
condition|)
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|p
operator|==
name|limit
condition|)
break|break;
name|p
operator|=
name|convert_escape
argument_list|(
name|pfile
argument_list|,
name|p
operator|+
literal|1
argument_list|,
name|limit
argument_list|,
operator|&
name|tbuf
argument_list|,
name|wide
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* NUL-terminate the 'to' buffer and translate it to a cpp_string      structure.  */
name|emit_numeric_escape
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|,
operator|&
name|tbuf
argument_list|,
name|wide
argument_list|)
expr_stmt|;
name|tbuf
operator|.
name|text
operator|=
name|XRESIZEVEC
argument_list|(
name|uchar
argument_list|,
name|tbuf
operator|.
name|text
argument_list|,
name|tbuf
operator|.
name|len
argument_list|)
expr_stmt|;
name|to
operator|->
name|text
operator|=
name|tbuf
operator|.
name|text
expr_stmt|;
name|to
operator|->
name|len
operator|=
name|tbuf
operator|.
name|len
expr_stmt|;
return|return
name|true
return|;
name|fail
label|:
name|cpp_errno
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"converting to execution character set"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tbuf
operator|.
name|text
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of do_line and do_linemarker.  Convert escape sequences    in a string, but do not perform character set conversion.  */
end_comment

begin_function
name|bool
name|cpp_interpret_string_notranslate
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|cpp_string
modifier|*
name|from
parameter_list|,
name|size_t
name|count
parameter_list|,
name|cpp_string
modifier|*
name|to
parameter_list|,
name|bool
name|wide
parameter_list|)
block|{
name|struct
name|cset_converter
name|save_narrow_cset_desc
init|=
name|pfile
operator|->
name|narrow_cset_desc
decl_stmt|;
name|bool
name|retval
decl_stmt|;
name|pfile
operator|->
name|narrow_cset_desc
operator|.
name|func
operator|=
name|convert_no_conversion
expr_stmt|;
name|pfile
operator|->
name|narrow_cset_desc
operator|.
name|cd
operator|=
operator|(
name|iconv_t
operator|)
operator|-
literal|1
expr_stmt|;
name|retval
operator|=
name|cpp_interpret_string
argument_list|(
name|pfile
argument_list|,
name|from
argument_list|,
name|count
argument_list|,
name|to
argument_list|,
name|wide
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|narrow_cset_desc
operator|=
name|save_narrow_cset_desc
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of cpp_interpret_charconst which performs the conversion    to a number, for narrow strings.  STR is the string structure returned    by cpp_interpret_string.  PCHARS_SEEN and UNSIGNEDP are as for    cpp_interpret_charconst.  */
end_comment

begin_function
specifier|static
name|cppchar_t
name|narrow_str_to_charconst
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_string
name|str
parameter_list|,
name|unsigned
name|int
modifier|*
name|pchars_seen
parameter_list|,
name|int
modifier|*
name|unsignedp
parameter_list|)
block|{
name|size_t
name|width
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|char_precision
argument_list|)
decl_stmt|;
name|size_t
name|max_chars
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|int_precision
argument_list|)
operator|/
name|width
decl_stmt|;
name|size_t
name|mask
init|=
name|width_to_mask
argument_list|(
name|width
argument_list|)
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|cppchar_t
name|result
decl_stmt|,
name|c
decl_stmt|;
name|bool
name|unsigned_p
decl_stmt|;
comment|/* The value of a multi-character character constant, or a      single-character character constant whose representation in the      execution character set is more than one byte long, is      implementation defined.  This implementation defines it to be the      number formed by interpreting the byte sequence in memory as a      big-endian binary number.  If overflow occurs, the high bytes are      lost, and a warning is issued.       We don't want to process the NUL terminator handed back by      cpp_interpret_string.  */
name|result
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|str
operator|.
name|len
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|str
operator|.
name|text
index|[
name|i
index|]
operator|&
name|mask
expr_stmt|;
if|if
condition|(
name|width
operator|<
name|BITS_PER_CPPCHAR_T
condition|)
name|result
operator|=
operator|(
name|result
operator|<<
name|width
operator|)
operator||
name|c
expr_stmt|;
else|else
name|result
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
name|max_chars
condition|)
block|{
name|i
operator|=
name|max_chars
expr_stmt|;
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"character constant too long for its type"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>
literal|1
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_multichar
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"multi-character character constant"
argument_list|)
expr_stmt|;
comment|/* Multichar constants are of type int and therefore signed.  */
if|if
condition|(
name|i
operator|>
literal|1
condition|)
name|unsigned_p
operator|=
literal|0
expr_stmt|;
else|else
name|unsigned_p
operator|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|unsigned_char
argument_list|)
expr_stmt|;
comment|/* Truncate the constant to its natural width, and simultaneously      sign- or zero-extend to the full width of cppchar_t.      For single-character constants, the value is WIDTH bits wide.      For multi-character constants, the value is INT_PRECISION bits wide.  */
if|if
condition|(
name|i
operator|>
literal|1
condition|)
name|width
operator|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|int_precision
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|<
name|BITS_PER_CPPCHAR_T
condition|)
block|{
name|mask
operator|=
operator|(
operator|(
name|cppchar_t
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|unsigned_p
operator|||
operator|!
operator|(
name|result
operator|&
operator|(
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|result
operator|&=
name|mask
expr_stmt|;
else|else
name|result
operator||=
operator|~
name|mask
expr_stmt|;
block|}
operator|*
name|pchars_seen
operator|=
name|i
expr_stmt|;
operator|*
name|unsignedp
operator|=
name|unsigned_p
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of cpp_interpret_charconst which performs the conversion    to a number, for wide strings.  STR is the string structure returned    by cpp_interpret_string.  PCHARS_SEEN and UNSIGNEDP are as for    cpp_interpret_charconst.  */
end_comment

begin_function
specifier|static
name|cppchar_t
name|wide_str_to_charconst
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_string
name|str
parameter_list|,
name|unsigned
name|int
modifier|*
name|pchars_seen
parameter_list|,
name|int
modifier|*
name|unsignedp
parameter_list|)
block|{
name|bool
name|bigend
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|bytes_big_endian
argument_list|)
decl_stmt|;
name|size_t
name|width
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|wchar_precision
argument_list|)
decl_stmt|;
name|size_t
name|cwidth
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|char_precision
argument_list|)
decl_stmt|;
name|size_t
name|mask
init|=
name|width_to_mask
argument_list|(
name|width
argument_list|)
decl_stmt|;
name|size_t
name|cmask
init|=
name|width_to_mask
argument_list|(
name|cwidth
argument_list|)
decl_stmt|;
name|size_t
name|nbwc
init|=
name|width
operator|/
name|cwidth
decl_stmt|;
name|size_t
name|off
decl_stmt|,
name|i
decl_stmt|;
name|cppchar_t
name|result
init|=
literal|0
decl_stmt|,
name|c
decl_stmt|;
comment|/* This is finicky because the string is in the target's byte order,      which may not be our byte order.  Only the last character, ignoring      the NUL terminator, is relevant.  */
name|off
operator|=
name|str
operator|.
name|len
operator|-
operator|(
name|nbwc
operator|*
literal|2
operator|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbwc
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|bigend
condition|?
name|str
operator|.
name|text
index|[
name|off
operator|+
name|i
index|]
else|:
name|str
operator|.
name|text
index|[
name|off
operator|+
name|nbwc
operator|-
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|result
operator|=
operator|(
name|result
operator|<<
name|cwidth
operator|)
operator||
operator|(
name|c
operator|&
name|cmask
operator|)
expr_stmt|;
block|}
comment|/* Wide character constants have type wchar_t, and a single      character exactly fills a wchar_t, so a multi-character wide      character constant is guaranteed to overflow.  */
if|if
condition|(
name|off
operator|>
literal|0
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_WARNING
argument_list|,
literal|"character constant too long for its type"
argument_list|)
expr_stmt|;
comment|/* Truncate the constant to its natural width, and simultaneously      sign- or zero-extend to the full width of cppchar_t.  */
if|if
condition|(
name|width
operator|<
name|BITS_PER_CPPCHAR_T
condition|)
block|{
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|unsigned_wchar
argument_list|)
operator|||
operator|!
operator|(
name|result
operator|&
operator|(
literal|1
operator|<<
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|result
operator|&=
name|mask
expr_stmt|;
else|else
name|result
operator||=
operator|~
name|mask
expr_stmt|;
block|}
operator|*
name|unsignedp
operator|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|unsigned_wchar
argument_list|)
expr_stmt|;
operator|*
name|pchars_seen
operator|=
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Interpret a (possibly wide) character constant in TOKEN.    PCHARS_SEEN points to a variable that is filled in with the number    of characters seen, and UNSIGNEDP to a variable that indicates    whether the result has signed type.  */
end_comment

begin_function
name|cppchar_t
name|cpp_interpret_charconst
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|cpp_token
modifier|*
name|token
parameter_list|,
name|unsigned
name|int
modifier|*
name|pchars_seen
parameter_list|,
name|int
modifier|*
name|unsignedp
parameter_list|)
block|{
name|cpp_string
name|str
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|bool
name|wide
init|=
operator|(
name|token
operator|->
name|type
operator|==
name|CPP_WCHAR
operator|)
decl_stmt|;
name|cppchar_t
name|result
decl_stmt|;
comment|/* an empty constant will appear as L'' or '' */
if|if
condition|(
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|==
call|(
name|size_t
call|)
argument_list|(
literal|2
operator|+
name|wide
argument_list|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"empty character constant"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|cpp_interpret_string
argument_list|(
name|pfile
argument_list|,
operator|&
name|token
operator|->
name|val
operator|.
name|str
argument_list|,
literal|1
argument_list|,
operator|&
name|str
argument_list|,
name|wide
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|wide
condition|)
name|result
operator|=
name|wide_str_to_charconst
argument_list|(
name|pfile
argument_list|,
name|str
argument_list|,
name|pchars_seen
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|narrow_str_to_charconst
argument_list|(
name|pfile
argument_list|,
name|str
argument_list|,
name|pchars_seen
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|.
name|text
operator|!=
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
condition|)
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|str
operator|.
name|text
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert an identifier denoted by ID and LEN, which might contain    UCN escapes, to the source character set, either UTF-8 or    UTF-EBCDIC.  Assumes that the identifier is actually a valid identifier.  */
end_comment

begin_function
name|cpp_hashnode
modifier|*
name|_cpp_interpret_identifier
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|uchar
modifier|*
name|id
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
comment|/* It turns out that a UCN escape always turns into fewer characters      than the escape itself, so we can allocate a temporary in advance.  */
name|uchar
modifier|*
name|buf
init|=
operator|(
name|uchar
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|uchar
modifier|*
name|bufp
init|=
name|buf
decl_stmt|;
name|size_t
name|idp
decl_stmt|;
for|for
control|(
name|idp
operator|=
literal|0
init|;
name|idp
operator|<
name|len
condition|;
name|idp
operator|++
control|)
if|if
condition|(
name|id
index|[
name|idp
index|]
operator|!=
literal|'\\'
condition|)
operator|*
name|bufp
operator|++
operator|=
name|id
index|[
name|idp
index|]
expr_stmt|;
else|else
block|{
name|unsigned
name|length
init|=
name|id
index|[
name|idp
operator|+
literal|1
index|]
operator|==
literal|'u'
condition|?
literal|4
else|:
literal|8
decl_stmt|;
name|cppchar_t
name|value
init|=
literal|0
decl_stmt|;
name|size_t
name|bufleft
init|=
name|len
operator|-
operator|(
name|bufp
operator|-
name|buf
operator|)
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|idp
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|length
operator|&&
name|idp
operator|<
name|len
operator|&&
name|ISXDIGIT
argument_list|(
name|id
index|[
name|idp
index|]
argument_list|)
condition|)
block|{
name|value
operator|=
operator|(
name|value
operator|<<
literal|4
operator|)
operator|+
name|hex_value
argument_list|(
name|id
index|[
name|idp
index|]
argument_list|)
expr_stmt|;
name|idp
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
name|idp
operator|--
expr_stmt|;
comment|/* Special case for EBCDIC: if the identifier contains 	   a '$' specified using a UCN, translate it to EBCDIC.  */
if|if
condition|(
name|value
operator|==
literal|0x24
condition|)
block|{
operator|*
name|bufp
operator|++
operator|=
literal|'$'
expr_stmt|;
continue|continue;
block|}
name|rval
operator|=
name|one_cppchar_to_utf8
argument_list|(
name|value
argument_list|,
operator|&
name|bufp
argument_list|,
operator|&
name|bufleft
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
name|errno
operator|=
name|rval
expr_stmt|;
name|cpp_errno
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"converting UCN to source character set"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|CPP_HASHNODE
argument_list|(
name|ht_lookup
argument_list|(
name|pfile
operator|->
name|hash_table
argument_list|,
name|buf
argument_list|,
name|bufp
operator|-
name|buf
argument_list|,
name|HT_ALLOC
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert an input buffer (containing the complete contents of one    source file) from INPUT_CHARSET to the source character set.  INPUT    points to the input buffer, SIZE is its allocated size, and LEN is    the length of the meaningful data within the buffer.  The    translated buffer is returned, and *ST_SIZE is set to the length of    the meaningful data within the translated buffer.     INPUT is expected to have been allocated with xmalloc.  This function    will either return INPUT, or free it and return a pointer to another    xmalloc-allocated block of memory.  */
end_comment

begin_function
name|uchar
modifier|*
name|_cpp_convert_input
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|char
modifier|*
name|input_charset
parameter_list|,
name|uchar
modifier|*
name|input
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|len
parameter_list|,
name|off_t
modifier|*
name|st_size
parameter_list|)
block|{
name|struct
name|cset_converter
name|input_cset
decl_stmt|;
name|struct
name|_cpp_strbuf
name|to
decl_stmt|;
name|input_cset
operator|=
name|init_iconv_desc
argument_list|(
name|pfile
argument_list|,
name|SOURCE_CHARSET
argument_list|,
name|input_charset
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_cset
operator|.
name|func
operator|==
name|convert_no_conversion
condition|)
block|{
name|to
operator|.
name|text
operator|=
name|input
expr_stmt|;
name|to
operator|.
name|asize
operator|=
name|size
expr_stmt|;
name|to
operator|.
name|len
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
name|to
operator|.
name|asize
operator|=
name|MAX
argument_list|(
literal|65536
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|to
operator|.
name|text
operator|=
name|XNEWVEC
argument_list|(
name|uchar
argument_list|,
name|to
operator|.
name|asize
argument_list|)
expr_stmt|;
name|to
operator|.
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|APPLY_CONVERSION
argument_list|(
name|input_cset
argument_list|,
name|input
argument_list|,
name|len
argument_list|,
operator|&
name|to
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|CPP_DL_ERROR
argument_list|,
literal|"failure to convert %s to %s"
argument_list|,
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|input_charset
argument_list|)
argument_list|,
name|SOURCE_CHARSET
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up the mess.  */
if|if
condition|(
name|input_cset
operator|.
name|func
operator|==
name|convert_using_iconv
condition|)
name|iconv_close
argument_list|(
name|input_cset
operator|.
name|cd
argument_list|)
expr_stmt|;
comment|/* Resize buffer if we allocated substantially too much, or if we      haven't enough space for the \n-terminator.  */
if|if
condition|(
name|to
operator|.
name|len
operator|+
literal|4096
operator|<
name|to
operator|.
name|asize
operator|||
name|to
operator|.
name|len
operator|>=
name|to
operator|.
name|asize
condition|)
name|to
operator|.
name|text
operator|=
name|XRESIZEVEC
argument_list|(
name|uchar
argument_list|,
name|to
operator|.
name|text
argument_list|,
name|to
operator|.
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* If the file is using old-school Mac line endings (\r only),      terminate with another \r, not an \n, so that we do not mistake      the \r\n sequence for a single DOS line ending and erroneously      issue the "No newline at end of file" diagnostic.  */
if|if
condition|(
name|to
operator|.
name|len
operator|&&
name|to
operator|.
name|text
index|[
name|to
operator|.
name|len
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
name|to
operator|.
name|text
index|[
name|to
operator|.
name|len
index|]
operator|=
literal|'\r'
expr_stmt|;
else|else
name|to
operator|.
name|text
index|[
name|to
operator|.
name|len
index|]
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|st_size
operator|=
name|to
operator|.
name|len
expr_stmt|;
return|return
name|to
operator|.
name|text
return|;
block|}
end_function

begin_comment
comment|/* Decide on the default encoding to assume for input files.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|_cpp_default_encoding
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|current_encoding
init|=
name|NULL
decl_stmt|;
comment|/* We disable this because the default codeset is 7-bit ASCII on      most platforms, and this causes conversion failures on every      file in GCC that happens to have one of the upper 128 characters      in it -- most likely, as part of the name of a contributor.      We should definitely recognize in-band markers of file encoding,      like:      - the appropriate Unicode byte-order mark (FE FF) to recognize        UTF16 and UCS4 (in both big-endian and little-endian flavors)        and UTF8      - a "#i", "#d", "/ *", "//", " #p" or "#p" (for #pragma) to        distinguish ASCII and EBCDIC.      - now we can parse something like "#pragma GCC encoding<xyz>        on the first line, or even Emacs/VIM's mode line tags (there's        a problem here in that VIM uses the last line, and Emacs has        its more elaborate "local variables" convention).      - investigate whether Java has another common convention, which        would be friendly to support.      (Zack Weinberg and Paolo Bonzini, May 20th 2004)  */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LOCALE_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LANGINFO_CODESET
argument_list|)
operator|&&
literal|0
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|current_encoding
operator|=
name|nl_langinfo
argument_list|(
name|CODESET
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|current_encoding
operator|==
name|NULL
operator|||
operator|*
name|current_encoding
operator|==
literal|'\0'
condition|)
name|current_encoding
operator|=
name|SOURCE_CHARSET
expr_stmt|;
return|return
name|current_encoding
return|;
block|}
end_function

end_unit

