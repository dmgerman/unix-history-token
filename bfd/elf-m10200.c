begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Matsushita 10200 specific support for 32-bit ELF    Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007    Free Software Foundation, Inc.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|bfd_elf32_bfd_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|bfd_reloc_code_real_type
name|code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mn10200_info_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mn10200_elf_relax_delete_bytes
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mn10200_elf_symbol_address_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mn10200_elf_final_link_relocate
name|PARAMS
argument_list|(
operator|(
name|reloc_howto_type
operator|*
operator|,
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mn10200_elf_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mn10200_elf_relax_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd_boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_byte
modifier|*
name|mn10200_elf_get_relocated_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|bfd_link_order
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_boolean
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|reloc_type
block|{
name|R_MN10200_NONE
init|=
literal|0
block|,
name|R_MN10200_32
block|,
name|R_MN10200_16
block|,
name|R_MN10200_8
block|,
name|R_MN10200_24
block|,
name|R_MN10200_PCREL8
block|,
name|R_MN10200_PCREL16
block|,
name|R_MN10200_PCREL24
block|,
name|R_MN10200_MAX
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_mn10200_howto_table
index|[]
init|=
block|{
comment|/* Dummy relocation.  Does nothing.  */
name|HOWTO
argument_list|(
name|R_MN10200_NONE
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_MN10200_NONE"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
block|,
comment|/* Standard 32 bit reloc.  */
name|HOWTO
argument_list|(
name|R_MN10200_32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_MN10200_32"
argument_list|,
name|FALSE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
comment|/* Standard 16 bit reloc.  */
name|HOWTO
argument_list|(
name|R_MN10200_16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_MN10200_16"
argument_list|,
name|FALSE
argument_list|,
literal|0xffff
argument_list|,
literal|0xffff
argument_list|,
name|FALSE
argument_list|)
block|,
comment|/* Standard 8 bit reloc.  */
name|HOWTO
argument_list|(
name|R_MN10200_8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_MN10200_8"
argument_list|,
name|FALSE
argument_list|,
literal|0xff
argument_list|,
literal|0xff
argument_list|,
name|FALSE
argument_list|)
block|,
comment|/* Standard 24 bit reloc.  */
name|HOWTO
argument_list|(
name|R_MN10200_24
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|24
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_MN10200_24"
argument_list|,
name|FALSE
argument_list|,
literal|0xffffff
argument_list|,
literal|0xffffff
argument_list|,
name|FALSE
argument_list|)
block|,
comment|/* Simple 8 pc-relative reloc.  */
name|HOWTO
argument_list|(
name|R_MN10200_PCREL8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_MN10200_PCREL8"
argument_list|,
name|FALSE
argument_list|,
literal|0xff
argument_list|,
literal|0xff
argument_list|,
name|TRUE
argument_list|)
block|,
comment|/* Simple 16 pc-relative reloc.  */
name|HOWTO
argument_list|(
name|R_MN10200_PCREL16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_MN10200_PCREL16"
argument_list|,
name|FALSE
argument_list|,
literal|0xffff
argument_list|,
literal|0xffff
argument_list|,
name|TRUE
argument_list|)
block|,
comment|/* Simple 32bit pc-relative reloc with a 1 byte adjustment      to get the pc-relative offset correct.  */
name|HOWTO
argument_list|(
name|R_MN10200_PCREL24
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|24
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_MN10200_PCREL24"
argument_list|,
name|FALSE
argument_list|,
literal|0xffffff
argument_list|,
literal|0xffffff
argument_list|,
name|TRUE
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|mn10200_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_val
decl_stmt|;
name|unsigned
name|char
name|elf_reloc_val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|mn10200_reloc_map
name|mn10200_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_MN10200_NONE
block|, }
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_MN10200_32
block|, }
block|,
block|{
name|BFD_RELOC_16
block|,
name|R_MN10200_16
block|, }
block|,
block|{
name|BFD_RELOC_8
block|,
name|R_MN10200_8
block|, }
block|,
block|{
name|BFD_RELOC_24
block|,
name|R_MN10200_24
block|, }
block|,
block|{
name|BFD_RELOC_8_PCREL
block|,
name|R_MN10200_PCREL8
block|, }
block|,
block|{
name|BFD_RELOC_16_PCREL
block|,
name|R_MN10200_PCREL16
block|, }
block|,
block|{
name|BFD_RELOC_24_PCREL
block|,
name|R_MN10200_PCREL24
block|, }
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|bfd_elf32_bfd_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|mn10200_reloc_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|mn10200_reloc_map
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mn10200_reloc_map
index|[
name|i
index|]
operator|.
name|bfd_reloc_val
operator|==
name|code
condition|)
return|return
operator|&
name|elf_mn10200_howto_table
index|[
name|mn10200_reloc_map
index|[
name|i
index|]
operator|.
name|elf_reloc_val
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|bfd_elf32_bfd_reloc_name_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|r_name
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|elf_mn10200_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|elf_mn10200_howto_table
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|elf_mn10200_howto_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcasecmp
argument_list|(
name|elf_mn10200_howto_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|elf_mn10200_howto_table
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set the howto pointer for an MN10200 ELF reloc.  */
end_comment

begin_function
specifier|static
name|void
name|mn10200_info_to_howto
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r_type
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_MN10200_MAX
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf_mn10200_howto_table
index|[
name|r_type
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform a relocation as part of a final link.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mn10200_elf_final_link_relocate
parameter_list|(
name|howto
parameter_list|,
name|input_bfd
parameter_list|,
name|output_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|offset
parameter_list|,
name|value
parameter_list|,
name|addend
parameter_list|,
name|info
parameter_list|,
name|sym_sec
parameter_list|,
name|is_local
parameter_list|)
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sym_sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|is_local
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|long
name|r_type
init|=
name|howto
operator|->
name|type
decl_stmt|;
name|bfd_byte
modifier|*
name|hit_data
init|=
name|contents
operator|+
name|offset
decl_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_MN10200_NONE
case|:
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_MN10200_32
case|:
name|value
operator|+=
name|addend
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_MN10200_16
case|:
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0x7fff
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x8000
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_MN10200_8
case|:
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0x7f
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x80
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|bfd_put_8
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_MN10200_24
case|:
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0x7fffff
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x800000
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|value
operator|&=
literal|0xffffff
expr_stmt|;
name|value
operator||=
operator|(
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|&
literal|0xff000000
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_MN10200_PCREL8
case|:
name|value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
operator|(
name|offset
operator|+
literal|1
operator|)
expr_stmt|;
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0xff
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x100
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|bfd_put_8
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_MN10200_PCREL16
case|:
name|value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
operator|(
name|offset
operator|+
literal|2
operator|)
expr_stmt|;
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0xffff
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x10000
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_MN10200_PCREL24
case|:
name|value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
operator|(
name|offset
operator|+
literal|3
operator|)
expr_stmt|;
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0xffffff
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x1000000
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|value
operator|&=
literal|0xffffff
expr_stmt|;
name|value
operator||=
operator|(
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|&
literal|0xff000000
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
default|default:
return|return
name|bfd_reloc_notsupported
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Relocate an MN10200 ELF section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mn10200_elf_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|howto
operator|=
name|elf_mn10200_howto_table
operator|+
name|r_type
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_boolean
name|unresolved_reloc
decl_stmt|,
name|warned
decl_stmt|;
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|elf_discarded_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
comment|/* For relocs against symbols from removed linkonce sections, 	     or sections discarded by a linker script, we just want the 	     section contents zeroed.  Avoid any special processing.  */
name|_bfd_clear_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
continue|continue;
name|r
operator|=
name|mn10200_elf_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|output_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|info
argument_list|,
name|sec
argument_list|,
name|h
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
operator|(
name|h
condition|?
operator|&
name|h
operator|->
name|root
else|:
name|NULL
operator|)
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|bfd_reloc_undefined
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: out of range error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
name|bfd_reloc_notsupported
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unsupported relocation error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
name|bfd_reloc_dangerous
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: dangerous error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
default|default:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unknown error"
argument_list|)
expr_stmt|;
comment|/* fall through */
name|common_error
label|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This function handles relaxing for the mn10200.     There are quite a few relaxing opportunities available on the mn10200:  	* jsr:24 -> jsr:16 					   2 bytes  	* jmp:24 -> jmp:16					   2 bytes 	* jmp:16 -> bra:8					   1 byte  		* If the previous instruction is a conditional branch 		around the jump/bra, we may be able to reverse its condition 		and change its target to the jump's target.  The jump/bra 		can then be deleted.				   2 bytes  	* mov abs24 -> mov abs16	2 byte savings  	* Most instructions which accept imm24 can relax to imm16  2 bytes 	- Most instructions which accept imm16 can relax to imm8   1 byte  	* Most instructions which accept d24 can relax to d16	   2 bytes 	- Most instructions which accept d16 can relax to d8	   1 byte  	abs24, imm24, d24 all look the same at the reloc level.  It 	might make the code simpler if we had different relocs for 	the various relaxable operand types.  	We don't handle imm16->imm8 or d16->d8 as they're very rare 	and somewhat more difficult to support.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mn10200_elf_relax_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|link_info
parameter_list|,
name|again
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|bfd_boolean
modifier|*
name|again
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
comment|/* Assume nothing changes.  */
operator|*
name|again
operator|=
name|FALSE
expr_stmt|;
comment|/* We don't have to do anything for a relocatable link, if      this section does not have relocs, or if this is not a      code section.  */
if|if
condition|(
name|link_info
operator|->
name|relocatable
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|sec
operator|->
name|reloc_count
operator|==
literal|0
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
comment|/* Get a copy of the native relocations.  */
name|internal_relocs
operator|=
operator|(
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* Walk through them looking for relaxing opportunities.  */
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|symval
decl_stmt|;
comment|/* If this isn't something that can be relaxed, then ignore 	 this reloc.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10200_NONE
operator|||
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10200_8
operator|||
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10200_MAX
condition|)
continue|continue;
comment|/* Get the section contents if we haven't done so already.  */
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
block|{
comment|/* Get cached copy if it exists.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
comment|/* Go get them off disk.  */
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|&
name|contents
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* Read this BFD's local symbols if we haven't done so already.  */
if|if
condition|(
name|isymbuf
operator|==
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Get the value of the symbol referred to by the reloc.  */
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* A local symbol.  */
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|isym
operator|=
name|isymbuf
operator|+
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|sym_sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|sym_sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|sym_sec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
name|sym_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|symval
operator|=
operator|(
name|isym
operator|->
name|st_value
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sym_sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|indx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* An external symbol.  */
name|indx
operator|=
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
block|{
comment|/* This appears to be a reference to an undefined                  symbol.  Just ignore it--it will be caught by the                  regular reloc processing.  */
continue|continue;
block|}
name|symval
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
comment|/* For simplicity of coding, we are going to modify the section 	 contents, the section relocs, and the BFD symbol table.  We 	 must tell the rest of the code not to free up this 	 information.  It would be possible to instead create a table 	 of changes which have to be made, as is done in coff-mips.c; 	 that would be more work, but would require less memory when 	 the linker is run.  */
comment|/* Try to turn a 24bit pc-relative branch/call into a 16bit pc-relative 	 branch/call.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10200_PCREL24
condition|)
block|{
name|bfd_vma
name|value
init|=
name|symval
decl_stmt|;
comment|/* Deal with pc-relative gunk.  */
name|value
operator|-=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
operator|(
name|irel
operator|->
name|r_offset
operator|+
literal|3
operator|)
expr_stmt|;
name|value
operator|+=
name|irel
operator|->
name|r_addend
expr_stmt|;
comment|/* See if the value will fit in 16 bits, note the high value is 	     0x7fff + 2 as the target will be two bytes closer if we are 	     able to relax.  */
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|<
literal|0x8001
operator|&&
operator|(
name|long
operator|)
name|value
operator|>
operator|-
literal|0x8000
condition|)
block|{
name|unsigned
name|char
name|code
decl_stmt|;
comment|/* Get the opcode.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0xe0
operator|&&
name|code
operator|!=
literal|0xe1
condition|)
continue|continue;
comment|/* Note that we've changed the relocs, section contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Fix the opcode.  */
if|if
condition|(
name|code
operator|==
literal|0xe0
condition|)
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xfc
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|0xe1
condition|)
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_MN10200_PCREL16
argument_list|)
expr_stmt|;
comment|/* The opcode got shorter too, so we have to fix the offset.  */
name|irel
operator|->
name|r_offset
operator|-=
literal|1
expr_stmt|;
comment|/* Delete two bytes of data.  */
if|if
condition|(
operator|!
name|mn10200_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 		 Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Try to turn a 16bit pc-relative branch into a 8bit pc-relative 	 branch.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10200_PCREL16
condition|)
block|{
name|bfd_vma
name|value
init|=
name|symval
decl_stmt|;
comment|/* Deal with pc-relative gunk.  */
name|value
operator|-=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
operator|(
name|irel
operator|->
name|r_offset
operator|+
literal|2
operator|)
expr_stmt|;
name|value
operator|+=
name|irel
operator|->
name|r_addend
expr_stmt|;
comment|/* See if the value will fit in 8 bits, note the high value is 	     0x7f + 1 as the target will be one bytes closer if we are 	     able to relax.  */
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|<
literal|0x80
operator|&&
operator|(
name|long
operator|)
name|value
operator|>
operator|-
literal|0x80
condition|)
block|{
name|unsigned
name|char
name|code
decl_stmt|;
comment|/* Get the opcode.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0xfc
condition|)
continue|continue;
comment|/* Note that we've changed the relocs, section contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Fix the opcode.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xea
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_MN10200_PCREL8
argument_list|)
expr_stmt|;
comment|/* Delete one byte of data.  */
if|if
condition|(
operator|!
name|mn10200_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 		 Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Try to eliminate an unconditional 8 bit pc-relative branch 	 which immediately follows a conditional 8 bit pc-relative 	 branch around the unconditional branch.  	    original:		new: 	    bCC lab1		bCC' lab2 	    bra lab2 	   lab1:	       lab1:  	 This happens when the bCC can't reach lab2 at assembly time, 	 but due to other relaxations it can reach at link time.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10200_PCREL8
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|nrel
decl_stmt|;
name|bfd_vma
name|value
init|=
name|symval
decl_stmt|;
name|unsigned
name|char
name|code
decl_stmt|;
comment|/* Deal with pc-relative gunk.  */
name|value
operator|-=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
operator|(
name|irel
operator|->
name|r_offset
operator|+
literal|1
operator|)
expr_stmt|;
name|value
operator|+=
name|irel
operator|->
name|r_addend
expr_stmt|;
comment|/* Do nothing if this reloc is the last byte in the section.  */
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|==
name|sec
operator|->
name|size
condition|)
continue|continue;
comment|/* See if the next instruction is an unconditional pc-relative 	     branch, more often than not this test will fail, so we 	     test it first to speed things up.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0xea
condition|)
continue|continue;
comment|/* Also make sure the next relocation applies to the next 	     instruction and that it's a pc-relative 8 bit branch.  */
name|nrel
operator|=
name|irel
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nrel
operator|==
name|irelend
operator|||
name|irel
operator|->
name|r_offset
operator|+
literal|2
operator|!=
name|nrel
operator|->
name|r_offset
operator|||
name|ELF32_R_TYPE
argument_list|(
name|nrel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_MN10200_PCREL8
condition|)
continue|continue;
comment|/* Make sure our destination immediately follows the 	     unconditional branch.  */
if|if
condition|(
name|symval
operator|!=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|3
operator|)
condition|)
continue|continue;
comment|/* Now make sure we are a conditional branch.  This may not 	     be necessary, but why take the chance.  	     Note these checks assume that R_MN10200_PCREL8 relocs 	     only occur on bCC and bCCx insns.  If they occured 	     elsewhere, we'd need to know the start of this insn 	     for this check to be accurate.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0xe0
operator|&&
name|code
operator|!=
literal|0xe1
operator|&&
name|code
operator|!=
literal|0xe2
operator|&&
name|code
operator|!=
literal|0xe3
operator|&&
name|code
operator|!=
literal|0xe4
operator|&&
name|code
operator|!=
literal|0xe5
operator|&&
name|code
operator|!=
literal|0xe6
operator|&&
name|code
operator|!=
literal|0xe7
operator|&&
name|code
operator|!=
literal|0xe8
operator|&&
name|code
operator|!=
literal|0xe9
operator|&&
name|code
operator|!=
literal|0xec
operator|&&
name|code
operator|!=
literal|0xed
operator|&&
name|code
operator|!=
literal|0xee
operator|&&
name|code
operator|!=
literal|0xef
operator|&&
name|code
operator|!=
literal|0xfc
operator|&&
name|code
operator|!=
literal|0xfd
operator|&&
name|code
operator|!=
literal|0xfe
operator|&&
name|code
operator|!=
literal|0xff
condition|)
continue|continue;
comment|/* We also have to be sure there is no symbol/label 	     at the unconditional branch.  */
if|if
condition|(
name|mn10200_elf_symbol_address_p
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|isymbuf
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|)
condition|)
continue|continue;
comment|/* Note that we've changed the relocs, section contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Reverse the condition of the first branch.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|0xfc
case|:
name|code
operator|=
literal|0xfd
expr_stmt|;
break|break;
case|case
literal|0xfd
case|:
name|code
operator|=
literal|0xfc
expr_stmt|;
break|break;
case|case
literal|0xfe
case|:
name|code
operator|=
literal|0xff
expr_stmt|;
break|break;
case|case
literal|0xff
case|:
name|code
operator|=
literal|0xfe
expr_stmt|;
break|break;
case|case
literal|0xe8
case|:
name|code
operator|=
literal|0xe9
expr_stmt|;
break|break;
case|case
literal|0xe9
case|:
name|code
operator|=
literal|0xe8
expr_stmt|;
break|break;
case|case
literal|0xe0
case|:
name|code
operator|=
literal|0xe2
expr_stmt|;
break|break;
case|case
literal|0xe2
case|:
name|code
operator|=
literal|0xe0
expr_stmt|;
break|break;
case|case
literal|0xe3
case|:
name|code
operator|=
literal|0xe1
expr_stmt|;
break|break;
case|case
literal|0xe1
case|:
name|code
operator|=
literal|0xe3
expr_stmt|;
break|break;
case|case
literal|0xe4
case|:
name|code
operator|=
literal|0xe6
expr_stmt|;
break|break;
case|case
literal|0xe6
case|:
name|code
operator|=
literal|0xe4
expr_stmt|;
break|break;
case|case
literal|0xe7
case|:
name|code
operator|=
literal|0xe5
expr_stmt|;
break|break;
case|case
literal|0xe5
case|:
name|code
operator|=
literal|0xe7
expr_stmt|;
break|break;
case|case
literal|0xec
case|:
name|code
operator|=
literal|0xed
expr_stmt|;
break|break;
case|case
literal|0xed
case|:
name|code
operator|=
literal|0xec
expr_stmt|;
break|break;
case|case
literal|0xee
case|:
name|code
operator|=
literal|0xef
expr_stmt|;
break|break;
case|case
literal|0xef
case|:
name|code
operator|=
literal|0xee
expr_stmt|;
break|break;
block|}
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Set the reloc type and symbol for the first branch 	     from the second branch.  */
name|irel
operator|->
name|r_info
operator|=
name|nrel
operator|->
name|r_info
expr_stmt|;
comment|/* Make the reloc for the second branch a null reloc.  */
name|nrel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|nrel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_MN10200_NONE
argument_list|)
expr_stmt|;
comment|/* Delete two bytes of data.  */
if|if
condition|(
operator|!
name|mn10200_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 	     Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Try to turn a 24bit immediate, displacement or absolute address 	 into a 16bit immediate, displacement or absolute address.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10200_24
condition|)
block|{
name|bfd_vma
name|value
init|=
name|symval
decl_stmt|;
comment|/* See if the value will fit in 16 bits. 	     We allow any 16bit match here.  We prune those we can't 	     handle below.  */
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|<
literal|0x7fff
operator|&&
operator|(
name|long
operator|)
name|value
operator|>
operator|-
literal|0x8000
condition|)
block|{
name|unsigned
name|char
name|code
decl_stmt|;
comment|/* All insns which have 24bit operands are 5 bytes long, 		 the first byte will always be 0xf4, but we double check 		 it just in case.  */
comment|/* Get the first opcode.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0xf4
condition|)
continue|continue;
comment|/* Get the second opcode.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
operator|&
literal|0xfc
condition|)
block|{
comment|/* mov imm24,dn -> mov imm16,dn */
case|case
literal|0x70
case|:
comment|/* Not safe if the high bit is on as relaxing may 		     move the value out of high mem and thus not fit 		     in a signed 16bit value.  */
if|if
condition|(
name|value
operator|&
literal|0x8000
condition|)
continue|continue;
comment|/* Note that we've changed the relocation contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Fix the opcode.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xf8
operator|+
operator|(
name|code
operator|&
literal|0x03
operator|)
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_MN10200_16
argument_list|)
expr_stmt|;
comment|/* The opcode got shorter too, so we have to fix the 		     offset.  */
name|irel
operator|->
name|r_offset
operator|-=
literal|1
expr_stmt|;
comment|/* Delete two bytes of data.  */
if|if
condition|(
operator|!
name|mn10200_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 		     Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
break|break;
comment|/* mov imm24,an -> mov imm16,an 		   cmp imm24,an -> cmp imm16,an 		   mov (abs24),dn -> mov (abs16),dn 		   mov dn,(abs24) -> mov dn,(abs16) 		   movb dn,(abs24) -> movb dn,(abs16) 		   movbu (abs24),dn -> movbu (abs16),dn */
case|case
literal|0x74
case|:
case|case
literal|0x7c
case|:
case|case
literal|0xc0
case|:
case|case
literal|0x40
case|:
case|case
literal|0x44
case|:
case|case
literal|0xc8
case|:
comment|/* Note that we've changed the relocation contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x74
condition|)
name|code
operator|=
literal|0xdc
operator|+
operator|(
name|code
operator|&
literal|0x03
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x7c
condition|)
name|code
operator|=
literal|0xec
operator|+
operator|(
name|code
operator|&
literal|0x03
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0xc0
condition|)
name|code
operator|=
literal|0xc8
operator|+
operator|(
name|code
operator|&
literal|0x03
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x40
condition|)
name|code
operator|=
literal|0xc0
operator|+
operator|(
name|code
operator|&
literal|0x03
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x44
condition|)
name|code
operator|=
literal|0xc4
operator|+
operator|(
name|code
operator|&
literal|0x03
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0xc8
condition|)
name|code
operator|=
literal|0xcc
operator|+
operator|(
name|code
operator|&
literal|0x03
operator|)
expr_stmt|;
comment|/* Fix the opcode.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_MN10200_16
argument_list|)
expr_stmt|;
comment|/* The opcode got shorter too, so we have to fix the 		     offset.  */
name|irel
operator|->
name|r_offset
operator|-=
literal|1
expr_stmt|;
comment|/* Delete two bytes of data.  */
if|if
condition|(
operator|!
name|mn10200_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 		     Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
break|break;
comment|/* cmp imm24,dn -> cmp imm16,dn 		   mov (abs24),an -> mov (abs16),an 		   mov an,(abs24) -> mov an,(abs16) 		   add imm24,dn -> add imm16,dn 		   add imm24,an -> add imm16,an 		   sub imm24,dn -> sub imm16,dn 		   sub imm24,an -> sub imm16,an 		   And all d24->d16 in memory ops.  */
case|case
literal|0x78
case|:
case|case
literal|0xd0
case|:
case|case
literal|0x50
case|:
case|case
literal|0x60
case|:
case|case
literal|0x64
case|:
case|case
literal|0x68
case|:
case|case
literal|0x6c
case|:
case|case
literal|0x80
case|:
case|case
literal|0xf0
case|:
case|case
literal|0x00
case|:
case|case
literal|0x10
case|:
case|case
literal|0xb0
case|:
case|case
literal|0x30
case|:
case|case
literal|0xa0
case|:
case|case
literal|0x20
case|:
case|case
literal|0x90
case|:
comment|/* Not safe if the high bit is on as relaxing may 		     move the value out of high mem and thus not fit 		     in a signed 16bit value.  */
if|if
condition|(
operator|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x78
operator|||
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x60
operator|||
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x64
operator|||
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x68
operator|||
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x6c
operator|||
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x80
operator|||
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0xf0
operator|||
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x00
operator|||
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x10
operator|||
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0xb0
operator|||
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x30
operator|||
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0xa0
operator|||
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x20
operator|||
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x90
operator|)
operator|&&
operator|(
name|value
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* Note that we've changed the relocation contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Fix the opcode.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xf7
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x78
condition|)
name|code
operator|=
literal|0x48
operator|+
operator|(
name|code
operator|&
literal|0x03
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0xd0
condition|)
name|code
operator|=
literal|0x30
operator|+
operator|(
name|code
operator|&
literal|0x03
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x50
condition|)
name|code
operator|=
literal|0x20
operator|+
operator|(
name|code
operator|&
literal|0x03
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x60
condition|)
name|code
operator|=
literal|0x18
operator|+
operator|(
name|code
operator|&
literal|0x03
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x64
condition|)
name|code
operator|=
literal|0x08
operator|+
operator|(
name|code
operator|&
literal|0x03
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x68
condition|)
name|code
operator|=
literal|0x1c
operator|+
operator|(
name|code
operator|&
literal|0x03
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x6c
condition|)
name|code
operator|=
literal|0x0c
operator|+
operator|(
name|code
operator|&
literal|0x03
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x80
condition|)
name|code
operator|=
literal|0xc0
operator|+
operator|(
name|code
operator|&
literal|0x07
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0xf0
condition|)
name|code
operator|=
literal|0xb0
operator|+
operator|(
name|code
operator|&
literal|0x07
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x00
condition|)
name|code
operator|=
literal|0x80
operator|+
operator|(
name|code
operator|&
literal|0x07
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x10
condition|)
name|code
operator|=
literal|0xa0
operator|+
operator|(
name|code
operator|&
literal|0x07
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0xb0
condition|)
name|code
operator|=
literal|0x70
operator|+
operator|(
name|code
operator|&
literal|0x07
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x30
condition|)
name|code
operator|=
literal|0x60
operator|+
operator|(
name|code
operator|&
literal|0x07
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0xa0
condition|)
name|code
operator|=
literal|0xd0
operator|+
operator|(
name|code
operator|&
literal|0x07
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x20
condition|)
name|code
operator|=
literal|0x90
operator|+
operator|(
name|code
operator|&
literal|0x07
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0x90
condition|)
name|code
operator|=
literal|0x50
operator|+
operator|(
name|code
operator|&
literal|0x07
operator|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_MN10200_16
argument_list|)
expr_stmt|;
comment|/* Delete one bytes of data.  */
if|if
condition|(
operator|!
name|mn10200_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 		     Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
break|break;
comment|/* movb (abs24),dn ->movbu (abs16),dn extxb bn */
case|case
literal|0xc4
case|:
comment|/* Note that we've changed the reldection contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xcc
operator|+
operator|(
name|code
operator|&
literal|0x03
operator|)
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xb8
operator|+
operator|(
name|code
operator|&
literal|0x03
operator|)
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_MN10200_16
argument_list|)
expr_stmt|;
comment|/* The reloc will be applied one byte in front of its 		     current location.  */
name|irel
operator|->
name|r_offset
operator|-=
literal|1
expr_stmt|;
comment|/* Delete one bytes of data.  */
if|if
condition|(
operator|!
name|mn10200_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 		     Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the symbols for elf_link_input_bfd.  */
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
block|}
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the section contents for elf_link_input_bfd.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
block|}
block|}
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Delete some bytes from a section while relaxing.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mn10200_elf_relax_delete_bytes
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|addr
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|unsigned
name|int
name|sec_shndx
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelalign
decl_stmt|;
name|bfd_vma
name|toaddr
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymend
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|end_hashes
decl_stmt|;
name|unsigned
name|int
name|symcount
decl_stmt|;
name|sec_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
comment|/* The deletion must stop at the next ALIGN reloc for an aligment      power larger than the number of bytes we are deleting.  */
name|irelalign
operator|=
name|NULL
expr_stmt|;
name|toaddr
operator|=
name|sec
operator|->
name|size
expr_stmt|;
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
expr_stmt|;
name|irelend
operator|=
name|irel
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
comment|/* Actually delete the bytes.  */
name|memmove
argument_list|(
name|contents
operator|+
name|addr
argument_list|,
name|contents
operator|+
name|addr
operator|+
name|count
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|toaddr
operator|-
name|addr
operator|-
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|sec
operator|->
name|size
operator|-=
name|count
expr_stmt|;
comment|/* Adjust all the relocs.  */
for|for
control|(
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
comment|/* Get the new reloc address.  */
if|if
condition|(
operator|(
name|irel
operator|->
name|r_offset
operator|>
name|addr
operator|&&
name|irel
operator|->
name|r_offset
operator|<
name|toaddr
operator|)
condition|)
name|irel
operator|->
name|r_offset
operator|-=
name|count
expr_stmt|;
block|}
comment|/* Adjust the local symbols defined in this section.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|isym
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
for|for
control|(
name|isymend
operator|=
name|isym
operator|+
name|symtab_hdr
operator|->
name|sh_info
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
control|)
block|{
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|sec_shndx
operator|&&
name|isym
operator|->
name|st_value
operator|>
name|addr
operator|&&
name|isym
operator|->
name|st_value
operator|<
name|toaddr
condition|)
name|isym
operator|->
name|st_value
operator|-=
name|count
expr_stmt|;
block|}
comment|/* Now adjust the global symbols defined in this section.  */
name|symcount
operator|=
operator|(
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|end_hashes
operator|=
name|sym_hashes
operator|+
name|symcount
expr_stmt|;
for|for
control|(
init|;
name|sym_hashes
operator|<
name|end_hashes
condition|;
name|sym_hashes
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|sym_hash
init|=
operator|*
name|sym_hashes
decl_stmt|;
if|if
condition|(
operator|(
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|sec
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|>
name|addr
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|<
name|toaddr
condition|)
block|{
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|-=
name|count
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if a symbol exists at the given address, else return    FALSE.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mn10200_elf_symbol_address_p
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|isym
parameter_list|,
name|addr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|unsigned
name|int
name|sec_shndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymend
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|end_hashes
decl_stmt|;
name|unsigned
name|int
name|symcount
decl_stmt|;
name|sec_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
comment|/* Examine all the local symbols.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
for|for
control|(
name|isymend
operator|=
name|isym
operator|+
name|symtab_hdr
operator|->
name|sh_info
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
control|)
block|{
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|sec_shndx
operator|&&
name|isym
operator|->
name|st_value
operator|==
name|addr
condition|)
return|return
name|TRUE
return|;
block|}
name|symcount
operator|=
operator|(
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|end_hashes
operator|=
name|sym_hashes
operator|+
name|symcount
expr_stmt|;
for|for
control|(
init|;
name|sym_hashes
operator|<
name|end_hashes
condition|;
name|sym_hashes
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|sym_hash
init|=
operator|*
name|sym_hashes
decl_stmt|;
if|if
condition|(
operator|(
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|sec
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|==
name|addr
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* This is a version of bfd_generic_get_relocated_section_contents    which uses mn10200_elf_relocate_section.  */
end_comment

begin_function
specifier|static
name|bfd_byte
modifier|*
name|mn10200_elf_get_relocated_section_contents
parameter_list|(
name|output_bfd
parameter_list|,
name|link_info
parameter_list|,
name|link_order
parameter_list|,
name|data
parameter_list|,
name|relocatable
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|bfd_boolean
name|relocatable
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|input_section
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
init|=
name|input_section
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sections
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
comment|/* We only need to handle the case of relaxing, or of having a      particular set of section contents, specially.  */
if|if
condition|(
name|relocatable
operator|||
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|==
name|NULL
condition|)
return|return
name|bfd_generic_get_relocated_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|link_info
argument_list|,
name|link_order
argument_list|,
name|data
argument_list|,
name|relocatable
argument_list|,
name|symbols
argument_list|)
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
argument_list|,
operator|(
name|size_t
operator|)
name|input_section
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|input_section
operator|->
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymend
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secpp
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|internal_relocs
operator|=
operator|(
name|_bfd_elf_link_read_relocs
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
name|amt
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|sections
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sections
operator|==
name|NULL
operator|&&
name|amt
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|isymend
operator|=
name|isymbuf
operator|+
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
name|isym
operator|=
name|isymbuf
operator|,
name|secpp
operator|=
name|sections
init|;
name|isym
operator|<
name|isymend
condition|;
operator|++
name|isym
operator|,
operator|++
name|secpp
control|)
block|{
name|asection
modifier|*
name|isec
decl_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|isec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|isec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|isec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
name|isec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|input_bfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
operator|*
name|secpp
operator|=
name|isec
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mn10200_elf_relocate_section
argument_list|(
name|output_bfd
argument_list|,
name|link_info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|data
argument_list|,
name|internal_relocs
argument_list|,
name|isymbuf
argument_list|,
name|sections
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
return|return
name|data
return|;
name|error_return
label|:
if|if
condition|(
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_mn10200_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-mn10200"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_mn10200
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_MN10200
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT1
value|EM_CYGNUS_MN10200
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1000
end_define

begin_define
define|#
directive|define
name|elf_backend_rela_normal
value|1
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|mn10200_info_to_howto
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|mn10200_elf_relocate_section
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_relax_section
value|mn10200_elf_relax_section
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_get_relocated_section_contents
define|\
value|mn10200_elf_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|elf_symbol_leading_char
value|'_'
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

