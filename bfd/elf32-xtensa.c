begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Xtensa-specific support for 32-bit ELF.    Copyright 2003, 2004, 2005 Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/xtensa.h"
end_include

begin_include
include|#
directive|include
file|"xtensa-isa.h"
end_include

begin_include
include|#
directive|include
file|"xtensa-config.h"
end_include

begin_define
define|#
directive|define
name|XTENSA_NO_NOP_REMOVAL
value|0
end_define

begin_comment
comment|/* Local helper functions.  */
end_comment

begin_function_decl
specifier|static
name|bfd_boolean
name|add_extra_plt_sections
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|vsprint_msg
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTRIBUTE_PRINTF
parameter_list|(
function_decl|2
operator|,
function_decl|4
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|bfd_elf_xtensa_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|do_fix_for_relocatable_link
parameter_list|(
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_fix_for_final_link
parameter_list|(
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|bfd_vma
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Local functions to handle Xtensa configurability.  */
end_comment

begin_function_decl
specifier|static
name|bfd_boolean
name|is_indirect_call_opcode
parameter_list|(
name|xtensa_opcode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|is_direct_call_opcode
parameter_list|(
name|xtensa_opcode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|is_windowed_call_opcode
parameter_list|(
name|xtensa_opcode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|xtensa_opcode
name|get_const16_opcode
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|xtensa_opcode
name|get_l32r_opcode
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_vma
name|l32r_offset
parameter_list|(
name|bfd_vma
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_relocation_opnd
parameter_list|(
name|xtensa_opcode
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_relocation_slot
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|xtensa_opcode
name|get_relocation_opcode
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|is_l32r_relocation
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|is_alt_relocation
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|is_operand_relocation
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_size_type
name|insn_decode_len
parameter_list|(
name|bfd_byte
modifier|*
parameter_list|,
name|bfd_size_type
parameter_list|,
name|bfd_size_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|xtensa_opcode
name|insn_decode_opcode
parameter_list|(
name|bfd_byte
modifier|*
parameter_list|,
name|bfd_size_type
parameter_list|,
name|bfd_size_type
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|check_branch_target_aligned
parameter_list|(
name|bfd_byte
modifier|*
parameter_list|,
name|bfd_size_type
parameter_list|,
name|bfd_vma
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|check_loop_aligned
parameter_list|(
name|bfd_byte
modifier|*
parameter_list|,
name|bfd_size_type
parameter_list|,
name|bfd_vma
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|check_branch_target_aligned_address
parameter_list|(
name|bfd_vma
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_size_type
name|get_asm_simplify_size
parameter_list|(
name|bfd_byte
modifier|*
parameter_list|,
name|bfd_size_type
parameter_list|,
name|bfd_size_type
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Functions for link-time code simplifications.  */
end_comment

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|elf_xtensa_do_asm_simplify
parameter_list|(
name|bfd_byte
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|bfd_vma
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|contract_asm_expansion
parameter_list|(
name|bfd_byte
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|xtensa_opcode
name|swap_callx_for_call_opcode
parameter_list|(
name|xtensa_opcode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|xtensa_opcode
name|get_expanded_call_opcode
parameter_list|(
name|bfd_byte
modifier|*
parameter_list|,
name|int
parameter_list|,
name|bfd_boolean
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Access to internal relocations, section contents and symbols.  */
end_comment

begin_function_decl
specifier|static
name|Elf_Internal_Rela
modifier|*
name|retrieve_internal_relocs
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pin_internal_relocs
parameter_list|(
name|asection
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|release_internal_relocs
parameter_list|(
name|asection
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_byte
modifier|*
name|retrieve_contents
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pin_contents
parameter_list|(
name|asection
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|release_contents
parameter_list|(
name|asection
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Elf_Internal_Sym
modifier|*
name|retrieve_local_syms
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Miscellaneous utility functions.  */
end_comment

begin_function_decl
specifier|static
name|asection
modifier|*
name|elf_xtensa_get_plt_section
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|asection
modifier|*
name|elf_xtensa_get_gotplt_section
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|asection
modifier|*
name|get_elf_r_symndx_section
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|elf_link_hash_entry
modifier|*
name|get_elf_r_symndx_hash_entry
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_vma
name|get_elf_r_symndx_offset
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|is_reloc_sym_weak
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|pcrel_reloc_fits
parameter_list|(
name|xtensa_opcode
parameter_list|,
name|int
parameter_list|,
name|bfd_vma
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|xtensa_is_property_section
parameter_list|(
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|xtensa_is_littable_section
parameter_list|(
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|internal_reloc_compare
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|internal_reloc_matches
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|xtensa_get_property_section_name
parameter_list|(
name|asection
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|flagword
name|xtensa_get_property_predef_flags
parameter_list|(
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Other functions called directly by the linker.  */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|deps_callback_t
function_decl|)
parameter_list|(
name|asection
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|extern
name|bfd_boolean
name|xtensa_callback_required_dependence
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|deps_callback_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Globally visible flag for choosing size optimization of NOP removal    instead of branch-target-aware minimization for NOP removal.    When nonzero, narrow all instructions and remove all NOPs possible    around longcall expansions.  */
end_comment

begin_decl_stmt
name|int
name|elf32xtensa_size_opt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The "new_section_hook" is used to set up a per-section    "xtensa_relax_info" data structure with additional information used    during relaxation.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|xtensa_relax_info_struct
name|xtensa_relax_info
typedef|;
end_typedef

begin_comment
comment|/* Total count of PLT relocations seen during check_relocs.    The actual PLT code must be split into multiple sections and all    the sections have to be created before size_dynamic_sections,    where we figure out the exact number of PLT entries that will be    needed.  It is OK if this count is an overestimate, e.g., some    relocations may be removed by GC.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|plt_reloc_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The GNU tools do not easily allow extending interfaces to pass around    the pointer to the Xtensa ISA information, so instead we add a global    variable here (in BFD) that can be used by any of the tools that need    this information. */
end_comment

begin_decl_stmt
name|xtensa_isa
name|xtensa_default_isa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When this is true, relocations may have been modified to refer to    symbols from other input files.  The per-section list of "fix"    records needs to be checked when resolving relocations.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|relaxing_section
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When this is true, during final links, literals that cannot be    coalesced and their relocations may be moved to other sections.  */
end_comment

begin_decl_stmt
name|int
name|elf32xtensa_no_literal_movement
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_howto_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|R_XTENSA_NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_NONE"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_32"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
comment|/* Replace a 32-bit value with a value from the runtime linker (only      used by linker-generated stub functions).  The r_addend value is      special: 1 means to substitute a pointer to the runtime linker's      dynamic resolver function; 2 means to substitute the link map for      the shared object.  */
name|HOWTO
argument_list|(
name|R_XTENSA_RTLD
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|NULL
argument_list|,
literal|"R_XTENSA_RTLD"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_GLOB_DAT
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_XTENSA_GLOB_DAT"
argument_list|,
name|FALSE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_JMP_SLOT
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_XTENSA_JMP_SLOT"
argument_list|,
name|FALSE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_RELATIVE
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_XTENSA_RELATIVE"
argument_list|,
name|FALSE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_PLT
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_PLT"
argument_list|,
name|FALSE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|7
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_OP0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_OP0"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_OP1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_OP1"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_OP2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_OP2"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
comment|/* Assembly auto-expansion.  */
name|HOWTO
argument_list|(
name|R_XTENSA_ASM_EXPAND
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_ASM_EXPAND"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|FALSE
argument_list|)
block|,
comment|/* Relax assembly auto-expansion.  */
name|HOWTO
argument_list|(
name|R_XTENSA_ASM_SIMPLIFY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_ASM_SIMPLIFY"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|13
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|14
argument_list|)
block|,
comment|/* GNU extension to record C++ vtable hierarchy.  */
name|HOWTO
argument_list|(
name|R_XTENSA_GNU_VTINHERIT
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|NULL
argument_list|,
literal|"R_XTENSA_GNU_VTINHERIT"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|FALSE
argument_list|)
block|,
comment|/* GNU extension to record C++ vtable member usage.  */
name|HOWTO
argument_list|(
name|R_XTENSA_GNU_VTENTRY
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|_bfd_elf_rel_vtable_reloc_fn
argument_list|,
literal|"R_XTENSA_GNU_VTENTRY"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|FALSE
argument_list|)
block|,
comment|/* Relocations for supporting difference of symbols.  */
name|HOWTO
argument_list|(
name|R_XTENSA_DIFF8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_DIFF8"
argument_list|,
name|FALSE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_DIFF16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_DIFF16"
argument_list|,
name|FALSE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_DIFF32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_DIFF32"
argument_list|,
name|FALSE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
comment|/* General immediate operand relocations.  */
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT0_OP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT0_OP"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT1_OP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT1_OP"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT2_OP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT2_OP"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT3_OP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT3_OP"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT4_OP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT4_OP"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT5_OP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT5_OP"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT6_OP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT6_OP"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT7_OP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT7_OP"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT8_OP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT8_OP"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT9_OP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT9_OP"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT10_OP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT10_OP"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT11_OP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT11_OP"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT12_OP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT12_OP"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT13_OP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT13_OP"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT14_OP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT14_OP"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
comment|/* "Alternate" relocations.  The meaning of these is opcode-specific.  */
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT0_ALT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT0_ALT"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT1_ALT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT1_ALT"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT2_ALT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT2_ALT"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT3_ALT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT3_ALT"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT4_ALT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT4_ALT"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT5_ALT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT5_ALT"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT6_ALT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT6_ALT"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT7_ALT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT7_ALT"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT8_ALT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT8_ALT"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT9_ALT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT9_ALT"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT10_ALT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT10_ALT"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT11_ALT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT11_ALT"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT12_ALT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT12_ALT"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_SLOT13_ALT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT13_ALT"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
argument|R_XTENSA_SLOT14_ALT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
argument|TRUE
argument_list|,
literal|0
argument_list|,
argument|complain_overflow_dont
argument_list|,
argument|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_SLOT14_ALT"
argument_list|,
argument|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
argument|TRUE
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|DEBUG_GEN_RELOC
end_if

begin_define
define|#
directive|define
name|TRACE
parameter_list|(
name|str
parameter_list|)
define|\
value|fprintf (stderr, "Xtensa bfd reloc lookup %d (%s)\n", code, str)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TRACE
parameter_list|(
name|str
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|elf_xtensa_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BFD_RELOC_NONE
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_NONE"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_NONE
index|]
return|;
case|case
name|BFD_RELOC_32
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_32"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_32
index|]
return|;
case|case
name|BFD_RELOC_XTENSA_DIFF8
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_XTENSA_DIFF8"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_DIFF8
index|]
return|;
case|case
name|BFD_RELOC_XTENSA_DIFF16
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_XTENSA_DIFF16"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_DIFF16
index|]
return|;
case|case
name|BFD_RELOC_XTENSA_DIFF32
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_XTENSA_DIFF32"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_DIFF32
index|]
return|;
case|case
name|BFD_RELOC_XTENSA_RTLD
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_XTENSA_RTLD"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_RTLD
index|]
return|;
case|case
name|BFD_RELOC_XTENSA_GLOB_DAT
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_XTENSA_GLOB_DAT"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_GLOB_DAT
index|]
return|;
case|case
name|BFD_RELOC_XTENSA_JMP_SLOT
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_XTENSA_JMP_SLOT"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_JMP_SLOT
index|]
return|;
case|case
name|BFD_RELOC_XTENSA_RELATIVE
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_XTENSA_RELATIVE"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_RELATIVE
index|]
return|;
case|case
name|BFD_RELOC_XTENSA_PLT
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_XTENSA_PLT"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_PLT
index|]
return|;
case|case
name|BFD_RELOC_XTENSA_OP0
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_XTENSA_OP0"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_OP0
index|]
return|;
case|case
name|BFD_RELOC_XTENSA_OP1
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_XTENSA_OP1"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_OP1
index|]
return|;
case|case
name|BFD_RELOC_XTENSA_OP2
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_XTENSA_OP2"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_OP2
index|]
return|;
case|case
name|BFD_RELOC_XTENSA_ASM_EXPAND
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_XTENSA_ASM_EXPAND"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_ASM_EXPAND
index|]
return|;
case|case
name|BFD_RELOC_XTENSA_ASM_SIMPLIFY
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_XTENSA_ASM_SIMPLIFY"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_ASM_SIMPLIFY
index|]
return|;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_VTABLE_INHERIT"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_GNU_VTINHERIT
index|]
return|;
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_VTABLE_ENTRY"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_GNU_VTENTRY
index|]
return|;
default|default:
if|if
condition|(
name|code
operator|>=
name|BFD_RELOC_XTENSA_SLOT0_OP
operator|&&
name|code
operator|<=
name|BFD_RELOC_XTENSA_SLOT14_OP
condition|)
block|{
name|unsigned
name|n
init|=
operator|(
name|R_XTENSA_SLOT0_OP
operator|+
operator|(
name|code
operator|-
name|BFD_RELOC_XTENSA_SLOT0_OP
operator|)
operator|)
decl_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|n
index|]
return|;
block|}
if|if
condition|(
name|code
operator|>=
name|BFD_RELOC_XTENSA_SLOT0_ALT
operator|&&
name|code
operator|<=
name|BFD_RELOC_XTENSA_SLOT14_ALT
condition|)
block|{
name|unsigned
name|n
init|=
operator|(
name|R_XTENSA_SLOT0_ALT
operator|+
operator|(
name|code
operator|-
name|BFD_RELOC_XTENSA_SLOT0_ALT
operator|)
operator|)
decl_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
name|n
index|]
return|;
block|}
break|break;
block|}
name|TRACE
argument_list|(
literal|"Unknown"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Given an ELF "rela" relocation, find the corresponding howto and record    it in the BFD internal arelent representation of the relocation.  */
end_comment

begin_function
specifier|static
name|void
name|elf_xtensa_info_to_howto_rela
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|cache_ptr
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|dst
parameter_list|)
block|{
name|unsigned
name|int
name|r_type
init|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|r_type
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_XTENSA_max
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf_howto_table
index|[
name|r_type
index|]
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for the Xtensa ELF linker.  */
end_comment

begin_comment
comment|/* The name of the dynamic interpreter.  This is put in the .interp    section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/lib/ld.so"
end_define

begin_comment
comment|/* The size in bytes of an entry in the procedure linkage table.    (This does _not_ include the space for the literals associated with    the PLT entry.) */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_SIZE
value|16
end_define

begin_comment
comment|/* For _really_ large PLTs, we may need to alternate between literals    and code to keep the literals within the 256K range of the L32R    instructions in the code.  It's unlikely that anyone would ever need    such a big PLT, but an arbitrary limit on the PLT size would be bad.    Thus, we split the PLT into chunks.  Since there's very little    overhead (2 extra literals) for each chunk, the chunk size is kept    small so that the code for handling multiple chunks get used and    tested regularly.  With 254 entries, there are 1K of literals for    each chunk, and that seems like a nice round number.  */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRIES_PER_CHUNK
value|254
end_define

begin_comment
comment|/* PLT entries are actually used as stub functions for lazy symbol    resolution.  Once the symbol is resolved, the stub function is never    invoked.  Note: the 32-byte frame size used here cannot be changed    without a corresponding change in the runtime linker.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_xtensa_be_plt_entry
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0x6c
block|,
literal|0x10
block|,
literal|0x04
block|,
comment|/* entry sp, 32 */
literal|0x18
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* l32r  a8, [got entry for rtld's resolver] */
literal|0x1a
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* l32r  a10, [got entry for rtld's link map] */
literal|0x1b
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* l32r  a11, [literal for reloc index] */
literal|0x0a
block|,
literal|0x80
block|,
literal|0x00
block|,
comment|/* jx    a8 */
literal|0
comment|/* unused */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_xtensa_le_plt_entry
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0x36
block|,
literal|0x41
block|,
literal|0x00
block|,
comment|/* entry sp, 32 */
literal|0x81
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* l32r  a8, [got entry for rtld's resolver] */
literal|0xa1
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* l32r  a10, [got entry for rtld's link map] */
literal|0xb1
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* l32r  a11, [literal for reloc index] */
literal|0xa0
block|,
literal|0x08
block|,
literal|0x00
block|,
comment|/* jx    a8 */
literal|0
comment|/* unused */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|bfd_boolean
name|xtensa_elf_dynamic_symbol_p
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
comment|/* Check if we should do dynamic things to this symbol.  The      "ignore_protected" argument need not be set, because Xtensa code      does not require special handling of STV_PROTECTED to make function      pointer comparisons work properly.  The PLT addresses are never      used for function pointers.  */
return|return
name|_bfd_elf_dynamic_symbol_p
argument_list|(
name|h
argument_list|,
name|info
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|property_table_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|ap
parameter_list|,
specifier|const
name|void
modifier|*
name|bp
parameter_list|)
block|{
specifier|const
name|property_table_entry
modifier|*
name|a
init|=
operator|(
specifier|const
name|property_table_entry
operator|*
operator|)
name|ap
decl_stmt|;
specifier|const
name|property_table_entry
modifier|*
name|b
init|=
operator|(
specifier|const
name|property_table_entry
operator|*
operator|)
name|bp
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|address
operator|==
name|b
operator|->
name|address
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|size
operator|!=
name|b
operator|->
name|size
condition|)
return|return
operator|(
name|a
operator|->
name|size
operator|-
name|b
operator|->
name|size
operator|)
return|;
if|if
condition|(
operator|(
name|a
operator|->
name|flags
operator|&
name|XTENSA_PROP_ALIGN
operator|)
operator|!=
operator|(
name|b
operator|->
name|flags
operator|&
name|XTENSA_PROP_ALIGN
operator|)
condition|)
return|return
operator|(
operator|(
name|b
operator|->
name|flags
operator|&
name|XTENSA_PROP_ALIGN
operator|)
operator|-
operator|(
name|a
operator|->
name|flags
operator|&
name|XTENSA_PROP_ALIGN
operator|)
operator|)
return|;
if|if
condition|(
operator|(
name|a
operator|->
name|flags
operator|&
name|XTENSA_PROP_ALIGN
operator|)
operator|&&
operator|(
name|GET_XTENSA_PROP_ALIGNMENT
argument_list|(
name|a
operator|->
name|flags
argument_list|)
operator|!=
name|GET_XTENSA_PROP_ALIGNMENT
argument_list|(
name|b
operator|->
name|flags
argument_list|)
operator|)
condition|)
return|return
operator|(
name|GET_XTENSA_PROP_ALIGNMENT
argument_list|(
name|a
operator|->
name|flags
argument_list|)
operator|-
name|GET_XTENSA_PROP_ALIGNMENT
argument_list|(
name|b
operator|->
name|flags
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|a
operator|->
name|flags
operator|&
name|XTENSA_PROP_UNREACHABLE
operator|)
operator|!=
operator|(
name|b
operator|->
name|flags
operator|&
name|XTENSA_PROP_UNREACHABLE
operator|)
condition|)
return|return
operator|(
operator|(
name|b
operator|->
name|flags
operator|&
name|XTENSA_PROP_UNREACHABLE
operator|)
operator|-
operator|(
name|a
operator|->
name|flags
operator|&
name|XTENSA_PROP_UNREACHABLE
operator|)
operator|)
return|;
return|return
operator|(
name|a
operator|->
name|flags
operator|-
name|b
operator|->
name|flags
operator|)
return|;
block|}
return|return
operator|(
name|a
operator|->
name|address
operator|-
name|b
operator|->
name|address
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|property_table_matches
parameter_list|(
specifier|const
name|void
modifier|*
name|ap
parameter_list|,
specifier|const
name|void
modifier|*
name|bp
parameter_list|)
block|{
specifier|const
name|property_table_entry
modifier|*
name|a
init|=
operator|(
specifier|const
name|property_table_entry
operator|*
operator|)
name|ap
decl_stmt|;
specifier|const
name|property_table_entry
modifier|*
name|b
init|=
operator|(
specifier|const
name|property_table_entry
operator|*
operator|)
name|bp
decl_stmt|;
comment|/* Check if one entry overlaps with the other.  */
if|if
condition|(
operator|(
name|b
operator|->
name|address
operator|>=
name|a
operator|->
name|address
operator|&&
name|b
operator|->
name|address
operator|<
operator|(
name|a
operator|->
name|address
operator|+
name|a
operator|->
name|size
operator|)
operator|)
operator|||
operator|(
name|a
operator|->
name|address
operator|>=
name|b
operator|->
name|address
operator|&&
name|a
operator|->
name|address
operator|<
operator|(
name|b
operator|->
name|address
operator|+
name|b
operator|->
name|size
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|a
operator|->
name|address
operator|-
name|b
operator|->
name|address
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get the literal table or property table entries for the given    section.  Sets TABLE_P and returns the number of entries.  On    error, returns a negative value.  */
end_comment

begin_function
specifier|static
name|int
name|xtensa_read_table_entries
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|property_table_entry
modifier|*
modifier|*
name|table_p
parameter_list|,
specifier|const
name|char
modifier|*
name|sec_name
parameter_list|,
name|bfd_boolean
name|output_addr
parameter_list|)
block|{
name|asection
modifier|*
name|table_section
decl_stmt|;
name|char
modifier|*
name|table_section_name
decl_stmt|;
name|bfd_size_type
name|table_size
init|=
literal|0
decl_stmt|;
name|bfd_byte
modifier|*
name|table_data
decl_stmt|;
name|property_table_entry
modifier|*
name|blocks
decl_stmt|;
name|int
name|blk
decl_stmt|,
name|block_count
decl_stmt|;
name|bfd_size_type
name|num_records
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|bfd_vma
name|section_addr
decl_stmt|;
name|flagword
name|predef_flags
decl_stmt|;
name|bfd_size_type
name|table_entry_size
decl_stmt|;
if|if
condition|(
operator|!
name|section
operator|||
operator|!
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|||
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
condition|)
block|{
operator|*
name|table_p
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
name|table_section_name
operator|=
name|xtensa_get_property_section_name
argument_list|(
name|section
argument_list|,
name|sec_name
argument_list|)
expr_stmt|;
name|table_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|table_section_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|table_section_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|table_section
condition|)
name|table_size
operator|=
name|table_section
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|table_size
operator|==
literal|0
condition|)
block|{
operator|*
name|table_p
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
name|predef_flags
operator|=
name|xtensa_get_property_predef_flags
argument_list|(
name|table_section
argument_list|)
expr_stmt|;
name|table_entry_size
operator|=
literal|12
expr_stmt|;
if|if
condition|(
name|predef_flags
condition|)
name|table_entry_size
operator|-=
literal|4
expr_stmt|;
name|num_records
operator|=
name|table_size
operator|/
name|table_entry_size
expr_stmt|;
name|table_data
operator|=
name|retrieve_contents
argument_list|(
name|abfd
argument_list|,
name|table_section
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|blocks
operator|=
operator|(
name|property_table_entry
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|num_records
operator|*
sizeof|sizeof
argument_list|(
name|property_table_entry
argument_list|)
argument_list|)
expr_stmt|;
name|block_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|output_addr
condition|)
name|section_addr
operator|=
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|section
operator|->
name|output_offset
expr_stmt|;
else|else
name|section_addr
operator|=
name|section
operator|->
name|vma
expr_stmt|;
comment|/* If the file has not yet been relocated, process the relocations      and sort out the table entries that apply to the specified section.  */
name|internal_relocs
operator|=
name|retrieve_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|table_section
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|&&
operator|!
name|table_section
operator|->
name|reloc_done
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table_section
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|rel
init|=
operator|&
name|internal_relocs
index|[
name|i
index|]
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_XTENSA_NONE
condition|)
continue|continue;
name|BFD_ASSERT
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_XTENSA_32
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_elf_r_symndx_section
argument_list|(
name|abfd
argument_list|,
name|r_symndx
argument_list|)
operator|==
name|section
condition|)
block|{
name|bfd_vma
name|sym_off
init|=
name|get_elf_r_symndx_offset
argument_list|(
name|abfd
argument_list|,
name|r_symndx
argument_list|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sym_off
operator|==
literal|0
argument_list|)
expr_stmt|;
name|blocks
index|[
name|block_count
index|]
operator|.
name|address
operator|=
operator|(
name|section_addr
operator|+
name|sym_off
operator|+
name|rel
operator|->
name|r_addend
operator|+
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|table_data
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
expr_stmt|;
name|blocks
index|[
name|block_count
index|]
operator|.
name|size
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|table_data
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|predef_flags
condition|)
name|blocks
index|[
name|block_count
index|]
operator|.
name|flags
operator|=
name|predef_flags
expr_stmt|;
else|else
name|blocks
index|[
name|block_count
index|]
operator|.
name|flags
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|table_data
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|8
argument_list|)
expr_stmt|;
name|block_count
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* The file has already been relocated and the addresses are 	 already in the table.  */
name|bfd_vma
name|off
decl_stmt|;
name|bfd_size_type
name|section_limit
init|=
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
decl_stmt|;
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|table_size
condition|;
name|off
operator|+=
name|table_entry_size
control|)
block|{
name|bfd_vma
name|address
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|table_data
operator|+
name|off
argument_list|)
decl_stmt|;
if|if
condition|(
name|address
operator|>=
name|section_addr
operator|&&
name|address
operator|<
name|section_addr
operator|+
name|section_limit
condition|)
block|{
name|blocks
index|[
name|block_count
index|]
operator|.
name|address
operator|=
name|address
expr_stmt|;
name|blocks
index|[
name|block_count
index|]
operator|.
name|size
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|table_data
operator|+
name|off
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|predef_flags
condition|)
name|blocks
index|[
name|block_count
index|]
operator|.
name|flags
operator|=
name|predef_flags
expr_stmt|;
else|else
name|blocks
index|[
name|block_count
index|]
operator|.
name|flags
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|table_data
operator|+
name|off
operator|+
literal|8
argument_list|)
expr_stmt|;
name|block_count
operator|++
expr_stmt|;
block|}
block|}
block|}
name|release_contents
argument_list|(
name|table_section
argument_list|,
name|table_data
argument_list|)
expr_stmt|;
name|release_internal_relocs
argument_list|(
name|table_section
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|block_count
operator|>
literal|0
condition|)
block|{
comment|/* Now sort them into address order for easy reference.  */
name|qsort
argument_list|(
name|blocks
argument_list|,
name|block_count
argument_list|,
sizeof|sizeof
argument_list|(
name|property_table_entry
argument_list|)
argument_list|,
name|property_table_compare
argument_list|)
expr_stmt|;
comment|/* Check that the table contents are valid.  Problems may occur,          for example, if an unrelocated object file is stripped.  */
for|for
control|(
name|blk
operator|=
literal|1
init|;
name|blk
operator|<
name|block_count
condition|;
name|blk
operator|++
control|)
block|{
comment|/* The only circumstance where two entries may legitimately 	     have the same address is when one of them is a zero-size 	     placeholder to mark a place where fill can be inserted. 	     The zero-size entry should come first.  */
if|if
condition|(
name|blocks
index|[
name|blk
operator|-
literal|1
index|]
operator|.
name|address
operator|==
name|blocks
index|[
name|blk
index|]
operator|.
name|address
operator|&&
name|blocks
index|[
name|blk
operator|-
literal|1
index|]
operator|.
name|size
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A): invalid property table"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
operator|*
name|table_p
operator|=
name|blocks
expr_stmt|;
return|return
name|block_count
return|;
block|}
end_function

begin_function
specifier|static
name|property_table_entry
modifier|*
name|elf_xtensa_find_property_entry
parameter_list|(
name|property_table_entry
modifier|*
name|property_table
parameter_list|,
name|int
name|property_table_size
parameter_list|,
name|bfd_vma
name|addr
parameter_list|)
block|{
name|property_table_entry
name|entry
decl_stmt|;
name|property_table_entry
modifier|*
name|rv
decl_stmt|;
if|if
condition|(
name|property_table_size
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|entry
operator|.
name|address
operator|=
name|addr
expr_stmt|;
name|entry
operator|.
name|size
operator|=
literal|1
expr_stmt|;
name|entry
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|rv
operator|=
name|bsearch
argument_list|(
operator|&
name|entry
argument_list|,
name|property_table
argument_list|,
name|property_table_size
argument_list|,
sizeof|sizeof
argument_list|(
name|property_table_entry
argument_list|)
argument_list|,
name|property_table_matches
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_in_literal_pool
parameter_list|(
name|property_table_entry
modifier|*
name|lit_table
parameter_list|,
name|int
name|lit_table_size
parameter_list|,
name|bfd_vma
name|addr
parameter_list|)
block|{
if|if
condition|(
name|elf_xtensa_find_property_entry
argument_list|(
name|lit_table
argument_list|,
name|lit_table_size
argument_list|,
name|addr
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look through the relocs for a section during the first phase, and    calculate needed space in the dynamic reloc sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_check_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|NUM_SHDR_ENTRIES
argument_list|(
name|symtab_hdr
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: bad symbol index: %d"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_XTENSA_32
case|:
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
goto|goto
name|local_literal
goto|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|<=
literal|0
condition|)
name|h
operator|->
name|got
operator|.
name|refcount
operator|=
literal|1
expr_stmt|;
else|else
name|h
operator|->
name|got
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|R_XTENSA_PLT
case|:
comment|/* If this relocation is against a local symbol, then it's 	     exactly the same as a normal local GOT entry.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
goto|goto
name|local_literal
goto|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|<=
literal|0
condition|)
block|{
name|h
operator|->
name|needs_plt
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|refcount
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|h
operator|->
name|plt
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
comment|/* Keep track of the total PLT relocation count even if we 		 don't yet know whether the dynamic sections will be 		 created.  */
name|plt_reloc_count
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
if|if
condition|(
operator|!
name|add_extra_plt_sections
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|plt_reloc_count
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
break|break;
name|local_literal
label|:
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
comment|/* This is a global offset table entry for a local symbol.  */
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|size
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|size
operator|*=
sizeof|sizeof
argument_list|(
name|bfd_signed_vma
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
operator|(
name|bfd_signed_vma
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_got_refcounts
expr_stmt|;
block|}
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|R_XTENSA_OP0
case|:
case|case
name|R_XTENSA_OP1
case|:
case|case
name|R_XTENSA_OP2
case|:
case|case
name|R_XTENSA_SLOT0_OP
case|:
case|case
name|R_XTENSA_SLOT1_OP
case|:
case|case
name|R_XTENSA_SLOT2_OP
case|:
case|case
name|R_XTENSA_SLOT3_OP
case|:
case|case
name|R_XTENSA_SLOT4_OP
case|:
case|case
name|R_XTENSA_SLOT5_OP
case|:
case|case
name|R_XTENSA_SLOT6_OP
case|:
case|case
name|R_XTENSA_SLOT7_OP
case|:
case|case
name|R_XTENSA_SLOT8_OP
case|:
case|case
name|R_XTENSA_SLOT9_OP
case|:
case|case
name|R_XTENSA_SLOT10_OP
case|:
case|case
name|R_XTENSA_SLOT11_OP
case|:
case|case
name|R_XTENSA_SLOT12_OP
case|:
case|case
name|R_XTENSA_SLOT13_OP
case|:
case|case
name|R_XTENSA_SLOT14_OP
case|:
case|case
name|R_XTENSA_SLOT0_ALT
case|:
case|case
name|R_XTENSA_SLOT1_ALT
case|:
case|case
name|R_XTENSA_SLOT2_ALT
case|:
case|case
name|R_XTENSA_SLOT3_ALT
case|:
case|case
name|R_XTENSA_SLOT4_ALT
case|:
case|case
name|R_XTENSA_SLOT5_ALT
case|:
case|case
name|R_XTENSA_SLOT6_ALT
case|:
case|case
name|R_XTENSA_SLOT7_ALT
case|:
case|case
name|R_XTENSA_SLOT8_ALT
case|:
case|case
name|R_XTENSA_SLOT9_ALT
case|:
case|case
name|R_XTENSA_SLOT10_ALT
case|:
case|case
name|R_XTENSA_SLOT11_ALT
case|:
case|case
name|R_XTENSA_SLOT12_ALT
case|:
case|case
name|R_XTENSA_SLOT13_ALT
case|:
case|case
name|R_XTENSA_SLOT14_ALT
case|:
case|case
name|R_XTENSA_ASM_EXPAND
case|:
case|case
name|R_XTENSA_ASM_SIMPLIFY
case|:
case|case
name|R_XTENSA_DIFF8
case|:
case|case
name|R_XTENSA_DIFF16
case|:
case|case
name|R_XTENSA_DIFF32
case|:
comment|/* Nothing to do for these.  */
break|break;
case|case
name|R_XTENSA_GNU_VTINHERIT
case|:
comment|/* This relocation describes the C++ object vtable hierarchy. 	     Reconstruct it for later use during GC.  */
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|R_XTENSA_GNU_VTENTRY
case|:
comment|/* This relocation describes which C++ vtable entries are actually 	     used.  Record for later use during GC.  */
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf_xtensa_make_sym_local
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
comment|/* Will use RELATIVE relocs instead of JMP_SLOT relocs.  */
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|<
literal|0
condition|)
name|h
operator|->
name|got
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|refcount
operator|+=
name|h
operator|->
name|plt
operator|.
name|refcount
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Don't need any dynamic relocations at all.  */
name|h
operator|->
name|plt
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elf_xtensa_hide_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|bfd_boolean
name|force_local
parameter_list|)
block|{
comment|/* For a shared link, move the plt refcount to the got refcount to leave      space for RELATIVE relocs.  */
name|elf_xtensa_make_sym_local
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|_bfd_elf_link_hash_hide_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|force_local
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the section that should be marked against GC for a given    relocation.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|elf_xtensa_gc_mark_hook
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|h
condition|)
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_XTENSA_GNU_VTINHERIT
case|:
case|case
name|R_XTENSA_GNU_VTENTRY
case|:
break|break;
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
default|default:
break|break;
block|}
block|}
block|}
else|else
return|return
name|bfd_section_from_elf_index
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Update the GOT& PLT entry reference counts    for the section being removed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_gc_sweep_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|unsigned
name|int
name|r_type
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_XTENSA_32
case|:
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
goto|goto
name|local_literal
goto|;
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|got
operator|.
name|refcount
operator|--
expr_stmt|;
break|break;
case|case
name|R_XTENSA_PLT
case|:
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
goto|goto
name|local_literal
goto|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|plt
operator|.
name|refcount
operator|--
expr_stmt|;
break|break;
name|local_literal
label|:
if|if
condition|(
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|>
literal|0
condition|)
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|-=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create all the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_create_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|dynobj
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|flagword
name|flags
decl_stmt|,
name|noalloc_flags
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* First do all the standard stuff.  */
if|if
condition|(
operator|!
name|_bfd_elf_create_dynamic_sections
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Create any extra PLT sections in case check_relocs has already      been called on all the non-dynamic input files.  */
if|if
condition|(
operator|!
name|add_extra_plt_sections
argument_list|(
name|dynobj
argument_list|,
name|plt_reloc_count
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|noalloc_flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
expr_stmt|;
name|flags
operator|=
name|noalloc_flags
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
comment|/* Mark the ".got.plt" section READONLY.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Create ".rela.got".  */
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Create ".got.loc" (literal tables for use by dynamic linker).  */
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
literal|".got.loc"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Create ".xt.lit.plt" (literal table for ".got.plt*").  */
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
literal|".xt.lit.plt"
argument_list|,
name|noalloc_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|add_extra_plt_sections
parameter_list|(
name|bfd
modifier|*
name|dynobj
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|chunk
decl_stmt|;
comment|/* Iterate over all chunks except 0 which uses the standard ".plt" and      ".got.plt" sections.  */
for|for
control|(
name|chunk
operator|=
name|count
operator|/
name|PLT_ENTRIES_PER_CHUNK
init|;
name|chunk
operator|>
literal|0
condition|;
name|chunk
operator|--
control|)
block|{
name|char
modifier|*
name|sname
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* Stop when we find a section has already been created.  */
if|if
condition|(
name|elf_xtensa_get_plt_section
argument_list|(
name|dynobj
argument_list|,
name|chunk
argument_list|)
condition|)
break|break;
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
expr_stmt|;
name|sname
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sname
argument_list|,
literal|".plt.%u"
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
name|sname
argument_list|,
name|flags
operator||
name|SEC_CODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|sname
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
literal|14
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sname
argument_list|,
literal|".got.plt.%u"
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
name|sname
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_adjust_dynamic_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|weakdef
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object.  The      reference must go through the GOT, so there's no need for COPY relocs,      .dynbss, etc.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_fix_refcounts
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
operator|!
name|xtensa_elf_dynamic_symbol_p
argument_list|(
name|h
argument_list|,
name|info
argument_list|)
condition|)
name|elf_xtensa_make_sym_local
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_allocate_plt_size
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|asection
modifier|*
name|srelplt
init|=
operator|(
name|asection
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|srelplt
operator|->
name|size
operator|+=
operator|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_allocate_got_size
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|asection
modifier|*
name|srelgot
init|=
operator|(
name|asection
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
name|srelgot
operator|->
name|size
operator|+=
operator|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf_xtensa_allocate_local_got_size
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|srelgot
parameter_list|)
block|{
name|bfd
modifier|*
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|info
operator|->
name|input_bfds
init|;
name|i
condition|;
name|i
operator|=
name|i
operator|->
name|link_next
control|)
block|{
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
name|bfd_size_type
name|j
decl_stmt|,
name|cnt
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_got_refcounts
condition|)
continue|continue;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|cnt
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|cnt
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|local_got_refcounts
index|[
name|j
index|]
operator|>
literal|0
condition|)
name|srelgot
operator|->
name|size
operator|+=
operator|(
name|local_got_refcounts
index|[
name|j
index|]
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_size_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|,
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|,
modifier|*
name|srelplt
decl_stmt|,
modifier|*
name|splt
decl_stmt|,
modifier|*
name|sgotplt
decl_stmt|,
modifier|*
name|srelgot
decl_stmt|,
modifier|*
name|spltlittbl
decl_stmt|,
modifier|*
name|sgotloc
decl_stmt|;
name|bfd_boolean
name|relplt
decl_stmt|,
name|relgot
decl_stmt|;
name|int
name|plt_entries
decl_stmt|,
name|plt_chunks
decl_stmt|,
name|chunk
decl_stmt|;
name|plt_entries
operator|=
literal|0
expr_stmt|;
name|plt_chunks
operator|=
literal|0
expr_stmt|;
name|srelgot
operator|=
literal|0
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|s
operator|->
name|size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
comment|/* Allocate room for one word in ".got".  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|s
operator|->
name|size
operator|=
literal|4
expr_stmt|;
comment|/* Adjust refcounts for symbols that we now know are not "dynamic".  */
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_xtensa_fix_refcounts
argument_list|,
operator|(
name|void
operator|*
operator|)
name|info
argument_list|)
expr_stmt|;
comment|/* Allocate space in ".rela.got" for literals that reference 	 global symbols.  */
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srelgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_xtensa_allocate_got_size
argument_list|,
operator|(
name|void
operator|*
operator|)
name|srelgot
argument_list|)
expr_stmt|;
comment|/* If we are generating a shared object, we also need space in 	 ".rela.got" for R_XTENSA_RELATIVE relocs for literals that 	 reference local symbols.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|elf_xtensa_allocate_local_got_size
argument_list|(
name|info
argument_list|,
name|srelgot
argument_list|)
expr_stmt|;
comment|/* Allocate space in ".rela.plt" for literals that have PLT entries.  */
name|srelplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srelplt
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_xtensa_allocate_plt_size
argument_list|,
operator|(
name|void
operator|*
operator|)
name|srelplt
argument_list|)
expr_stmt|;
comment|/* Allocate space in ".plt" to match the size of ".rela.plt".  For 	 each PLT entry, we need the PLT code plus a 4-byte literal. 	 For each chunk of ".plt", we also need two more 4-byte 	 literals, two corresponding entries in ".rela.got", and an 	 8-byte entry in ".xt.lit.plt".  */
name|spltlittbl
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".xt.lit.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spltlittbl
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|plt_entries
operator|=
name|srelplt
operator|->
name|size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|plt_chunks
operator|=
operator|(
name|plt_entries
operator|+
name|PLT_ENTRIES_PER_CHUNK
operator|-
literal|1
operator|)
operator|/
name|PLT_ENTRIES_PER_CHUNK
expr_stmt|;
comment|/* Iterate over all the PLT chunks, including any extra sections 	 created earlier because the initial count of PLT relocations 	 was an overestimate.  */
for|for
control|(
name|chunk
operator|=
literal|0
init|;
operator|(
name|splt
operator|=
name|elf_xtensa_get_plt_section
argument_list|(
name|dynobj
argument_list|,
name|chunk
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|chunk
operator|++
control|)
block|{
name|int
name|chunk_entries
decl_stmt|;
name|sgotplt
operator|=
name|elf_xtensa_get_gotplt_section
argument_list|(
name|dynobj
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgotplt
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|chunk
operator|<
name|plt_chunks
operator|-
literal|1
condition|)
name|chunk_entries
operator|=
name|PLT_ENTRIES_PER_CHUNK
expr_stmt|;
elseif|else
if|if
condition|(
name|chunk
operator|==
name|plt_chunks
operator|-
literal|1
condition|)
name|chunk_entries
operator|=
name|plt_entries
operator|-
operator|(
name|chunk
operator|*
name|PLT_ENTRIES_PER_CHUNK
operator|)
expr_stmt|;
else|else
name|chunk_entries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chunk_entries
operator|!=
literal|0
condition|)
block|{
name|sgotplt
operator|->
name|size
operator|=
literal|4
operator|*
operator|(
name|chunk_entries
operator|+
literal|2
operator|)
expr_stmt|;
name|splt
operator|->
name|size
operator|=
name|PLT_ENTRY_SIZE
operator|*
name|chunk_entries
expr_stmt|;
name|srelgot
operator|->
name|size
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|spltlittbl
operator|->
name|size
operator|+=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|sgotplt
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|splt
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Allocate space in ".got.loc" to match the total size of all the 	 literal tables.  */
name|sgotloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.loc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgotloc
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|sgotloc
operator|->
name|size
operator|=
name|spltlittbl
operator|->
name|size
expr_stmt|;
for|for
control|(
name|abfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|abfd
operator|!=
name|NULL
condition|;
name|abfd
operator|=
name|abfd
operator|->
name|link_next
control|)
block|{
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
condition|)
continue|continue;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|elf_discarded_section
argument_list|(
name|s
argument_list|)
operator|&&
name|xtensa_is_littable_section
argument_list|(
name|s
argument_list|)
operator|&&
name|s
operator|!=
name|spltlittbl
condition|)
name|sgotloc
operator|->
name|size
operator|+=
name|s
operator|->
name|size
expr_stmt|;
block|}
block|}
block|}
comment|/* Allocate memory for dynamic sections.  */
name|relplt
operator|=
name|FALSE
expr_stmt|;
name|relgot
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* It's OK to base decisions on the section name, because none 	 of the dynobj section names depend upon the input files.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rela.plt"
argument_list|)
operator|==
literal|0
condition|)
name|relplt
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rela.got"
argument_list|)
operator|==
literal|0
condition|)
name|relgot
operator|=
name|TRUE
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need 		 to copy relocs into the output file.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".plt."
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".got.plt."
argument_list|,
literal|9
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".got"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".plt"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".got.plt"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".xt.lit.plt"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".got.loc"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
block|{
comment|/* If we don't need this section, strip it from the output 	     file.  We must create the ".plt*" and ".got.plt*" 	     sections in create_dynamic_sections and/or check_relocs 	     based on a conservative estimate of the PLT relocation 	     count, because the sections must be created before the 	     linker maps input sections to output sections.  The 	     linker does that before size_dynamic_sections, where we 	     compute the exact size of the PLT, so there may be more 	     of these sections than are actually needed.  */
name|s
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Allocate memory for the section contents.  */
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Add the special XTENSA_RTLD relocations now.  The offsets won't be 	 known until finish_dynamic_sections, but we need to get the relocs 	 in place before they are sorted.  */
if|if
condition|(
name|srelgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|chunk
operator|=
literal|0
init|;
name|chunk
operator|<
name|plt_chunks
condition|;
name|chunk
operator|++
control|)
block|{
name|Elf_Internal_Rela
name|irela
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|irela
operator|.
name|r_offset
operator|=
literal|0
expr_stmt|;
name|irela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_XTENSA_RTLD
argument_list|)
expr_stmt|;
name|irela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
operator|(
name|srelgot
operator|->
name|contents
operator|+
name|srelgot
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|irela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|irela
argument_list|,
name|loc
operator|+
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
argument_list|)
expr_stmt|;
name|srelgot
operator|->
name|reloc_count
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in elf_xtensa_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
define|#
directive|define
name|add_dynamic_entry
parameter_list|(
name|TAG
parameter_list|,
name|VAL
parameter_list|)
define|\
value|_bfd_elf_add_dynamic_entry (info, TAG, VAL)
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|relplt
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTREL
argument_list|,
name|DT_RELA
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|relgot
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELA
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELAENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_XTENSA_GOT_LOC_OFF
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_XTENSA_GOT_LOC_SZ
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
undef|#
directive|undef
name|add_dynamic_entry
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remove any PT_LOAD segments with no allocated sections.  Prior to    binutils 2.13, this function used to remove the non-SEC_ALLOC    sections from PT_LOAD segments, but that task has now been moved    into elf.c.  We still need this function to remove any empty    segments that result, but there's nothing Xtensa-specific about    this and it probably ought to be moved into elf.c as well.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_modify_segment_map
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|elf_segment_map
modifier|*
modifier|*
name|m_p
decl_stmt|;
name|m_p
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
expr_stmt|;
while|while
condition|(
operator|*
name|m_p
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|m_p
operator|)
operator|->
name|p_type
operator|==
name|PT_LOAD
operator|&&
operator|(
operator|*
name|m_p
operator|)
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|m_p
operator|=
operator|(
operator|*
name|m_p
operator|)
operator|->
name|next
expr_stmt|;
else|else
name|m_p
operator|=
operator|&
operator|(
operator|*
name|m_p
operator|)
operator|->
name|next
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform the specified relocation.  The instruction at (contents + address)    is modified to set one operand to represent the value in "relocation".  The    operand position is determined by the relocation type recorded in the    howto.  */
end_comment

begin_define
define|#
directive|define
name|CALL_SEGMENT_BITS
value|(30)
end_define

begin_define
define|#
directive|define
name|CALL_SEGMENT_SIZE
value|(1<< CALL_SEGMENT_BITS)
end_define

begin_function
specifier|static
name|bfd_reloc_status_type
name|elf_xtensa_do_reloc
parameter_list|(
name|reloc_howto_type
modifier|*
name|howto
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_vma
name|relocation
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|bfd_vma
name|address
parameter_list|,
name|bfd_boolean
name|is_weak_undef
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
name|xtensa_format
name|fmt
decl_stmt|;
name|xtensa_opcode
name|opcode
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|ibuff
init|=
name|NULL
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|sbuff
init|=
name|NULL
decl_stmt|;
name|bfd_vma
name|self_address
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|input_size
decl_stmt|;
name|int
name|opnd
decl_stmt|,
name|slot
decl_stmt|;
name|uint32
name|newval
decl_stmt|;
if|if
condition|(
operator|!
name|ibuff
condition|)
block|{
name|ibuff
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|sbuff
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
block|}
name|input_size
operator|=
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|howto
operator|->
name|type
condition|)
block|{
case|case
name|R_XTENSA_NONE
case|:
case|case
name|R_XTENSA_DIFF8
case|:
case|case
name|R_XTENSA_DIFF16
case|:
case|case
name|R_XTENSA_DIFF32
case|:
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_XTENSA_ASM_EXPAND
case|:
if|if
condition|(
operator|!
name|is_weak_undef
condition|)
block|{
comment|/* Check for windowed CALL across a 1GB boundary.  */
name|xtensa_opcode
name|opcode
init|=
name|get_expanded_call_opcode
argument_list|(
name|contents
operator|+
name|address
argument_list|,
name|input_size
operator|-
name|address
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_windowed_call_opcode
argument_list|(
name|opcode
argument_list|)
condition|)
block|{
name|self_address
operator|=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|address
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|self_address
operator|>>
name|CALL_SEGMENT_BITS
operator|)
operator|!=
operator|(
name|relocation
operator|>>
name|CALL_SEGMENT_BITS
operator|)
condition|)
block|{
operator|*
name|error_message
operator|=
literal|"windowed longcall crosses 1GB boundary; "
literal|"return may fail"
expr_stmt|;
return|return
name|bfd_reloc_dangerous
return|;
block|}
block|}
block|}
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_XTENSA_ASM_SIMPLIFY
case|:
block|{
comment|/* Convert the L32R/CALLX to CALL.  */
name|bfd_reloc_status_type
name|retval
init|=
name|elf_xtensa_do_asm_simplify
argument_list|(
name|contents
argument_list|,
name|address
argument_list|,
name|input_size
argument_list|,
name|error_message
argument_list|)
decl_stmt|;
if|if
condition|(
name|retval
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|bfd_reloc_dangerous
return|;
comment|/* The CALL needs to be relocated.  Continue below for that part.  */
name|address
operator|+=
literal|3
expr_stmt|;
name|howto
operator|=
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_SLOT0_OP
index|]
expr_stmt|;
block|}
break|break;
case|case
name|R_XTENSA_32
case|:
case|case
name|R_XTENSA_PLT
case|:
block|{
name|bfd_vma
name|x
decl_stmt|;
name|x
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|address
argument_list|)
expr_stmt|;
name|x
operator|=
name|x
operator|+
name|relocation
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
name|contents
operator|+
name|address
argument_list|)
expr_stmt|;
block|}
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* Only instruction slot-specific relocations handled below.... */
name|slot
operator|=
name|get_relocation_slot
argument_list|(
name|howto
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
operator|*
name|error_message
operator|=
literal|"unexpected relocation"
expr_stmt|;
return|return
name|bfd_reloc_dangerous
return|;
block|}
comment|/* Read the instruction into a buffer and decode the opcode.  */
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|ibuff
argument_list|,
name|contents
operator|+
name|address
argument_list|,
name|input_size
operator|-
name|address
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|xtensa_format_decode
argument_list|(
name|isa
argument_list|,
name|ibuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
operator|*
name|error_message
operator|=
literal|"cannot decode instruction format"
expr_stmt|;
return|return
name|bfd_reloc_dangerous
return|;
block|}
name|xtensa_format_get_slot
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|ibuff
argument_list|,
name|sbuff
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|xtensa_opcode_decode
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|sbuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
operator|*
name|error_message
operator|=
literal|"cannot decode instruction opcode"
expr_stmt|;
return|return
name|bfd_reloc_dangerous
return|;
block|}
comment|/* Check for opcode-specific "alternate" relocations.  */
if|if
condition|(
name|is_alt_relocation
argument_list|(
name|howto
operator|->
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|opcode
operator|==
name|get_l32r_opcode
argument_list|()
condition|)
block|{
comment|/* Handle the special-case of non-PC-relative L32R instructions.  */
name|bfd
modifier|*
name|output_bfd
init|=
name|input_section
operator|->
name|output_section
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
name|lit4_sec
init|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".lit4"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lit4_sec
condition|)
block|{
operator|*
name|error_message
operator|=
literal|"relocation references missing .lit4 section"
expr_stmt|;
return|return
name|bfd_reloc_dangerous
return|;
block|}
name|self_address
operator|=
operator|(
operator|(
name|lit4_sec
operator|->
name|vma
operator|&
operator|~
literal|0xfff
operator|)
operator|+
literal|0x40000
operator|-
literal|3
operator|)
expr_stmt|;
comment|/* -3 to compensate for do_reloc */
name|newval
operator|=
name|relocation
expr_stmt|;
name|opnd
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|get_const16_opcode
argument_list|()
condition|)
block|{
comment|/* ALT used for high 16 bits.  */
name|newval
operator|=
name|relocation
operator|>>
literal|16
expr_stmt|;
name|opnd
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* No other "alternate" relocations currently defined.  */
operator|*
name|error_message
operator|=
literal|"unexpected relocation"
expr_stmt|;
return|return
name|bfd_reloc_dangerous
return|;
block|}
block|}
else|else
comment|/* Not an "alternate" relocation.... */
block|{
if|if
condition|(
name|opcode
operator|==
name|get_const16_opcode
argument_list|()
condition|)
block|{
name|newval
operator|=
name|relocation
operator|&
literal|0xffff
expr_stmt|;
name|opnd
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* ...normal PC-relative relocation.... */
comment|/* Determine which operand is being relocated.  */
name|opnd
operator|=
name|get_relocation_opnd
argument_list|(
name|opcode
argument_list|,
name|howto
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|opnd
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
operator|*
name|error_message
operator|=
literal|"unexpected relocation"
expr_stmt|;
return|return
name|bfd_reloc_dangerous
return|;
block|}
if|if
condition|(
operator|!
name|howto
operator|->
name|pc_relative
condition|)
block|{
operator|*
name|error_message
operator|=
literal|"expected PC-relative relocation"
expr_stmt|;
return|return
name|bfd_reloc_dangerous
return|;
block|}
comment|/* Calculate the PC address for this instruction.  */
name|self_address
operator|=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|address
operator|)
expr_stmt|;
name|newval
operator|=
name|relocation
expr_stmt|;
block|}
block|}
comment|/* Apply the relocation.  */
if|if
condition|(
name|xtensa_operand_do_reloc
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|opnd
argument_list|,
operator|&
name|newval
argument_list|,
name|self_address
argument_list|)
operator|||
name|xtensa_operand_encode
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|opnd
argument_list|,
operator|&
name|newval
argument_list|)
operator|||
name|xtensa_operand_set_field
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|opnd
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|sbuff
argument_list|,
name|newval
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|opname
init|=
name|xtensa_opcode_name
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|msg
operator|=
literal|"cannot encode"
expr_stmt|;
if|if
condition|(
name|is_direct_call_opcode
argument_list|(
name|opcode
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|relocation
operator|&
literal|0x3
operator|)
operator|!=
literal|0
condition|)
name|msg
operator|=
literal|"misaligned call target"
expr_stmt|;
else|else
name|msg
operator|=
literal|"call target out of range"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|get_l32r_opcode
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|relocation
operator|&
literal|0x3
operator|)
operator|!=
literal|0
condition|)
name|msg
operator|=
literal|"misaligned literal target"
expr_stmt|;
elseif|else
if|if
condition|(
name|is_alt_relocation
argument_list|(
name|howto
operator|->
name|type
argument_list|)
condition|)
name|msg
operator|=
literal|"literal target out of range (too many literals)"
expr_stmt|;
elseif|else
if|if
condition|(
name|self_address
operator|>
name|relocation
condition|)
name|msg
operator|=
literal|"literal target out of range (try using text-section-literals)"
expr_stmt|;
else|else
name|msg
operator|=
literal|"literal placed after use"
expr_stmt|;
block|}
operator|*
name|error_message
operator|=
name|vsprint_msg
argument_list|(
name|opname
argument_list|,
literal|": %s"
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
operator|+
literal|2
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_dangerous
return|;
block|}
comment|/* Check for calls across 1GB boundaries.  */
if|if
condition|(
name|is_direct_call_opcode
argument_list|(
name|opcode
argument_list|)
operator|&&
name|is_windowed_call_opcode
argument_list|(
name|opcode
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|self_address
operator|>>
name|CALL_SEGMENT_BITS
operator|)
operator|!=
operator|(
name|relocation
operator|>>
name|CALL_SEGMENT_BITS
operator|)
condition|)
block|{
operator|*
name|error_message
operator|=
literal|"windowed call crosses 1GB boundary; return may fail"
expr_stmt|;
return|return
name|bfd_reloc_dangerous
return|;
block|}
block|}
comment|/* Write the modified instruction back out of the buffer.  */
name|xtensa_format_set_slot
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|ibuff
argument_list|,
name|sbuff
argument_list|)
expr_stmt|;
name|xtensa_insnbuf_to_chars
argument_list|(
name|isa
argument_list|,
name|ibuff
argument_list|,
name|contents
operator|+
name|address
argument_list|,
name|input_size
operator|-
name|address
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|vsprint_msg
parameter_list|(
specifier|const
name|char
modifier|*
name|origmsg
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|int
name|arglen
parameter_list|,
modifier|...
parameter_list|)
block|{
comment|/* To reduce the size of the memory leak,      we only use a single message buffer.  */
specifier|static
name|bfd_size_type
name|alloc_size
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
name|message
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|orig_len
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|;
name|bfd_boolean
name|is_append
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|arglen
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|origmsg
argument_list|)
expr_stmt|;
name|is_append
operator|=
operator|(
name|origmsg
operator|==
name|message
operator|)
expr_stmt|;
name|orig_len
operator|=
name|strlen
argument_list|(
name|origmsg
argument_list|)
expr_stmt|;
name|len
operator|=
name|orig_len
operator|+
name|strlen
argument_list|(
name|fmt
argument_list|)
operator|+
name|arglen
operator|+
literal|20
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|alloc_size
condition|)
block|{
name|message
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_realloc
argument_list|(
name|message
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|alloc_size
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_append
condition|)
name|memcpy
argument_list|(
name|message
argument_list|,
name|origmsg
argument_list|,
name|orig_len
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|message
operator|+
name|orig_len
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
end_function

begin_comment
comment|/* This function is registered as the "special_function" in the    Xtensa howto for handling simplify operations.    bfd_perform_relocation / bfd_install_relocation use it to    perform (install) the specified relocation.  Since this replaces the code    in bfd_perform_relocation, it is basically an Xtensa-specific,    stripped-down version of bfd_perform_relocation.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|bfd_elf_xtensa_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|flag
decl_stmt|;
name|bfd_size_type
name|octets
init|=
name|reloc_entry
operator|->
name|address
operator|*
name|bfd_octets_per_byte
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|bfd_vma
name|output_base
init|=
literal|0
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
init|=
name|reloc_entry
operator|->
name|howto
decl_stmt|;
name|asection
modifier|*
name|reloc_target_output_section
decl_stmt|;
name|bfd_boolean
name|is_weak_undef
decl_stmt|;
if|if
condition|(
operator|!
name|xtensa_default_isa
condition|)
name|xtensa_default_isa
operator|=
name|xtensa_isa_init
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ELF relocs are against symbols.  If we are producing relocatable      output, and the reloc is against an external symbol, the resulting      reloc will also be against the same symbol.  In such a case, we      don't want to change anything about the way the reloc is handled,      since it will all be done at final link time.  This test is similar      to what bfd_elf_generic_reloc does except that it lets relocs with      howto->partial_inplace go through even if the addend is non-zero.      (The real problem is that partial_inplace is set for XTENSA_32      relocs to begin with, but that's a long story and there's little we      can do about it now....)  */
if|if
condition|(
name|output_bfd
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* Is the address of the relocation really within the section?  */
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|input_section
argument_list|)
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* Work out which section the relocation is targeted at and the      initial relocation command value.  */
comment|/* Get symbol value.  (Common symbols are special.)  */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|reloc_target_output_section
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
expr_stmt|;
comment|/* Convert input-section-relative symbol value to absolute.  */
if|if
condition|(
operator|(
name|output_bfd
operator|&&
operator|!
name|howto
operator|->
name|partial_inplace
operator|)
operator|||
name|reloc_target_output_section
operator|==
name|NULL
condition|)
name|output_base
operator|=
literal|0
expr_stmt|;
else|else
name|output_base
operator|=
name|reloc_target_output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|output_base
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
comment|/* Add in supplied addend.  */
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
comment|/* Here the variable relocation holds the final address of the      symbol we are relocating against, plus any addend.  */
if|if
condition|(
name|output_bfd
condition|)
block|{
if|if
condition|(
operator|!
name|howto
operator|->
name|partial_inplace
condition|)
block|{
comment|/* This is a partial relocation, and we want to apply the relocation 	     to the reloc entry rather than the raw data.  Everything except 	     relocations against section symbols has already been handled 	     above.  */
name|BFD_ASSERT
argument_list|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
argument_list|)
expr_stmt|;
name|reloc_entry
operator|->
name|addend
operator|=
name|relocation
expr_stmt|;
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
else|else
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
name|reloc_entry
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|is_weak_undef
operator|=
operator|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|flag
operator|=
name|elf_xtensa_do_reloc
argument_list|(
name|howto
argument_list|,
name|abfd
argument_list|,
name|input_section
argument_list|,
name|relocation
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
argument_list|,
operator|(
name|bfd_vma
operator|)
name|octets
argument_list|,
name|is_weak_undef
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|bfd_reloc_dangerous
condition|)
block|{
comment|/* Add the symbol name to the error message.  */
if|if
condition|(
operator|!
operator|*
name|error_message
condition|)
operator|*
name|error_message
operator|=
literal|""
expr_stmt|;
operator|*
name|error_message
operator|=
name|vsprint_msg
argument_list|(
operator|*
name|error_message
argument_list|,
literal|": (%s + 0x%lx)"
argument_list|,
name|strlen
argument_list|(
name|symbol
operator|->
name|name
argument_list|)
operator|+
literal|17
argument_list|,
name|symbol
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|reloc_entry
operator|->
name|addend
argument_list|)
expr_stmt|;
block|}
return|return
name|flag
return|;
block|}
end_function

begin_comment
comment|/* Set up an entry in the procedure linkage table.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|elf_xtensa_create_plt_entry
parameter_list|(
name|bfd
modifier|*
name|dynobj
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|unsigned
name|reloc_index
parameter_list|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|,
modifier|*
name|sgotplt
decl_stmt|;
name|bfd_vma
name|plt_base
decl_stmt|,
name|got_base
decl_stmt|;
name|bfd_vma
name|code_offset
decl_stmt|,
name|lit_offset
decl_stmt|;
name|int
name|chunk
decl_stmt|;
name|chunk
operator|=
name|reloc_index
operator|/
name|PLT_ENTRIES_PER_CHUNK
expr_stmt|;
name|splt
operator|=
name|elf_xtensa_get_plt_section
argument_list|(
name|dynobj
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|sgotplt
operator|=
name|elf_xtensa_get_gotplt_section
argument_list|(
name|dynobj
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|sgotplt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|plt_base
operator|=
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
expr_stmt|;
name|got_base
operator|=
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgotplt
operator|->
name|output_offset
expr_stmt|;
name|lit_offset
operator|=
literal|8
operator|+
operator|(
name|reloc_index
operator|%
name|PLT_ENTRIES_PER_CHUNK
operator|)
operator|*
literal|4
expr_stmt|;
name|code_offset
operator|=
operator|(
name|reloc_index
operator|%
name|PLT_ENTRIES_PER_CHUNK
operator|)
operator|*
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* Fill in the literal entry.  This is the offset of the dynamic      relocation entry.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|reloc_index
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
argument_list|,
name|sgotplt
operator|->
name|contents
operator|+
name|lit_offset
argument_list|)
expr_stmt|;
comment|/* Fill in the entry in the procedure linkage table.  */
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
operator|+
name|code_offset
argument_list|,
operator|(
name|bfd_big_endian
argument_list|(
name|output_bfd
argument_list|)
condition|?
name|elf_xtensa_be_plt_entry
else|:
name|elf_xtensa_le_plt_entry
operator|)
argument_list|,
name|PLT_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|output_bfd
argument_list|,
name|l32r_offset
argument_list|(
name|got_base
operator|+
literal|0
argument_list|,
name|plt_base
operator|+
name|code_offset
operator|+
literal|3
argument_list|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|code_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|output_bfd
argument_list|,
name|l32r_offset
argument_list|(
name|got_base
operator|+
literal|4
argument_list|,
name|plt_base
operator|+
name|code_offset
operator|+
literal|6
argument_list|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|code_offset
operator|+
literal|7
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|output_bfd
argument_list|,
name|l32r_offset
argument_list|(
name|got_base
operator|+
name|lit_offset
argument_list|,
name|plt_base
operator|+
name|code_offset
operator|+
literal|9
argument_list|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|code_offset
operator|+
literal|10
argument_list|)
expr_stmt|;
return|return
name|plt_base
operator|+
name|code_offset
return|;
block|}
end_function

begin_comment
comment|/* Relocate an Xtensa ELF section.  This is invoked by the linker for    both relocatable and final links.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|asection
modifier|*
name|srelgot
decl_stmt|,
modifier|*
name|srelplt
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|property_table_entry
modifier|*
name|lit_table
init|=
literal|0
decl_stmt|;
name|int
name|ltblsize
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|error_message
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|input_size
decl_stmt|;
if|if
condition|(
operator|!
name|xtensa_default_isa
condition|)
name|xtensa_default_isa
operator|=
name|xtensa_isa_init
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|srelgot
operator|=
name|NULL
expr_stmt|;
name|srelplt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dynobj
condition|)
block|{
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
empty_stmt|;
name|srelplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|ltblsize
operator|=
name|xtensa_read_table_entries
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|&
name|lit_table
argument_list|,
name|XTENSA_LIT_SEC_NAME
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ltblsize
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
name|input_size
operator|=
name|bfd_get_section_limit
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|bfd_boolean
name|is_weak_undef
decl_stmt|;
name|bfd_boolean
name|unresolved_reloc
decl_stmt|;
name|bfd_boolean
name|warned
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
operator|(
name|int
operator|)
name|R_XTENSA_GNU_VTINHERIT
operator|||
name|r_type
operator|==
operator|(
name|int
operator|)
name|R_XTENSA_GNU_VTENTRY
condition|)
continue|continue;
if|if
condition|(
name|r_type
operator|<
literal|0
operator|||
name|r_type
operator|>=
operator|(
name|int
operator|)
name|R_XTENSA_max
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|howto
operator|=
operator|&
name|elf_howto_table
index|[
name|r_type
index|]
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
block|{
comment|/* This is a relocatable link. 	     1) If the reloc is against a section symbol, adjust 	     according to the output section. 	     2) If there is a new target for this relocation, 	     the new target will be in the same output section. 	     We adjust the relocation by the output section 	     difference.  */
if|if
condition|(
name|relaxing_section
condition|)
block|{
comment|/* Check if this references a section in another input file.  */
if|if
condition|(
operator|!
name|do_fix_for_relocatable_link
argument_list|(
name|rel
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_XTENSA_ASM_SIMPLIFY
condition|)
block|{
name|char
modifier|*
name|error_message
init|=
name|NULL
decl_stmt|;
comment|/* Convert ASM_SIMPLIFY into the simpler relocation 		 so that they never escape a relaxing link.  */
name|r
operator|=
name|contract_asm_expansion
argument_list|(
name|contents
argument_list|,
name|input_size
argument_list|,
name|rel
argument_list|,
operator|&
name|error_message
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|info
argument_list|,
name|error_message
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
block|}
comment|/* This is a relocatable link, so we don't have to change 	     anything unless the reloc is against a section symbol, 	     in which case we have to adjust according to where the 	     section symbol winds up in the output section.  */
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|+=
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
expr_stmt|;
block|}
block|}
comment|/* If there is an addend with a partial_inplace howto, 	     then move the addend to the contents.  This is a hack 	     to work around problems with DWARF in relocatable links 	     with some previous version of BFD.  Now we can't easily get 	     rid of the hack without breaking backward compatibility.... */
if|if
condition|(
name|rel
operator|->
name|r_addend
condition|)
block|{
name|howto
operator|=
operator|&
name|elf_howto_table
index|[
name|r_type
index|]
expr_stmt|;
if|if
condition|(
name|howto
operator|->
name|partial_inplace
condition|)
block|{
name|r
operator|=
name|elf_xtensa_do_reloc
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|FALSE
argument_list|,
operator|&
name|error_message
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|info
argument_list|,
name|error_message
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
name|rel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Done with work for relocatable link; continue with next reloc.  */
continue|continue;
block|}
comment|/* This is a final link.  */
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
name|is_weak_undef
operator|=
name|FALSE
expr_stmt|;
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
name|warned
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|howto
operator|->
name|partial_inplace
condition|)
block|{
comment|/* Because R_XTENSA_32 was made partial_inplace to fix some 	     problems with DWARF info in partial links, there may be 	     an addend stored in the contents.  Take it out of there 	     and move it back into the addend field of the reloc.  */
name|rel
operator|->
name|r_addend
operator|+=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
literal|0
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocation
operator|==
literal|0
operator|&&
operator|!
name|unresolved_reloc
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|is_weak_undef
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|relaxing_section
condition|)
block|{
comment|/* Check if this references a section in another input file.  */
name|do_fix_for_final_link
argument_list|(
name|rel
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
operator|&
name|relocation
argument_list|)
expr_stmt|;
comment|/* Update some already cached values.  */
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|howto
operator|=
operator|&
name|elf_howto_table
index|[
name|r_type
index|]
expr_stmt|;
block|}
comment|/* Sanity check the address.  */
if|if
condition|(
name|rel
operator|->
name|r_offset
operator|>=
name|input_size
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_XTENSA_NONE
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): relocation offset out of range (size=0x%x)"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|input_size
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Generate dynamic relocations.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|bfd_boolean
name|dynamic_symbol
init|=
name|xtensa_elf_dynamic_symbol_p
argument_list|(
name|h
argument_list|,
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|dynamic_symbol
operator|&&
name|is_operand_relocation
argument_list|(
name|r_type
argument_list|)
condition|)
block|{
comment|/* This is an error.  The symbol's real value won't be known 		 until runtime and it's likely to be out of range anyway.  */
specifier|const
name|char
modifier|*
name|name
init|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
decl_stmt|;
name|error_message
operator|=
name|vsprint_msg
argument_list|(
literal|"invalid relocation for dynamic "
literal|"symbol"
argument_list|,
literal|": %s"
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|info
argument_list|,
name|error_message
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|r_type
operator|==
name|R_XTENSA_32
operator|||
name|r_type
operator|==
name|R_XTENSA_PLT
operator|)
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|dynamic_symbol
operator|||
name|info
operator|->
name|shared
operator|)
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
if|if
condition|(
name|dynamic_symbol
operator|&&
name|r_type
operator|==
name|R_XTENSA_PLT
condition|)
name|srel
operator|=
name|srelplt
expr_stmt|;
else|else
name|srel
operator|=
name|srelgot
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|outrel
operator|.
name|r_offset
operator||
literal|1
operator|)
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|outrel
argument_list|)
expr_stmt|;
else|else
block|{
name|outrel
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
comment|/* Complain if the relocation is in a read-only section 		     and not in a literal pool.  */
if|if
condition|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|elf_xtensa_in_literal_pool
argument_list|(
name|lit_table
argument_list|,
name|ltblsize
argument_list|,
name|outrel
operator|.
name|r_offset
argument_list|)
condition|)
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|"dynamic relocation in read-only section"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|info
argument_list|,
name|error_message
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|dynamic_symbol
condition|)
block|{
name|outrel
operator|.
name|r_addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_XTENSA_32
condition|)
block|{
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_XTENSA_GLOB_DAT
argument_list|)
expr_stmt|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* r_type == R_XTENSA_PLT */
block|{
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_XTENSA_JMP_SLOT
argument_list|)
expr_stmt|;
comment|/* Create the PLT entry and set the initial 			     contents of the literal entry to the address of 			     the PLT entry.  */
name|relocation
operator|=
name|elf_xtensa_create_plt_entry
argument_list|(
name|dynobj
argument_list|,
name|output_bfd
argument_list|,
name|srel
operator|->
name|reloc_count
argument_list|)
expr_stmt|;
block|}
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* Generate a RELATIVE relocation.  */
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_XTENSA_RELATIVE
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|loc
operator|=
operator|(
name|srel
operator|->
name|contents
operator|+
name|srel
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|*
name|srel
operator|->
name|reloc_count
operator|<=
name|srel
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Dynamic relocs are not propagated for SEC_DEBUGGING sections 	 because such sections are not SEC_ALLOC and thus ld.so will 	 not process them.  */
if|if
condition|(
name|unresolved_reloc
operator|&&
operator|!
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|->
name|def_dynamic
operator|)
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
comment|/* There's no point in calling bfd_perform_relocation here. 	 Just go directly to our "special function".  */
name|r
operator|=
name|elf_xtensa_do_reloc
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|is_weak_undef
argument_list|,
operator|&
name|error_message
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
operator|&&
operator|!
name|warned
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|r
operator|==
name|bfd_reloc_dangerous
operator|||
name|r
operator|==
name|bfd_reloc_other
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|error_message
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
condition|)
block|{
if|if
condition|(
name|rel
operator|->
name|r_addend
operator|==
literal|0
condition|)
name|error_message
operator|=
name|vsprint_msg
argument_list|(
name|error_message
argument_list|,
literal|": %s"
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error_message
operator|=
name|vsprint_msg
argument_list|(
name|error_message
argument_list|,
literal|": (%s+0x%x)"
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|22
argument_list|,
name|name
argument_list|,
operator|(
name|int
operator|)
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|info
argument_list|,
name|error_message
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|lit_table
condition|)
name|free
argument_list|(
name|lit_table
argument_list|)
expr_stmt|;
name|input_section
operator|->
name|reloc_done
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  There's not much to do here since    the PLT and GOT entries are all set up by relocate_section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_finish_dynamic_symbol
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|h
operator|->
name|needs_plt
operator|&&
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
comment|/* Mark the symbol as undefined, rather than as defined in 	 the .plt section.  Leave the value alone.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
block|}
comment|/* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
name|h
operator|==
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hgot
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Combine adjacent literal table entries in the output.  Adjacent    entries within each input section may have been removed during    relaxation, but we repeat the process here, even though it's too late    to shrink the output section, because it's important to minimize the    number of literal table entries to reduce the start-up work for the    runtime linker.  Returns the number of remaining table entries or -1    on error.  */
end_comment

begin_function
specifier|static
name|int
name|elf_xtensa_combine_prop_entries
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|asection
modifier|*
name|sxtlit
parameter_list|,
name|asection
modifier|*
name|sgotloc
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|property_table_entry
modifier|*
name|table
decl_stmt|;
name|bfd_size_type
name|section_size
decl_stmt|,
name|sgotloc_size
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|int
name|n
decl_stmt|,
name|m
decl_stmt|,
name|num
decl_stmt|;
name|section_size
operator|=
name|sxtlit
operator|->
name|size
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|section_size
operator|%
literal|8
operator|==
literal|0
argument_list|)
expr_stmt|;
name|num
operator|=
name|section_size
operator|/
literal|8
expr_stmt|;
name|sgotloc_size
operator|=
name|sgotloc
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|sgotloc_size
operator|!=
name|section_size
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"internal inconsistency in size of .got.loc section"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|table
operator|=
name|bfd_malloc
argument_list|(
name|num
operator|*
sizeof|sizeof
argument_list|(
name|property_table_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* The ".xt.lit.plt" section has the SEC_IN_MEMORY flag set and this      propagates to the output section, where it doesn't really apply and      where it breaks the following call to bfd_malloc_and_get_section.  */
name|sxtlit
operator|->
name|flags
operator|&=
operator|~
name|SEC_IN_MEMORY
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|output_bfd
argument_list|,
name|sxtlit
argument_list|,
operator|&
name|contents
argument_list|)
condition|)
block|{
if|if
condition|(
name|contents
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|table
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* There should never be any relocations left at this point, so this      is quite a bit easier than what is done during relaxation.  */
comment|/* Copy the raw contents into a property table array and sort it.  */
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num
condition|;
name|n
operator|++
control|)
block|{
name|table
index|[
name|n
index|]
operator|.
name|address
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|contents
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
name|table
index|[
name|n
index|]
operator|.
name|size
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|contents
index|[
name|offset
operator|+
literal|4
index|]
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
block|}
name|qsort
argument_list|(
name|table
argument_list|,
name|num
argument_list|,
sizeof|sizeof
argument_list|(
name|property_table_entry
argument_list|)
argument_list|,
name|property_table_compare
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num
condition|;
name|n
operator|++
control|)
block|{
name|bfd_boolean
name|remove
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|table
index|[
name|n
index|]
operator|.
name|size
operator|==
literal|0
condition|)
name|remove
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
operator|(
name|table
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|address
operator|+
name|table
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|size
operator|==
name|table
index|[
name|n
index|]
operator|.
name|address
operator|)
condition|)
block|{
name|table
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|size
operator|+=
name|table
index|[
name|n
index|]
operator|.
name|size
expr_stmt|;
name|remove
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|remove
condition|)
block|{
for|for
control|(
name|m
operator|=
name|n
init|;
name|m
operator|<
name|num
operator|-
literal|1
condition|;
name|m
operator|++
control|)
block|{
name|table
index|[
name|m
index|]
operator|.
name|address
operator|=
name|table
index|[
name|m
operator|+
literal|1
index|]
operator|.
name|address
expr_stmt|;
name|table
index|[
name|m
index|]
operator|.
name|size
operator|=
name|table
index|[
name|m
operator|+
literal|1
index|]
operator|.
name|size
expr_stmt|;
block|}
name|n
operator|--
expr_stmt|;
name|num
operator|--
expr_stmt|;
block|}
block|}
comment|/* Copy the data back to the raw contents.  */
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num
condition|;
name|n
operator|++
control|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|table
index|[
name|n
index|]
operator|.
name|address
argument_list|,
operator|&
name|contents
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|table
index|[
name|n
index|]
operator|.
name|size
argument_list|,
operator|&
name|contents
index|[
name|offset
operator|+
literal|4
index|]
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* Clear the removed bytes.  */
if|if
condition|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|num
operator|*
literal|8
argument_list|)
operator|<
name|section_size
condition|)
name|memset
argument_list|(
operator|&
name|contents
index|[
name|num
operator|*
literal|8
index|]
argument_list|,
literal|0
argument_list|,
name|section_size
operator|-
name|num
operator|*
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|sxtlit
argument_list|,
name|contents
argument_list|,
literal|0
argument_list|,
name|section_size
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Copy the contents to ".got.loc".  */
name|memcpy
argument_list|(
name|sgotloc
operator|->
name|contents
argument_list|,
name|contents
argument_list|,
name|section_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|table
argument_list|)
expr_stmt|;
return|return
name|num
return|;
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_finish_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|,
modifier|*
name|srelplt
decl_stmt|,
modifier|*
name|sgot
decl_stmt|,
modifier|*
name|sxtlit
decl_stmt|,
modifier|*
name|sgotloc
decl_stmt|;
name|Elf32_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
name|int
name|num_xtlit_entries
decl_stmt|;
if|if
condition|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
return|return
name|TRUE
return|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Set the first entry in the global offset table to the address of      the dynamic section.  */
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgot
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|sgot
operator|->
name|size
operator|==
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdyn
operator|==
name|NULL
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
else|else
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sdyn
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sdyn
operator|->
name|output_offset
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
block|}
name|srelplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srelplt
operator|&&
name|srelplt
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|sgotplt
decl_stmt|,
modifier|*
name|srelgot
decl_stmt|,
modifier|*
name|spltlittbl
decl_stmt|;
name|int
name|chunk
decl_stmt|,
name|plt_chunks
decl_stmt|,
name|plt_entries
decl_stmt|;
name|Elf_Internal_Rela
name|irela
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|unsigned
name|rtld_reloc
decl_stmt|;
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
empty_stmt|;
name|BFD_ASSERT
argument_list|(
name|srelgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|spltlittbl
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".xt.lit.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|spltlittbl
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Find the first XTENSA_RTLD relocation.  Presumably the rest 	 of them follow immediately after....  */
for|for
control|(
name|rtld_reloc
operator|=
literal|0
init|;
name|rtld_reloc
operator|<
name|srelgot
operator|->
name|reloc_count
condition|;
name|rtld_reloc
operator|++
control|)
block|{
name|loc
operator|=
name|srelgot
operator|->
name|contents
operator|+
name|rtld_reloc
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_in
argument_list|(
name|output_bfd
argument_list|,
name|loc
argument_list|,
operator|&
name|irela
argument_list|)
expr_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irela
operator|.
name|r_info
argument_list|)
operator|==
name|R_XTENSA_RTLD
condition|)
break|break;
block|}
name|BFD_ASSERT
argument_list|(
name|rtld_reloc
operator|<
name|srelgot
operator|->
name|reloc_count
argument_list|)
expr_stmt|;
name|plt_entries
operator|=
name|srelplt
operator|->
name|size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|plt_chunks
operator|=
operator|(
name|plt_entries
operator|+
name|PLT_ENTRIES_PER_CHUNK
operator|-
literal|1
operator|)
operator|/
name|PLT_ENTRIES_PER_CHUNK
expr_stmt|;
for|for
control|(
name|chunk
operator|=
literal|0
init|;
name|chunk
operator|<
name|plt_chunks
condition|;
name|chunk
operator|++
control|)
block|{
name|int
name|chunk_entries
init|=
literal|0
decl_stmt|;
name|sgotplt
operator|=
name|elf_xtensa_get_gotplt_section
argument_list|(
name|dynobj
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgotplt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Emit special RTLD relocations for the first two entries in 	     each chunk of the .got.plt section.  */
name|loc
operator|=
name|srelgot
operator|->
name|contents
operator|+
name|rtld_reloc
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_in
argument_list|(
name|output_bfd
argument_list|,
name|loc
argument_list|,
operator|&
name|irela
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|irela
operator|.
name|r_info
argument_list|)
operator|==
name|R_XTENSA_RTLD
argument_list|)
expr_stmt|;
name|irela
operator|.
name|r_offset
operator|=
operator|(
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgotplt
operator|->
name|output_offset
operator|)
expr_stmt|;
name|irela
operator|.
name|r_addend
operator|=
literal|1
expr_stmt|;
comment|/* tell rtld to set value to resolver function */
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|irela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|rtld_reloc
operator|+=
literal|1
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|rtld_reloc
operator|<=
name|srelgot
operator|->
name|reloc_count
argument_list|)
expr_stmt|;
comment|/* Next literal immediately follows the first.  */
name|loc
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_in
argument_list|(
name|output_bfd
argument_list|,
name|loc
argument_list|,
operator|&
name|irela
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|irela
operator|.
name|r_info
argument_list|)
operator|==
name|R_XTENSA_RTLD
argument_list|)
expr_stmt|;
name|irela
operator|.
name|r_offset
operator|=
operator|(
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgotplt
operator|->
name|output_offset
operator|+
literal|4
operator|)
expr_stmt|;
comment|/* Tell rtld to set value to object's link map.  */
name|irela
operator|.
name|r_addend
operator|=
literal|2
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|irela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|rtld_reloc
operator|+=
literal|1
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|rtld_reloc
operator|<=
name|srelgot
operator|->
name|reloc_count
argument_list|)
expr_stmt|;
comment|/* Fill in the literal table.  */
if|if
condition|(
name|chunk
operator|<
name|plt_chunks
operator|-
literal|1
condition|)
name|chunk_entries
operator|=
name|PLT_ENTRIES_PER_CHUNK
expr_stmt|;
else|else
name|chunk_entries
operator|=
name|plt_entries
operator|-
operator|(
name|chunk
operator|*
name|PLT_ENTRIES_PER_CHUNK
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|chunk
operator|+
literal|1
argument_list|)
operator|*
literal|8
operator|<=
name|spltlittbl
operator|->
name|size
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgotplt
operator|->
name|output_offset
argument_list|,
name|spltlittbl
operator|->
name|contents
operator|+
operator|(
name|chunk
operator|*
literal|8
operator|)
operator|+
literal|0
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|8
operator|+
operator|(
name|chunk_entries
operator|*
literal|4
operator|)
argument_list|,
name|spltlittbl
operator|->
name|contents
operator|+
operator|(
name|chunk
operator|*
literal|8
operator|)
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* All the dynamic relocations have been emitted at this point. 	 Make sure the relocation sections are the correct size.  */
if|if
condition|(
name|srelgot
operator|->
name|size
operator|!=
operator|(
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|*
name|srelgot
operator|->
name|reloc_count
operator|)
operator|||
name|srelplt
operator|->
name|size
operator|!=
operator|(
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|*
name|srelplt
operator|->
name|reloc_count
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* The .xt.lit.plt section has just been modified.  This must 	happen before the code below which combines adjacent literal 	table entries, and the .xt.lit.plt contents have to be forced to 	the output here.  */
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|spltlittbl
operator|->
name|output_section
argument_list|,
name|spltlittbl
operator|->
name|contents
argument_list|,
name|spltlittbl
operator|->
name|output_offset
argument_list|,
name|spltlittbl
operator|->
name|size
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Clear SEC_HAS_CONTENTS so the contents won't be output again.  */
name|spltlittbl
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
comment|/* Combine adjacent literal table entries.  */
name|BFD_ASSERT
argument_list|(
operator|!
name|info
operator|->
name|relocatable
argument_list|)
expr_stmt|;
name|sxtlit
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".xt.lit"
argument_list|)
expr_stmt|;
name|sgotloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.loc"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sxtlit
operator|&&
name|sgotloc
argument_list|)
expr_stmt|;
name|num_xtlit_entries
operator|=
name|elf_xtensa_combine_prop_entries
argument_list|(
name|output_bfd
argument_list|,
name|sxtlit
argument_list|,
name|sgotloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_xtlit_entries
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
name|dyncon
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_elf32_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
default|default:
break|break;
case|case
name|DT_XTENSA_GOT_LOC_SZ
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|num_xtlit_entries
expr_stmt|;
break|break;
case|case
name|DT_XTENSA_GOT_LOC_OFF
case|:
name|name
operator|=
literal|".got.loc"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_PLTGOT
case|:
name|name
operator|=
literal|".got"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_JMPREL
case|:
name|name
operator|=
literal|".rela.plt"
expr_stmt|;
name|get_vma
label|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|size
expr_stmt|;
break|break;
case|case
name|DT_RELASZ
case|:
comment|/* Adjust RELASZ to not include JMPREL.  This matches what 	     glibc expects and what is done for several other ELF 	     targets (e.g., i386, alpha), but the "correct" behavior 	     seems to be unresolved.  Since the linker script arranges 	     for .rela.plt to follow all other relocation sections, we 	     don't have to worry about changing the DT_RELA entry.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|-=
name|s
operator|->
name|size
expr_stmt|;
break|break;
block|}
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for dealing with the e_flags field.  */
end_comment

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_merge_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|unsigned
name|out_mach
decl_stmt|,
name|in_mach
decl_stmt|;
name|flagword
name|out_flag
decl_stmt|,
name|in_flag
decl_stmt|;
comment|/* Check if we have the same endianess.  */
if|if
condition|(
operator|!
name|_bfd_generic_verify_endian_match
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Don't even pretend to support mixed-format linking.  */
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|FALSE
return|;
name|out_flag
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|in_flag
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|out_mach
operator|=
name|out_flag
operator|&
name|EF_XTENSA_MACH
expr_stmt|;
name|in_mach
operator|=
name|in_flag
operator|&
name|EF_XTENSA_MACH
expr_stmt|;
if|if
condition|(
name|out_mach
operator|!=
name|in_mach
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: incompatible machine type. Output is 0x%x. Input is 0x%x"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|out_mach
argument_list|,
name|in_mach
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|in_flag
expr_stmt|;
if|if
condition|(
name|bfd_get_arch
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
operator|&&
name|bfd_get_arch_info
argument_list|(
name|obfd
argument_list|)
operator|->
name|the_default
condition|)
return|return
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
return|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
operator|(
name|out_flag
operator|&
name|EF_XTENSA_XT_INSN
operator|)
operator|!=
operator|(
name|in_flag
operator|&
name|EF_XTENSA_XT_INSN
operator|)
condition|)
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|(
operator|~
name|EF_XTENSA_XT_INSN
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|out_flag
operator|&
name|EF_XTENSA_XT_LIT
operator|)
operator|!=
operator|(
name|in_flag
operator|&
name|EF_XTENSA_XT_LIT
operator|)
condition|)
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|(
operator|~
name|EF_XTENSA_XT_LIT
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_set_private_flags
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|flagword
name|flags
parameter_list|)
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|||
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|==
name|flags
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator||=
name|flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_print_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|void
modifier|*
name|farg
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
operator|(
name|FILE
operator|*
operator|)
name|farg
decl_stmt|;
name|flagword
name|e_flags
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nXtensa header:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_XTENSA_MACH
operator|)
operator|==
name|E_XTENSA_MACH
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nMachine     = Base\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nMachine Id  = 0x%x\n"
argument_list|,
name|e_flags
operator|&
name|EF_XTENSA_MACH
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Insn tables = %s\n"
argument_list|,
operator|(
name|e_flags
operator|&
name|EF_XTENSA_XT_INSN
operator|)
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Literal tables = %s\n"
argument_list|,
operator|(
name|e_flags
operator|&
name|EF_XTENSA_XT_LIT
operator|)
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
return|return
name|_bfd_elf_print_private_bfd_data
argument_list|(
name|abfd
argument_list|,
name|farg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set the right machine number for an Xtensa ELF file.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|int
name|mach
decl_stmt|;
name|unsigned
name|long
name|arch
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_XTENSA_MACH
decl_stmt|;
switch|switch
condition|(
name|arch
condition|)
block|{
case|case
name|E_XTENSA_MACH
case|:
name|mach
operator|=
name|bfd_mach_xtensa
expr_stmt|;
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
operator|(
name|void
operator|)
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_xtensa
argument_list|,
name|mach
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The final processing done just before writing out an Xtensa ELF object    file.  This gets the Xtensa architecture right based on the machine    number.  */
end_comment

begin_function
specifier|static
name|void
name|elf_xtensa_final_write_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|linker
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|mach
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
switch|switch
condition|(
name|mach
operator|=
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_mach_xtensa
case|:
name|val
operator|=
name|E_XTENSA_MACH
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|(
operator|~
name|EF_XTENSA_MACH
operator|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator||=
name|val
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|elf_reloc_type_class
name|elf_xtensa_reloc_type_class
parameter_list|(
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rela
parameter_list|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|ELF32_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_XTENSA_RELATIVE
case|:
return|return
name|reloc_class_relative
return|;
case|case
name|R_XTENSA_JMP_SLOT
case|:
return|return
name|reloc_class_plt
return|;
default|default:
return|return
name|reloc_class_normal
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_discard_info_for_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|elf_reloc_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|section_size
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|,
name|actual_offset
decl_stmt|;
name|size_t
name|removed_bytes
init|=
literal|0
decl_stmt|;
name|section_size
operator|=
name|sec
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|section_size
operator|==
literal|0
operator|||
name|section_size
operator|%
literal|8
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|sec
operator|->
name|output_section
operator|&&
name|bfd_is_abs_section
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|contents
operator|=
name|retrieve_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|contents
condition|)
return|return
name|FALSE
return|;
name|cookie
operator|->
name|rels
operator|=
name|retrieve_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cookie
operator|->
name|rels
condition|)
block|{
name|release_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|cookie
operator|->
name|rel
operator|=
name|cookie
operator|->
name|rels
expr_stmt|;
name|cookie
operator|->
name|relend
operator|=
name|cookie
operator|->
name|rels
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|section_size
condition|;
name|offset
operator|+=
literal|8
control|)
block|{
name|actual_offset
operator|=
name|offset
operator|-
name|removed_bytes
expr_stmt|;
comment|/* The ...symbol_deleted_p function will skip over relocs but it 	 won't adjust their offsets, so do that here.  */
while|while
condition|(
name|cookie
operator|->
name|rel
operator|<
name|cookie
operator|->
name|relend
operator|&&
name|cookie
operator|->
name|rel
operator|->
name|r_offset
operator|<
name|offset
condition|)
block|{
name|cookie
operator|->
name|rel
operator|->
name|r_offset
operator|-=
name|removed_bytes
expr_stmt|;
name|cookie
operator|->
name|rel
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|cookie
operator|->
name|rel
operator|<
name|cookie
operator|->
name|relend
operator|&&
name|cookie
operator|->
name|rel
operator|->
name|r_offset
operator|==
name|offset
condition|)
block|{
if|if
condition|(
name|bfd_elf_reloc_symbol_deleted_p
argument_list|(
name|offset
argument_list|,
name|cookie
argument_list|)
condition|)
block|{
comment|/* Remove the table entry.  (If the reloc type is NONE, then 		 the entry has already been merged with another and deleted 		 during relaxation.)  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|cookie
operator|->
name|rel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_XTENSA_NONE
condition|)
block|{
comment|/* Shift the contents up.  */
if|if
condition|(
name|offset
operator|+
literal|8
operator|<
name|section_size
condition|)
name|memmove
argument_list|(
operator|&
name|contents
index|[
name|actual_offset
index|]
argument_list|,
operator|&
name|contents
index|[
name|actual_offset
operator|+
literal|8
index|]
argument_list|,
name|section_size
operator|-
name|offset
operator|-
literal|8
argument_list|)
expr_stmt|;
name|removed_bytes
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* Remove this relocation.  */
name|cookie
operator|->
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_XTENSA_NONE
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust the relocation offset for previous removals.  This 	     should not be done before calling ...symbol_deleted_p 	     because it might mess up the offset comparisons there. 	     Make sure the offset doesn't underflow in the case where 	     the first entry is removed.  */
if|if
condition|(
name|cookie
operator|->
name|rel
operator|->
name|r_offset
operator|>=
name|removed_bytes
condition|)
name|cookie
operator|->
name|rel
operator|->
name|r_offset
operator|-=
name|removed_bytes
expr_stmt|;
else|else
name|cookie
operator|->
name|rel
operator|->
name|r_offset
operator|=
literal|0
expr_stmt|;
name|cookie
operator|->
name|rel
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|removed_bytes
operator|!=
literal|0
condition|)
block|{
comment|/* Adjust any remaining relocs (shouldn't be any).  */
for|for
control|(
init|;
name|cookie
operator|->
name|rel
operator|<
name|cookie
operator|->
name|relend
condition|;
name|cookie
operator|->
name|rel
operator|++
control|)
block|{
if|if
condition|(
name|cookie
operator|->
name|rel
operator|->
name|r_offset
operator|>=
name|removed_bytes
condition|)
name|cookie
operator|->
name|rel
operator|->
name|r_offset
operator|-=
name|removed_bytes
expr_stmt|;
else|else
name|cookie
operator|->
name|rel
operator|->
name|r_offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Clear the removed bytes.  */
name|memset
argument_list|(
operator|&
name|contents
index|[
name|section_size
operator|-
name|removed_bytes
index|]
argument_list|,
literal|0
argument_list|,
name|removed_bytes
argument_list|)
expr_stmt|;
name|pin_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|pin_internal_relocs
argument_list|(
name|sec
argument_list|,
name|cookie
operator|->
name|rels
argument_list|)
expr_stmt|;
comment|/* Shrink size.  */
name|sec
operator|->
name|size
operator|=
name|section_size
operator|-
name|removed_bytes
expr_stmt|;
if|if
condition|(
name|xtensa_is_littable_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
name|bfd
modifier|*
name|dynobj
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
decl_stmt|;
if|if
condition|(
name|dynobj
condition|)
block|{
name|asection
modifier|*
name|sgotloc
init|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.loc"
argument_list|)
decl_stmt|;
if|if
condition|(
name|sgotloc
condition|)
name|sgotloc
operator|->
name|size
operator|-=
name|removed_bytes
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|release_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|release_internal_relocs
argument_list|(
name|sec
argument_list|,
name|cookie
operator|->
name|rels
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|removed_bytes
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_discard_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|elf_reloc_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_boolean
name|changed
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
if|if
condition|(
name|xtensa_is_property_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
if|if
condition|(
name|elf_xtensa_discard_info_for_section
argument_list|(
name|abfd
argument_list|,
name|cookie
argument_list|,
name|info
argument_list|,
name|sec
argument_list|)
condition|)
name|changed
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
return|return
name|changed
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_ignore_discarded_relocs
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|)
block|{
return|return
name|xtensa_is_property_section
argument_list|(
name|sec
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Support for core dump NOTE sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_grok_prstatus
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
comment|/* The size for Xtensa is variable, so don't try to recognize the format      based on the size.  Just assume this is GNU/Linux.  */
comment|/* pr_cursig */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* pr_pid */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_pid
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|24
argument_list|)
expr_stmt|;
comment|/* pr_reg */
name|offset
operator|=
literal|72
expr_stmt|;
name|size
operator|=
name|note
operator|->
name|descsz
operator|-
name|offset
operator|-
literal|4
expr_stmt|;
comment|/* Make a ".reg/999" section.  */
return|return
name|_bfd_elfcore_make_pseudosection
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|,
name|size
argument_list|,
name|note
operator|->
name|descpos
operator|+
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_grok_psinfo
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
switch|switch
condition|(
name|note
operator|->
name|descsz
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
literal|128
case|:
comment|/* GNU/Linux elf_prpsinfo */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_program
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|32
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|48
argument_list|,
literal|80
argument_list|)
expr_stmt|;
block|}
comment|/* Note that for some reason, a spurious space is tacked      onto the end of the args in some (at least one anyway)      implementations, so strip it off if it exists.  */
block|{
name|char
modifier|*
name|command
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
decl_stmt|;
name|int
name|n
init|=
name|strlen
argument_list|(
name|command
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|n
operator|&&
name|command
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|command
index|[
name|n
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generic Xtensa configurability stuff.  */
end_comment

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|callx0_op
init|=
name|XTENSA_UNDEFINED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|callx4_op
init|=
name|XTENSA_UNDEFINED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|callx8_op
init|=
name|XTENSA_UNDEFINED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|callx12_op
init|=
name|XTENSA_UNDEFINED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|call0_op
init|=
name|XTENSA_UNDEFINED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|call4_op
init|=
name|XTENSA_UNDEFINED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|call8_op
init|=
name|XTENSA_UNDEFINED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|call12_op
init|=
name|XTENSA_UNDEFINED
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_call_opcodes
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|callx0_op
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
name|callx0_op
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|xtensa_default_isa
argument_list|,
literal|"callx0"
argument_list|)
expr_stmt|;
name|callx4_op
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|xtensa_default_isa
argument_list|,
literal|"callx4"
argument_list|)
expr_stmt|;
name|callx8_op
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|xtensa_default_isa
argument_list|,
literal|"callx8"
argument_list|)
expr_stmt|;
name|callx12_op
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|xtensa_default_isa
argument_list|,
literal|"callx12"
argument_list|)
expr_stmt|;
name|call0_op
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|xtensa_default_isa
argument_list|,
literal|"call0"
argument_list|)
expr_stmt|;
name|call4_op
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|xtensa_default_isa
argument_list|,
literal|"call4"
argument_list|)
expr_stmt|;
name|call8_op
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|xtensa_default_isa
argument_list|,
literal|"call8"
argument_list|)
expr_stmt|;
name|call12_op
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|xtensa_default_isa
argument_list|,
literal|"call12"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|is_indirect_call_opcode
parameter_list|(
name|xtensa_opcode
name|opcode
parameter_list|)
block|{
name|init_call_opcodes
argument_list|()
expr_stmt|;
return|return
operator|(
name|opcode
operator|==
name|callx0_op
operator|||
name|opcode
operator|==
name|callx4_op
operator|||
name|opcode
operator|==
name|callx8_op
operator|||
name|opcode
operator|==
name|callx12_op
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|is_direct_call_opcode
parameter_list|(
name|xtensa_opcode
name|opcode
parameter_list|)
block|{
name|init_call_opcodes
argument_list|()
expr_stmt|;
return|return
operator|(
name|opcode
operator|==
name|call0_op
operator|||
name|opcode
operator|==
name|call4_op
operator|||
name|opcode
operator|==
name|call8_op
operator|||
name|opcode
operator|==
name|call12_op
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|is_windowed_call_opcode
parameter_list|(
name|xtensa_opcode
name|opcode
parameter_list|)
block|{
name|init_call_opcodes
argument_list|()
expr_stmt|;
return|return
operator|(
name|opcode
operator|==
name|call4_op
operator|||
name|opcode
operator|==
name|call8_op
operator|||
name|opcode
operator|==
name|call12_op
operator|||
name|opcode
operator|==
name|callx4_op
operator|||
name|opcode
operator|==
name|callx8_op
operator|||
name|opcode
operator|==
name|callx12_op
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|xtensa_opcode
name|get_const16_opcode
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|bfd_boolean
name|done_lookup
init|=
name|FALSE
decl_stmt|;
specifier|static
name|xtensa_opcode
name|const16_opcode
init|=
name|XTENSA_UNDEFINED
decl_stmt|;
if|if
condition|(
operator|!
name|done_lookup
condition|)
block|{
name|const16_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|xtensa_default_isa
argument_list|,
literal|"const16"
argument_list|)
expr_stmt|;
name|done_lookup
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|const16_opcode
return|;
block|}
end_function

begin_function
specifier|static
name|xtensa_opcode
name|get_l32r_opcode
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|xtensa_opcode
name|l32r_opcode
init|=
name|XTENSA_UNDEFINED
decl_stmt|;
specifier|static
name|bfd_boolean
name|done_lookup
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|done_lookup
condition|)
block|{
name|l32r_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|xtensa_default_isa
argument_list|,
literal|"l32r"
argument_list|)
expr_stmt|;
name|done_lookup
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|l32r_opcode
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|l32r_offset
parameter_list|(
name|bfd_vma
name|addr
parameter_list|,
name|bfd_vma
name|pc
parameter_list|)
block|{
name|bfd_vma
name|offset
decl_stmt|;
name|offset
operator|=
name|addr
operator|-
operator|(
operator|(
name|pc
operator|+
literal|3
operator|)
operator|&
operator|-
literal|4
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|offset
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|signed
name|int
operator|)
name|offset
operator|>>
literal|2
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|signed
name|int
operator|)
name|offset
operator|>>
literal|16
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_relocation_opnd
parameter_list|(
name|xtensa_opcode
name|opcode
parameter_list|,
name|int
name|r_type
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|int
name|last_immed
decl_stmt|,
name|last_opnd
decl_stmt|,
name|opi
decl_stmt|;
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
comment|/* Find the last visible PC-relative immediate operand for the opcode.      If there are no PC-relative immediates, then choose the last visible      immediate; otherwise, fail and return XTENSA_UNDEFINED.  */
name|last_immed
operator|=
name|XTENSA_UNDEFINED
expr_stmt|;
name|last_opnd
operator|=
name|xtensa_opcode_num_operands
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
for|for
control|(
name|opi
operator|=
name|last_opnd
operator|-
literal|1
init|;
name|opi
operator|>=
literal|0
condition|;
name|opi
operator|--
control|)
block|{
if|if
condition|(
name|xtensa_operand_is_visible
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|opi
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|xtensa_operand_is_PCrelative
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|opi
argument_list|)
operator|==
literal|1
condition|)
block|{
name|last_immed
operator|=
name|opi
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|last_immed
operator|==
name|XTENSA_UNDEFINED
operator|&&
name|xtensa_operand_is_register
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|opi
argument_list|)
operator|==
literal|0
condition|)
name|last_immed
operator|=
name|opi
expr_stmt|;
block|}
if|if
condition|(
name|last_immed
operator|<
literal|0
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
comment|/* If the operand number was specified in an old-style relocation,      check for consistency with the operand computed above.  */
if|if
condition|(
name|r_type
operator|>=
name|R_XTENSA_OP0
operator|&&
name|r_type
operator|<=
name|R_XTENSA_OP2
condition|)
block|{
name|int
name|reloc_opnd
init|=
name|r_type
operator|-
name|R_XTENSA_OP0
decl_stmt|;
if|if
condition|(
name|reloc_opnd
operator|!=
name|last_immed
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
block|}
return|return
name|last_immed
return|;
block|}
end_function

begin_function
name|int
name|get_relocation_slot
parameter_list|(
name|int
name|r_type
parameter_list|)
block|{
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_XTENSA_OP0
case|:
case|case
name|R_XTENSA_OP1
case|:
case|case
name|R_XTENSA_OP2
case|:
return|return
literal|0
return|;
default|default:
if|if
condition|(
name|r_type
operator|>=
name|R_XTENSA_SLOT0_OP
operator|&&
name|r_type
operator|<=
name|R_XTENSA_SLOT14_OP
condition|)
return|return
name|r_type
operator|-
name|R_XTENSA_SLOT0_OP
return|;
if|if
condition|(
name|r_type
operator|>=
name|R_XTENSA_SLOT0_ALT
operator|&&
name|r_type
operator|<=
name|R_XTENSA_SLOT14_ALT
condition|)
return|return
name|r_type
operator|-
name|R_XTENSA_SLOT0_ALT
return|;
break|break;
block|}
return|return
name|XTENSA_UNDEFINED
return|;
block|}
end_function

begin_comment
comment|/* Get the opcode for a relocation.  */
end_comment

begin_function
specifier|static
name|xtensa_opcode
name|get_relocation_opcode
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|irel
parameter_list|)
block|{
specifier|static
name|xtensa_insnbuf
name|ibuff
init|=
name|NULL
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|sbuff
init|=
name|NULL
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|xtensa_format
name|fmt
decl_stmt|;
name|int
name|slot
decl_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
if|if
condition|(
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|<=
name|irel
operator|->
name|r_offset
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
if|if
condition|(
name|ibuff
operator|==
name|NULL
condition|)
block|{
name|ibuff
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|sbuff
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
block|}
comment|/* Decode the instruction.  */
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|ibuff
argument_list|,
operator|&
name|contents
index|[
name|irel
operator|->
name|r_offset
index|]
argument_list|,
name|sec
operator|->
name|size
operator|-
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|xtensa_format_decode
argument_list|(
name|isa
argument_list|,
name|ibuff
argument_list|)
expr_stmt|;
name|slot
operator|=
name|get_relocation_slot
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
name|xtensa_format_get_slot
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|ibuff
argument_list|,
name|sbuff
argument_list|)
expr_stmt|;
return|return
name|xtensa_opcode_decode
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|sbuff
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|is_l32r_relocation
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|irel
parameter_list|)
block|{
name|xtensa_opcode
name|opcode
decl_stmt|;
if|if
condition|(
operator|!
name|is_operand_relocation
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|opcode
operator|=
name|get_relocation_opcode
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
name|irel
argument_list|)
expr_stmt|;
return|return
operator|(
name|opcode
operator|==
name|get_l32r_opcode
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_size_type
name|get_asm_simplify_size
parameter_list|(
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|bfd_size_type
name|content_len
parameter_list|,
name|bfd_size_type
name|offset
parameter_list|)
block|{
name|bfd_size_type
name|insnlen
decl_stmt|,
name|size
init|=
literal|0
decl_stmt|;
comment|/* Decode the size of the next two instructions.  */
name|insnlen
operator|=
name|insn_decode_len
argument_list|(
name|contents
argument_list|,
name|content_len
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|insnlen
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|size
operator|+=
name|insnlen
expr_stmt|;
name|insnlen
operator|=
name|insn_decode_len
argument_list|(
name|contents
argument_list|,
name|content_len
argument_list|,
name|offset
operator|+
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|insnlen
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|size
operator|+=
name|insnlen
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|is_alt_relocation
parameter_list|(
name|int
name|r_type
parameter_list|)
block|{
return|return
operator|(
name|r_type
operator|>=
name|R_XTENSA_SLOT0_ALT
operator|&&
name|r_type
operator|<=
name|R_XTENSA_SLOT14_ALT
operator|)
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|is_operand_relocation
parameter_list|(
name|int
name|r_type
parameter_list|)
block|{
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_XTENSA_OP0
case|:
case|case
name|R_XTENSA_OP1
case|:
case|case
name|R_XTENSA_OP2
case|:
return|return
name|TRUE
return|;
default|default:
if|if
condition|(
name|r_type
operator|>=
name|R_XTENSA_SLOT0_OP
operator|&&
name|r_type
operator|<=
name|R_XTENSA_SLOT14_OP
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|r_type
operator|>=
name|R_XTENSA_SLOT0_ALT
operator|&&
name|r_type
operator|<=
name|R_XTENSA_SLOT14_ALT
condition|)
return|return
name|TRUE
return|;
break|break;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MIN_INSN_LENGTH
value|2
end_define

begin_comment
comment|/* Return 0 if it fails to decode.  */
end_comment

begin_function
name|bfd_size_type
name|insn_decode_len
parameter_list|(
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|bfd_size_type
name|content_len
parameter_list|,
name|bfd_size_type
name|offset
parameter_list|)
block|{
name|int
name|insn_len
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|xtensa_format
name|fmt
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|ibuff
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|offset
operator|+
name|MIN_INSN_LENGTH
operator|>
name|content_len
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ibuff
operator|==
name|NULL
condition|)
name|ibuff
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|ibuff
argument_list|,
operator|&
name|contents
index|[
name|offset
index|]
argument_list|,
name|content_len
operator|-
name|offset
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|xtensa_format_decode
argument_list|(
name|isa
argument_list|,
name|ibuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
literal|0
return|;
name|insn_len
operator|=
name|xtensa_format_length
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_len
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
literal|0
return|;
return|return
name|insn_len
return|;
block|}
end_function

begin_comment
comment|/* Decode the opcode for a single slot instruction.    Return 0 if it fails to decode or the instruction is multi-slot.  */
end_comment

begin_function
name|xtensa_opcode
name|insn_decode_opcode
parameter_list|(
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|bfd_size_type
name|content_len
parameter_list|,
name|bfd_size_type
name|offset
parameter_list|,
name|int
name|slot
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|xtensa_format
name|fmt
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|slotbuf
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|offset
operator|+
name|MIN_INSN_LENGTH
operator|>
name|content_len
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
if|if
condition|(
name|insnbuf
operator|==
name|NULL
condition|)
block|{
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|slotbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
block|}
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
operator|&
name|contents
index|[
name|offset
index|]
argument_list|,
name|content_len
operator|-
name|offset
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|xtensa_format_decode
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
if|if
condition|(
name|slot
operator|>=
name|xtensa_format_num_slots
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
name|xtensa_format_get_slot
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|insnbuf
argument_list|,
name|slotbuf
argument_list|)
expr_stmt|;
return|return
name|xtensa_opcode_decode
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|slotbuf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The offset is the offset in the contents.    The address is the address of that offset.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|check_branch_target_aligned
parameter_list|(
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|bfd_size_type
name|content_length
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|bfd_vma
name|address
parameter_list|)
block|{
name|bfd_size_type
name|insn_len
init|=
name|insn_decode_len
argument_list|(
name|contents
argument_list|,
name|content_length
argument_list|,
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|insn_len
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
return|return
name|check_branch_target_aligned_address
argument_list|(
name|address
argument_list|,
name|insn_len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|check_loop_aligned
parameter_list|(
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|bfd_size_type
name|content_length
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|bfd_vma
name|address
parameter_list|)
block|{
name|bfd_size_type
name|loop_len
decl_stmt|,
name|insn_len
decl_stmt|;
name|xtensa_opcode
name|opcode
init|=
name|insn_decode_opcode
argument_list|(
name|contents
argument_list|,
name|content_length
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|opcode
operator|!=
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|!=
name|XTENSA_UNDEFINED
condition|)
return|return
name|FALSE
return|;
name|BFD_ASSERT
argument_list|(
name|xtensa_opcode_is_loop
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xtensa_opcode_is_loop
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|loop_len
operator|=
name|insn_decode_len
argument_list|(
name|contents
argument_list|,
name|content_length
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|loop_len
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop_len
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
name|insn_len
operator|=
name|insn_decode_len
argument_list|(
name|contents
argument_list|,
name|content_length
argument_list|,
name|offset
operator|+
name|loop_len
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|insn_len
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_len
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
return|return
name|check_branch_target_aligned_address
argument_list|(
name|address
operator|+
name|loop_len
argument_list|,
name|insn_len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|check_branch_target_aligned_address
parameter_list|(
name|bfd_vma
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|==
literal|8
condition|)
return|return
operator|(
name|addr
operator|%
literal|8
operator|==
literal|0
operator|)
return|;
return|return
operator|(
operator|(
name|addr
operator|>>
literal|2
operator|)
operator|==
operator|(
operator|(
name|addr
operator|+
name|len
operator|-
literal|1
operator|)
operator|>>
literal|2
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Instruction widening and narrowing.  */
end_comment

begin_comment
comment|/* When FLIX is available we need to access certain instructions only    when they are 16-bit or 24-bit instructions.  This table caches    information about such instructions by walking through all the    opcodes and finding the smallest single-slot format into which each    can be encoded.  */
end_comment

begin_decl_stmt
specifier|static
name|xtensa_format
modifier|*
name|op_single_fmt_table
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_op_single_format_table
parameter_list|(
name|void
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|xtensa_insnbuf
name|ibuf
decl_stmt|;
name|xtensa_opcode
name|opcode
decl_stmt|;
name|xtensa_format
name|fmt
decl_stmt|;
name|int
name|num_opcodes
decl_stmt|;
if|if
condition|(
name|op_single_fmt_table
condition|)
return|return;
name|ibuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|num_opcodes
operator|=
name|xtensa_isa_num_opcodes
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|op_single_fmt_table
operator|=
operator|(
name|xtensa_format
operator|*
operator|)
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xtensa_format
argument_list|)
operator|*
name|num_opcodes
argument_list|)
expr_stmt|;
for|for
control|(
name|opcode
operator|=
literal|0
init|;
name|opcode
operator|<
name|num_opcodes
condition|;
name|opcode
operator|++
control|)
block|{
name|op_single_fmt_table
index|[
name|opcode
index|]
operator|=
name|XTENSA_UNDEFINED
expr_stmt|;
for|for
control|(
name|fmt
operator|=
literal|0
init|;
name|fmt
operator|<
name|xtensa_isa_num_formats
argument_list|(
name|isa
argument_list|)
condition|;
name|fmt
operator|++
control|)
block|{
if|if
condition|(
name|xtensa_format_num_slots
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
operator|==
literal|1
operator|&&
name|xtensa_opcode_encode
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|,
name|ibuf
argument_list|,
name|opcode
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xtensa_opcode
name|old_fmt
init|=
name|op_single_fmt_table
index|[
name|opcode
index|]
decl_stmt|;
name|int
name|fmt_length
init|=
name|xtensa_format_length
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|old_fmt
operator|==
name|XTENSA_UNDEFINED
operator|||
name|fmt_length
operator|<
name|xtensa_format_length
argument_list|(
name|isa
argument_list|,
name|old_fmt
argument_list|)
condition|)
name|op_single_fmt_table
index|[
name|opcode
index|]
operator|=
name|fmt
expr_stmt|;
block|}
block|}
block|}
name|xtensa_insnbuf_free
argument_list|(
name|isa
argument_list|,
name|ibuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|xtensa_format
name|get_single_format
parameter_list|(
name|xtensa_opcode
name|opcode
parameter_list|)
block|{
name|init_op_single_format_table
argument_list|()
expr_stmt|;
return|return
name|op_single_fmt_table
index|[
name|opcode
index|]
return|;
block|}
end_function

begin_comment
comment|/* For the set of narrowable instructions we do NOT include the    narrowings beqz -> beqz.n or bnez -> bnez.n because of complexities    involved during linker relaxation that may require these to    re-expand in some conditions.  Also, the narrowing "or" -> mov.n    requires special case code to ensure it only works when op1 == op2.  */
end_comment

begin_struct
struct|struct
name|string_pair
block|{
specifier|const
name|char
modifier|*
name|wide
decl_stmt|;
specifier|const
name|char
modifier|*
name|narrow
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|string_pair
name|narrowable
index|[]
init|=
block|{
block|{
literal|"add"
block|,
literal|"add.n"
block|}
block|,
block|{
literal|"addi"
block|,
literal|"addi.n"
block|}
block|,
block|{
literal|"addmi"
block|,
literal|"addi.n"
block|}
block|,
block|{
literal|"l32i"
block|,
literal|"l32i.n"
block|}
block|,
block|{
literal|"movi"
block|,
literal|"movi.n"
block|}
block|,
block|{
literal|"ret"
block|,
literal|"ret.n"
block|}
block|,
block|{
literal|"retw"
block|,
literal|"retw.n"
block|}
block|,
block|{
literal|"s32i"
block|,
literal|"s32i.n"
block|}
block|,
block|{
literal|"or"
block|,
literal|"mov.n"
block|}
comment|/* special case only when op1 == op2 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|string_pair
name|widenable
index|[]
init|=
block|{
block|{
literal|"add"
block|,
literal|"add.n"
block|}
block|,
block|{
literal|"addi"
block|,
literal|"addi.n"
block|}
block|,
block|{
literal|"addmi"
block|,
literal|"addi.n"
block|}
block|,
block|{
literal|"beqz"
block|,
literal|"beqz.n"
block|}
block|,
block|{
literal|"bnez"
block|,
literal|"bnez.n"
block|}
block|,
block|{
literal|"l32i"
block|,
literal|"l32i.n"
block|}
block|,
block|{
literal|"movi"
block|,
literal|"movi.n"
block|}
block|,
block|{
literal|"ret"
block|,
literal|"ret.n"
block|}
block|,
block|{
literal|"retw"
block|,
literal|"retw.n"
block|}
block|,
block|{
literal|"s32i"
block|,
literal|"s32i.n"
block|}
block|,
block|{
literal|"or"
block|,
literal|"mov.n"
block|}
comment|/* special case only when op1 == op2 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Attempt to narrow an instruction.  Return true if the narrowing is    valid.  If the do_it parameter is non-zero, then perform the action    in-place directly into the contents.  Otherwise, do not modify the    contents.  The set of valid narrowing are specified by a string table    but require some special case operand checks in some cases.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|narrow_instruction
parameter_list|(
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|bfd_size_type
name|content_length
parameter_list|,
name|bfd_size_type
name|offset
parameter_list|,
name|bfd_boolean
name|do_it
parameter_list|)
block|{
name|xtensa_opcode
name|opcode
decl_stmt|;
name|bfd_size_type
name|insn_len
decl_stmt|,
name|opi
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|xtensa_format
name|fmt
decl_stmt|,
name|o_fmt
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|slotbuf
init|=
name|NULL
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|o_insnbuf
init|=
name|NULL
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|o_slotbuf
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|insnbuf
operator|==
name|NULL
condition|)
block|{
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|slotbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|o_insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|o_slotbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|offset
operator|<
name|content_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|content_length
operator|<
literal|2
condition|)
return|return
name|FALSE
return|;
comment|/* We will hand-code a few of these for a little while.      These have all been specified in the assembler aleady.  */
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
operator|&
name|contents
index|[
name|offset
index|]
argument_list|,
name|content_length
operator|-
name|offset
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|xtensa_format_decode
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|xtensa_format_num_slots
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|xtensa_format_get_slot
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|,
name|insnbuf
argument_list|,
name|slotbuf
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|opcode
operator|=
name|xtensa_opcode_decode
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|,
name|slotbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|FALSE
return|;
name|insn_len
operator|=
name|xtensa_format_length
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_len
operator|>
name|content_length
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|opi
operator|=
literal|0
init|;
name|opi
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|narrowable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|string_pair
argument_list|)
operator|)
condition|;
operator|++
name|opi
control|)
block|{
name|bfd_boolean
name|is_or
init|=
operator|(
name|strcmp
argument_list|(
literal|"or"
argument_list|,
name|narrowable
index|[
name|opi
index|]
operator|.
name|wide
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|opcode
operator|==
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
name|narrowable
index|[
name|opi
index|]
operator|.
name|wide
argument_list|)
condition|)
block|{
name|uint32
name|value
decl_stmt|,
name|newval
decl_stmt|;
name|int
name|i
decl_stmt|,
name|operand_count
decl_stmt|,
name|o_operand_count
decl_stmt|;
name|xtensa_opcode
name|o_opcode
decl_stmt|;
comment|/* Address does not matter in this case.  We might need to 	     fix it to handle branches/jumps.  */
name|bfd_vma
name|self_address
init|=
literal|0
decl_stmt|;
name|o_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
name|narrowable
index|[
name|opi
index|]
operator|.
name|narrow
argument_list|)
expr_stmt|;
if|if
condition|(
name|o_opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|FALSE
return|;
name|o_fmt
operator|=
name|get_single_format
argument_list|(
name|o_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|o_fmt
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|xtensa_format_length
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
operator|!=
literal|3
operator|||
name|xtensa_format_length
argument_list|(
name|isa
argument_list|,
name|o_fmt
argument_list|)
operator|!=
literal|2
condition|)
return|return
name|FALSE
return|;
name|xtensa_format_encode
argument_list|(
name|isa
argument_list|,
name|o_fmt
argument_list|,
name|o_insnbuf
argument_list|)
expr_stmt|;
name|operand_count
operator|=
name|xtensa_opcode_num_operands
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
name|o_operand_count
operator|=
name|xtensa_opcode_num_operands
argument_list|(
name|isa
argument_list|,
name|o_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|xtensa_opcode_encode
argument_list|(
name|isa
argument_list|,
name|o_fmt
argument_list|,
literal|0
argument_list|,
name|o_slotbuf
argument_list|,
name|o_opcode
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|is_or
condition|)
block|{
if|if
condition|(
name|xtensa_opcode_num_operands
argument_list|(
name|isa
argument_list|,
name|o_opcode
argument_list|)
operator|!=
name|operand_count
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|uint32
name|rawval0
decl_stmt|,
name|rawval1
decl_stmt|,
name|rawval2
decl_stmt|;
if|if
condition|(
name|o_operand_count
operator|+
literal|1
operator|!=
name|operand_count
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|xtensa_operand_get_field
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|,
name|slotbuf
argument_list|,
operator|&
name|rawval0
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|xtensa_operand_get_field
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
literal|1
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|,
name|slotbuf
argument_list|,
operator|&
name|rawval1
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|xtensa_operand_get_field
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
literal|2
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|,
name|slotbuf
argument_list|,
operator|&
name|rawval2
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|rawval1
operator|!=
name|rawval2
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|rawval0
operator|==
name|rawval1
condition|)
comment|/* it is a nop */
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|o_operand_count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|xtensa_operand_get_field
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|i
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|,
name|slotbuf
argument_list|,
operator|&
name|value
argument_list|)
operator|||
name|xtensa_operand_decode
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|i
argument_list|,
operator|&
name|value
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* PC-relative branches need adjustment, but 		 the PC-rel operand will always have a relocation.  */
name|newval
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|xtensa_operand_do_reloc
argument_list|(
name|isa
argument_list|,
name|o_opcode
argument_list|,
name|i
argument_list|,
operator|&
name|newval
argument_list|,
name|self_address
argument_list|)
operator|||
name|xtensa_operand_encode
argument_list|(
name|isa
argument_list|,
name|o_opcode
argument_list|,
name|i
argument_list|,
operator|&
name|newval
argument_list|)
operator|||
name|xtensa_operand_set_field
argument_list|(
name|isa
argument_list|,
name|o_opcode
argument_list|,
name|i
argument_list|,
name|o_fmt
argument_list|,
literal|0
argument_list|,
name|o_slotbuf
argument_list|,
name|newval
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|xtensa_format_set_slot
argument_list|(
name|isa
argument_list|,
name|o_fmt
argument_list|,
literal|0
argument_list|,
name|o_insnbuf
argument_list|,
name|o_slotbuf
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|do_it
condition|)
name|xtensa_insnbuf_to_chars
argument_list|(
name|isa
argument_list|,
name|o_insnbuf
argument_list|,
name|contents
operator|+
name|offset
argument_list|,
name|content_length
operator|-
name|offset
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Attempt to widen an instruction.  Return true if the widening is    valid.  If the do_it parameter is non-zero, then the action should    be performed inplace into the contents.  Otherwise, do not modify    the contents.  The set of valid widenings are specified by a string    table but require some special case operand checks in some    cases.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|widen_instruction
parameter_list|(
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|bfd_size_type
name|content_length
parameter_list|,
name|bfd_size_type
name|offset
parameter_list|,
name|bfd_boolean
name|do_it
parameter_list|)
block|{
name|xtensa_opcode
name|opcode
decl_stmt|;
name|bfd_size_type
name|insn_len
decl_stmt|,
name|opi
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|xtensa_format
name|fmt
decl_stmt|,
name|o_fmt
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|slotbuf
init|=
name|NULL
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|o_insnbuf
init|=
name|NULL
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|o_slotbuf
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|insnbuf
operator|==
name|NULL
condition|)
block|{
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|slotbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|o_insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|o_slotbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|offset
operator|<
name|content_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|content_length
operator|<
literal|2
condition|)
return|return
name|FALSE
return|;
comment|/* We will hand code a few of these for a little while.      These have all been specified in the assembler aleady.  */
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
operator|&
name|contents
index|[
name|offset
index|]
argument_list|,
name|content_length
operator|-
name|offset
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|xtensa_format_decode
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|xtensa_format_num_slots
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|xtensa_format_get_slot
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|,
name|insnbuf
argument_list|,
name|slotbuf
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|opcode
operator|=
name|xtensa_opcode_decode
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|,
name|slotbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|FALSE
return|;
name|insn_len
operator|=
name|xtensa_format_length
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_len
operator|>
name|content_length
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|opi
operator|=
literal|0
init|;
name|opi
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|widenable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|string_pair
argument_list|)
operator|)
condition|;
operator|++
name|opi
control|)
block|{
name|bfd_boolean
name|is_or
init|=
operator|(
name|strcmp
argument_list|(
literal|"or"
argument_list|,
name|widenable
index|[
name|opi
index|]
operator|.
name|wide
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
name|bfd_boolean
name|is_branch
init|=
operator|(
name|strcmp
argument_list|(
literal|"beqz"
argument_list|,
name|widenable
index|[
name|opi
index|]
operator|.
name|wide
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
literal|"bnez"
argument_list|,
name|widenable
index|[
name|opi
index|]
operator|.
name|wide
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|opcode
operator|==
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
name|widenable
index|[
name|opi
index|]
operator|.
name|narrow
argument_list|)
condition|)
block|{
name|uint32
name|value
decl_stmt|,
name|newval
decl_stmt|;
name|int
name|i
decl_stmt|,
name|operand_count
decl_stmt|,
name|o_operand_count
decl_stmt|,
name|check_operand_count
decl_stmt|;
name|xtensa_opcode
name|o_opcode
decl_stmt|;
comment|/* Address does not matter in this case.  We might need to fix it 	     to handle branches/jumps.  */
name|bfd_vma
name|self_address
init|=
literal|0
decl_stmt|;
name|o_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
name|widenable
index|[
name|opi
index|]
operator|.
name|wide
argument_list|)
expr_stmt|;
if|if
condition|(
name|o_opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|FALSE
return|;
name|o_fmt
operator|=
name|get_single_format
argument_list|(
name|o_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|o_fmt
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|xtensa_format_length
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
operator|!=
literal|2
operator|||
name|xtensa_format_length
argument_list|(
name|isa
argument_list|,
name|o_fmt
argument_list|)
operator|!=
literal|3
condition|)
return|return
name|FALSE
return|;
name|xtensa_format_encode
argument_list|(
name|isa
argument_list|,
name|o_fmt
argument_list|,
name|o_insnbuf
argument_list|)
expr_stmt|;
name|operand_count
operator|=
name|xtensa_opcode_num_operands
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
name|o_operand_count
operator|=
name|xtensa_opcode_num_operands
argument_list|(
name|isa
argument_list|,
name|o_opcode
argument_list|)
expr_stmt|;
name|check_operand_count
operator|=
name|o_operand_count
expr_stmt|;
if|if
condition|(
name|xtensa_opcode_encode
argument_list|(
name|isa
argument_list|,
name|o_fmt
argument_list|,
literal|0
argument_list|,
name|o_slotbuf
argument_list|,
name|o_opcode
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|is_or
condition|)
block|{
if|if
condition|(
name|xtensa_opcode_num_operands
argument_list|(
name|isa
argument_list|,
name|o_opcode
argument_list|)
operator|!=
name|operand_count
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|uint32
name|rawval0
decl_stmt|,
name|rawval1
decl_stmt|;
if|if
condition|(
name|o_operand_count
operator|!=
name|operand_count
operator|+
literal|1
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|xtensa_operand_get_field
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|,
name|slotbuf
argument_list|,
operator|&
name|rawval0
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|xtensa_operand_get_field
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
literal|1
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|,
name|slotbuf
argument_list|,
operator|&
name|rawval1
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|rawval0
operator|==
name|rawval1
condition|)
comment|/* it is a nop */
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|is_branch
condition|)
name|check_operand_count
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|check_operand_count
condition|;
operator|++
name|i
control|)
block|{
name|int
name|new_i
init|=
name|i
decl_stmt|;
if|if
condition|(
name|is_or
operator|&&
name|i
operator|==
name|o_operand_count
operator|-
literal|1
condition|)
name|new_i
operator|=
name|i
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|xtensa_operand_get_field
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|new_i
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|,
name|slotbuf
argument_list|,
operator|&
name|value
argument_list|)
operator|||
name|xtensa_operand_decode
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|new_i
argument_list|,
operator|&
name|value
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* PC-relative branches need adjustment, but 		 the PC-rel operand will always have a relocation.  */
name|newval
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|xtensa_operand_do_reloc
argument_list|(
name|isa
argument_list|,
name|o_opcode
argument_list|,
name|i
argument_list|,
operator|&
name|newval
argument_list|,
name|self_address
argument_list|)
operator|||
name|xtensa_operand_encode
argument_list|(
name|isa
argument_list|,
name|o_opcode
argument_list|,
name|i
argument_list|,
operator|&
name|newval
argument_list|)
operator|||
name|xtensa_operand_set_field
argument_list|(
name|isa
argument_list|,
name|o_opcode
argument_list|,
name|i
argument_list|,
name|o_fmt
argument_list|,
literal|0
argument_list|,
name|o_slotbuf
argument_list|,
name|newval
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|xtensa_format_set_slot
argument_list|(
name|isa
argument_list|,
name|o_fmt
argument_list|,
literal|0
argument_list|,
name|o_insnbuf
argument_list|,
name|o_slotbuf
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|do_it
condition|)
name|xtensa_insnbuf_to_chars
argument_list|(
name|isa
argument_list|,
name|o_insnbuf
argument_list|,
name|contents
operator|+
name|offset
argument_list|,
name|content_length
operator|-
name|offset
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Code for transforming CALLs at link-time.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|elf_xtensa_do_asm_simplify
parameter_list|(
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|bfd_vma
name|address
parameter_list|,
name|bfd_vma
name|content_length
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|slotbuf
init|=
name|NULL
decl_stmt|;
name|xtensa_format
name|core_format
init|=
name|XTENSA_UNDEFINED
decl_stmt|;
name|xtensa_opcode
name|opcode
decl_stmt|;
name|xtensa_opcode
name|direct_call_opcode
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|bfd_byte
modifier|*
name|chbuf
init|=
name|contents
operator|+
name|address
decl_stmt|;
name|int
name|opn
decl_stmt|;
if|if
condition|(
name|insnbuf
operator|==
name|NULL
condition|)
block|{
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|slotbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|content_length
operator|<
name|address
condition|)
block|{
operator|*
name|error_message
operator|=
name|_
argument_list|(
literal|"Attempt to convert L32R/CALLX to CALL failed"
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_other
return|;
block|}
name|opcode
operator|=
name|get_expanded_call_opcode
argument_list|(
name|chbuf
argument_list|,
name|content_length
operator|-
name|address
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|direct_call_opcode
operator|=
name|swap_callx_for_call_opcode
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|direct_call_opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
operator|*
name|error_message
operator|=
name|_
argument_list|(
literal|"Attempt to convert L32R/CALLX to CALL failed"
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_other
return|;
block|}
comment|/* Assemble a NOP ("or a1, a1, a1") into the 0 byte offset.  */
name|core_format
operator|=
name|xtensa_format_lookup
argument_list|(
name|isa
argument_list|,
literal|"x24"
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"or"
argument_list|)
expr_stmt|;
name|xtensa_opcode_encode
argument_list|(
name|isa
argument_list|,
name|core_format
argument_list|,
literal|0
argument_list|,
name|slotbuf
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
for|for
control|(
name|opn
operator|=
literal|0
init|;
name|opn
operator|<
literal|3
condition|;
name|opn
operator|++
control|)
block|{
name|uint32
name|regno
init|=
literal|1
decl_stmt|;
name|xtensa_operand_encode
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|opn
argument_list|,
operator|&
name|regno
argument_list|)
expr_stmt|;
name|xtensa_operand_set_field
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|opn
argument_list|,
name|core_format
argument_list|,
literal|0
argument_list|,
name|slotbuf
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
name|xtensa_format_encode
argument_list|(
name|isa
argument_list|,
name|core_format
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
name|xtensa_format_set_slot
argument_list|(
name|isa
argument_list|,
name|core_format
argument_list|,
literal|0
argument_list|,
name|insnbuf
argument_list|,
name|slotbuf
argument_list|)
expr_stmt|;
name|xtensa_insnbuf_to_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
name|chbuf
argument_list|,
name|content_length
operator|-
name|address
argument_list|)
expr_stmt|;
comment|/* Assemble a CALL ("callN 0") into the 3 byte offset.  */
name|xtensa_opcode_encode
argument_list|(
name|isa
argument_list|,
name|core_format
argument_list|,
literal|0
argument_list|,
name|slotbuf
argument_list|,
name|direct_call_opcode
argument_list|)
expr_stmt|;
name|xtensa_operand_set_field
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
literal|0
argument_list|,
name|core_format
argument_list|,
literal|0
argument_list|,
name|slotbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xtensa_format_encode
argument_list|(
name|isa
argument_list|,
name|core_format
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
name|xtensa_format_set_slot
argument_list|(
name|isa
argument_list|,
name|core_format
argument_list|,
literal|0
argument_list|,
name|insnbuf
argument_list|,
name|slotbuf
argument_list|)
expr_stmt|;
name|xtensa_insnbuf_to_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
name|chbuf
operator|+
literal|3
argument_list|,
name|content_length
operator|-
name|address
operator|-
literal|3
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|contract_asm_expansion
parameter_list|(
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|bfd_vma
name|content_length
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|irel
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
name|bfd_reloc_status_type
name|retval
init|=
name|elf_xtensa_do_asm_simplify
argument_list|(
name|contents
argument_list|,
name|irel
operator|->
name|r_offset
argument_list|,
name|content_length
argument_list|,
name|error_message
argument_list|)
decl_stmt|;
if|if
condition|(
name|retval
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|bfd_reloc_dangerous
return|;
comment|/* Update the irel->r_offset field so that the right immediate and      the right instruction are modified during the relocation.  */
name|irel
operator|->
name|r_offset
operator|+=
literal|3
expr_stmt|;
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_XTENSA_SLOT0_OP
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function
specifier|static
name|xtensa_opcode
name|swap_callx_for_call_opcode
parameter_list|(
name|xtensa_opcode
name|opcode
parameter_list|)
block|{
name|init_call_opcodes
argument_list|()
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|callx0_op
condition|)
return|return
name|call0_op
return|;
if|if
condition|(
name|opcode
operator|==
name|callx4_op
condition|)
return|return
name|call4_op
return|;
if|if
condition|(
name|opcode
operator|==
name|callx8_op
condition|)
return|return
name|call8_op
return|;
if|if
condition|(
name|opcode
operator|==
name|callx12_op
condition|)
return|return
name|call12_op
return|;
comment|/* Return XTENSA_UNDEFINED if the opcode is not an indirect call.  */
return|return
name|XTENSA_UNDEFINED
return|;
block|}
end_function

begin_comment
comment|/* Check if "buf" is pointing to a "L32R aN; CALLX aN" or "CONST16 aN;    CONST16 aN; CALLX aN" sequence, and if so, return the CALLX opcode.    If not, return XTENSA_UNDEFINED.  */
end_comment

begin_define
define|#
directive|define
name|L32R_TARGET_REG_OPERAND
value|0
end_define

begin_define
define|#
directive|define
name|CONST16_TARGET_REG_OPERAND
value|0
end_define

begin_define
define|#
directive|define
name|CALLN_SOURCE_OPERAND
value|0
end_define

begin_function
specifier|static
name|xtensa_opcode
name|get_expanded_call_opcode
parameter_list|(
name|bfd_byte
modifier|*
name|buf
parameter_list|,
name|int
name|bufsize
parameter_list|,
name|bfd_boolean
modifier|*
name|p_uses_l32r
parameter_list|)
block|{
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|slotbuf
init|=
name|NULL
decl_stmt|;
name|xtensa_format
name|fmt
decl_stmt|;
name|xtensa_opcode
name|opcode
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|uint32
name|regno
decl_stmt|,
name|const16_regno
decl_stmt|,
name|call_regno
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|insnbuf
operator|==
name|NULL
condition|)
block|{
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|slotbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
block|}
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|xtensa_format_decode
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|XTENSA_UNDEFINED
operator|||
name|xtensa_format_get_slot
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|,
name|insnbuf
argument_list|,
name|slotbuf
argument_list|)
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
name|opcode
operator|=
name|xtensa_opcode_decode
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|,
name|slotbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
if|if
condition|(
name|opcode
operator|==
name|get_l32r_opcode
argument_list|()
condition|)
block|{
if|if
condition|(
name|p_uses_l32r
condition|)
operator|*
name|p_uses_l32r
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|xtensa_operand_get_field
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|L32R_TARGET_REG_OPERAND
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|,
name|slotbuf
argument_list|,
operator|&
name|regno
argument_list|)
operator|||
name|xtensa_operand_decode
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|L32R_TARGET_REG_OPERAND
argument_list|,
operator|&
name|regno
argument_list|)
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|get_const16_opcode
argument_list|()
condition|)
block|{
if|if
condition|(
name|p_uses_l32r
condition|)
operator|*
name|p_uses_l32r
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|xtensa_operand_get_field
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|CONST16_TARGET_REG_OPERAND
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|,
name|slotbuf
argument_list|,
operator|&
name|regno
argument_list|)
operator|||
name|xtensa_operand_decode
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|CONST16_TARGET_REG_OPERAND
argument_list|,
operator|&
name|regno
argument_list|)
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
comment|/* Check that the next instruction is also CONST16.  */
name|offset
operator|+=
name|xtensa_format_length
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
name|buf
operator|+
name|offset
argument_list|,
name|bufsize
operator|-
name|offset
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|xtensa_format_decode
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|XTENSA_UNDEFINED
operator|||
name|xtensa_format_get_slot
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|,
name|insnbuf
argument_list|,
name|slotbuf
argument_list|)
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
name|opcode
operator|=
name|xtensa_opcode_decode
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|,
name|slotbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|!=
name|get_const16_opcode
argument_list|()
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
if|if
condition|(
name|xtensa_operand_get_field
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|CONST16_TARGET_REG_OPERAND
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|,
name|slotbuf
argument_list|,
operator|&
name|const16_regno
argument_list|)
operator|||
name|xtensa_operand_decode
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|CONST16_TARGET_REG_OPERAND
argument_list|,
operator|&
name|const16_regno
argument_list|)
operator|||
name|const16_regno
operator|!=
name|regno
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
block|}
else|else
return|return
name|XTENSA_UNDEFINED
return|;
comment|/* Next instruction should be an CALLXn with operand 0 == regno.  */
name|offset
operator|+=
name|xtensa_format_length
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
name|buf
operator|+
name|offset
argument_list|,
name|bufsize
operator|-
name|offset
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|xtensa_format_decode
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|XTENSA_UNDEFINED
operator|||
name|xtensa_format_get_slot
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|,
name|insnbuf
argument_list|,
name|slotbuf
argument_list|)
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
name|opcode
operator|=
name|xtensa_opcode_decode
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|,
name|slotbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
operator|||
operator|!
name|is_indirect_call_opcode
argument_list|(
name|opcode
argument_list|)
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
if|if
condition|(
name|xtensa_operand_get_field
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|CALLN_SOURCE_OPERAND
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|,
name|slotbuf
argument_list|,
operator|&
name|call_regno
argument_list|)
operator|||
name|xtensa_operand_decode
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|CALLN_SOURCE_OPERAND
argument_list|,
operator|&
name|call_regno
argument_list|)
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
if|if
condition|(
name|call_regno
operator|!=
name|regno
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
return|return
name|opcode
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Data structures used during relaxation.  */
end_comment

begin_comment
comment|/* r_reloc: relocation values.  */
end_comment

begin_comment
comment|/* Through the relaxation process, we need to keep track of the values    that will result from evaluating relocations.  The standard ELF    relocation structure is not sufficient for this purpose because we're    operating on multiple input files at once, so we need to know which    input file a relocation refers to.  The r_reloc structure thus    records both the input file (bfd) and ELF relocation.     For efficiency, an r_reloc also contains a "target_offset" field to    cache the target-section-relative offset value that is represented by    the relocation.        The r_reloc also contains a virtual offset that allows multiple    inserted literals to be placed at the same "address" with    different offsets.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|r_reloc_struct
name|r_reloc
typedef|;
end_typedef

begin_struct
struct|struct
name|r_reloc_struct
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|bfd_vma
name|target_offset
decl_stmt|;
name|bfd_vma
name|virtual_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The r_reloc structure is included by value in literal_value, but not    every literal_value has an associated relocation -- some are simple    constants.  In such cases, we set all the fields in the r_reloc    struct to zero.  The r_reloc_is_const function should be used to    detect this case.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|r_reloc_is_const
parameter_list|(
specifier|const
name|r_reloc
modifier|*
name|r_rel
parameter_list|)
block|{
return|return
operator|(
name|r_rel
operator|->
name|abfd
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|r_reloc_get_target_offset
parameter_list|(
specifier|const
name|r_reloc
modifier|*
name|r_rel
parameter_list|)
block|{
name|bfd_vma
name|target_offset
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|BFD_ASSERT
argument_list|(
operator|!
name|r_reloc_is_const
argument_list|(
name|r_rel
argument_list|)
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|r_rel
operator|->
name|rela
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|target_offset
operator|=
name|get_elf_r_symndx_offset
argument_list|(
name|r_rel
operator|->
name|abfd
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
return|return
operator|(
name|target_offset
operator|+
name|r_rel
operator|->
name|rela
operator|.
name|r_addend
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|elf_link_hash_entry
modifier|*
name|r_reloc_get_hash_entry
parameter_list|(
specifier|const
name|r_reloc
modifier|*
name|r_rel
parameter_list|)
block|{
name|unsigned
name|long
name|r_symndx
init|=
name|ELF32_R_SYM
argument_list|(
name|r_rel
operator|->
name|rela
operator|.
name|r_info
argument_list|)
decl_stmt|;
return|return
name|get_elf_r_symndx_hash_entry
argument_list|(
name|r_rel
operator|->
name|abfd
argument_list|,
name|r_symndx
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|r_reloc_get_section
parameter_list|(
specifier|const
name|r_reloc
modifier|*
name|r_rel
parameter_list|)
block|{
name|unsigned
name|long
name|r_symndx
init|=
name|ELF32_R_SYM
argument_list|(
name|r_rel
operator|->
name|rela
operator|.
name|r_info
argument_list|)
decl_stmt|;
return|return
name|get_elf_r_symndx_section
argument_list|(
name|r_rel
operator|->
name|abfd
argument_list|,
name|r_symndx
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|r_reloc_is_defined
parameter_list|(
specifier|const
name|r_reloc
modifier|*
name|r_rel
parameter_list|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
name|r_rel
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sec
operator|=
name|r_reloc_get_section
argument_list|(
name|r_rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|bfd_abs_section_ptr
operator|||
name|sec
operator|==
name|bfd_com_section_ptr
operator|||
name|sec
operator|==
name|bfd_und_section_ptr
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|r_reloc_init
parameter_list|(
name|r_reloc
modifier|*
name|r_rel
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|irel
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|bfd_size_type
name|content_length
parameter_list|)
block|{
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
if|if
condition|(
name|irel
condition|)
block|{
name|r_rel
operator|->
name|rela
operator|=
operator|*
name|irel
expr_stmt|;
name|r_rel
operator|->
name|abfd
operator|=
name|abfd
expr_stmt|;
name|r_rel
operator|->
name|target_offset
operator|=
name|r_reloc_get_target_offset
argument_list|(
name|r_rel
argument_list|)
expr_stmt|;
name|r_rel
operator|->
name|virtual_offset
operator|=
literal|0
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|r_rel
operator|->
name|rela
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|howto
operator|=
operator|&
name|elf_howto_table
index|[
name|r_type
index|]
expr_stmt|;
if|if
condition|(
name|howto
operator|->
name|partial_inplace
condition|)
block|{
name|bfd_vma
name|inplace_val
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|r_rel
operator|->
name|rela
operator|.
name|r_offset
operator|<
name|content_length
argument_list|)
expr_stmt|;
name|inplace_val
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|contents
index|[
name|r_rel
operator|->
name|rela
operator|.
name|r_offset
index|]
argument_list|)
expr_stmt|;
name|r_rel
operator|->
name|target_offset
operator|+=
name|inplace_val
expr_stmt|;
block|}
block|}
else|else
name|memset
argument_list|(
name|r_rel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|r_reloc
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|DEBUG
end_if

begin_function
specifier|static
name|void
name|print_r_reloc
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|r_reloc
modifier|*
name|r_rel
parameter_list|)
block|{
if|if
condition|(
name|r_reloc_is_defined
argument_list|(
name|r_rel
argument_list|)
condition|)
block|{
name|asection
modifier|*
name|sec
init|=
name|r_reloc_get_section
argument_list|(
name|r_rel
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %s(%s + "
argument_list|,
name|sec
operator|->
name|owner
operator|->
name|filename
argument_list|,
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_reloc_get_hash_entry
argument_list|(
name|r_rel
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %s + "
argument_list|,
name|r_reloc_get_hash_entry
argument_list|(
name|r_rel
argument_list|)
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" ?? + "
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|fp
argument_list|,
name|r_rel
operator|->
name|target_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_rel
operator|->
name|virtual_offset
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" + "
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|fp
argument_list|,
name|r_rel
operator|->
name|virtual_offset
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_escape
end_escape

begin_comment
comment|/* source_reloc: relocations that reference literals.  */
end_comment

begin_comment
comment|/* To determine whether literals can be coalesced, we need to first    record all the relocations that reference the literals.  The    source_reloc structure below is used for this purpose.  The    source_reloc entries are kept in a per-literal-section array, sorted    by offset within the literal section (i.e., target offset).     The source_sec and r_rel.rela.r_offset fields identify the source of    the relocation.  The r_rel field records the relocation value, i.e.,    the offset of the literal being referenced.  The opnd field is needed    to determine the range of the immediate field to which the relocation    applies, so we can determine whether another literal with the same    value is within range.  The is_null field is true when the relocation    is being removed (e.g., when an L32R is being removed due to a CALLX    that is converted to a direct CALL).  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|source_reloc_struct
name|source_reloc
typedef|;
end_typedef

begin_struct
struct|struct
name|source_reloc_struct
block|{
name|asection
modifier|*
name|source_sec
decl_stmt|;
name|r_reloc
name|r_rel
decl_stmt|;
name|xtensa_opcode
name|opcode
decl_stmt|;
name|int
name|opnd
decl_stmt|;
name|bfd_boolean
name|is_null
decl_stmt|;
name|bfd_boolean
name|is_abs_literal
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|init_source_reloc
parameter_list|(
name|source_reloc
modifier|*
name|reloc
parameter_list|,
name|asection
modifier|*
name|source_sec
parameter_list|,
specifier|const
name|r_reloc
modifier|*
name|r_rel
parameter_list|,
name|xtensa_opcode
name|opcode
parameter_list|,
name|int
name|opnd
parameter_list|,
name|bfd_boolean
name|is_abs_literal
parameter_list|)
block|{
name|reloc
operator|->
name|source_sec
operator|=
name|source_sec
expr_stmt|;
name|reloc
operator|->
name|r_rel
operator|=
operator|*
name|r_rel
expr_stmt|;
name|reloc
operator|->
name|opcode
operator|=
name|opcode
expr_stmt|;
name|reloc
operator|->
name|opnd
operator|=
name|opnd
expr_stmt|;
name|reloc
operator|->
name|is_null
operator|=
name|FALSE
expr_stmt|;
name|reloc
operator|->
name|is_abs_literal
operator|=
name|is_abs_literal
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the source_reloc for a particular source offset and relocation    type.  Note that the array is sorted by _target_ offset, so this is    just a linear search.  */
end_comment

begin_function
specifier|static
name|source_reloc
modifier|*
name|find_source_reloc
parameter_list|(
name|source_reloc
modifier|*
name|src_relocs
parameter_list|,
name|int
name|src_count
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|irel
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|src_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|src_relocs
index|[
name|i
index|]
operator|.
name|source_sec
operator|==
name|sec
operator|&&
name|src_relocs
index|[
name|i
index|]
operator|.
name|r_rel
operator|.
name|rela
operator|.
name|r_offset
operator|==
name|irel
operator|->
name|r_offset
operator|&&
operator|(
name|ELF32_R_TYPE
argument_list|(
name|src_relocs
index|[
name|i
index|]
operator|.
name|r_rel
operator|.
name|rela
operator|.
name|r_info
argument_list|)
operator|==
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|)
condition|)
return|return
operator|&
name|src_relocs
index|[
name|i
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|source_reloc_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|ap
parameter_list|,
specifier|const
name|void
modifier|*
name|bp
parameter_list|)
block|{
specifier|const
name|source_reloc
modifier|*
name|a
init|=
operator|(
specifier|const
name|source_reloc
operator|*
operator|)
name|ap
decl_stmt|;
specifier|const
name|source_reloc
modifier|*
name|b
init|=
operator|(
specifier|const
name|source_reloc
operator|*
operator|)
name|bp
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|r_rel
operator|.
name|target_offset
operator|!=
name|b
operator|->
name|r_rel
operator|.
name|target_offset
condition|)
return|return
operator|(
name|a
operator|->
name|r_rel
operator|.
name|target_offset
operator|-
name|b
operator|->
name|r_rel
operator|.
name|target_offset
operator|)
return|;
comment|/* We don't need to sort on these criteria for correctness,      but enforcing a more strict ordering prevents unstable qsort      from behaving differently with different implementations.      Without the code below we get correct but different results      on Solaris 2.7 and 2.8.  We would like to always produce the      same results no matter the host. */
if|if
condition|(
operator|(
operator|!
name|a
operator|->
name|is_null
operator|)
operator|-
operator|(
operator|!
name|b
operator|->
name|is_null
operator|)
condition|)
return|return
operator|(
operator|(
operator|!
name|a
operator|->
name|is_null
operator|)
operator|-
operator|(
operator|!
name|b
operator|->
name|is_null
operator|)
operator|)
return|;
return|return
name|internal_reloc_compare
argument_list|(
operator|&
name|a
operator|->
name|r_rel
operator|.
name|rela
argument_list|,
operator|&
name|b
operator|->
name|r_rel
operator|.
name|rela
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Literal values and value hash tables.  */
end_comment

begin_comment
comment|/* Literals with the same value can be coalesced.  The literal_value    structure records the value of a literal: the "r_rel" field holds the    information from the relocation on the literal (if there is one) and    the "value" field holds the contents of the literal word itself.     The value_map structure records a literal value along with the    location of a literal holding that value.  The value_map hash table    is indexed by the literal value, so that we can quickly check if a    particular literal value has been seen before and is thus a candidate    for coalescing.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|literal_value_struct
name|literal_value
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|value_map_struct
name|value_map
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|value_map_hash_table_struct
name|value_map_hash_table
typedef|;
end_typedef

begin_struct
struct|struct
name|literal_value_struct
block|{
name|r_reloc
name|r_rel
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
name|bfd_boolean
name|is_abs_literal
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|value_map_struct
block|{
name|literal_value
name|val
decl_stmt|;
comment|/* The literal value.  */
name|r_reloc
name|loc
decl_stmt|;
comment|/* Location of the literal.  */
name|value_map
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|value_map_hash_table_struct
block|{
name|unsigned
name|bucket_count
decl_stmt|;
name|value_map
modifier|*
modifier|*
name|buckets
decl_stmt|;
name|unsigned
name|count
decl_stmt|;
name|bfd_boolean
name|has_last_loc
decl_stmt|;
name|r_reloc
name|last_loc
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|init_literal_value
parameter_list|(
name|literal_value
modifier|*
name|lit
parameter_list|,
specifier|const
name|r_reloc
modifier|*
name|r_rel
parameter_list|,
name|unsigned
name|long
name|value
parameter_list|,
name|bfd_boolean
name|is_abs_literal
parameter_list|)
block|{
name|lit
operator|->
name|r_rel
operator|=
operator|*
name|r_rel
expr_stmt|;
name|lit
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|lit
operator|->
name|is_abs_literal
operator|=
name|is_abs_literal
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|literal_value_equal
parameter_list|(
specifier|const
name|literal_value
modifier|*
name|src1
parameter_list|,
specifier|const
name|literal_value
modifier|*
name|src2
parameter_list|,
name|bfd_boolean
name|final_static_link
parameter_list|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h1
decl_stmt|,
modifier|*
name|h2
decl_stmt|;
if|if
condition|(
name|r_reloc_is_const
argument_list|(
operator|&
name|src1
operator|->
name|r_rel
argument_list|)
operator|!=
name|r_reloc_is_const
argument_list|(
operator|&
name|src2
operator|->
name|r_rel
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|r_reloc_is_const
argument_list|(
operator|&
name|src1
operator|->
name|r_rel
argument_list|)
condition|)
return|return
operator|(
name|src1
operator|->
name|value
operator|==
name|src2
operator|->
name|value
operator|)
return|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|src1
operator|->
name|r_rel
operator|.
name|rela
operator|.
name|r_info
argument_list|)
operator|!=
name|ELF32_R_TYPE
argument_list|(
name|src2
operator|->
name|r_rel
operator|.
name|rela
operator|.
name|r_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|src1
operator|->
name|r_rel
operator|.
name|target_offset
operator|!=
name|src2
operator|->
name|r_rel
operator|.
name|target_offset
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|src1
operator|->
name|r_rel
operator|.
name|virtual_offset
operator|!=
name|src2
operator|->
name|r_rel
operator|.
name|virtual_offset
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|src1
operator|->
name|value
operator|!=
name|src2
operator|->
name|value
condition|)
return|return
name|FALSE
return|;
comment|/* Now check for the same section (if defined) or the same elf_hash      (if undefined or weak).  */
name|h1
operator|=
name|r_reloc_get_hash_entry
argument_list|(
operator|&
name|src1
operator|->
name|r_rel
argument_list|)
expr_stmt|;
name|h2
operator|=
name|r_reloc_get_hash_entry
argument_list|(
operator|&
name|src2
operator|->
name|r_rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_reloc_is_defined
argument_list|(
operator|&
name|src1
operator|->
name|r_rel
argument_list|)
operator|&&
operator|(
name|final_static_link
operator|||
operator|(
operator|(
operator|!
name|h1
operator|||
name|h1
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|(
operator|!
name|h2
operator|||
name|h2
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|r_reloc_get_section
argument_list|(
operator|&
name|src1
operator|->
name|r_rel
argument_list|)
operator|!=
name|r_reloc_get_section
argument_list|(
operator|&
name|src2
operator|->
name|r_rel
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
comment|/* Require that the hash entries (i.e., symbols) be identical.  */
if|if
condition|(
name|h1
operator|!=
name|h2
operator|||
name|h1
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|src1
operator|->
name|is_abs_literal
operator|!=
name|src2
operator|->
name|is_abs_literal
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Must be power of 2.  */
end_comment

begin_define
define|#
directive|define
name|INITIAL_HASH_RELOC_BUCKET_COUNT
value|1024
end_define

begin_function
specifier|static
name|value_map_hash_table
modifier|*
name|value_map_hash_table_init
parameter_list|(
name|void
parameter_list|)
block|{
name|value_map_hash_table
modifier|*
name|values
decl_stmt|;
name|values
operator|=
operator|(
name|value_map_hash_table
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|value_map_hash_table
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|->
name|bucket_count
operator|=
name|INITIAL_HASH_RELOC_BUCKET_COUNT
expr_stmt|;
name|values
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|values
operator|->
name|buckets
operator|=
operator|(
name|value_map
operator|*
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|value_map
operator|*
argument_list|)
operator|*
name|values
operator|->
name|bucket_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|values
operator|->
name|buckets
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|values
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|values
operator|->
name|has_last_loc
operator|=
name|FALSE
expr_stmt|;
return|return
name|values
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|value_map_hash_table_delete
parameter_list|(
name|value_map_hash_table
modifier|*
name|table
parameter_list|)
block|{
name|free
argument_list|(
name|table
operator|->
name|buckets
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|hash_bfd_vma
parameter_list|(
name|bfd_vma
name|val
parameter_list|)
block|{
return|return
operator|(
name|val
operator|>>
literal|2
operator|)
operator|+
operator|(
name|val
operator|>>
literal|10
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|literal_value_hash
parameter_list|(
specifier|const
name|literal_value
modifier|*
name|src
parameter_list|)
block|{
name|unsigned
name|hash_val
decl_stmt|;
name|hash_val
operator|=
name|hash_bfd_vma
argument_list|(
name|src
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r_reloc_is_const
argument_list|(
operator|&
name|src
operator|->
name|r_rel
argument_list|)
condition|)
block|{
name|void
modifier|*
name|sec_or_hash
decl_stmt|;
name|hash_val
operator|+=
name|hash_bfd_vma
argument_list|(
name|src
operator|->
name|is_abs_literal
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|hash_val
operator|+=
name|hash_bfd_vma
argument_list|(
name|src
operator|->
name|r_rel
operator|.
name|target_offset
argument_list|)
expr_stmt|;
name|hash_val
operator|+=
name|hash_bfd_vma
argument_list|(
name|src
operator|->
name|r_rel
operator|.
name|virtual_offset
argument_list|)
expr_stmt|;
comment|/* Now check for the same section and the same elf_hash.  */
if|if
condition|(
name|r_reloc_is_defined
argument_list|(
operator|&
name|src
operator|->
name|r_rel
argument_list|)
condition|)
name|sec_or_hash
operator|=
name|r_reloc_get_section
argument_list|(
operator|&
name|src
operator|->
name|r_rel
argument_list|)
expr_stmt|;
else|else
name|sec_or_hash
operator|=
name|r_reloc_get_hash_entry
argument_list|(
operator|&
name|src
operator|->
name|r_rel
argument_list|)
expr_stmt|;
name|hash_val
operator|+=
name|hash_bfd_vma
argument_list|(
operator|(
name|bfd_vma
operator|)
operator|(
name|size_t
operator|)
name|sec_or_hash
argument_list|)
expr_stmt|;
block|}
return|return
name|hash_val
return|;
block|}
end_function

begin_comment
comment|/* Check if the specified literal_value has been seen before.  */
end_comment

begin_function
specifier|static
name|value_map
modifier|*
name|value_map_get_cached_value
parameter_list|(
name|value_map_hash_table
modifier|*
name|map
parameter_list|,
specifier|const
name|literal_value
modifier|*
name|val
parameter_list|,
name|bfd_boolean
name|final_static_link
parameter_list|)
block|{
name|value_map
modifier|*
name|map_e
decl_stmt|;
name|value_map
modifier|*
name|bucket
decl_stmt|;
name|unsigned
name|idx
decl_stmt|;
name|idx
operator|=
name|literal_value_hash
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|idx
operator|=
name|idx
operator|&
operator|(
name|map
operator|->
name|bucket_count
operator|-
literal|1
operator|)
expr_stmt|;
name|bucket
operator|=
name|map
operator|->
name|buckets
index|[
name|idx
index|]
expr_stmt|;
for|for
control|(
name|map_e
operator|=
name|bucket
init|;
name|map_e
condition|;
name|map_e
operator|=
name|map_e
operator|->
name|next
control|)
block|{
if|if
condition|(
name|literal_value_equal
argument_list|(
operator|&
name|map_e
operator|->
name|val
argument_list|,
name|val
argument_list|,
name|final_static_link
argument_list|)
condition|)
return|return
name|map_e
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Record a new literal value.  It is illegal to call this if VALUE    already has an entry here.  */
end_comment

begin_function
specifier|static
name|value_map
modifier|*
name|add_value_map
parameter_list|(
name|value_map_hash_table
modifier|*
name|map
parameter_list|,
specifier|const
name|literal_value
modifier|*
name|val
parameter_list|,
specifier|const
name|r_reloc
modifier|*
name|loc
parameter_list|,
name|bfd_boolean
name|final_static_link
parameter_list|)
block|{
name|value_map
modifier|*
modifier|*
name|bucket_p
decl_stmt|;
name|unsigned
name|idx
decl_stmt|;
name|value_map
modifier|*
name|val_e
init|=
operator|(
name|value_map
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|value_map
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|val_e
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|BFD_ASSERT
argument_list|(
operator|!
name|value_map_get_cached_value
argument_list|(
name|map
argument_list|,
name|val
argument_list|,
name|final_static_link
argument_list|)
argument_list|)
expr_stmt|;
name|val_e
operator|->
name|val
operator|=
operator|*
name|val
expr_stmt|;
name|val_e
operator|->
name|loc
operator|=
operator|*
name|loc
expr_stmt|;
name|idx
operator|=
name|literal_value_hash
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|idx
operator|=
name|idx
operator|&
operator|(
name|map
operator|->
name|bucket_count
operator|-
literal|1
operator|)
expr_stmt|;
name|bucket_p
operator|=
operator|&
name|map
operator|->
name|buckets
index|[
name|idx
index|]
expr_stmt|;
name|val_e
operator|->
name|next
operator|=
operator|*
name|bucket_p
expr_stmt|;
operator|*
name|bucket_p
operator|=
name|val_e
expr_stmt|;
name|map
operator|->
name|count
operator|++
expr_stmt|;
comment|/* FIXME: Consider resizing the hash table if we get too many entries.  */
return|return
name|val_e
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Lists of text actions (ta_) for narrowing, widening, longcall    conversion, space fill, code& literal removal, etc.  */
end_comment

begin_comment
comment|/* The following text actions are generated:     "ta_remove_insn"         remove an instruction or instructions    "ta_remove_longcall"     convert longcall to call    "ta_convert_longcall"    convert longcall to nop/call    "ta_narrow_insn"         narrow a wide instruction    "ta_widen"               widen a narrow instruction    "ta_fill"                add fill or remove fill       removed< 0 is a fill; branches to the fill address will be 	changed to address + fill size (e.g., address - removed)       removed>= 0 branches to the fill address will stay unchanged    "ta_remove_literal"      remove a literal; this action is 			    indicated when a literal is removed                             or replaced.    "ta_add_literal"         insert a new literal; this action is                             indicated when a literal has been moved.                             It may use a virtual_offset because 			    multiple literals can be placed at the                             same location.     For each of these text actions, we also record the number of bytes    removed by performing the text action.  In the case of a "ta_widen"    or a "ta_fill" that adds space, the removed_bytes will be negative.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|text_action_struct
name|text_action
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|text_action_list_struct
name|text_action_list
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|enum
name|text_action_enum_t
name|text_action_t
typedef|;
end_typedef

begin_enum
enum|enum
name|text_action_enum_t
block|{
name|ta_none
block|,
name|ta_remove_insn
block|,
comment|/* removed = -size */
name|ta_remove_longcall
block|,
comment|/* removed = -size */
name|ta_convert_longcall
block|,
comment|/* removed = 0 */
name|ta_narrow_insn
block|,
comment|/* removed = -1 */
name|ta_widen_insn
block|,
comment|/* removed = +1 */
name|ta_fill
block|,
comment|/* removed = +size */
name|ta_remove_literal
block|,
name|ta_add_literal
block|}
enum|;
end_enum

begin_comment
comment|/* Structure for a text action record.  */
end_comment

begin_struct
struct|struct
name|text_action_struct
block|{
name|text_action_t
name|action
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* Optional */
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_vma
name|virtual_offset
decl_stmt|;
comment|/* Zero except for adding literals.  */
name|int
name|removed_bytes
decl_stmt|;
name|literal_value
name|value
decl_stmt|;
comment|/* Only valid when adding literals.  */
name|text_action
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* List of all of the actions taken on a text section.  */
end_comment

begin_struct
struct|struct
name|text_action_list_struct
block|{
name|text_action
modifier|*
name|head
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|text_action
modifier|*
name|find_fill_action
parameter_list|(
name|text_action_list
modifier|*
name|l
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|offset
parameter_list|)
block|{
name|text_action
modifier|*
modifier|*
name|m_p
decl_stmt|;
comment|/* It is not necessary to fill at the end of a section.  */
if|if
condition|(
name|sec
operator|->
name|size
operator|==
name|offset
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|m_p
operator|=
operator|&
name|l
operator|->
name|head
init|;
operator|*
name|m_p
operator|&&
operator|(
operator|*
name|m_p
operator|)
operator|->
name|offset
operator|<=
name|offset
condition|;
name|m_p
operator|=
operator|&
operator|(
operator|*
name|m_p
operator|)
operator|->
name|next
control|)
block|{
name|text_action
modifier|*
name|t
init|=
operator|*
name|m_p
decl_stmt|;
comment|/* When the action is another fill at the same address, 	 just increase the size.  */
if|if
condition|(
name|t
operator|->
name|offset
operator|==
name|offset
operator|&&
name|t
operator|->
name|action
operator|==
name|ta_fill
condition|)
return|return
name|t
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|compute_removed_action_diff
parameter_list|(
specifier|const
name|text_action
modifier|*
name|ta
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|int
name|removed
parameter_list|,
name|int
name|removable_space
parameter_list|)
block|{
name|int
name|new_removed
decl_stmt|;
name|int
name|current_removed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ta
condition|)
name|current_removed
operator|=
name|ta
operator|->
name|removed_bytes
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ta
operator|==
name|NULL
operator|||
name|ta
operator|->
name|offset
operator|==
name|offset
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ta
operator|==
name|NULL
operator|||
name|ta
operator|->
name|action
operator|==
name|ta_fill
argument_list|)
expr_stmt|;
comment|/* It is not necessary to fill at the end of a section.  Clean this up.  */
if|if
condition|(
name|sec
operator|->
name|size
operator|==
name|offset
condition|)
name|new_removed
operator|=
name|removable_space
operator|-
literal|0
expr_stmt|;
else|else
block|{
name|int
name|space
decl_stmt|;
name|int
name|added
init|=
operator|-
name|removed
operator|-
name|current_removed
decl_stmt|;
comment|/* Ignore multiples of the section alignment.  */
name|added
operator|=
operator|(
operator|(
literal|1
operator|<<
name|sec
operator|->
name|alignment_power
operator|)
operator|-
literal|1
operator|)
operator|&
name|added
expr_stmt|;
name|new_removed
operator|=
operator|(
operator|-
name|added
operator|)
expr_stmt|;
comment|/* Modify for removable.  */
name|space
operator|=
name|removable_space
operator|-
name|new_removed
expr_stmt|;
name|new_removed
operator|=
operator|(
name|removable_space
operator|-
operator|(
operator|(
operator|(
literal|1
operator|<<
name|sec
operator|->
name|alignment_power
operator|)
operator|-
literal|1
operator|)
operator|&
name|space
operator|)
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|new_removed
operator|-
name|current_removed
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|adjust_fill_action
parameter_list|(
name|text_action
modifier|*
name|ta
parameter_list|,
name|int
name|fill_diff
parameter_list|)
block|{
name|ta
operator|->
name|removed_bytes
operator|+=
name|fill_diff
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a modification action to the text.  For the case of adding or    removing space, modify any current fill and assume that    "unreachable_space" bytes can be freely contracted.  Note that a    negative removed value is a fill.  */
end_comment

begin_function
specifier|static
name|void
name|text_action_add
parameter_list|(
name|text_action_list
modifier|*
name|l
parameter_list|,
name|text_action_t
name|action
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|int
name|removed
parameter_list|)
block|{
name|text_action
modifier|*
modifier|*
name|m_p
decl_stmt|;
name|text_action
modifier|*
name|ta
decl_stmt|;
comment|/* It is not necessary to fill at the end of a section.  */
if|if
condition|(
name|action
operator|==
name|ta_fill
operator|&&
name|sec
operator|->
name|size
operator|==
name|offset
condition|)
return|return;
comment|/* It is not necessary to fill 0 bytes.  */
if|if
condition|(
name|action
operator|==
name|ta_fill
operator|&&
name|removed
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|m_p
operator|=
operator|&
name|l
operator|->
name|head
init|;
operator|*
name|m_p
operator|&&
operator|(
operator|*
name|m_p
operator|)
operator|->
name|offset
operator|<=
name|offset
condition|;
name|m_p
operator|=
operator|&
operator|(
operator|*
name|m_p
operator|)
operator|->
name|next
control|)
block|{
name|text_action
modifier|*
name|t
init|=
operator|*
name|m_p
decl_stmt|;
comment|/* When the action is another fill at the same address, 	 just increase the size.  */
if|if
condition|(
name|t
operator|->
name|offset
operator|==
name|offset
operator|&&
name|t
operator|->
name|action
operator|==
name|ta_fill
operator|&&
name|action
operator|==
name|ta_fill
condition|)
block|{
name|t
operator|->
name|removed_bytes
operator|+=
name|removed
expr_stmt|;
return|return;
block|}
block|}
comment|/* Create a new record and fill it up.  */
name|ta
operator|=
operator|(
name|text_action
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|text_action
argument_list|)
argument_list|)
expr_stmt|;
name|ta
operator|->
name|action
operator|=
name|action
expr_stmt|;
name|ta
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
name|ta
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|ta
operator|->
name|removed_bytes
operator|=
name|removed
expr_stmt|;
name|ta
operator|->
name|next
operator|=
operator|(
operator|*
name|m_p
operator|)
expr_stmt|;
operator|*
name|m_p
operator|=
name|ta
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|text_action_add_literal
parameter_list|(
name|text_action_list
modifier|*
name|l
parameter_list|,
name|text_action_t
name|action
parameter_list|,
specifier|const
name|r_reloc
modifier|*
name|loc
parameter_list|,
specifier|const
name|literal_value
modifier|*
name|value
parameter_list|,
name|int
name|removed
parameter_list|)
block|{
name|text_action
modifier|*
modifier|*
name|m_p
decl_stmt|;
name|text_action
modifier|*
name|ta
decl_stmt|;
name|asection
modifier|*
name|sec
init|=
name|r_reloc_get_section
argument_list|(
name|loc
argument_list|)
decl_stmt|;
name|bfd_vma
name|offset
init|=
name|loc
operator|->
name|target_offset
decl_stmt|;
name|bfd_vma
name|virtual_offset
init|=
name|loc
operator|->
name|virtual_offset
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|action
operator|==
name|ta_add_literal
argument_list|)
expr_stmt|;
for|for
control|(
name|m_p
operator|=
operator|&
name|l
operator|->
name|head
init|;
operator|*
name|m_p
operator|!=
name|NULL
condition|;
name|m_p
operator|=
operator|&
operator|(
operator|*
name|m_p
operator|)
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|m_p
operator|)
operator|->
name|offset
operator|>
name|offset
operator|&&
operator|(
operator|(
operator|*
name|m_p
operator|)
operator|->
name|offset
operator|!=
name|offset
operator|||
operator|(
operator|*
name|m_p
operator|)
operator|->
name|virtual_offset
operator|>
name|virtual_offset
operator|)
condition|)
break|break;
block|}
comment|/* Create a new record and fill it up.  */
name|ta
operator|=
operator|(
name|text_action
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|text_action
argument_list|)
argument_list|)
expr_stmt|;
name|ta
operator|->
name|action
operator|=
name|action
expr_stmt|;
name|ta
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
name|ta
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|ta
operator|->
name|virtual_offset
operator|=
name|virtual_offset
expr_stmt|;
name|ta
operator|->
name|value
operator|=
operator|*
name|value
expr_stmt|;
name|ta
operator|->
name|removed_bytes
operator|=
name|removed
expr_stmt|;
name|ta
operator|->
name|next
operator|=
operator|(
operator|*
name|m_p
operator|)
expr_stmt|;
operator|*
name|m_p
operator|=
name|ta
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|offset_with_removed_text
parameter_list|(
name|text_action_list
modifier|*
name|action_list
parameter_list|,
name|bfd_vma
name|offset
parameter_list|)
block|{
name|text_action
modifier|*
name|r
decl_stmt|;
name|int
name|removed
init|=
literal|0
decl_stmt|;
for|for
control|(
name|r
operator|=
name|action_list
operator|->
name|head
init|;
name|r
operator|&&
name|r
operator|->
name|offset
operator|<=
name|offset
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
if|if
condition|(
name|r
operator|->
name|offset
operator|<
name|offset
operator|||
operator|(
name|r
operator|->
name|action
operator|==
name|ta_fill
operator|&&
name|r
operator|->
name|removed_bytes
operator|<
literal|0
operator|)
condition|)
name|removed
operator|+=
name|r
operator|->
name|removed_bytes
expr_stmt|;
block|}
return|return
operator|(
name|offset
operator|-
name|removed
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|action_list_count
parameter_list|(
name|text_action_list
modifier|*
name|action_list
parameter_list|)
block|{
name|text_action
modifier|*
name|r
init|=
name|action_list
operator|->
name|head
decl_stmt|;
name|unsigned
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|r
operator|=
name|action_list
operator|->
name|head
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
name|count
operator|++
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|offset_with_removed_text_before_fill
parameter_list|(
name|text_action_list
modifier|*
name|action_list
parameter_list|,
name|bfd_vma
name|offset
parameter_list|)
block|{
name|text_action
modifier|*
name|r
decl_stmt|;
name|int
name|removed
init|=
literal|0
decl_stmt|;
for|for
control|(
name|r
operator|=
name|action_list
operator|->
name|head
init|;
name|r
operator|&&
name|r
operator|->
name|offset
operator|<
name|offset
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
name|removed
operator|+=
name|r
operator|->
name|removed_bytes
expr_stmt|;
return|return
operator|(
name|offset
operator|-
name|removed
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The find_insn_action routine will only find non-fill actions.  */
end_comment

begin_function
specifier|static
name|text_action
modifier|*
name|find_insn_action
parameter_list|(
name|text_action_list
modifier|*
name|action_list
parameter_list|,
name|bfd_vma
name|offset
parameter_list|)
block|{
name|text_action
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|action_list
operator|->
name|head
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
if|if
condition|(
name|t
operator|->
name|offset
operator|==
name|offset
condition|)
block|{
switch|switch
condition|(
name|t
operator|->
name|action
condition|)
block|{
case|case
name|ta_none
case|:
case|case
name|ta_fill
case|:
break|break;
case|case
name|ta_remove_insn
case|:
case|case
name|ta_remove_longcall
case|:
case|case
name|ta_convert_longcall
case|:
case|case
name|ta_narrow_insn
case|:
case|case
name|ta_widen_insn
case|:
return|return
name|t
return|;
case|case
name|ta_remove_literal
case|:
case|case
name|ta_add_literal
case|:
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_if
if|#
directive|if
name|DEBUG
end_if

begin_function
specifier|static
name|void
name|print_action_list
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|text_action_list
modifier|*
name|action_list
parameter_list|)
block|{
name|text_action
modifier|*
name|r
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Text Action\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|action_list
operator|->
name|head
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|t
init|=
literal|"unknown"
decl_stmt|;
switch|switch
condition|(
name|r
operator|->
name|action
condition|)
block|{
case|case
name|ta_remove_insn
case|:
name|t
operator|=
literal|"remove_insn"
expr_stmt|;
break|break;
case|case
name|ta_remove_longcall
case|:
name|t
operator|=
literal|"remove_longcall"
expr_stmt|;
break|break;
case|case
name|ta_convert_longcall
case|:
name|t
operator|=
literal|"remove_longcall"
expr_stmt|;
break|break;
case|case
name|ta_narrow_insn
case|:
name|t
operator|=
literal|"narrow_insn"
expr_stmt|;
break|break;
case|case
name|ta_widen_insn
case|:
name|t
operator|=
literal|"widen_insn"
expr_stmt|;
break|break;
case|case
name|ta_fill
case|:
name|t
operator|=
literal|"fill"
expr_stmt|;
break|break;
case|case
name|ta_none
case|:
name|t
operator|=
literal|"none"
expr_stmt|;
break|break;
case|case
name|ta_remove_literal
case|:
name|t
operator|=
literal|"remove_literal"
expr_stmt|;
break|break;
case|case
name|ta_add_literal
case|:
name|t
operator|=
literal|"add_literal"
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s: %s[0x%lx] \"%s\" %d\n"
argument_list|,
name|r
operator|->
name|sec
operator|->
name|owner
operator|->
name|filename
argument_list|,
name|r
operator|->
name|sec
operator|->
name|name
argument_list|,
name|r
operator|->
name|offset
argument_list|,
name|t
argument_list|,
name|r
operator|->
name|removed_bytes
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Lists of literals being coalesced or removed.  */
end_comment

begin_comment
comment|/* In the usual case, the literal identified by "from" is being    coalesced with another literal identified by "to".  If the literal is    unused and is being removed altogether, "to.abfd" will be NULL.    The removed_literal entries are kept on a per-section list, sorted    by the "from" offset field.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|removed_literal_struct
name|removed_literal
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|removed_literal_list_struct
name|removed_literal_list
typedef|;
end_typedef

begin_struct
struct|struct
name|removed_literal_struct
block|{
name|r_reloc
name|from
decl_stmt|;
name|r_reloc
name|to
decl_stmt|;
name|removed_literal
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|removed_literal_list_struct
block|{
name|removed_literal
modifier|*
name|head
decl_stmt|;
name|removed_literal
modifier|*
name|tail
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Record that the literal at "from" is being removed.  If "to" is not    NULL, the "from" literal is being coalesced with the "to" literal.  */
end_comment

begin_function
specifier|static
name|void
name|add_removed_literal
parameter_list|(
name|removed_literal_list
modifier|*
name|removed_list
parameter_list|,
specifier|const
name|r_reloc
modifier|*
name|from
parameter_list|,
specifier|const
name|r_reloc
modifier|*
name|to
parameter_list|)
block|{
name|removed_literal
modifier|*
name|r
decl_stmt|,
modifier|*
name|new_r
decl_stmt|,
modifier|*
name|next_r
decl_stmt|;
name|new_r
operator|=
operator|(
name|removed_literal
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|removed_literal
argument_list|)
argument_list|)
expr_stmt|;
name|new_r
operator|->
name|from
operator|=
operator|*
name|from
expr_stmt|;
if|if
condition|(
name|to
condition|)
name|new_r
operator|->
name|to
operator|=
operator|*
name|to
expr_stmt|;
else|else
name|new_r
operator|->
name|to
operator|.
name|abfd
operator|=
name|NULL
expr_stmt|;
name|new_r
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|r
operator|=
name|removed_list
operator|->
name|head
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|removed_list
operator|->
name|head
operator|=
name|new_r
expr_stmt|;
name|removed_list
operator|->
name|tail
operator|=
name|new_r
expr_stmt|;
block|}
comment|/* Special check for common case of append.  */
elseif|else
if|if
condition|(
name|removed_list
operator|->
name|tail
operator|->
name|from
operator|.
name|target_offset
operator|<
name|from
operator|->
name|target_offset
condition|)
block|{
name|removed_list
operator|->
name|tail
operator|->
name|next
operator|=
name|new_r
expr_stmt|;
name|removed_list
operator|->
name|tail
operator|=
name|new_r
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|r
operator|->
name|from
operator|.
name|target_offset
operator|<
name|from
operator|->
name|target_offset
operator|&&
name|r
operator|->
name|next
condition|)
block|{
name|r
operator|=
name|r
operator|->
name|next
expr_stmt|;
block|}
name|next_r
operator|=
name|r
operator|->
name|next
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|new_r
expr_stmt|;
name|new_r
operator|->
name|next
operator|=
name|next_r
expr_stmt|;
if|if
condition|(
name|next_r
operator|==
name|NULL
condition|)
name|removed_list
operator|->
name|tail
operator|=
name|new_r
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check if the list of removed literals contains an entry for the    given address.  Return the entry if found.  */
end_comment

begin_function
specifier|static
name|removed_literal
modifier|*
name|find_removed_literal
parameter_list|(
name|removed_literal_list
modifier|*
name|removed_list
parameter_list|,
name|bfd_vma
name|addr
parameter_list|)
block|{
name|removed_literal
modifier|*
name|r
init|=
name|removed_list
operator|->
name|head
decl_stmt|;
while|while
condition|(
name|r
operator|&&
name|r
operator|->
name|from
operator|.
name|target_offset
operator|<
name|addr
condition|)
name|r
operator|=
name|r
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|r
operator|&&
name|r
operator|->
name|from
operator|.
name|target_offset
operator|==
name|addr
condition|)
return|return
name|r
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_if
if|#
directive|if
name|DEBUG
end_if

begin_function
specifier|static
name|void
name|print_removed_literals
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|removed_literal_list
modifier|*
name|removed_list
parameter_list|)
block|{
name|removed_literal
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|removed_list
operator|->
name|head
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Removed Literals\n"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
name|print_r_reloc
argument_list|(
name|fp
argument_list|,
operator|&
name|r
operator|->
name|from
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" => "
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|to
operator|.
name|abfd
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"REMOVED"
argument_list|)
expr_stmt|;
else|else
name|print_r_reloc
argument_list|(
name|fp
argument_list|,
operator|&
name|r
operator|->
name|to
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Per-section data for relaxation.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|reloc_bfd_fix_struct
name|reloc_bfd_fix
typedef|;
end_typedef

begin_struct
struct|struct
name|xtensa_relax_info_struct
block|{
name|bfd_boolean
name|is_relaxable_literal_section
decl_stmt|;
name|bfd_boolean
name|is_relaxable_asm_section
decl_stmt|;
name|int
name|visited
decl_stmt|;
comment|/* Number of times visited.  */
name|source_reloc
modifier|*
name|src_relocs
decl_stmt|;
comment|/* Array[src_count].  */
name|int
name|src_count
decl_stmt|;
name|int
name|src_next
decl_stmt|;
comment|/* Next src_relocs entry to assign.  */
name|removed_literal_list
name|removed_list
decl_stmt|;
name|text_action_list
name|action_list
decl_stmt|;
name|reloc_bfd_fix
modifier|*
name|fix_list
decl_stmt|;
name|reloc_bfd_fix
modifier|*
name|fix_array
decl_stmt|;
name|unsigned
name|fix_array_count
decl_stmt|;
comment|/* Support for expanding the reloc array that is stored      in the section structure.  If the relocations have been      reallocated, the newly allocated relocations will be referenced      here along with the actual size allocated.  The relocation      count will always be found in the section structure.  */
name|Elf_Internal_Rela
modifier|*
name|allocated_relocs
decl_stmt|;
name|unsigned
name|relocs_count
decl_stmt|;
name|unsigned
name|allocated_relocs_count
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|elf_xtensa_section_data
block|{
name|struct
name|bfd_elf_section_data
name|elf
decl_stmt|;
name|xtensa_relax_info
name|relax_info
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_new_section_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
name|struct
name|elf_xtensa_section_data
modifier|*
name|sdata
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
operator|*
name|sdata
argument_list|)
decl_stmt|;
name|sdata
operator|=
operator|(
expr|struct
name|elf_xtensa_section_data
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdata
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sec
operator|->
name|used_by_bfd
operator|=
operator|(
name|void
operator|*
operator|)
name|sdata
expr_stmt|;
return|return
name|_bfd_elf_new_section_hook
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|xtensa_relax_info
modifier|*
name|get_xtensa_relax_info
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|)
block|{
name|struct
name|elf_xtensa_section_data
modifier|*
name|section_data
decl_stmt|;
comment|/* No info available if no section or if it is an output section.  */
if|if
condition|(
operator|!
name|sec
operator|||
name|sec
operator|==
name|sec
operator|->
name|output_section
condition|)
return|return
name|NULL
return|;
name|section_data
operator|=
operator|(
expr|struct
name|elf_xtensa_section_data
operator|*
operator|)
name|elf_section_data
argument_list|(
name|sec
argument_list|)
expr_stmt|;
return|return
operator|&
name|section_data
operator|->
name|relax_info
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_xtensa_relax_info
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|)
block|{
name|xtensa_relax_info
modifier|*
name|relax_info
init|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|relax_info
operator|->
name|is_relaxable_literal_section
operator|=
name|FALSE
expr_stmt|;
name|relax_info
operator|->
name|is_relaxable_asm_section
operator|=
name|FALSE
expr_stmt|;
name|relax_info
operator|->
name|visited
operator|=
literal|0
expr_stmt|;
name|relax_info
operator|->
name|src_relocs
operator|=
name|NULL
expr_stmt|;
name|relax_info
operator|->
name|src_count
operator|=
literal|0
expr_stmt|;
name|relax_info
operator|->
name|src_next
operator|=
literal|0
expr_stmt|;
name|relax_info
operator|->
name|removed_list
operator|.
name|head
operator|=
name|NULL
expr_stmt|;
name|relax_info
operator|->
name|removed_list
operator|.
name|tail
operator|=
name|NULL
expr_stmt|;
name|relax_info
operator|->
name|action_list
operator|.
name|head
operator|=
name|NULL
expr_stmt|;
name|relax_info
operator|->
name|fix_list
operator|=
name|NULL
expr_stmt|;
name|relax_info
operator|->
name|fix_array
operator|=
name|NULL
expr_stmt|;
name|relax_info
operator|->
name|fix_array_count
operator|=
literal|0
expr_stmt|;
name|relax_info
operator|->
name|allocated_relocs
operator|=
name|NULL
expr_stmt|;
name|relax_info
operator|->
name|relocs_count
operator|=
literal|0
expr_stmt|;
name|relax_info
operator|->
name|allocated_relocs_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Coalescing literals may require a relocation to refer to a section in    a different input file, but the standard relocation information    cannot express that.  Instead, the reloc_bfd_fix structures are used    to "fix" the relocations that refer to sections in other input files.    These structures are kept on per-section lists.  The "src_type" field    records the relocation type in case there are multiple relocations on    the same location.  FIXME: This is ugly; an alternative might be to    add new symbols with the "owner" field to some other input file.  */
end_comment

begin_struct
struct|struct
name|reloc_bfd_fix_struct
block|{
name|asection
modifier|*
name|src_sec
decl_stmt|;
name|bfd_vma
name|src_offset
decl_stmt|;
name|unsigned
name|src_type
decl_stmt|;
comment|/* Relocation type.  */
name|bfd
modifier|*
name|target_abfd
decl_stmt|;
name|asection
modifier|*
name|target_sec
decl_stmt|;
name|bfd_vma
name|target_offset
decl_stmt|;
name|bfd_boolean
name|translated
decl_stmt|;
name|reloc_bfd_fix
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|reloc_bfd_fix
modifier|*
name|reloc_bfd_fix_init
parameter_list|(
name|asection
modifier|*
name|src_sec
parameter_list|,
name|bfd_vma
name|src_offset
parameter_list|,
name|unsigned
name|src_type
parameter_list|,
name|bfd
modifier|*
name|target_abfd
parameter_list|,
name|asection
modifier|*
name|target_sec
parameter_list|,
name|bfd_vma
name|target_offset
parameter_list|,
name|bfd_boolean
name|translated
parameter_list|)
block|{
name|reloc_bfd_fix
modifier|*
name|fix
decl_stmt|;
name|fix
operator|=
operator|(
name|reloc_bfd_fix
operator|*
operator|)
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|reloc_bfd_fix
argument_list|)
argument_list|)
expr_stmt|;
name|fix
operator|->
name|src_sec
operator|=
name|src_sec
expr_stmt|;
name|fix
operator|->
name|src_offset
operator|=
name|src_offset
expr_stmt|;
name|fix
operator|->
name|src_type
operator|=
name|src_type
expr_stmt|;
name|fix
operator|->
name|target_abfd
operator|=
name|target_abfd
expr_stmt|;
name|fix
operator|->
name|target_sec
operator|=
name|target_sec
expr_stmt|;
name|fix
operator|->
name|target_offset
operator|=
name|target_offset
expr_stmt|;
name|fix
operator|->
name|translated
operator|=
name|translated
expr_stmt|;
return|return
name|fix
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_fix
parameter_list|(
name|asection
modifier|*
name|src_sec
parameter_list|,
name|reloc_bfd_fix
modifier|*
name|fix
parameter_list|)
block|{
name|xtensa_relax_info
modifier|*
name|relax_info
decl_stmt|;
name|relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|src_sec
argument_list|)
expr_stmt|;
name|fix
operator|->
name|next
operator|=
name|relax_info
operator|->
name|fix_list
expr_stmt|;
name|relax_info
operator|->
name|fix_list
operator|=
name|fix
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fix_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|ap
parameter_list|,
specifier|const
name|void
modifier|*
name|bp
parameter_list|)
block|{
specifier|const
name|reloc_bfd_fix
modifier|*
name|a
init|=
operator|(
specifier|const
name|reloc_bfd_fix
operator|*
operator|)
name|ap
decl_stmt|;
specifier|const
name|reloc_bfd_fix
modifier|*
name|b
init|=
operator|(
specifier|const
name|reloc_bfd_fix
operator|*
operator|)
name|bp
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|src_offset
operator|!=
name|b
operator|->
name|src_offset
condition|)
return|return
operator|(
name|a
operator|->
name|src_offset
operator|-
name|b
operator|->
name|src_offset
operator|)
return|;
return|return
operator|(
name|a
operator|->
name|src_type
operator|-
name|b
operator|->
name|src_type
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cache_fix_array
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|reloc_bfd_fix
modifier|*
name|r
decl_stmt|;
name|xtensa_relax_info
modifier|*
name|relax_info
init|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
if|if
condition|(
name|relax_info
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|relax_info
operator|->
name|fix_list
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|r
operator|=
name|relax_info
operator|->
name|fix_list
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
name|count
operator|++
expr_stmt|;
name|relax_info
operator|->
name|fix_array
operator|=
operator|(
name|reloc_bfd_fix
operator|*
operator|)
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|reloc_bfd_fix
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
name|relax_info
operator|->
name|fix_array_count
operator|=
name|count
expr_stmt|;
name|r
operator|=
name|relax_info
operator|->
name|fix_list
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
name|relax_info
operator|->
name|fix_array
index|[
name|count
operator|-
literal|1
operator|-
name|i
index|]
operator|=
operator|*
name|r
expr_stmt|;
name|relax_info
operator|->
name|fix_array
index|[
name|count
operator|-
literal|1
operator|-
name|i
index|]
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
block|}
name|qsort
argument_list|(
name|relax_info
operator|->
name|fix_array
argument_list|,
name|relax_info
operator|->
name|fix_array_count
argument_list|,
sizeof|sizeof
argument_list|(
name|reloc_bfd_fix
argument_list|)
argument_list|,
name|fix_compare
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|reloc_bfd_fix
modifier|*
name|get_bfd_fix
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|unsigned
name|type
parameter_list|)
block|{
name|xtensa_relax_info
modifier|*
name|relax_info
init|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|reloc_bfd_fix
modifier|*
name|rv
decl_stmt|;
name|reloc_bfd_fix
name|key
decl_stmt|;
if|if
condition|(
name|relax_info
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|relax_info
operator|->
name|fix_list
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|relax_info
operator|->
name|fix_array
operator|==
name|NULL
condition|)
name|cache_fix_array
argument_list|(
name|sec
argument_list|)
expr_stmt|;
name|key
operator|.
name|src_offset
operator|=
name|offset
expr_stmt|;
name|key
operator|.
name|src_type
operator|=
name|type
expr_stmt|;
name|rv
operator|=
name|bsearch
argument_list|(
operator|&
name|key
argument_list|,
name|relax_info
operator|->
name|fix_array
argument_list|,
name|relax_info
operator|->
name|fix_array_count
argument_list|,
sizeof|sizeof
argument_list|(
name|reloc_bfd_fix
argument_list|)
argument_list|,
name|fix_compare
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Section caching.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|section_cache_struct
name|section_cache_t
typedef|;
end_typedef

begin_struct
struct|struct
name|section_cache_struct
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
comment|/* Cache of the section contents.  */
name|bfd_size_type
name|content_length
decl_stmt|;
name|property_table_entry
modifier|*
name|ptbl
decl_stmt|;
comment|/* Cache of the section property table.  */
name|unsigned
name|pte_count
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
comment|/* Cache of the section relocations.  */
name|unsigned
name|reloc_count
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|init_section_cache
parameter_list|(
name|section_cache_t
modifier|*
name|sec_cache
parameter_list|)
block|{
name|memset
argument_list|(
name|sec_cache
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sec_cache
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_section_cache
parameter_list|(
name|section_cache_t
modifier|*
name|sec_cache
parameter_list|)
block|{
if|if
condition|(
name|sec_cache
operator|->
name|sec
condition|)
block|{
name|release_contents
argument_list|(
name|sec_cache
operator|->
name|sec
argument_list|,
name|sec_cache
operator|->
name|contents
argument_list|)
expr_stmt|;
name|release_internal_relocs
argument_list|(
name|sec_cache
operator|->
name|sec
argument_list|,
name|sec_cache
operator|->
name|relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec_cache
operator|->
name|ptbl
condition|)
name|free
argument_list|(
name|sec_cache
operator|->
name|ptbl
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sec_cache
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sec_cache
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|section_cache_section
parameter_list|(
name|section_cache_t
modifier|*
name|sec_cache
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|property_table_entry
modifier|*
name|prop_table
init|=
name|NULL
decl_stmt|;
name|int
name|ptblsize
init|=
literal|0
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|sec_size
decl_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|sec
operator|==
name|sec_cache
operator|->
name|sec
condition|)
return|return
name|TRUE
return|;
name|abfd
operator|=
name|sec
operator|->
name|owner
expr_stmt|;
name|sec_size
operator|=
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
comment|/* Get the contents.  */
name|contents
operator|=
name|retrieve_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
operator|&&
name|sec_size
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
comment|/* Get the relocations.  */
name|internal_relocs
operator|=
name|retrieve_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
comment|/* Get the entry table.  */
name|ptblsize
operator|=
name|xtensa_read_table_entries
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|&
name|prop_table
argument_list|,
name|XTENSA_PROP_SEC_NAME
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptblsize
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
comment|/* Fill in the new section cache.  */
name|clear_section_cache
argument_list|(
name|sec_cache
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sec_cache
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sec_cache
argument_list|)
argument_list|)
expr_stmt|;
name|sec_cache
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
name|sec_cache
operator|->
name|contents
operator|=
name|contents
expr_stmt|;
name|sec_cache
operator|->
name|content_length
operator|=
name|sec_size
expr_stmt|;
name|sec_cache
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|sec_cache
operator|->
name|reloc_count
operator|=
name|sec
operator|->
name|reloc_count
expr_stmt|;
name|sec_cache
operator|->
name|pte_count
operator|=
name|ptblsize
expr_stmt|;
name|sec_cache
operator|->
name|ptbl
operator|=
name|prop_table
expr_stmt|;
return|return
name|TRUE
return|;
name|err
label|:
name|release_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|release_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_table
condition|)
name|free
argument_list|(
name|prop_table
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Extended basic blocks.  */
end_comment

begin_comment
comment|/* An ebb_struct represents an Extended Basic Block.  Within this    range, we guarantee that all instructions are decodable, the    property table entries are contiguous, and no property table    specifies a segment that cannot have instructions moved.  This    structure contains caches of the contents, property table and    relocations for the specified section for easy use.  The range is    specified by ranges of indices for the byte offset, property table    offsets and relocation offsets.  These must be consistent.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|ebb_struct
name|ebb_t
typedef|;
end_typedef

begin_struct
struct|struct
name|ebb_struct
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
comment|/* Cache of the section contents.  */
name|bfd_size_type
name|content_length
decl_stmt|;
name|property_table_entry
modifier|*
name|ptbl
decl_stmt|;
comment|/* Cache of the section property table.  */
name|unsigned
name|pte_count
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
comment|/* Cache of the section relocations.  */
name|unsigned
name|reloc_count
decl_stmt|;
name|bfd_vma
name|start_offset
decl_stmt|;
comment|/* Offset in section.  */
name|unsigned
name|start_ptbl_idx
decl_stmt|;
comment|/* Offset in the property table.  */
name|unsigned
name|start_reloc_idx
decl_stmt|;
comment|/* Offset in the relocations.  */
name|bfd_vma
name|end_offset
decl_stmt|;
name|unsigned
name|end_ptbl_idx
decl_stmt|;
name|unsigned
name|end_reloc_idx
decl_stmt|;
name|bfd_boolean
name|ends_section
decl_stmt|;
comment|/* Is this the last ebb in a section?  */
comment|/* The unreachable property table at the end of this set of blocks;      NULL if the end is not an unreachable block.  */
name|property_table_entry
modifier|*
name|ends_unreachable
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ebb_target_enum
block|{
name|EBB_NO_ALIGN
init|=
literal|0
block|,
name|EBB_DESIRE_TGT_ALIGN
block|,
name|EBB_REQUIRE_TGT_ALIGN
block|,
name|EBB_REQUIRE_LOOP_ALIGN
block|,
name|EBB_REQUIRE_ALIGN
block|}
enum|;
end_enum

begin_comment
comment|/* proposed_action_struct is similar to the text_action_struct except    that is represents a potential transformation, not one that will    occur.  We build a list of these for an extended basic block    and use them to compute the actual actions desired.  We must be    careful that the entire set of actual actions we perform do not    break any relocations that would fit if the actions were not    performed.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|proposed_action_struct
name|proposed_action
typedef|;
end_typedef

begin_struct
struct|struct
name|proposed_action_struct
block|{
name|enum
name|ebb_target_enum
name|align_type
decl_stmt|;
comment|/* for the target alignment */
name|bfd_vma
name|alignment_pow
decl_stmt|;
name|text_action_t
name|action
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|int
name|removed_bytes
decl_stmt|;
name|bfd_boolean
name|do_action
decl_stmt|;
comment|/* If false, then we will not perform the action.  */
block|}
struct|;
end_struct

begin_comment
comment|/* The ebb_constraint_struct keeps a set of proposed actions for an    extended basic block.   */
end_comment

begin_typedef
typedef|typedef
name|struct
name|ebb_constraint_struct
name|ebb_constraint
typedef|;
end_typedef

begin_struct
struct|struct
name|ebb_constraint_struct
block|{
name|ebb_t
name|ebb
decl_stmt|;
name|bfd_boolean
name|start_movable
decl_stmt|;
comment|/* Bytes of extra space at the beginning if movable.  */
name|int
name|start_extra_space
decl_stmt|;
name|enum
name|ebb_target_enum
name|start_align
decl_stmt|;
name|bfd_boolean
name|end_movable
decl_stmt|;
comment|/* Bytes of extra space at the end if movable.  */
name|int
name|end_extra_space
decl_stmt|;
name|unsigned
name|action_count
decl_stmt|;
name|unsigned
name|action_allocated
decl_stmt|;
comment|/* Array of proposed actions.  */
name|proposed_action
modifier|*
name|actions
decl_stmt|;
comment|/* Action alignments -- one for each proposed action.  */
name|enum
name|ebb_target_enum
modifier|*
name|action_aligns
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|init_ebb_constraint
parameter_list|(
name|ebb_constraint
modifier|*
name|c
parameter_list|)
block|{
name|memset
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ebb_constraint
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_ebb_constraint
parameter_list|(
name|ebb_constraint
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|actions
condition|)
name|free
argument_list|(
name|c
operator|->
name|actions
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_ebb
parameter_list|(
name|ebb_t
modifier|*
name|ebb
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|bfd_size_type
name|content_length
parameter_list|,
name|property_table_entry
modifier|*
name|prop_table
parameter_list|,
name|unsigned
name|ptblsize
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
parameter_list|,
name|unsigned
name|reloc_count
parameter_list|)
block|{
name|memset
argument_list|(
name|ebb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ebb_t
argument_list|)
argument_list|)
expr_stmt|;
name|ebb
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
name|ebb
operator|->
name|contents
operator|=
name|contents
expr_stmt|;
name|ebb
operator|->
name|content_length
operator|=
name|content_length
expr_stmt|;
name|ebb
operator|->
name|ptbl
operator|=
name|prop_table
expr_stmt|;
name|ebb
operator|->
name|pte_count
operator|=
name|ptblsize
expr_stmt|;
name|ebb
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|ebb
operator|->
name|reloc_count
operator|=
name|reloc_count
expr_stmt|;
name|ebb
operator|->
name|start_offset
operator|=
literal|0
expr_stmt|;
name|ebb
operator|->
name|end_offset
operator|=
name|ebb
operator|->
name|content_length
operator|-
literal|1
expr_stmt|;
name|ebb
operator|->
name|start_ptbl_idx
operator|=
literal|0
expr_stmt|;
name|ebb
operator|->
name|end_ptbl_idx
operator|=
name|ptblsize
expr_stmt|;
name|ebb
operator|->
name|start_reloc_idx
operator|=
literal|0
expr_stmt|;
name|ebb
operator|->
name|end_reloc_idx
operator|=
name|reloc_count
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extend the ebb to all decodable contiguous sections.  The algorithm    for building a basic block around an instruction is to push it    forward until we hit the end of a section, an unreachable block or    a block that cannot be transformed.  Then we push it backwards    searching for similar conditions.  */
end_comment

begin_function_decl
specifier|static
name|bfd_boolean
name|extend_ebb_bounds_forward
parameter_list|(
name|ebb_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|extend_ebb_bounds_backward
parameter_list|(
name|ebb_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_size_type
name|insn_block_decodable_len
parameter_list|(
name|bfd_byte
modifier|*
parameter_list|,
name|bfd_size_type
parameter_list|,
name|bfd_vma
parameter_list|,
name|bfd_size_type
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|bfd_boolean
name|extend_ebb_bounds
parameter_list|(
name|ebb_t
modifier|*
name|ebb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|extend_ebb_bounds_forward
argument_list|(
name|ebb
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|extend_ebb_bounds_backward
argument_list|(
name|ebb
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|extend_ebb_bounds_forward
parameter_list|(
name|ebb_t
modifier|*
name|ebb
parameter_list|)
block|{
name|property_table_entry
modifier|*
name|the_entry
decl_stmt|,
modifier|*
name|new_entry
decl_stmt|;
name|the_entry
operator|=
operator|&
name|ebb
operator|->
name|ptbl
index|[
name|ebb
operator|->
name|end_ptbl_idx
index|]
expr_stmt|;
comment|/* Stop when (1) we cannot decode an instruction, (2) we are at      the end of the property tables, (3) we hit a non-contiguous property      table entry, (4) we hit a NO_TRANSFORM region.  */
while|while
condition|(
literal|1
condition|)
block|{
name|bfd_vma
name|entry_end
decl_stmt|;
name|bfd_size_type
name|insn_block_len
decl_stmt|;
name|entry_end
operator|=
name|the_entry
operator|->
name|address
operator|-
name|ebb
operator|->
name|sec
operator|->
name|vma
operator|+
name|the_entry
operator|->
name|size
expr_stmt|;
name|insn_block_len
operator|=
name|insn_block_decodable_len
argument_list|(
name|ebb
operator|->
name|contents
argument_list|,
name|ebb
operator|->
name|content_length
argument_list|,
name|ebb
operator|->
name|end_offset
argument_list|,
name|entry_end
operator|-
name|ebb
operator|->
name|end_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_block_len
operator|!=
operator|(
name|entry_end
operator|-
name|ebb
operator|->
name|end_offset
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): could not decode instruction; possible configuration mismatch"
argument_list|)
argument_list|,
name|ebb
operator|->
name|sec
operator|->
name|owner
argument_list|,
name|ebb
operator|->
name|sec
argument_list|,
name|ebb
operator|->
name|end_offset
operator|+
name|insn_block_len
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ebb
operator|->
name|end_offset
operator|+=
name|insn_block_len
expr_stmt|;
if|if
condition|(
name|ebb
operator|->
name|end_offset
operator|==
name|ebb
operator|->
name|sec
operator|->
name|size
condition|)
name|ebb
operator|->
name|ends_section
operator|=
name|TRUE
expr_stmt|;
comment|/* Update the reloc counter.  */
while|while
condition|(
name|ebb
operator|->
name|end_reloc_idx
operator|+
literal|1
operator|<
name|ebb
operator|->
name|reloc_count
operator|&&
operator|(
name|ebb
operator|->
name|relocs
index|[
name|ebb
operator|->
name|end_reloc_idx
operator|+
literal|1
index|]
operator|.
name|r_offset
operator|<
name|ebb
operator|->
name|end_offset
operator|)
condition|)
block|{
name|ebb
operator|->
name|end_reloc_idx
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ebb
operator|->
name|end_ptbl_idx
operator|+
literal|1
operator|==
name|ebb
operator|->
name|pte_count
condition|)
return|return
name|TRUE
return|;
name|new_entry
operator|=
operator|&
name|ebb
operator|->
name|ptbl
index|[
name|ebb
operator|->
name|end_ptbl_idx
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|new_entry
operator|->
name|flags
operator|&
name|XTENSA_PROP_INSN
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|new_entry
operator|->
name|flags
operator|&
name|XTENSA_PROP_INSN_NO_TRANSFORM
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|the_entry
operator|->
name|flags
operator|&
name|XTENSA_PROP_ALIGN
operator|)
operator|!=
literal|0
operator|)
condition|)
break|break;
if|if
condition|(
name|the_entry
operator|->
name|address
operator|+
name|the_entry
operator|->
name|size
operator|!=
name|new_entry
operator|->
name|address
condition|)
break|break;
name|the_entry
operator|=
name|new_entry
expr_stmt|;
name|ebb
operator|->
name|end_ptbl_idx
operator|++
expr_stmt|;
block|}
comment|/* Quick check for an unreachable or end of file just at the end.  */
if|if
condition|(
name|ebb
operator|->
name|end_ptbl_idx
operator|+
literal|1
operator|==
name|ebb
operator|->
name|pte_count
condition|)
block|{
if|if
condition|(
name|ebb
operator|->
name|end_offset
operator|==
name|ebb
operator|->
name|content_length
condition|)
name|ebb
operator|->
name|ends_section
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|new_entry
operator|=
operator|&
name|ebb
operator|->
name|ptbl
index|[
name|ebb
operator|->
name|end_ptbl_idx
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|new_entry
operator|->
name|flags
operator|&
name|XTENSA_PROP_UNREACHABLE
operator|)
operator|!=
literal|0
operator|&&
name|the_entry
operator|->
name|address
operator|+
name|the_entry
operator|->
name|size
operator|==
name|new_entry
operator|->
name|address
condition|)
name|ebb
operator|->
name|ends_unreachable
operator|=
name|new_entry
expr_stmt|;
block|}
comment|/* Any other ending requires exact alignment.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|extend_ebb_bounds_backward
parameter_list|(
name|ebb_t
modifier|*
name|ebb
parameter_list|)
block|{
name|property_table_entry
modifier|*
name|the_entry
decl_stmt|,
modifier|*
name|new_entry
decl_stmt|;
name|the_entry
operator|=
operator|&
name|ebb
operator|->
name|ptbl
index|[
name|ebb
operator|->
name|start_ptbl_idx
index|]
expr_stmt|;
comment|/* Stop when (1) we cannot decode the instructions in the current entry.      (2) we are at the beginning of the property tables, (3) we hit a      non-contiguous property table entry, (4) we hit a NO_TRANSFORM region.  */
while|while
condition|(
literal|1
condition|)
block|{
name|bfd_vma
name|block_begin
decl_stmt|;
name|bfd_size_type
name|insn_block_len
decl_stmt|;
name|block_begin
operator|=
name|the_entry
operator|->
name|address
operator|-
name|ebb
operator|->
name|sec
operator|->
name|vma
expr_stmt|;
name|insn_block_len
operator|=
name|insn_block_decodable_len
argument_list|(
name|ebb
operator|->
name|contents
argument_list|,
name|ebb
operator|->
name|content_length
argument_list|,
name|block_begin
argument_list|,
name|ebb
operator|->
name|start_offset
operator|-
name|block_begin
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_block_len
operator|!=
name|ebb
operator|->
name|start_offset
operator|-
name|block_begin
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): could not decode instruction; possible configuration mismatch"
argument_list|)
argument_list|,
name|ebb
operator|->
name|sec
operator|->
name|owner
argument_list|,
name|ebb
operator|->
name|sec
argument_list|,
name|ebb
operator|->
name|end_offset
operator|+
name|insn_block_len
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ebb
operator|->
name|start_offset
operator|-=
name|insn_block_len
expr_stmt|;
comment|/* Update the reloc counter.  */
while|while
condition|(
name|ebb
operator|->
name|start_reloc_idx
operator|>
literal|0
operator|&&
operator|(
name|ebb
operator|->
name|relocs
index|[
name|ebb
operator|->
name|start_reloc_idx
operator|-
literal|1
index|]
operator|.
name|r_offset
operator|>=
name|ebb
operator|->
name|start_offset
operator|)
condition|)
block|{
name|ebb
operator|->
name|start_reloc_idx
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|ebb
operator|->
name|start_ptbl_idx
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|new_entry
operator|=
operator|&
name|ebb
operator|->
name|ptbl
index|[
name|ebb
operator|->
name|start_ptbl_idx
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|new_entry
operator|->
name|flags
operator|&
name|XTENSA_PROP_INSN
operator|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|new_entry
operator|->
name|flags
operator|&
name|XTENSA_PROP_INSN_NO_TRANSFORM
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|new_entry
operator|->
name|flags
operator|&
name|XTENSA_PROP_ALIGN
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|new_entry
operator|->
name|address
operator|+
name|new_entry
operator|->
name|size
operator|!=
name|the_entry
operator|->
name|address
condition|)
return|return
name|TRUE
return|;
name|the_entry
operator|=
name|new_entry
expr_stmt|;
name|ebb
operator|->
name|start_ptbl_idx
operator|--
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_size_type
name|insn_block_decodable_len
parameter_list|(
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|bfd_size_type
name|content_len
parameter_list|,
name|bfd_vma
name|block_offset
parameter_list|,
name|bfd_size_type
name|block_len
parameter_list|)
block|{
name|bfd_vma
name|offset
init|=
name|block_offset
decl_stmt|;
while|while
condition|(
name|offset
operator|<
name|block_offset
operator|+
name|block_len
condition|)
block|{
name|bfd_size_type
name|insn_len
init|=
literal|0
decl_stmt|;
name|insn_len
operator|=
name|insn_decode_len
argument_list|(
name|contents
argument_list|,
name|content_len
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_len
operator|==
literal|0
condition|)
return|return
operator|(
name|offset
operator|-
name|block_offset
operator|)
return|;
name|offset
operator|+=
name|insn_len
expr_stmt|;
block|}
return|return
operator|(
name|offset
operator|-
name|block_offset
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ebb_propose_action
parameter_list|(
name|ebb_constraint
modifier|*
name|c
parameter_list|,
name|enum
name|ebb_target_enum
name|align_type
parameter_list|,
name|bfd_vma
name|alignment_pow
parameter_list|,
name|text_action_t
name|action
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|int
name|removed_bytes
parameter_list|,
name|bfd_boolean
name|do_action
parameter_list|)
block|{
name|proposed_action
modifier|*
name|act
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|action_allocated
operator|<=
name|c
operator|->
name|action_count
condition|)
block|{
name|unsigned
name|new_allocated
decl_stmt|,
name|i
decl_stmt|;
name|proposed_action
modifier|*
name|new_actions
decl_stmt|;
name|new_allocated
operator|=
operator|(
name|c
operator|->
name|action_count
operator|+
literal|2
operator|)
operator|*
literal|2
expr_stmt|;
name|new_actions
operator|=
operator|(
name|proposed_action
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|proposed_action
argument_list|)
operator|*
name|new_allocated
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
operator|->
name|action_count
condition|;
name|i
operator|++
control|)
name|new_actions
index|[
name|i
index|]
operator|=
name|c
operator|->
name|actions
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|actions
condition|)
name|free
argument_list|(
name|c
operator|->
name|actions
argument_list|)
expr_stmt|;
name|c
operator|->
name|actions
operator|=
name|new_actions
expr_stmt|;
name|c
operator|->
name|action_allocated
operator|=
name|new_allocated
expr_stmt|;
block|}
name|act
operator|=
operator|&
name|c
operator|->
name|actions
index|[
name|c
operator|->
name|action_count
index|]
expr_stmt|;
name|act
operator|->
name|align_type
operator|=
name|align_type
expr_stmt|;
name|act
operator|->
name|alignment_pow
operator|=
name|alignment_pow
expr_stmt|;
name|act
operator|->
name|action
operator|=
name|action
expr_stmt|;
name|act
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|act
operator|->
name|removed_bytes
operator|=
name|removed_bytes
expr_stmt|;
name|act
operator|->
name|do_action
operator|=
name|do_action
expr_stmt|;
name|c
operator|->
name|action_count
operator|++
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Access to internal relocations, section contents and symbols.  */
end_comment

begin_comment
comment|/* During relaxation, we need to modify relocations, section contents,    and symbol definitions, and we need to keep the original values from    being reloaded from the input files, i.e., we need to "pin" the    modified values in memory.  We also want to continue to observe the    setting of the "keep-memory" flag.  The following functions wrap the    standard BFD functions to take care of this for us.  */
end_comment

begin_function
specifier|static
name|Elf_Internal_Rela
modifier|*
name|retrieve_internal_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_boolean
name|keep_memory
parameter_list|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
name|internal_relocs
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
name|internal_relocs
operator|=
operator|(
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
return|return
name|internal_relocs
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pin_internal_relocs
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
parameter_list|)
block|{
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|release_internal_relocs
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
parameter_list|)
block|{
if|if
condition|(
name|internal_relocs
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bfd_byte
modifier|*
name|retrieve_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_boolean
name|keep_memory
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_size_type
name|sec_size
decl_stmt|;
name|sec_size
operator|=
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
operator|&&
name|sec_size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|&
name|contents
argument_list|)
condition|)
block|{
if|if
condition|(
name|contents
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|keep_memory
condition|)
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
block|}
return|return
name|contents
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pin_contents
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|)
block|{
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|release_contents
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|)
block|{
if|if
condition|(
name|contents
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|Elf_Internal_Sym
modifier|*
name|retrieve_local_syms
parameter_list|(
name|bfd
modifier|*
name|input_bfd
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
decl_stmt|;
name|size_t
name|locsymcount
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
operator|&&
name|locsymcount
operator|!=
literal|0
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|locsymcount
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Save the symbols for this input file so they won't be read again.  */
if|if
condition|(
name|isymbuf
operator|&&
name|isymbuf
operator|!=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
condition|)
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
return|return
name|isymbuf
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Code for link-time relaxation.  */
end_comment

begin_comment
comment|/* Initialization for relaxation: */
end_comment

begin_function_decl
specifier|static
name|bfd_boolean
name|analyze_relocations
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|find_relaxable_sections
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|bfd_boolean
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|collect_source_relocs
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|is_resolvable_asm_expansion
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|bfd_boolean
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Elf_Internal_Rela
modifier|*
name|find_associated_l32r_irel
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|compute_text_actions
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|compute_ebb_proposed_actions
parameter_list|(
name|ebb_constraint
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|compute_ebb_actions
parameter_list|(
name|ebb_constraint
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|check_section_ebb_pcrels_fit
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|,
specifier|const
name|ebb_constraint
modifier|*
parameter_list|,
specifier|const
name|xtensa_opcode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|check_section_ebb_reduces
parameter_list|(
specifier|const
name|ebb_constraint
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|text_action_add_proposed
parameter_list|(
name|text_action_list
modifier|*
parameter_list|,
specifier|const
name|ebb_constraint
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compute_fill_extra_space
parameter_list|(
name|property_table_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* First pass: */
end_comment

begin_function_decl
specifier|static
name|bfd_boolean
name|compute_removed_literals
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|value_map_hash_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Elf_Internal_Rela
modifier|*
name|get_irel_at_offset
parameter_list|(
name|asection
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|is_removable_literal
parameter_list|(
specifier|const
name|source_reloc
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|source_reloc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|remove_dead_literal
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|source_reloc
modifier|*
parameter_list|,
name|property_table_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|identify_literal_placement
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|value_map_hash_table
modifier|*
parameter_list|,
name|bfd_boolean
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|int
parameter_list|,
name|source_reloc
modifier|*
parameter_list|,
name|property_table_entry
modifier|*
parameter_list|,
name|int
parameter_list|,
name|section_cache_t
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|relocations_reach
parameter_list|(
name|source_reloc
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|r_reloc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|coalesce_shared_literal
parameter_list|(
name|asection
modifier|*
parameter_list|,
name|source_reloc
modifier|*
parameter_list|,
name|property_table_entry
modifier|*
parameter_list|,
name|int
parameter_list|,
name|value_map
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|move_shared_literal
parameter_list|(
name|asection
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|source_reloc
modifier|*
parameter_list|,
name|property_table_entry
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|r_reloc
modifier|*
parameter_list|,
specifier|const
name|literal_value
modifier|*
parameter_list|,
name|section_cache_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Second pass: */
end_comment

begin_function_decl
specifier|static
name|bfd_boolean
name|relax_section
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|translate_section_fixes
parameter_list|(
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|translate_reloc_bfd_fix
parameter_list|(
name|reloc_bfd_fix
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|translate_reloc
parameter_list|(
specifier|const
name|r_reloc
modifier|*
parameter_list|,
name|r_reloc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shrink_dynamic_reloc_sections
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|move_literal
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|xtensa_relax_info
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
modifier|*
parameter_list|,
specifier|const
name|literal_value
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|relax_property_section
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Third pass: */
end_comment

begin_function_decl
specifier|static
name|bfd_boolean
name|relax_section_symbols
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_relax_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|bfd_boolean
modifier|*
name|again
parameter_list|)
block|{
specifier|static
name|value_map_hash_table
modifier|*
name|values
init|=
name|NULL
decl_stmt|;
specifier|static
name|bfd_boolean
name|relocations_analyzed
init|=
name|FALSE
decl_stmt|;
name|xtensa_relax_info
modifier|*
name|relax_info
decl_stmt|;
if|if
condition|(
operator|!
name|relocations_analyzed
condition|)
block|{
comment|/* Do some overall initialization for relaxation.  */
name|values
operator|=
name|value_map_hash_table_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|values
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|relaxing_section
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|analyze_relocations
argument_list|(
name|link_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|relocations_analyzed
operator|=
name|TRUE
expr_stmt|;
block|}
operator|*
name|again
operator|=
name|FALSE
expr_stmt|;
comment|/* Don't mess with linker-created sections.  */
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|!=
literal|0
condition|)
return|return
name|TRUE
return|;
name|relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|relax_info
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|relax_info
operator|->
name|visited
condition|)
block|{
case|case
literal|0
case|:
comment|/* Note: It would be nice to fold this pass into 	 analyze_relocations, but it is important for this step that the 	 sections be examined in link order.  */
if|if
condition|(
operator|!
name|compute_removed_literals
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
argument_list|,
name|values
argument_list|)
condition|)
return|return
name|FALSE
return|;
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|values
condition|)
name|value_map_hash_table_delete
argument_list|(
name|values
argument_list|)
expr_stmt|;
name|values
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|relax_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
operator|!
name|relax_section_symbols
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
name|relax_info
operator|->
name|visited
operator|++
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialization for relaxation.  */
end_comment

begin_comment
comment|/* This function is called once at the start of relaxation.  It scans    all the input sections and marks the ones that are relaxable (i.e.,    literal sections with L32R relocations against them), and then    collects source_reloc information for all the relocations against    those relaxable sections.  During this process, it also detects    longcalls, i.e., calls relaxed by the assembler into indirect    calls, that can be optimized back into direct calls.  Within each    extended basic block (ebb) containing an optimized longcall, it    computes a set of "text actions" that can be performed to remove    the L32R associated with the longcall while optionally preserving    branch target alignments.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|analyze_relocations
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_boolean
name|is_relaxable
init|=
name|FALSE
decl_stmt|;
comment|/* Initialize the per-section relaxation info.  */
for|for
control|(
name|abfd
operator|=
name|link_info
operator|->
name|input_bfds
init|;
name|abfd
operator|!=
name|NULL
condition|;
name|abfd
operator|=
name|abfd
operator|->
name|link_next
control|)
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|init_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
block|}
comment|/* Mark relaxable sections (and count relocations against each one).  */
for|for
control|(
name|abfd
operator|=
name|link_info
operator|->
name|input_bfds
init|;
name|abfd
operator|!=
name|NULL
condition|;
name|abfd
operator|=
name|abfd
operator|->
name|link_next
control|)
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|find_relaxable_sections
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
argument_list|,
operator|&
name|is_relaxable
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Bail out if there are no relaxable sections.  */
if|if
condition|(
operator|!
name|is_relaxable
condition|)
return|return
name|TRUE
return|;
comment|/* Allocate space for source_relocs.  */
for|for
control|(
name|abfd
operator|=
name|link_info
operator|->
name|input_bfds
init|;
name|abfd
operator|!=
name|NULL
condition|;
name|abfd
operator|=
name|abfd
operator|->
name|link_next
control|)
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|xtensa_relax_info
modifier|*
name|relax_info
decl_stmt|;
name|relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|relax_info
operator|->
name|is_relaxable_literal_section
operator|||
name|relax_info
operator|->
name|is_relaxable_asm_section
condition|)
block|{
name|relax_info
operator|->
name|src_relocs
operator|=
operator|(
name|source_reloc
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|relax_info
operator|->
name|src_count
operator|*
sizeof|sizeof
argument_list|(
name|source_reloc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Collect info on relocations against each relaxable section.  */
for|for
control|(
name|abfd
operator|=
name|link_info
operator|->
name|input_bfds
init|;
name|abfd
operator|!=
name|NULL
condition|;
name|abfd
operator|=
name|abfd
operator|->
name|link_next
control|)
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|collect_source_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Compute the text actions.  */
for|for
control|(
name|abfd
operator|=
name|link_info
operator|->
name|input_bfds
init|;
name|abfd
operator|!=
name|NULL
condition|;
name|abfd
operator|=
name|abfd
operator|->
name|link_next
control|)
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|compute_text_actions
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Find all the sections that might be relaxed.  The motivation for    this pass is that collect_source_relocs() needs to record _all_ the    relocations that target each relaxable section.  That is expensive    and unnecessary unless the target section is actually going to be    relaxed.  This pass identifies all such sections by checking if    they have L32Rs pointing to them.  In the process, the total number    of relocations targeting each section is also counted so that we    know how much space to allocate for source_relocs against each    relaxable literal section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|find_relaxable_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|bfd_boolean
modifier|*
name|is_relaxable_p
parameter_list|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_boolean
name|ok
init|=
name|TRUE
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|xtensa_relax_info
modifier|*
name|source_relax_info
decl_stmt|;
name|internal_relocs
operator|=
name|retrieve_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
return|return
name|ok
return|;
name|contents
operator|=
name|retrieve_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
operator|&&
name|sec
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
name|ok
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|source_relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|irel
init|=
operator|&
name|internal_relocs
index|[
name|i
index|]
decl_stmt|;
name|r_reloc
name|r_rel
decl_stmt|;
name|asection
modifier|*
name|target_sec
decl_stmt|;
name|xtensa_relax_info
modifier|*
name|target_relax_info
decl_stmt|;
comment|/* If this section has not already been marked as "relaxable", and 	 if it contains any ASM_EXPAND relocations (marking expanded 	 longcalls) that can be optimized into direct calls, then mark 	 the section as "relaxable".  */
if|if
condition|(
name|source_relax_info
operator|&&
operator|!
name|source_relax_info
operator|->
name|is_relaxable_asm_section
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
name|R_XTENSA_ASM_EXPAND
condition|)
block|{
name|bfd_boolean
name|is_reachable
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|is_resolvable_asm_expansion
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
name|irel
argument_list|,
name|link_info
argument_list|,
operator|&
name|is_reachable
argument_list|)
operator|&&
name|is_reachable
condition|)
block|{
name|source_relax_info
operator|->
name|is_relaxable_asm_section
operator|=
name|TRUE
expr_stmt|;
operator|*
name|is_relaxable_p
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|r_reloc_init
argument_list|(
operator|&
name|r_rel
argument_list|,
name|abfd
argument_list|,
name|irel
argument_list|,
name|contents
argument_list|,
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|)
expr_stmt|;
name|target_sec
operator|=
name|r_reloc_get_section
argument_list|(
operator|&
name|r_rel
argument_list|)
expr_stmt|;
name|target_relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|target_sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_relax_info
condition|)
continue|continue;
comment|/* Count PC-relative operand relocations against the target section.          Note: The conditions tested here must match the conditions under 	 which init_source_reloc is called in collect_source_relocs().  */
if|if
condition|(
name|is_operand_relocation
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|)
operator|&&
operator|(
operator|!
name|is_alt_relocation
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|)
operator|||
name|is_l32r_relocation
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
name|irel
argument_list|)
operator|)
condition|)
name|target_relax_info
operator|->
name|src_count
operator|++
expr_stmt|;
if|if
condition|(
name|is_l32r_relocation
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
name|irel
argument_list|)
operator|&&
name|r_reloc_is_defined
argument_list|(
operator|&
name|r_rel
argument_list|)
condition|)
block|{
comment|/* Mark the target section as relaxable.  */
name|target_relax_info
operator|->
name|is_relaxable_literal_section
operator|=
name|TRUE
expr_stmt|;
operator|*
name|is_relaxable_p
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|error_return
label|:
name|release_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|release_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/* Record _all_ the relocations that point to relaxable sections, and    get rid of ASM_EXPAND relocs by either converting them to    ASM_SIMPLIFY or by removing them.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|collect_source_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_boolean
name|ok
init|=
name|TRUE
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|bfd_size_type
name|sec_size
decl_stmt|;
name|internal_relocs
operator|=
name|retrieve_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
return|return
name|ok
return|;
name|sec_size
operator|=
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|contents
operator|=
name|retrieve_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
operator|&&
name|sec_size
operator|!=
literal|0
condition|)
block|{
name|ok
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* Record relocations against relaxable literal sections.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|irel
init|=
operator|&
name|internal_relocs
index|[
name|i
index|]
decl_stmt|;
name|r_reloc
name|r_rel
decl_stmt|;
name|asection
modifier|*
name|target_sec
decl_stmt|;
name|xtensa_relax_info
modifier|*
name|target_relax_info
decl_stmt|;
name|r_reloc_init
argument_list|(
operator|&
name|r_rel
argument_list|,
name|abfd
argument_list|,
name|irel
argument_list|,
name|contents
argument_list|,
name|sec_size
argument_list|)
expr_stmt|;
name|target_sec
operator|=
name|r_reloc_get_section
argument_list|(
operator|&
name|r_rel
argument_list|)
expr_stmt|;
name|target_relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|target_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_relax_info
operator|&&
operator|(
name|target_relax_info
operator|->
name|is_relaxable_literal_section
operator|||
name|target_relax_info
operator|->
name|is_relaxable_asm_section
operator|)
condition|)
block|{
name|xtensa_opcode
name|opcode
init|=
name|XTENSA_UNDEFINED
decl_stmt|;
name|int
name|opnd
init|=
operator|-
literal|1
decl_stmt|;
name|bfd_boolean
name|is_abs_literal
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|is_alt_relocation
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|)
condition|)
block|{
comment|/* None of the current alternate relocs are PC-relative, 		 and only PC-relative relocs matter here.  However, we 		 still need to record the opcode for literal 		 coalescing.  */
name|opcode
operator|=
name|get_relocation_opcode
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
name|irel
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|get_l32r_opcode
argument_list|()
condition|)
block|{
name|is_abs_literal
operator|=
name|TRUE
expr_stmt|;
name|opnd
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|opcode
operator|=
name|XTENSA_UNDEFINED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_operand_relocation
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|)
condition|)
block|{
name|opcode
operator|=
name|get_relocation_opcode
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
name|irel
argument_list|)
expr_stmt|;
name|opnd
operator|=
name|get_relocation_opnd
argument_list|(
name|opcode
argument_list|,
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opcode
operator|!=
name|XTENSA_UNDEFINED
condition|)
block|{
name|int
name|src_next
init|=
name|target_relax_info
operator|->
name|src_next
operator|++
decl_stmt|;
name|source_reloc
modifier|*
name|s_reloc
init|=
operator|&
name|target_relax_info
operator|->
name|src_relocs
index|[
name|src_next
index|]
decl_stmt|;
name|init_source_reloc
argument_list|(
name|s_reloc
argument_list|,
name|sec
argument_list|,
operator|&
name|r_rel
argument_list|,
name|opcode
argument_list|,
name|opnd
argument_list|,
name|is_abs_literal
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Now get rid of ASM_EXPAND relocations.  At this point, the      src_relocs array for the target literal section may still be      incomplete, but it must at least contain the entries for the L32R      relocations associated with ASM_EXPANDs because they were just      added in the preceding loop over the relocations.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|irel
init|=
operator|&
name|internal_relocs
index|[
name|i
index|]
decl_stmt|;
name|bfd_boolean
name|is_reachable
decl_stmt|;
if|if
condition|(
operator|!
name|is_resolvable_asm_expansion
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
name|irel
argument_list|,
name|link_info
argument_list|,
operator|&
name|is_reachable
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|is_reachable
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|l32r_irel
decl_stmt|;
name|r_reloc
name|r_rel
decl_stmt|;
name|asection
modifier|*
name|target_sec
decl_stmt|;
name|xtensa_relax_info
modifier|*
name|target_relax_info
decl_stmt|;
comment|/* Mark the source_reloc for the L32R so that it will be 	     removed in compute_removed_literals(), along with the 	     associated literal.  */
name|l32r_irel
operator|=
name|find_associated_l32r_irel
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
name|irel
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|l32r_irel
operator|==
name|NULL
condition|)
continue|continue;
name|r_reloc_init
argument_list|(
operator|&
name|r_rel
argument_list|,
name|abfd
argument_list|,
name|l32r_irel
argument_list|,
name|contents
argument_list|,
name|sec_size
argument_list|)
expr_stmt|;
name|target_sec
operator|=
name|r_reloc_get_section
argument_list|(
operator|&
name|r_rel
argument_list|)
expr_stmt|;
name|target_relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|target_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_relax_info
operator|&&
operator|(
name|target_relax_info
operator|->
name|is_relaxable_literal_section
operator|||
name|target_relax_info
operator|->
name|is_relaxable_asm_section
operator|)
condition|)
block|{
name|source_reloc
modifier|*
name|s_reloc
decl_stmt|;
comment|/* Search the source_relocs for the entry corresponding to 		 the l32r_irel.  Note: The src_relocs array is not yet 		 sorted, but it wouldn't matter anyway because we're 		 searching by source offset instead of target offset.  */
name|s_reloc
operator|=
name|find_source_reloc
argument_list|(
name|target_relax_info
operator|->
name|src_relocs
argument_list|,
name|target_relax_info
operator|->
name|src_next
argument_list|,
name|sec
argument_list|,
name|l32r_irel
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s_reloc
argument_list|)
expr_stmt|;
name|s_reloc
operator|->
name|is_null
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Convert this reloc to ASM_SIMPLIFY.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_XTENSA_ASM_SIMPLIFY
argument_list|)
expr_stmt|;
name|l32r_irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_XTENSA_NONE
argument_list|)
expr_stmt|;
name|pin_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It is resolvable but doesn't reach.  We resolve now 	     by eliminating the relocation -- the call will remain 	     expanded into L32R/CALLX.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_XTENSA_NONE
argument_list|)
expr_stmt|;
name|pin_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
block|}
name|error_return
label|:
name|release_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|release_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the asm expansion can be resolved.  Generally it can    be resolved on a final link or when a partial link locates it in the    same section as the target.  Set "is_reachable" flag if the target of    the call is within the range of a direct call, given the current VMA    for this section and the target section.  */
end_comment

begin_function
name|bfd_boolean
name|is_resolvable_asm_expansion
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|irel
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|bfd_boolean
modifier|*
name|is_reachable_p
parameter_list|)
block|{
name|asection
modifier|*
name|target_sec
decl_stmt|;
name|bfd_vma
name|target_offset
decl_stmt|;
name|r_reloc
name|r_rel
decl_stmt|;
name|xtensa_opcode
name|opcode
decl_stmt|,
name|direct_call_opcode
decl_stmt|;
name|bfd_vma
name|self_address
decl_stmt|;
name|bfd_vma
name|dest_address
decl_stmt|;
name|bfd_boolean
name|uses_l32r
decl_stmt|;
name|bfd_size_type
name|sec_size
decl_stmt|;
operator|*
name|is_reachable_p
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_XTENSA_ASM_EXPAND
condition|)
return|return
name|FALSE
return|;
name|sec_size
operator|=
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|get_expanded_call_opcode
argument_list|(
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|,
name|sec_size
operator|-
name|irel
operator|->
name|r_offset
argument_list|,
operator|&
name|uses_l32r
argument_list|)
expr_stmt|;
comment|/* Optimization of longcalls that use CONST16 is not yet implemented.  */
if|if
condition|(
operator|!
name|uses_l32r
condition|)
return|return
name|FALSE
return|;
name|direct_call_opcode
operator|=
name|swap_callx_for_call_opcode
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|direct_call_opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|FALSE
return|;
comment|/* Check and see that the target resolves.  */
name|r_reloc_init
argument_list|(
operator|&
name|r_rel
argument_list|,
name|abfd
argument_list|,
name|irel
argument_list|,
name|contents
argument_list|,
name|sec_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r_reloc_is_defined
argument_list|(
operator|&
name|r_rel
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|target_sec
operator|=
name|r_reloc_get_section
argument_list|(
operator|&
name|r_rel
argument_list|)
expr_stmt|;
name|target_offset
operator|=
name|r_rel
operator|.
name|target_offset
expr_stmt|;
comment|/* If the target is in a shared library, then it doesn't reach.  This      isn't supposed to come up because the compiler should never generate      non-PIC calls on systems that use shared libraries, but the linker      shouldn't crash regardless.  */
if|if
condition|(
operator|!
name|target_sec
operator|->
name|output_section
condition|)
return|return
name|FALSE
return|;
comment|/* For relocatable sections, we can only simplify when the output      section of the target is the same as the output section of the      source.  */
if|if
condition|(
name|link_info
operator|->
name|relocatable
operator|&&
operator|(
name|target_sec
operator|->
name|output_section
operator|!=
name|sec
operator|->
name|output_section
operator|||
name|is_reloc_sym_weak
argument_list|(
name|abfd
argument_list|,
name|irel
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|self_address
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|3
operator|)
expr_stmt|;
name|dest_address
operator|=
operator|(
name|target_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|target_sec
operator|->
name|output_offset
operator|+
name|target_offset
operator|)
expr_stmt|;
operator|*
name|is_reachable_p
operator|=
name|pcrel_reloc_fits
argument_list|(
name|direct_call_opcode
argument_list|,
literal|0
argument_list|,
name|self_address
argument_list|,
name|dest_address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|self_address
operator|>>
name|CALL_SEGMENT_BITS
operator|)
operator|!=
operator|(
name|dest_address
operator|>>
name|CALL_SEGMENT_BITS
operator|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|Elf_Internal_Rela
modifier|*
name|find_associated_l32r_irel
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|other_irel
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|irel
init|=
operator|&
name|internal_relocs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|irel
operator|==
name|other_irel
condition|)
continue|continue;
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|!=
name|other_irel
operator|->
name|r_offset
condition|)
continue|continue;
if|if
condition|(
name|is_l32r_relocation
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
name|irel
argument_list|)
condition|)
return|return
name|irel
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|xtensa_opcode
modifier|*
name|build_reloc_opcodes
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|xtensa_opcode
modifier|*
name|reloc_opcodes
init|=
operator|(
name|xtensa_opcode
operator|*
operator|)
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xtensa_opcode
argument_list|)
operator|*
name|sec
operator|->
name|reloc_count
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|irel
init|=
operator|&
name|internal_relocs
index|[
name|i
index|]
decl_stmt|;
name|reloc_opcodes
index|[
name|i
index|]
operator|=
name|get_relocation_opcode
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
name|irel
argument_list|)
expr_stmt|;
block|}
return|return
name|reloc_opcodes
return|;
block|}
end_function

begin_comment
comment|/* The compute_text_actions function will build a list of potential    transformation actions for code in the extended basic block of each    longcall that is optimized to a direct call.  From this list we    generate a set of actions to actually perform that optimizes for    space and, if not using size_opt, maintains branch target    alignments.     These actions to be performed are placed on a per-section list.    The actual changes are performed by relax_section() in the second    pass.  */
end_comment

begin_function
name|bfd_boolean
name|compute_text_actions
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|)
block|{
name|xtensa_opcode
modifier|*
name|reloc_opcodes
init|=
name|NULL
decl_stmt|;
name|xtensa_relax_info
modifier|*
name|relax_info
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|bfd_boolean
name|ok
init|=
name|TRUE
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|property_table_entry
modifier|*
name|prop_table
init|=
literal|0
decl_stmt|;
name|int
name|ptblsize
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|sec_size
decl_stmt|;
specifier|static
name|bfd_boolean
name|no_insn_move
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|no_insn_move
condition|)
return|return
name|ok
return|;
comment|/* Do nothing if the section contains no optimized longcalls.  */
name|relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|relax_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relax_info
operator|->
name|is_relaxable_asm_section
condition|)
return|return
name|ok
return|;
name|internal_relocs
operator|=
name|retrieve_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
condition|)
name|qsort
argument_list|(
name|internal_relocs
argument_list|,
name|sec
operator|->
name|reloc_count
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
argument_list|,
name|internal_reloc_compare
argument_list|)
expr_stmt|;
name|sec_size
operator|=
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|contents
operator|=
name|retrieve_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
operator|&&
name|sec_size
operator|!=
literal|0
condition|)
block|{
name|ok
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|ptblsize
operator|=
name|xtensa_read_table_entries
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|&
name|prop_table
argument_list|,
name|XTENSA_PROP_SEC_NAME
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptblsize
operator|<
literal|0
condition|)
block|{
name|ok
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|irel
init|=
operator|&
name|internal_relocs
index|[
name|i
index|]
decl_stmt|;
name|bfd_vma
name|r_offset
decl_stmt|;
name|property_table_entry
modifier|*
name|the_entry
decl_stmt|;
name|int
name|ptbl_idx
decl_stmt|;
name|ebb_t
modifier|*
name|ebb
decl_stmt|;
name|ebb_constraint
name|ebb_table
decl_stmt|;
name|bfd_size_type
name|simplify_size
decl_stmt|;
if|if
condition|(
name|irel
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_XTENSA_ASM_SIMPLIFY
condition|)
continue|continue;
name|r_offset
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
name|simplify_size
operator|=
name|get_asm_simplify_size
argument_list|(
name|contents
argument_list|,
name|sec_size
argument_list|,
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|simplify_size
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): could not decode instruction for XTENSA_ASM_SIMPLIFY relocation; possible configuration mismatch"
argument_list|)
argument_list|,
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|,
name|r_offset
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If the instruction table is not around, then don't do this 	 relaxation.  */
name|the_entry
operator|=
name|elf_xtensa_find_property_entry
argument_list|(
name|prop_table
argument_list|,
name|ptblsize
argument_list|,
name|sec
operator|->
name|vma
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_entry
operator|==
name|NULL
operator|||
name|XTENSA_NO_NOP_REMOVAL
condition|)
block|{
name|text_action_add
argument_list|(
operator|&
name|relax_info
operator|->
name|action_list
argument_list|,
name|ta_convert_longcall
argument_list|,
name|sec
argument_list|,
name|r_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If the next longcall happens to be at the same address as an 	 unreachable section of size 0, then skip forward.  */
name|ptbl_idx
operator|=
name|the_entry
operator|-
name|prop_table
expr_stmt|;
while|while
condition|(
operator|(
name|the_entry
operator|->
name|flags
operator|&
name|XTENSA_PROP_UNREACHABLE
operator|)
operator|&&
name|the_entry
operator|->
name|size
operator|==
literal|0
operator|&&
name|ptbl_idx
operator|+
literal|1
operator|<
name|ptblsize
operator|&&
operator|(
name|prop_table
index|[
name|ptbl_idx
operator|+
literal|1
index|]
operator|.
name|address
operator|==
name|prop_table
index|[
name|ptbl_idx
index|]
operator|.
name|address
operator|)
condition|)
block|{
name|ptbl_idx
operator|++
expr_stmt|;
name|the_entry
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|the_entry
operator|->
name|flags
operator|&
name|XTENSA_PROP_INSN_NO_TRANSFORM
condition|)
comment|/* NO_REORDER is OK */
continue|continue;
name|init_ebb_constraint
argument_list|(
operator|&
name|ebb_table
argument_list|)
expr_stmt|;
name|ebb
operator|=
operator|&
name|ebb_table
operator|.
name|ebb
expr_stmt|;
name|init_ebb
argument_list|(
name|ebb
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
name|sec_size
argument_list|,
name|prop_table
argument_list|,
name|ptblsize
argument_list|,
name|internal_relocs
argument_list|,
name|sec
operator|->
name|reloc_count
argument_list|)
expr_stmt|;
name|ebb
operator|->
name|start_offset
operator|=
name|r_offset
operator|+
name|simplify_size
expr_stmt|;
name|ebb
operator|->
name|end_offset
operator|=
name|r_offset
operator|+
name|simplify_size
expr_stmt|;
name|ebb
operator|->
name|start_ptbl_idx
operator|=
name|ptbl_idx
expr_stmt|;
name|ebb
operator|->
name|end_ptbl_idx
operator|=
name|ptbl_idx
expr_stmt|;
name|ebb
operator|->
name|start_reloc_idx
operator|=
name|i
expr_stmt|;
name|ebb
operator|->
name|end_reloc_idx
operator|=
name|i
expr_stmt|;
comment|/* Precompute the opcode for each relocation.  */
if|if
condition|(
name|reloc_opcodes
operator|==
name|NULL
condition|)
name|reloc_opcodes
operator|=
name|build_reloc_opcodes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|extend_ebb_bounds
argument_list|(
name|ebb
argument_list|)
operator|||
operator|!
name|compute_ebb_proposed_actions
argument_list|(
operator|&
name|ebb_table
argument_list|)
operator|||
operator|!
name|compute_ebb_actions
argument_list|(
operator|&
name|ebb_table
argument_list|)
operator|||
operator|!
name|check_section_ebb_pcrels_fit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
name|internal_relocs
argument_list|,
operator|&
name|ebb_table
argument_list|,
name|reloc_opcodes
argument_list|)
operator|||
operator|!
name|check_section_ebb_reduces
argument_list|(
operator|&
name|ebb_table
argument_list|)
condition|)
block|{
comment|/* If anything goes wrong or we get unlucky and something does 	     not fit, with our plan because of expansion between 	     critical branches, just convert to a NOP.  */
name|text_action_add
argument_list|(
operator|&
name|relax_info
operator|->
name|action_list
argument_list|,
name|ta_convert_longcall
argument_list|,
name|sec
argument_list|,
name|r_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
name|ebb_table
operator|.
name|ebb
operator|.
name|end_reloc_idx
expr_stmt|;
name|free_ebb_constraint
argument_list|(
operator|&
name|ebb_table
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|text_action_add_proposed
argument_list|(
operator|&
name|relax_info
operator|->
name|action_list
argument_list|,
operator|&
name|ebb_table
argument_list|,
name|sec
argument_list|)
expr_stmt|;
comment|/* Update the index so we do not go looking at the relocations 	 we have already processed.  */
name|i
operator|=
name|ebb_table
operator|.
name|ebb
operator|.
name|end_reloc_idx
expr_stmt|;
name|free_ebb_constraint
argument_list|(
operator|&
name|ebb_table
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|DEBUG
if|if
condition|(
name|relax_info
operator|->
name|action_list
operator|.
name|head
condition|)
name|print_action_list
argument_list|(
name|stderr
argument_list|,
operator|&
name|relax_info
operator|->
name|action_list
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error_return
label|:
name|release_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|release_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_table
condition|)
name|free
argument_list|(
name|prop_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_opcodes
condition|)
name|free
argument_list|(
name|reloc_opcodes
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/* Find all of the possible actions for an extended basic block.  */
end_comment

begin_function
name|bfd_boolean
name|compute_ebb_proposed_actions
parameter_list|(
name|ebb_constraint
modifier|*
name|ebb_table
parameter_list|)
block|{
specifier|const
name|ebb_t
modifier|*
name|ebb
init|=
operator|&
name|ebb_table
operator|->
name|ebb
decl_stmt|;
name|unsigned
name|rel_idx
init|=
name|ebb
operator|->
name|start_reloc_idx
decl_stmt|;
name|property_table_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|start_entry
decl_stmt|,
modifier|*
name|end_entry
decl_stmt|;
name|start_entry
operator|=
operator|&
name|ebb
operator|->
name|ptbl
index|[
name|ebb
operator|->
name|start_ptbl_idx
index|]
expr_stmt|;
name|end_entry
operator|=
operator|&
name|ebb
operator|->
name|ptbl
index|[
name|ebb
operator|->
name|end_ptbl_idx
index|]
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|start_entry
init|;
name|entry
operator|<=
name|end_entry
condition|;
name|entry
operator|++
control|)
block|{
name|bfd_vma
name|offset
decl_stmt|,
name|start_offset
decl_stmt|,
name|end_offset
decl_stmt|;
name|bfd_size_type
name|insn_len
decl_stmt|;
name|start_offset
operator|=
name|entry
operator|->
name|address
operator|-
name|ebb
operator|->
name|sec
operator|->
name|vma
expr_stmt|;
name|end_offset
operator|=
name|entry
operator|->
name|address
operator|+
name|entry
operator|->
name|size
operator|-
name|ebb
operator|->
name|sec
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|start_entry
condition|)
name|start_offset
operator|=
name|ebb
operator|->
name|start_offset
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|end_entry
condition|)
name|end_offset
operator|=
name|ebb
operator|->
name|end_offset
expr_stmt|;
name|offset
operator|=
name|start_offset
expr_stmt|;
if|if
condition|(
name|offset
operator|==
name|entry
operator|->
name|address
operator|-
name|ebb
operator|->
name|sec
operator|->
name|vma
operator|&&
operator|(
name|entry
operator|->
name|flags
operator|&
name|XTENSA_PROP_INSN_BRANCH_TARGET
operator|)
operator|!=
literal|0
condition|)
block|{
name|enum
name|ebb_target_enum
name|align_type
init|=
name|EBB_DESIRE_TGT_ALIGN
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|offset
operator|!=
name|end_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
name|end_offset
condition|)
return|return
name|FALSE
return|;
name|insn_len
operator|=
name|insn_decode_len
argument_list|(
name|ebb
operator|->
name|contents
argument_list|,
name|ebb
operator|->
name|content_length
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* Propose no actions for a section with an undecodable offset.  */
if|if
condition|(
name|insn_len
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): could not decode instruction; possible configuration mismatch"
argument_list|)
argument_list|,
name|ebb
operator|->
name|sec
operator|->
name|owner
argument_list|,
name|ebb
operator|->
name|sec
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|check_branch_target_aligned_address
argument_list|(
name|offset
argument_list|,
name|insn_len
argument_list|)
condition|)
name|align_type
operator|=
name|EBB_REQUIRE_TGT_ALIGN
expr_stmt|;
name|ebb_propose_action
argument_list|(
name|ebb_table
argument_list|,
name|align_type
argument_list|,
literal|0
argument_list|,
name|ta_none
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|offset
operator|!=
name|end_offset
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
name|xtensa_opcode
name|opcode
decl_stmt|;
while|while
condition|(
name|rel_idx
operator|<
name|ebb
operator|->
name|end_reloc_idx
operator|&&
operator|(
name|ebb
operator|->
name|relocs
index|[
name|rel_idx
index|]
operator|.
name|r_offset
operator|<
name|offset
operator|||
operator|(
name|ebb
operator|->
name|relocs
index|[
name|rel_idx
index|]
operator|.
name|r_offset
operator|==
name|offset
operator|&&
operator|(
name|ELF32_R_TYPE
argument_list|(
name|ebb
operator|->
name|relocs
index|[
name|rel_idx
index|]
operator|.
name|r_info
argument_list|)
operator|!=
name|R_XTENSA_ASM_SIMPLIFY
operator|)
operator|)
operator|)
condition|)
name|rel_idx
operator|++
expr_stmt|;
comment|/* Check for longcall.  */
name|irel
operator|=
operator|&
name|ebb
operator|->
name|relocs
index|[
name|rel_idx
index|]
expr_stmt|;
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|==
name|offset
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
name|R_XTENSA_ASM_SIMPLIFY
condition|)
block|{
name|bfd_size_type
name|simplify_size
decl_stmt|;
name|simplify_size
operator|=
name|get_asm_simplify_size
argument_list|(
name|ebb
operator|->
name|contents
argument_list|,
name|ebb
operator|->
name|content_length
argument_list|,
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|simplify_size
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): could not decode instruction for XTENSA_ASM_SIMPLIFY relocation; possible configuration mismatch"
argument_list|)
argument_list|,
name|ebb
operator|->
name|sec
operator|->
name|owner
argument_list|,
name|ebb
operator|->
name|sec
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|ebb_propose_action
argument_list|(
name|ebb_table
argument_list|,
name|EBB_NO_ALIGN
argument_list|,
literal|0
argument_list|,
name|ta_convert_longcall
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|simplify_size
expr_stmt|;
continue|continue;
block|}
name|insn_len
operator|=
name|insn_decode_len
argument_list|(
name|ebb
operator|->
name|contents
argument_list|,
name|ebb
operator|->
name|content_length
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* If the instruction is undecodable, then report an error.  */
if|if
condition|(
name|insn_len
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): could not decode instruction; possible configuration mismatch"
argument_list|)
argument_list|,
name|ebb
operator|->
name|sec
operator|->
name|owner
argument_list|,
name|ebb
operator|->
name|sec
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|XTENSA_PROP_INSN_NO_DENSITY
operator|)
operator|==
literal|0
operator|&&
operator|(
name|entry
operator|->
name|flags
operator|&
name|XTENSA_PROP_INSN_NO_TRANSFORM
operator|)
operator|==
literal|0
operator|&&
name|narrow_instruction
argument_list|(
name|ebb
operator|->
name|contents
argument_list|,
name|ebb
operator|->
name|content_length
argument_list|,
name|offset
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
comment|/* Add an instruction narrow action.  */
name|ebb_propose_action
argument_list|(
name|ebb_table
argument_list|,
name|EBB_NO_ALIGN
argument_list|,
literal|0
argument_list|,
name|ta_narrow_insn
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|insn_len
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|XTENSA_PROP_INSN_NO_TRANSFORM
operator|)
operator|==
literal|0
operator|&&
name|widen_instruction
argument_list|(
name|ebb
operator|->
name|contents
argument_list|,
name|ebb
operator|->
name|content_length
argument_list|,
name|offset
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
comment|/* Add an instruction widen action.  */
name|ebb_propose_action
argument_list|(
name|ebb_table
argument_list|,
name|EBB_NO_ALIGN
argument_list|,
literal|0
argument_list|,
name|ta_widen_insn
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|insn_len
expr_stmt|;
continue|continue;
block|}
name|opcode
operator|=
name|insn_decode_opcode
argument_list|(
name|ebb
operator|->
name|contents
argument_list|,
name|ebb
operator|->
name|content_length
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xtensa_opcode_is_loop
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|)
condition|)
block|{
comment|/* Check for branch targets.  */
name|ebb_propose_action
argument_list|(
name|ebb_table
argument_list|,
name|EBB_REQUIRE_LOOP_ALIGN
argument_list|,
literal|0
argument_list|,
name|ta_none
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|insn_len
expr_stmt|;
continue|continue;
block|}
name|offset
operator|+=
name|insn_len
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ebb
operator|->
name|ends_unreachable
condition|)
block|{
name|ebb_propose_action
argument_list|(
name|ebb_table
argument_list|,
name|EBB_NO_ALIGN
argument_list|,
literal|0
argument_list|,
name|ta_fill
argument_list|,
name|ebb
operator|->
name|end_offset
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* After all of the information has collected about the    transformations possible in an EBB, compute the appropriate actions    here in compute_ebb_actions.  We still must check later to make    sure that the actions do not break any relocations.  The algorithm    used here is pretty greedy.  Basically, it removes as many no-ops    as possible so that the end of the EBB has the same alignment    characteristics as the original.  First, it uses narrowing, then    fill space at the end of the EBB, and finally widenings.  If that    does not work, it tries again with one fewer no-op removed.  The    optimization will only be performed if all of the branch targets    that were aligned before transformation are also aligned after the    transformation.     When the size_opt flag is set, ignore the branch target alignments,    narrow all wide instructions, and remove all no-ops unless the end    of the EBB prevents it.  */
end_comment

begin_function
name|bfd_boolean
name|compute_ebb_actions
parameter_list|(
name|ebb_constraint
modifier|*
name|ebb_table
parameter_list|)
block|{
name|unsigned
name|i
init|=
literal|0
decl_stmt|;
name|unsigned
name|j
decl_stmt|;
name|int
name|removed_bytes
init|=
literal|0
decl_stmt|;
name|ebb_t
modifier|*
name|ebb
init|=
operator|&
name|ebb_table
operator|->
name|ebb
decl_stmt|;
name|unsigned
name|seg_idx_start
init|=
literal|0
decl_stmt|;
name|unsigned
name|seg_idx_end
init|=
literal|0
decl_stmt|;
comment|/* We perform this like the assembler relaxation algorithm: Start by      assuming all instructions are narrow and all no-ops removed; then      walk through....  */
comment|/* For each segment of this that has a solid constraint, check to      see if there are any combinations that will keep the constraint.      If so, use it.  */
for|for
control|(
name|seg_idx_end
operator|=
literal|0
init|;
name|seg_idx_end
operator|<
name|ebb_table
operator|->
name|action_count
condition|;
name|seg_idx_end
operator|++
control|)
block|{
name|bfd_boolean
name|requires_text_end_align
init|=
name|FALSE
decl_stmt|;
name|unsigned
name|longcall_count
init|=
literal|0
decl_stmt|;
name|unsigned
name|longcall_convert_count
init|=
literal|0
decl_stmt|;
name|unsigned
name|narrowable_count
init|=
literal|0
decl_stmt|;
name|unsigned
name|narrowable_convert_count
init|=
literal|0
decl_stmt|;
name|unsigned
name|widenable_count
init|=
literal|0
decl_stmt|;
name|unsigned
name|widenable_convert_count
init|=
literal|0
decl_stmt|;
name|proposed_action
modifier|*
name|action
init|=
name|NULL
decl_stmt|;
name|int
name|align
init|=
operator|(
literal|1
operator|<<
name|ebb_table
operator|->
name|ebb
operator|.
name|sec
operator|->
name|alignment_power
operator|)
decl_stmt|;
name|seg_idx_start
operator|=
name|seg_idx_end
expr_stmt|;
for|for
control|(
name|i
operator|=
name|seg_idx_start
init|;
name|i
operator|<
name|ebb_table
operator|->
name|action_count
condition|;
name|i
operator|++
control|)
block|{
name|action
operator|=
operator|&
name|ebb_table
operator|->
name|actions
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|action
operator|->
name|action
operator|==
name|ta_convert_longcall
condition|)
name|longcall_count
operator|++
expr_stmt|;
if|if
condition|(
name|action
operator|->
name|action
operator|==
name|ta_narrow_insn
condition|)
name|narrowable_count
operator|++
expr_stmt|;
if|if
condition|(
name|action
operator|->
name|action
operator|==
name|ta_widen_insn
condition|)
name|widenable_count
operator|++
expr_stmt|;
if|if
condition|(
name|action
operator|->
name|action
operator|==
name|ta_fill
condition|)
break|break;
if|if
condition|(
name|action
operator|->
name|align_type
operator|==
name|EBB_REQUIRE_LOOP_ALIGN
condition|)
break|break;
if|if
condition|(
name|action
operator|->
name|align_type
operator|==
name|EBB_REQUIRE_TGT_ALIGN
operator|&&
operator|!
name|elf32xtensa_size_opt
condition|)
break|break;
block|}
name|seg_idx_end
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|seg_idx_end
operator|==
name|ebb_table
operator|->
name|action_count
operator|&&
operator|!
name|ebb
operator|->
name|ends_unreachable
condition|)
name|requires_text_end_align
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|elf32xtensa_size_opt
operator|&&
operator|!
name|requires_text_end_align
operator|&&
name|action
operator|->
name|align_type
operator|!=
name|EBB_REQUIRE_LOOP_ALIGN
operator|&&
name|action
operator|->
name|align_type
operator|!=
name|EBB_REQUIRE_TGT_ALIGN
condition|)
block|{
name|longcall_convert_count
operator|=
name|longcall_count
expr_stmt|;
name|narrowable_convert_count
operator|=
name|narrowable_count
expr_stmt|;
name|widenable_convert_count
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* There is a constraint.  Convert the max number of longcalls.  */
name|narrowable_convert_count
operator|=
literal|0
expr_stmt|;
name|longcall_convert_count
operator|=
literal|0
expr_stmt|;
name|widenable_convert_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|longcall_count
condition|;
name|j
operator|++
control|)
block|{
name|int
name|removed
init|=
operator|(
name|longcall_count
operator|-
name|j
operator|)
operator|*
literal|3
operator|&
operator|(
name|align
operator|-
literal|1
operator|)
decl_stmt|;
name|unsigned
name|desire_narrow
init|=
operator|(
name|align
operator|-
name|removed
operator|)
operator|&
operator|(
name|align
operator|-
literal|1
operator|)
decl_stmt|;
name|unsigned
name|desire_widen
init|=
name|removed
decl_stmt|;
if|if
condition|(
name|desire_narrow
operator|<=
name|narrowable_count
condition|)
block|{
name|narrowable_convert_count
operator|=
name|desire_narrow
expr_stmt|;
name|narrowable_convert_count
operator|+=
operator|(
name|align
operator|*
operator|(
operator|(
name|narrowable_count
operator|-
name|narrowable_convert_count
operator|)
operator|/
name|align
operator|)
operator|)
expr_stmt|;
name|longcall_convert_count
operator|=
operator|(
name|longcall_count
operator|-
name|j
operator|)
expr_stmt|;
name|widenable_convert_count
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|desire_widen
operator|<=
name|widenable_count
operator|&&
operator|!
name|elf32xtensa_size_opt
condition|)
block|{
name|narrowable_convert_count
operator|=
literal|0
expr_stmt|;
name|longcall_convert_count
operator|=
name|longcall_count
operator|-
name|j
expr_stmt|;
name|widenable_convert_count
operator|=
name|desire_widen
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Now the number of conversions are saved.  Do them.  */
for|for
control|(
name|i
operator|=
name|seg_idx_start
init|;
name|i
operator|<
name|seg_idx_end
condition|;
name|i
operator|++
control|)
block|{
name|action
operator|=
operator|&
name|ebb_table
operator|->
name|actions
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|action
operator|->
name|action
condition|)
block|{
case|case
name|ta_convert_longcall
case|:
if|if
condition|(
name|longcall_convert_count
operator|!=
literal|0
condition|)
block|{
name|action
operator|->
name|action
operator|=
name|ta_remove_longcall
expr_stmt|;
name|action
operator|->
name|do_action
operator|=
name|TRUE
expr_stmt|;
name|action
operator|->
name|removed_bytes
operator|+=
literal|3
expr_stmt|;
name|longcall_convert_count
operator|--
expr_stmt|;
block|}
break|break;
case|case
name|ta_narrow_insn
case|:
if|if
condition|(
name|narrowable_convert_count
operator|!=
literal|0
condition|)
block|{
name|action
operator|->
name|do_action
operator|=
name|TRUE
expr_stmt|;
name|action
operator|->
name|removed_bytes
operator|+=
literal|1
expr_stmt|;
name|narrowable_convert_count
operator|--
expr_stmt|;
block|}
break|break;
case|case
name|ta_widen_insn
case|:
if|if
condition|(
name|widenable_convert_count
operator|!=
literal|0
condition|)
block|{
name|action
operator|->
name|do_action
operator|=
name|TRUE
expr_stmt|;
name|action
operator|->
name|removed_bytes
operator|-=
literal|1
expr_stmt|;
name|widenable_convert_count
operator|--
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
comment|/* Now we move on to some local opts.  Try to remove each of the      remaining longcalls.  */
if|if
condition|(
name|ebb_table
operator|->
name|ebb
operator|.
name|ends_section
operator|||
name|ebb_table
operator|->
name|ebb
operator|.
name|ends_unreachable
condition|)
block|{
name|removed_bytes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ebb_table
operator|->
name|action_count
condition|;
name|i
operator|++
control|)
block|{
name|int
name|old_removed_bytes
init|=
name|removed_bytes
decl_stmt|;
name|proposed_action
modifier|*
name|action
init|=
operator|&
name|ebb_table
operator|->
name|actions
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|action
operator|->
name|do_action
operator|&&
name|action
operator|->
name|action
operator|==
name|ta_convert_longcall
condition|)
block|{
name|bfd_boolean
name|bad_alignment
init|=
name|FALSE
decl_stmt|;
name|removed_bytes
operator|+=
literal|3
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|ebb_table
operator|->
name|action_count
condition|;
name|j
operator|++
control|)
block|{
name|proposed_action
modifier|*
name|new_action
init|=
operator|&
name|ebb_table
operator|->
name|actions
index|[
name|j
index|]
decl_stmt|;
name|bfd_vma
name|offset
init|=
name|new_action
operator|->
name|offset
decl_stmt|;
if|if
condition|(
name|new_action
operator|->
name|align_type
operator|==
name|EBB_REQUIRE_TGT_ALIGN
condition|)
block|{
if|if
condition|(
operator|!
name|check_branch_target_aligned
argument_list|(
name|ebb_table
operator|->
name|ebb
operator|.
name|contents
argument_list|,
name|ebb_table
operator|->
name|ebb
operator|.
name|content_length
argument_list|,
name|offset
argument_list|,
name|offset
operator|-
name|removed_bytes
argument_list|)
condition|)
block|{
name|bad_alignment
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|new_action
operator|->
name|align_type
operator|==
name|EBB_REQUIRE_LOOP_ALIGN
condition|)
block|{
if|if
condition|(
operator|!
name|check_loop_aligned
argument_list|(
name|ebb_table
operator|->
name|ebb
operator|.
name|contents
argument_list|,
name|ebb_table
operator|->
name|ebb
operator|.
name|content_length
argument_list|,
name|offset
argument_list|,
name|offset
operator|-
name|removed_bytes
argument_list|)
condition|)
block|{
name|bad_alignment
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|new_action
operator|->
name|action
operator|==
name|ta_narrow_insn
operator|&&
operator|!
name|new_action
operator|->
name|do_action
operator|&&
name|ebb_table
operator|->
name|ebb
operator|.
name|sec
operator|->
name|alignment_power
operator|==
literal|2
condition|)
block|{
comment|/* Narrow an instruction and we are done.  */
name|new_action
operator|->
name|do_action
operator|=
name|TRUE
expr_stmt|;
name|new_action
operator|->
name|removed_bytes
operator|+=
literal|1
expr_stmt|;
name|bad_alignment
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|new_action
operator|->
name|action
operator|==
name|ta_widen_insn
operator|&&
name|new_action
operator|->
name|do_action
operator|&&
name|ebb_table
operator|->
name|ebb
operator|.
name|sec
operator|->
name|alignment_power
operator|==
literal|2
condition|)
block|{
comment|/* Narrow an instruction and we are done.  */
name|new_action
operator|->
name|do_action
operator|=
name|FALSE
expr_stmt|;
name|new_action
operator|->
name|removed_bytes
operator|+=
literal|1
expr_stmt|;
name|bad_alignment
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|bad_alignment
condition|)
block|{
name|action
operator|->
name|removed_bytes
operator|+=
literal|3
expr_stmt|;
name|action
operator|->
name|action
operator|=
name|ta_remove_longcall
expr_stmt|;
name|action
operator|->
name|do_action
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|removed_bytes
operator|=
name|old_removed_bytes
expr_stmt|;
if|if
condition|(
name|action
operator|->
name|do_action
condition|)
name|removed_bytes
operator|+=
name|action
operator|->
name|removed_bytes
expr_stmt|;
block|}
block|}
name|removed_bytes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ebb_table
operator|->
name|action_count
condition|;
operator|++
name|i
control|)
block|{
name|proposed_action
modifier|*
name|action
init|=
operator|&
name|ebb_table
operator|->
name|actions
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|action
operator|->
name|do_action
condition|)
name|removed_bytes
operator|+=
name|action
operator|->
name|removed_bytes
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|removed_bytes
operator|%
operator|(
literal|1
operator|<<
name|ebb_table
operator|->
name|ebb
operator|.
name|sec
operator|->
name|alignment_power
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|ebb
operator|->
name|ends_unreachable
condition|)
block|{
name|proposed_action
modifier|*
name|action
decl_stmt|;
name|int
name|br
decl_stmt|;
name|int
name|extra_space
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|ebb_table
operator|->
name|action_count
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|action
operator|=
operator|&
name|ebb_table
operator|->
name|actions
index|[
name|ebb_table
operator|->
name|action_count
operator|-
literal|1
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|action
operator|->
name|action
operator|==
name|ta_fill
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ebb
operator|->
name|ends_unreachable
operator|->
name|flags
operator|&
name|XTENSA_PROP_UNREACHABLE
argument_list|)
expr_stmt|;
name|extra_space
operator|=
name|compute_fill_extra_space
argument_list|(
name|ebb
operator|->
name|ends_unreachable
argument_list|)
expr_stmt|;
name|br
operator|=
name|action
operator|->
name|removed_bytes
operator|+
name|removed_bytes
operator|+
name|extra_space
expr_stmt|;
name|br
operator|=
name|br
operator|&
operator|(
operator|(
literal|1
operator|<<
name|ebb
operator|->
name|sec
operator|->
name|alignment_power
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|action
operator|->
name|removed_bytes
operator|=
name|extra_space
operator|-
name|br
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The xlate_map is a sorted array of address mappings designed to    answer the offset_with_removed_text() query with a binary search instead    of a linear search through the section's action_list.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|xlate_map_entry
name|xlate_map_entry_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|xlate_map
name|xlate_map_t
typedef|;
end_typedef

begin_struct
struct|struct
name|xlate_map_entry
block|{
name|unsigned
name|orig_address
decl_stmt|;
name|unsigned
name|new_address
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|xlate_map
block|{
name|unsigned
name|entry_count
decl_stmt|;
name|xlate_map_entry_t
modifier|*
name|entry
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|xlate_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a_v
parameter_list|,
specifier|const
name|void
modifier|*
name|b_v
parameter_list|)
block|{
specifier|const
name|xlate_map_entry_t
modifier|*
name|a
init|=
operator|(
specifier|const
name|xlate_map_entry_t
operator|*
operator|)
name|a_v
decl_stmt|;
specifier|const
name|xlate_map_entry_t
modifier|*
name|b
init|=
operator|(
specifier|const
name|xlate_map_entry_t
operator|*
operator|)
name|b_v
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|orig_address
operator|<
name|b
operator|->
name|orig_address
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|orig_address
operator|>
operator|(
name|b
operator|->
name|orig_address
operator|+
name|b
operator|->
name|size
operator|-
literal|1
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|xlate_offset_with_removed_text
parameter_list|(
specifier|const
name|xlate_map_t
modifier|*
name|map
parameter_list|,
name|text_action_list
modifier|*
name|action_list
parameter_list|,
name|bfd_vma
name|offset
parameter_list|)
block|{
name|xlate_map_entry_t
name|tmp
decl_stmt|;
name|void
modifier|*
name|r
decl_stmt|;
name|xlate_map_entry_t
modifier|*
name|e
decl_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
return|return
name|offset_with_removed_text
argument_list|(
name|action_list
argument_list|,
name|offset
argument_list|)
return|;
if|if
condition|(
name|map
operator|->
name|entry_count
operator|==
literal|0
condition|)
return|return
name|offset
return|;
name|tmp
operator|.
name|orig_address
operator|=
name|offset
expr_stmt|;
name|tmp
operator|.
name|new_address
operator|=
name|offset
expr_stmt|;
name|tmp
operator|.
name|size
operator|=
literal|1
expr_stmt|;
name|r
operator|=
name|bsearch
argument_list|(
operator|&
name|offset
argument_list|,
name|map
operator|->
name|entry
argument_list|,
name|map
operator|->
name|entry_count
argument_list|,
sizeof|sizeof
argument_list|(
name|xlate_map_entry_t
argument_list|)
argument_list|,
operator|&
name|xlate_compare
argument_list|)
expr_stmt|;
name|e
operator|=
operator|(
name|xlate_map_entry_t
operator|*
operator|)
name|r
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|e
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
return|return
name|offset
return|;
return|return
name|e
operator|->
name|new_address
operator|-
name|e
operator|->
name|orig_address
operator|+
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Build a binary searchable offset translation map from a section's    action list.  */
end_comment

begin_function
specifier|static
name|xlate_map_t
modifier|*
name|build_xlate_map
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|xtensa_relax_info
modifier|*
name|relax_info
parameter_list|)
block|{
name|xlate_map_t
modifier|*
name|map
init|=
operator|(
name|xlate_map_t
operator|*
operator|)
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xlate_map_t
argument_list|)
argument_list|)
decl_stmt|;
name|text_action_list
modifier|*
name|action_list
init|=
operator|&
name|relax_info
operator|->
name|action_list
decl_stmt|;
name|unsigned
name|num_actions
init|=
literal|0
decl_stmt|;
name|text_action
modifier|*
name|r
decl_stmt|;
name|int
name|removed
decl_stmt|;
name|xlate_map_entry_t
modifier|*
name|current_entry
decl_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|num_actions
operator|=
name|action_list_count
argument_list|(
name|action_list
argument_list|)
expr_stmt|;
name|map
operator|->
name|entry
operator|=
operator|(
name|xlate_map_entry_t
operator|*
operator|)
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xlate_map_entry_t
argument_list|)
operator|*
operator|(
name|num_actions
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|entry
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|map
operator|->
name|entry_count
operator|=
literal|0
expr_stmt|;
name|removed
operator|=
literal|0
expr_stmt|;
name|current_entry
operator|=
operator|&
name|map
operator|->
name|entry
index|[
literal|0
index|]
expr_stmt|;
name|current_entry
operator|->
name|orig_address
operator|=
literal|0
expr_stmt|;
name|current_entry
operator|->
name|new_address
operator|=
literal|0
expr_stmt|;
name|current_entry
operator|->
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|r
operator|=
name|action_list
operator|->
name|head
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
name|unsigned
name|orig_size
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|r
operator|->
name|action
condition|)
block|{
case|case
name|ta_none
case|:
case|case
name|ta_remove_insn
case|:
case|case
name|ta_convert_longcall
case|:
case|case
name|ta_remove_literal
case|:
case|case
name|ta_add_literal
case|:
break|break;
case|case
name|ta_remove_longcall
case|:
name|orig_size
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|ta_narrow_insn
case|:
name|orig_size
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|ta_widen_insn
case|:
name|orig_size
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|ta_fill
case|:
break|break;
block|}
name|current_entry
operator|->
name|size
operator|=
name|r
operator|->
name|offset
operator|+
name|orig_size
operator|-
name|current_entry
operator|->
name|orig_address
expr_stmt|;
if|if
condition|(
name|current_entry
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
name|current_entry
operator|++
expr_stmt|;
name|map
operator|->
name|entry_count
operator|++
expr_stmt|;
block|}
name|current_entry
operator|->
name|orig_address
operator|=
name|r
operator|->
name|offset
operator|+
name|orig_size
expr_stmt|;
name|removed
operator|+=
name|r
operator|->
name|removed_bytes
expr_stmt|;
name|current_entry
operator|->
name|new_address
operator|=
name|r
operator|->
name|offset
operator|+
name|orig_size
operator|-
name|removed
expr_stmt|;
name|current_entry
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
name|current_entry
operator|->
name|size
operator|=
operator|(
name|bfd_get_section_limit
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
operator|-
name|current_entry
operator|->
name|orig_address
operator|)
expr_stmt|;
if|if
condition|(
name|current_entry
operator|->
name|size
operator|!=
literal|0
condition|)
name|map
operator|->
name|entry_count
operator|++
expr_stmt|;
return|return
name|map
return|;
block|}
end_function

begin_comment
comment|/* Free an offset translation map.  */
end_comment

begin_function
specifier|static
name|void
name|free_xlate_map
parameter_list|(
name|xlate_map_t
modifier|*
name|map
parameter_list|)
block|{
if|if
condition|(
name|map
operator|&&
name|map
operator|->
name|entry
condition|)
name|free
argument_list|(
name|map
operator|->
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
condition|)
name|free
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Use check_section_ebb_pcrels_fit to make sure that all of the    relocations in a section will fit if a proposed set of actions    are performed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|check_section_ebb_pcrels_fit
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
parameter_list|,
specifier|const
name|ebb_constraint
modifier|*
name|constraint
parameter_list|,
specifier|const
name|xtensa_opcode
modifier|*
name|reloc_opcodes
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
name|xlate_map_t
modifier|*
name|xmap
init|=
name|NULL
decl_stmt|;
name|bfd_boolean
name|ok
init|=
name|TRUE
decl_stmt|;
name|xtensa_relax_info
modifier|*
name|relax_info
decl_stmt|;
name|relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|relax_info
operator|&&
name|sec
operator|->
name|reloc_count
operator|>
literal|100
condition|)
block|{
name|xmap
operator|=
name|build_xlate_map
argument_list|(
name|sec
argument_list|,
name|relax_info
argument_list|)
expr_stmt|;
comment|/* NULL indicates out of memory, but the slow version 	 can still be used.  */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|r_reloc
name|r_rel
decl_stmt|;
name|bfd_vma
name|orig_self_offset
decl_stmt|,
name|orig_target_offset
decl_stmt|;
name|bfd_vma
name|self_offset
decl_stmt|,
name|target_offset
decl_stmt|;
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|int
name|self_removed_bytes
decl_stmt|,
name|target_removed_bytes
decl_stmt|;
name|irel
operator|=
operator|&
name|internal_relocs
index|[
name|i
index|]
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|howto
operator|=
operator|&
name|elf_howto_table
index|[
name|r_type
index|]
expr_stmt|;
comment|/* We maintain the required invariant: PC-relative relocations 	 that fit before linking must fit after linking.  Thus we only 	 need to deal with relocations to the same section that are 	 PC-relative.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
name|R_XTENSA_ASM_SIMPLIFY
operator|||
operator|!
name|howto
operator|->
name|pc_relative
condition|)
continue|continue;
name|r_reloc_init
argument_list|(
operator|&
name|r_rel
argument_list|,
name|abfd
argument_list|,
name|irel
argument_list|,
name|contents
argument_list|,
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_reloc_get_section
argument_list|(
operator|&
name|r_rel
argument_list|)
operator|!=
name|sec
condition|)
continue|continue;
name|orig_self_offset
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
name|orig_target_offset
operator|=
name|r_rel
operator|.
name|target_offset
expr_stmt|;
name|self_offset
operator|=
name|orig_self_offset
expr_stmt|;
name|target_offset
operator|=
name|orig_target_offset
expr_stmt|;
if|if
condition|(
name|relax_info
condition|)
block|{
name|self_offset
operator|=
name|xlate_offset_with_removed_text
argument_list|(
name|xmap
argument_list|,
operator|&
name|relax_info
operator|->
name|action_list
argument_list|,
name|orig_self_offset
argument_list|)
expr_stmt|;
name|target_offset
operator|=
name|xlate_offset_with_removed_text
argument_list|(
name|xmap
argument_list|,
operator|&
name|relax_info
operator|->
name|action_list
argument_list|,
name|orig_target_offset
argument_list|)
expr_stmt|;
block|}
name|self_removed_bytes
operator|=
literal|0
expr_stmt|;
name|target_removed_bytes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|constraint
operator|->
name|action_count
condition|;
operator|++
name|j
control|)
block|{
name|proposed_action
modifier|*
name|action
init|=
operator|&
name|constraint
operator|->
name|actions
index|[
name|j
index|]
decl_stmt|;
name|bfd_vma
name|offset
init|=
name|action
operator|->
name|offset
decl_stmt|;
name|int
name|removed_bytes
init|=
name|action
operator|->
name|removed_bytes
decl_stmt|;
if|if
condition|(
name|offset
operator|<
name|orig_self_offset
operator|||
operator|(
name|offset
operator|==
name|orig_self_offset
operator|&&
name|action
operator|->
name|action
operator|==
name|ta_fill
operator|&&
name|action
operator|->
name|removed_bytes
operator|<
literal|0
operator|)
condition|)
name|self_removed_bytes
operator|+=
name|removed_bytes
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|orig_target_offset
operator|||
operator|(
name|offset
operator|==
name|orig_target_offset
operator|&&
name|action
operator|->
name|action
operator|==
name|ta_fill
operator|&&
name|action
operator|->
name|removed_bytes
operator|<
literal|0
operator|)
condition|)
name|target_removed_bytes
operator|+=
name|removed_bytes
expr_stmt|;
block|}
name|self_offset
operator|-=
name|self_removed_bytes
expr_stmt|;
name|target_offset
operator|-=
name|target_removed_bytes
expr_stmt|;
comment|/* Try to encode it.  Get the operand and check.  */
if|if
condition|(
name|is_alt_relocation
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|)
condition|)
block|{
comment|/* None of the current alternate relocs are PC-relative, 	     and only PC-relative relocs matter here.  */
block|}
else|else
block|{
name|xtensa_opcode
name|opcode
decl_stmt|;
name|int
name|opnum
decl_stmt|;
if|if
condition|(
name|reloc_opcodes
condition|)
name|opcode
operator|=
name|reloc_opcodes
index|[
name|i
index|]
expr_stmt|;
else|else
name|opcode
operator|=
name|get_relocation_opcode
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
name|irel
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
name|ok
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|opnum
operator|=
name|get_relocation_opnd
argument_list|(
name|opcode
argument_list|,
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opnum
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
name|ok
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|pcrel_reloc_fits
argument_list|(
name|opcode
argument_list|,
name|opnum
argument_list|,
name|self_offset
argument_list|,
name|target_offset
argument_list|)
condition|)
block|{
name|ok
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|xmap
condition|)
name|free_xlate_map
argument_list|(
name|xmap
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|check_section_ebb_reduces
parameter_list|(
specifier|const
name|ebb_constraint
modifier|*
name|constraint
parameter_list|)
block|{
name|int
name|removed
init|=
literal|0
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|constraint
operator|->
name|action_count
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|proposed_action
modifier|*
name|action
init|=
operator|&
name|constraint
operator|->
name|actions
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|action
operator|->
name|do_action
condition|)
name|removed
operator|+=
name|action
operator|->
name|removed_bytes
expr_stmt|;
block|}
if|if
condition|(
name|removed
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
name|text_action_add_proposed
parameter_list|(
name|text_action_list
modifier|*
name|l
parameter_list|,
specifier|const
name|ebb_constraint
modifier|*
name|ebb_table
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ebb_table
operator|->
name|action_count
condition|;
name|i
operator|++
control|)
block|{
name|proposed_action
modifier|*
name|action
init|=
operator|&
name|ebb_table
operator|->
name|actions
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|action
operator|->
name|do_action
condition|)
continue|continue;
switch|switch
condition|(
name|action
operator|->
name|action
condition|)
block|{
case|case
name|ta_remove_insn
case|:
case|case
name|ta_remove_longcall
case|:
case|case
name|ta_convert_longcall
case|:
case|case
name|ta_narrow_insn
case|:
case|case
name|ta_widen_insn
case|:
case|case
name|ta_fill
case|:
case|case
name|ta_remove_literal
case|:
name|text_action_add
argument_list|(
name|l
argument_list|,
name|action
operator|->
name|action
argument_list|,
name|sec
argument_list|,
name|action
operator|->
name|offset
argument_list|,
name|action
operator|->
name|removed_bytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|ta_none
case|:
break|break;
default|default:
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|int
name|compute_fill_extra_space
parameter_list|(
name|property_table_entry
modifier|*
name|entry
parameter_list|)
block|{
name|int
name|fill_extra_space
decl_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|XTENSA_PROP_UNREACHABLE
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|fill_extra_space
operator|=
name|entry
operator|->
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|XTENSA_PROP_ALIGN
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Fill bytes for alignment: 	 (2**n)-1 - (addr + (2**n)-1)& (2**n -1) */
name|int
name|pow
init|=
name|GET_XTENSA_PROP_ALIGNMENT
argument_list|(
name|entry
operator|->
name|flags
argument_list|)
decl_stmt|;
name|int
name|nsm
init|=
operator|(
literal|1
operator|<<
name|pow
operator|)
operator|-
literal|1
decl_stmt|;
name|bfd_vma
name|addr
init|=
name|entry
operator|->
name|address
operator|+
name|entry
operator|->
name|size
decl_stmt|;
name|bfd_vma
name|align_fill
init|=
name|nsm
operator|-
operator|(
operator|(
name|addr
operator|+
name|nsm
operator|)
operator|&
name|nsm
operator|)
decl_stmt|;
name|fill_extra_space
operator|+=
name|align_fill
expr_stmt|;
block|}
return|return
name|fill_extra_space
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* First relaxation pass.  */
end_comment

begin_comment
comment|/* If the section contains relaxable literals, check each literal to    see if it has the same value as another literal that has already    been seen, either in the current section or a previous one.  If so,    add an entry to the per-section list of removed literals.  The    actual changes are deferred until the next pass.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|compute_removed_literals
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|value_map_hash_table
modifier|*
name|values
parameter_list|)
block|{
name|xtensa_relax_info
modifier|*
name|relax_info
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|source_reloc
modifier|*
name|src_relocs
decl_stmt|,
modifier|*
name|rel
decl_stmt|;
name|bfd_boolean
name|ok
init|=
name|TRUE
decl_stmt|;
name|property_table_entry
modifier|*
name|prop_table
init|=
name|NULL
decl_stmt|;
name|int
name|ptblsize
decl_stmt|;
name|int
name|i
decl_stmt|,
name|prev_i
decl_stmt|;
name|bfd_boolean
name|last_loc_is_prev
init|=
name|FALSE
decl_stmt|;
name|bfd_vma
name|last_target_offset
init|=
literal|0
decl_stmt|;
name|section_cache_t
name|target_sec_cache
decl_stmt|;
name|bfd_size_type
name|sec_size
decl_stmt|;
name|init_section_cache
argument_list|(
operator|&
name|target_sec_cache
argument_list|)
expr_stmt|;
comment|/* Do nothing if it is not a relaxable literal section.  */
name|relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|relax_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relax_info
operator|->
name|is_relaxable_literal_section
condition|)
return|return
name|ok
return|;
name|internal_relocs
operator|=
name|retrieve_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
name|sec_size
operator|=
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|contents
operator|=
name|retrieve_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
operator|&&
name|sec_size
operator|!=
literal|0
condition|)
block|{
name|ok
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* Sort the source_relocs by target offset.  */
name|src_relocs
operator|=
name|relax_info
operator|->
name|src_relocs
expr_stmt|;
name|qsort
argument_list|(
name|src_relocs
argument_list|,
name|relax_info
operator|->
name|src_count
argument_list|,
sizeof|sizeof
argument_list|(
name|source_reloc
argument_list|)
argument_list|,
name|source_reloc_compare
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|internal_relocs
argument_list|,
name|sec
operator|->
name|reloc_count
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
argument_list|,
name|internal_reloc_compare
argument_list|)
expr_stmt|;
name|ptblsize
operator|=
name|xtensa_read_table_entries
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|&
name|prop_table
argument_list|,
name|XTENSA_PROP_SEC_NAME
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptblsize
operator|<
literal|0
condition|)
block|{
name|ok
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|prev_i
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|relax_info
operator|->
name|src_count
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|irel
init|=
name|NULL
decl_stmt|;
name|rel
operator|=
operator|&
name|src_relocs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|get_l32r_opcode
argument_list|()
operator|!=
name|rel
operator|->
name|opcode
condition|)
continue|continue;
name|irel
operator|=
name|get_irel_at_offset
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|,
name|rel
operator|->
name|r_rel
operator|.
name|target_offset
argument_list|)
expr_stmt|;
comment|/* If the relocation on this is not a simple R_XTENSA_32 or 	 R_XTENSA_PLT then do not consider it.  This may happen when 	 the difference of two symbols is used in a literal.  */
if|if
condition|(
name|irel
operator|&&
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_XTENSA_32
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_XTENSA_PLT
operator|)
condition|)
continue|continue;
comment|/* If the target_offset for this relocation is the same as the 	 previous relocation, then we've already considered whether the 	 literal can be coalesced.  Skip to the next one....  */
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
name|prev_i
operator|!=
operator|-
literal|1
operator|&&
name|src_relocs
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|r_rel
operator|.
name|target_offset
operator|==
name|rel
operator|->
name|r_rel
operator|.
name|target_offset
condition|)
continue|continue;
name|prev_i
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|last_loc_is_prev
operator|&&
name|last_target_offset
operator|+
literal|4
operator|!=
name|rel
operator|->
name|r_rel
operator|.
name|target_offset
condition|)
name|last_loc_is_prev
operator|=
name|FALSE
expr_stmt|;
comment|/* Check if the relocation was from an L32R that is being removed 	 because a CALLX was converted to a direct CALL, and check if 	 there are no other relocations to the literal.  */
if|if
condition|(
name|is_removable_literal
argument_list|(
name|rel
argument_list|,
name|i
argument_list|,
name|src_relocs
argument_list|,
name|relax_info
operator|->
name|src_count
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|remove_dead_literal
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
argument_list|,
name|internal_relocs
argument_list|,
name|irel
argument_list|,
name|rel
argument_list|,
name|prop_table
argument_list|,
name|ptblsize
argument_list|)
condition|)
block|{
name|ok
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|last_target_offset
operator|=
name|rel
operator|->
name|r_rel
operator|.
name|target_offset
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|identify_literal_placement
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
name|link_info
argument_list|,
name|values
argument_list|,
operator|&
name|last_loc_is_prev
argument_list|,
name|irel
argument_list|,
name|relax_info
operator|->
name|src_count
operator|-
name|i
argument_list|,
name|rel
argument_list|,
name|prop_table
argument_list|,
name|ptblsize
argument_list|,
operator|&
name|target_sec_cache
argument_list|,
name|rel
operator|->
name|is_abs_literal
argument_list|)
condition|)
block|{
name|ok
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|last_target_offset
operator|=
name|rel
operator|->
name|r_rel
operator|.
name|target_offset
expr_stmt|;
block|}
if|#
directive|if
name|DEBUG
name|print_removed_literals
argument_list|(
name|stderr
argument_list|,
operator|&
name|relax_info
operator|->
name|removed_list
argument_list|)
expr_stmt|;
name|print_action_list
argument_list|(
name|stderr
argument_list|,
operator|&
name|relax_info
operator|->
name|action_list
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|error_return
label|:
if|if
condition|(
name|prop_table
condition|)
name|free
argument_list|(
name|prop_table
argument_list|)
expr_stmt|;
name|clear_section_cache
argument_list|(
operator|&
name|target_sec_cache
argument_list|)
expr_stmt|;
name|release_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|release_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_function
specifier|static
name|Elf_Internal_Rela
modifier|*
name|get_irel_at_offset
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
parameter_list|,
name|bfd_vma
name|offset
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
name|unsigned
name|r_type
decl_stmt|;
name|Elf_Internal_Rela
name|key
decl_stmt|;
if|if
condition|(
operator|!
name|internal_relocs
condition|)
return|return
name|NULL
return|;
name|key
operator|.
name|r_offset
operator|=
name|offset
expr_stmt|;
name|irel
operator|=
name|bsearch
argument_list|(
operator|&
name|key
argument_list|,
name|internal_relocs
argument_list|,
name|sec
operator|->
name|reloc_count
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
argument_list|,
name|internal_reloc_matches
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|irel
condition|)
return|return
name|NULL
return|;
comment|/* bsearch does not guarantee which will be returned if there are      multiple matches.  We need the first that is not an alignment.  */
name|i
operator|=
name|irel
operator|-
name|internal_relocs
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|internal_relocs
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|r_offset
operator|!=
name|offset
condition|)
break|break;
name|i
operator|--
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|irel
operator|=
operator|&
name|internal_relocs
index|[
name|i
index|]
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|==
name|offset
operator|&&
name|r_type
operator|!=
name|R_XTENSA_NONE
condition|)
return|return
name|irel
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|is_removable_literal
parameter_list|(
specifier|const
name|source_reloc
modifier|*
name|rel
parameter_list|,
name|int
name|i
parameter_list|,
specifier|const
name|source_reloc
modifier|*
name|src_relocs
parameter_list|,
name|int
name|src_count
parameter_list|)
block|{
specifier|const
name|source_reloc
modifier|*
name|curr_rel
decl_stmt|;
if|if
condition|(
operator|!
name|rel
operator|->
name|is_null
condition|)
return|return
name|FALSE
return|;
for|for
control|(
operator|++
name|i
init|;
name|i
operator|<
name|src_count
condition|;
operator|++
name|i
control|)
block|{
name|curr_rel
operator|=
operator|&
name|src_relocs
index|[
name|i
index|]
expr_stmt|;
comment|/* If all others have the same target offset....  */
if|if
condition|(
name|curr_rel
operator|->
name|r_rel
operator|.
name|target_offset
operator|!=
name|rel
operator|->
name|r_rel
operator|.
name|target_offset
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|curr_rel
operator|->
name|is_null
operator|&&
operator|!
name|xtensa_is_property_section
argument_list|(
name|curr_rel
operator|->
name|source_sec
argument_list|)
operator|&&
operator|!
operator|(
name|curr_rel
operator|->
name|source_sec
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|remove_dead_literal
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|irel
parameter_list|,
name|source_reloc
modifier|*
name|rel
parameter_list|,
name|property_table_entry
modifier|*
name|prop_table
parameter_list|,
name|int
name|ptblsize
parameter_list|)
block|{
name|property_table_entry
modifier|*
name|entry
decl_stmt|;
name|xtensa_relax_info
modifier|*
name|relax_info
decl_stmt|;
name|relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relax_info
condition|)
return|return
name|FALSE
return|;
name|entry
operator|=
name|elf_xtensa_find_property_entry
argument_list|(
name|prop_table
argument_list|,
name|ptblsize
argument_list|,
name|sec
operator|->
name|vma
operator|+
name|rel
operator|->
name|r_rel
operator|.
name|target_offset
argument_list|)
expr_stmt|;
comment|/* Mark the unused literal so that it will be removed.  */
name|add_removed_literal
argument_list|(
operator|&
name|relax_info
operator|->
name|removed_list
argument_list|,
operator|&
name|rel
operator|->
name|r_rel
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|text_action_add
argument_list|(
operator|&
name|relax_info
operator|->
name|action_list
argument_list|,
name|ta_remove_literal
argument_list|,
name|sec
argument_list|,
name|rel
operator|->
name|r_rel
operator|.
name|target_offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* If the section is 4-byte aligned, do not add fill.  */
if|if
condition|(
name|sec
operator|->
name|alignment_power
operator|>
literal|2
condition|)
block|{
name|int
name|fill_extra_space
decl_stmt|;
name|bfd_vma
name|entry_sec_offset
decl_stmt|;
name|text_action
modifier|*
name|fa
decl_stmt|;
name|property_table_entry
modifier|*
name|the_add_entry
decl_stmt|;
name|int
name|removed_diff
decl_stmt|;
if|if
condition|(
name|entry
condition|)
name|entry_sec_offset
operator|=
name|entry
operator|->
name|address
operator|-
name|sec
operator|->
name|vma
operator|+
name|entry
operator|->
name|size
expr_stmt|;
else|else
name|entry_sec_offset
operator|=
name|rel
operator|->
name|r_rel
operator|.
name|target_offset
operator|+
literal|4
expr_stmt|;
comment|/* If the literal range is at the end of the section, 	 do not add fill.  */
name|the_add_entry
operator|=
name|elf_xtensa_find_property_entry
argument_list|(
name|prop_table
argument_list|,
name|ptblsize
argument_list|,
name|entry_sec_offset
argument_list|)
expr_stmt|;
name|fill_extra_space
operator|=
name|compute_fill_extra_space
argument_list|(
name|the_add_entry
argument_list|)
expr_stmt|;
name|fa
operator|=
name|find_fill_action
argument_list|(
operator|&
name|relax_info
operator|->
name|action_list
argument_list|,
name|sec
argument_list|,
name|entry_sec_offset
argument_list|)
expr_stmt|;
name|removed_diff
operator|=
name|compute_removed_action_diff
argument_list|(
name|fa
argument_list|,
name|sec
argument_list|,
name|entry_sec_offset
argument_list|,
operator|-
literal|4
argument_list|,
name|fill_extra_space
argument_list|)
expr_stmt|;
if|if
condition|(
name|fa
condition|)
name|adjust_fill_action
argument_list|(
name|fa
argument_list|,
name|removed_diff
argument_list|)
expr_stmt|;
else|else
name|text_action_add
argument_list|(
operator|&
name|relax_info
operator|->
name|action_list
argument_list|,
name|ta_fill
argument_list|,
name|sec
argument_list|,
name|entry_sec_offset
argument_list|,
name|removed_diff
argument_list|)
expr_stmt|;
block|}
comment|/* Zero out the relocation on this literal location.  */
if|if
condition|(
name|irel
condition|)
block|{
if|if
condition|(
name|elf_hash_table
argument_list|(
name|link_info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
name|shrink_dynamic_reloc_sections
argument_list|(
name|link_info
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_XTENSA_NONE
argument_list|)
expr_stmt|;
name|pin_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
comment|/* Do not modify "last_loc_is_prev".  */
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|identify_literal_placement
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|value_map_hash_table
modifier|*
name|values
parameter_list|,
name|bfd_boolean
modifier|*
name|last_loc_is_prev_p
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|irel
parameter_list|,
name|int
name|remaining_src_rels
parameter_list|,
name|source_reloc
modifier|*
name|rel
parameter_list|,
name|property_table_entry
modifier|*
name|prop_table
parameter_list|,
name|int
name|ptblsize
parameter_list|,
name|section_cache_t
modifier|*
name|target_sec_cache
parameter_list|,
name|bfd_boolean
name|is_abs_literal
parameter_list|)
block|{
name|literal_value
name|val
decl_stmt|;
name|value_map
modifier|*
name|val_map
decl_stmt|;
name|xtensa_relax_info
modifier|*
name|relax_info
decl_stmt|;
name|bfd_boolean
name|literal_placed
init|=
name|FALSE
decl_stmt|;
name|r_reloc
name|r_rel
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
name|bfd_boolean
name|final_static_link
decl_stmt|;
name|bfd_size_type
name|sec_size
decl_stmt|;
name|relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relax_info
condition|)
return|return
name|FALSE
return|;
name|sec_size
operator|=
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|final_static_link
operator|=
operator|(
operator|!
name|link_info
operator|->
name|relocatable
operator|&&
operator|!
name|elf_hash_table
argument_list|(
name|link_info
argument_list|)
operator|->
name|dynamic_sections_created
operator|)
expr_stmt|;
comment|/* The placement algorithm first checks to see if the literal is      already in the value map.  If so and the value map is reachable      from all uses, then the literal is moved to that location.  If      not, then we identify the last location where a fresh literal was      placed.  If the literal can be safely moved there, then we do so.      If not, then we assume that the literal is not to move and leave      the literal where it is, marking it as the last literal      location.  */
comment|/* Find the literal value.  */
name|value
operator|=
literal|0
expr_stmt|;
name|r_reloc_init
argument_list|(
operator|&
name|r_rel
argument_list|,
name|abfd
argument_list|,
name|irel
argument_list|,
name|contents
argument_list|,
name|sec_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|irel
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|rel
operator|->
name|r_rel
operator|.
name|target_offset
operator|<
name|sec_size
argument_list|)
expr_stmt|;
name|value
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_rel
operator|.
name|target_offset
argument_list|)
expr_stmt|;
block|}
name|init_literal_value
argument_list|(
operator|&
name|val
argument_list|,
operator|&
name|r_rel
argument_list|,
name|value
argument_list|,
name|is_abs_literal
argument_list|)
expr_stmt|;
comment|/* Check if we've seen another literal with the same value that      is in the same output section.  */
name|val_map
operator|=
name|value_map_get_cached_value
argument_list|(
name|values
argument_list|,
operator|&
name|val
argument_list|,
name|final_static_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|val_map
operator|&&
operator|(
name|r_reloc_get_section
argument_list|(
operator|&
name|val_map
operator|->
name|loc
argument_list|)
operator|->
name|output_section
operator|==
name|sec
operator|->
name|output_section
operator|)
operator|&&
name|relocations_reach
argument_list|(
name|rel
argument_list|,
name|remaining_src_rels
argument_list|,
operator|&
name|val_map
operator|->
name|loc
argument_list|)
operator|&&
name|coalesce_shared_literal
argument_list|(
name|sec
argument_list|,
name|rel
argument_list|,
name|prop_table
argument_list|,
name|ptblsize
argument_list|,
name|val_map
argument_list|)
condition|)
block|{
comment|/* No change to last_loc_is_prev.  */
name|literal_placed
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* For relocatable links, do not try to move literals.  To do it      correctly might increase the number of relocations in an input      section making the default relocatable linking fail.  */
if|if
condition|(
operator|!
name|link_info
operator|->
name|relocatable
operator|&&
operator|!
name|literal_placed
operator|&&
name|values
operator|->
name|has_last_loc
operator|&&
operator|!
operator|(
operator|*
name|last_loc_is_prev_p
operator|)
condition|)
block|{
name|asection
modifier|*
name|target_sec
init|=
name|r_reloc_get_section
argument_list|(
operator|&
name|values
operator|->
name|last_loc
argument_list|)
decl_stmt|;
if|if
condition|(
name|target_sec
operator|&&
name|target_sec
operator|->
name|output_section
operator|==
name|sec
operator|->
name|output_section
condition|)
block|{
comment|/* Increment the virtual offset.  */
name|r_reloc
name|try_loc
init|=
name|values
operator|->
name|last_loc
decl_stmt|;
name|try_loc
operator|.
name|virtual_offset
operator|+=
literal|4
expr_stmt|;
comment|/* There is a last loc that was in the same output section.  */
if|if
condition|(
name|relocations_reach
argument_list|(
name|rel
argument_list|,
name|remaining_src_rels
argument_list|,
operator|&
name|try_loc
argument_list|)
operator|&&
name|move_shared_literal
argument_list|(
name|sec
argument_list|,
name|link_info
argument_list|,
name|rel
argument_list|,
name|prop_table
argument_list|,
name|ptblsize
argument_list|,
operator|&
name|try_loc
argument_list|,
operator|&
name|val
argument_list|,
name|target_sec_cache
argument_list|)
condition|)
block|{
name|values
operator|->
name|last_loc
operator|.
name|virtual_offset
operator|+=
literal|4
expr_stmt|;
name|literal_placed
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|val_map
condition|)
name|val_map
operator|=
name|add_value_map
argument_list|(
name|values
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|try_loc
argument_list|,
name|final_static_link
argument_list|)
expr_stmt|;
else|else
name|val_map
operator|->
name|loc
operator|=
name|try_loc
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|literal_placed
condition|)
block|{
comment|/* Nothing worked, leave the literal alone but update the last loc.  */
name|values
operator|->
name|has_last_loc
operator|=
name|TRUE
expr_stmt|;
name|values
operator|->
name|last_loc
operator|=
name|rel
operator|->
name|r_rel
expr_stmt|;
if|if
condition|(
operator|!
name|val_map
condition|)
name|val_map
operator|=
name|add_value_map
argument_list|(
name|values
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|rel
operator|->
name|r_rel
argument_list|,
name|final_static_link
argument_list|)
expr_stmt|;
else|else
name|val_map
operator|->
name|loc
operator|=
name|rel
operator|->
name|r_rel
expr_stmt|;
operator|*
name|last_loc_is_prev_p
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Check if the original relocations (presumably on L32R instructions)    identified by reloc[0..N] can be changed to reference the literal    identified by r_rel.  If r_rel is out of range for any of the    original relocations, then we don't want to coalesce the original    literal with the one at r_rel.  We only check reloc[0..N], where the    offsets are all the same as for reloc[0] (i.e., they're all    referencing the same literal) and where N is also bounded by the    number of remaining entries in the "reloc" array.  The "reloc" array    is sorted by target offset so we know all the entries for the same    literal will be contiguous.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|relocations_reach
parameter_list|(
name|source_reloc
modifier|*
name|reloc
parameter_list|,
name|int
name|remaining_relocs
parameter_list|,
specifier|const
name|r_reloc
modifier|*
name|r_rel
parameter_list|)
block|{
name|bfd_vma
name|from_offset
decl_stmt|,
name|source_address
decl_stmt|,
name|dest_address
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|r_reloc_is_defined
argument_list|(
name|r_rel
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|sec
operator|=
name|r_reloc_get_section
argument_list|(
name|r_rel
argument_list|)
expr_stmt|;
name|from_offset
operator|=
name|reloc
index|[
literal|0
index|]
operator|.
name|r_rel
operator|.
name|target_offset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|remaining_relocs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reloc
index|[
name|i
index|]
operator|.
name|r_rel
operator|.
name|target_offset
operator|!=
name|from_offset
condition|)
break|break;
comment|/* Ignore relocations that have been removed.  */
if|if
condition|(
name|reloc
index|[
name|i
index|]
operator|.
name|is_null
condition|)
continue|continue;
comment|/* The original and new output section for these must be the same          in order to coalesce.  */
if|if
condition|(
name|r_reloc_get_section
argument_list|(
operator|&
name|reloc
index|[
name|i
index|]
operator|.
name|r_rel
argument_list|)
operator|->
name|output_section
operator|!=
name|sec
operator|->
name|output_section
condition|)
return|return
name|FALSE
return|;
comment|/* Absolute literals in the same output section can always be 	 combined.  */
if|if
condition|(
name|reloc
index|[
name|i
index|]
operator|.
name|is_abs_literal
condition|)
continue|continue;
comment|/* A literal with no PC-relative relocations can be moved anywhere.  */
if|if
condition|(
name|reloc
index|[
name|i
index|]
operator|.
name|opnd
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Otherwise, check to see that it fits.  */
name|source_address
operator|=
operator|(
name|reloc
index|[
name|i
index|]
operator|.
name|source_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|reloc
index|[
name|i
index|]
operator|.
name|source_sec
operator|->
name|output_offset
operator|+
name|reloc
index|[
name|i
index|]
operator|.
name|r_rel
operator|.
name|rela
operator|.
name|r_offset
operator|)
expr_stmt|;
name|dest_address
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|r_rel
operator|->
name|target_offset
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|pcrel_reloc_fits
argument_list|(
name|reloc
index|[
name|i
index|]
operator|.
name|opcode
argument_list|,
name|reloc
index|[
name|i
index|]
operator|.
name|opnd
argument_list|,
name|source_address
argument_list|,
name|dest_address
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Move a literal to another literal location because it is    the same as the other literal value.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|coalesce_shared_literal
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|source_reloc
modifier|*
name|rel
parameter_list|,
name|property_table_entry
modifier|*
name|prop_table
parameter_list|,
name|int
name|ptblsize
parameter_list|,
name|value_map
modifier|*
name|val_map
parameter_list|)
block|{
name|property_table_entry
modifier|*
name|entry
decl_stmt|;
name|text_action
modifier|*
name|fa
decl_stmt|;
name|property_table_entry
modifier|*
name|the_add_entry
decl_stmt|;
name|int
name|removed_diff
decl_stmt|;
name|xtensa_relax_info
modifier|*
name|relax_info
decl_stmt|;
name|relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relax_info
condition|)
return|return
name|FALSE
return|;
name|entry
operator|=
name|elf_xtensa_find_property_entry
argument_list|(
name|prop_table
argument_list|,
name|ptblsize
argument_list|,
name|sec
operator|->
name|vma
operator|+
name|rel
operator|->
name|r_rel
operator|.
name|target_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|&&
operator|(
name|entry
operator|->
name|flags
operator|&
name|XTENSA_PROP_INSN_NO_TRANSFORM
operator|)
condition|)
return|return
name|TRUE
return|;
comment|/* Mark that the literal will be coalesced.  */
name|add_removed_literal
argument_list|(
operator|&
name|relax_info
operator|->
name|removed_list
argument_list|,
operator|&
name|rel
operator|->
name|r_rel
argument_list|,
operator|&
name|val_map
operator|->
name|loc
argument_list|)
expr_stmt|;
name|text_action_add
argument_list|(
operator|&
name|relax_info
operator|->
name|action_list
argument_list|,
name|ta_remove_literal
argument_list|,
name|sec
argument_list|,
name|rel
operator|->
name|r_rel
operator|.
name|target_offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* If the section is 4-byte aligned, do not add fill.  */
if|if
condition|(
name|sec
operator|->
name|alignment_power
operator|>
literal|2
condition|)
block|{
name|int
name|fill_extra_space
decl_stmt|;
name|bfd_vma
name|entry_sec_offset
decl_stmt|;
if|if
condition|(
name|entry
condition|)
name|entry_sec_offset
operator|=
name|entry
operator|->
name|address
operator|-
name|sec
operator|->
name|vma
operator|+
name|entry
operator|->
name|size
expr_stmt|;
else|else
name|entry_sec_offset
operator|=
name|rel
operator|->
name|r_rel
operator|.
name|target_offset
operator|+
literal|4
expr_stmt|;
comment|/* If the literal range is at the end of the section, 	 do not add fill.  */
name|fill_extra_space
operator|=
literal|0
expr_stmt|;
name|the_add_entry
operator|=
name|elf_xtensa_find_property_entry
argument_list|(
name|prop_table
argument_list|,
name|ptblsize
argument_list|,
name|entry_sec_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_add_entry
operator|&&
operator|(
name|the_add_entry
operator|->
name|flags
operator|&
name|XTENSA_PROP_UNREACHABLE
operator|)
condition|)
name|fill_extra_space
operator|=
name|the_add_entry
operator|->
name|size
expr_stmt|;
name|fa
operator|=
name|find_fill_action
argument_list|(
operator|&
name|relax_info
operator|->
name|action_list
argument_list|,
name|sec
argument_list|,
name|entry_sec_offset
argument_list|)
expr_stmt|;
name|removed_diff
operator|=
name|compute_removed_action_diff
argument_list|(
name|fa
argument_list|,
name|sec
argument_list|,
name|entry_sec_offset
argument_list|,
operator|-
literal|4
argument_list|,
name|fill_extra_space
argument_list|)
expr_stmt|;
if|if
condition|(
name|fa
condition|)
name|adjust_fill_action
argument_list|(
name|fa
argument_list|,
name|removed_diff
argument_list|)
expr_stmt|;
else|else
name|text_action_add
argument_list|(
operator|&
name|relax_info
operator|->
name|action_list
argument_list|,
name|ta_fill
argument_list|,
name|sec
argument_list|,
name|entry_sec_offset
argument_list|,
name|removed_diff
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Move a literal to another location.  This may actually increase the    total amount of space used because of alignments so we need to do    this carefully.  Also, it may make a branch go out of range.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|move_shared_literal
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|source_reloc
modifier|*
name|rel
parameter_list|,
name|property_table_entry
modifier|*
name|prop_table
parameter_list|,
name|int
name|ptblsize
parameter_list|,
specifier|const
name|r_reloc
modifier|*
name|target_loc
parameter_list|,
specifier|const
name|literal_value
modifier|*
name|lit_value
parameter_list|,
name|section_cache_t
modifier|*
name|target_sec_cache
parameter_list|)
block|{
name|property_table_entry
modifier|*
name|the_add_entry
decl_stmt|,
modifier|*
name|src_entry
decl_stmt|,
modifier|*
name|target_entry
init|=
name|NULL
decl_stmt|;
name|text_action
modifier|*
name|fa
decl_stmt|,
modifier|*
name|target_fa
decl_stmt|;
name|int
name|removed_diff
decl_stmt|;
name|xtensa_relax_info
modifier|*
name|relax_info
decl_stmt|,
modifier|*
name|target_relax_info
decl_stmt|;
name|asection
modifier|*
name|target_sec
decl_stmt|;
name|ebb_t
modifier|*
name|ebb
decl_stmt|;
name|ebb_constraint
name|ebb_table
decl_stmt|;
name|bfd_boolean
name|relocs_fit
decl_stmt|;
comment|/* If this routine always returns FALSE, the literals that cannot be      coalesced will not be moved.  */
if|if
condition|(
name|elf32xtensa_no_literal_movement
condition|)
return|return
name|FALSE
return|;
name|relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relax_info
condition|)
return|return
name|FALSE
return|;
name|target_sec
operator|=
name|r_reloc_get_section
argument_list|(
name|target_loc
argument_list|)
expr_stmt|;
name|target_relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|target_sec
argument_list|)
expr_stmt|;
comment|/* Literals to undefined sections may not be moved because they      must report an error.  */
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|target_sec
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|src_entry
operator|=
name|elf_xtensa_find_property_entry
argument_list|(
name|prop_table
argument_list|,
name|ptblsize
argument_list|,
name|sec
operator|->
name|vma
operator|+
name|rel
operator|->
name|r_rel
operator|.
name|target_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|section_cache_section
argument_list|(
name|target_sec_cache
argument_list|,
name|target_sec
argument_list|,
name|link_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|target_entry
operator|=
name|elf_xtensa_find_property_entry
argument_list|(
name|target_sec_cache
operator|->
name|ptbl
argument_list|,
name|target_sec_cache
operator|->
name|pte_count
argument_list|,
name|target_sec
operator|->
name|vma
operator|+
name|target_loc
operator|->
name|target_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_entry
condition|)
return|return
name|FALSE
return|;
comment|/* Make sure that we have not broken any branches.  */
name|relocs_fit
operator|=
name|FALSE
expr_stmt|;
name|init_ebb_constraint
argument_list|(
operator|&
name|ebb_table
argument_list|)
expr_stmt|;
name|ebb
operator|=
operator|&
name|ebb_table
operator|.
name|ebb
expr_stmt|;
name|init_ebb
argument_list|(
name|ebb
argument_list|,
name|target_sec_cache
operator|->
name|sec
argument_list|,
name|target_sec_cache
operator|->
name|contents
argument_list|,
name|target_sec_cache
operator|->
name|content_length
argument_list|,
name|target_sec_cache
operator|->
name|ptbl
argument_list|,
name|target_sec_cache
operator|->
name|pte_count
argument_list|,
name|target_sec_cache
operator|->
name|relocs
argument_list|,
name|target_sec_cache
operator|->
name|reloc_count
argument_list|)
expr_stmt|;
comment|/* Propose to add 4 bytes + worst-case alignment size increase to      destination.  */
name|ebb_propose_action
argument_list|(
operator|&
name|ebb_table
argument_list|,
name|EBB_NO_ALIGN
argument_list|,
literal|0
argument_list|,
name|ta_fill
argument_list|,
name|target_loc
operator|->
name|target_offset
argument_list|,
operator|-
literal|4
operator|-
operator|(
literal|1
operator|<<
name|target_sec
operator|->
name|alignment_power
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Check all of the PC-relative relocations to make sure they still fit.  */
name|relocs_fit
operator|=
name|check_section_ebb_pcrels_fit
argument_list|(
name|target_sec
operator|->
name|owner
argument_list|,
name|target_sec
argument_list|,
name|target_sec_cache
operator|->
name|contents
argument_list|,
name|target_sec_cache
operator|->
name|relocs
argument_list|,
operator|&
name|ebb_table
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relocs_fit
condition|)
return|return
name|FALSE
return|;
name|text_action_add_literal
argument_list|(
operator|&
name|target_relax_info
operator|->
name|action_list
argument_list|,
name|ta_add_literal
argument_list|,
name|target_loc
argument_list|,
name|lit_value
argument_list|,
operator|-
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_sec
operator|->
name|alignment_power
operator|>
literal|2
operator|&&
name|target_entry
operator|!=
name|src_entry
condition|)
block|{
comment|/* May need to add or remove some fill to maintain alignment.  */
name|int
name|fill_extra_space
decl_stmt|;
name|bfd_vma
name|entry_sec_offset
decl_stmt|;
name|entry_sec_offset
operator|=
name|target_entry
operator|->
name|address
operator|-
name|target_sec
operator|->
name|vma
operator|+
name|target_entry
operator|->
name|size
expr_stmt|;
comment|/* If the literal range is at the end of the section, 	 do not add fill.  */
name|fill_extra_space
operator|=
literal|0
expr_stmt|;
name|the_add_entry
operator|=
name|elf_xtensa_find_property_entry
argument_list|(
name|target_sec_cache
operator|->
name|ptbl
argument_list|,
name|target_sec_cache
operator|->
name|pte_count
argument_list|,
name|entry_sec_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_add_entry
operator|&&
operator|(
name|the_add_entry
operator|->
name|flags
operator|&
name|XTENSA_PROP_UNREACHABLE
operator|)
condition|)
name|fill_extra_space
operator|=
name|the_add_entry
operator|->
name|size
expr_stmt|;
name|target_fa
operator|=
name|find_fill_action
argument_list|(
operator|&
name|target_relax_info
operator|->
name|action_list
argument_list|,
name|target_sec
argument_list|,
name|entry_sec_offset
argument_list|)
expr_stmt|;
name|removed_diff
operator|=
name|compute_removed_action_diff
argument_list|(
name|target_fa
argument_list|,
name|target_sec
argument_list|,
name|entry_sec_offset
argument_list|,
literal|4
argument_list|,
name|fill_extra_space
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_fa
condition|)
name|adjust_fill_action
argument_list|(
name|target_fa
argument_list|,
name|removed_diff
argument_list|)
expr_stmt|;
else|else
name|text_action_add
argument_list|(
operator|&
name|target_relax_info
operator|->
name|action_list
argument_list|,
name|ta_fill
argument_list|,
name|target_sec
argument_list|,
name|entry_sec_offset
argument_list|,
name|removed_diff
argument_list|)
expr_stmt|;
block|}
comment|/* Mark that the literal will be moved to the new location.  */
name|add_removed_literal
argument_list|(
operator|&
name|relax_info
operator|->
name|removed_list
argument_list|,
operator|&
name|rel
operator|->
name|r_rel
argument_list|,
name|target_loc
argument_list|)
expr_stmt|;
comment|/* Remove the literal.  */
name|text_action_add
argument_list|(
operator|&
name|relax_info
operator|->
name|action_list
argument_list|,
name|ta_remove_literal
argument_list|,
name|sec
argument_list|,
name|rel
operator|->
name|r_rel
operator|.
name|target_offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* If the section is 4-byte aligned, do not add fill.  */
if|if
condition|(
name|sec
operator|->
name|alignment_power
operator|>
literal|2
operator|&&
name|target_entry
operator|!=
name|src_entry
condition|)
block|{
name|int
name|fill_extra_space
decl_stmt|;
name|bfd_vma
name|entry_sec_offset
decl_stmt|;
if|if
condition|(
name|src_entry
condition|)
name|entry_sec_offset
operator|=
name|src_entry
operator|->
name|address
operator|-
name|sec
operator|->
name|vma
operator|+
name|src_entry
operator|->
name|size
expr_stmt|;
else|else
name|entry_sec_offset
operator|=
name|rel
operator|->
name|r_rel
operator|.
name|target_offset
operator|+
literal|4
expr_stmt|;
comment|/* If the literal range is at the end of the section, 	 do not add fill.  */
name|fill_extra_space
operator|=
literal|0
expr_stmt|;
name|the_add_entry
operator|=
name|elf_xtensa_find_property_entry
argument_list|(
name|prop_table
argument_list|,
name|ptblsize
argument_list|,
name|entry_sec_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_add_entry
operator|&&
operator|(
name|the_add_entry
operator|->
name|flags
operator|&
name|XTENSA_PROP_UNREACHABLE
operator|)
condition|)
name|fill_extra_space
operator|=
name|the_add_entry
operator|->
name|size
expr_stmt|;
name|fa
operator|=
name|find_fill_action
argument_list|(
operator|&
name|relax_info
operator|->
name|action_list
argument_list|,
name|sec
argument_list|,
name|entry_sec_offset
argument_list|)
expr_stmt|;
name|removed_diff
operator|=
name|compute_removed_action_diff
argument_list|(
name|fa
argument_list|,
name|sec
argument_list|,
name|entry_sec_offset
argument_list|,
operator|-
literal|4
argument_list|,
name|fill_extra_space
argument_list|)
expr_stmt|;
if|if
condition|(
name|fa
condition|)
name|adjust_fill_action
argument_list|(
name|fa
argument_list|,
name|removed_diff
argument_list|)
expr_stmt|;
else|else
name|text_action_add
argument_list|(
operator|&
name|relax_info
operator|->
name|action_list
argument_list|,
name|ta_fill
argument_list|,
name|sec
argument_list|,
name|entry_sec_offset
argument_list|,
name|removed_diff
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Second relaxation pass.  */
end_comment

begin_comment
comment|/* Modify all of the relocations to point to the right spot, and if this    is a relaxable section, delete the unwanted literals and fix the    section size.  */
end_comment

begin_function
name|bfd_boolean
name|relax_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|xtensa_relax_info
modifier|*
name|relax_info
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_boolean
name|ok
init|=
name|TRUE
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|bfd_boolean
name|rv
init|=
name|FALSE
decl_stmt|;
name|bfd_boolean
name|virtual_action
decl_stmt|;
name|bfd_size_type
name|sec_size
decl_stmt|;
name|sec_size
operator|=
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|relax_info
argument_list|)
expr_stmt|;
comment|/* First translate any of the fixes that have been added already.  */
name|translate_section_fixes
argument_list|(
name|sec
argument_list|)
expr_stmt|;
comment|/* Handle property sections (e.g., literal tables) specially.  */
if|if
condition|(
name|xtensa_is_property_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|relax_info
operator|->
name|is_relaxable_literal_section
argument_list|)
expr_stmt|;
return|return
name|relax_property_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
argument_list|)
return|;
block|}
name|internal_relocs
operator|=
name|retrieve_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
name|contents
operator|=
name|retrieve_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
operator|&&
name|sec_size
operator|!=
literal|0
condition|)
block|{
name|ok
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|internal_relocs
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
name|xtensa_relax_info
modifier|*
name|target_relax_info
decl_stmt|;
name|bfd_vma
name|source_offset
decl_stmt|,
name|old_source_offset
decl_stmt|;
name|r_reloc
name|r_rel
decl_stmt|;
name|unsigned
name|r_type
decl_stmt|;
name|asection
modifier|*
name|target_sec
decl_stmt|;
comment|/* Locally change the source address. 	     Translate the target to the new target address. 	     If it points to this section and has been removed, 	     NULLify it. 	     Write it back.  */
name|irel
operator|=
operator|&
name|internal_relocs
index|[
name|i
index|]
expr_stmt|;
name|source_offset
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
name|old_source_offset
operator|=
name|source_offset
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_reloc_init
argument_list|(
operator|&
name|r_rel
argument_list|,
name|abfd
argument_list|,
name|irel
argument_list|,
name|contents
argument_list|,
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this section could have changed then we may need to 	     change the relocation's offset.  */
if|if
condition|(
name|relax_info
operator|->
name|is_relaxable_literal_section
operator|||
name|relax_info
operator|->
name|is_relaxable_asm_section
condition|)
block|{
if|if
condition|(
name|r_type
operator|!=
name|R_XTENSA_NONE
operator|&&
name|find_removed_literal
argument_list|(
operator|&
name|relax_info
operator|->
name|removed_list
argument_list|,
name|irel
operator|->
name|r_offset
argument_list|)
condition|)
block|{
comment|/* Remove this relocation.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|link_info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
name|shrink_dynamic_reloc_sections
argument_list|(
name|link_info
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_XTENSA_NONE
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_offset
operator|=
name|offset_with_removed_text
argument_list|(
operator|&
name|relax_info
operator|->
name|action_list
argument_list|,
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|pin_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_XTENSA_ASM_SIMPLIFY
condition|)
block|{
name|text_action
modifier|*
name|action
init|=
name|find_insn_action
argument_list|(
operator|&
name|relax_info
operator|->
name|action_list
argument_list|,
name|irel
operator|->
name|r_offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|action
operator|&&
operator|(
name|action
operator|->
name|action
operator|==
name|ta_convert_longcall
operator|||
name|action
operator|->
name|action
operator|==
name|ta_remove_longcall
operator|)
condition|)
block|{
name|bfd_reloc_status_type
name|retval
decl_stmt|;
name|char
modifier|*
name|error_message
init|=
name|NULL
decl_stmt|;
name|retval
operator|=
name|contract_asm_expansion
argument_list|(
name|contents
argument_list|,
name|sec_size
argument_list|,
name|irel
argument_list|,
operator|&
name|error_message
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|bfd_reloc_ok
condition|)
block|{
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|link_info
argument_list|,
name|error_message
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* Update the action so that the code that moves 			 the contents will do the right thing.  */
if|if
condition|(
name|action
operator|->
name|action
operator|==
name|ta_remove_longcall
condition|)
name|action
operator|->
name|action
operator|=
name|ta_remove_insn
expr_stmt|;
else|else
name|action
operator|->
name|action
operator|=
name|ta_none
expr_stmt|;
comment|/* Refresh the info in the r_rel.  */
name|r_reloc_init
argument_list|(
operator|&
name|r_rel
argument_list|,
name|abfd
argument_list|,
name|irel
argument_list|,
name|contents
argument_list|,
name|sec_size
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
block|}
block|}
name|source_offset
operator|=
name|offset_with_removed_text
argument_list|(
operator|&
name|relax_info
operator|->
name|action_list
argument_list|,
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_offset
operator|=
name|source_offset
expr_stmt|;
block|}
comment|/* If the target section could have changed then 	     we may need to change the relocation's target offset.  */
name|target_sec
operator|=
name|r_reloc_get_section
argument_list|(
operator|&
name|r_rel
argument_list|)
expr_stmt|;
name|target_relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|target_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_relax_info
operator|&&
operator|(
name|target_relax_info
operator|->
name|is_relaxable_literal_section
operator|||
name|target_relax_info
operator|->
name|is_relaxable_asm_section
operator|)
condition|)
block|{
name|r_reloc
name|new_reloc
decl_stmt|;
name|reloc_bfd_fix
modifier|*
name|fix
decl_stmt|;
name|bfd_vma
name|addend_displacement
decl_stmt|;
name|translate_reloc
argument_list|(
operator|&
name|r_rel
argument_list|,
operator|&
name|new_reloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_XTENSA_DIFF8
operator|||
name|r_type
operator|==
name|R_XTENSA_DIFF16
operator|||
name|r_type
operator|==
name|R_XTENSA_DIFF32
condition|)
block|{
name|bfd_vma
name|diff_value
init|=
literal|0
decl_stmt|,
name|new_end_offset
decl_stmt|,
name|diff_mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|<
name|old_source_offset
condition|)
block|{
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|link_info
argument_list|,
name|_
argument_list|(
literal|"invalid relocation address"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
name|old_source_offset
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_XTENSA_DIFF8
case|:
name|diff_value
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|&
name|contents
index|[
name|old_source_offset
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_XTENSA_DIFF16
case|:
name|diff_value
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
operator|&
name|contents
index|[
name|old_source_offset
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_XTENSA_DIFF32
case|:
name|diff_value
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|contents
index|[
name|old_source_offset
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|new_end_offset
operator|=
name|offset_with_removed_text
argument_list|(
operator|&
name|target_relax_info
operator|->
name|action_list
argument_list|,
name|r_rel
operator|.
name|target_offset
operator|+
name|diff_value
argument_list|)
expr_stmt|;
name|diff_value
operator|=
name|new_end_offset
operator|-
name|new_reloc
operator|.
name|target_offset
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_XTENSA_DIFF8
case|:
name|diff_mask
operator|=
literal|0xff
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|diff_value
argument_list|,
operator|&
name|contents
index|[
name|old_source_offset
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_XTENSA_DIFF16
case|:
name|diff_mask
operator|=
literal|0xffff
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|diff_value
argument_list|,
operator|&
name|contents
index|[
name|old_source_offset
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_XTENSA_DIFF32
case|:
name|diff_mask
operator|=
literal|0xffffffff
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|diff_value
argument_list|,
operator|&
name|contents
index|[
name|old_source_offset
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Check for overflow.  */
if|if
condition|(
operator|(
name|diff_value
operator|&
operator|~
name|diff_mask
operator|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|link_info
argument_list|,
name|_
argument_list|(
literal|"overflow after relaxation"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
name|old_source_offset
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|pin_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: If the relocation still references a section in 		 the same input file, the relocation should be modified 		 directly instead of adding a "fix" record.  */
name|addend_displacement
operator|=
name|new_reloc
operator|.
name|target_offset
operator|+
name|new_reloc
operator|.
name|virtual_offset
expr_stmt|;
name|fix
operator|=
name|reloc_bfd_fix_init
argument_list|(
name|sec
argument_list|,
name|source_offset
argument_list|,
name|r_type
argument_list|,
literal|0
argument_list|,
name|r_reloc_get_section
argument_list|(
operator|&
name|new_reloc
argument_list|)
argument_list|,
name|addend_displacement
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|add_fix
argument_list|(
name|sec
argument_list|,
name|fix
argument_list|)
expr_stmt|;
block|}
name|pin_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|relax_info
operator|->
name|is_relaxable_literal_section
operator|||
name|relax_info
operator|->
name|is_relaxable_asm_section
operator|)
operator|&&
name|relax_info
operator|->
name|action_list
operator|.
name|head
condition|)
block|{
comment|/* Walk through the planned actions and build up a table 	 of move, copy and fill records.  Use the move, copy and 	 fill records to perform the actions once.  */
name|bfd_size_type
name|size
init|=
name|sec
operator|->
name|size
decl_stmt|;
name|int
name|removed
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|final_size
decl_stmt|,
name|copy_size
decl_stmt|,
name|orig_insn_size
decl_stmt|;
name|bfd_byte
modifier|*
name|scratch
init|=
name|NULL
decl_stmt|;
name|bfd_byte
modifier|*
name|dup_contents
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|orig_size
init|=
name|size
decl_stmt|;
name|bfd_vma
name|orig_dot
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|orig_dot_copied
init|=
literal|0
decl_stmt|;
comment|/* Byte copied already from 					    orig dot in physical memory.  */
name|bfd_vma
name|orig_dot_vo
init|=
literal|0
decl_stmt|;
comment|/* Virtual offset from orig_dot.  */
name|bfd_vma
name|dup_dot
init|=
literal|0
decl_stmt|;
name|text_action
modifier|*
name|action
init|=
name|relax_info
operator|->
name|action_list
operator|.
name|head
decl_stmt|;
name|final_size
operator|=
name|sec
operator|->
name|size
expr_stmt|;
for|for
control|(
name|action
operator|=
name|relax_info
operator|->
name|action_list
operator|.
name|head
init|;
name|action
condition|;
name|action
operator|=
name|action
operator|->
name|next
control|)
block|{
name|final_size
operator|-=
name|action
operator|->
name|removed_bytes
expr_stmt|;
block|}
name|scratch
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|final_size
argument_list|)
expr_stmt|;
name|dup_contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|final_size
argument_list|)
expr_stmt|;
comment|/* The dot is the current fill location.  */
if|#
directive|if
name|DEBUG
name|print_action_list
argument_list|(
name|stderr
argument_list|,
operator|&
name|relax_info
operator|->
name|action_list
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|action
operator|=
name|relax_info
operator|->
name|action_list
operator|.
name|head
init|;
name|action
condition|;
name|action
operator|=
name|action
operator|->
name|next
control|)
block|{
name|virtual_action
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|action
operator|->
name|offset
operator|>
name|orig_dot
condition|)
block|{
name|orig_dot
operator|+=
name|orig_dot_copied
expr_stmt|;
name|orig_dot_copied
operator|=
literal|0
expr_stmt|;
name|orig_dot_vo
operator|=
literal|0
expr_stmt|;
comment|/* Out of the virtual world.  */
block|}
if|if
condition|(
name|action
operator|->
name|offset
operator|>
name|orig_dot
condition|)
block|{
name|copy_size
operator|=
name|action
operator|->
name|offset
operator|-
name|orig_dot
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|dup_contents
index|[
name|dup_dot
index|]
argument_list|,
operator|&
name|contents
index|[
name|orig_dot
index|]
argument_list|,
name|copy_size
argument_list|)
expr_stmt|;
name|orig_dot
operator|+=
name|copy_size
expr_stmt|;
name|dup_dot
operator|+=
name|copy_size
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|action
operator|->
name|offset
operator|==
name|orig_dot
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|->
name|offset
operator|<
name|orig_dot
condition|)
block|{
if|if
condition|(
name|action
operator|->
name|action
operator|==
name|ta_fill
operator|&&
name|action
operator|->
name|offset
operator|-
name|action
operator|->
name|removed_bytes
operator|==
name|orig_dot
condition|)
block|{
comment|/* This is OK because the fill only effects the dup_dot.  */
block|}
elseif|else
if|if
condition|(
name|action
operator|->
name|action
operator|==
name|ta_add_literal
condition|)
block|{
comment|/* TBD.  Might need to handle this.  */
block|}
block|}
if|if
condition|(
name|action
operator|->
name|offset
operator|==
name|orig_dot
condition|)
block|{
if|if
condition|(
name|action
operator|->
name|virtual_offset
operator|>
name|orig_dot_vo
condition|)
block|{
if|if
condition|(
name|orig_dot_vo
operator|==
literal|0
condition|)
block|{
comment|/* Need to copy virtual_offset bytes.  Probably four.  */
name|copy_size
operator|=
name|action
operator|->
name|virtual_offset
operator|-
name|orig_dot_vo
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|dup_contents
index|[
name|dup_dot
index|]
argument_list|,
operator|&
name|contents
index|[
name|orig_dot
index|]
argument_list|,
name|copy_size
argument_list|)
expr_stmt|;
name|orig_dot_copied
operator|=
name|copy_size
expr_stmt|;
name|dup_dot
operator|+=
name|copy_size
expr_stmt|;
block|}
name|virtual_action
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|BFD_ASSERT
argument_list|(
name|action
operator|->
name|virtual_offset
operator|<=
name|orig_dot_vo
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|action
operator|->
name|action
condition|)
block|{
case|case
name|ta_remove_literal
case|:
case|case
name|ta_remove_insn
case|:
name|BFD_ASSERT
argument_list|(
name|action
operator|->
name|removed_bytes
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|orig_dot
operator|+=
name|action
operator|->
name|removed_bytes
expr_stmt|;
break|break;
case|case
name|ta_narrow_insn
case|:
name|orig_insn_size
operator|=
literal|3
expr_stmt|;
name|copy_size
operator|=
literal|2
expr_stmt|;
name|memmove
argument_list|(
name|scratch
argument_list|,
operator|&
name|contents
index|[
name|orig_dot
index|]
argument_list|,
name|orig_insn_size
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|action
operator|->
name|removed_bytes
operator|==
literal|1
argument_list|)
expr_stmt|;
name|rv
operator|=
name|narrow_instruction
argument_list|(
name|scratch
argument_list|,
name|final_size
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|dup_contents
index|[
name|dup_dot
index|]
argument_list|,
name|scratch
argument_list|,
name|copy_size
argument_list|)
expr_stmt|;
name|orig_dot
operator|+=
name|orig_insn_size
expr_stmt|;
name|dup_dot
operator|+=
name|copy_size
expr_stmt|;
break|break;
case|case
name|ta_fill
case|:
if|if
condition|(
name|action
operator|->
name|removed_bytes
operator|>=
literal|0
condition|)
name|orig_dot
operator|+=
name|action
operator|->
name|removed_bytes
expr_stmt|;
else|else
block|{
comment|/* Already zeroed in dup_contents.  Just bump the 		     counters.  */
name|dup_dot
operator|+=
operator|(
operator|-
name|action
operator|->
name|removed_bytes
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|ta_none
case|:
name|BFD_ASSERT
argument_list|(
name|action
operator|->
name|removed_bytes
operator|==
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ta_convert_longcall
case|:
case|case
name|ta_remove_longcall
case|:
comment|/* These will be removed or converted before we get here.  */
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ta_widen_insn
case|:
name|orig_insn_size
operator|=
literal|2
expr_stmt|;
name|copy_size
operator|=
literal|3
expr_stmt|;
name|memmove
argument_list|(
name|scratch
argument_list|,
operator|&
name|contents
index|[
name|orig_dot
index|]
argument_list|,
name|orig_insn_size
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|action
operator|->
name|removed_bytes
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rv
operator|=
name|widen_instruction
argument_list|(
name|scratch
argument_list|,
name|final_size
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|dup_contents
index|[
name|dup_dot
index|]
argument_list|,
name|scratch
argument_list|,
name|copy_size
argument_list|)
expr_stmt|;
name|orig_dot
operator|+=
name|orig_insn_size
expr_stmt|;
name|dup_dot
operator|+=
name|copy_size
expr_stmt|;
break|break;
case|case
name|ta_add_literal
case|:
name|orig_insn_size
operator|=
literal|0
expr_stmt|;
name|copy_size
operator|=
literal|4
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|action
operator|->
name|removed_bytes
operator|==
operator|-
literal|4
argument_list|)
expr_stmt|;
comment|/* TBD -- place the literal value here and insert 		 into the table.  */
name|memset
argument_list|(
operator|&
name|dup_contents
index|[
name|dup_dot
index|]
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pin_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
name|pin_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|move_literal
argument_list|(
name|abfd
argument_list|,
name|link_info
argument_list|,
name|sec
argument_list|,
name|dup_dot
argument_list|,
name|dup_contents
argument_list|,
name|relax_info
argument_list|,
operator|&
name|internal_relocs
argument_list|,
operator|&
name|action
operator|->
name|value
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|virtual_action
condition|)
name|orig_dot_vo
operator|+=
name|copy_size
expr_stmt|;
name|orig_dot
operator|+=
name|orig_insn_size
expr_stmt|;
name|dup_dot
operator|+=
name|copy_size
expr_stmt|;
break|break;
default|default:
comment|/* Not implemented yet.  */
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|size
operator|-=
name|action
operator|->
name|removed_bytes
expr_stmt|;
name|removed
operator|+=
name|action
operator|->
name|removed_bytes
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dup_dot
operator|<=
name|final_size
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|orig_dot
operator|<=
name|orig_size
argument_list|)
expr_stmt|;
block|}
name|orig_dot
operator|+=
name|orig_dot_copied
expr_stmt|;
name|orig_dot_copied
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|orig_dot
operator|!=
name|orig_size
condition|)
block|{
name|copy_size
operator|=
name|orig_size
operator|-
name|orig_dot
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|orig_size
operator|>
name|orig_dot
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dup_dot
operator|+
name|copy_size
operator|==
name|final_size
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|dup_contents
index|[
name|dup_dot
index|]
argument_list|,
operator|&
name|contents
index|[
name|orig_dot
index|]
argument_list|,
name|copy_size
argument_list|)
expr_stmt|;
name|orig_dot
operator|+=
name|copy_size
expr_stmt|;
name|dup_dot
operator|+=
name|copy_size
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|orig_size
operator|==
name|orig_dot
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|final_size
operator|==
name|dup_dot
argument_list|)
expr_stmt|;
comment|/* Move the dup_contents back.  */
if|if
condition|(
name|final_size
operator|>
name|orig_size
condition|)
block|{
comment|/* Contents need to be reallocated.  Swap the dup_contents into 	     contents.  */
name|sec
operator|->
name|contents
operator|=
name|dup_contents
expr_stmt|;
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
name|contents
operator|=
name|dup_contents
expr_stmt|;
name|pin_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|final_size
operator|<=
name|orig_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|contents
argument_list|,
literal|0
argument_list|,
name|orig_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|contents
argument_list|,
name|dup_contents
argument_list|,
name|final_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dup_contents
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|scratch
argument_list|)
expr_stmt|;
name|pin_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|sec
operator|->
name|size
operator|=
name|final_size
expr_stmt|;
block|}
name|error_return
label|:
name|release_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
name|release_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|translate_section_fixes
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|)
block|{
name|xtensa_relax_info
modifier|*
name|relax_info
decl_stmt|;
name|reloc_bfd_fix
modifier|*
name|r
decl_stmt|;
name|relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relax_info
condition|)
return|return
name|TRUE
return|;
for|for
control|(
name|r
operator|=
name|relax_info
operator|->
name|fix_list
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|translate_reloc_bfd_fix
argument_list|(
name|r
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Translate a fix given the mapping in the relax info for the target    section.  If it has already been translated, no work is required.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|translate_reloc_bfd_fix
parameter_list|(
name|reloc_bfd_fix
modifier|*
name|fix
parameter_list|)
block|{
name|reloc_bfd_fix
name|new_fix
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|xtensa_relax_info
modifier|*
name|relax_info
decl_stmt|;
name|removed_literal
modifier|*
name|removed
decl_stmt|;
name|bfd_vma
name|new_offset
decl_stmt|,
name|target_offset
decl_stmt|;
if|if
condition|(
name|fix
operator|->
name|translated
condition|)
return|return
name|TRUE
return|;
name|sec
operator|=
name|fix
operator|->
name|target_sec
expr_stmt|;
name|target_offset
operator|=
name|fix
operator|->
name|target_offset
expr_stmt|;
name|relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relax_info
condition|)
block|{
name|fix
operator|->
name|translated
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|new_fix
operator|=
operator|*
name|fix
expr_stmt|;
comment|/* The fix does not need to be translated if the section cannot change.  */
if|if
condition|(
operator|!
name|relax_info
operator|->
name|is_relaxable_literal_section
operator|&&
operator|!
name|relax_info
operator|->
name|is_relaxable_asm_section
condition|)
block|{
name|fix
operator|->
name|translated
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* If the literal has been moved and this relocation was on an      opcode, then the relocation should move to the new literal      location.  Otherwise, the relocation should move within the      section.  */
name|removed
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|is_operand_relocation
argument_list|(
name|fix
operator|->
name|src_type
argument_list|)
condition|)
block|{
comment|/* Check if the original relocation is against a literal being 	 removed.  */
name|removed
operator|=
name|find_removed_literal
argument_list|(
operator|&
name|relax_info
operator|->
name|removed_list
argument_list|,
name|target_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|removed
condition|)
block|{
name|asection
modifier|*
name|new_sec
decl_stmt|;
comment|/* The fact that there is still a relocation to this literal indicates 	 that the literal is being coalesced, not simply removed.  */
name|BFD_ASSERT
argument_list|(
name|removed
operator|->
name|to
operator|.
name|abfd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* This was moved to some other address (possibly another section).  */
name|new_sec
operator|=
name|r_reloc_get_section
argument_list|(
operator|&
name|removed
operator|->
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_sec
operator|!=
name|sec
condition|)
block|{
name|sec
operator|=
name|new_sec
expr_stmt|;
name|relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relax_info
operator|||
operator|(
operator|!
name|relax_info
operator|->
name|is_relaxable_literal_section
operator|&&
operator|!
name|relax_info
operator|->
name|is_relaxable_asm_section
operator|)
condition|)
block|{
name|target_offset
operator|=
name|removed
operator|->
name|to
operator|.
name|target_offset
expr_stmt|;
name|new_fix
operator|.
name|target_sec
operator|=
name|new_sec
expr_stmt|;
name|new_fix
operator|.
name|target_offset
operator|=
name|target_offset
expr_stmt|;
name|new_fix
operator|.
name|translated
operator|=
name|TRUE
expr_stmt|;
operator|*
name|fix
operator|=
name|new_fix
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
name|target_offset
operator|=
name|removed
operator|->
name|to
operator|.
name|target_offset
expr_stmt|;
name|new_fix
operator|.
name|target_sec
operator|=
name|new_sec
expr_stmt|;
block|}
comment|/* The target address may have been moved within its section.  */
name|new_offset
operator|=
name|offset_with_removed_text
argument_list|(
operator|&
name|relax_info
operator|->
name|action_list
argument_list|,
name|target_offset
argument_list|)
expr_stmt|;
name|new_fix
operator|.
name|target_offset
operator|=
name|new_offset
expr_stmt|;
name|new_fix
operator|.
name|target_offset
operator|=
name|new_offset
expr_stmt|;
name|new_fix
operator|.
name|translated
operator|=
name|TRUE
expr_stmt|;
operator|*
name|fix
operator|=
name|new_fix
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Fix up a relocation to take account of removed literals.  */
end_comment

begin_function
specifier|static
name|void
name|translate_reloc
parameter_list|(
specifier|const
name|r_reloc
modifier|*
name|orig_rel
parameter_list|,
name|r_reloc
modifier|*
name|new_rel
parameter_list|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|xtensa_relax_info
modifier|*
name|relax_info
decl_stmt|;
name|removed_literal
modifier|*
name|removed
decl_stmt|;
name|bfd_vma
name|new_offset
decl_stmt|,
name|target_offset
decl_stmt|,
name|removed_bytes
decl_stmt|;
operator|*
name|new_rel
operator|=
operator|*
name|orig_rel
expr_stmt|;
if|if
condition|(
operator|!
name|r_reloc_is_defined
argument_list|(
name|orig_rel
argument_list|)
condition|)
return|return;
name|sec
operator|=
name|r_reloc_get_section
argument_list|(
name|orig_rel
argument_list|)
expr_stmt|;
name|relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|relax_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relax_info
operator|->
name|is_relaxable_literal_section
operator|&&
operator|!
name|relax_info
operator|->
name|is_relaxable_asm_section
condition|)
return|return;
name|target_offset
operator|=
name|orig_rel
operator|->
name|target_offset
expr_stmt|;
name|removed
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|is_operand_relocation
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|orig_rel
operator|->
name|rela
operator|.
name|r_info
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Check if the original relocation is against a literal being 	 removed.  */
name|removed
operator|=
name|find_removed_literal
argument_list|(
operator|&
name|relax_info
operator|->
name|removed_list
argument_list|,
name|target_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|removed
operator|&&
name|removed
operator|->
name|to
operator|.
name|abfd
condition|)
block|{
name|asection
modifier|*
name|new_sec
decl_stmt|;
comment|/* The fact that there is still a relocation to this literal indicates 	 that the literal is being coalesced, not simply removed.  */
name|BFD_ASSERT
argument_list|(
name|removed
operator|->
name|to
operator|.
name|abfd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* This was moved to some other address 	 (possibly in another section).  */
operator|*
name|new_rel
operator|=
name|removed
operator|->
name|to
expr_stmt|;
name|new_sec
operator|=
name|r_reloc_get_section
argument_list|(
name|new_rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_sec
operator|!=
name|sec
condition|)
block|{
name|sec
operator|=
name|new_sec
expr_stmt|;
name|relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relax_info
operator|||
operator|(
operator|!
name|relax_info
operator|->
name|is_relaxable_literal_section
operator|&&
operator|!
name|relax_info
operator|->
name|is_relaxable_asm_section
operator|)
condition|)
return|return;
block|}
name|target_offset
operator|=
name|new_rel
operator|->
name|target_offset
expr_stmt|;
block|}
comment|/* ...and the target address may have been moved within its section.  */
name|new_offset
operator|=
name|offset_with_removed_text
argument_list|(
operator|&
name|relax_info
operator|->
name|action_list
argument_list|,
name|target_offset
argument_list|)
expr_stmt|;
comment|/* Modify the offset and addend.  */
name|removed_bytes
operator|=
name|target_offset
operator|-
name|new_offset
expr_stmt|;
name|new_rel
operator|->
name|target_offset
operator|=
name|new_offset
expr_stmt|;
name|new_rel
operator|->
name|rela
operator|.
name|r_addend
operator|-=
name|removed_bytes
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For dynamic links, there may be a dynamic relocation for each    literal.  The number of dynamic relocations must be computed in    size_dynamic_sections, which occurs before relaxation.  When a    literal is removed, this function checks if there is a corresponding    dynamic relocation and shrinks the size of the appropriate dynamic    relocation section accordingly.  At this point, the contents of the    dynamic relocation sections have not yet been filled in, so there's    nothing else that needs to be done.  */
end_comment

begin_function
specifier|static
name|void
name|shrink_dynamic_reloc_sections
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|int
name|r_type
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_boolean
name|dynamic_symbol
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
name|dynamic_symbol
operator|=
name|xtensa_elf_dynamic_symbol_p
argument_list|(
name|h
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r_type
operator|==
name|R_XTENSA_32
operator|||
name|r_type
operator|==
name|R_XTENSA_PLT
operator|)
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|dynamic_symbol
operator|||
name|info
operator|->
name|shared
operator|)
condition|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
specifier|const
name|char
modifier|*
name|srel_name
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
name|bfd_boolean
name|is_plt
init|=
name|FALSE
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic_symbol
operator|&&
name|r_type
operator|==
name|R_XTENSA_PLT
condition|)
block|{
name|srel_name
operator|=
literal|".rela.plt"
expr_stmt|;
name|is_plt
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|srel_name
operator|=
literal|".rela.got"
expr_stmt|;
comment|/* Reduce size of the .rela.* section by one reloc.  */
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|srel_name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|->
name|size
operator|>=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
argument_list|)
expr_stmt|;
name|srel
operator|->
name|size
operator|-=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_plt
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|,
modifier|*
name|sgotplt
decl_stmt|,
modifier|*
name|srelgot
decl_stmt|;
name|int
name|reloc_index
decl_stmt|,
name|chunk
decl_stmt|;
comment|/* Find the PLT reloc index of the entry being removed.  This 	     is computed from the size of ".rela.plt".  It is needed to 	     figure out which PLT chunk to resize.  Usually "last index 	     = size - 1" since the index starts at zero, but in this 	     context, the size has just been decremented so there's no 	     need to subtract one.  */
name|reloc_index
operator|=
name|srel
operator|->
name|size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|chunk
operator|=
name|reloc_index
operator|/
name|PLT_ENTRIES_PER_CHUNK
expr_stmt|;
name|splt
operator|=
name|elf_xtensa_get_plt_section
argument_list|(
name|dynobj
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|sgotplt
operator|=
name|elf_xtensa_get_gotplt_section
argument_list|(
name|dynobj
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|sgotplt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Check if an entire PLT chunk has just been eliminated.  */
if|if
condition|(
name|reloc_index
operator|%
name|PLT_ENTRIES_PER_CHUNK
operator|==
literal|0
condition|)
block|{
comment|/* The two magic GOT entries for that chunk can go away.  */
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srelgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|srelgot
operator|->
name|reloc_count
operator|-=
literal|2
expr_stmt|;
name|srelgot
operator|->
name|size
operator|-=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|sgotplt
operator|->
name|size
operator|-=
literal|8
expr_stmt|;
comment|/* There should be only one entry left (and it will be 		 removed below).  */
name|BFD_ASSERT
argument_list|(
name|sgotplt
operator|->
name|size
operator|==
literal|4
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|->
name|size
operator|==
name|PLT_ENTRY_SIZE
argument_list|)
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|sgotplt
operator|->
name|size
operator|>=
literal|4
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|->
name|size
operator|>=
name|PLT_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|sgotplt
operator|->
name|size
operator|-=
literal|4
expr_stmt|;
name|splt
operator|->
name|size
operator|-=
name|PLT_ENTRY_SIZE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Take an r_rel and move it to another section.  This usually    requires extending the interal_relocation array and pinning it.  If    the original r_rel is from the same BFD, we can complete this here.    Otherwise, we add a fix record to let the final link fix the    appropriate address.  Contents and internal relocations for the    section must be pinned after calling this routine.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|move_literal
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|xtensa_relax_info
modifier|*
name|relax_info
parameter_list|,
name|Elf_Internal_Rela
modifier|*
modifier|*
name|internal_relocs_p
parameter_list|,
specifier|const
name|literal_value
modifier|*
name|lit
parameter_list|)
block|{
name|Elf_Internal_Rela
modifier|*
name|new_relocs
init|=
name|NULL
decl_stmt|;
name|size_t
name|new_relocs_count
init|=
literal|0
decl_stmt|;
name|Elf_Internal_Rela
name|this_rela
decl_stmt|;
specifier|const
name|r_reloc
modifier|*
name|r_rel
decl_stmt|;
name|r_rel
operator|=
operator|&
name|lit
operator|->
name|r_rel
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|==
operator|*
name|internal_relocs_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_reloc_is_const
argument_list|(
name|r_rel
argument_list|)
condition|)
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|lit
operator|->
name|value
argument_list|,
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|r_type
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|asection
modifier|*
name|target_sec
decl_stmt|;
name|reloc_bfd_fix
modifier|*
name|fix
decl_stmt|;
name|unsigned
name|insert_at
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|r_rel
operator|->
name|rela
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|target_sec
operator|=
name|r_reloc_get_section
argument_list|(
name|r_rel
argument_list|)
expr_stmt|;
comment|/* This is the difficult case.  We have to create a fix up.  */
name|this_rela
operator|.
name|r_offset
operator|=
name|offset
expr_stmt|;
name|this_rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|this_rela
operator|.
name|r_addend
operator|=
name|r_rel
operator|->
name|target_offset
operator|-
name|r_reloc_get_target_offset
argument_list|(
name|r_rel
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|lit
operator|->
name|value
argument_list|,
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
comment|/* Currently, we cannot move relocations during a relocatable link.  */
name|BFD_ASSERT
argument_list|(
operator|!
name|link_info
operator|->
name|relocatable
argument_list|)
expr_stmt|;
name|fix
operator|=
name|reloc_bfd_fix_init
argument_list|(
name|sec
argument_list|,
name|offset
argument_list|,
name|r_type
argument_list|,
name|r_rel
operator|->
name|abfd
argument_list|,
name|r_reloc_get_section
argument_list|(
name|r_rel
argument_list|)
argument_list|,
name|r_rel
operator|->
name|target_offset
operator|+
name|r_rel
operator|->
name|virtual_offset
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* We also need to mark that relocations are needed here.  */
name|sec
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
name|translate_reloc_bfd_fix
argument_list|(
name|fix
argument_list|)
expr_stmt|;
comment|/* This fix has not yet been translated.  */
name|add_fix
argument_list|(
name|sec
argument_list|,
name|fix
argument_list|)
expr_stmt|;
comment|/* Add the relocation.  If we have already allocated our own 	 space for the relocations and we have room for more, then use 	 it.  Otherwise, allocate new space and move the literals.  */
name|insert_at
operator|=
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sec
operator|->
name|reloc_count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|this_rela
operator|.
name|r_offset
operator|<
operator|(
operator|*
name|internal_relocs_p
operator|)
index|[
name|i
index|]
operator|.
name|r_offset
condition|)
block|{
name|insert_at
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|internal_relocs_p
operator|!=
name|relax_info
operator|->
name|allocated_relocs
operator|||
name|sec
operator|->
name|reloc_count
operator|+
literal|1
operator|>
name|relax_info
operator|->
name|allocated_relocs_count
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|relax_info
operator|->
name|allocated_relocs
operator|==
name|NULL
operator|||
name|sec
operator|->
name|reloc_count
operator|==
name|relax_info
operator|->
name|relocs_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|relax_info
operator|->
name|allocated_relocs_count
operator|==
literal|0
condition|)
name|new_relocs_count
operator|=
operator|(
name|sec
operator|->
name|reloc_count
operator|+
literal|2
operator|)
operator|*
literal|2
expr_stmt|;
else|else
name|new_relocs_count
operator|=
operator|(
name|relax_info
operator|->
name|allocated_relocs_count
operator|+
literal|2
operator|)
operator|*
literal|2
expr_stmt|;
name|new_relocs
operator|=
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
operator|*
operator|(
name|new_relocs_count
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_relocs
condition|)
return|return
name|FALSE
return|;
comment|/* We could handle this more quickly by finding the split point.  */
if|if
condition|(
name|insert_at
operator|!=
literal|0
condition|)
name|memcpy
argument_list|(
name|new_relocs
argument_list|,
operator|*
name|internal_relocs_p
argument_list|,
name|insert_at
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
argument_list|)
expr_stmt|;
name|new_relocs
index|[
name|insert_at
index|]
operator|=
name|this_rela
expr_stmt|;
if|if
condition|(
name|insert_at
operator|!=
name|sec
operator|->
name|reloc_count
condition|)
name|memcpy
argument_list|(
name|new_relocs
operator|+
name|insert_at
operator|+
literal|1
argument_list|,
operator|(
operator|*
name|internal_relocs_p
operator|)
operator|+
name|insert_at
argument_list|,
operator|(
name|sec
operator|->
name|reloc_count
operator|-
name|insert_at
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|internal_relocs_p
operator|!=
name|relax_info
operator|->
name|allocated_relocs
condition|)
block|{
comment|/* The first time we re-allocate, we can only free the 		 old relocs if they were allocated with bfd_malloc. 		 This is not true when keep_memory is in effect.  */
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
operator|*
name|internal_relocs_p
argument_list|)
expr_stmt|;
block|}
else|else
name|free
argument_list|(
operator|*
name|internal_relocs_p
argument_list|)
expr_stmt|;
name|relax_info
operator|->
name|allocated_relocs
operator|=
name|new_relocs
expr_stmt|;
name|relax_info
operator|->
name|allocated_relocs_count
operator|=
name|new_relocs_count
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|new_relocs
expr_stmt|;
name|sec
operator|->
name|reloc_count
operator|++
expr_stmt|;
name|relax_info
operator|->
name|relocs_count
operator|=
name|sec
operator|->
name|reloc_count
expr_stmt|;
operator|*
name|internal_relocs_p
operator|=
name|new_relocs
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|insert_at
operator|!=
name|sec
operator|->
name|reloc_count
condition|)
block|{
name|unsigned
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
name|sec
operator|->
name|reloc_count
init|;
name|idx
operator|>
name|insert_at
condition|;
name|idx
operator|--
control|)
operator|(
operator|*
name|internal_relocs_p
operator|)
index|[
name|idx
index|]
operator|=
operator|(
operator|*
name|internal_relocs_p
operator|)
index|[
name|idx
operator|-
literal|1
index|]
expr_stmt|;
block|}
operator|(
operator|*
name|internal_relocs_p
operator|)
index|[
name|insert_at
index|]
operator|=
name|this_rela
expr_stmt|;
name|sec
operator|->
name|reloc_count
operator|++
expr_stmt|;
if|if
condition|(
name|relax_info
operator|->
name|allocated_relocs
condition|)
name|relax_info
operator|->
name|relocs_count
operator|=
name|sec
operator|->
name|reloc_count
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This is similar to relax_section except that when a target is moved,    we shift addresses up.  We also need to modify the size.  This    algorithm does NOT allow for relocations into the middle of the    property sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|relax_property_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|nexti
decl_stmt|;
name|bfd_boolean
name|ok
init|=
name|TRUE
decl_stmt|;
name|bfd_boolean
name|is_full_prop_section
decl_stmt|;
name|size_t
name|last_zfill_target_offset
init|=
literal|0
decl_stmt|;
name|asection
modifier|*
name|last_zfill_target_sec
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|sec_size
decl_stmt|;
name|sec_size
operator|=
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|internal_relocs
operator|=
name|retrieve_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
name|contents
operator|=
name|retrieve_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
operator|&&
name|sec_size
operator|!=
literal|0
condition|)
block|{
name|ok
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|is_full_prop_section
operator|=
operator|(
operator|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
name|XTENSA_PROP_SEC_NAME
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".gnu.linkonce.prop."
argument_list|,
sizeof|sizeof
expr|".gnu.linkonce.prop."
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
name|xtensa_relax_info
modifier|*
name|target_relax_info
decl_stmt|;
name|unsigned
name|r_type
decl_stmt|;
name|asection
modifier|*
name|target_sec
decl_stmt|;
name|literal_value
name|val
decl_stmt|;
name|bfd_byte
modifier|*
name|size_p
decl_stmt|,
modifier|*
name|flags_p
decl_stmt|;
comment|/* Locally change the source address. 	     Translate the target to the new target address. 	     If it points to this section and has been removed, MOVE IT. 	     Also, don't forget to modify the associated SIZE at 	     (offset + 4).  */
name|irel
operator|=
operator|&
name|internal_relocs
index|[
name|i
index|]
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_XTENSA_NONE
condition|)
continue|continue;
comment|/* Find the literal value.  */
name|r_reloc_init
argument_list|(
operator|&
name|val
operator|.
name|r_rel
argument_list|,
name|abfd
argument_list|,
name|irel
argument_list|,
name|contents
argument_list|,
name|sec_size
argument_list|)
expr_stmt|;
name|size_p
operator|=
operator|&
name|contents
index|[
name|irel
operator|->
name|r_offset
operator|+
literal|4
index|]
expr_stmt|;
name|flags_p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|is_full_prop_section
condition|)
block|{
name|flags_p
operator|=
operator|&
name|contents
index|[
name|irel
operator|->
name|r_offset
operator|+
literal|8
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|irel
operator|->
name|r_offset
operator|+
literal|12
operator|<=
name|sec_size
argument_list|)
expr_stmt|;
block|}
else|else
name|BFD_ASSERT
argument_list|(
name|irel
operator|->
name|r_offset
operator|+
literal|8
operator|<=
name|sec_size
argument_list|)
expr_stmt|;
name|target_sec
operator|=
name|r_reloc_get_section
argument_list|(
operator|&
name|val
operator|.
name|r_rel
argument_list|)
expr_stmt|;
name|target_relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|target_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_relax_info
operator|&&
operator|(
name|target_relax_info
operator|->
name|is_relaxable_literal_section
operator|||
name|target_relax_info
operator|->
name|is_relaxable_asm_section
operator|)
condition|)
block|{
comment|/* Translate the relocation's destination.  */
name|bfd_vma
name|new_offset
decl_stmt|,
name|new_end_offset
decl_stmt|;
name|long
name|old_size
decl_stmt|,
name|new_size
decl_stmt|;
name|new_offset
operator|=
name|offset_with_removed_text
argument_list|(
operator|&
name|target_relax_info
operator|->
name|action_list
argument_list|,
name|val
operator|.
name|r_rel
operator|.
name|target_offset
argument_list|)
expr_stmt|;
comment|/* Assert that we are not out of bounds.  */
name|old_size
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|size_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_size
operator|==
literal|0
condition|)
block|{
comment|/* Only the first zero-sized unreachable entry is 		     allowed to expand.  In this case the new offset 		     should be the offset before the fill and the new 		     size is the expansion size.  For other zero-sized 		     entries the resulting size should be zero with an 		     offset before or after the fill address depending 		     on whether the expanding unreachable entry 		     preceeds it.  */
if|if
condition|(
name|last_zfill_target_sec
operator|&&
name|last_zfill_target_sec
operator|==
name|target_sec
operator|&&
name|last_zfill_target_offset
operator|==
name|val
operator|.
name|r_rel
operator|.
name|target_offset
condition|)
name|new_end_offset
operator|=
name|new_offset
expr_stmt|;
else|else
block|{
name|new_end_offset
operator|=
name|new_offset
expr_stmt|;
name|new_offset
operator|=
name|offset_with_removed_text_before_fill
argument_list|(
operator|&
name|target_relax_info
operator|->
name|action_list
argument_list|,
name|val
operator|.
name|r_rel
operator|.
name|target_offset
argument_list|)
expr_stmt|;
comment|/* If it is not unreachable and we have not yet 			 seen an unreachable at this address, place it 			 before the fill address.  */
if|if
condition|(
operator|!
name|flags_p
operator|||
operator|(
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|flags_p
argument_list|)
operator|&
name|XTENSA_PROP_UNREACHABLE
operator|)
operator|==
literal|0
condition|)
name|new_end_offset
operator|=
name|new_offset
expr_stmt|;
else|else
block|{
name|last_zfill_target_sec
operator|=
name|target_sec
expr_stmt|;
name|last_zfill_target_offset
operator|=
name|val
operator|.
name|r_rel
operator|.
name|target_offset
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|new_end_offset
operator|=
name|offset_with_removed_text_before_fill
argument_list|(
operator|&
name|target_relax_info
operator|->
name|action_list
argument_list|,
name|val
operator|.
name|r_rel
operator|.
name|target_offset
operator|+
name|old_size
argument_list|)
expr_stmt|;
block|}
name|new_size
operator|=
name|new_end_offset
operator|-
name|new_offset
expr_stmt|;
if|if
condition|(
name|new_size
operator|!=
name|old_size
condition|)
block|{
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|new_size
argument_list|,
name|size_p
argument_list|)
expr_stmt|;
name|pin_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_offset
operator|!=
name|val
operator|.
name|r_rel
operator|.
name|target_offset
condition|)
block|{
name|bfd_vma
name|diff
init|=
name|new_offset
operator|-
name|val
operator|.
name|r_rel
operator|.
name|target_offset
decl_stmt|;
name|irel
operator|->
name|r_addend
operator|+=
name|diff
expr_stmt|;
name|pin_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Combine adjacent property table entries.  This is also done in      finish_dynamic_sections() but at that point it's too late to      reclaim the space in the output section, so we do this twice.  */
if|if
condition|(
name|internal_relocs
operator|&&
operator|(
operator|!
name|link_info
operator|->
name|relocatable
operator|||
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
name|XTENSA_LIT_SEC_NAME
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|last_irel
init|=
name|NULL
decl_stmt|;
name|int
name|removed_bytes
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|,
name|last_irel_offset
decl_stmt|;
name|bfd_vma
name|section_size
decl_stmt|;
name|bfd_size_type
name|entry_size
decl_stmt|;
name|flagword
name|predef_flags
decl_stmt|;
if|if
condition|(
name|is_full_prop_section
condition|)
name|entry_size
operator|=
literal|12
expr_stmt|;
else|else
name|entry_size
operator|=
literal|8
expr_stmt|;
name|predef_flags
operator|=
name|xtensa_get_property_predef_flags
argument_list|(
name|sec
argument_list|)
expr_stmt|;
comment|/* Walk over memory and irels at the same time.          This REQUIRES that the internal_relocs be sorted by offset.  */
name|qsort
argument_list|(
name|internal_relocs
argument_list|,
name|sec
operator|->
name|reloc_count
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
argument_list|,
name|internal_reloc_compare
argument_list|)
expr_stmt|;
name|nexti
operator|=
literal|0
expr_stmt|;
comment|/* Index into internal_relocs.  */
name|pin_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
name|pin_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|last_irel_offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|section_size
operator|=
name|sec
operator|->
name|size
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|section_size
operator|%
name|entry_size
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|section_size
condition|;
name|offset
operator|+=
name|entry_size
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|next_irel
decl_stmt|;
name|bfd_vma
name|bytes_to_remove
decl_stmt|,
name|size
decl_stmt|,
name|actual_offset
decl_stmt|;
name|bfd_boolean
name|remove_this_irel
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|irel
operator|=
name|NULL
expr_stmt|;
name|next_irel
operator|=
name|NULL
expr_stmt|;
comment|/* Find the next two relocations (if there are that many left), 	     skipping over any R_XTENSA_NONE relocs.  On entry, "nexti" is 	     the starting reloc index.  After these two loops, "i" 	     is the index of the first non-NONE reloc past that starting 	     index, and "nexti" is the index for the next non-NONE reloc 	     after "i".  */
for|for
control|(
name|i
operator|=
name|nexti
init|;
name|i
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|internal_relocs
index|[
name|i
index|]
operator|.
name|r_info
argument_list|)
operator|!=
name|R_XTENSA_NONE
condition|)
block|{
name|irel
operator|=
operator|&
name|internal_relocs
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
name|internal_relocs
index|[
name|i
index|]
operator|.
name|r_offset
operator|-=
name|removed_bytes
expr_stmt|;
block|}
for|for
control|(
name|nexti
operator|=
name|i
operator|+
literal|1
init|;
name|nexti
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|nexti
operator|++
control|)
block|{
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|internal_relocs
index|[
name|nexti
index|]
operator|.
name|r_info
argument_list|)
operator|!=
name|R_XTENSA_NONE
condition|)
block|{
name|next_irel
operator|=
operator|&
name|internal_relocs
index|[
name|nexti
index|]
expr_stmt|;
break|break;
block|}
name|internal_relocs
index|[
name|nexti
index|]
operator|.
name|r_offset
operator|-=
name|removed_bytes
expr_stmt|;
block|}
name|remove_this_irel
operator|=
name|FALSE
expr_stmt|;
name|bytes_to_remove
operator|=
literal|0
expr_stmt|;
name|actual_offset
operator|=
name|offset
operator|-
name|removed_bytes
expr_stmt|;
name|size
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|contents
index|[
name|actual_offset
operator|+
literal|4
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_full_prop_section
condition|)
name|flags
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|contents
index|[
name|actual_offset
operator|+
literal|8
index|]
argument_list|)
expr_stmt|;
else|else
name|flags
operator|=
name|predef_flags
expr_stmt|;
comment|/* Check that the irels are sorted by offset, 	     with only one per address.  */
name|BFD_ASSERT
argument_list|(
operator|!
name|irel
operator|||
operator|(
name|int
operator|)
name|irel
operator|->
name|r_offset
operator|>
operator|(
name|int
operator|)
name|last_irel_offset
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|!
name|next_irel
operator|||
name|next_irel
operator|->
name|r_offset
operator|>
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Make sure there aren't relocs on the size or flag fields.  */
if|if
condition|(
operator|(
name|irel
operator|&&
name|irel
operator|->
name|r_offset
operator|==
name|offset
operator|+
literal|4
operator|)
operator|||
operator|(
name|is_full_prop_section
operator|&&
name|irel
operator|&&
name|irel
operator|->
name|r_offset
operator|==
name|offset
operator|+
literal|8
operator|)
condition|)
block|{
name|irel
operator|->
name|r_offset
operator|-=
name|removed_bytes
expr_stmt|;
name|last_irel_offset
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|next_irel
operator|&&
operator|(
name|next_irel
operator|->
name|r_offset
operator|==
name|offset
operator|+
literal|4
operator|||
operator|(
name|is_full_prop_section
operator|&&
name|next_irel
operator|->
name|r_offset
operator|==
name|offset
operator|+
literal|8
operator|)
operator|)
condition|)
block|{
name|nexti
operator|+=
literal|1
expr_stmt|;
name|irel
operator|->
name|r_offset
operator|-=
name|removed_bytes
expr_stmt|;
name|next_irel
operator|->
name|r_offset
operator|-=
name|removed_bytes
expr_stmt|;
name|last_irel_offset
operator|=
name|next_irel
operator|->
name|r_offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|0
operator|&&
operator|(
name|flags
operator|&
name|XTENSA_PROP_ALIGN
operator|)
operator|==
literal|0
operator|&&
operator|(
name|flags
operator|&
name|XTENSA_PROP_UNREACHABLE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Always remove entries with zero size and no alignment.  */
name|bytes_to_remove
operator|=
name|entry_size
expr_stmt|;
if|if
condition|(
name|irel
operator|&&
name|irel
operator|->
name|r_offset
operator|==
name|offset
condition|)
block|{
name|remove_this_irel
operator|=
name|TRUE
expr_stmt|;
name|irel
operator|->
name|r_offset
operator|-=
name|removed_bytes
expr_stmt|;
name|last_irel_offset
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|irel
operator|&&
name|irel
operator|->
name|r_offset
operator|==
name|offset
condition|)
block|{
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
name|R_XTENSA_32
condition|)
block|{
if|if
condition|(
name|last_irel
condition|)
block|{
name|flagword
name|old_flags
decl_stmt|;
name|bfd_vma
name|old_size
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|contents
index|[
name|last_irel
operator|->
name|r_offset
operator|+
literal|4
index|]
argument_list|)
decl_stmt|;
name|bfd_vma
name|old_address
init|=
operator|(
name|last_irel
operator|->
name|r_addend
operator|+
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|contents
index|[
name|last_irel
operator|->
name|r_offset
index|]
argument_list|)
operator|)
decl_stmt|;
name|bfd_vma
name|new_address
init|=
operator|(
name|irel
operator|->
name|r_addend
operator|+
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|contents
index|[
name|actual_offset
index|]
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|is_full_prop_section
condition|)
name|old_flags
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|contents
index|[
name|last_irel
operator|->
name|r_offset
operator|+
literal|8
index|]
argument_list|)
expr_stmt|;
else|else
name|old_flags
operator|=
name|predef_flags
expr_stmt|;
if|if
condition|(
operator|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
name|ELF32_R_SYM
argument_list|(
name|last_irel
operator|->
name|r_info
argument_list|)
operator|)
operator|&&
name|old_address
operator|+
name|old_size
operator|==
name|new_address
operator|&&
name|old_flags
operator|==
name|flags
operator|&&
operator|(
name|old_flags
operator|&
name|XTENSA_PROP_INSN_BRANCH_TARGET
operator|)
operator|==
literal|0
operator|&&
operator|(
name|old_flags
operator|&
name|XTENSA_PROP_INSN_LOOP_TARGET
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Fix the old size.  */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|old_size
operator|+
name|size
argument_list|,
operator|&
name|contents
index|[
name|last_irel
operator|->
name|r_offset
operator|+
literal|4
index|]
argument_list|)
expr_stmt|;
name|bytes_to_remove
operator|=
name|entry_size
expr_stmt|;
name|remove_this_irel
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|last_irel
operator|=
name|irel
expr_stmt|;
block|}
else|else
name|last_irel
operator|=
name|irel
expr_stmt|;
block|}
name|irel
operator|->
name|r_offset
operator|-=
name|removed_bytes
expr_stmt|;
name|last_irel_offset
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
block|}
if|if
condition|(
name|remove_this_irel
condition|)
block|{
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_XTENSA_NONE
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_offset
operator|-=
name|bytes_to_remove
expr_stmt|;
block|}
if|if
condition|(
name|bytes_to_remove
operator|!=
literal|0
condition|)
block|{
name|removed_bytes
operator|+=
name|bytes_to_remove
expr_stmt|;
if|if
condition|(
name|offset
operator|+
name|bytes_to_remove
operator|<
name|section_size
condition|)
name|memmove
argument_list|(
operator|&
name|contents
index|[
name|actual_offset
index|]
argument_list|,
operator|&
name|contents
index|[
name|actual_offset
operator|+
name|bytes_to_remove
index|]
argument_list|,
name|section_size
operator|-
name|offset
operator|-
name|bytes_to_remove
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|removed_bytes
condition|)
block|{
comment|/* Clear the removed bytes.  */
name|memset
argument_list|(
operator|&
name|contents
index|[
name|section_size
operator|-
name|removed_bytes
index|]
argument_list|,
literal|0
argument_list|,
name|removed_bytes
argument_list|)
expr_stmt|;
name|sec
operator|->
name|size
operator|=
name|section_size
operator|-
name|removed_bytes
expr_stmt|;
if|if
condition|(
name|xtensa_is_littable_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
name|bfd
modifier|*
name|dynobj
init|=
name|elf_hash_table
argument_list|(
name|link_info
argument_list|)
operator|->
name|dynobj
decl_stmt|;
if|if
condition|(
name|dynobj
condition|)
block|{
name|asection
modifier|*
name|sgotloc
init|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.loc"
argument_list|)
decl_stmt|;
if|if
condition|(
name|sgotloc
condition|)
name|sgotloc
operator|->
name|size
operator|-=
name|removed_bytes
expr_stmt|;
block|}
block|}
block|}
block|}
name|error_return
label|:
name|release_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
name|release_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Third relaxation pass.  */
end_comment

begin_comment
comment|/* Change symbol values to account for removed literals.  */
end_comment

begin_function
name|bfd_boolean
name|relax_section_symbols
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
name|xtensa_relax_info
modifier|*
name|relax_info
decl_stmt|;
name|unsigned
name|int
name|sec_shndx
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|num_syms
decl_stmt|,
name|num_locals
decl_stmt|;
name|relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|relax_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relax_info
operator|->
name|is_relaxable_literal_section
operator|&&
operator|!
name|relax_info
operator|->
name|is_relaxable_asm_section
condition|)
return|return
name|TRUE
return|;
name|sec_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|isymbuf
operator|=
name|retrieve_local_syms
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|num_syms
operator|=
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
expr_stmt|;
name|num_locals
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
comment|/* Adjust the local symbols defined in this section.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_locals
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Sym
modifier|*
name|isym
init|=
operator|&
name|isymbuf
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|sec_shndx
condition|)
block|{
name|bfd_vma
name|new_address
init|=
name|offset_with_removed_text
argument_list|(
operator|&
name|relax_info
operator|->
name|action_list
argument_list|,
name|isym
operator|->
name|st_value
argument_list|)
decl_stmt|;
name|bfd_vma
name|new_size
init|=
name|isym
operator|->
name|st_size
decl_stmt|;
if|if
condition|(
name|ELF32_ST_TYPE
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_FUNC
condition|)
block|{
name|bfd_vma
name|new_end
init|=
name|offset_with_removed_text
argument_list|(
operator|&
name|relax_info
operator|->
name|action_list
argument_list|,
name|isym
operator|->
name|st_value
operator|+
name|isym
operator|->
name|st_size
argument_list|)
decl_stmt|;
name|new_size
operator|=
name|new_end
operator|-
name|new_address
expr_stmt|;
block|}
name|isym
operator|->
name|st_value
operator|=
name|new_address
expr_stmt|;
name|isym
operator|->
name|st_size
operator|=
name|new_size
expr_stmt|;
block|}
block|}
comment|/* Now adjust the global symbols defined in this section.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|num_syms
operator|-
name|num_locals
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|sym_hash
decl_stmt|;
name|sym_hash
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|sym_hash
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
operator|(
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|sec
condition|)
block|{
name|bfd_vma
name|new_address
init|=
name|offset_with_removed_text
argument_list|(
operator|&
name|relax_info
operator|->
name|action_list
argument_list|,
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
argument_list|)
decl_stmt|;
name|bfd_vma
name|new_size
init|=
name|sym_hash
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|sym_hash
operator|->
name|type
operator|==
name|STT_FUNC
condition|)
block|{
name|bfd_vma
name|new_end
init|=
name|offset_with_removed_text
argument_list|(
operator|&
name|relax_info
operator|->
name|action_list
argument_list|,
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sym_hash
operator|->
name|size
argument_list|)
decl_stmt|;
name|new_size
operator|=
name|new_end
operator|-
name|new_address
expr_stmt|;
block|}
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|new_address
expr_stmt|;
name|sym_hash
operator|->
name|size
operator|=
name|new_size
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* "Fix" handling functions, called while performing relocations.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|do_fix_for_relocatable_link
parameter_list|(
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|)
block|{
name|r_reloc
name|r_rel
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|,
modifier|*
name|old_sec
decl_stmt|;
name|bfd_vma
name|old_offset
decl_stmt|;
name|int
name|r_type
init|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|reloc_bfd_fix
modifier|*
name|fix
decl_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_XTENSA_NONE
condition|)
return|return
name|TRUE
return|;
name|fix
operator|=
name|get_bfd_fix
argument_list|(
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fix
condition|)
return|return
name|TRUE
return|;
name|r_reloc_init
argument_list|(
operator|&
name|r_rel
argument_list|,
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|contents
argument_list|,
name|bfd_get_section_limit
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|)
expr_stmt|;
name|old_sec
operator|=
name|r_reloc_get_section
argument_list|(
operator|&
name|r_rel
argument_list|)
expr_stmt|;
name|old_offset
operator|=
name|r_rel
operator|.
name|target_offset
expr_stmt|;
if|if
condition|(
operator|!
name|old_sec
operator|||
operator|!
name|r_reloc_is_defined
argument_list|(
operator|&
name|r_rel
argument_list|)
condition|)
block|{
if|if
condition|(
name|r_type
operator|!=
name|R_XTENSA_ASM_EXPAND
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): unexpected fix for %s relocation"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|elf_howto_table
index|[
name|r_type
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Leave it be.  Resolution will happen in a later stage.  */
block|}
else|else
block|{
name|sec
operator|=
name|fix
operator|->
name|target_sec
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|+=
operator|(
operator|(
name|sec
operator|->
name|output_offset
operator|+
name|fix
operator|->
name|target_offset
operator|)
operator|-
operator|(
name|old_sec
operator|->
name|output_offset
operator|+
name|old_offset
operator|)
operator|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_fix_for_final_link
parameter_list|(
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|bfd_vma
modifier|*
name|relocationp
parameter_list|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|int
name|r_type
init|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|reloc_bfd_fix
modifier|*
name|fix
decl_stmt|;
name|bfd_vma
name|fixup_diff
decl_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_XTENSA_NONE
condition|)
return|return;
name|fix
operator|=
name|get_bfd_fix
argument_list|(
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fix
condition|)
return|return;
name|sec
operator|=
name|fix
operator|->
name|target_sec
expr_stmt|;
name|fixup_diff
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|elf_howto_table
index|[
name|fix
operator|->
name|src_type
index|]
operator|.
name|partial_inplace
condition|)
block|{
name|bfd_vma
name|inplace_val
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|fix
operator|->
name|src_offset
operator|<
name|bfd_get_section_limit
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|)
expr_stmt|;
name|inplace_val
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|contents
index|[
name|fix
operator|->
name|src_offset
index|]
argument_list|)
expr_stmt|;
name|fixup_diff
operator|+=
name|inplace_val
expr_stmt|;
block|}
operator|*
name|relocationp
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|fix
operator|->
name|target_offset
operator|-
name|fixup_diff
operator|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Miscellaneous utility functions....  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|elf_xtensa_get_plt_section
parameter_list|(
name|bfd
modifier|*
name|dynobj
parameter_list|,
name|int
name|chunk
parameter_list|)
block|{
name|char
name|plt_name
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|chunk
operator|==
literal|0
condition|)
return|return
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
return|;
name|sprintf
argument_list|(
name|plt_name
argument_list|,
literal|".plt.%u"
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
return|return
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|plt_name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|elf_xtensa_get_gotplt_section
parameter_list|(
name|bfd
modifier|*
name|dynobj
parameter_list|,
name|int
name|chunk
parameter_list|)
block|{
name|char
name|got_name
index|[
literal|14
index|]
decl_stmt|;
if|if
condition|(
name|chunk
operator|==
literal|0
condition|)
return|return
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
return|;
name|sprintf
argument_list|(
name|got_name
argument_list|,
literal|".got.plt.%u"
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
return|return
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|got_name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the input section for a given symbol index.    If the symbol is:    . a section symbol, return the section;    . a common symbol, return the common section;    . an undefined symbol, return the undefined section;    . an indirect symbol, follow the links;    . an absolute value, return the absolute section.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|get_elf_r_symndx_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|long
name|r_symndx
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
init|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|target_sec
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|Elf_Internal_Sym
modifier|*
name|isymbuf
decl_stmt|;
name|unsigned
name|int
name|section_index
decl_stmt|;
name|isymbuf
operator|=
name|retrieve_local_syms
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|section_index
operator|=
name|isymbuf
index|[
name|r_symndx
index|]
operator|.
name|st_shndx
expr_stmt|;
if|if
condition|(
name|section_index
operator|==
name|SHN_UNDEF
condition|)
name|target_sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|section_index
operator|>
literal|0
operator|&&
name|section_index
operator|<
name|SHN_LORESERVE
condition|)
name|target_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|section_index
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|section_index
operator|==
name|SHN_ABS
condition|)
name|target_sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|section_index
operator|==
name|SHN_COMMON
condition|)
name|target_sec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
comment|/* Who knows?  */
name|target_sec
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|indx
init|=
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
decl_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
name|target_sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_common
case|:
name|target_sec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_undefined
case|:
case|case
name|bfd_link_hash_undefweak
case|:
name|target_sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
break|break;
default|default:
comment|/* New indirect warning.  */
name|target_sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
break|break;
block|}
block|}
return|return
name|target_sec
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|elf_link_hash_entry
modifier|*
name|get_elf_r_symndx_hash_entry
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|long
name|r_symndx
parameter_list|)
block|{
name|unsigned
name|long
name|indx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
init|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
decl_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
return|return
name|NULL
return|;
name|indx
operator|=
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/* Get the section-relative offset for a symbol number.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|get_elf_r_symndx_offset
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|long
name|r_symndx
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
init|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
decl_stmt|;
name|bfd_vma
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|Elf_Internal_Sym
modifier|*
name|isymbuf
decl_stmt|;
name|isymbuf
operator|=
name|retrieve_local_syms
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|offset
operator|=
name|isymbuf
index|[
name|r_symndx
index|]
operator|.
name|st_value
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|indx
init|=
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
decl_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
name|offset
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|is_reloc_sym_weak
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|)
block|{
name|unsigned
name|long
name|r_symndx
init|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|get_elf_r_symndx_hash_entry
argument_list|(
name|abfd
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|pcrel_reloc_fits
parameter_list|(
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|,
name|bfd_vma
name|self_address
parameter_list|,
name|bfd_vma
name|dest_address
parameter_list|)
block|{
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|uint32
name|valp
init|=
name|dest_address
decl_stmt|;
if|if
condition|(
name|xtensa_operand_do_reloc
argument_list|(
name|isa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|,
operator|&
name|valp
argument_list|,
name|self_address
argument_list|)
operator|||
name|xtensa_operand_encode
argument_list|(
name|isa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|,
operator|&
name|valp
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|linkonce_len
init|=
sizeof|sizeof
argument_list|(
literal|".gnu.linkonce."
argument_list|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_sec_len
init|=
sizeof|sizeof
argument_list|(
name|XTENSA_INSN_SEC_NAME
argument_list|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lit_sec_len
init|=
sizeof|sizeof
argument_list|(
name|XTENSA_LIT_SEC_NAME
argument_list|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|prop_sec_len
init|=
sizeof|sizeof
argument_list|(
name|XTENSA_PROP_SEC_NAME
argument_list|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_boolean
name|xtensa_is_property_section
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|XTENSA_INSN_SEC_NAME
argument_list|,
name|sec
operator|->
name|name
argument_list|,
name|insn_sec_len
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|XTENSA_LIT_SEC_NAME
argument_list|,
name|sec
operator|->
name|name
argument_list|,
name|lit_sec_len
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|XTENSA_PROP_SEC_NAME
argument_list|,
name|sec
operator|->
name|name
argument_list|,
name|prop_sec_len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|strncmp
argument_list|(
literal|".gnu.linkonce."
argument_list|,
name|sec
operator|->
name|name
argument_list|,
name|linkonce_len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|strncmp
argument_list|(
operator|&
name|sec
operator|->
name|name
index|[
name|linkonce_len
index|]
argument_list|,
literal|"x."
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
operator|&
name|sec
operator|->
name|name
index|[
name|linkonce_len
index|]
argument_list|,
literal|"p."
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
operator|&
name|sec
operator|->
name|name
index|[
name|linkonce_len
index|]
argument_list|,
literal|"prop."
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|xtensa_is_littable_section
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|XTENSA_LIT_SEC_NAME
argument_list|,
name|sec
operator|->
name|name
argument_list|,
name|lit_sec_len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|strncmp
argument_list|(
literal|".gnu.linkonce."
argument_list|,
name|sec
operator|->
name|name
argument_list|,
name|linkonce_len
argument_list|)
operator|==
literal|0
operator|&&
name|sec
operator|->
name|name
index|[
name|linkonce_len
index|]
operator|==
literal|'p'
operator|&&
name|sec
operator|->
name|name
index|[
name|linkonce_len
operator|+
literal|1
index|]
operator|==
literal|'.'
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|internal_reloc_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|ap
parameter_list|,
specifier|const
name|void
modifier|*
name|bp
parameter_list|)
block|{
specifier|const
name|Elf_Internal_Rela
modifier|*
name|a
init|=
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
name|ap
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|b
init|=
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
name|bp
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|r_offset
operator|!=
name|b
operator|->
name|r_offset
condition|)
return|return
operator|(
name|a
operator|->
name|r_offset
operator|-
name|b
operator|->
name|r_offset
operator|)
return|;
comment|/* We don't need to sort on these criteria for correctness,      but enforcing a more strict ordering prevents unstable qsort      from behaving differently with different implementations.      Without the code below we get correct but different results      on Solaris 2.7 and 2.8.  We would like to always produce the      same results no matter the host.  */
if|if
condition|(
name|a
operator|->
name|r_info
operator|!=
name|b
operator|->
name|r_info
condition|)
return|return
operator|(
name|a
operator|->
name|r_info
operator|-
name|b
operator|->
name|r_info
operator|)
return|;
return|return
operator|(
name|a
operator|->
name|r_addend
operator|-
name|b
operator|->
name|r_addend
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|internal_reloc_matches
parameter_list|(
specifier|const
name|void
modifier|*
name|ap
parameter_list|,
specifier|const
name|void
modifier|*
name|bp
parameter_list|)
block|{
specifier|const
name|Elf_Internal_Rela
modifier|*
name|a
init|=
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
name|ap
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|b
init|=
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
name|bp
decl_stmt|;
comment|/* Check if one entry overlaps with the other; this shouldn't happen      except when searching for a match.  */
return|return
operator|(
name|a
operator|->
name|r_offset
operator|-
name|b
operator|->
name|r_offset
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|xtensa_get_property_section_name
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|char
modifier|*
name|base_name
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".gnu.linkonce."
argument_list|,
name|linkonce_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|prop_sec_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
name|char
modifier|*
name|linkonce_kind
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|base_name
argument_list|,
name|XTENSA_INSN_SEC_NAME
argument_list|)
operator|==
literal|0
condition|)
name|linkonce_kind
operator|=
literal|"x."
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|base_name
argument_list|,
name|XTENSA_LIT_SEC_NAME
argument_list|)
operator|==
literal|0
condition|)
name|linkonce_kind
operator|=
literal|"p."
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|base_name
argument_list|,
name|XTENSA_PROP_SEC_NAME
argument_list|)
operator|==
literal|0
condition|)
name|linkonce_kind
operator|=
literal|"prop."
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|prop_sec_name
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|strlen
argument_list|(
name|sec
operator|->
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|linkonce_kind
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|prop_sec_name
argument_list|,
literal|".gnu.linkonce."
argument_list|,
name|linkonce_len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|prop_sec_name
operator|+
name|linkonce_len
argument_list|,
name|linkonce_kind
argument_list|)
expr_stmt|;
name|suffix
operator|=
name|sec
operator|->
name|name
operator|+
name|linkonce_len
expr_stmt|;
comment|/* For backward compatibility, replace "t." instead of inserting          the new linkonce_kind (but not for "prop" sections).  */
if|if
condition|(
name|strncmp
argument_list|(
name|suffix
argument_list|,
literal|"t."
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|&&
name|linkonce_kind
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
name|suffix
operator|+=
literal|2
expr_stmt|;
name|strcat
argument_list|(
name|prop_sec_name
operator|+
name|linkonce_len
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
return|return
name|prop_sec_name
return|;
block|}
return|return
name|strdup
argument_list|(
name|base_name
argument_list|)
return|;
block|}
end_function

begin_function
name|flagword
name|xtensa_get_property_predef_flags
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
name|XTENSA_INSN_SEC_NAME
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".gnu.linkonce.x."
argument_list|,
sizeof|sizeof
expr|".gnu.linkonce.x."
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|XTENSA_PROP_INSN
operator||
name|XTENSA_PROP_INSN_NO_TRANSFORM
operator||
name|XTENSA_PROP_INSN_NO_REORDER
operator|)
return|;
if|if
condition|(
name|xtensa_is_littable_section
argument_list|(
name|sec
argument_list|)
condition|)
return|return
operator|(
name|XTENSA_PROP_LITERAL
operator||
name|XTENSA_PROP_INSN_NO_TRANSFORM
operator||
name|XTENSA_PROP_INSN_NO_REORDER
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Other functions called directly by the linker.  */
end_comment

begin_function
name|bfd_boolean
name|xtensa_callback_required_dependence
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|deps_callback_t
name|callback
parameter_list|,
name|void
modifier|*
name|closure
parameter_list|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|bfd_boolean
name|ok
init|=
name|TRUE
decl_stmt|;
name|bfd_size_type
name|sec_size
decl_stmt|;
name|sec_size
operator|=
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
comment|/* ".plt*" sections have no explicit relocations but they contain L32R      instructions that reference the corresponding ".got.plt*" sections.  */
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".plt"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|asection
modifier|*
name|sgotplt
decl_stmt|;
comment|/* Find the corresponding ".got.plt*" section.  */
if|if
condition|(
name|sec
operator|->
name|name
index|[
literal|4
index|]
operator|==
literal|'\0'
condition|)
name|sgotplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|got_name
index|[
literal|14
index|]
decl_stmt|;
name|int
name|chunk
init|=
literal|0
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|->
name|name
index|[
literal|4
index|]
operator|==
literal|'.'
argument_list|)
expr_stmt|;
name|chunk
operator|=
name|strtol
argument_list|(
operator|&
name|sec
operator|->
name|name
index|[
literal|5
index|]
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|got_name
argument_list|,
literal|".got.plt.%u"
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|sgotplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|got_name
argument_list|)
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|sgotplt
argument_list|)
expr_stmt|;
comment|/* Assume worst-case offsets: L32R at the very end of the ".plt" 	 section referencing a literal at the very beginning of 	 ".got.plt".  This is very close to the real dependence, anyway.  */
call|(
modifier|*
name|callback
call|)
argument_list|(
name|sec
argument_list|,
name|sec_size
argument_list|,
name|sgotplt
argument_list|,
literal|0
argument_list|,
name|closure
argument_list|)
expr_stmt|;
block|}
name|internal_relocs
operator|=
name|retrieve_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
operator|||
name|sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|ok
return|;
comment|/* Cache the contents for the duration of this scan.  */
name|contents
operator|=
name|retrieve_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
operator|&&
name|sec_size
operator|!=
literal|0
condition|)
block|{
name|ok
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
operator|!
name|xtensa_default_isa
condition|)
name|xtensa_default_isa
operator|=
name|xtensa_isa_init
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|irel
init|=
operator|&
name|internal_relocs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|is_l32r_relocation
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
name|irel
argument_list|)
condition|)
block|{
name|r_reloc
name|l32r_rel
decl_stmt|;
name|asection
modifier|*
name|target_sec
decl_stmt|;
name|bfd_vma
name|target_offset
decl_stmt|;
name|r_reloc_init
argument_list|(
operator|&
name|l32r_rel
argument_list|,
name|abfd
argument_list|,
name|irel
argument_list|,
name|contents
argument_list|,
name|sec_size
argument_list|)
expr_stmt|;
name|target_sec
operator|=
name|NULL
expr_stmt|;
name|target_offset
operator|=
literal|0
expr_stmt|;
comment|/* L32Rs must be local to the input file.  */
if|if
condition|(
name|r_reloc_is_defined
argument_list|(
operator|&
name|l32r_rel
argument_list|)
condition|)
block|{
name|target_sec
operator|=
name|r_reloc_get_section
argument_list|(
operator|&
name|l32r_rel
argument_list|)
expr_stmt|;
name|target_offset
operator|=
name|l32r_rel
operator|.
name|target_offset
expr_stmt|;
block|}
call|(
modifier|*
name|callback
call|)
argument_list|(
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
argument_list|,
name|target_sec
argument_list|,
name|target_offset
argument_list|,
name|closure
argument_list|)
expr_stmt|;
block|}
block|}
name|error_return
label|:
name|release_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
name|release_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/* The default literal sections should always be marked as "code" (i.e.,    SHF_EXECINSTR).  This is particularly important for the Linux kernel    module loader so that the literals are not placed after the text.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|bfd_elf_special_section
name|elf_xtensa_special_sections
index|[]
init|=
block|{
block|{
literal|".fini.literal"
block|,
literal|13
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_EXECINSTR
block|}
block|,
block|{
literal|".init.literal"
block|,
literal|13
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_EXECINSTR
block|}
block|,
block|{
literal|".literal"
block|,
literal|8
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_EXECINSTR
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|ELF_ARCH
end_ifndef

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_xtensa_le_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-xtensa-le"
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_xtensa_be_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-xtensa-be"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_xtensa
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_XTENSA
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT1
value|EM_XTENSA_OLD
end_define

begin_if
if|#
directive|if
name|XCHAL_HAVE_MMU
end_if

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|(1<< XCHAL_MMU_MIN_PTE_PAGE_SIZE)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !XCHAL_HAVE_MMU */
end_comment

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !XCHAL_HAVE_MMU */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ELF_ARCH */
end_comment

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_can_refcount
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_readonly
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|4
end_define

begin_define
define|#
directive|define
name|elf_backend_want_dynbss
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_want_got_plt
value|1
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|elf_xtensa_info_to_howto_rela
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_merge_private_bfd_data
value|elf_xtensa_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_new_section_hook
value|elf_xtensa_new_section_hook
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_print_private_bfd_data
value|elf_xtensa_print_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_relax_section
value|elf_xtensa_relax_section
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|elf_xtensa_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_set_private_flags
value|elf_xtensa_set_private_flags
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
value|elf_xtensa_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|elf_xtensa_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
value|elf_xtensa_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_discard_info
value|elf_xtensa_discard_info
end_define

begin_define
define|#
directive|define
name|elf_backend_ignore_discarded_relocs
value|elf_xtensa_ignore_discarded_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
value|elf_xtensa_final_write_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
value|elf_xtensa_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
value|elf_xtensa_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|elf_xtensa_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|elf_xtensa_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_prstatus
value|elf_xtensa_grok_prstatus
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_psinfo
value|elf_xtensa_grok_psinfo
end_define

begin_define
define|#
directive|define
name|elf_backend_hide_symbol
value|elf_xtensa_hide_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_modify_segment_map
value|elf_xtensa_modify_segment_map
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|elf_xtensa_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_reloc_type_class
value|elf_xtensa_reloc_type_class
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|elf_xtensa_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
value|elf_xtensa_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_special_sections
value|elf_xtensa_special_sections
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

