begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Xtensa-specific support for 32-bit ELF.    Copyright 2003, 2004 Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/xtensa.h"
end_include

begin_include
include|#
directive|include
file|"xtensa-isa.h"
end_include

begin_include
include|#
directive|include
file|"xtensa-config.h"
end_include

begin_comment
comment|/* Main interface functions.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|elf_xtensa_info_to_howto_rela
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|elf_xtensa_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|bfd_reloc_code_real_type
name|code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|xtensa_read_table_entries
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|property_table_entry
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_xtensa_check_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_xtensa_hide_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|elf_xtensa_gc_mark_hook
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_xtensa_gc_sweep_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_xtensa_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_xtensa_adjust_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_xtensa_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_xtensa_modify_segment_map
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_xtensa_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_xtensa_relax_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd_boolean
operator|*
name|again
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_xtensa_finish_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_xtensa_finish_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_xtensa_merge_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_xtensa_set_private_flags
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|flagword
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|flagword
name|elf_xtensa_get_private_bfd_flags
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_xtensa_print_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_xtensa_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_xtensa_final_write_processing
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|elf_reloc_type_class
name|elf_xtensa_reloc_type_class
name|PARAMS
argument_list|(
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_xtensa_discard_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|elf_reloc_cookie
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_xtensa_ignore_discarded_relocs
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_xtensa_grok_prstatus
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Note
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_xtensa_grok_psinfo
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Note
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_xtensa_new_section_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local helper functions.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xtensa_elf_dynamic_symbol_p
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|property_table_compare
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_xtensa_in_literal_pool
name|PARAMS
argument_list|(
operator|(
name|property_table_entry
operator|*
operator|,
name|int
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_xtensa_make_sym_local
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|add_extra_plt_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_xtensa_fix_refcounts
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_xtensa_allocate_plt_size
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_xtensa_allocate_got_size
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_xtensa_allocate_local_got_size
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|elf_xtensa_do_reloc
name|PARAMS
argument_list|(
operator|(
name|reloc_howto_type
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_boolean
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vsprint_msg
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|build_encoding_error_message
name|PARAMS
argument_list|(
operator|(
name|xtensa_opcode
operator|,
name|xtensa_encode_result
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|bfd_elf_xtensa_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_fix_for_relocatable_link
name|PARAMS
argument_list|(
operator|(
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_fix_for_final_link
name|PARAMS
argument_list|(
operator|(
name|Elf_Internal_Rela
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|elf_xtensa_create_plt_entry
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elf_xtensa_combine_prop_entries
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_xtensa_discard_info_for_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|elf_reloc_cookie
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local functions to handle Xtensa configurability.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|init_call_opcodes
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_indirect_call_opcode
name|PARAMS
argument_list|(
operator|(
name|xtensa_opcode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_direct_call_opcode
name|PARAMS
argument_list|(
operator|(
name|xtensa_opcode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_windowed_call_opcode
name|PARAMS
argument_list|(
operator|(
name|xtensa_opcode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|get_l32r_opcode
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|l32r_offset
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_relocation_opnd
name|PARAMS
argument_list|(
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|get_relocation_opcode
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_l32r_relocation
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions for link-time code simplifications.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|elf_xtensa_do_asm_simplify
name|PARAMS
argument_list|(
operator|(
name|bfd_byte
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|contract_asm_expansion
name|PARAMS
argument_list|(
operator|(
name|bfd_byte
operator|*
operator|,
name|bfd_vma
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|swap_callx_for_call_opcode
name|PARAMS
argument_list|(
operator|(
name|xtensa_opcode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|get_expanded_call_opcode
name|PARAMS
argument_list|(
operator|(
name|bfd_byte
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Access to internal relocations, section contents and symbols.  */
end_comment

begin_decl_stmt
specifier|static
name|Elf_Internal_Rela
modifier|*
name|retrieve_internal_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pin_internal_relocs
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|release_internal_relocs
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_byte
modifier|*
name|retrieve_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pin_contents
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|release_contents
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf_Internal_Sym
modifier|*
name|retrieve_local_syms
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Miscellaneous utility functions.  */
end_comment

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|elf_xtensa_get_plt_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|elf_xtensa_get_gotplt_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|get_elf_r_symndx_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|elf_link_hash_entry
modifier|*
name|get_elf_r_symndx_hash_entry
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|get_elf_r_symndx_offset
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|pcrel_reloc_fits
name|PARAMS
argument_list|(
operator|(
name|xtensa_operand
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xtensa_is_property_section
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|xtensa_is_littable_section
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_literal_section
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|internal_reloc_compare
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xtensa_get_property_section_name
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Other functions called directly by the linker.  */
end_comment

begin_typedef
typedef|typedef
name|void
argument_list|(
argument|*deps_callback_t
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|PTR
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_decl_stmt
specifier|extern
name|bfd_boolean
name|xtensa_callback_required_dependence
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|deps_callback_t
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|struct
name|xtensa_relax_info_struct
name|xtensa_relax_info
typedef|;
end_typedef

begin_comment
comment|/* Total count of PLT relocations seen during check_relocs.    The actual PLT code must be split into multiple sections and all    the sections have to be created before size_dynamic_sections,    where we figure out the exact number of PLT entries that will be    needed.  It is OK if this count is an overestimate, e.g., some    relocations may be removed by GC.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|plt_reloc_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When this is true, relocations may have been modified to refer to    symbols from other input files.  The per-section list of "fix"    records needs to be checked when resolving relocations.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|relaxing_section
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_howto_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|R_XTENSA_NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_NONE"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_32"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
comment|/* Replace a 32-bit value with a value from the runtime linker (only      used by linker-generated stub functions).  The r_addend value is      special: 1 means to substitute a pointer to the runtime linker's      dynamic resolver function; 2 means to substitute the link map for      the shared object.  */
name|HOWTO
argument_list|(
name|R_XTENSA_RTLD
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|NULL
argument_list|,
literal|"R_XTENSA_RTLD"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_GLOB_DAT
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_XTENSA_GLOB_DAT"
argument_list|,
name|FALSE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_JMP_SLOT
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_XTENSA_JMP_SLOT"
argument_list|,
name|FALSE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_RELATIVE
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_XTENSA_RELATIVE"
argument_list|,
name|FALSE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_PLT
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_PLT"
argument_list|,
name|FALSE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|7
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_OP0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_OP0"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_OP1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_OP1"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_XTENSA_OP2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_OP2"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
comment|/* Assembly auto-expansion.  */
name|HOWTO
argument_list|(
name|R_XTENSA_ASM_EXPAND
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_ASM_EXPAND"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|FALSE
argument_list|)
block|,
comment|/* Relax assembly auto-expansion.  */
name|HOWTO
argument_list|(
name|R_XTENSA_ASM_SIMPLIFY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_xtensa_reloc
argument_list|,
literal|"R_XTENSA_ASM_SIMPLIFY"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|TRUE
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|13
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|14
argument_list|)
block|,
comment|/* GNU extension to record C++ vtable hierarchy.  */
name|HOWTO
argument_list|(
name|R_XTENSA_GNU_VTINHERIT
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|NULL
argument_list|,
literal|"R_XTENSA_GNU_VTINHERIT"
argument_list|,
name|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
name|FALSE
argument_list|)
block|,
comment|/* GNU extension to record C++ vtable member usage.  */
name|HOWTO
argument_list|(
argument|R_XTENSA_GNU_VTENTRY
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
argument|FALSE
argument_list|,
literal|0
argument_list|,
argument|complain_overflow_dont
argument_list|,
argument|_bfd_elf_rel_vtable_reloc_fn
argument_list|,
literal|"R_XTENSA_GNU_VTENTRY"
argument_list|,
argument|FALSE
argument_list|,
literal|0x00000000
argument_list|,
literal|0x00000000
argument_list|,
argument|FALSE
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_GEN_RELOC
end_ifdef

begin_define
define|#
directive|define
name|TRACE
parameter_list|(
name|str
parameter_list|)
define|\
value|fprintf (stderr, "Xtensa bfd reloc lookup %d (%s)\n", code, str)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TRACE
parameter_list|(
name|str
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|elf_xtensa_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BFD_RELOC_NONE
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_NONE"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_NONE
index|]
return|;
case|case
name|BFD_RELOC_32
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_32"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_32
index|]
return|;
case|case
name|BFD_RELOC_XTENSA_RTLD
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_XTENSA_RTLD"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_RTLD
index|]
return|;
case|case
name|BFD_RELOC_XTENSA_GLOB_DAT
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_XTENSA_GLOB_DAT"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_GLOB_DAT
index|]
return|;
case|case
name|BFD_RELOC_XTENSA_JMP_SLOT
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_XTENSA_JMP_SLOT"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_JMP_SLOT
index|]
return|;
case|case
name|BFD_RELOC_XTENSA_RELATIVE
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_XTENSA_RELATIVE"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_RELATIVE
index|]
return|;
case|case
name|BFD_RELOC_XTENSA_PLT
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_XTENSA_PLT"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_PLT
index|]
return|;
case|case
name|BFD_RELOC_XTENSA_OP0
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_XTENSA_OP0"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_OP0
index|]
return|;
case|case
name|BFD_RELOC_XTENSA_OP1
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_XTENSA_OP1"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_OP1
index|]
return|;
case|case
name|BFD_RELOC_XTENSA_OP2
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_XTENSA_OP2"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_OP2
index|]
return|;
case|case
name|BFD_RELOC_XTENSA_ASM_EXPAND
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_XTENSA_ASM_EXPAND"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_ASM_EXPAND
index|]
return|;
case|case
name|BFD_RELOC_XTENSA_ASM_SIMPLIFY
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_XTENSA_ASM_SIMPLIFY"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_ASM_SIMPLIFY
index|]
return|;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_VTABLE_INHERIT"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_GNU_VTINHERIT
index|]
return|;
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|TRACE
argument_list|(
literal|"BFD_RELOC_VTABLE_ENTRY"
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_GNU_VTENTRY
index|]
return|;
default|default:
break|break;
block|}
name|TRACE
argument_list|(
literal|"Unknown"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Given an ELF "rela" relocation, find the corresponding howto and record    it in the BFD internal arelent representation of the relocation.  */
end_comment

begin_function
specifier|static
name|void
name|elf_xtensa_info_to_howto_rela
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|unsigned
name|int
name|r_type
init|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|r_type
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_XTENSA_max
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf_howto_table
index|[
name|r_type
index|]
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for the Xtensa ELF linker.  */
end_comment

begin_comment
comment|/* The name of the dynamic interpreter.  This is put in the .interp    section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/lib/ld.so"
end_define

begin_comment
comment|/* The size in bytes of an entry in the procedure linkage table.    (This does _not_ include the space for the literals associated with    the PLT entry.) */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_SIZE
value|16
end_define

begin_comment
comment|/* For _really_ large PLTs, we may need to alternate between literals    and code to keep the literals within the 256K range of the L32R    instructions in the code.  It's unlikely that anyone would ever need    such a big PLT, but an arbitrary limit on the PLT size would be bad.    Thus, we split the PLT into chunks.  Since there's very little    overhead (2 extra literals) for each chunk, the chunk size is kept    small so that the code for handling multiple chunks get used and    tested regularly.  With 254 entries, there are 1K of literals for    each chunk, and that seems like a nice round number.  */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRIES_PER_CHUNK
value|254
end_define

begin_comment
comment|/* PLT entries are actually used as stub functions for lazy symbol    resolution.  Once the symbol is resolved, the stub function is never    invoked.  Note: the 32-byte frame size used here cannot be changed    without a corresponding change in the runtime linker.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_xtensa_be_plt_entry
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0x6c
block|,
literal|0x10
block|,
literal|0x04
block|,
comment|/* entry sp, 32 */
literal|0x18
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* l32r  a8, [got entry for rtld's resolver] */
literal|0x1a
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* l32r  a10, [got entry for rtld's link map] */
literal|0x1b
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* l32r  a11, [literal for reloc index] */
literal|0x0a
block|,
literal|0x80
block|,
literal|0x00
block|,
comment|/* jx    a8 */
literal|0
comment|/* unused */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_xtensa_le_plt_entry
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0x36
block|,
literal|0x41
block|,
literal|0x00
block|,
comment|/* entry sp, 32 */
literal|0x81
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* l32r  a8, [got entry for rtld's resolver] */
literal|0xa1
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* l32r  a10, [got entry for rtld's link map] */
literal|0xb1
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* l32r  a11, [literal for reloc index] */
literal|0xa0
block|,
literal|0x08
block|,
literal|0x00
block|,
comment|/* jx    a8 */
literal|0
comment|/* unused */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|bfd_boolean
name|xtensa_elf_dynamic_symbol_p
parameter_list|(
name|h
parameter_list|,
name|info
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
comment|/* Check if we should do dynamic things to this symbol.  The      "ignore_protected" argument need not be set, because Xtensa code      does not require special handling of STV_PROTECTED to make function      pointer comparisons work properly.  The PLT addresses are never      used for function pointers.  */
return|return
name|_bfd_elf_dynamic_symbol_p
argument_list|(
name|h
argument_list|,
name|info
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|property_table_compare
parameter_list|(
name|ap
parameter_list|,
name|bp
parameter_list|)
specifier|const
name|PTR
name|ap
decl_stmt|;
specifier|const
name|PTR
name|bp
decl_stmt|;
block|{
specifier|const
name|property_table_entry
modifier|*
name|a
init|=
operator|(
specifier|const
name|property_table_entry
operator|*
operator|)
name|ap
decl_stmt|;
specifier|const
name|property_table_entry
modifier|*
name|b
init|=
operator|(
specifier|const
name|property_table_entry
operator|*
operator|)
name|bp
decl_stmt|;
comment|/* Check if one entry overlaps with the other; this shouldn't happen      except when searching for a match.  */
if|if
condition|(
operator|(
name|b
operator|->
name|address
operator|>=
name|a
operator|->
name|address
operator|&&
name|b
operator|->
name|address
operator|<
operator|(
name|a
operator|->
name|address
operator|+
name|a
operator|->
name|size
operator|)
operator|)
operator|||
operator|(
name|a
operator|->
name|address
operator|>=
name|b
operator|->
name|address
operator|&&
name|a
operator|->
name|address
operator|<
operator|(
name|b
operator|->
name|address
operator|+
name|b
operator|->
name|size
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|a
operator|->
name|address
operator|-
name|b
operator|->
name|address
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get the literal table or instruction table entries for the given    section.  Sets TABLE_P and returns the number of entries.  On error,    returns a negative value.  */
end_comment

begin_function
name|int
name|xtensa_read_table_entries
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|table_p
parameter_list|,
name|sec_name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|property_table_entry
modifier|*
modifier|*
name|table_p
decl_stmt|;
specifier|const
name|char
modifier|*
name|sec_name
decl_stmt|;
block|{
name|asection
modifier|*
name|table_section
decl_stmt|;
name|char
modifier|*
name|table_section_name
decl_stmt|;
name|bfd_size_type
name|table_size
init|=
literal|0
decl_stmt|;
name|bfd_byte
modifier|*
name|table_data
decl_stmt|;
name|property_table_entry
modifier|*
name|blocks
decl_stmt|;
name|int
name|block_count
decl_stmt|;
name|bfd_size_type
name|num_records
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|bfd_vma
name|section_addr
decl_stmt|;
name|table_section_name
operator|=
name|xtensa_get_property_section_name
argument_list|(
name|section
argument_list|,
name|sec_name
argument_list|)
expr_stmt|;
name|table_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|table_section_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|table_section_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|table_section
operator|!=
name|NULL
condition|)
name|table_size
operator|=
operator|(
name|table_section
operator|->
name|_cooked_size
condition|?
name|table_section
operator|->
name|_cooked_size
else|:
name|table_section
operator|->
name|_raw_size
operator|)
expr_stmt|;
if|if
condition|(
name|table_size
operator|==
literal|0
condition|)
block|{
operator|*
name|table_p
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
name|num_records
operator|=
name|table_size
operator|/
literal|8
expr_stmt|;
name|table_data
operator|=
name|retrieve_contents
argument_list|(
name|abfd
argument_list|,
name|table_section
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|blocks
operator|=
operator|(
name|property_table_entry
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|num_records
operator|*
sizeof|sizeof
argument_list|(
name|property_table_entry
argument_list|)
argument_list|)
expr_stmt|;
name|block_count
operator|=
literal|0
expr_stmt|;
name|section_addr
operator|=
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|section
operator|->
name|output_offset
expr_stmt|;
comment|/* If the file has not yet been relocated, process the relocations      and sort out the table entries that apply to the specified section.  */
name|internal_relocs
operator|=
name|retrieve_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|table_section
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|&&
operator|!
name|table_section
operator|->
name|reloc_done
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table_section
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|rel
init|=
operator|&
name|internal_relocs
index|[
name|i
index|]
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_XTENSA_NONE
condition|)
continue|continue;
name|BFD_ASSERT
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_XTENSA_32
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_elf_r_symndx_section
argument_list|(
name|abfd
argument_list|,
name|r_symndx
argument_list|)
operator|==
name|section
condition|)
block|{
name|bfd_vma
name|sym_off
init|=
name|get_elf_r_symndx_offset
argument_list|(
name|abfd
argument_list|,
name|r_symndx
argument_list|)
decl_stmt|;
name|blocks
index|[
name|block_count
index|]
operator|.
name|address
operator|=
operator|(
name|section_addr
operator|+
name|sym_off
operator|+
name|rel
operator|->
name|r_addend
operator|+
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|table_data
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
expr_stmt|;
name|blocks
index|[
name|block_count
index|]
operator|.
name|size
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|table_data
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
name|block_count
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* The file has already been relocated and the addresses are 	 already in the table.  */
name|bfd_vma
name|off
decl_stmt|;
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|table_size
condition|;
name|off
operator|+=
literal|8
control|)
block|{
name|bfd_vma
name|address
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|table_data
operator|+
name|off
argument_list|)
decl_stmt|;
if|if
condition|(
name|address
operator|>=
name|section_addr
operator|&&
name|address
operator|<
operator|(
name|section_addr
operator|+
name|section
operator|->
name|_raw_size
operator|)
condition|)
block|{
name|blocks
index|[
name|block_count
index|]
operator|.
name|address
operator|=
name|address
expr_stmt|;
name|blocks
index|[
name|block_count
index|]
operator|.
name|size
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|table_data
operator|+
name|off
operator|+
literal|4
argument_list|)
expr_stmt|;
name|block_count
operator|++
expr_stmt|;
block|}
block|}
block|}
name|release_contents
argument_list|(
name|table_section
argument_list|,
name|table_data
argument_list|)
expr_stmt|;
name|release_internal_relocs
argument_list|(
name|table_section
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|block_count
operator|>
literal|0
condition|)
block|{
comment|/* Now sort them into address order for easy reference.  */
name|qsort
argument_list|(
name|blocks
argument_list|,
name|block_count
argument_list|,
sizeof|sizeof
argument_list|(
name|property_table_entry
argument_list|)
argument_list|,
name|property_table_compare
argument_list|)
expr_stmt|;
block|}
operator|*
name|table_p
operator|=
name|blocks
expr_stmt|;
return|return
name|block_count
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_in_literal_pool
parameter_list|(
name|lit_table
parameter_list|,
name|lit_table_size
parameter_list|,
name|addr
parameter_list|)
name|property_table_entry
modifier|*
name|lit_table
decl_stmt|;
name|int
name|lit_table_size
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
block|{
name|property_table_entry
name|entry
decl_stmt|;
if|if
condition|(
name|lit_table_size
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
name|entry
operator|.
name|address
operator|=
name|addr
expr_stmt|;
name|entry
operator|.
name|size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bsearch
argument_list|(
operator|&
name|entry
argument_list|,
name|lit_table
argument_list|,
name|lit_table_size
argument_list|,
sizeof|sizeof
argument_list|(
name|property_table_entry
argument_list|)
argument_list|,
name|property_table_compare
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look through the relocs for a section during the first phase, and    calculate needed space in the dynamic reloc sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_check_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|NUM_SHDR_ENTRIES
argument_list|(
name|symtab_hdr
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: bad symbol index: %d"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_XTENSA_32
case|:
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
goto|goto
name|local_literal
goto|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|<=
literal|0
condition|)
name|h
operator|->
name|got
operator|.
name|refcount
operator|=
literal|1
expr_stmt|;
else|else
name|h
operator|->
name|got
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|R_XTENSA_PLT
case|:
comment|/* If this relocation is against a local symbol, then it's 	     exactly the same as a normal local GOT entry.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
goto|goto
name|local_literal
goto|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|<=
literal|0
condition|)
block|{
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|refcount
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|h
operator|->
name|plt
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
comment|/* Keep track of the total PLT relocation count even if we 		 don't yet know whether the dynamic sections will be 		 created.  */
name|plt_reloc_count
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
if|if
condition|(
operator|!
name|add_extra_plt_sections
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|plt_reloc_count
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
break|break;
name|local_literal
label|:
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
comment|/* This is a global offset table entry for a local symbol.  */
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|size
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|size
operator|*=
sizeof|sizeof
argument_list|(
name|bfd_signed_vma
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
operator|(
operator|(
name|bfd_signed_vma
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_got_refcounts
expr_stmt|;
block|}
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|R_XTENSA_OP0
case|:
case|case
name|R_XTENSA_OP1
case|:
case|case
name|R_XTENSA_OP2
case|:
case|case
name|R_XTENSA_ASM_EXPAND
case|:
case|case
name|R_XTENSA_ASM_SIMPLIFY
case|:
comment|/* Nothing to do for these.  */
break|break;
case|case
name|R_XTENSA_GNU_VTINHERIT
case|:
comment|/* This relocation describes the C++ object vtable hierarchy. 	     Reconstruct it for later use during GC.  */
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|R_XTENSA_GNU_VTENTRY
case|:
comment|/* This relocation describes which C++ vtable entries are actually 	     used.  Record for later use during GC.  */
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf_xtensa_hide_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|,
name|force_local
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_boolean
name|force_local
decl_stmt|;
block|{
comment|/* For a shared link, move the plt refcount to the got refcount to leave      space for RELATIVE relocs.  */
name|elf_xtensa_make_sym_local
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|_bfd_elf_link_hash_hide_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|force_local
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the section that should be marked against GC for a given    relocation.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|elf_xtensa_gc_mark_hook
parameter_list|(
name|sec
parameter_list|,
name|info
parameter_list|,
name|rel
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_XTENSA_GNU_VTINHERIT
case|:
case|case
name|R_XTENSA_GNU_VTENTRY
case|:
break|break;
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
default|default:
break|break;
block|}
block|}
block|}
else|else
return|return
name|bfd_section_from_elf_index
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Update the GOT& PLT entry reference counts    for the section being removed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_gc_sweep_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|unsigned
name|int
name|r_type
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_XTENSA_32
case|:
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
goto|goto
name|local_literal
goto|;
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|got
operator|.
name|refcount
operator|--
expr_stmt|;
break|break;
case|case
name|R_XTENSA_PLT
case|:
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
goto|goto
name|local_literal
goto|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|plt
operator|.
name|refcount
operator|--
expr_stmt|;
break|break;
name|local_literal
label|:
if|if
condition|(
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|>
literal|0
condition|)
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|-=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create all the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_create_dynamic_sections
parameter_list|(
name|dynobj
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|,
name|noalloc_flags
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* First do all the standard stuff.  */
if|if
condition|(
operator|!
name|_bfd_elf_create_dynamic_sections
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Create any extra PLT sections in case check_relocs has already      been called on all the non-dynamic input files.  */
if|if
condition|(
operator|!
name|add_extra_plt_sections
argument_list|(
name|dynobj
argument_list|,
name|plt_reloc_count
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|noalloc_flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
expr_stmt|;
name|flags
operator|=
name|noalloc_flags
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
comment|/* Mark the ".got.plt" section READONLY.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Create ".rela.got".  */
name|s
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Create ".got.loc" (literal tables for use by dynamic linker).  */
name|s
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
literal|".got.loc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Create ".xt.lit.plt" (literal table for ".got.plt*").  */
name|s
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
literal|".xt.lit.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
name|noalloc_flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|add_extra_plt_sections
parameter_list|(
name|dynobj
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|int
name|chunk
decl_stmt|;
comment|/* Iterate over all chunks except 0 which uses the standard ".plt" and      ".got.plt" sections.  */
for|for
control|(
name|chunk
operator|=
name|count
operator|/
name|PLT_ENTRIES_PER_CHUNK
init|;
name|chunk
operator|>
literal|0
condition|;
name|chunk
operator|--
control|)
block|{
name|char
modifier|*
name|sname
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* Stop when we find a section has already been created.  */
if|if
condition|(
name|elf_xtensa_get_plt_section
argument_list|(
name|dynobj
argument_list|,
name|chunk
argument_list|)
condition|)
break|break;
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
expr_stmt|;
name|sname
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sname
argument_list|,
literal|".plt.%u"
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
name|sname
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_CODE
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|sname
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
literal|14
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sname
argument_list|,
literal|".got.plt.%u"
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
name|sname
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_adjust_dynamic_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object.  The      reference must go through the GOT, so there's no need for COPY relocs,      .dynbss, etc.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf_xtensa_make_sym_local
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
comment|/* Will use RELATIVE relocs instead of JMP_SLOT relocs.  */
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|<
literal|0
condition|)
name|h
operator|->
name|got
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|refcount
operator|+=
name|h
operator|->
name|plt
operator|.
name|refcount
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Don't need any dynamic relocations at all.  */
name|h
operator|->
name|plt
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_fix_refcounts
parameter_list|(
name|h
parameter_list|,
name|arg
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|arg
decl_stmt|;
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
operator|!
name|xtensa_elf_dynamic_symbol_p
argument_list|(
name|h
argument_list|,
name|info
argument_list|)
condition|)
name|elf_xtensa_make_sym_local
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_allocate_plt_size
parameter_list|(
name|h
parameter_list|,
name|arg
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|arg
decl_stmt|;
block|{
name|asection
modifier|*
name|srelplt
init|=
operator|(
name|asection
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|srelplt
operator|->
name|_raw_size
operator|+=
operator|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_allocate_got_size
parameter_list|(
name|h
parameter_list|,
name|arg
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|arg
decl_stmt|;
block|{
name|asection
modifier|*
name|srelgot
init|=
operator|(
name|asection
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
name|srelgot
operator|->
name|_raw_size
operator|+=
operator|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf_xtensa_allocate_local_got_size
parameter_list|(
name|info
parameter_list|,
name|srelgot
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|srelgot
decl_stmt|;
block|{
name|bfd
modifier|*
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|info
operator|->
name|input_bfds
init|;
name|i
condition|;
name|i
operator|=
name|i
operator|->
name|link_next
control|)
block|{
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
name|bfd_size_type
name|j
decl_stmt|,
name|cnt
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_got_refcounts
condition|)
continue|continue;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|i
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|cnt
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|cnt
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|local_got_refcounts
index|[
name|j
index|]
operator|>
literal|0
condition|)
name|srelgot
operator|->
name|_raw_size
operator|+=
operator|(
name|local_got_refcounts
index|[
name|j
index|]
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_size_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|,
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|,
modifier|*
name|srelplt
decl_stmt|,
modifier|*
name|splt
decl_stmt|,
modifier|*
name|sgotplt
decl_stmt|,
modifier|*
name|srelgot
decl_stmt|,
modifier|*
name|spltlittbl
decl_stmt|,
modifier|*
name|sgotloc
decl_stmt|;
name|bfd_boolean
name|relplt
decl_stmt|,
name|relgot
decl_stmt|;
name|int
name|plt_entries
decl_stmt|,
name|plt_chunks
decl_stmt|,
name|chunk
decl_stmt|;
name|plt_entries
operator|=
literal|0
expr_stmt|;
name|plt_chunks
operator|=
literal|0
expr_stmt|;
name|srelgot
operator|=
literal|0
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
comment|/* Allocate room for one word in ".got".  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
literal|4
expr_stmt|;
comment|/* Adjust refcounts for symbols that we now know are not "dynamic".  */
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_xtensa_fix_refcounts
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
comment|/* Allocate space in ".rela.got" for literals that reference 	 global symbols.  */
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srelgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_xtensa_allocate_got_size
argument_list|,
operator|(
name|PTR
operator|)
name|srelgot
argument_list|)
expr_stmt|;
comment|/* If we are generating a shared object, we also need space in 	 ".rela.got" for R_XTENSA_RELATIVE relocs for literals that 	 reference local symbols.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|elf_xtensa_allocate_local_got_size
argument_list|(
name|info
argument_list|,
name|srelgot
argument_list|)
expr_stmt|;
comment|/* Allocate space in ".rela.plt" for literals that have PLT entries.  */
name|srelplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srelplt
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_xtensa_allocate_plt_size
argument_list|,
operator|(
name|PTR
operator|)
name|srelplt
argument_list|)
expr_stmt|;
comment|/* Allocate space in ".plt" to match the size of ".rela.plt".  For 	 each PLT entry, we need the PLT code plus a 4-byte literal. 	 For each chunk of ".plt", we also need two more 4-byte 	 literals, two corresponding entries in ".rela.got", and an 	 8-byte entry in ".xt.lit.plt".  */
name|spltlittbl
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".xt.lit.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spltlittbl
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|plt_entries
operator|=
name|srelplt
operator|->
name|_raw_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|plt_chunks
operator|=
operator|(
name|plt_entries
operator|+
name|PLT_ENTRIES_PER_CHUNK
operator|-
literal|1
operator|)
operator|/
name|PLT_ENTRIES_PER_CHUNK
expr_stmt|;
comment|/* Iterate over all the PLT chunks, including any extra sections 	 created earlier because the initial count of PLT relocations 	 was an overestimate.  */
for|for
control|(
name|chunk
operator|=
literal|0
init|;
operator|(
name|splt
operator|=
name|elf_xtensa_get_plt_section
argument_list|(
name|dynobj
argument_list|,
name|chunk
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|chunk
operator|++
control|)
block|{
name|int
name|chunk_entries
decl_stmt|;
name|sgotplt
operator|=
name|elf_xtensa_get_gotplt_section
argument_list|(
name|dynobj
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgotplt
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|chunk
operator|<
name|plt_chunks
operator|-
literal|1
condition|)
name|chunk_entries
operator|=
name|PLT_ENTRIES_PER_CHUNK
expr_stmt|;
elseif|else
if|if
condition|(
name|chunk
operator|==
name|plt_chunks
operator|-
literal|1
condition|)
name|chunk_entries
operator|=
name|plt_entries
operator|-
operator|(
name|chunk
operator|*
name|PLT_ENTRIES_PER_CHUNK
operator|)
expr_stmt|;
else|else
name|chunk_entries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chunk_entries
operator|!=
literal|0
condition|)
block|{
name|sgotplt
operator|->
name|_raw_size
operator|=
literal|4
operator|*
operator|(
name|chunk_entries
operator|+
literal|2
operator|)
expr_stmt|;
name|splt
operator|->
name|_raw_size
operator|=
name|PLT_ENTRY_SIZE
operator|*
name|chunk_entries
expr_stmt|;
name|srelgot
operator|->
name|_raw_size
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|spltlittbl
operator|->
name|_raw_size
operator|+=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|sgotplt
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|splt
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Allocate space in ".got.loc" to match the total size of all the 	 literal tables.  */
name|sgotloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.loc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgotloc
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|sgotloc
operator|->
name|_raw_size
operator|=
name|spltlittbl
operator|->
name|_raw_size
expr_stmt|;
for|for
control|(
name|abfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|abfd
operator|!=
name|NULL
condition|;
name|abfd
operator|=
name|abfd
operator|->
name|link_next
control|)
block|{
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
condition|)
continue|continue;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|elf_discarded_section
argument_list|(
name|s
argument_list|)
operator|&&
name|xtensa_is_littable_section
argument_list|(
name|s
argument_list|)
operator|&&
name|s
operator|!=
name|spltlittbl
condition|)
name|sgotloc
operator|->
name|_raw_size
operator|+=
name|s
operator|->
name|_raw_size
expr_stmt|;
block|}
block|}
block|}
comment|/* Allocate memory for dynamic sections.  */
name|relplt
operator|=
name|FALSE
expr_stmt|;
name|relgot
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_boolean
name|strip
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* It's OK to base decisions on the section name, because none 	 of the dynobj section names depend upon the input files.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|strip
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rela.plt"
argument_list|)
operator|==
literal|0
condition|)
name|relplt
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rela.got"
argument_list|)
operator|==
literal|0
condition|)
name|relgot
operator|=
name|TRUE
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need 	     to copy relocs into the output file.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".plt."
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".got.plt."
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
comment|/* If we don't need this section, strip it from the output 		 file.  We must create the ".plt*" and ".got.plt*" 		 sections in create_dynamic_sections and/or check_relocs 		 based on a conservative estimate of the PLT relocation 		 count, because the sections must be created before the 		 linker maps input sections to output sections.  The 		 linker does that before size_dynamic_sections, where we 		 compute the exact size of the PLT, so there may be more 		 of these sections than are actually needed.  */
name|strip
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".got"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".plt"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".got.plt"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".xt.lit.plt"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".got.loc"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|strip
condition|)
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Allocate memory for the section contents.  */
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|s
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Add the special XTENSA_RTLD relocations now.  The offsets won't be 	 known until finish_dynamic_sections, but we need to get the relocs 	 in place before they are sorted.  */
if|if
condition|(
name|srelgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|chunk
operator|=
literal|0
init|;
name|chunk
operator|<
name|plt_chunks
condition|;
name|chunk
operator|++
control|)
block|{
name|Elf_Internal_Rela
name|irela
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|irela
operator|.
name|r_offset
operator|=
literal|0
expr_stmt|;
name|irela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_XTENSA_RTLD
argument_list|)
expr_stmt|;
name|irela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
operator|(
name|srelgot
operator|->
name|contents
operator|+
name|srelgot
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|irela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|irela
argument_list|,
name|loc
operator|+
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
argument_list|)
expr_stmt|;
name|srelgot
operator|->
name|reloc_count
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in elf_xtensa_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
define|#
directive|define
name|add_dynamic_entry
parameter_list|(
name|TAG
parameter_list|,
name|VAL
parameter_list|)
define|\
value|_bfd_elf_add_dynamic_entry (info, TAG, VAL)
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|relplt
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTREL
argument_list|,
name|DT_RELA
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|relgot
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELA
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELAENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_XTENSA_GOT_LOC_OFF
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_XTENSA_GOT_LOC_SZ
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
undef|#
directive|undef
name|add_dynamic_entry
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remove any PT_LOAD segments with no allocated sections.  Prior to    binutils 2.13, this function used to remove the non-SEC_ALLOC    sections from PT_LOAD segments, but that task has now been moved    into elf.c.  We still need this function to remove any empty    segments that result, but there's nothing Xtensa-specific about    this and it probably ought to be moved into elf.c as well.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_modify_segment_map
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|elf_segment_map
modifier|*
modifier|*
name|m_p
decl_stmt|;
name|m_p
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
expr_stmt|;
while|while
condition|(
operator|*
name|m_p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|m_p
operator|)
operator|->
name|p_type
operator|==
name|PT_LOAD
operator|&&
operator|(
operator|*
name|m_p
operator|)
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|m_p
operator|=
operator|(
operator|*
name|m_p
operator|)
operator|->
name|next
expr_stmt|;
else|else
name|m_p
operator|=
operator|&
operator|(
operator|*
name|m_p
operator|)
operator|->
name|next
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform the specified relocation.  The instruction at (contents + address)    is modified to set one operand to represent the value in "relocation".  The    operand position is determined by the relocation type recorded in the    howto.  */
end_comment

begin_define
define|#
directive|define
name|CALL_SEGMENT_BITS
value|(30)
end_define

begin_define
define|#
directive|define
name|CALL_SEGMENT_SIZE
value|(1<<CALL_SEGMENT_BITS)
end_define

begin_function
specifier|static
name|bfd_reloc_status_type
name|elf_xtensa_do_reloc
parameter_list|(
name|howto
parameter_list|,
name|abfd
parameter_list|,
name|input_section
parameter_list|,
name|relocation
parameter_list|,
name|contents
parameter_list|,
name|address
parameter_list|,
name|is_weak_undef
parameter_list|,
name|error_message
parameter_list|)
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
name|bfd_boolean
name|is_weak_undef
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|xtensa_opcode
name|opcode
decl_stmt|;
name|xtensa_operand
name|operand
decl_stmt|;
name|xtensa_encode_result
name|encode_result
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|xtensa_insnbuf
name|ibuff
decl_stmt|;
name|bfd_vma
name|self_address
decl_stmt|;
name|int
name|opnd
decl_stmt|;
name|uint32
name|newval
decl_stmt|;
switch|switch
condition|(
name|howto
operator|->
name|type
condition|)
block|{
case|case
name|R_XTENSA_NONE
case|:
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_XTENSA_ASM_EXPAND
case|:
if|if
condition|(
operator|!
name|is_weak_undef
condition|)
block|{
comment|/* Check for windowed CALL across a 1GB boundary.  */
name|xtensa_opcode
name|opcode
init|=
name|get_expanded_call_opcode
argument_list|(
name|contents
operator|+
name|address
argument_list|,
name|input_section
operator|->
name|_raw_size
operator|-
name|address
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_windowed_call_opcode
argument_list|(
name|opcode
argument_list|)
condition|)
block|{
name|self_address
operator|=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|address
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|self_address
operator|>>
name|CALL_SEGMENT_BITS
operator|)
operator|!=
operator|(
name|relocation
operator|>>
name|CALL_SEGMENT_BITS
operator|)
condition|)
block|{
operator|*
name|error_message
operator|=
literal|"windowed longcall crosses 1GB boundary; "
literal|"return may fail"
expr_stmt|;
return|return
name|bfd_reloc_dangerous
return|;
block|}
block|}
block|}
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_XTENSA_ASM_SIMPLIFY
case|:
block|{
comment|/* Convert the L32R/CALLX to CALL.  */
name|bfd_reloc_status_type
name|retval
init|=
name|elf_xtensa_do_asm_simplify
argument_list|(
name|contents
argument_list|,
name|address
argument_list|,
name|input_section
operator|->
name|_raw_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|retval
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|retval
return|;
comment|/* The CALL needs to be relocated.  Continue below for that part.  */
name|address
operator|+=
literal|3
expr_stmt|;
name|howto
operator|=
operator|&
name|elf_howto_table
index|[
operator|(
name|unsigned
operator|)
name|R_XTENSA_OP0
index|]
expr_stmt|;
block|}
break|break;
case|case
name|R_XTENSA_32
case|:
case|case
name|R_XTENSA_PLT
case|:
block|{
name|bfd_vma
name|x
decl_stmt|;
name|x
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|address
argument_list|)
expr_stmt|;
name|x
operator|=
name|x
operator|+
name|relocation
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
name|contents
operator|+
name|address
argument_list|)
expr_stmt|;
block|}
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* Read the instruction into a buffer and decode the opcode.  */
name|ibuff
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|ibuff
argument_list|,
name|contents
operator|+
name|address
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|xtensa_decode_insn
argument_list|(
name|isa
argument_list|,
name|ibuff
argument_list|)
expr_stmt|;
comment|/* Determine which operand is being relocated.  */
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
operator|*
name|error_message
operator|=
literal|"cannot decode instruction"
expr_stmt|;
return|return
name|bfd_reloc_dangerous
return|;
block|}
if|if
condition|(
name|howto
operator|->
name|type
operator|<
name|R_XTENSA_OP0
operator|||
name|howto
operator|->
name|type
operator|>
name|R_XTENSA_OP2
condition|)
block|{
operator|*
name|error_message
operator|=
literal|"unexpected relocation"
expr_stmt|;
return|return
name|bfd_reloc_dangerous
return|;
block|}
name|opnd
operator|=
name|howto
operator|->
name|type
operator|-
name|R_XTENSA_OP0
expr_stmt|;
comment|/* Calculate the PC address for this instruction.  */
if|if
condition|(
operator|!
name|howto
operator|->
name|pc_relative
condition|)
block|{
operator|*
name|error_message
operator|=
literal|"expected PC-relative relocation"
expr_stmt|;
return|return
name|bfd_reloc_dangerous
return|;
block|}
name|self_address
operator|=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|address
operator|)
expr_stmt|;
comment|/* Apply the relocation.  */
name|operand
operator|=
name|xtensa_get_operand
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|opnd
argument_list|)
expr_stmt|;
name|newval
operator|=
name|xtensa_operand_do_reloc
argument_list|(
name|operand
argument_list|,
name|relocation
argument_list|,
name|self_address
argument_list|)
expr_stmt|;
name|encode_result
operator|=
name|xtensa_operand_encode
argument_list|(
name|operand
argument_list|,
operator|&
name|newval
argument_list|)
expr_stmt|;
name|xtensa_operand_set_field
argument_list|(
name|operand
argument_list|,
name|ibuff
argument_list|,
name|newval
argument_list|)
expr_stmt|;
comment|/* Write the modified instruction back out of the buffer.  */
name|xtensa_insnbuf_to_chars
argument_list|(
name|isa
argument_list|,
name|ibuff
argument_list|,
name|contents
operator|+
name|address
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ibuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|encode_result
operator|!=
name|xtensa_encode_result_ok
condition|)
block|{
name|char
modifier|*
name|message
init|=
name|build_encoding_error_message
argument_list|(
name|opcode
argument_list|,
name|encode_result
argument_list|)
decl_stmt|;
operator|*
name|error_message
operator|=
name|message
expr_stmt|;
return|return
name|bfd_reloc_dangerous
return|;
block|}
comment|/* Final check for call.  */
if|if
condition|(
name|is_direct_call_opcode
argument_list|(
name|opcode
argument_list|)
operator|&&
name|is_windowed_call_opcode
argument_list|(
name|opcode
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|self_address
operator|>>
name|CALL_SEGMENT_BITS
operator|)
operator|!=
operator|(
name|relocation
operator|>>
name|CALL_SEGMENT_BITS
operator|)
condition|)
block|{
operator|*
name|error_message
operator|=
literal|"windowed call crosses 1GB boundary; "
literal|"return may fail"
expr_stmt|;
return|return
name|bfd_reloc_dangerous
return|;
block|}
block|}
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vsprint_msg
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|origmsg
operator|,
specifier|const
name|char
operator|*
name|fmt
operator|,
name|int
name|arglen
operator|,
operator|...
operator|)
argument_list|)
block|{
comment|/* To reduce the size of the memory leak,      we only use a single message buffer.  */
specifier|static
name|bfd_size_type
name|alloc_size
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
name|message
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|orig_len
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|;
name|bfd_boolean
name|is_append
decl_stmt|;
name|VA_OPEN
argument_list|(
name|ap
argument_list|,
name|arglen
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|origmsg
argument_list|)
expr_stmt|;
name|is_append
operator|=
operator|(
name|origmsg
operator|==
name|message
operator|)
expr_stmt|;
name|orig_len
operator|=
name|strlen
argument_list|(
name|origmsg
argument_list|)
expr_stmt|;
name|len
operator|=
name|orig_len
operator|+
name|strlen
argument_list|(
name|fmt
argument_list|)
operator|+
name|arglen
operator|+
literal|20
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|alloc_size
condition|)
block|{
name|message
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_realloc
argument_list|(
name|message
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|alloc_size
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_append
condition|)
name|memcpy
argument_list|(
name|message
argument_list|,
name|origmsg
argument_list|,
name|orig_len
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|message
operator|+
name|orig_len
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|message
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|build_encoding_error_message
parameter_list|(
name|opcode
parameter_list|,
name|encode_result
parameter_list|)
name|xtensa_opcode
name|opcode
decl_stmt|;
name|xtensa_encode_result
name|encode_result
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|opname
init|=
name|xtensa_opcode_name
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|encode_result
condition|)
block|{
case|case
name|xtensa_encode_result_ok
case|:
name|msg
operator|=
literal|"unexpected valid encoding"
expr_stmt|;
break|break;
case|case
name|xtensa_encode_result_align
case|:
name|msg
operator|=
literal|"misaligned encoding"
expr_stmt|;
break|break;
case|case
name|xtensa_encode_result_not_in_table
case|:
name|msg
operator|=
literal|"encoding not in lookup table"
expr_stmt|;
break|break;
case|case
name|xtensa_encode_result_too_low
case|:
name|msg
operator|=
literal|"encoding out of range: too low"
expr_stmt|;
break|break;
case|case
name|xtensa_encode_result_too_high
case|:
name|msg
operator|=
literal|"encoding out of range: too high"
expr_stmt|;
break|break;
case|case
name|xtensa_encode_result_not_ok
case|:
default|default:
name|msg
operator|=
literal|"could not encode"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|is_direct_call_opcode
argument_list|(
name|opcode
argument_list|)
operator|&&
operator|(
name|encode_result
operator|==
name|xtensa_encode_result_too_low
operator|||
name|encode_result
operator|==
name|xtensa_encode_result_too_high
operator|)
condition|)
name|msg
operator|=
literal|"direct call out of range"
expr_stmt|;
elseif|else
if|if
condition|(
name|opcode
operator|==
name|get_l32r_opcode
argument_list|()
condition|)
block|{
comment|/* L32Rs have the strange interaction with encoding in that they          have an unsigned immediate field, so libisa returns "too high"          when the absolute value is out of range and never returns "too          low", but I leave the "too low" message in case anything          changes.  */
if|if
condition|(
name|encode_result
operator|==
name|xtensa_encode_result_too_low
condition|)
name|msg
operator|=
literal|"literal out of range"
expr_stmt|;
elseif|else
if|if
condition|(
name|encode_result
operator|==
name|xtensa_encode_result_too_high
condition|)
name|msg
operator|=
literal|"literal placed after use"
expr_stmt|;
block|}
return|return
name|vsprint_msg
argument_list|(
name|opname
argument_list|,
literal|": %s"
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
operator|+
literal|2
argument_list|,
name|msg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This function is registered as the "special_function" in the    Xtensa howto for handling simplify operations.    bfd_perform_relocation / bfd_install_relocation use it to    perform (install) the specified relocation.  Since this replaces the code    in bfd_perform_relocation, it is basically an Xtensa-specific,    stripped-down version of bfd_perform_relocation.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|bfd_elf_xtensa_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|flag
decl_stmt|;
name|bfd_size_type
name|octets
init|=
name|reloc_entry
operator|->
name|address
operator|*
name|bfd_octets_per_byte
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|bfd_vma
name|output_base
init|=
literal|0
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
init|=
name|reloc_entry
operator|->
name|howto
decl_stmt|;
name|asection
modifier|*
name|reloc_target_output_section
decl_stmt|;
name|bfd_boolean
name|is_weak_undef
decl_stmt|;
comment|/* ELF relocs are against symbols.  If we are producing relocatable      output, and the reloc is against an external symbol, the resulting      reloc will also be against the same symbol.  In such a case, we      don't want to change anything about the way the reloc is handled,      since it will all be done at final link time.  This test is similar      to what bfd_elf_generic_reloc does except that it lets relocs with      howto->partial_inplace go through even if the addend is non-zero.      (The real problem is that partial_inplace is set for XTENSA_32      relocs to begin with, but that's a long story and there's little we      can do about it now....)  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* Is the address of the relocation really within the section?  */
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
operator|(
name|input_section
operator|->
name|_cooked_size
operator|/
name|bfd_octets_per_byte
argument_list|(
name|abfd
argument_list|)
operator|)
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* Work out which section the relocation is targeted at and the      initial relocation command value.  */
comment|/* Get symbol value.  (Common symbols are special.)  */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|reloc_target_output_section
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
expr_stmt|;
comment|/* Convert input-section-relative symbol value to absolute.  */
if|if
condition|(
operator|(
name|output_bfd
operator|&&
operator|!
name|howto
operator|->
name|partial_inplace
operator|)
operator|||
name|reloc_target_output_section
operator|==
name|NULL
condition|)
name|output_base
operator|=
literal|0
expr_stmt|;
else|else
name|output_base
operator|=
name|reloc_target_output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|output_base
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
comment|/* Add in supplied addend.  */
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
comment|/* Here the variable relocation holds the final address of the      symbol we are relocating against, plus any addend.  */
if|if
condition|(
name|output_bfd
condition|)
block|{
if|if
condition|(
operator|!
name|howto
operator|->
name|partial_inplace
condition|)
block|{
comment|/* This is a partial relocation, and we want to apply the relocation 	     to the reloc entry rather than the raw data.  Everything except 	     relocations against section symbols has already been handled 	     above.  */
name|BFD_ASSERT
argument_list|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
argument_list|)
expr_stmt|;
name|reloc_entry
operator|->
name|addend
operator|=
name|relocation
expr_stmt|;
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
else|else
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
name|reloc_entry
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|is_weak_undef
operator|=
operator|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|flag
operator|=
name|elf_xtensa_do_reloc
argument_list|(
name|howto
argument_list|,
name|abfd
argument_list|,
name|input_section
argument_list|,
name|relocation
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
argument_list|,
operator|(
name|bfd_vma
operator|)
name|octets
argument_list|,
name|is_weak_undef
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|bfd_reloc_dangerous
condition|)
block|{
comment|/* Add the symbol name to the error message.  */
if|if
condition|(
operator|!
operator|*
name|error_message
condition|)
operator|*
name|error_message
operator|=
literal|""
expr_stmt|;
operator|*
name|error_message
operator|=
name|vsprint_msg
argument_list|(
operator|*
name|error_message
argument_list|,
literal|": (%s + 0x%lx)"
argument_list|,
name|strlen
argument_list|(
name|symbol
operator|->
name|name
argument_list|)
operator|+
literal|17
argument_list|,
name|symbol
operator|->
name|name
argument_list|,
name|reloc_entry
operator|->
name|addend
argument_list|)
expr_stmt|;
block|}
return|return
name|flag
return|;
block|}
end_function

begin_comment
comment|/* Set up an entry in the procedure linkage table.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|elf_xtensa_create_plt_entry
parameter_list|(
name|dynobj
parameter_list|,
name|output_bfd
parameter_list|,
name|reloc_index
parameter_list|)
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|unsigned
name|reloc_index
decl_stmt|;
block|{
name|asection
modifier|*
name|splt
decl_stmt|,
modifier|*
name|sgotplt
decl_stmt|;
name|bfd_vma
name|plt_base
decl_stmt|,
name|got_base
decl_stmt|;
name|bfd_vma
name|code_offset
decl_stmt|,
name|lit_offset
decl_stmt|;
name|int
name|chunk
decl_stmt|;
name|chunk
operator|=
name|reloc_index
operator|/
name|PLT_ENTRIES_PER_CHUNK
expr_stmt|;
name|splt
operator|=
name|elf_xtensa_get_plt_section
argument_list|(
name|dynobj
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|sgotplt
operator|=
name|elf_xtensa_get_gotplt_section
argument_list|(
name|dynobj
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|sgotplt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|plt_base
operator|=
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
expr_stmt|;
name|got_base
operator|=
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgotplt
operator|->
name|output_offset
expr_stmt|;
name|lit_offset
operator|=
literal|8
operator|+
operator|(
name|reloc_index
operator|%
name|PLT_ENTRIES_PER_CHUNK
operator|)
operator|*
literal|4
expr_stmt|;
name|code_offset
operator|=
operator|(
name|reloc_index
operator|%
name|PLT_ENTRIES_PER_CHUNK
operator|)
operator|*
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* Fill in the literal entry.  This is the offset of the dynamic      relocation entry.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|reloc_index
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
argument_list|,
name|sgotplt
operator|->
name|contents
operator|+
name|lit_offset
argument_list|)
expr_stmt|;
comment|/* Fill in the entry in the procedure linkage table.  */
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
operator|+
name|code_offset
argument_list|,
operator|(
name|bfd_big_endian
argument_list|(
name|output_bfd
argument_list|)
condition|?
name|elf_xtensa_be_plt_entry
else|:
name|elf_xtensa_le_plt_entry
operator|)
argument_list|,
name|PLT_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|output_bfd
argument_list|,
name|l32r_offset
argument_list|(
name|got_base
operator|+
literal|0
argument_list|,
name|plt_base
operator|+
name|code_offset
operator|+
literal|3
argument_list|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|code_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|output_bfd
argument_list|,
name|l32r_offset
argument_list|(
name|got_base
operator|+
literal|4
argument_list|,
name|plt_base
operator|+
name|code_offset
operator|+
literal|6
argument_list|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|code_offset
operator|+
literal|7
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|output_bfd
argument_list|,
name|l32r_offset
argument_list|(
name|got_base
operator|+
name|lit_offset
argument_list|,
name|plt_base
operator|+
name|code_offset
operator|+
literal|9
argument_list|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|code_offset
operator|+
literal|10
argument_list|)
expr_stmt|;
return|return
name|plt_base
operator|+
name|code_offset
return|;
block|}
end_function

begin_comment
comment|/* Relocate an Xtensa ELF section.  This is invoked by the linker for    both relocatable and final links.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|asection
modifier|*
name|srelgot
decl_stmt|,
modifier|*
name|srelplt
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|property_table_entry
modifier|*
name|lit_table
init|=
literal|0
decl_stmt|;
name|int
name|ltblsize
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|error_message
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|xtensa_default_isa
operator|==
name|NULL
condition|)
name|xtensa_isa_init
argument_list|()
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|srelgot
operator|=
name|NULL
expr_stmt|;
name|srelplt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dynobj
operator|!=
name|NULL
condition|)
block|{
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
empty_stmt|;
name|srelplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|ltblsize
operator|=
name|xtensa_read_table_entries
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|&
name|lit_table
argument_list|,
name|XTENSA_LIT_SEC_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|ltblsize
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|bfd_boolean
name|is_weak_undef
decl_stmt|;
name|bfd_boolean
name|unresolved_reloc
decl_stmt|;
name|bfd_boolean
name|warned
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
operator|(
name|int
operator|)
name|R_XTENSA_GNU_VTINHERIT
operator|||
name|r_type
operator|==
operator|(
name|int
operator|)
name|R_XTENSA_GNU_VTENTRY
condition|)
continue|continue;
if|if
condition|(
name|r_type
operator|<
literal|0
operator|||
name|r_type
operator|>=
operator|(
name|int
operator|)
name|R_XTENSA_max
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|howto
operator|=
operator|&
name|elf_howto_table
index|[
name|r_type
index|]
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
block|{
comment|/* This is a relocatable link.  	     1) If the reloc is against a section symbol, adjust 	     according to the output section. 	     2) If there is a new target for this relocation, 	     the new target will be in the same output section. 	     We adjust the relocation by the output section 	     difference.  */
if|if
condition|(
name|relaxing_section
condition|)
block|{
comment|/* Check if this references a section in another input file.  */
name|do_fix_for_relocatable_link
argument_list|(
name|rel
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_XTENSA_ASM_SIMPLIFY
condition|)
block|{
comment|/* Convert ASM_SIMPLIFY into the simpler relocation 		 so that they never escape a relaxing link.  */
name|contract_asm_expansion
argument_list|(
name|contents
argument_list|,
name|input_section
operator|->
name|_raw_size
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
block|}
comment|/* This is a relocatable link, so we don't have to change 	     anything unless the reloc is against a section symbol, 	     in which case we have to adjust according to where the 	     section symbol winds up in the output section.  */
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|+=
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
expr_stmt|;
block|}
block|}
comment|/* If there is an addend with a partial_inplace howto, 	     then move the addend to the contents.  This is a hack 	     to work around problems with DWARF in relocatable links 	     with some previous version of BFD.  Now we can't easily get 	     rid of the hack without breaking backward compatibility.... */
if|if
condition|(
name|rel
operator|->
name|r_addend
condition|)
block|{
name|howto
operator|=
operator|&
name|elf_howto_table
index|[
name|r_type
index|]
expr_stmt|;
if|if
condition|(
name|howto
operator|->
name|partial_inplace
condition|)
block|{
name|r
operator|=
name|elf_xtensa_do_reloc
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|FALSE
argument_list|,
operator|&
name|error_message
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|info
argument_list|,
name|error_message
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
name|rel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Done with work for relocatable link; continue with next reloc.  */
continue|continue;
block|}
comment|/* This is a final link.  */
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
name|is_weak_undef
operator|=
name|FALSE
expr_stmt|;
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
name|warned
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|howto
operator|->
name|partial_inplace
condition|)
block|{
comment|/* Because R_XTENSA_32 was made partial_inplace to fix some 	     problems with DWARF info in partial links, there may be 	     an addend stored in the contents.  Take it out of there 	     and move it back into the addend field of the reloc.  */
name|rel
operator|->
name|r_addend
operator|+=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
literal|0
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocation
operator|==
literal|0
operator|&&
operator|!
name|unresolved_reloc
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|is_weak_undef
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|relaxing_section
condition|)
block|{
comment|/* Check if this references a section in another input file.  */
name|do_fix_for_final_link
argument_list|(
name|rel
argument_list|,
name|input_section
argument_list|,
operator|&
name|relocation
argument_list|)
expr_stmt|;
comment|/* Update some already cached values.  */
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|howto
operator|=
operator|&
name|elf_howto_table
index|[
name|r_type
index|]
expr_stmt|;
block|}
comment|/* Sanity check the address.  */
if|if
condition|(
name|rel
operator|->
name|r_offset
operator|>=
name|input_section
operator|->
name|_raw_size
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_XTENSA_NONE
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Generate dynamic relocations.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|bfd_boolean
name|dynamic_symbol
init|=
name|xtensa_elf_dynamic_symbol_p
argument_list|(
name|h
argument_list|,
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|dynamic_symbol
operator|&&
operator|(
name|r_type
operator|==
name|R_XTENSA_OP0
operator|||
name|r_type
operator|==
name|R_XTENSA_OP1
operator|||
name|r_type
operator|==
name|R_XTENSA_OP2
operator|)
condition|)
block|{
comment|/* This is an error.  The symbol's real value won't be known 		 until runtime and it's likely to be out of range anyway.  */
specifier|const
name|char
modifier|*
name|name
init|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
decl_stmt|;
name|error_message
operator|=
name|vsprint_msg
argument_list|(
literal|"invalid relocation for dynamic "
literal|"symbol"
argument_list|,
literal|": %s"
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|info
argument_list|,
name|error_message
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|r_type
operator|==
name|R_XTENSA_32
operator|||
name|r_type
operator|==
name|R_XTENSA_PLT
operator|)
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|dynamic_symbol
operator|||
name|info
operator|->
name|shared
operator|)
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
if|if
condition|(
name|dynamic_symbol
operator|&&
name|r_type
operator|==
name|R_XTENSA_PLT
condition|)
name|srel
operator|=
name|srelplt
expr_stmt|;
else|else
name|srel
operator|=
name|srelgot
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|outrel
operator|.
name|r_offset
operator||
literal|1
operator|)
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|outrel
argument_list|)
expr_stmt|;
else|else
block|{
name|outrel
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
comment|/* Complain if the relocation is in a read-only section 		     and not in a literal pool.  */
if|if
condition|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|elf_xtensa_in_literal_pool
argument_list|(
name|lit_table
argument_list|,
name|ltblsize
argument_list|,
name|outrel
operator|.
name|r_offset
argument_list|)
condition|)
block|{
name|error_message
operator|=
name|_
argument_list|(
literal|"dynamic relocation in read-only section"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|info
argument_list|,
name|error_message
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|dynamic_symbol
condition|)
block|{
name|outrel
operator|.
name|r_addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_XTENSA_32
condition|)
block|{
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_XTENSA_GLOB_DAT
argument_list|)
expr_stmt|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* r_type == R_XTENSA_PLT */
block|{
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_XTENSA_JMP_SLOT
argument_list|)
expr_stmt|;
comment|/* Create the PLT entry and set the initial 			     contents of the literal entry to the address of 			     the PLT entry.  */
name|relocation
operator|=
name|elf_xtensa_create_plt_entry
argument_list|(
name|dynobj
argument_list|,
name|output_bfd
argument_list|,
name|srel
operator|->
name|reloc_count
argument_list|)
expr_stmt|;
block|}
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* Generate a RELATIVE relocation.  */
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_XTENSA_RELATIVE
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|loc
operator|=
operator|(
name|srel
operator|->
name|contents
operator|+
name|srel
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|*
name|srel
operator|->
name|reloc_count
operator|<=
name|srel
operator|->
name|_cooked_size
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Dynamic relocs are not propagated for SEC_DEBUGGING sections 	 because such sections are not SEC_ALLOC and thus ld.so will 	 not process them.  */
if|if
condition|(
name|unresolved_reloc
operator|&&
operator|!
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s(%s+0x%lx): unresolvable relocation against symbol `%s'"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
comment|/* There's no point in calling bfd_perform_relocation here. 	 Just go directly to our "special function".  */
name|r
operator|=
name|elf_xtensa_do_reloc
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|is_weak_undef
argument_list|,
operator|&
name|error_message
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
operator|&&
operator|!
name|warned
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|r
operator|==
name|bfd_reloc_dangerous
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|error_message
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|&&
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
condition|)
name|error_message
operator|=
name|vsprint_msg
argument_list|(
name|error_message
argument_list|,
literal|": %s"
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|info
argument_list|,
name|error_message
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|lit_table
condition|)
name|free
argument_list|(
name|lit_table
argument_list|)
expr_stmt|;
name|input_section
operator|->
name|reloc_done
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  There's not much to do here since    the PLT and GOT entries are all set up by relocate_section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_finish_dynamic_symbol
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Mark the symbol as undefined, rather than as defined in 	 the .plt section.  Leave the value alone.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
block|}
comment|/* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Combine adjacent literal table entries in the output.  Adjacent    entries within each input section may have been removed during    relaxation, but we repeat the process here, even though it's too late    to shrink the output section, because it's important to minimize the    number of literal table entries to reduce the start-up work for the    runtime linker.  Returns the number of remaining table entries or -1    on error.  */
end_comment

begin_function
specifier|static
name|int
name|elf_xtensa_combine_prop_entries
parameter_list|(
name|output_bfd
parameter_list|,
name|sxtlit
parameter_list|,
name|sgotloc
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|asection
modifier|*
name|sxtlit
decl_stmt|;
name|asection
modifier|*
name|sgotloc
decl_stmt|;
block|{
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|property_table_entry
modifier|*
name|table
decl_stmt|;
name|bfd_size_type
name|section_size
decl_stmt|,
name|sgotloc_size
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|int
name|n
decl_stmt|,
name|m
decl_stmt|,
name|num
decl_stmt|;
name|section_size
operator|=
operator|(
name|sxtlit
operator|->
name|_cooked_size
operator|!=
literal|0
condition|?
name|sxtlit
operator|->
name|_cooked_size
else|:
name|sxtlit
operator|->
name|_raw_size
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|section_size
operator|%
literal|8
operator|==
literal|0
argument_list|)
expr_stmt|;
name|num
operator|=
name|section_size
operator|/
literal|8
expr_stmt|;
name|sgotloc_size
operator|=
operator|(
name|sgotloc
operator|->
name|_cooked_size
operator|!=
literal|0
condition|?
name|sgotloc
operator|->
name|_cooked_size
else|:
name|sgotloc
operator|->
name|_raw_size
operator|)
expr_stmt|;
if|if
condition|(
name|sgotloc_size
operator|!=
name|section_size
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"internal inconsistency in size of .got.loc section"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|section_size
argument_list|)
expr_stmt|;
name|table
operator|=
operator|(
name|property_table_entry
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|num
operator|*
sizeof|sizeof
argument_list|(
name|property_table_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
literal|0
operator|||
name|table
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* The ".xt.lit.plt" section has the SEC_IN_MEMORY flag set and this      propagates to the output section, where it doesn't really apply and      where it breaks the following call to bfd_get_section_contents.  */
name|sxtlit
operator|->
name|flags
operator|&=
operator|~
name|SEC_IN_MEMORY
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|sxtlit
argument_list|,
name|contents
argument_list|,
literal|0
argument_list|,
name|section_size
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* There should never be any relocations left at this point, so this      is quite a bit easier than what is done during relaxation.  */
comment|/* Copy the raw contents into a property table array and sort it.  */
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num
condition|;
name|n
operator|++
control|)
block|{
name|table
index|[
name|n
index|]
operator|.
name|address
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|contents
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
name|table
index|[
name|n
index|]
operator|.
name|size
operator|=
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|contents
index|[
name|offset
operator|+
literal|4
index|]
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
block|}
name|qsort
argument_list|(
name|table
argument_list|,
name|num
argument_list|,
sizeof|sizeof
argument_list|(
name|property_table_entry
argument_list|)
argument_list|,
name|property_table_compare
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num
condition|;
name|n
operator|++
control|)
block|{
name|bfd_boolean
name|remove
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|table
index|[
name|n
index|]
operator|.
name|size
operator|==
literal|0
condition|)
name|remove
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
operator|(
name|table
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|address
operator|+
name|table
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|size
operator|==
name|table
index|[
name|n
index|]
operator|.
name|address
operator|)
condition|)
block|{
name|table
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|size
operator|+=
name|table
index|[
name|n
index|]
operator|.
name|size
expr_stmt|;
name|remove
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|remove
condition|)
block|{
for|for
control|(
name|m
operator|=
name|n
init|;
name|m
operator|<
name|num
operator|-
literal|1
condition|;
name|m
operator|++
control|)
block|{
name|table
index|[
name|m
index|]
operator|.
name|address
operator|=
name|table
index|[
name|m
operator|+
literal|1
index|]
operator|.
name|address
expr_stmt|;
name|table
index|[
name|m
index|]
operator|.
name|size
operator|=
name|table
index|[
name|m
operator|+
literal|1
index|]
operator|.
name|size
expr_stmt|;
block|}
name|n
operator|--
expr_stmt|;
name|num
operator|--
expr_stmt|;
block|}
block|}
comment|/* Copy the data back to the raw contents.  */
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|num
condition|;
name|n
operator|++
control|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|table
index|[
name|n
index|]
operator|.
name|address
argument_list|,
operator|&
name|contents
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|table
index|[
name|n
index|]
operator|.
name|size
argument_list|,
operator|&
name|contents
index|[
name|offset
operator|+
literal|4
index|]
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* Clear the removed bytes.  */
if|if
condition|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|num
operator|*
literal|8
argument_list|)
operator|<
name|section_size
condition|)
block|{
name|memset
argument_list|(
operator|&
name|contents
index|[
name|num
operator|*
literal|8
index|]
argument_list|,
literal|0
argument_list|,
name|section_size
operator|-
name|num
operator|*
literal|8
argument_list|)
expr_stmt|;
name|sxtlit
operator|->
name|_cooked_size
operator|=
name|num
operator|*
literal|8
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|sxtlit
argument_list|,
name|contents
argument_list|,
literal|0
argument_list|,
name|section_size
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Copy the contents to ".got.loc".  */
name|memcpy
argument_list|(
name|sgotloc
operator|->
name|contents
argument_list|,
name|contents
argument_list|,
name|section_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|table
argument_list|)
expr_stmt|;
return|return
name|num
return|;
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_finish_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|,
modifier|*
name|srelplt
decl_stmt|,
modifier|*
name|sgot
decl_stmt|,
modifier|*
name|sxtlit
decl_stmt|,
modifier|*
name|sgotloc
decl_stmt|;
name|Elf32_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
name|int
name|num_xtlit_entries
decl_stmt|;
if|if
condition|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
return|return
name|TRUE
return|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Set the first entry in the global offset table to the address of      the dynamic section.  */
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgot
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|sgot
operator|->
name|_raw_size
operator|==
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdyn
operator|==
name|NULL
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
else|else
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sdyn
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sdyn
operator|->
name|output_offset
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
block|}
name|srelplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srelplt
operator|!=
name|NULL
operator|&&
name|srelplt
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|sgotplt
decl_stmt|,
modifier|*
name|srelgot
decl_stmt|,
modifier|*
name|spltlittbl
decl_stmt|;
name|int
name|chunk
decl_stmt|,
name|plt_chunks
decl_stmt|,
name|plt_entries
decl_stmt|;
name|Elf_Internal_Rela
name|irela
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|unsigned
name|rtld_reloc
decl_stmt|;
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
empty_stmt|;
name|BFD_ASSERT
argument_list|(
name|srelgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|spltlittbl
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".xt.lit.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|spltlittbl
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Find the first XTENSA_RTLD relocation.  Presumably the rest 	 of them follow immediately after....  */
for|for
control|(
name|rtld_reloc
operator|=
literal|0
init|;
name|rtld_reloc
operator|<
name|srelgot
operator|->
name|reloc_count
condition|;
name|rtld_reloc
operator|++
control|)
block|{
name|loc
operator|=
name|srelgot
operator|->
name|contents
operator|+
name|rtld_reloc
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_in
argument_list|(
name|output_bfd
argument_list|,
name|loc
argument_list|,
operator|&
name|irela
argument_list|)
expr_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irela
operator|.
name|r_info
argument_list|)
operator|==
name|R_XTENSA_RTLD
condition|)
break|break;
block|}
name|BFD_ASSERT
argument_list|(
name|rtld_reloc
operator|<
name|srelgot
operator|->
name|reloc_count
argument_list|)
expr_stmt|;
name|plt_entries
operator|=
operator|(
name|srelplt
operator|->
name|_raw_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
expr_stmt|;
name|plt_chunks
operator|=
operator|(
name|plt_entries
operator|+
name|PLT_ENTRIES_PER_CHUNK
operator|-
literal|1
operator|)
operator|/
name|PLT_ENTRIES_PER_CHUNK
expr_stmt|;
for|for
control|(
name|chunk
operator|=
literal|0
init|;
name|chunk
operator|<
name|plt_chunks
condition|;
name|chunk
operator|++
control|)
block|{
name|int
name|chunk_entries
init|=
literal|0
decl_stmt|;
name|sgotplt
operator|=
name|elf_xtensa_get_gotplt_section
argument_list|(
name|dynobj
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgotplt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Emit special RTLD relocations for the first two entries in 	     each chunk of the .got.plt section.  */
name|loc
operator|=
name|srelgot
operator|->
name|contents
operator|+
name|rtld_reloc
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_in
argument_list|(
name|output_bfd
argument_list|,
name|loc
argument_list|,
operator|&
name|irela
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|irela
operator|.
name|r_info
argument_list|)
operator|==
name|R_XTENSA_RTLD
argument_list|)
expr_stmt|;
name|irela
operator|.
name|r_offset
operator|=
operator|(
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgotplt
operator|->
name|output_offset
operator|)
expr_stmt|;
name|irela
operator|.
name|r_addend
operator|=
literal|1
expr_stmt|;
comment|/* tell rtld to set value to resolver function */
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|irela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|rtld_reloc
operator|+=
literal|1
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|rtld_reloc
operator|<=
name|srelgot
operator|->
name|reloc_count
argument_list|)
expr_stmt|;
comment|/* Next literal immediately follows the first.  */
name|loc
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_in
argument_list|(
name|output_bfd
argument_list|,
name|loc
argument_list|,
operator|&
name|irela
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|irela
operator|.
name|r_info
argument_list|)
operator|==
name|R_XTENSA_RTLD
argument_list|)
expr_stmt|;
name|irela
operator|.
name|r_offset
operator|=
operator|(
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgotplt
operator|->
name|output_offset
operator|+
literal|4
operator|)
expr_stmt|;
comment|/* Tell rtld to set value to object's link map.  */
name|irela
operator|.
name|r_addend
operator|=
literal|2
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|irela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|rtld_reloc
operator|+=
literal|1
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|rtld_reloc
operator|<=
name|srelgot
operator|->
name|reloc_count
argument_list|)
expr_stmt|;
comment|/* Fill in the literal table.  */
if|if
condition|(
name|chunk
operator|<
name|plt_chunks
operator|-
literal|1
condition|)
name|chunk_entries
operator|=
name|PLT_ENTRIES_PER_CHUNK
expr_stmt|;
else|else
name|chunk_entries
operator|=
name|plt_entries
operator|-
operator|(
name|chunk
operator|*
name|PLT_ENTRIES_PER_CHUNK
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|chunk
operator|+
literal|1
argument_list|)
operator|*
literal|8
operator|<=
name|spltlittbl
operator|->
name|_cooked_size
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgotplt
operator|->
name|output_offset
argument_list|,
name|spltlittbl
operator|->
name|contents
operator|+
operator|(
name|chunk
operator|*
literal|8
operator|)
operator|+
literal|0
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|8
operator|+
operator|(
name|chunk_entries
operator|*
literal|4
operator|)
argument_list|,
name|spltlittbl
operator|->
name|contents
operator|+
operator|(
name|chunk
operator|*
literal|8
operator|)
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* All the dynamic relocations have been emitted at this point. 	 Make sure the relocation sections are the correct size.  */
if|if
condition|(
name|srelgot
operator|->
name|_cooked_size
operator|!=
operator|(
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|*
name|srelgot
operator|->
name|reloc_count
operator|)
operator|||
name|srelplt
operator|->
name|_cooked_size
operator|!=
operator|(
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|*
name|srelplt
operator|->
name|reloc_count
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* The .xt.lit.plt section has just been modified.  This must 	happen before the code below which combines adjacent literal 	table entries, and the .xt.lit.plt contents have to be forced to 	the output here.  */
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|spltlittbl
operator|->
name|output_section
argument_list|,
name|spltlittbl
operator|->
name|contents
argument_list|,
name|spltlittbl
operator|->
name|output_offset
argument_list|,
name|spltlittbl
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Clear SEC_HAS_CONTENTS so the contents won't be output again.  */
name|spltlittbl
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
comment|/* Combine adjacent literal table entries.  */
name|BFD_ASSERT
argument_list|(
operator|!
name|info
operator|->
name|relocatable
argument_list|)
expr_stmt|;
name|sxtlit
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".xt.lit"
argument_list|)
expr_stmt|;
name|sgotloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.loc"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sxtlit
operator|&&
name|sgotloc
argument_list|)
expr_stmt|;
name|num_xtlit_entries
operator|=
name|elf_xtensa_combine_prop_entries
argument_list|(
name|output_bfd
argument_list|,
name|sxtlit
argument_list|,
name|sgotloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_xtlit_entries
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
name|dyncon
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|_raw_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_elf32_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
default|default:
break|break;
case|case
name|DT_XTENSA_GOT_LOC_SZ
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|num_xtlit_entries
expr_stmt|;
break|break;
case|case
name|DT_XTENSA_GOT_LOC_OFF
case|:
name|name
operator|=
literal|".got.loc"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_PLTGOT
case|:
name|name
operator|=
literal|".got"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_JMPREL
case|:
name|name
operator|=
literal|".rela.plt"
expr_stmt|;
name|get_vma
label|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
operator|(
name|s
operator|->
name|_cooked_size
condition|?
name|s
operator|->
name|_cooked_size
else|:
name|s
operator|->
name|_raw_size
operator|)
expr_stmt|;
break|break;
case|case
name|DT_RELASZ
case|:
comment|/* Adjust RELASZ to not include JMPREL.  This matches what 	     glibc expects and what is done for several other ELF 	     targets (e.g., i386, alpha), but the "correct" behavior 	     seems to be unresolved.  Since the linker script arranges 	     for .rela.plt to follow all other relocation sections, we 	     don't have to worry about changing the DT_RELA entry.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|-=
operator|(
name|s
operator|->
name|_cooked_size
condition|?
name|s
operator|->
name|_cooked_size
else|:
name|s
operator|->
name|_raw_size
operator|)
expr_stmt|;
block|}
break|break;
block|}
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for dealing with the e_flags field.  */
end_comment

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_merge_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
name|unsigned
name|out_mach
decl_stmt|,
name|in_mach
decl_stmt|;
name|flagword
name|out_flag
decl_stmt|,
name|in_flag
decl_stmt|;
comment|/* Check if we have the same endianess.  */
if|if
condition|(
operator|!
name|_bfd_generic_verify_endian_match
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Don't even pretend to support mixed-format linking.  */
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|FALSE
return|;
name|out_flag
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|in_flag
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|out_mach
operator|=
name|out_flag
operator|&
name|EF_XTENSA_MACH
expr_stmt|;
name|in_mach
operator|=
name|in_flag
operator|&
name|EF_XTENSA_MACH
expr_stmt|;
if|if
condition|(
name|out_mach
operator|!=
name|in_mach
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: incompatible machine type. Output is 0x%x. Input is 0x%x"
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|out_mach
argument_list|,
name|in_mach
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|in_flag
expr_stmt|;
if|if
condition|(
name|bfd_get_arch
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
operator|&&
name|bfd_get_arch_info
argument_list|(
name|obfd
argument_list|)
operator|->
name|the_default
condition|)
return|return
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
return|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
operator|(
name|out_flag
operator|&
name|EF_XTENSA_XT_INSN
operator|)
operator|!=
operator|(
name|in_flag
operator|&
name|EF_XTENSA_XT_INSN
operator|)
condition|)
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|(
operator|~
name|EF_XTENSA_XT_INSN
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|out_flag
operator|&
name|EF_XTENSA_XT_LIT
operator|)
operator|!=
operator|(
name|in_flag
operator|&
name|EF_XTENSA_XT_LIT
operator|)
condition|)
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|(
operator|~
name|EF_XTENSA_XT_LIT
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_set_private_flags
parameter_list|(
name|abfd
parameter_list|,
name|flags
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|||
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|==
name|flags
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator||=
name|flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|extern
name|flagword
name|elf_xtensa_get_private_bfd_flags
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_print_private_bfd_data
parameter_list|(
name|abfd
parameter_list|,
name|farg
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|farg
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
init|=
operator|(
name|FILE
operator|*
operator|)
name|farg
decl_stmt|;
name|flagword
name|e_flags
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nXtensa header:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e_flags
operator|&
name|EF_XTENSA_MACH
operator|)
operator|==
name|E_XTENSA_MACH
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nMachine     = Base\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nMachine Id  = 0x%x\n"
argument_list|,
name|e_flags
operator|&
name|EF_XTENSA_MACH
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Insn tables = %s\n"
argument_list|,
operator|(
name|e_flags
operator|&
name|EF_XTENSA_XT_INSN
operator|)
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Literal tables = %s\n"
argument_list|,
operator|(
name|e_flags
operator|&
name|EF_XTENSA_XT_LIT
operator|)
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
return|return
name|_bfd_elf_print_private_bfd_data
argument_list|(
name|abfd
argument_list|,
name|farg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set the right machine number for an Xtensa ELF file.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|mach
decl_stmt|;
name|unsigned
name|long
name|arch
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_XTENSA_MACH
decl_stmt|;
switch|switch
condition|(
name|arch
condition|)
block|{
case|case
name|E_XTENSA_MACH
case|:
name|mach
operator|=
name|bfd_mach_xtensa
expr_stmt|;
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
operator|(
name|void
operator|)
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_xtensa
argument_list|,
name|mach
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The final processing done just before writing out an Xtensa ELF object    file.  This gets the Xtensa architecture right based on the machine    number.  */
end_comment

begin_function
specifier|static
name|void
name|elf_xtensa_final_write_processing
parameter_list|(
name|abfd
parameter_list|,
name|linker
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_boolean
name|linker
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|mach
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
switch|switch
condition|(
name|mach
operator|=
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_mach_xtensa
case|:
name|val
operator|=
name|E_XTENSA_MACH
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|(
operator|~
name|EF_XTENSA_MACH
operator|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator||=
name|val
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|elf_reloc_type_class
name|elf_xtensa_reloc_type_class
parameter_list|(
name|rela
parameter_list|)
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rela
decl_stmt|;
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|ELF32_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_XTENSA_RELATIVE
case|:
return|return
name|reloc_class_relative
return|;
case|case
name|R_XTENSA_JMP_SLOT
case|:
return|return
name|reloc_class_plt
return|;
default|default:
return|return
name|reloc_class_normal
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_discard_info_for_section
parameter_list|(
name|abfd
parameter_list|,
name|cookie
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|elf_reloc_cookie
modifier|*
name|cookie
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|section_size
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|,
name|actual_offset
decl_stmt|;
name|size_t
name|removed_bytes
init|=
literal|0
decl_stmt|;
name|section_size
operator|=
operator|(
name|sec
operator|->
name|_cooked_size
condition|?
name|sec
operator|->
name|_cooked_size
else|:
name|sec
operator|->
name|_raw_size
operator|)
expr_stmt|;
if|if
condition|(
name|section_size
operator|==
literal|0
operator|||
name|section_size
operator|%
literal|8
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|sec
operator|->
name|output_section
operator|&&
name|bfd_is_abs_section
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|contents
operator|=
name|retrieve_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|contents
condition|)
return|return
name|FALSE
return|;
name|cookie
operator|->
name|rels
operator|=
name|retrieve_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cookie
operator|->
name|rels
condition|)
block|{
name|release_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|cookie
operator|->
name|rel
operator|=
name|cookie
operator|->
name|rels
expr_stmt|;
name|cookie
operator|->
name|relend
operator|=
name|cookie
operator|->
name|rels
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|section_size
condition|;
name|offset
operator|+=
literal|8
control|)
block|{
name|actual_offset
operator|=
name|offset
operator|-
name|removed_bytes
expr_stmt|;
comment|/* The ...symbol_deleted_p function will skip over relocs but it 	 won't adjust their offsets, so do that here.  */
while|while
condition|(
name|cookie
operator|->
name|rel
operator|<
name|cookie
operator|->
name|relend
operator|&&
name|cookie
operator|->
name|rel
operator|->
name|r_offset
operator|<
name|offset
condition|)
block|{
name|cookie
operator|->
name|rel
operator|->
name|r_offset
operator|-=
name|removed_bytes
expr_stmt|;
name|cookie
operator|->
name|rel
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|cookie
operator|->
name|rel
operator|<
name|cookie
operator|->
name|relend
operator|&&
name|cookie
operator|->
name|rel
operator|->
name|r_offset
operator|==
name|offset
condition|)
block|{
if|if
condition|(
name|bfd_elf_reloc_symbol_deleted_p
argument_list|(
name|offset
argument_list|,
name|cookie
argument_list|)
condition|)
block|{
comment|/* Remove the table entry.  (If the reloc type is NONE, then 		 the entry has already been merged with another and deleted 		 during relaxation.)  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|cookie
operator|->
name|rel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_XTENSA_NONE
condition|)
block|{
comment|/* Shift the contents up.  */
if|if
condition|(
name|offset
operator|+
literal|8
operator|<
name|section_size
condition|)
name|memmove
argument_list|(
operator|&
name|contents
index|[
name|actual_offset
index|]
argument_list|,
operator|&
name|contents
index|[
name|actual_offset
operator|+
literal|8
index|]
argument_list|,
name|section_size
operator|-
name|offset
operator|-
literal|8
argument_list|)
expr_stmt|;
name|removed_bytes
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* Remove this relocation.  */
name|cookie
operator|->
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_XTENSA_NONE
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust the relocation offset for previous removals.  This 	     should not be done before calling ...symbol_deleted_p 	     because it might mess up the offset comparisons there. 	     Make sure the offset doesn't underflow in the case where 	     the first entry is removed.  */
if|if
condition|(
name|cookie
operator|->
name|rel
operator|->
name|r_offset
operator|>=
name|removed_bytes
condition|)
name|cookie
operator|->
name|rel
operator|->
name|r_offset
operator|-=
name|removed_bytes
expr_stmt|;
else|else
name|cookie
operator|->
name|rel
operator|->
name|r_offset
operator|=
literal|0
expr_stmt|;
name|cookie
operator|->
name|rel
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|removed_bytes
operator|!=
literal|0
condition|)
block|{
comment|/* Adjust any remaining relocs (shouldn't be any).  */
for|for
control|(
init|;
name|cookie
operator|->
name|rel
operator|<
name|cookie
operator|->
name|relend
condition|;
name|cookie
operator|->
name|rel
operator|++
control|)
block|{
if|if
condition|(
name|cookie
operator|->
name|rel
operator|->
name|r_offset
operator|>=
name|removed_bytes
condition|)
name|cookie
operator|->
name|rel
operator|->
name|r_offset
operator|-=
name|removed_bytes
expr_stmt|;
else|else
name|cookie
operator|->
name|rel
operator|->
name|r_offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Clear the removed bytes.  */
name|memset
argument_list|(
operator|&
name|contents
index|[
name|section_size
operator|-
name|removed_bytes
index|]
argument_list|,
literal|0
argument_list|,
name|removed_bytes
argument_list|)
expr_stmt|;
name|pin_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|pin_internal_relocs
argument_list|(
name|sec
argument_list|,
name|cookie
operator|->
name|rels
argument_list|)
expr_stmt|;
name|sec
operator|->
name|_cooked_size
operator|=
name|section_size
operator|-
name|removed_bytes
expr_stmt|;
comment|/* Also shrink _raw_size.  See comments in relax_property_section.  */
name|sec
operator|->
name|_raw_size
operator|=
name|sec
operator|->
name|_cooked_size
expr_stmt|;
if|if
condition|(
name|xtensa_is_littable_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
name|bfd
modifier|*
name|dynobj
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
decl_stmt|;
if|if
condition|(
name|dynobj
condition|)
block|{
name|asection
modifier|*
name|sgotloc
init|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.loc"
argument_list|)
decl_stmt|;
if|if
condition|(
name|sgotloc
condition|)
block|{
name|bfd_size_type
name|sgotloc_size
init|=
operator|(
name|sgotloc
operator|->
name|_cooked_size
condition|?
name|sgotloc
operator|->
name|_cooked_size
else|:
name|sgotloc
operator|->
name|_raw_size
operator|)
decl_stmt|;
name|sgotloc
operator|->
name|_cooked_size
operator|=
name|sgotloc_size
operator|-
name|removed_bytes
expr_stmt|;
name|sgotloc
operator|->
name|_raw_size
operator|=
name|sgotloc_size
operator|-
name|removed_bytes
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|release_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|release_internal_relocs
argument_list|(
name|sec
argument_list|,
name|cookie
operator|->
name|rels
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|removed_bytes
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_discard_info
parameter_list|(
name|abfd
parameter_list|,
name|cookie
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|elf_reloc_cookie
modifier|*
name|cookie
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_boolean
name|changed
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
if|if
condition|(
name|xtensa_is_property_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
if|if
condition|(
name|elf_xtensa_discard_info_for_section
argument_list|(
name|abfd
argument_list|,
name|cookie
argument_list|,
name|info
argument_list|,
name|sec
argument_list|)
condition|)
name|changed
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
return|return
name|changed
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_ignore_discarded_relocs
parameter_list|(
name|sec
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
return|return
name|xtensa_is_property_section
argument_list|(
name|sec
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Support for core dump NOTE sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_grok_prstatus
parameter_list|(
name|abfd
parameter_list|,
name|note
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Note
modifier|*
name|note
decl_stmt|;
block|{
name|int
name|offset
decl_stmt|;
name|unsigned
name|int
name|raw_size
decl_stmt|;
comment|/* The size for Xtensa is variable, so don't try to recognize the format      based on the size.  Just assume this is GNU/Linux.  */
comment|/* pr_cursig */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* pr_pid */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_pid
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|24
argument_list|)
expr_stmt|;
comment|/* pr_reg */
name|offset
operator|=
literal|72
expr_stmt|;
name|raw_size
operator|=
name|note
operator|->
name|descsz
operator|-
name|offset
operator|-
literal|4
expr_stmt|;
comment|/* Make a ".reg/999" section.  */
return|return
name|_bfd_elfcore_make_pseudosection
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|,
name|raw_size
argument_list|,
name|note
operator|->
name|descpos
operator|+
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_grok_psinfo
parameter_list|(
name|abfd
parameter_list|,
name|note
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Note
modifier|*
name|note
decl_stmt|;
block|{
switch|switch
condition|(
name|note
operator|->
name|descsz
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
literal|128
case|:
comment|/* GNU/Linux elf_prpsinfo */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_program
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|32
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|48
argument_list|,
literal|80
argument_list|)
expr_stmt|;
block|}
comment|/* Note that for some reason, a spurious space is tacked      onto the end of the args in some (at least one anyway)      implementations, so strip it off if it exists.  */
block|{
name|char
modifier|*
name|command
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
decl_stmt|;
name|int
name|n
init|=
name|strlen
argument_list|(
name|command
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|n
operator|&&
name|command
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|command
index|[
name|n
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generic Xtensa configurability stuff.  */
end_comment

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|callx0_op
init|=
name|XTENSA_UNDEFINED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|callx4_op
init|=
name|XTENSA_UNDEFINED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|callx8_op
init|=
name|XTENSA_UNDEFINED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|callx12_op
init|=
name|XTENSA_UNDEFINED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|call0_op
init|=
name|XTENSA_UNDEFINED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|call4_op
init|=
name|XTENSA_UNDEFINED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|call8_op
init|=
name|XTENSA_UNDEFINED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_opcode
name|call12_op
init|=
name|XTENSA_UNDEFINED
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_call_opcodes
parameter_list|()
block|{
if|if
condition|(
name|callx0_op
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
name|callx0_op
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|xtensa_default_isa
argument_list|,
literal|"callx0"
argument_list|)
expr_stmt|;
name|callx4_op
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|xtensa_default_isa
argument_list|,
literal|"callx4"
argument_list|)
expr_stmt|;
name|callx8_op
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|xtensa_default_isa
argument_list|,
literal|"callx8"
argument_list|)
expr_stmt|;
name|callx12_op
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|xtensa_default_isa
argument_list|,
literal|"callx12"
argument_list|)
expr_stmt|;
name|call0_op
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|xtensa_default_isa
argument_list|,
literal|"call0"
argument_list|)
expr_stmt|;
name|call4_op
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|xtensa_default_isa
argument_list|,
literal|"call4"
argument_list|)
expr_stmt|;
name|call8_op
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|xtensa_default_isa
argument_list|,
literal|"call8"
argument_list|)
expr_stmt|;
name|call12_op
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|xtensa_default_isa
argument_list|,
literal|"call12"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|is_indirect_call_opcode
parameter_list|(
name|opcode
parameter_list|)
name|xtensa_opcode
name|opcode
decl_stmt|;
block|{
name|init_call_opcodes
argument_list|()
expr_stmt|;
return|return
operator|(
name|opcode
operator|==
name|callx0_op
operator|||
name|opcode
operator|==
name|callx4_op
operator|||
name|opcode
operator|==
name|callx8_op
operator|||
name|opcode
operator|==
name|callx12_op
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|is_direct_call_opcode
parameter_list|(
name|opcode
parameter_list|)
name|xtensa_opcode
name|opcode
decl_stmt|;
block|{
name|init_call_opcodes
argument_list|()
expr_stmt|;
return|return
operator|(
name|opcode
operator|==
name|call0_op
operator|||
name|opcode
operator|==
name|call4_op
operator|||
name|opcode
operator|==
name|call8_op
operator|||
name|opcode
operator|==
name|call12_op
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|is_windowed_call_opcode
parameter_list|(
name|opcode
parameter_list|)
name|xtensa_opcode
name|opcode
decl_stmt|;
block|{
name|init_call_opcodes
argument_list|()
expr_stmt|;
return|return
operator|(
name|opcode
operator|==
name|call4_op
operator|||
name|opcode
operator|==
name|call8_op
operator|||
name|opcode
operator|==
name|call12_op
operator|||
name|opcode
operator|==
name|callx4_op
operator|||
name|opcode
operator|==
name|callx8_op
operator|||
name|opcode
operator|==
name|callx12_op
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|xtensa_opcode
name|get_l32r_opcode
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|xtensa_opcode
name|l32r_opcode
init|=
name|XTENSA_UNDEFINED
decl_stmt|;
if|if
condition|(
name|l32r_opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
name|l32r_opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|xtensa_default_isa
argument_list|,
literal|"l32r"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|l32r_opcode
operator|!=
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
block|}
return|return
name|l32r_opcode
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|l32r_offset
parameter_list|(
name|addr
parameter_list|,
name|pc
parameter_list|)
name|bfd_vma
name|addr
decl_stmt|;
name|bfd_vma
name|pc
decl_stmt|;
block|{
name|bfd_vma
name|offset
decl_stmt|;
name|offset
operator|=
name|addr
operator|-
operator|(
operator|(
name|pc
operator|+
literal|3
operator|)
operator|&
operator|-
literal|4
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|offset
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|signed
name|int
operator|)
name|offset
operator|>>
literal|2
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|signed
name|int
operator|)
name|offset
operator|>>
literal|16
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Get the operand number for a PC-relative relocation.    If the relocation is not a PC-relative one, return (-1).  */
end_comment

begin_function
specifier|static
name|int
name|get_relocation_opnd
parameter_list|(
name|irel
parameter_list|)
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
block|{
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|R_XTENSA_OP0
operator|||
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|>=
name|R_XTENSA_max
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|-
name|R_XTENSA_OP0
return|;
block|}
end_function

begin_comment
comment|/* Get the opcode for a relocation.  */
end_comment

begin_function
specifier|static
name|xtensa_opcode
name|get_relocation_opcode
parameter_list|(
name|sec
parameter_list|,
name|contents
parameter_list|,
name|irel
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
block|{
specifier|static
name|xtensa_insnbuf
name|ibuff
init|=
name|NULL
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
if|if
condition|(
name|get_relocation_opnd
argument_list|(
name|irel
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
if|if
condition|(
name|sec
operator|->
name|_raw_size
operator|<=
name|irel
operator|->
name|r_offset
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
if|if
condition|(
name|ibuff
operator|==
name|NULL
condition|)
name|ibuff
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
comment|/* Decode the instruction.  */
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|ibuff
argument_list|,
operator|&
name|contents
index|[
name|irel
operator|->
name|r_offset
index|]
argument_list|)
expr_stmt|;
return|return
name|xtensa_decode_insn
argument_list|(
name|isa
argument_list|,
name|ibuff
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|is_l32r_relocation
parameter_list|(
name|sec
parameter_list|,
name|contents
parameter_list|,
name|irel
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
block|{
name|xtensa_opcode
name|opcode
decl_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_XTENSA_OP1
condition|)
return|return
name|FALSE
return|;
name|opcode
operator|=
name|get_relocation_opcode
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|,
name|irel
argument_list|)
expr_stmt|;
return|return
operator|(
name|opcode
operator|==
name|get_l32r_opcode
argument_list|()
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Code for transforming CALLs at link-time.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|elf_xtensa_do_asm_simplify
parameter_list|(
name|contents
parameter_list|,
name|address
parameter_list|,
name|content_length
parameter_list|)
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
name|bfd_vma
name|content_length
decl_stmt|;
block|{
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
name|xtensa_opcode
name|opcode
decl_stmt|;
name|xtensa_operand
name|operand
decl_stmt|;
name|xtensa_opcode
name|direct_call_opcode
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|bfd_byte
modifier|*
name|chbuf
init|=
name|contents
operator|+
name|address
decl_stmt|;
name|int
name|opn
decl_stmt|;
if|if
condition|(
name|insnbuf
operator|==
name|NULL
condition|)
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
if|if
condition|(
name|content_length
operator|<
name|address
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"Attempt to convert L32R/CALLX to CALL failed"
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_other
return|;
block|}
name|opcode
operator|=
name|get_expanded_call_opcode
argument_list|(
name|chbuf
argument_list|,
name|content_length
operator|-
name|address
argument_list|)
expr_stmt|;
name|direct_call_opcode
operator|=
name|swap_callx_for_call_opcode
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|direct_call_opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"Attempt to convert L32R/CALLX to CALL failed"
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_other
return|;
block|}
comment|/* Assemble a NOP ("or a1, a1, a1") into the 0 byte offset.  */
name|opcode
operator|=
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
literal|"or"
argument_list|)
expr_stmt|;
name|xtensa_encode_insn
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|opn
operator|=
literal|0
init|;
name|opn
operator|<
literal|3
condition|;
name|opn
operator|++
control|)
block|{
name|operand
operator|=
name|xtensa_get_operand
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|opn
argument_list|)
expr_stmt|;
name|xtensa_operand_set_field
argument_list|(
name|operand
argument_list|,
name|insnbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|xtensa_insnbuf_to_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
name|chbuf
argument_list|)
expr_stmt|;
comment|/* Assemble a CALL ("callN 0") into the 3 byte offset.  */
name|xtensa_encode_insn
argument_list|(
name|isa
argument_list|,
name|direct_call_opcode
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
name|operand
operator|=
name|xtensa_get_operand
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xtensa_operand_set_field
argument_list|(
name|operand
argument_list|,
name|insnbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xtensa_insnbuf_to_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
name|chbuf
operator|+
literal|3
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|contract_asm_expansion
parameter_list|(
name|contents
parameter_list|,
name|content_length
parameter_list|,
name|irel
parameter_list|)
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|content_length
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
block|{
name|bfd_reloc_status_type
name|retval
init|=
name|elf_xtensa_do_asm_simplify
argument_list|(
name|contents
argument_list|,
name|irel
operator|->
name|r_offset
argument_list|,
name|content_length
argument_list|)
decl_stmt|;
if|if
condition|(
name|retval
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|retval
return|;
comment|/* Update the irel->r_offset field so that the right immediate and      the right instruction are modified during the relocation.  */
name|irel
operator|->
name|r_offset
operator|+=
literal|3
expr_stmt|;
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_XTENSA_OP0
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function
specifier|static
name|xtensa_opcode
name|swap_callx_for_call_opcode
parameter_list|(
name|opcode
parameter_list|)
name|xtensa_opcode
name|opcode
decl_stmt|;
block|{
name|init_call_opcodes
argument_list|()
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|callx0_op
condition|)
return|return
name|call0_op
return|;
if|if
condition|(
name|opcode
operator|==
name|callx4_op
condition|)
return|return
name|call4_op
return|;
if|if
condition|(
name|opcode
operator|==
name|callx8_op
condition|)
return|return
name|call8_op
return|;
if|if
condition|(
name|opcode
operator|==
name|callx12_op
condition|)
return|return
name|call12_op
return|;
comment|/* Return XTENSA_UNDEFINED if the opcode is not an indirect call.  */
return|return
name|XTENSA_UNDEFINED
return|;
block|}
end_function

begin_comment
comment|/* Check if "buf" is pointing to a "L32R aN; CALLX aN" sequence, and    if so, return the CALLX opcode.  If not, return XTENSA_UNDEFINED.  */
end_comment

begin_define
define|#
directive|define
name|L32R_TARGET_REG_OPERAND
value|0
end_define

begin_define
define|#
directive|define
name|CALLN_SOURCE_OPERAND
value|0
end_define

begin_function
specifier|static
name|xtensa_opcode
name|get_expanded_call_opcode
parameter_list|(
name|buf
parameter_list|,
name|bufsize
parameter_list|)
name|bfd_byte
modifier|*
name|buf
decl_stmt|;
name|int
name|bufsize
decl_stmt|;
block|{
specifier|static
name|xtensa_insnbuf
name|insnbuf
init|=
name|NULL
decl_stmt|;
name|xtensa_opcode
name|opcode
decl_stmt|;
name|xtensa_operand
name|operand
decl_stmt|;
name|xtensa_isa
name|isa
init|=
name|xtensa_default_isa
decl_stmt|;
name|uint32
name|regno
decl_stmt|,
name|call_regno
decl_stmt|;
comment|/* Buffer must be at least 6 bytes.  */
if|if
condition|(
name|bufsize
operator|<
literal|6
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
if|if
condition|(
name|insnbuf
operator|==
name|NULL
condition|)
name|insnbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|xtensa_decode_insn
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|!=
name|get_l32r_opcode
argument_list|()
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
name|operand
operator|=
name|xtensa_get_operand
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|L32R_TARGET_REG_OPERAND
argument_list|)
expr_stmt|;
name|regno
operator|=
name|xtensa_operand_decode
argument_list|(
name|operand
argument_list|,
name|xtensa_operand_get_field
argument_list|(
name|operand
argument_list|,
name|insnbuf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Next instruction should be an CALLXn with operand 0 == regno.  */
name|xtensa_insnbuf_from_chars
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|,
name|buf
operator|+
name|xtensa_insn_length
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|xtensa_decode_insn
argument_list|(
name|isa
argument_list|,
name|insnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_indirect_call_opcode
argument_list|(
name|opcode
argument_list|)
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
name|operand
operator|=
name|xtensa_get_operand
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|CALLN_SOURCE_OPERAND
argument_list|)
expr_stmt|;
name|call_regno
operator|=
name|xtensa_operand_decode
argument_list|(
name|operand
argument_list|,
name|xtensa_operand_get_field
argument_list|(
name|operand
argument_list|,
name|insnbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|call_regno
operator|!=
name|regno
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
return|return
name|opcode
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Data structures used during relaxation.  */
end_comment

begin_comment
comment|/* r_reloc: relocation values.  */
end_comment

begin_comment
comment|/* Through the relaxation process, we need to keep track of the values    that will result from evaluating relocations.  The standard ELF    relocation structure is not sufficient for this purpose because we're    operating on multiple input files at once, so we need to know which    input file a relocation refers to.  The r_reloc structure thus    records both the input file (bfd) and ELF relocation.     For efficiency, an r_reloc also contains a "target_offset" field to    cache the target-section-relative offset value that is represented by    the relocation.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|r_reloc_struct
name|r_reloc
typedef|;
end_typedef

begin_struct
struct|struct
name|r_reloc_struct
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|bfd_vma
name|target_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|bfd_boolean
name|r_reloc_is_const
name|PARAMS
argument_list|(
operator|(
specifier|const
name|r_reloc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|r_reloc_init
name|PARAMS
argument_list|(
operator|(
name|r_reloc
operator|*
operator|,
name|bfd
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|r_reloc_get_target_offset
name|PARAMS
argument_list|(
operator|(
specifier|const
name|r_reloc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|r_reloc_get_section
name|PARAMS
argument_list|(
operator|(
specifier|const
name|r_reloc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|r_reloc_is_defined
name|PARAMS
argument_list|(
operator|(
specifier|const
name|r_reloc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|elf_link_hash_entry
modifier|*
name|r_reloc_get_hash_entry
name|PARAMS
argument_list|(
operator|(
specifier|const
name|r_reloc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The r_reloc structure is included by value in literal_value, but not    every literal_value has an associated relocation -- some are simple    constants.  In such cases, we set all the fields in the r_reloc    struct to zero.  The r_reloc_is_const function should be used to    detect this case.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|r_reloc_is_const
parameter_list|(
name|r_rel
parameter_list|)
specifier|const
name|r_reloc
modifier|*
name|r_rel
decl_stmt|;
block|{
return|return
operator|(
name|r_rel
operator|->
name|abfd
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|r_reloc_init
parameter_list|(
name|r_rel
parameter_list|,
name|abfd
parameter_list|,
name|irel
parameter_list|)
name|r_reloc
modifier|*
name|r_rel
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
block|{
if|if
condition|(
name|irel
operator|!=
name|NULL
condition|)
block|{
name|r_rel
operator|->
name|rela
operator|=
operator|*
name|irel
expr_stmt|;
name|r_rel
operator|->
name|abfd
operator|=
name|abfd
expr_stmt|;
name|r_rel
operator|->
name|target_offset
operator|=
name|r_reloc_get_target_offset
argument_list|(
name|r_rel
argument_list|)
expr_stmt|;
block|}
else|else
name|memset
argument_list|(
name|r_rel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|r_reloc
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|r_reloc_get_target_offset
parameter_list|(
name|r_rel
parameter_list|)
specifier|const
name|r_reloc
modifier|*
name|r_rel
decl_stmt|;
block|{
name|bfd_vma
name|target_offset
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|BFD_ASSERT
argument_list|(
operator|!
name|r_reloc_is_const
argument_list|(
name|r_rel
argument_list|)
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|r_rel
operator|->
name|rela
operator|.
name|r_info
argument_list|)
expr_stmt|;
name|target_offset
operator|=
name|get_elf_r_symndx_offset
argument_list|(
name|r_rel
operator|->
name|abfd
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
return|return
operator|(
name|target_offset
operator|+
name|r_rel
operator|->
name|rela
operator|.
name|r_addend
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|elf_link_hash_entry
modifier|*
name|r_reloc_get_hash_entry
parameter_list|(
name|r_rel
parameter_list|)
specifier|const
name|r_reloc
modifier|*
name|r_rel
decl_stmt|;
block|{
name|unsigned
name|long
name|r_symndx
init|=
name|ELF32_R_SYM
argument_list|(
name|r_rel
operator|->
name|rela
operator|.
name|r_info
argument_list|)
decl_stmt|;
return|return
name|get_elf_r_symndx_hash_entry
argument_list|(
name|r_rel
operator|->
name|abfd
argument_list|,
name|r_symndx
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|r_reloc_get_section
parameter_list|(
name|r_rel
parameter_list|)
specifier|const
name|r_reloc
modifier|*
name|r_rel
decl_stmt|;
block|{
name|unsigned
name|long
name|r_symndx
init|=
name|ELF32_R_SYM
argument_list|(
name|r_rel
operator|->
name|rela
operator|.
name|r_info
argument_list|)
decl_stmt|;
return|return
name|get_elf_r_symndx_section
argument_list|(
name|r_rel
operator|->
name|abfd
argument_list|,
name|r_symndx
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|r_reloc_is_defined
parameter_list|(
name|r_rel
parameter_list|)
specifier|const
name|r_reloc
modifier|*
name|r_rel
decl_stmt|;
block|{
name|asection
modifier|*
name|sec
init|=
name|r_reloc_get_section
argument_list|(
name|r_rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|sec
operator|==
name|bfd_abs_section_ptr
operator|||
name|sec
operator|==
name|bfd_com_section_ptr
operator|||
name|sec
operator|==
name|bfd_und_section_ptr
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* source_reloc: relocations that reference literal sections.  */
end_comment

begin_comment
comment|/* To determine whether literals can be coalesced, we need to first    record all the relocations that reference the literals.  The    source_reloc structure below is used for this purpose.  The    source_reloc entries are kept in a per-literal-section array, sorted    by offset within the literal section (i.e., target offset).     The source_sec and r_rel.rela.r_offset fields identify the source of    the relocation.  The r_rel field records the relocation value, i.e.,    the offset of the literal being referenced.  The opnd field is needed    to determine the range of the immediate field to which the relocation    applies, so we can determine whether another literal with the same    value is within range.  The is_null field is true when the relocation    is being removed (e.g., when an L32R is being removed due to a CALLX    that is converted to a direct CALL).  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|source_reloc_struct
name|source_reloc
typedef|;
end_typedef

begin_struct
struct|struct
name|source_reloc_struct
block|{
name|asection
modifier|*
name|source_sec
decl_stmt|;
name|r_reloc
name|r_rel
decl_stmt|;
name|xtensa_operand
name|opnd
decl_stmt|;
name|bfd_boolean
name|is_null
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|init_source_reloc
name|PARAMS
argument_list|(
operator|(
name|source_reloc
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|r_reloc
operator|*
operator|,
name|xtensa_operand
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|source_reloc
modifier|*
name|find_source_reloc
name|PARAMS
argument_list|(
operator|(
name|source_reloc
operator|*
operator|,
name|int
operator|,
name|asection
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|source_reloc_compare
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_source_reloc
parameter_list|(
name|reloc
parameter_list|,
name|source_sec
parameter_list|,
name|r_rel
parameter_list|,
name|opnd
parameter_list|)
name|source_reloc
modifier|*
name|reloc
decl_stmt|;
name|asection
modifier|*
name|source_sec
decl_stmt|;
specifier|const
name|r_reloc
modifier|*
name|r_rel
decl_stmt|;
name|xtensa_operand
name|opnd
decl_stmt|;
block|{
name|reloc
operator|->
name|source_sec
operator|=
name|source_sec
expr_stmt|;
name|reloc
operator|->
name|r_rel
operator|=
operator|*
name|r_rel
expr_stmt|;
name|reloc
operator|->
name|opnd
operator|=
name|opnd
expr_stmt|;
name|reloc
operator|->
name|is_null
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the source_reloc for a particular source offset and relocation    type.  Note that the array is sorted by _target_ offset, so this is    just a linear search.  */
end_comment

begin_function
specifier|static
name|source_reloc
modifier|*
name|find_source_reloc
parameter_list|(
name|src_relocs
parameter_list|,
name|src_count
parameter_list|,
name|sec
parameter_list|,
name|irel
parameter_list|)
name|source_reloc
modifier|*
name|src_relocs
decl_stmt|;
name|int
name|src_count
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|src_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|src_relocs
index|[
name|i
index|]
operator|.
name|source_sec
operator|==
name|sec
operator|&&
name|src_relocs
index|[
name|i
index|]
operator|.
name|r_rel
operator|.
name|rela
operator|.
name|r_offset
operator|==
name|irel
operator|->
name|r_offset
operator|&&
operator|(
name|ELF32_R_TYPE
argument_list|(
name|src_relocs
index|[
name|i
index|]
operator|.
name|r_rel
operator|.
name|rela
operator|.
name|r_info
argument_list|)
operator|==
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|)
condition|)
return|return
operator|&
name|src_relocs
index|[
name|i
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|source_reloc_compare
parameter_list|(
name|ap
parameter_list|,
name|bp
parameter_list|)
specifier|const
name|PTR
name|ap
decl_stmt|;
specifier|const
name|PTR
name|bp
decl_stmt|;
block|{
specifier|const
name|source_reloc
modifier|*
name|a
init|=
operator|(
specifier|const
name|source_reloc
operator|*
operator|)
name|ap
decl_stmt|;
specifier|const
name|source_reloc
modifier|*
name|b
init|=
operator|(
specifier|const
name|source_reloc
operator|*
operator|)
name|bp
decl_stmt|;
return|return
operator|(
name|a
operator|->
name|r_rel
operator|.
name|target_offset
operator|-
name|b
operator|->
name|r_rel
operator|.
name|target_offset
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Literal values and value hash tables.  */
end_comment

begin_comment
comment|/* Literals with the same value can be coalesced.  The literal_value    structure records the value of a literal: the "r_rel" field holds the    information from the relocation on the literal (if there is one) and    the "value" field holds the contents of the literal word itself.     The value_map structure records a literal value along with the    location of a literal holding that value.  The value_map hash table    is indexed by the literal value, so that we can quickly check if a    particular literal value has been seen before and is thus a candidate    for coalescing.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|literal_value_struct
name|literal_value
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|value_map_struct
name|value_map
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|value_map_hash_table_struct
name|value_map_hash_table
typedef|;
end_typedef

begin_struct
struct|struct
name|literal_value_struct
block|{
name|r_reloc
name|r_rel
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|value_map_struct
block|{
name|literal_value
name|val
decl_stmt|;
comment|/* The literal value.  */
name|r_reloc
name|loc
decl_stmt|;
comment|/* Location of the literal.  */
name|value_map
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|value_map_hash_table_struct
block|{
name|unsigned
name|bucket_count
decl_stmt|;
name|value_map
modifier|*
modifier|*
name|buckets
decl_stmt|;
name|unsigned
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_same_value
name|PARAMS
argument_list|(
operator|(
specifier|const
name|literal_value
operator|*
operator|,
specifier|const
name|literal_value
operator|*
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|value_map_hash_table
modifier|*
name|value_map_hash_table_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|hash_literal_value
name|PARAMS
argument_list|(
operator|(
specifier|const
name|literal_value
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|hash_bfd_vma
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|value_map
modifier|*
name|get_cached_value
name|PARAMS
argument_list|(
operator|(
name|value_map_hash_table
operator|*
operator|,
specifier|const
name|literal_value
operator|*
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|value_map
modifier|*
name|add_value_map
name|PARAMS
argument_list|(
operator|(
name|value_map_hash_table
operator|*
operator|,
specifier|const
name|literal_value
operator|*
operator|,
specifier|const
name|r_reloc
operator|*
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_boolean
name|is_same_value
parameter_list|(
name|src1
parameter_list|,
name|src2
parameter_list|,
name|final_static_link
parameter_list|)
specifier|const
name|literal_value
modifier|*
name|src1
decl_stmt|;
specifier|const
name|literal_value
modifier|*
name|src2
decl_stmt|;
name|bfd_boolean
name|final_static_link
decl_stmt|;
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h1
decl_stmt|,
modifier|*
name|h2
decl_stmt|;
if|if
condition|(
name|r_reloc_is_const
argument_list|(
operator|&
name|src1
operator|->
name|r_rel
argument_list|)
operator|!=
name|r_reloc_is_const
argument_list|(
operator|&
name|src2
operator|->
name|r_rel
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|r_reloc_is_const
argument_list|(
operator|&
name|src1
operator|->
name|r_rel
argument_list|)
condition|)
return|return
operator|(
name|src1
operator|->
name|value
operator|==
name|src2
operator|->
name|value
operator|)
return|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|src1
operator|->
name|r_rel
operator|.
name|rela
operator|.
name|r_info
argument_list|)
operator|!=
name|ELF32_R_TYPE
argument_list|(
name|src2
operator|->
name|r_rel
operator|.
name|rela
operator|.
name|r_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|r_reloc_get_target_offset
argument_list|(
operator|&
name|src1
operator|->
name|r_rel
argument_list|)
operator|!=
name|r_reloc_get_target_offset
argument_list|(
operator|&
name|src2
operator|->
name|r_rel
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|src1
operator|->
name|value
operator|!=
name|src2
operator|->
name|value
condition|)
return|return
name|FALSE
return|;
comment|/* Now check for the same section (if defined) or the same elf_hash      (if undefined or weak).  */
name|h1
operator|=
name|r_reloc_get_hash_entry
argument_list|(
operator|&
name|src1
operator|->
name|r_rel
argument_list|)
expr_stmt|;
name|h2
operator|=
name|r_reloc_get_hash_entry
argument_list|(
operator|&
name|src2
operator|->
name|r_rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_reloc_is_defined
argument_list|(
operator|&
name|src1
operator|->
name|r_rel
argument_list|)
operator|&&
operator|(
name|final_static_link
operator|||
operator|(
operator|(
operator|!
name|h1
operator|||
name|h1
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|(
operator|!
name|h2
operator|||
name|h2
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|r_reloc_get_section
argument_list|(
operator|&
name|src1
operator|->
name|r_rel
argument_list|)
operator|!=
name|r_reloc_get_section
argument_list|(
operator|&
name|src2
operator|->
name|r_rel
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
comment|/* Require that the hash entries (i.e., symbols) be identical.  */
if|if
condition|(
name|h1
operator|!=
name|h2
operator|||
name|h1
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Must be power of 2.  */
end_comment

begin_define
define|#
directive|define
name|INITIAL_HASH_RELOC_BUCKET_COUNT
value|1024
end_define

begin_function
specifier|static
name|value_map_hash_table
modifier|*
name|value_map_hash_table_init
parameter_list|()
block|{
name|value_map_hash_table
modifier|*
name|values
decl_stmt|;
name|values
operator|=
operator|(
name|value_map_hash_table
operator|*
operator|)
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|value_map_hash_table
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|->
name|bucket_count
operator|=
name|INITIAL_HASH_RELOC_BUCKET_COUNT
expr_stmt|;
name|values
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|values
operator|->
name|buckets
operator|=
operator|(
name|value_map
operator|*
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|value_map
operator|*
argument_list|)
operator|*
name|values
operator|->
name|bucket_count
argument_list|)
expr_stmt|;
return|return
name|values
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|hash_bfd_vma
parameter_list|(
name|val
parameter_list|)
name|bfd_vma
name|val
decl_stmt|;
block|{
return|return
operator|(
name|val
operator|>>
literal|2
operator|)
operator|+
operator|(
name|val
operator|>>
literal|10
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|hash_literal_value
parameter_list|(
name|src
parameter_list|)
specifier|const
name|literal_value
modifier|*
name|src
decl_stmt|;
block|{
name|unsigned
name|hash_val
decl_stmt|;
if|if
condition|(
name|r_reloc_is_const
argument_list|(
operator|&
name|src
operator|->
name|r_rel
argument_list|)
condition|)
return|return
name|hash_bfd_vma
argument_list|(
name|src
operator|->
name|value
argument_list|)
return|;
name|hash_val
operator|=
operator|(
name|hash_bfd_vma
argument_list|(
name|r_reloc_get_target_offset
argument_list|(
operator|&
name|src
operator|->
name|r_rel
argument_list|)
argument_list|)
operator|+
name|hash_bfd_vma
argument_list|(
name|src
operator|->
name|value
argument_list|)
operator|)
expr_stmt|;
comment|/* Now check for the same section and the same elf_hash.  */
if|if
condition|(
name|r_reloc_is_defined
argument_list|(
operator|&
name|src
operator|->
name|r_rel
argument_list|)
condition|)
name|hash_val
operator|+=
name|hash_bfd_vma
argument_list|(
operator|(
name|bfd_vma
operator|)
operator|(
name|unsigned
operator|)
name|r_reloc_get_section
argument_list|(
operator|&
name|src
operator|->
name|r_rel
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|hash_val
operator|+=
name|hash_bfd_vma
argument_list|(
operator|(
name|bfd_vma
operator|)
operator|(
name|unsigned
operator|)
name|r_reloc_get_hash_entry
argument_list|(
operator|&
name|src
operator|->
name|r_rel
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|hash_val
return|;
block|}
end_function

begin_comment
comment|/* Check if the specified literal_value has been seen before.  */
end_comment

begin_function
specifier|static
name|value_map
modifier|*
name|get_cached_value
parameter_list|(
name|map
parameter_list|,
name|val
parameter_list|,
name|final_static_link
parameter_list|)
name|value_map_hash_table
modifier|*
name|map
decl_stmt|;
specifier|const
name|literal_value
modifier|*
name|val
decl_stmt|;
name|bfd_boolean
name|final_static_link
decl_stmt|;
block|{
name|value_map
modifier|*
name|map_e
decl_stmt|;
name|value_map
modifier|*
name|bucket
decl_stmt|;
name|unsigned
name|idx
decl_stmt|;
name|idx
operator|=
name|hash_literal_value
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|idx
operator|=
name|idx
operator|&
operator|(
name|map
operator|->
name|bucket_count
operator|-
literal|1
operator|)
expr_stmt|;
name|bucket
operator|=
name|map
operator|->
name|buckets
index|[
name|idx
index|]
expr_stmt|;
for|for
control|(
name|map_e
operator|=
name|bucket
init|;
name|map_e
condition|;
name|map_e
operator|=
name|map_e
operator|->
name|next
control|)
block|{
if|if
condition|(
name|is_same_value
argument_list|(
operator|&
name|map_e
operator|->
name|val
argument_list|,
name|val
argument_list|,
name|final_static_link
argument_list|)
condition|)
return|return
name|map_e
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Record a new literal value.  It is illegal to call this if VALUE    already has an entry here.  */
end_comment

begin_function
specifier|static
name|value_map
modifier|*
name|add_value_map
parameter_list|(
name|map
parameter_list|,
name|val
parameter_list|,
name|loc
parameter_list|,
name|final_static_link
parameter_list|)
name|value_map_hash_table
modifier|*
name|map
decl_stmt|;
specifier|const
name|literal_value
modifier|*
name|val
decl_stmt|;
specifier|const
name|r_reloc
modifier|*
name|loc
decl_stmt|;
name|bfd_boolean
name|final_static_link
decl_stmt|;
block|{
name|value_map
modifier|*
modifier|*
name|bucket_p
decl_stmt|;
name|unsigned
name|idx
decl_stmt|;
name|value_map
modifier|*
name|val_e
init|=
operator|(
name|value_map
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|value_map
argument_list|)
argument_list|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|get_cached_value
argument_list|(
name|map
argument_list|,
name|val
argument_list|,
name|final_static_link
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|val_e
operator|->
name|val
operator|=
operator|*
name|val
expr_stmt|;
name|val_e
operator|->
name|loc
operator|=
operator|*
name|loc
expr_stmt|;
name|idx
operator|=
name|hash_literal_value
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|idx
operator|=
name|idx
operator|&
operator|(
name|map
operator|->
name|bucket_count
operator|-
literal|1
operator|)
expr_stmt|;
name|bucket_p
operator|=
operator|&
name|map
operator|->
name|buckets
index|[
name|idx
index|]
expr_stmt|;
name|val_e
operator|->
name|next
operator|=
operator|*
name|bucket_p
expr_stmt|;
operator|*
name|bucket_p
operator|=
name|val_e
expr_stmt|;
name|map
operator|->
name|count
operator|++
expr_stmt|;
comment|/* FIXME: consider resizing the hash table if we get too many entries */
return|return
name|val_e
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Lists of literals being coalesced or removed.  */
end_comment

begin_comment
comment|/* In the usual case, the literal identified by "from" is being    coalesced with another literal identified by "to".  If the literal is    unused and is being removed altogether, "to.abfd" will be NULL.    The removed_literal entries are kept on a per-section list, sorted    by the "from" offset field.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|removed_literal_struct
name|removed_literal
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|removed_literal_list_struct
name|removed_literal_list
typedef|;
end_typedef

begin_struct
struct|struct
name|removed_literal_struct
block|{
name|r_reloc
name|from
decl_stmt|;
name|r_reloc
name|to
decl_stmt|;
name|removed_literal
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|removed_literal_list_struct
block|{
name|removed_literal
modifier|*
name|head
decl_stmt|;
name|removed_literal
modifier|*
name|tail
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|add_removed_literal
name|PARAMS
argument_list|(
operator|(
name|removed_literal_list
operator|*
operator|,
specifier|const
name|r_reloc
operator|*
operator|,
specifier|const
name|r_reloc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|removed_literal
modifier|*
name|find_removed_literal
name|PARAMS
argument_list|(
operator|(
name|removed_literal_list
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|offset_with_removed_literals
name|PARAMS
argument_list|(
operator|(
name|removed_literal_list
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record that the literal at "from" is being removed.  If "to" is not    NULL, the "from" literal is being coalesced with the "to" literal.  */
end_comment

begin_function
specifier|static
name|void
name|add_removed_literal
parameter_list|(
name|removed_list
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|)
name|removed_literal_list
modifier|*
name|removed_list
decl_stmt|;
specifier|const
name|r_reloc
modifier|*
name|from
decl_stmt|;
specifier|const
name|r_reloc
modifier|*
name|to
decl_stmt|;
block|{
name|removed_literal
modifier|*
name|r
decl_stmt|,
modifier|*
name|new_r
decl_stmt|,
modifier|*
name|next_r
decl_stmt|;
name|new_r
operator|=
operator|(
name|removed_literal
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|removed_literal
argument_list|)
argument_list|)
expr_stmt|;
name|new_r
operator|->
name|from
operator|=
operator|*
name|from
expr_stmt|;
if|if
condition|(
name|to
condition|)
name|new_r
operator|->
name|to
operator|=
operator|*
name|to
expr_stmt|;
else|else
name|new_r
operator|->
name|to
operator|.
name|abfd
operator|=
name|NULL
expr_stmt|;
name|new_r
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|r
operator|=
name|removed_list
operator|->
name|head
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|removed_list
operator|->
name|head
operator|=
name|new_r
expr_stmt|;
name|removed_list
operator|->
name|tail
operator|=
name|new_r
expr_stmt|;
block|}
comment|/* Special check for common case of append.  */
elseif|else
if|if
condition|(
name|removed_list
operator|->
name|tail
operator|->
name|from
operator|.
name|target_offset
operator|<
name|from
operator|->
name|target_offset
condition|)
block|{
name|removed_list
operator|->
name|tail
operator|->
name|next
operator|=
name|new_r
expr_stmt|;
name|removed_list
operator|->
name|tail
operator|=
name|new_r
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|r
operator|->
name|from
operator|.
name|target_offset
operator|<
name|from
operator|->
name|target_offset
operator|&&
name|r
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|r
operator|=
name|r
operator|->
name|next
expr_stmt|;
block|}
name|next_r
operator|=
name|r
operator|->
name|next
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|new_r
expr_stmt|;
name|new_r
operator|->
name|next
operator|=
name|next_r
expr_stmt|;
if|if
condition|(
name|next_r
operator|==
name|NULL
condition|)
name|removed_list
operator|->
name|tail
operator|=
name|new_r
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check if the list of removed literals contains an entry for the    given address.  Return the entry if found.  */
end_comment

begin_function
specifier|static
name|removed_literal
modifier|*
name|find_removed_literal
parameter_list|(
name|removed_list
parameter_list|,
name|addr
parameter_list|)
name|removed_literal_list
modifier|*
name|removed_list
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
block|{
name|removed_literal
modifier|*
name|r
init|=
name|removed_list
operator|->
name|head
decl_stmt|;
while|while
condition|(
name|r
operator|&&
name|r
operator|->
name|from
operator|.
name|target_offset
operator|<
name|addr
condition|)
name|r
operator|=
name|r
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|r
operator|&&
name|r
operator|->
name|from
operator|.
name|target_offset
operator|==
name|addr
condition|)
return|return
name|r
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Adjust an offset in a section to compensate for literals that are    being removed.  Search the list of removed literals and subtract    4 bytes for every removed literal prior to the given address.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|offset_with_removed_literals
parameter_list|(
name|removed_list
parameter_list|,
name|addr
parameter_list|)
name|removed_literal_list
modifier|*
name|removed_list
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
block|{
name|removed_literal
modifier|*
name|r
init|=
name|removed_list
operator|->
name|head
decl_stmt|;
name|unsigned
name|num_bytes
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
name|addr
return|;
while|while
condition|(
name|r
operator|&&
name|r
operator|->
name|from
operator|.
name|target_offset
operator|<=
name|addr
condition|)
block|{
name|num_bytes
operator|+=
literal|4
expr_stmt|;
name|r
operator|=
name|r
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|num_bytes
operator|>
name|addr
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|addr
operator|-
name|num_bytes
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Coalescing literals may require a relocation to refer to a section in    a different input file, but the standard relocation information    cannot express that.  Instead, the reloc_bfd_fix structures are used    to "fix" the relocations that refer to sections in other input files.    These structures are kept on per-section lists.  The "src_type" field    records the relocation type in case there are multiple relocations on    the same location.  FIXME: This is ugly; an alternative might be to    add new symbols with the "owner" field to some other input file.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|reloc_bfd_fix_struct
name|reloc_bfd_fix
typedef|;
end_typedef

begin_struct
struct|struct
name|reloc_bfd_fix_struct
block|{
name|asection
modifier|*
name|src_sec
decl_stmt|;
name|bfd_vma
name|src_offset
decl_stmt|;
name|unsigned
name|src_type
decl_stmt|;
comment|/* Relocation type.  */
name|bfd
modifier|*
name|target_abfd
decl_stmt|;
name|asection
modifier|*
name|target_sec
decl_stmt|;
name|bfd_vma
name|target_offset
decl_stmt|;
name|reloc_bfd_fix
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|reloc_bfd_fix
modifier|*
name|reloc_bfd_fix_init
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|unsigned
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_bfd_fix
modifier|*
name|get_bfd_fix
name|PARAMS
argument_list|(
operator|(
name|reloc_bfd_fix
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|reloc_bfd_fix
modifier|*
name|reloc_bfd_fix_init
parameter_list|(
name|src_sec
parameter_list|,
name|src_offset
parameter_list|,
name|src_type
parameter_list|,
name|target_abfd
parameter_list|,
name|target_sec
parameter_list|,
name|target_offset
parameter_list|)
name|asection
modifier|*
name|src_sec
decl_stmt|;
name|bfd_vma
name|src_offset
decl_stmt|;
name|unsigned
name|src_type
decl_stmt|;
name|bfd
modifier|*
name|target_abfd
decl_stmt|;
name|asection
modifier|*
name|target_sec
decl_stmt|;
name|bfd_vma
name|target_offset
decl_stmt|;
block|{
name|reloc_bfd_fix
modifier|*
name|fix
decl_stmt|;
name|fix
operator|=
operator|(
name|reloc_bfd_fix
operator|*
operator|)
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|reloc_bfd_fix
argument_list|)
argument_list|)
expr_stmt|;
name|fix
operator|->
name|src_sec
operator|=
name|src_sec
expr_stmt|;
name|fix
operator|->
name|src_offset
operator|=
name|src_offset
expr_stmt|;
name|fix
operator|->
name|src_type
operator|=
name|src_type
expr_stmt|;
name|fix
operator|->
name|target_abfd
operator|=
name|target_abfd
expr_stmt|;
name|fix
operator|->
name|target_sec
operator|=
name|target_sec
expr_stmt|;
name|fix
operator|->
name|target_offset
operator|=
name|target_offset
expr_stmt|;
return|return
name|fix
return|;
block|}
end_function

begin_function
specifier|static
name|reloc_bfd_fix
modifier|*
name|get_bfd_fix
parameter_list|(
name|fix_list
parameter_list|,
name|sec
parameter_list|,
name|offset
parameter_list|,
name|type
parameter_list|)
name|reloc_bfd_fix
modifier|*
name|fix_list
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|unsigned
name|type
decl_stmt|;
block|{
name|reloc_bfd_fix
modifier|*
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
name|fix_list
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
if|if
condition|(
name|r
operator|->
name|src_sec
operator|==
name|sec
operator|&&
name|r
operator|->
name|src_offset
operator|==
name|offset
operator|&&
name|r
operator|->
name|src_type
operator|==
name|type
condition|)
return|return
name|r
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Per-section data for relaxation.  */
end_comment

begin_struct
struct|struct
name|xtensa_relax_info_struct
block|{
name|bfd_boolean
name|is_relaxable_literal_section
decl_stmt|;
name|int
name|visited
decl_stmt|;
comment|/* Number of times visited.  */
name|source_reloc
modifier|*
name|src_relocs
decl_stmt|;
comment|/* Array[src_count].  */
name|int
name|src_count
decl_stmt|;
name|int
name|src_next
decl_stmt|;
comment|/* Next src_relocs entry to assign.  */
name|removed_literal_list
name|removed_list
decl_stmt|;
name|reloc_bfd_fix
modifier|*
name|fix_list
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|elf_xtensa_section_data
block|{
name|struct
name|bfd_elf_section_data
name|elf
decl_stmt|;
name|xtensa_relax_info
name|relax_info
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|init_xtensa_relax_info
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|xtensa_relax_info
modifier|*
name|get_xtensa_relax_info
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_fix
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
name|reloc_bfd_fix
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_new_section_hook
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
name|struct
name|elf_xtensa_section_data
modifier|*
name|sdata
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
operator|*
name|sdata
argument_list|)
decl_stmt|;
name|sdata
operator|=
operator|(
expr|struct
name|elf_xtensa_section_data
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdata
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sec
operator|->
name|used_by_bfd
operator|=
operator|(
name|PTR
operator|)
name|sdata
expr_stmt|;
return|return
name|_bfd_elf_new_section_hook
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_xtensa_relax_info
parameter_list|(
name|sec
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
name|xtensa_relax_info
modifier|*
name|relax_info
init|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|relax_info
operator|->
name|is_relaxable_literal_section
operator|=
name|FALSE
expr_stmt|;
name|relax_info
operator|->
name|visited
operator|=
literal|0
expr_stmt|;
name|relax_info
operator|->
name|src_relocs
operator|=
name|NULL
expr_stmt|;
name|relax_info
operator|->
name|src_count
operator|=
literal|0
expr_stmt|;
name|relax_info
operator|->
name|src_next
operator|=
literal|0
expr_stmt|;
name|relax_info
operator|->
name|removed_list
operator|.
name|head
operator|=
name|NULL
expr_stmt|;
name|relax_info
operator|->
name|removed_list
operator|.
name|tail
operator|=
name|NULL
expr_stmt|;
name|relax_info
operator|->
name|fix_list
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|xtensa_relax_info
modifier|*
name|get_xtensa_relax_info
parameter_list|(
name|sec
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
name|struct
name|elf_xtensa_section_data
modifier|*
name|section_data
decl_stmt|;
comment|/* No info available if no section or if it is an output section.  */
if|if
condition|(
operator|!
name|sec
operator|||
name|sec
operator|==
name|sec
operator|->
name|output_section
condition|)
return|return
name|NULL
return|;
name|section_data
operator|=
operator|(
expr|struct
name|elf_xtensa_section_data
operator|*
operator|)
name|elf_section_data
argument_list|(
name|sec
argument_list|)
expr_stmt|;
return|return
operator|&
name|section_data
operator|->
name|relax_info
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_fix
parameter_list|(
name|src_sec
parameter_list|,
name|fix
parameter_list|)
name|asection
modifier|*
name|src_sec
decl_stmt|;
name|reloc_bfd_fix
modifier|*
name|fix
decl_stmt|;
block|{
name|xtensa_relax_info
modifier|*
name|relax_info
decl_stmt|;
name|relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|src_sec
argument_list|)
expr_stmt|;
name|fix
operator|->
name|next
operator|=
name|relax_info
operator|->
name|fix_list
expr_stmt|;
name|relax_info
operator|->
name|fix_list
operator|=
name|fix
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Access to internal relocations, section contents and symbols.  */
end_comment

begin_comment
comment|/* During relaxation, we need to modify relocations, section contents,    and symbol definitions, and we need to keep the original values from    being reloaded from the input files, i.e., we need to "pin" the    modified values in memory.  We also want to continue to observe the    setting of the "keep-memory" flag.  The following functions wrap the    standard BFD functions to take care of this for us.  */
end_comment

begin_function
specifier|static
name|Elf_Internal_Rela
modifier|*
name|retrieve_internal_relocs
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|keep_memory
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_boolean
name|keep_memory
decl_stmt|;
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
name|internal_relocs
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
name|internal_relocs
operator|=
operator|(
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
return|return
name|internal_relocs
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pin_internal_relocs
parameter_list|(
name|sec
parameter_list|,
name|internal_relocs
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
block|{
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|release_internal_relocs
parameter_list|(
name|sec
parameter_list|,
name|internal_relocs
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
block|{
if|if
condition|(
name|internal_relocs
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bfd_byte
modifier|*
name|retrieve_contents
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|keep_memory
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_boolean
name|keep_memory
decl_stmt|;
block|{
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
operator|&&
name|sec
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|keep_memory
condition|)
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
block|}
block|}
return|return
name|contents
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pin_contents
parameter_list|(
name|sec
parameter_list|,
name|contents
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
block|{
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|release_contents
parameter_list|(
name|sec
parameter_list|,
name|contents
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
block|{
if|if
condition|(
name|contents
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|Elf_Internal_Sym
modifier|*
name|retrieve_local_syms
parameter_list|(
name|input_bfd
parameter_list|)
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
decl_stmt|;
name|size_t
name|locsymcount
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
operator|&&
name|locsymcount
operator|!=
literal|0
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|locsymcount
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Save the symbols for this input file so they won't be read again.  */
if|if
condition|(
name|isymbuf
operator|&&
name|isymbuf
operator|!=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
condition|)
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
return|return
name|isymbuf
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Code for link-time relaxation.  */
end_comment

begin_comment
comment|/* Local helper functions.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|analyze_relocations
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|find_relaxable_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd_boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|collect_source_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|is_resolvable_asm_expansion
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd_boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|remove_literals
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|value_map_hash_table
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|relax_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|relax_property_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|relax_section_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|relocations_reach
name|PARAMS
argument_list|(
operator|(
name|source_reloc
operator|*
operator|,
name|int
operator|,
specifier|const
name|r_reloc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|translate_reloc
name|PARAMS
argument_list|(
operator|(
specifier|const
name|r_reloc
operator|*
operator|,
name|r_reloc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf_Internal_Rela
modifier|*
name|get_irel_at_offset
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf_Internal_Rela
modifier|*
name|find_associated_l32r_irel
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|shrink_dynamic_reloc_sections
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_boolean
name|elf_xtensa_relax_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|link_info
parameter_list|,
name|again
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|bfd_boolean
modifier|*
name|again
decl_stmt|;
block|{
specifier|static
name|value_map_hash_table
modifier|*
name|values
init|=
name|NULL
decl_stmt|;
name|xtensa_relax_info
modifier|*
name|relax_info
decl_stmt|;
if|if
condition|(
operator|!
name|values
condition|)
block|{
comment|/* Do some overall initialization for relaxation.  */
name|values
operator|=
name|value_map_hash_table_init
argument_list|()
expr_stmt|;
name|relaxing_section
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|analyze_relocations
argument_list|(
name|link_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
operator|*
name|again
operator|=
name|FALSE
expr_stmt|;
comment|/* Don't mess with linker-created sections.  */
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|!=
literal|0
condition|)
return|return
name|TRUE
return|;
name|relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|relax_info
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|relax_info
operator|->
name|visited
condition|)
block|{
case|case
literal|0
case|:
comment|/* Note: It would be nice to fold this pass into 	 analyze_relocations, but it is important for this step that the 	 sections be examined in link order.  */
if|if
condition|(
operator|!
name|remove_literals
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
argument_list|,
name|values
argument_list|)
condition|)
return|return
name|FALSE
return|;
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
operator|!
name|relax_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
operator|!
name|relax_section_symbols
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
name|relax_info
operator|->
name|visited
operator|++
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Initialization for relaxation.  */
end_comment

begin_comment
comment|/* This function is called once at the start of relaxation.  It scans    all the input sections and marks the ones that are relaxable (i.e.,    literal sections with L32R relocations against them).  It then    collect source_reloc information for all the relocations against    those relaxable sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|analyze_relocations
parameter_list|(
name|link_info
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_boolean
name|is_relaxable
init|=
name|FALSE
decl_stmt|;
comment|/* Initialize the per-section relaxation info.  */
for|for
control|(
name|abfd
operator|=
name|link_info
operator|->
name|input_bfds
init|;
name|abfd
operator|!=
name|NULL
condition|;
name|abfd
operator|=
name|abfd
operator|->
name|link_next
control|)
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|init_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
block|}
comment|/* Mark relaxable sections (and count relocations against each one).  */
for|for
control|(
name|abfd
operator|=
name|link_info
operator|->
name|input_bfds
init|;
name|abfd
operator|!=
name|NULL
condition|;
name|abfd
operator|=
name|abfd
operator|->
name|link_next
control|)
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|find_relaxable_sections
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
argument_list|,
operator|&
name|is_relaxable
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Bail out if there are no relaxable sections.  */
if|if
condition|(
operator|!
name|is_relaxable
condition|)
return|return
name|TRUE
return|;
comment|/* Allocate space for source_relocs.  */
for|for
control|(
name|abfd
operator|=
name|link_info
operator|->
name|input_bfds
init|;
name|abfd
operator|!=
name|NULL
condition|;
name|abfd
operator|=
name|abfd
operator|->
name|link_next
control|)
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|xtensa_relax_info
modifier|*
name|relax_info
decl_stmt|;
name|relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|relax_info
operator|->
name|is_relaxable_literal_section
condition|)
block|{
name|relax_info
operator|->
name|src_relocs
operator|=
operator|(
name|source_reloc
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|relax_info
operator|->
name|src_count
operator|*
sizeof|sizeof
argument_list|(
name|source_reloc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Collect info on relocations against each relaxable section.  */
for|for
control|(
name|abfd
operator|=
name|link_info
operator|->
name|input_bfds
init|;
name|abfd
operator|!=
name|NULL
condition|;
name|abfd
operator|=
name|abfd
operator|->
name|link_next
control|)
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|collect_source_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Find all the literal sections that might be relaxed.  The motivation    for this pass is that collect_source_relocs() needs to record _all_    the relocations that target each relaxable section.  That is    expensive and unnecessary unless the target section is actually going    to be relaxed.  This pass identifies all such sections by checking if    they have L32Rs pointing to them.  In the process, the total number    of relocations targeting each section is also counted so that we    know how much space to allocate for source_relocs against each    relaxable literal section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|find_relaxable_sections
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|link_info
parameter_list|,
name|is_relaxable_p
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|bfd_boolean
modifier|*
name|is_relaxable_p
decl_stmt|;
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_boolean
name|ok
init|=
name|TRUE
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|internal_relocs
operator|=
name|retrieve_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
return|return
name|ok
return|;
name|contents
operator|=
name|retrieve_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
operator|&&
name|sec
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
name|ok
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|irel
init|=
operator|&
name|internal_relocs
index|[
name|i
index|]
decl_stmt|;
name|r_reloc
name|r_rel
decl_stmt|;
name|asection
modifier|*
name|target_sec
decl_stmt|;
name|xtensa_relax_info
modifier|*
name|target_relax_info
decl_stmt|;
name|r_reloc_init
argument_list|(
operator|&
name|r_rel
argument_list|,
name|abfd
argument_list|,
name|irel
argument_list|)
expr_stmt|;
name|target_sec
operator|=
name|r_reloc_get_section
argument_list|(
operator|&
name|r_rel
argument_list|)
expr_stmt|;
name|target_relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|target_sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_relax_info
condition|)
continue|continue;
comment|/* Count relocations against the target section.  */
name|target_relax_info
operator|->
name|src_count
operator|++
expr_stmt|;
if|if
condition|(
name|is_literal_section
argument_list|(
name|target_sec
argument_list|)
operator|&&
name|is_l32r_relocation
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|,
name|irel
argument_list|)
operator|&&
name|r_reloc_is_defined
argument_list|(
operator|&
name|r_rel
argument_list|)
condition|)
block|{
comment|/* Mark the target section as relaxable.  */
name|target_relax_info
operator|->
name|is_relaxable_literal_section
operator|=
name|TRUE
expr_stmt|;
operator|*
name|is_relaxable_p
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|error_return
label|:
name|release_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|release_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/* Record _all_ the relocations that point to relaxable literal    sections, and get rid of ASM_EXPAND relocs by either converting them    to ASM_SIMPLIFY or by removing them.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|collect_source_relocs
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|link_info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_boolean
name|ok
init|=
name|TRUE
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|internal_relocs
operator|=
name|retrieve_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
return|return
name|ok
return|;
name|contents
operator|=
name|retrieve_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
operator|&&
name|sec
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
name|ok
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* Record relocations against relaxable literal sections.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|irel
init|=
operator|&
name|internal_relocs
index|[
name|i
index|]
decl_stmt|;
name|r_reloc
name|r_rel
decl_stmt|;
name|asection
modifier|*
name|target_sec
decl_stmt|;
name|xtensa_relax_info
modifier|*
name|target_relax_info
decl_stmt|;
name|r_reloc_init
argument_list|(
operator|&
name|r_rel
argument_list|,
name|abfd
argument_list|,
name|irel
argument_list|)
expr_stmt|;
name|target_sec
operator|=
name|r_reloc_get_section
argument_list|(
operator|&
name|r_rel
argument_list|)
expr_stmt|;
name|target_relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|target_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_relax_info
operator|&&
name|target_relax_info
operator|->
name|is_relaxable_literal_section
condition|)
block|{
name|xtensa_opcode
name|opcode
decl_stmt|;
name|xtensa_operand
name|opnd
decl_stmt|;
name|source_reloc
modifier|*
name|s_reloc
decl_stmt|;
name|int
name|src_next
decl_stmt|;
name|src_next
operator|=
name|target_relax_info
operator|->
name|src_next
operator|++
expr_stmt|;
name|s_reloc
operator|=
operator|&
name|target_relax_info
operator|->
name|src_relocs
index|[
name|src_next
index|]
expr_stmt|;
name|opcode
operator|=
name|get_relocation_opcode
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|,
name|irel
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
name|opnd
operator|=
name|NULL
expr_stmt|;
else|else
name|opnd
operator|=
name|xtensa_get_operand
argument_list|(
name|xtensa_default_isa
argument_list|,
name|opcode
argument_list|,
name|get_relocation_opnd
argument_list|(
name|irel
argument_list|)
argument_list|)
expr_stmt|;
name|init_source_reloc
argument_list|(
name|s_reloc
argument_list|,
name|sec
argument_list|,
operator|&
name|r_rel
argument_list|,
name|opnd
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now get rid of ASM_EXPAND relocations.  At this point, the      src_relocs array for the target literal section may still be      incomplete, but it must at least contain the entries for the L32R      relocations associated with ASM_EXPANDs because they were just      added in the preceding loop over the relocations.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|irel
init|=
operator|&
name|internal_relocs
index|[
name|i
index|]
decl_stmt|;
name|bfd_boolean
name|is_reachable
decl_stmt|;
if|if
condition|(
operator|!
name|is_resolvable_asm_expansion
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
name|irel
argument_list|,
name|link_info
argument_list|,
operator|&
name|is_reachable
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|is_reachable
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|l32r_irel
decl_stmt|;
name|r_reloc
name|r_rel
decl_stmt|;
name|asection
modifier|*
name|target_sec
decl_stmt|;
name|xtensa_relax_info
modifier|*
name|target_relax_info
decl_stmt|;
comment|/* Mark the source_reloc for the L32R so that it will be 	     removed in remove_literals(), along with the associated 	     literal.  */
name|l32r_irel
operator|=
name|find_associated_l32r_irel
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|,
name|irel
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|l32r_irel
operator|==
name|NULL
condition|)
continue|continue;
name|r_reloc_init
argument_list|(
operator|&
name|r_rel
argument_list|,
name|abfd
argument_list|,
name|l32r_irel
argument_list|)
expr_stmt|;
name|target_sec
operator|=
name|r_reloc_get_section
argument_list|(
operator|&
name|r_rel
argument_list|)
expr_stmt|;
name|target_relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|target_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_relax_info
operator|&&
name|target_relax_info
operator|->
name|is_relaxable_literal_section
condition|)
block|{
name|source_reloc
modifier|*
name|s_reloc
decl_stmt|;
comment|/* Search the source_relocs for the entry corresponding to 		 the l32r_irel.  Note: The src_relocs array is not yet 		 sorted, but it wouldn't matter anyway because we're 		 searching by source offset instead of target offset.  */
name|s_reloc
operator|=
name|find_source_reloc
argument_list|(
name|target_relax_info
operator|->
name|src_relocs
argument_list|,
name|target_relax_info
operator|->
name|src_next
argument_list|,
name|sec
argument_list|,
name|l32r_irel
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s_reloc
argument_list|)
expr_stmt|;
name|s_reloc
operator|->
name|is_null
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Convert this reloc to ASM_SIMPLIFY.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_XTENSA_ASM_SIMPLIFY
argument_list|)
expr_stmt|;
name|l32r_irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_XTENSA_NONE
argument_list|)
expr_stmt|;
name|pin_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It is resolvable but doesn't reach.  We resolve now 	     by eliminating the relocation -- the call will remain 	     expanded into L32R/CALLX.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_XTENSA_NONE
argument_list|)
expr_stmt|;
name|pin_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
block|}
name|error_return
label|:
name|release_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|release_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the asm expansion can be resolved.  Generally it can    be resolved on a final link or when a partial link locates it in the    same section as the target.  Set "is_reachable" flag if the target of    the call is within the range of a direct call, given the current VMA    for this section and the target section.  */
end_comment

begin_function
name|bfd_boolean
name|is_resolvable_asm_expansion
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|contents
parameter_list|,
name|irel
parameter_list|,
name|link_info
parameter_list|,
name|is_reachable_p
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|bfd_boolean
modifier|*
name|is_reachable_p
decl_stmt|;
block|{
name|asection
modifier|*
name|target_sec
decl_stmt|;
name|bfd_vma
name|target_offset
decl_stmt|;
name|r_reloc
name|r_rel
decl_stmt|;
name|xtensa_opcode
name|opcode
decl_stmt|,
name|direct_call_opcode
decl_stmt|;
name|bfd_vma
name|self_address
decl_stmt|;
name|bfd_vma
name|dest_address
decl_stmt|;
operator|*
name|is_reachable_p
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_XTENSA_ASM_EXPAND
condition|)
return|return
name|FALSE
return|;
name|opcode
operator|=
name|get_expanded_call_opcode
argument_list|(
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|,
name|sec
operator|->
name|_raw_size
operator|-
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|direct_call_opcode
operator|=
name|swap_callx_for_call_opcode
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|direct_call_opcode
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|FALSE
return|;
comment|/* Check and see that the target resolves.  */
name|r_reloc_init
argument_list|(
operator|&
name|r_rel
argument_list|,
name|abfd
argument_list|,
name|irel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r_reloc_is_defined
argument_list|(
operator|&
name|r_rel
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|target_sec
operator|=
name|r_reloc_get_section
argument_list|(
operator|&
name|r_rel
argument_list|)
expr_stmt|;
name|target_offset
operator|=
name|r_reloc_get_target_offset
argument_list|(
operator|&
name|r_rel
argument_list|)
expr_stmt|;
comment|/* If the target is in a shared library, then it doesn't reach.  This      isn't supposed to come up because the compiler should never generate      non-PIC calls on systems that use shared libraries, but the linker      shouldn't crash regardless.  */
if|if
condition|(
operator|!
name|target_sec
operator|->
name|output_section
condition|)
return|return
name|FALSE
return|;
comment|/* For relocatable sections, we can only simplify when the output      section of the target is the same as the output section of the      source.  */
if|if
condition|(
name|link_info
operator|->
name|relocatable
operator|&&
operator|(
name|target_sec
operator|->
name|output_section
operator|!=
name|sec
operator|->
name|output_section
operator|)
condition|)
return|return
name|FALSE
return|;
name|self_address
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|3
operator|)
expr_stmt|;
name|dest_address
operator|=
operator|(
name|target_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|target_sec
operator|->
name|output_offset
operator|+
name|target_offset
operator|)
expr_stmt|;
operator|*
name|is_reachable_p
operator|=
name|pcrel_reloc_fits
argument_list|(
name|xtensa_get_operand
argument_list|(
name|xtensa_default_isa
argument_list|,
name|direct_call_opcode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|self_address
argument_list|,
name|dest_address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|self_address
operator|>>
name|CALL_SEGMENT_BITS
operator|)
operator|!=
operator|(
name|dest_address
operator|>>
name|CALL_SEGMENT_BITS
operator|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|Elf_Internal_Rela
modifier|*
name|find_associated_l32r_irel
parameter_list|(
name|sec
parameter_list|,
name|contents
parameter_list|,
name|other_irel
parameter_list|,
name|internal_relocs
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|other_irel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|irel
init|=
operator|&
name|internal_relocs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|irel
operator|==
name|other_irel
condition|)
continue|continue;
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|!=
name|other_irel
operator|->
name|r_offset
condition|)
continue|continue;
if|if
condition|(
name|is_l32r_relocation
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|,
name|irel
argument_list|)
condition|)
return|return
name|irel
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* First relaxation pass.  */
end_comment

begin_comment
comment|/* If the section is relaxable (i.e., a literal section), check each    literal to see if it has the same value as another literal that has    already been seen, either in the current section or a previous one.    If so, add an entry to the per-section list of removed literals.  The    actual changes are deferred until the next pass.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|remove_literals
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|link_info
parameter_list|,
name|values
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|value_map_hash_table
modifier|*
name|values
decl_stmt|;
block|{
name|xtensa_relax_info
modifier|*
name|relax_info
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|source_reloc
modifier|*
name|src_relocs
decl_stmt|;
name|bfd_boolean
name|final_static_link
decl_stmt|;
name|bfd_boolean
name|ok
init|=
name|TRUE
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Do nothing if it is not a relaxable literal section.  */
name|relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|relax_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relax_info
operator|->
name|is_relaxable_literal_section
condition|)
return|return
name|ok
return|;
name|internal_relocs
operator|=
name|retrieve_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
name|contents
operator|=
name|retrieve_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
operator|&&
name|sec
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
name|ok
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|final_static_link
operator|=
operator|(
operator|!
name|link_info
operator|->
name|relocatable
operator|&&
operator|!
name|elf_hash_table
argument_list|(
name|link_info
argument_list|)
operator|->
name|dynamic_sections_created
operator|)
expr_stmt|;
comment|/* Sort the source_relocs by target offset.  */
name|src_relocs
operator|=
name|relax_info
operator|->
name|src_relocs
expr_stmt|;
name|qsort
argument_list|(
name|src_relocs
argument_list|,
name|relax_info
operator|->
name|src_count
argument_list|,
sizeof|sizeof
argument_list|(
name|source_reloc
argument_list|)
argument_list|,
name|source_reloc_compare
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|relax_info
operator|->
name|src_count
condition|;
name|i
operator|++
control|)
block|{
name|source_reloc
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
init|=
name|NULL
decl_stmt|;
name|literal_value
name|val
decl_stmt|;
name|value_map
modifier|*
name|val_map
decl_stmt|;
name|rel
operator|=
operator|&
name|src_relocs
index|[
name|i
index|]
expr_stmt|;
name|irel
operator|=
name|get_irel_at_offset
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|,
name|rel
operator|->
name|r_rel
operator|.
name|target_offset
argument_list|)
expr_stmt|;
comment|/* If the target_offset for this relocation is the same as the 	 previous relocation, then we've already considered whether the 	 literal can be coalesced.  Skip to the next one....  */
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
operator|(
name|src_relocs
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|r_rel
operator|.
name|target_offset
operator|==
name|rel
operator|->
name|r_rel
operator|.
name|target_offset
operator|)
condition|)
continue|continue;
comment|/* Check if the relocation was from an L32R that is being removed 	 because a CALLX was converted to a direct CALL, and check if 	 there are no other relocations to the literal.  */
if|if
condition|(
name|rel
operator|->
name|is_null
operator|&&
operator|(
name|i
operator|==
name|relax_info
operator|->
name|src_count
operator|-
literal|1
operator|||
operator|(
name|src_relocs
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|r_rel
operator|.
name|target_offset
operator|!=
name|rel
operator|->
name|r_rel
operator|.
name|target_offset
operator|)
operator|)
condition|)
block|{
comment|/* Mark the unused literal so that it will be removed.  */
name|add_removed_literal
argument_list|(
operator|&
name|relax_info
operator|->
name|removed_list
argument_list|,
operator|&
name|rel
operator|->
name|r_rel
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Zero out the relocation on this literal location.  */
if|if
condition|(
name|irel
condition|)
block|{
if|if
condition|(
name|elf_hash_table
argument_list|(
name|link_info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
name|shrink_dynamic_reloc_sections
argument_list|(
name|link_info
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_XTENSA_NONE
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Find the literal value.  */
name|r_reloc_init
argument_list|(
operator|&
name|val
operator|.
name|r_rel
argument_list|,
name|abfd
argument_list|,
name|irel
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|rel
operator|->
name|r_rel
operator|.
name|target_offset
operator|<
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|val
operator|.
name|value
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_rel
operator|.
name|target_offset
argument_list|)
expr_stmt|;
comment|/* Check if we've seen another literal with the same value.  */
name|val_map
operator|=
name|get_cached_value
argument_list|(
name|values
argument_list|,
operator|&
name|val
argument_list|,
name|final_static_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|val_map
operator|!=
name|NULL
condition|)
block|{
comment|/* First check that THIS and all the other relocs to this 	     literal will FIT if we move them to the new address.  */
if|if
condition|(
name|relocations_reach
argument_list|(
name|rel
argument_list|,
name|relax_info
operator|->
name|src_count
operator|-
name|i
argument_list|,
operator|&
name|val_map
operator|->
name|loc
argument_list|)
condition|)
block|{
comment|/* Mark that the literal will be coalesced.  */
name|add_removed_literal
argument_list|(
operator|&
name|relax_info
operator|->
name|removed_list
argument_list|,
operator|&
name|rel
operator|->
name|r_rel
argument_list|,
operator|&
name|val_map
operator|->
name|loc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Relocations do not reach -- do not remove this literal.  */
name|val_map
operator|->
name|loc
operator|=
name|rel
operator|->
name|r_rel
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This is the first time we've seen this literal value.  */
name|BFD_ASSERT
argument_list|(
name|sec
operator|==
name|r_reloc_get_section
argument_list|(
operator|&
name|rel
operator|->
name|r_rel
argument_list|)
argument_list|)
expr_stmt|;
name|add_value_map
argument_list|(
name|values
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|rel
operator|->
name|r_rel
argument_list|,
name|final_static_link
argument_list|)
expr_stmt|;
block|}
block|}
name|error_return
label|:
name|release_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|release_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/* Check if the original relocations (presumably on L32R instructions)    identified by reloc[0..N] can be changed to reference the literal    identified by r_rel.  If r_rel is out of range for any of the    original relocations, then we don't want to coalesce the original    literal with the one at r_rel.  We only check reloc[0..N], where the    offsets are all the same as for reloc[0] (i.e., they're all    referencing the same literal) and where N is also bounded by the    number of remaining entries in the "reloc" array.  The "reloc" array    is sorted by target offset so we know all the entries for the same    literal will be contiguous.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|relocations_reach
parameter_list|(
name|reloc
parameter_list|,
name|remaining_relocs
parameter_list|,
name|r_rel
parameter_list|)
name|source_reloc
modifier|*
name|reloc
decl_stmt|;
name|int
name|remaining_relocs
decl_stmt|;
specifier|const
name|r_reloc
modifier|*
name|r_rel
decl_stmt|;
block|{
name|bfd_vma
name|from_offset
decl_stmt|,
name|source_address
decl_stmt|,
name|dest_address
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|r_reloc_is_defined
argument_list|(
name|r_rel
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|sec
operator|=
name|r_reloc_get_section
argument_list|(
name|r_rel
argument_list|)
expr_stmt|;
name|from_offset
operator|=
name|reloc
index|[
literal|0
index|]
operator|.
name|r_rel
operator|.
name|target_offset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|remaining_relocs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reloc
index|[
name|i
index|]
operator|.
name|r_rel
operator|.
name|target_offset
operator|!=
name|from_offset
condition|)
break|break;
comment|/* Ignore relocations that have been removed.  */
if|if
condition|(
name|reloc
index|[
name|i
index|]
operator|.
name|is_null
condition|)
continue|continue;
comment|/* The original and new output section for these must be the same          in order to coalesce.  */
if|if
condition|(
name|r_reloc_get_section
argument_list|(
operator|&
name|reloc
index|[
name|i
index|]
operator|.
name|r_rel
argument_list|)
operator|->
name|output_section
operator|!=
name|sec
operator|->
name|output_section
condition|)
return|return
name|FALSE
return|;
comment|/* A NULL operand means it is not a PC-relative relocation, so          the literal can be moved anywhere.  */
if|if
condition|(
name|reloc
index|[
name|i
index|]
operator|.
name|opnd
condition|)
block|{
comment|/* Otherwise, check to see that it fits.  */
name|source_address
operator|=
operator|(
name|reloc
index|[
name|i
index|]
operator|.
name|source_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|reloc
index|[
name|i
index|]
operator|.
name|source_sec
operator|->
name|output_offset
operator|+
name|reloc
index|[
name|i
index|]
operator|.
name|r_rel
operator|.
name|rela
operator|.
name|r_offset
operator|)
expr_stmt|;
name|dest_address
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|r_rel
operator|->
name|target_offset
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|pcrel_reloc_fits
argument_list|(
name|reloc
index|[
name|i
index|]
operator|.
name|opnd
argument_list|,
name|source_address
argument_list|,
name|dest_address
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* WARNING: linear search here.  If the relocation are in order by    address, we can use a faster binary search.  ALSO, we assume that    there is only 1 non-NONE relocation per address.  */
end_comment

begin_function
specifier|static
name|Elf_Internal_Rela
modifier|*
name|get_irel_at_offset
parameter_list|(
name|sec
parameter_list|,
name|internal_relocs
parameter_list|,
name|offset
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
block|{
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|internal_relocs
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|irel
init|=
operator|&
name|internal_relocs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|==
name|offset
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_XTENSA_NONE
condition|)
return|return
name|irel
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Second relaxation pass.  */
end_comment

begin_comment
comment|/* Modify all of the relocations to point to the right spot, and if this    is a relaxable section, delete the unwanted literals and fix the    cooked_size.  */
end_comment

begin_function
name|bfd_boolean
name|relax_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|link_info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|xtensa_relax_info
modifier|*
name|relax_info
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_boolean
name|ok
init|=
name|TRUE
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|relax_info
argument_list|)
expr_stmt|;
comment|/* Handle property sections (e.g., literal tables) specially.  */
if|if
condition|(
name|xtensa_is_property_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|relax_info
operator|->
name|is_relaxable_literal_section
argument_list|)
expr_stmt|;
return|return
name|relax_property_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
argument_list|)
return|;
block|}
name|internal_relocs
operator|=
name|retrieve_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
name|contents
operator|=
name|retrieve_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
operator|&&
name|sec
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
name|ok
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|internal_relocs
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
name|xtensa_relax_info
modifier|*
name|target_relax_info
decl_stmt|;
name|bfd_vma
name|source_offset
decl_stmt|;
name|r_reloc
name|r_rel
decl_stmt|;
name|unsigned
name|r_type
decl_stmt|;
name|asection
modifier|*
name|target_sec
decl_stmt|;
comment|/* Locally change the source address. 	     Translate the target to the new target address. 	     If it points to this section and has been removed, 	     NULLify it. 	     Write it back.  */
name|irel
operator|=
operator|&
name|internal_relocs
index|[
name|i
index|]
expr_stmt|;
name|source_offset
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_reloc_init
argument_list|(
operator|&
name|r_rel
argument_list|,
name|abfd
argument_list|,
name|irel
argument_list|)
expr_stmt|;
if|if
condition|(
name|relax_info
operator|->
name|is_relaxable_literal_section
condition|)
block|{
if|if
condition|(
name|r_type
operator|!=
name|R_XTENSA_NONE
operator|&&
name|find_removed_literal
argument_list|(
operator|&
name|relax_info
operator|->
name|removed_list
argument_list|,
name|irel
operator|->
name|r_offset
argument_list|)
condition|)
block|{
comment|/* Remove this relocation.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|link_info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
name|shrink_dynamic_reloc_sections
argument_list|(
name|link_info
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_XTENSA_NONE
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_offset
operator|=
name|offset_with_removed_literals
argument_list|(
operator|&
name|relax_info
operator|->
name|removed_list
argument_list|,
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|source_offset
operator|=
name|offset_with_removed_literals
argument_list|(
operator|&
name|relax_info
operator|->
name|removed_list
argument_list|,
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_offset
operator|=
name|source_offset
expr_stmt|;
block|}
name|target_sec
operator|=
name|r_reloc_get_section
argument_list|(
operator|&
name|r_rel
argument_list|)
expr_stmt|;
name|target_relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|target_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_relax_info
operator|&&
name|target_relax_info
operator|->
name|is_relaxable_literal_section
condition|)
block|{
name|r_reloc
name|new_rel
decl_stmt|;
name|reloc_bfd_fix
modifier|*
name|fix
decl_stmt|;
name|translate_reloc
argument_list|(
operator|&
name|r_rel
argument_list|,
operator|&
name|new_rel
argument_list|)
expr_stmt|;
comment|/* FIXME: If the relocation still references a section in 		 the same input file, the relocation should be modified 		 directly instead of adding a "fix" record.  */
name|fix
operator|=
name|reloc_bfd_fix_init
argument_list|(
name|sec
argument_list|,
name|source_offset
argument_list|,
name|r_type
argument_list|,
literal|0
argument_list|,
name|r_reloc_get_section
argument_list|(
operator|&
name|new_rel
argument_list|)
argument_list|,
name|new_rel
operator|.
name|target_offset
argument_list|)
expr_stmt|;
name|add_fix
argument_list|(
name|sec
argument_list|,
name|fix
argument_list|)
expr_stmt|;
block|}
name|pin_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|relax_info
operator|->
name|is_relaxable_literal_section
condition|)
block|{
comment|/* Walk through the contents and delete literals that are not needed           anymore.  */
name|unsigned
name|long
name|size
init|=
name|sec
operator|->
name|_cooked_size
decl_stmt|;
name|unsigned
name|long
name|removed
init|=
literal|0
decl_stmt|;
name|removed_literal
modifier|*
name|reloc
init|=
name|relax_info
operator|->
name|removed_list
operator|.
name|head
decl_stmt|;
for|for
control|(
init|;
name|reloc
condition|;
name|reloc
operator|=
name|reloc
operator|->
name|next
control|)
block|{
name|unsigned
name|long
name|upper
init|=
name|sec
operator|->
name|_raw_size
decl_stmt|;
name|bfd_vma
name|start
init|=
name|reloc
operator|->
name|from
operator|.
name|target_offset
operator|+
literal|4
decl_stmt|;
if|if
condition|(
name|reloc
operator|->
name|next
condition|)
name|upper
operator|=
name|reloc
operator|->
name|next
operator|->
name|from
operator|.
name|target_offset
expr_stmt|;
if|if
condition|(
name|upper
operator|-
name|start
operator|!=
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|start
operator|<=
name|upper
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|contents
operator|+
name|start
operator|-
name|removed
operator|-
literal|4
argument_list|,
name|contents
operator|+
name|start
argument_list|,
name|upper
operator|-
name|start
argument_list|)
expr_stmt|;
name|pin_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
block|}
name|removed
operator|+=
literal|4
expr_stmt|;
name|size
operator|-=
literal|4
expr_stmt|;
block|}
comment|/* Change the section size.  */
name|sec
operator|->
name|_cooked_size
operator|=
name|size
expr_stmt|;
comment|/* Also shrink _raw_size.  (The code in relocate_section that 	 checks that relocations are within the section must use 	 _raw_size because of the way the stabs sections are relaxed; 	 shrinking _raw_size means that these checks will not be 	 unnecessarily lax.)  */
name|sec
operator|->
name|_raw_size
operator|=
name|size
expr_stmt|;
block|}
name|error_return
label|:
name|release_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
name|release_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/* Fix up a relocation to take account of removed literals.  */
end_comment

begin_function
specifier|static
name|void
name|translate_reloc
parameter_list|(
name|orig_rel
parameter_list|,
name|new_rel
parameter_list|)
specifier|const
name|r_reloc
modifier|*
name|orig_rel
decl_stmt|;
name|r_reloc
modifier|*
name|new_rel
decl_stmt|;
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|xtensa_relax_info
modifier|*
name|relax_info
decl_stmt|;
name|removed_literal
modifier|*
name|removed
decl_stmt|;
name|unsigned
name|long
name|new_offset
decl_stmt|;
operator|*
name|new_rel
operator|=
operator|*
name|orig_rel
expr_stmt|;
if|if
condition|(
operator|!
name|r_reloc_is_defined
argument_list|(
name|orig_rel
argument_list|)
condition|)
return|return;
name|sec
operator|=
name|r_reloc_get_section
argument_list|(
name|orig_rel
argument_list|)
expr_stmt|;
name|relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|relax_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relax_info
operator|->
name|is_relaxable_literal_section
condition|)
return|return;
comment|/* Check if the original relocation is against a literal being removed.  */
name|removed
operator|=
name|find_removed_literal
argument_list|(
operator|&
name|relax_info
operator|->
name|removed_list
argument_list|,
name|orig_rel
operator|->
name|target_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|removed
condition|)
block|{
name|asection
modifier|*
name|new_sec
decl_stmt|;
comment|/* The fact that there is still a relocation to this literal indicates 	 that the literal is being coalesced, not simply removed.  */
name|BFD_ASSERT
argument_list|(
name|removed
operator|->
name|to
operator|.
name|abfd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* This was moved to some other address (possibly in another section). */
operator|*
name|new_rel
operator|=
name|removed
operator|->
name|to
expr_stmt|;
name|new_sec
operator|=
name|r_reloc_get_section
argument_list|(
name|new_rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_sec
operator|!=
name|sec
condition|)
block|{
name|sec
operator|=
name|new_sec
expr_stmt|;
name|relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relax_info
operator|||
operator|!
name|relax_info
operator|->
name|is_relaxable_literal_section
condition|)
return|return;
block|}
block|}
comment|/* ...and the target address may have been moved within its section.  */
name|new_offset
operator|=
name|offset_with_removed_literals
argument_list|(
operator|&
name|relax_info
operator|->
name|removed_list
argument_list|,
name|new_rel
operator|->
name|target_offset
argument_list|)
expr_stmt|;
comment|/* Modify the offset and addend.  */
name|new_rel
operator|->
name|target_offset
operator|=
name|new_offset
expr_stmt|;
name|new_rel
operator|->
name|rela
operator|.
name|r_addend
operator|+=
operator|(
name|new_offset
operator|-
name|new_rel
operator|->
name|target_offset
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For dynamic links, there may be a dynamic relocation for each    literal.  The number of dynamic relocations must be computed in    size_dynamic_sections, which occurs before relaxation.  When a    literal is removed, this function checks if there is a corresponding    dynamic relocation and shrinks the size of the appropriate dynamic    relocation section accordingly.  At this point, the contents of the    dynamic relocation sections have not yet been filled in, so there's    nothing else that needs to be done.  */
end_comment

begin_function
specifier|static
name|void
name|shrink_dynamic_reloc_sections
parameter_list|(
name|info
parameter_list|,
name|abfd
parameter_list|,
name|input_section
parameter_list|,
name|rel
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|int
name|r_type
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_boolean
name|dynamic_symbol
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
name|dynamic_symbol
operator|=
name|xtensa_elf_dynamic_symbol_p
argument_list|(
name|h
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r_type
operator|==
name|R_XTENSA_32
operator|||
name|r_type
operator|==
name|R_XTENSA_PLT
operator|)
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|dynamic_symbol
operator|||
name|info
operator|->
name|shared
operator|)
condition|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
specifier|const
name|char
modifier|*
name|srel_name
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
name|bfd_boolean
name|is_plt
init|=
name|FALSE
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic_symbol
operator|&&
name|r_type
operator|==
name|R_XTENSA_PLT
condition|)
block|{
name|srel_name
operator|=
literal|".rela.plt"
expr_stmt|;
name|is_plt
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|srel_name
operator|=
literal|".rela.got"
expr_stmt|;
comment|/* Reduce size of the .rela.* section by one reloc.  */
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|srel_name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|->
name|_cooked_size
operator|>=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
argument_list|)
expr_stmt|;
name|srel
operator|->
name|_cooked_size
operator|-=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
comment|/* Also shrink _raw_size.  (This seems wrong but other bfd code seems 	 to assume that linker-created sections will never be relaxed and 	 hence _raw_size must always equal _cooked_size.) */
name|srel
operator|->
name|_raw_size
operator|=
name|srel
operator|->
name|_cooked_size
expr_stmt|;
if|if
condition|(
name|is_plt
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|,
modifier|*
name|sgotplt
decl_stmt|,
modifier|*
name|srelgot
decl_stmt|;
name|int
name|reloc_index
decl_stmt|,
name|chunk
decl_stmt|;
comment|/* Find the PLT reloc index of the entry being removed.  This 	     is computed from the size of ".rela.plt".  It is needed to 	     figure out which PLT chunk to resize.  Usually "last index 	     = size - 1" since the index starts at zero, but in this 	     context, the size has just been decremented so there's no 	     need to subtract one.  */
name|reloc_index
operator|=
name|srel
operator|->
name|_cooked_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|chunk
operator|=
name|reloc_index
operator|/
name|PLT_ENTRIES_PER_CHUNK
expr_stmt|;
name|splt
operator|=
name|elf_xtensa_get_plt_section
argument_list|(
name|dynobj
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|sgotplt
operator|=
name|elf_xtensa_get_gotplt_section
argument_list|(
name|dynobj
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|sgotplt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Check if an entire PLT chunk has just been eliminated.  */
if|if
condition|(
name|reloc_index
operator|%
name|PLT_ENTRIES_PER_CHUNK
operator|==
literal|0
condition|)
block|{
comment|/* The two magic GOT entries for that chunk can go away.  */
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srelgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|srelgot
operator|->
name|reloc_count
operator|-=
literal|2
expr_stmt|;
name|srelgot
operator|->
name|_cooked_size
operator|-=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
comment|/* Shrink _raw_size (see comment above).  */
name|srelgot
operator|->
name|_raw_size
operator|=
name|srelgot
operator|->
name|_cooked_size
expr_stmt|;
name|sgotplt
operator|->
name|_cooked_size
operator|-=
literal|8
expr_stmt|;
comment|/* There should be only one entry left (and it will be 		 removed below).  */
name|BFD_ASSERT
argument_list|(
name|sgotplt
operator|->
name|_cooked_size
operator|==
literal|4
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|->
name|_cooked_size
operator|==
name|PLT_ENTRY_SIZE
argument_list|)
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|sgotplt
operator|->
name|_cooked_size
operator|>=
literal|4
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|->
name|_cooked_size
operator|>=
name|PLT_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|sgotplt
operator|->
name|_cooked_size
operator|-=
literal|4
expr_stmt|;
name|splt
operator|->
name|_cooked_size
operator|-=
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* Shrink _raw_sizes (see comment above).  */
name|sgotplt
operator|->
name|_raw_size
operator|=
name|sgotplt
operator|->
name|_cooked_size
expr_stmt|;
name|splt
operator|->
name|_raw_size
operator|=
name|splt
operator|->
name|_cooked_size
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This is similar to relax_section except that when a target is moved,    we shift addresses up.  We also need to modify the size.  This    algorithm does NOT allow for relocations into the middle of the    property sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|relax_property_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|link_info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|nexti
decl_stmt|;
name|bfd_boolean
name|ok
init|=
name|TRUE
decl_stmt|;
name|internal_relocs
operator|=
name|retrieve_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
name|contents
operator|=
name|retrieve_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
operator|&&
name|sec
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
name|ok
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|internal_relocs
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
name|xtensa_relax_info
modifier|*
name|target_relax_info
decl_stmt|;
name|r_reloc
name|r_rel
decl_stmt|;
name|unsigned
name|r_type
decl_stmt|;
name|asection
modifier|*
name|target_sec
decl_stmt|;
comment|/* Locally change the source address. 	     Translate the target to the new target address. 	     If it points to this section and has been removed, MOVE IT. 	     Also, don't forget to modify the associated SIZE at 	     (offset + 4).  */
name|irel
operator|=
operator|&
name|internal_relocs
index|[
name|i
index|]
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_XTENSA_NONE
condition|)
continue|continue;
name|r_reloc_init
argument_list|(
operator|&
name|r_rel
argument_list|,
name|abfd
argument_list|,
name|irel
argument_list|)
expr_stmt|;
name|target_sec
operator|=
name|r_reloc_get_section
argument_list|(
operator|&
name|r_rel
argument_list|)
expr_stmt|;
name|target_relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|target_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_relax_info
operator|&&
name|target_relax_info
operator|->
name|is_relaxable_literal_section
condition|)
block|{
comment|/* Translate the relocation's destination.  */
name|bfd_vma
name|new_offset
decl_stmt|;
name|bfd_vma
name|new_end_offset
decl_stmt|;
name|bfd_byte
modifier|*
name|size_p
decl_stmt|;
name|long
name|old_size
decl_stmt|,
name|new_size
decl_stmt|;
name|new_offset
operator|=
name|offset_with_removed_literals
argument_list|(
operator|&
name|target_relax_info
operator|->
name|removed_list
argument_list|,
name|r_rel
operator|.
name|target_offset
argument_list|)
expr_stmt|;
comment|/* Assert that we are not out of bounds.  */
name|size_p
operator|=
operator|&
name|contents
index|[
name|irel
operator|->
name|r_offset
operator|+
literal|4
index|]
expr_stmt|;
name|old_size
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|contents
index|[
name|irel
operator|->
name|r_offset
operator|+
literal|4
index|]
argument_list|)
expr_stmt|;
name|new_end_offset
operator|=
name|offset_with_removed_literals
argument_list|(
operator|&
name|target_relax_info
operator|->
name|removed_list
argument_list|,
name|r_rel
operator|.
name|target_offset
operator|+
name|old_size
argument_list|)
expr_stmt|;
name|new_size
operator|=
name|new_end_offset
operator|-
name|new_offset
expr_stmt|;
if|if
condition|(
name|new_size
operator|!=
name|old_size
condition|)
block|{
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|new_size
argument_list|,
name|size_p
argument_list|)
expr_stmt|;
name|pin_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_offset
operator|!=
name|r_rel
operator|.
name|target_offset
condition|)
block|{
name|bfd_vma
name|diff
init|=
name|new_offset
operator|-
name|r_rel
operator|.
name|target_offset
decl_stmt|;
name|irel
operator|->
name|r_addend
operator|+=
name|diff
expr_stmt|;
name|pin_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Combine adjacent property table entries.  This is also done in      finish_dynamic_sections() but at that point it's too late to      reclaim the space in the output section, so we do this twice.  */
if|if
condition|(
name|internal_relocs
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|last_irel
init|=
name|NULL
decl_stmt|;
name|int
name|removed_bytes
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|,
name|last_irel_offset
decl_stmt|;
name|bfd_vma
name|section_size
decl_stmt|;
comment|/* Walk over memory and irels at the same time.          This REQUIRES that the internal_relocs be sorted by offset.  */
name|qsort
argument_list|(
name|internal_relocs
argument_list|,
name|sec
operator|->
name|reloc_count
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
argument_list|,
name|internal_reloc_compare
argument_list|)
expr_stmt|;
name|nexti
operator|=
literal|0
expr_stmt|;
comment|/* Index into internal_relocs.  */
name|pin_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
name|pin_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|last_irel_offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|section_size
operator|=
operator|(
name|sec
operator|->
name|_cooked_size
condition|?
name|sec
operator|->
name|_cooked_size
else|:
name|sec
operator|->
name|_raw_size
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|section_size
operator|%
literal|8
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|section_size
condition|;
name|offset
operator|+=
literal|8
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|next_irel
decl_stmt|;
name|bfd_vma
name|bytes_to_remove
decl_stmt|,
name|size
decl_stmt|,
name|actual_offset
decl_stmt|;
name|bfd_boolean
name|remove_this_irel
decl_stmt|;
name|irel
operator|=
name|NULL
expr_stmt|;
name|next_irel
operator|=
name|NULL
expr_stmt|;
comment|/* Find the next two relocations (if there are that many left), 	     skipping over any R_XTENSA_NONE relocs.  On entry, "nexti" is 	     the starting reloc index.  After these two loops, "i" 	     is the index of the first non-NONE reloc past that starting 	     index, and "nexti" is the index for the next non-NONE reloc 	     after "i".  */
for|for
control|(
name|i
operator|=
name|nexti
init|;
name|i
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|internal_relocs
index|[
name|i
index|]
operator|.
name|r_info
argument_list|)
operator|!=
name|R_XTENSA_NONE
condition|)
block|{
name|irel
operator|=
operator|&
name|internal_relocs
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
name|internal_relocs
index|[
name|i
index|]
operator|.
name|r_offset
operator|-=
name|removed_bytes
expr_stmt|;
block|}
for|for
control|(
name|nexti
operator|=
name|i
operator|+
literal|1
init|;
name|nexti
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|nexti
operator|++
control|)
block|{
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|internal_relocs
index|[
name|nexti
index|]
operator|.
name|r_info
argument_list|)
operator|!=
name|R_XTENSA_NONE
condition|)
block|{
name|next_irel
operator|=
operator|&
name|internal_relocs
index|[
name|nexti
index|]
expr_stmt|;
break|break;
block|}
name|internal_relocs
index|[
name|nexti
index|]
operator|.
name|r_offset
operator|-=
name|removed_bytes
expr_stmt|;
block|}
name|remove_this_irel
operator|=
name|FALSE
expr_stmt|;
name|bytes_to_remove
operator|=
literal|0
expr_stmt|;
name|actual_offset
operator|=
name|offset
operator|-
name|removed_bytes
expr_stmt|;
name|size
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|contents
index|[
name|actual_offset
operator|+
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/* Check that the irels are sorted by offset, 	     with only one per address.  */
name|BFD_ASSERT
argument_list|(
operator|!
name|irel
operator|||
operator|(
name|int
operator|)
name|irel
operator|->
name|r_offset
operator|>
operator|(
name|int
operator|)
name|last_irel_offset
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|!
name|next_irel
operator|||
name|next_irel
operator|->
name|r_offset
operator|>
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Make sure there isn't a reloc on the size field.  */
if|if
condition|(
name|irel
operator|&&
name|irel
operator|->
name|r_offset
operator|==
name|offset
operator|+
literal|4
condition|)
block|{
name|irel
operator|->
name|r_offset
operator|-=
name|removed_bytes
expr_stmt|;
name|last_irel_offset
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|next_irel
operator|&&
name|next_irel
operator|->
name|r_offset
operator|==
name|offset
operator|+
literal|4
condition|)
block|{
name|nexti
operator|+=
literal|1
expr_stmt|;
name|irel
operator|->
name|r_offset
operator|-=
name|removed_bytes
expr_stmt|;
name|next_irel
operator|->
name|r_offset
operator|-=
name|removed_bytes
expr_stmt|;
name|last_irel_offset
operator|=
name|next_irel
operator|->
name|r_offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
comment|/* Always remove entries with zero size.  */
name|bytes_to_remove
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|irel
operator|&&
name|irel
operator|->
name|r_offset
operator|==
name|offset
condition|)
block|{
name|remove_this_irel
operator|=
name|TRUE
expr_stmt|;
name|irel
operator|->
name|r_offset
operator|-=
name|removed_bytes
expr_stmt|;
name|last_irel_offset
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|irel
operator|&&
name|irel
operator|->
name|r_offset
operator|==
name|offset
condition|)
block|{
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
name|R_XTENSA_32
condition|)
block|{
if|if
condition|(
name|last_irel
condition|)
block|{
name|bfd_vma
name|old_size
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|contents
index|[
name|last_irel
operator|->
name|r_offset
operator|+
literal|4
index|]
argument_list|)
decl_stmt|;
name|bfd_vma
name|old_address
init|=
operator|(
name|last_irel
operator|->
name|r_addend
operator|+
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|contents
index|[
name|last_irel
operator|->
name|r_offset
index|]
argument_list|)
operator|)
decl_stmt|;
name|bfd_vma
name|new_address
init|=
operator|(
name|irel
operator|->
name|r_addend
operator|+
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|&
name|contents
index|[
name|actual_offset
index|]
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
name|ELF32_R_SYM
argument_list|(
name|last_irel
operator|->
name|r_info
argument_list|)
operator|)
operator|&&
operator|(
name|old_address
operator|+
name|old_size
operator|==
name|new_address
operator|)
condition|)
block|{
comment|/* fix the old size */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|old_size
operator|+
name|size
argument_list|,
operator|&
name|contents
index|[
name|last_irel
operator|->
name|r_offset
operator|+
literal|4
index|]
argument_list|)
expr_stmt|;
name|bytes_to_remove
operator|=
literal|8
expr_stmt|;
name|remove_this_irel
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|last_irel
operator|=
name|irel
expr_stmt|;
block|}
else|else
name|last_irel
operator|=
name|irel
expr_stmt|;
block|}
name|irel
operator|->
name|r_offset
operator|-=
name|removed_bytes
expr_stmt|;
name|last_irel_offset
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
block|}
if|if
condition|(
name|remove_this_irel
condition|)
block|{
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_XTENSA_NONE
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_offset
operator|-=
name|bytes_to_remove
expr_stmt|;
block|}
if|if
condition|(
name|bytes_to_remove
operator|!=
literal|0
condition|)
block|{
name|removed_bytes
operator|+=
name|bytes_to_remove
expr_stmt|;
if|if
condition|(
name|offset
operator|+
literal|8
operator|<
name|section_size
condition|)
name|memmove
argument_list|(
operator|&
name|contents
index|[
name|actual_offset
index|]
argument_list|,
operator|&
name|contents
index|[
name|actual_offset
operator|+
literal|8
index|]
argument_list|,
name|section_size
operator|-
name|offset
operator|-
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|removed_bytes
condition|)
block|{
comment|/* Clear the removed bytes.  */
name|memset
argument_list|(
operator|&
name|contents
index|[
name|section_size
operator|-
name|removed_bytes
index|]
argument_list|,
literal|0
argument_list|,
name|removed_bytes
argument_list|)
expr_stmt|;
name|sec
operator|->
name|_cooked_size
operator|=
name|section_size
operator|-
name|removed_bytes
expr_stmt|;
comment|/* Also shrink _raw_size.  (The code in relocate_section that 	     checks that relocations are within the section must use 	     _raw_size because of the way the stabs sections are 	     relaxed; shrinking _raw_size means that these checks will 	     not be unnecessarily lax.)  */
name|sec
operator|->
name|_raw_size
operator|=
name|sec
operator|->
name|_cooked_size
expr_stmt|;
if|if
condition|(
name|xtensa_is_littable_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
name|bfd
modifier|*
name|dynobj
init|=
name|elf_hash_table
argument_list|(
name|link_info
argument_list|)
operator|->
name|dynobj
decl_stmt|;
if|if
condition|(
name|dynobj
condition|)
block|{
name|asection
modifier|*
name|sgotloc
init|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.loc"
argument_list|)
decl_stmt|;
if|if
condition|(
name|sgotloc
condition|)
block|{
name|bfd_size_type
name|sgotloc_size
init|=
operator|(
name|sgotloc
operator|->
name|_cooked_size
condition|?
name|sgotloc
operator|->
name|_cooked_size
else|:
name|sgotloc
operator|->
name|_raw_size
operator|)
decl_stmt|;
name|sgotloc
operator|->
name|_cooked_size
operator|=
name|sgotloc_size
operator|-
name|removed_bytes
expr_stmt|;
name|sgotloc
operator|->
name|_raw_size
operator|=
name|sgotloc_size
operator|-
name|removed_bytes
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|error_return
label|:
name|release_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
name|release_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Third relaxation pass.  */
end_comment

begin_comment
comment|/* Change symbol values to account for removed literals.  */
end_comment

begin_function
name|bfd_boolean
name|relax_section_symbols
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
name|xtensa_relax_info
modifier|*
name|relax_info
decl_stmt|;
name|unsigned
name|int
name|sec_shndx
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|num_syms
decl_stmt|,
name|num_locals
decl_stmt|;
name|relax_info
operator|=
name|get_xtensa_relax_info
argument_list|(
name|sec
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|relax_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relax_info
operator|->
name|is_relaxable_literal_section
condition|)
return|return
name|TRUE
return|;
name|sec_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|isymbuf
operator|=
name|retrieve_local_syms
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|num_syms
operator|=
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
expr_stmt|;
name|num_locals
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
comment|/* Adjust the local symbols defined in this section.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_locals
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Sym
modifier|*
name|isym
init|=
operator|&
name|isymbuf
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|sec_shndx
condition|)
block|{
name|bfd_vma
name|new_address
init|=
name|offset_with_removed_literals
argument_list|(
operator|&
name|relax_info
operator|->
name|removed_list
argument_list|,
name|isym
operator|->
name|st_value
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_address
operator|!=
name|isym
operator|->
name|st_value
condition|)
name|isym
operator|->
name|st_value
operator|=
name|new_address
expr_stmt|;
block|}
block|}
comment|/* Now adjust the global symbols defined in this section.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|num_syms
operator|-
name|num_locals
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|sym_hash
decl_stmt|;
name|sym_hash
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|sym_hash
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
operator|(
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|sec
condition|)
block|{
name|bfd_vma
name|new_address
init|=
name|offset_with_removed_literals
argument_list|(
operator|&
name|relax_info
operator|->
name|removed_list
argument_list|,
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_address
operator|!=
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
condition|)
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|new_address
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* "Fix" handling functions, called while performing relocations.  */
end_comment

begin_function
specifier|static
name|void
name|do_fix_for_relocatable_link
parameter_list|(
name|rel
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|)
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
block|{
name|r_reloc
name|r_rel
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|,
modifier|*
name|old_sec
decl_stmt|;
name|bfd_vma
name|old_offset
decl_stmt|;
name|int
name|r_type
init|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|reloc_bfd_fix
modifier|*
name|fix_list
decl_stmt|;
name|reloc_bfd_fix
modifier|*
name|fix
decl_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_XTENSA_NONE
condition|)
return|return;
name|fix_list
operator|=
operator|(
name|get_xtensa_relax_info
argument_list|(
name|input_section
argument_list|)
operator|)
operator|->
name|fix_list
expr_stmt|;
if|if
condition|(
name|fix_list
operator|==
name|NULL
condition|)
return|return;
name|fix
operator|=
name|get_bfd_fix
argument_list|(
name|fix_list
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|fix
operator|==
name|NULL
condition|)
return|return;
name|r_reloc_init
argument_list|(
operator|&
name|r_rel
argument_list|,
name|input_bfd
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|old_sec
operator|=
name|r_reloc_get_section
argument_list|(
operator|&
name|r_rel
argument_list|)
expr_stmt|;
name|old_offset
operator|=
name|r_reloc_get_target_offset
argument_list|(
operator|&
name|r_rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_sec
operator|==
name|NULL
operator|||
operator|!
name|r_reloc_is_defined
argument_list|(
operator|&
name|r_rel
argument_list|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|r_type
operator|==
name|R_XTENSA_ASM_EXPAND
argument_list|)
expr_stmt|;
comment|/* Leave it be.  Resolution will happen in a later stage.  */
block|}
else|else
block|{
name|sec
operator|=
name|fix
operator|->
name|target_sec
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|+=
operator|(
operator|(
name|sec
operator|->
name|output_offset
operator|+
name|fix
operator|->
name|target_offset
operator|)
operator|-
operator|(
name|old_sec
operator|->
name|output_offset
operator|+
name|old_offset
operator|)
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_fix_for_final_link
parameter_list|(
name|rel
parameter_list|,
name|input_section
parameter_list|,
name|relocationp
parameter_list|)
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_vma
modifier|*
name|relocationp
decl_stmt|;
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|int
name|r_type
init|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|reloc_bfd_fix
modifier|*
name|fix_list
decl_stmt|;
name|reloc_bfd_fix
modifier|*
name|fix
decl_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_XTENSA_NONE
condition|)
return|return;
name|fix_list
operator|=
operator|(
name|get_xtensa_relax_info
argument_list|(
name|input_section
argument_list|)
operator|)
operator|->
name|fix_list
expr_stmt|;
if|if
condition|(
name|fix_list
operator|==
name|NULL
condition|)
return|return;
name|fix
operator|=
name|get_bfd_fix
argument_list|(
name|fix_list
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|fix
operator|==
name|NULL
condition|)
return|return;
name|sec
operator|=
name|fix
operator|->
name|target_sec
expr_stmt|;
operator|*
name|relocationp
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|fix
operator|->
name|target_offset
operator|-
name|rel
operator|->
name|r_addend
operator|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Miscellaneous utility functions....  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|elf_xtensa_get_plt_section
parameter_list|(
name|dynobj
parameter_list|,
name|chunk
parameter_list|)
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|int
name|chunk
decl_stmt|;
block|{
name|char
name|plt_name
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|chunk
operator|==
literal|0
condition|)
return|return
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
return|;
name|sprintf
argument_list|(
name|plt_name
argument_list|,
literal|".plt.%u"
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
return|return
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|plt_name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|elf_xtensa_get_gotplt_section
parameter_list|(
name|dynobj
parameter_list|,
name|chunk
parameter_list|)
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|int
name|chunk
decl_stmt|;
block|{
name|char
name|got_name
index|[
literal|14
index|]
decl_stmt|;
if|if
condition|(
name|chunk
operator|==
literal|0
condition|)
return|return
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
return|;
name|sprintf
argument_list|(
name|got_name
argument_list|,
literal|".got.plt.%u"
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
return|return
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|got_name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the input section for a given symbol index.    If the symbol is:    . a section symbol, return the section;    . a common symbol, return the common section;    . an undefined symbol, return the undefined section;    . an indirect symbol, follow the links;    . an absolute value, return the absolute section.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|get_elf_r_symndx_section
parameter_list|(
name|abfd
parameter_list|,
name|r_symndx
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
init|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|target_sec
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|Elf_Internal_Sym
modifier|*
name|isymbuf
decl_stmt|;
name|unsigned
name|int
name|section_index
decl_stmt|;
name|isymbuf
operator|=
name|retrieve_local_syms
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|section_index
operator|=
name|isymbuf
index|[
name|r_symndx
index|]
operator|.
name|st_shndx
expr_stmt|;
if|if
condition|(
name|section_index
operator|==
name|SHN_UNDEF
condition|)
name|target_sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|section_index
operator|>
literal|0
operator|&&
name|section_index
operator|<
name|SHN_LORESERVE
condition|)
name|target_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|section_index
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|section_index
operator|==
name|SHN_ABS
condition|)
name|target_sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|section_index
operator|==
name|SHN_COMMON
condition|)
name|target_sec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
comment|/* Who knows?  */
name|target_sec
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|indx
init|=
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
decl_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
name|target_sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_common
case|:
name|target_sec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_undefined
case|:
case|case
name|bfd_link_hash_undefweak
case|:
name|target_sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
break|break;
default|default:
comment|/* New indirect warning.  */
name|target_sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
break|break;
block|}
block|}
return|return
name|target_sec
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|elf_link_hash_entry
modifier|*
name|get_elf_r_symndx_hash_entry
parameter_list|(
name|abfd
parameter_list|,
name|r_symndx
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
block|{
name|unsigned
name|long
name|indx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
init|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
decl_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
return|return
name|NULL
return|;
name|indx
operator|=
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/* Get the section-relative offset for a symbol number.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|get_elf_r_symndx_offset
parameter_list|(
name|abfd
parameter_list|,
name|r_symndx
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
init|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
decl_stmt|;
name|bfd_vma
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|Elf_Internal_Sym
modifier|*
name|isymbuf
decl_stmt|;
name|isymbuf
operator|=
name|retrieve_local_syms
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|offset
operator|=
name|isymbuf
index|[
name|r_symndx
index|]
operator|.
name|st_value
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|indx
init|=
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
decl_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
name|offset
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|pcrel_reloc_fits
parameter_list|(
name|opnd
parameter_list|,
name|self_address
parameter_list|,
name|dest_address
parameter_list|)
name|xtensa_operand
name|opnd
decl_stmt|;
name|bfd_vma
name|self_address
decl_stmt|;
name|bfd_vma
name|dest_address
decl_stmt|;
block|{
name|uint32
name|new_address
init|=
name|xtensa_operand_do_reloc
argument_list|(
name|opnd
argument_list|,
name|dest_address
argument_list|,
name|self_address
argument_list|)
decl_stmt|;
return|return
operator|(
name|xtensa_operand_encode
argument_list|(
name|opnd
argument_list|,
operator|&
name|new_address
argument_list|)
operator|==
name|xtensa_encode_result_ok
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|linkonce_len
init|=
sizeof|sizeof
argument_list|(
literal|".gnu.linkonce."
argument_list|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_sec_len
init|=
sizeof|sizeof
argument_list|(
name|XTENSA_INSN_SEC_NAME
argument_list|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lit_sec_len
init|=
sizeof|sizeof
argument_list|(
name|XTENSA_LIT_SEC_NAME
argument_list|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_boolean
name|xtensa_is_property_section
parameter_list|(
name|sec
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|XTENSA_INSN_SEC_NAME
argument_list|,
name|sec
operator|->
name|name
argument_list|,
name|insn_sec_len
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|XTENSA_LIT_SEC_NAME
argument_list|,
name|sec
operator|->
name|name
argument_list|,
name|lit_sec_len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|strncmp
argument_list|(
literal|".gnu.linkonce."
argument_list|,
name|sec
operator|->
name|name
argument_list|,
name|linkonce_len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|sec
operator|->
name|name
index|[
name|linkonce_len
index|]
operator|==
literal|'x'
operator|||
name|sec
operator|->
name|name
index|[
name|linkonce_len
index|]
operator|==
literal|'p'
operator|)
operator|&&
name|sec
operator|->
name|name
index|[
name|linkonce_len
operator|+
literal|1
index|]
operator|==
literal|'.'
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|xtensa_is_littable_section
parameter_list|(
name|sec
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|XTENSA_LIT_SEC_NAME
argument_list|,
name|sec
operator|->
name|name
argument_list|,
name|lit_sec_len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|strncmp
argument_list|(
literal|".gnu.linkonce."
argument_list|,
name|sec
operator|->
name|name
argument_list|,
name|linkonce_len
argument_list|)
operator|==
literal|0
operator|&&
name|sec
operator|->
name|name
index|[
name|linkonce_len
index|]
operator|==
literal|'p'
operator|&&
name|sec
operator|->
name|name
index|[
name|linkonce_len
operator|+
literal|1
index|]
operator|==
literal|'.'
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|is_literal_section
parameter_list|(
name|sec
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
comment|/* FIXME: the current definition of this leaves a lot to be desired....  */
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
name|sec
operator|->
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
name|strstr
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|"literal"
argument_list|)
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|internal_reloc_compare
parameter_list|(
name|ap
parameter_list|,
name|bp
parameter_list|)
specifier|const
name|PTR
name|ap
decl_stmt|;
specifier|const
name|PTR
name|bp
decl_stmt|;
block|{
specifier|const
name|Elf_Internal_Rela
modifier|*
name|a
init|=
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
name|ap
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|b
init|=
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
name|bp
decl_stmt|;
return|return
operator|(
name|a
operator|->
name|r_offset
operator|-
name|b
operator|->
name|r_offset
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|xtensa_get_property_section_name
parameter_list|(
name|sec
parameter_list|,
name|base_name
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|char
modifier|*
name|base_name
decl_stmt|;
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".gnu.linkonce."
argument_list|,
name|linkonce_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|prop_sec_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
name|char
name|linkonce_kind
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|base_name
argument_list|,
name|XTENSA_INSN_SEC_NAME
argument_list|)
operator|==
literal|0
condition|)
name|linkonce_kind
operator|=
literal|'x'
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|base_name
argument_list|,
name|XTENSA_LIT_SEC_NAME
argument_list|)
operator|==
literal|0
condition|)
name|linkonce_kind
operator|=
literal|'p'
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|prop_sec_name
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|strlen
argument_list|(
name|sec
operator|->
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|prop_sec_name
argument_list|,
literal|".gnu.linkonce."
argument_list|,
name|linkonce_len
argument_list|)
expr_stmt|;
name|prop_sec_name
index|[
name|linkonce_len
index|]
operator|=
name|linkonce_kind
expr_stmt|;
name|prop_sec_name
index|[
name|linkonce_len
operator|+
literal|1
index|]
operator|=
literal|'.'
expr_stmt|;
name|suffix
operator|=
name|sec
operator|->
name|name
operator|+
name|linkonce_len
expr_stmt|;
while|while
condition|(
operator|*
name|suffix
condition|)
block|{
name|suffix
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|suffix
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
break|break;
block|}
name|strcpy
argument_list|(
name|prop_sec_name
operator|+
name|linkonce_len
operator|+
literal|2
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
return|return
name|prop_sec_name
return|;
block|}
return|return
name|strdup
argument_list|(
name|base_name
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Other functions called directly by the linker.  */
end_comment

begin_function
name|bfd_boolean
name|xtensa_callback_required_dependence
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|link_info
parameter_list|,
name|callback
parameter_list|,
name|closure
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|deps_callback_t
name|callback
decl_stmt|;
name|PTR
name|closure
decl_stmt|;
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|bfd_boolean
name|ok
init|=
name|TRUE
decl_stmt|;
comment|/* ".plt*" sections have no explicit relocations but they contain L32R      instructions that reference the corresponding ".got.plt*" sections.  */
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".plt"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|asection
modifier|*
name|sgotplt
decl_stmt|;
comment|/* Find the corresponding ".got.plt*" section.  */
if|if
condition|(
name|sec
operator|->
name|name
index|[
literal|4
index|]
operator|==
literal|'\0'
condition|)
name|sgotplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|got_name
index|[
literal|14
index|]
decl_stmt|;
name|int
name|chunk
init|=
literal|0
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|->
name|name
index|[
literal|4
index|]
operator|==
literal|'.'
argument_list|)
expr_stmt|;
name|chunk
operator|=
name|strtol
argument_list|(
operator|&
name|sec
operator|->
name|name
index|[
literal|5
index|]
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|got_name
argument_list|,
literal|".got.plt.%u"
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|sgotplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|got_name
argument_list|)
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|sgotplt
argument_list|)
expr_stmt|;
comment|/* Assume worst-case offsets: L32R at the very end of the ".plt" 	 section referencing a literal at the very beginning of 	 ".got.plt".  This is very close to the real dependence, anyway.  */
call|(
modifier|*
name|callback
call|)
argument_list|(
name|sec
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|,
name|sgotplt
argument_list|,
literal|0
argument_list|,
name|closure
argument_list|)
expr_stmt|;
block|}
name|internal_relocs
operator|=
name|retrieve_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
operator|||
name|sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|ok
return|;
comment|/* Cache the contents for the duration of this scan.  */
name|contents
operator|=
name|retrieve_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
operator|&&
name|sec
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
name|ok
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|xtensa_default_isa
operator|==
name|NULL
condition|)
name|xtensa_isa_init
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|irel
init|=
operator|&
name|internal_relocs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|is_l32r_relocation
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|,
name|irel
argument_list|)
condition|)
block|{
name|r_reloc
name|l32r_rel
decl_stmt|;
name|asection
modifier|*
name|target_sec
decl_stmt|;
name|bfd_vma
name|target_offset
decl_stmt|;
name|r_reloc_init
argument_list|(
operator|&
name|l32r_rel
argument_list|,
name|abfd
argument_list|,
name|irel
argument_list|)
expr_stmt|;
name|target_sec
operator|=
name|NULL
expr_stmt|;
name|target_offset
operator|=
literal|0
expr_stmt|;
comment|/* L32Rs must be local to the input file.  */
if|if
condition|(
name|r_reloc_is_defined
argument_list|(
operator|&
name|l32r_rel
argument_list|)
condition|)
block|{
name|target_sec
operator|=
name|r_reloc_get_section
argument_list|(
operator|&
name|l32r_rel
argument_list|)
expr_stmt|;
name|target_offset
operator|=
name|r_reloc_get_target_offset
argument_list|(
operator|&
name|l32r_rel
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|callback
call|)
argument_list|(
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
argument_list|,
name|target_sec
argument_list|,
name|target_offset
argument_list|,
name|closure
argument_list|)
expr_stmt|;
block|}
block|}
name|error_return
label|:
name|release_internal_relocs
argument_list|(
name|sec
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
name|release_contents
argument_list|(
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/* The default literal sections should always be marked as "code" (i.e.,    SHF_EXECINSTR).  This is particularly important for the Linux kernel    module loader so that the literals are not placed after the text.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bfd_elf_special_section
specifier|const
name|elf_xtensa_special_sections
index|[]
init|=
block|{
block|{
literal|".literal"
block|,
literal|8
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_EXECINSTR
block|}
block|,
block|{
literal|".init.literal"
block|,
literal|13
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_EXECINSTR
block|}
block|,
block|{
literal|".fini.literal"
block|,
literal|13
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_EXECINSTR
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|ELF_ARCH
end_ifndef

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_xtensa_le_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-xtensa-le"
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_xtensa_be_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-xtensa-be"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_xtensa
end_define

begin_comment
comment|/* The new EM_XTENSA value will be recognized beginning in the Xtensa T1040    release. However, we still have to generate files with the EM_XTENSA_OLD    value so that pre-T1040 tools can read the files.  As soon as we stop    caring about pre-T1040 tools, the following two values should be    swapped. At the same time, any other code that uses EM_XTENSA_OLD    (e.g., prep_headers() in elf.c) should be changed to use EM_XTENSA.  */
end_comment

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_XTENSA_OLD
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT1
value|EM_XTENSA
end_define

begin_if
if|#
directive|if
name|XCHAL_HAVE_MMU
end_if

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|(1<< XCHAL_MMU_MIN_PTE_PAGE_SIZE)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !XCHAL_HAVE_MMU */
end_comment

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !XCHAL_HAVE_MMU */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ELF_ARCH */
end_comment

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_can_refcount
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_readonly
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|4
end_define

begin_define
define|#
directive|define
name|elf_backend_want_dynbss
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_want_got_plt
value|1
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|elf_xtensa_info_to_howto_rela
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_merge_private_bfd_data
value|elf_xtensa_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_new_section_hook
value|elf_xtensa_new_section_hook
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_print_private_bfd_data
value|elf_xtensa_print_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_relax_section
value|elf_xtensa_relax_section
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|elf_xtensa_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_set_private_flags
value|elf_xtensa_set_private_flags
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
value|elf_xtensa_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|elf_xtensa_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
value|elf_xtensa_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_discard_info
value|elf_xtensa_discard_info
end_define

begin_define
define|#
directive|define
name|elf_backend_ignore_discarded_relocs
value|elf_xtensa_ignore_discarded_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
value|elf_xtensa_final_write_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
value|elf_xtensa_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
value|elf_xtensa_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|elf_xtensa_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|elf_xtensa_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_prstatus
value|elf_xtensa_grok_prstatus
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_psinfo
value|elf_xtensa_grok_psinfo
end_define

begin_define
define|#
directive|define
name|elf_backend_hide_symbol
value|elf_xtensa_hide_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_modify_segment_map
value|elf_xtensa_modify_segment_map
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|elf_xtensa_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_reloc_type_class
value|elf_xtensa_reloc_type_class
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|elf_xtensa_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
value|elf_xtensa_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_special_sections
value|elf_xtensa_special_sections
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

