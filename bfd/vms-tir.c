begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* vms-tir.c -- BFD back-end for VAX (openVMS/VAX) and    EVAX (openVMS/Alpha) files.    Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004, 2005, 2007    Free Software Foundation, Inc.     TIR record handling functions    ETIR record handling functions     go and read the openVMS linker manual (esp. appendix B)    if you don't know what's going on here :-)     Written by Klaus K"ampf (kkaempf@rmi.de)     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* The following type abbreviations are used:  	cs	counted string (ascii string with length byte) 	by	byte (1 byte) 	sh	short (2 byte, 16 bit) 	lw	longword (4 byte, 32 bit) 	qw	quadword (8 byte, 64 bit) 	da	data stream  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"vms.h"
end_include

begin_escape
end_escape

begin_function
specifier|static
name|int
name|check_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|bfd_size_type
name|offset
decl_stmt|;
name|offset
operator|=
name|PRIV
argument_list|(
name|image_ptr
argument_list|)
operator|-
name|PRIV
argument_list|(
name|image_section
argument_list|)
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|offset
operator|+
name|size
operator|>
name|PRIV
argument_list|(
name|image_section
argument_list|)
operator|->
name|size
condition|)
block|{
name|PRIV
argument_list|(
name|image_section
argument_list|)
operator|->
name|contents
operator|=
name|bfd_realloc
argument_list|(
name|PRIV
argument_list|(
name|image_section
argument_list|)
operator|->
name|contents
argument_list|,
name|offset
operator|+
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|PRIV
argument_list|(
name|image_section
argument_list|)
operator|->
name|contents
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"No Mem !"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|PRIV
argument_list|(
name|image_section
argument_list|)
operator|->
name|size
operator|=
name|offset
operator|+
name|size
expr_stmt|;
name|PRIV
argument_list|(
name|image_ptr
argument_list|)
operator|=
name|PRIV
argument_list|(
name|image_section
argument_list|)
operator|->
name|contents
operator|+
name|offset
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Routines to fill sections contents during tir/etir read.  */
end_comment

begin_comment
comment|/* Initialize image buffer pointer to be filled.  */
end_comment

begin_function
specifier|static
name|void
name|image_set_ptr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|psect
parameter_list|,
name|uquad
name|offset
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|4
argument_list|,
literal|"image_set_ptr (%d=%s, %d)\n"
argument_list|,
name|psect
argument_list|,
name|PRIV
argument_list|(
name|sections
argument_list|)
index|[
name|psect
index|]
operator|->
name|name
argument_list|,
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PRIV
argument_list|(
name|image_ptr
argument_list|)
operator|=
name|PRIV
argument_list|(
name|sections
argument_list|)
index|[
name|psect
index|]
operator|->
name|contents
operator|+
name|offset
expr_stmt|;
name|PRIV
argument_list|(
name|image_section
argument_list|)
operator|=
name|PRIV
argument_list|(
name|sections
argument_list|)
index|[
name|psect
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Increment image buffer pointer by offset.  */
end_comment

begin_function
specifier|static
name|void
name|image_inc_ptr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|uquad
name|offset
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|4
argument_list|,
literal|"image_inc_ptr (%d)\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PRIV
argument_list|(
name|image_ptr
argument_list|)
operator|+=
name|offset
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump multiple bytes to section image.  */
end_comment

begin_function
specifier|static
name|void
name|image_dump
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|offset
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|8
argument_list|,
literal|"image_dump from (%p, %d) to (%p)\n"
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|,
name|PRIV
argument_list|(
name|image_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|_bfd_hexdump
argument_list|(
literal|9
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|PRIV
argument_list|(
name|is_vax
argument_list|)
operator|&&
name|check_section
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
condition|)
return|return;
while|while
condition|(
name|size
operator|--
operator|>
literal|0
condition|)
operator|*
name|PRIV
argument_list|(
name|image_ptr
argument_list|)
operator|++
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write byte to section image.  */
end_comment

begin_function
specifier|static
name|void
name|image_write_b
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|int
name|value
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|6
argument_list|,
literal|"image_write_b (%02x)\n"
argument_list|,
operator|(
name|int
operator|)
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|PRIV
argument_list|(
name|is_vax
argument_list|)
operator|&&
name|check_section
argument_list|(
name|abfd
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
operator|*
name|PRIV
argument_list|(
name|image_ptr
argument_list|)
operator|++
operator|=
operator|(
name|value
operator|&
literal|0xff
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write 2-byte word to image.  */
end_comment

begin_function
specifier|static
name|void
name|image_write_w
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|int
name|value
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|6
argument_list|,
literal|"image_write_w (%04x)\n"
argument_list|,
operator|(
name|int
operator|)
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|PRIV
argument_list|(
name|is_vax
argument_list|)
operator|&&
name|check_section
argument_list|(
name|abfd
argument_list|,
literal|2
argument_list|)
condition|)
return|return;
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
name|PRIV
argument_list|(
name|image_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|PRIV
argument_list|(
name|image_ptr
argument_list|)
operator|+=
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write 4-byte long to image.  */
end_comment

begin_function
specifier|static
name|void
name|image_write_l
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|long
name|value
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|6
argument_list|,
literal|"image_write_l (%08lx)\n"
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|PRIV
argument_list|(
name|is_vax
argument_list|)
operator|&&
name|check_section
argument_list|(
name|abfd
argument_list|,
literal|4
argument_list|)
condition|)
return|return;
name|bfd_putl32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
name|PRIV
argument_list|(
name|image_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|PRIV
argument_list|(
name|image_ptr
argument_list|)
operator|+=
literal|4
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write 8-byte quad to image.  */
end_comment

begin_function
specifier|static
name|void
name|image_write_q
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|uquad
name|value
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|6
argument_list|,
literal|"image_write_q (%016lx)\n"
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|PRIV
argument_list|(
name|is_vax
argument_list|)
operator|&&
name|check_section
argument_list|(
name|abfd
argument_list|,
literal|8
argument_list|)
condition|)
return|return;
name|bfd_putl64
argument_list|(
name|value
argument_list|,
name|PRIV
argument_list|(
name|image_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|PRIV
argument_list|(
name|image_ptr
argument_list|)
operator|+=
literal|8
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cmd_name
parameter_list|(
name|int
name|cmd
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|ETIR_S_C_STA_GBL
case|:
return|return
literal|"ETIR_S_C_STA_GBL"
return|;
case|case
name|ETIR_S_C_STA_PQ
case|:
return|return
literal|"ETIR_S_C_STA_PQ"
return|;
case|case
name|ETIR_S_C_STA_LI
case|:
return|return
literal|"ETIR_S_C_STA_LI"
return|;
case|case
name|ETIR_S_C_STA_MOD
case|:
return|return
literal|"ETIR_S_C_STA_MOD"
return|;
case|case
name|ETIR_S_C_STA_CKARG
case|:
return|return
literal|"ETIR_S_C_STA_CKARG"
return|;
case|case
name|ETIR_S_C_STO_B
case|:
return|return
literal|"ETIR_S_C_STO_B"
return|;
case|case
name|ETIR_S_C_STO_W
case|:
return|return
literal|"ETIR_S_C_STO_W"
return|;
case|case
name|ETIR_S_C_STO_GBL
case|:
return|return
literal|"ETIR_S_C_STO_GBL"
return|;
case|case
name|ETIR_S_C_STO_CA
case|:
return|return
literal|"ETIR_S_C_STO_CA"
return|;
case|case
name|ETIR_S_C_STO_RB
case|:
return|return
literal|"ETIR_S_C_STO_RB"
return|;
case|case
name|ETIR_S_C_STO_AB
case|:
return|return
literal|"ETIR_S_C_STO_AB"
return|;
case|case
name|ETIR_S_C_STO_GBL_LW
case|:
return|return
literal|"ETIR_S_C_STO_GBL_LW"
return|;
case|case
name|ETIR_S_C_STO_LP_PSB
case|:
return|return
literal|"ETIR_S_C_STO_LP_PSB"
return|;
case|case
name|ETIR_S_C_STO_HINT_GBL
case|:
return|return
literal|"ETIR_S_C_STO_HINT_GBL"
return|;
case|case
name|ETIR_S_C_STO_HINT_PS
case|:
return|return
literal|"ETIR_S_C_STO_HINT_PS"
return|;
case|case
name|ETIR_S_C_OPR_INSV
case|:
return|return
literal|"ETIR_S_C_OPR_INSV"
return|;
case|case
name|ETIR_S_C_OPR_USH
case|:
return|return
literal|"ETIR_S_C_OPR_USH"
return|;
case|case
name|ETIR_S_C_OPR_ROT
case|:
return|return
literal|"ETIR_S_C_OPR_ROT"
return|;
case|case
name|ETIR_S_C_OPR_REDEF
case|:
return|return
literal|"ETIR_S_C_OPR_REDEF"
return|;
case|case
name|ETIR_S_C_OPR_DFLIT
case|:
return|return
literal|"ETIR_S_C_OPR_DFLIT"
return|;
case|case
name|ETIR_S_C_STC_LP
case|:
return|return
literal|"ETIR_S_C_STC_LP"
return|;
case|case
name|ETIR_S_C_STC_GBL
case|:
return|return
literal|"ETIR_S_C_STC_GBL"
return|;
case|case
name|ETIR_S_C_STC_GCA
case|:
return|return
literal|"ETIR_S_C_STC_GCA"
return|;
case|case
name|ETIR_S_C_STC_PS
case|:
return|return
literal|"ETIR_S_C_STC_PS"
return|;
case|case
name|ETIR_S_C_STC_NBH_PS
case|:
return|return
literal|"ETIR_S_C_STC_NBH_PS"
return|;
case|case
name|ETIR_S_C_STC_NOP_GBL
case|:
return|return
literal|"ETIR_S_C_STC_NOP_GBL"
return|;
case|case
name|ETIR_S_C_STC_NOP_PS
case|:
return|return
literal|"ETIR_S_C_STC_NOP_PS"
return|;
case|case
name|ETIR_S_C_STC_BSR_GBL
case|:
return|return
literal|"ETIR_S_C_STC_BSR_GBL"
return|;
case|case
name|ETIR_S_C_STC_BSR_PS
case|:
return|return
literal|"ETIR_S_C_STC_BSR_PS"
return|;
case|case
name|ETIR_S_C_STC_LDA_GBL
case|:
return|return
literal|"ETIR_S_C_STC_LDA_GBL"
return|;
case|case
name|ETIR_S_C_STC_LDA_PS
case|:
return|return
literal|"ETIR_S_C_STC_LDA_PS"
return|;
case|case
name|ETIR_S_C_STC_BOH_GBL
case|:
return|return
literal|"ETIR_S_C_STC_BOH_GBL"
return|;
case|case
name|ETIR_S_C_STC_BOH_PS
case|:
return|return
literal|"ETIR_S_C_STC_BOH_PS"
return|;
case|case
name|ETIR_S_C_STC_NBH_GBL
case|:
return|return
literal|"ETIR_S_C_STC_NBH_GBL"
return|;
default|default:
comment|/* These names have not yet been added to this switch statement.  */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|HIGHBIT
parameter_list|(
name|op
parameter_list|)
value|((op& 0x80000000L) == 0x80000000L)
end_define

begin_comment
comment|/* etir_sta     vms stack commands     handle sta_xxx commands in etir section    ptr points to data area in record     see table B-8 of the openVMS linker manual.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|etir_sta
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|cmd
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|5
argument_list|,
literal|"etir_sta %d/%x\n"
argument_list|,
name|cmd
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|_bfd_hexdump
argument_list|(
literal|8
argument_list|,
name|ptr
argument_list|,
literal|16
argument_list|,
operator|(
name|int
operator|)
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* stack global 	 arg: cs	symbol name  	 stack 32 bit value of symbol (high bits set to 0).  */
case|case
name|ETIR_S_C_STA_GBL
case|:
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|vms_symbol_entry
modifier|*
name|entry
decl_stmt|;
name|name
operator|=
name|_bfd_vms_save_counted_string
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|(
name|vms_symbol_entry
operator|*
operator|)
name|bfd_hash_lookup
argument_list|(
name|PRIV
argument_list|(
name|vms_symbol_table
argument_list|)
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|3
argument_list|,
literal|"%s: no symbol \"%s\"\n"
argument_list|,
name|cmd_name
argument_list|(
name|cmd
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
call|(
name|uquad
call|)
argument_list|(
name|entry
operator|->
name|symbol
operator|->
name|value
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* stack longword 	 arg: lw	value  	 stack 32 bit value, sign extend to 64 bit.  */
case|case
name|ETIR_S_C_STA_LW
case|:
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
name|bfd_getl32
argument_list|(
name|ptr
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
comment|/* stack global 	 arg: qw	value  	 stack 64 bit value of symbol.  */
case|case
name|ETIR_S_C_STA_QW
case|:
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
name|bfd_getl64
argument_list|(
name|ptr
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
comment|/* stack psect base plus quadword offset 	 arg: lw	section index 	 qw	signed quadword offset (low 32 bits)  	 stack qw argument and section index 	 (see ETIR_S_C_STO_OFF, ETIR_S_C_CTL_SETRB).  */
case|case
name|ETIR_S_C_STA_PQ
case|:
block|{
name|uquad
name|dummy
decl_stmt|;
name|unsigned
name|int
name|psect
decl_stmt|;
name|psect
operator|=
name|bfd_getl32
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|psect
operator|>=
name|PRIV
argument_list|(
name|section_count
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"bad section index in %s"
argument_list|)
argument_list|,
name|cmd_name
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|dummy
operator|=
name|bfd_getl64
argument_list|(
name|ptr
operator|+
literal|4
argument_list|)
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
name|dummy
argument_list|,
operator|(
name|int
operator|)
name|psect
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ETIR_S_C_STA_LI
case|:
case|case
name|ETIR_S_C_STA_MOD
case|:
case|case
name|ETIR_S_C_STA_CKARG
case|:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"unsupported STA cmd %s"
argument_list|)
argument_list|,
name|cmd_name
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
break|break;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"reserved STA cmd %d"
argument_list|)
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
break|break;
block|}
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|5
argument_list|,
literal|"etir_sta true\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* etir_sto     vms store commands     handle sto_xxx commands in etir section    ptr points to data area in record     see table B-9 of the openVMS linker manual.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|etir_sto
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|cmd
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|)
block|{
name|uquad
name|dummy
decl_stmt|;
name|int
name|psect
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|5
argument_list|,
literal|"etir_sto %d/%x\n"
argument_list|,
name|cmd
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|_bfd_hexdump
argument_list|(
literal|8
argument_list|,
name|ptr
argument_list|,
literal|16
argument_list|,
operator|(
name|int
operator|)
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* Store byte: pop stack, write byte 	 arg: -.  */
case|case
name|ETIR_S_C_STO_B
case|:
name|dummy
operator|=
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
operator|&
name|psect
argument_list|)
expr_stmt|;
comment|/* FIXME: check top bits.  */
name|image_write_b
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|dummy
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
comment|/* Store word: pop stack, write word 	 arg: -.  */
case|case
name|ETIR_S_C_STO_W
case|:
name|dummy
operator|=
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
operator|&
name|psect
argument_list|)
expr_stmt|;
comment|/* FIXME: check top bits */
name|image_write_w
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|dummy
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
break|break;
comment|/* Store longword: pop stack, write longword 	 arg: -.  */
case|case
name|ETIR_S_C_STO_LW
case|:
name|dummy
operator|=
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
operator|&
name|psect
argument_list|)
expr_stmt|;
name|dummy
operator|+=
operator|(
name|PRIV
argument_list|(
name|sections
argument_list|)
index|[
name|psect
index|]
operator|)
operator|->
name|vma
expr_stmt|;
comment|/* FIXME: check top bits.  */
name|image_write_l
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|dummy
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
break|break;
comment|/* Store quadword: pop stack, write quadword 	 arg: -.  */
case|case
name|ETIR_S_C_STO_QW
case|:
name|dummy
operator|=
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
operator|&
name|psect
argument_list|)
expr_stmt|;
name|dummy
operator|+=
operator|(
name|PRIV
argument_list|(
name|sections
argument_list|)
index|[
name|psect
index|]
operator|)
operator|->
name|vma
expr_stmt|;
comment|/* FIXME: check top bits.  */
name|image_write_q
argument_list|(
name|abfd
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
break|break;
comment|/* Store immediate repeated: pop stack for repeat count 	 arg: lw	byte count 	 da	data.  */
case|case
name|ETIR_S_C_STO_IMMR
case|:
block|{
name|int
name|size
decl_stmt|;
name|size
operator|=
name|bfd_getl32
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|dummy
operator|=
operator|(
name|unsigned
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|dummy
operator|--
operator|>
literal|0
condition|)
name|image_dump
argument_list|(
name|abfd
argument_list|,
name|ptr
operator|+
literal|4
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Store global: write symbol value 	 arg: cs	global symbol name.  */
case|case
name|ETIR_S_C_STO_GBL
case|:
block|{
name|vms_symbol_entry
modifier|*
name|entry
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|_bfd_vms_save_counted_string
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|(
name|vms_symbol_entry
operator|*
operator|)
name|bfd_hash_lookup
argument_list|(
name|PRIV
argument_list|(
name|vms_symbol_table
argument_list|)
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: no symbol \"%s\""
argument_list|)
argument_list|,
name|cmd_name
argument_list|(
name|cmd
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
comment|/* FIXME, reloc.  */
name|image_write_q
argument_list|(
name|abfd
argument_list|,
call|(
name|uquad
call|)
argument_list|(
name|entry
operator|->
name|symbol
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Store code address: write address of entry point 	 arg: cs	global symbol name (procedure).  */
case|case
name|ETIR_S_C_STO_CA
case|:
block|{
name|vms_symbol_entry
modifier|*
name|entry
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|_bfd_vms_save_counted_string
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|(
name|vms_symbol_entry
operator|*
operator|)
name|bfd_hash_lookup
argument_list|(
name|PRIV
argument_list|(
name|vms_symbol_table
argument_list|)
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: no symbol \"%s\""
argument_list|)
argument_list|,
name|cmd_name
argument_list|(
name|cmd
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
comment|/* FIXME, reloc.  */
name|image_write_q
argument_list|(
name|abfd
argument_list|,
call|(
name|uquad
call|)
argument_list|(
name|entry
operator|->
name|symbol
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Store offset to psect: pop stack, add low 32 bits to base of psect 	 arg: none.  */
case|case
name|ETIR_S_C_STO_OFF
case|:
block|{
name|uquad
name|q
decl_stmt|;
name|int
name|psect1
decl_stmt|;
name|q
operator|=
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
operator|&
name|psect1
argument_list|)
expr_stmt|;
name|q
operator|+=
operator|(
name|PRIV
argument_list|(
name|sections
argument_list|)
index|[
name|psect1
index|]
operator|)
operator|->
name|vma
expr_stmt|;
name|image_write_q
argument_list|(
name|abfd
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Store immediate 	 arg: lw	count of bytes 	      da	data.  */
case|case
name|ETIR_S_C_STO_IMM
case|:
block|{
name|int
name|size
decl_stmt|;
name|size
operator|=
name|bfd_getl32
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|image_dump
argument_list|(
name|abfd
argument_list|,
name|ptr
operator|+
literal|4
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* This code is 'reserved to digital' according to the openVMS 	 linker manual, however it is generated by the DEC C compiler 	 and defined in the include file. 	 FIXME, since the following is just a guess 	 store global longword: store 32bit value of symbol 	 arg: cs	symbol name.  */
case|case
name|ETIR_S_C_STO_GBL_LW
case|:
block|{
name|vms_symbol_entry
modifier|*
name|entry
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|_bfd_vms_save_counted_string
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|(
name|vms_symbol_entry
operator|*
operator|)
name|bfd_hash_lookup
argument_list|(
name|PRIV
argument_list|(
name|vms_symbol_table
argument_list|)
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|3
argument_list|,
literal|"%s: no symbol \"%s\"\n"
argument_list|,
name|cmd_name
argument_list|(
name|cmd
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|image_write_l
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|long
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME, reloc */
block|}
else|else
comment|/* FIXME, reloc.  */
name|image_write_l
argument_list|(
name|abfd
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|entry
operator|->
name|symbol
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ETIR_S_C_STO_RB
case|:
case|case
name|ETIR_S_C_STO_AB
case|:
case|case
name|ETIR_S_C_STO_LP_PSB
case|:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: not supported"
argument_list|)
argument_list|,
name|cmd_name
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETIR_S_C_STO_HINT_GBL
case|:
case|case
name|ETIR_S_C_STO_HINT_PS
case|:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: not implemented"
argument_list|)
argument_list|,
name|cmd_name
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"reserved STO cmd %d"
argument_list|)
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Stack operator commands    all 32 bit signed arithmetic    all word just like a stack calculator    arguments are popped from stack, results are pushed on stack     see table B-10 of the openVMS linker manual.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|etir_opr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|cmd
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|long
name|op1
decl_stmt|,
name|op2
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|5
argument_list|,
literal|"etir_opr %d/%x\n"
argument_list|,
name|cmd
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|_bfd_hexdump
argument_list|(
literal|8
argument_list|,
name|ptr
argument_list|,
literal|16
argument_list|,
operator|(
name|int
operator|)
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|ETIR_S_C_OPR_NOP
case|:
comment|/* No-op.  */
break|break;
case|case
name|ETIR_S_C_OPR_ADD
case|:
comment|/* Add.  */
name|op1
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op2
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
call|(
name|uquad
call|)
argument_list|(
name|op1
operator|+
name|op2
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETIR_S_C_OPR_SUB
case|:
comment|/* Subtract.  */
name|op1
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op2
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
call|(
name|uquad
call|)
argument_list|(
name|op2
operator|-
name|op1
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETIR_S_C_OPR_MUL
case|:
comment|/* Multiply.  */
name|op1
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op2
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
call|(
name|uquad
call|)
argument_list|(
name|op1
operator|*
name|op2
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETIR_S_C_OPR_DIV
case|:
comment|/* Divide.  */
name|op1
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op2
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|op2
operator|==
literal|0
condition|)
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
call|(
name|uquad
call|)
argument_list|(
name|op2
operator|/
name|op1
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETIR_S_C_OPR_AND
case|:
comment|/* Logical AND.  */
name|op1
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op2
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
call|(
name|uquad
call|)
argument_list|(
name|op1
operator|&
name|op2
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETIR_S_C_OPR_IOR
case|:
comment|/* Logical inclusive OR.  */
name|op1
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op2
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
call|(
name|uquad
call|)
argument_list|(
name|op1
operator||
name|op2
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETIR_S_C_OPR_EOR
case|:
comment|/* Logical exclusive OR.  */
name|op1
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op2
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
call|(
name|uquad
call|)
argument_list|(
name|op1
operator|^
name|op2
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETIR_S_C_OPR_NEG
case|:
comment|/* Negate.  */
name|op1
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
call|(
name|uquad
call|)
argument_list|(
operator|-
name|op1
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETIR_S_C_OPR_COM
case|:
comment|/* Complement.  */
name|op1
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
call|(
name|uquad
call|)
argument_list|(
name|op1
operator|^
operator|-
literal|1L
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETIR_S_C_OPR_ASH
case|:
comment|/* Arithmetic shift.  */
name|op1
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op2
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|op2
operator|<
literal|0
condition|)
comment|/* Shift right.  */
name|op1
operator|>>=
operator|-
name|op2
expr_stmt|;
else|else
comment|/* Shift left.  */
name|op1
operator|<<=
name|op2
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
name|op1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETIR_S_C_OPR_INSV
case|:
comment|/* Insert field.   */
operator|(
name|void
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
case|case
name|ETIR_S_C_OPR_USH
case|:
comment|/* Unsigned shift.   */
case|case
name|ETIR_S_C_OPR_ROT
case|:
comment|/* Rotate.  */
case|case
name|ETIR_S_C_OPR_REDEF
case|:
comment|/* Redefine symbol to current location.  */
case|case
name|ETIR_S_C_OPR_DFLIT
case|:
comment|/* Define a literal.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: not supported"
argument_list|)
argument_list|,
name|cmd_name
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETIR_S_C_OPR_SEL
case|:
comment|/* Select.  */
if|if
condition|(
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
operator|&
literal|0x01L
condition|)
operator|(
name|void
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|op1
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
name|op1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"reserved OPR cmd %d"
argument_list|)
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Control commands.     See table B-11 of the openVMS linker manual.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|etir_ctl
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|cmd
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|)
block|{
name|uquad
name|dummy
decl_stmt|;
name|int
name|psect
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|5
argument_list|,
literal|"etir_ctl %d/%x\n"
argument_list|,
name|cmd
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|_bfd_hexdump
argument_list|(
literal|8
argument_list|,
name|ptr
argument_list|,
literal|16
argument_list|,
operator|(
name|int
operator|)
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* Det relocation base: pop stack, set image location counter 	 arg: none.  */
case|case
name|ETIR_S_C_CTL_SETRB
case|:
name|dummy
operator|=
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
operator|&
name|psect
argument_list|)
expr_stmt|;
name|image_set_ptr
argument_list|(
name|abfd
argument_list|,
name|psect
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
break|break;
comment|/* Augment relocation base: increment image location counter by offset 	 arg: lw	offset value.  */
case|case
name|ETIR_S_C_CTL_AUGRB
case|:
name|dummy
operator|=
name|bfd_getl32
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|image_inc_ptr
argument_list|(
name|abfd
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
break|break;
comment|/* Define location: pop index, save location counter under index 	 arg: none.  */
case|case
name|ETIR_S_C_CTL_DFLOC
case|:
name|dummy
operator|=
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* FIXME */
break|break;
comment|/* Set location: pop index, restore location counter from index 	 arg: none.  */
case|case
name|ETIR_S_C_CTL_STLOC
case|:
name|dummy
operator|=
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
operator|&
name|psect
argument_list|)
expr_stmt|;
comment|/* FIXME */
break|break;
comment|/* Stack defined location: pop index, push location counter from index 	 arg: none.  */
case|case
name|ETIR_S_C_CTL_STKDL
case|:
name|dummy
operator|=
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
operator|&
name|psect
argument_list|)
expr_stmt|;
comment|/* FIXME.  */
break|break;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"reserved CTL cmd %d"
argument_list|)
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Store conditional commands     See table B-12 and B-13 of the openVMS linker manual.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|etir_stc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|cmd
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|5
argument_list|,
literal|"etir_stc %d/%x\n"
argument_list|,
name|cmd
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|_bfd_hexdump
argument_list|(
literal|8
argument_list|,
name|ptr
argument_list|,
literal|16
argument_list|,
operator|(
name|int
operator|)
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* 200 Store-conditional Linkage Pair 	 arg: none.  */
case|case
name|ETIR_S_C_STC_LP
case|:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: not supported"
argument_list|)
argument_list|,
name|cmd_name
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* 201 Store-conditional Linkage Pair with Procedure Signature 	 arg:	lw	linkage index 		cs	procedure name 		by	signature length 		da	signature.  */
case|case
name|ETIR_S_C_STC_LP_PSB
case|:
name|image_inc_ptr
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
literal|16
argument_list|)
expr_stmt|;
comment|/* skip entry,procval */
break|break;
comment|/* 202 Store-conditional Address at global address 	 arg:	lw	linkage index 		cs	global name.  */
case|case
name|ETIR_S_C_STC_GBL
case|:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: not supported"
argument_list|)
argument_list|,
name|cmd_name
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* 203 Store-conditional Code Address at global address 	 arg:	lw	linkage index 		cs	procedure name.  */
case|case
name|ETIR_S_C_STC_GCA
case|:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: not supported"
argument_list|)
argument_list|,
name|cmd_name
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* 204 Store-conditional Address at psect + offset 	 arg:	lw	linkage index 		lw	psect index 		qw	offset.  */
case|case
name|ETIR_S_C_STC_PS
case|:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: not supported"
argument_list|)
argument_list|,
name|cmd_name
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* 205 Store-conditional NOP at address of global 	 arg: none.  */
case|case
name|ETIR_S_C_STC_NOP_GBL
case|:
comment|/* 206 Store-conditional NOP at pect + offset 	 arg: none.  */
case|case
name|ETIR_S_C_STC_NOP_PS
case|:
comment|/* 207 Store-conditional BSR at global address 	 arg: none.  */
case|case
name|ETIR_S_C_STC_BSR_GBL
case|:
comment|/* 208 Store-conditional BSR at pect + offset 	 arg: none.  */
case|case
name|ETIR_S_C_STC_BSR_PS
case|:
comment|/* 209 Store-conditional LDA at global address 	 arg: none.  */
case|case
name|ETIR_S_C_STC_LDA_GBL
case|:
comment|/* 210 Store-conditional LDA at psect + offset 	 arg: none.  */
case|case
name|ETIR_S_C_STC_LDA_PS
case|:
comment|/* 211 Store-conditional BSR or Hint at global address 	 arg: none.  */
case|case
name|ETIR_S_C_STC_BOH_GBL
case|:
comment|/* 212 Store-conditional BSR or Hint at pect + offset 	 arg: none.  */
case|case
name|ETIR_S_C_STC_BOH_PS
case|:
comment|/* 213 Store-conditional NOP,BSR or HINT at global address 	 arg: none.  */
case|case
name|ETIR_S_C_STC_NBH_GBL
case|:
comment|/* 214 Store-conditional NOP,BSR or HINT at psect + offset 	 arg: none.  */
case|case
name|ETIR_S_C_STC_NBH_PS
case|:
comment|/* FIXME */
break|break;
default|default:
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|3
argument_list|,
literal|"reserved STC cmd %d"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|new_section
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|asection
modifier|*
name|section
decl_stmt|;
name|char
name|sname
index|[
literal|16
index|]
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|5
argument_list|,
literal|"new_section %d\n"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sprintf
argument_list|(
name|sname
argument_list|,
name|SECTION_NAME_TEMPLATE
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|strlen
argument_list|(
name|sname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|sname
argument_list|)
expr_stmt|;
name|section
operator|=
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|6
argument_list|,
literal|"bfd_make_section (%s) failed"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
name|section
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|section
operator|->
name|vma
operator|=
literal|0
expr_stmt|;
name|section
operator|->
name|contents
operator|=
literal|0
expr_stmt|;
name|section
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|section
operator|->
name|index
operator|=
name|idx
expr_stmt|;
return|return
name|section
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|)
block|{
name|bfd_size_type
name|amt
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|4
argument_list|,
literal|"alloc_section %d\n"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|amt
operator|=
name|idx
operator|+
literal|1
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|PRIV
argument_list|(
name|sections
argument_list|)
operator|=
name|bfd_realloc
argument_list|(
name|PRIV
argument_list|(
name|sections
argument_list|)
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|PRIV
argument_list|(
name|sections
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
name|PRIV
argument_list|(
name|section_count
argument_list|)
operator|<=
name|idx
condition|)
block|{
name|PRIV
argument_list|(
name|sections
argument_list|)
index|[
name|PRIV
argument_list|(
name|section_count
argument_list|)
index|]
operator|=
name|new_section
argument_list|(
name|abfd
argument_list|,
operator|(
name|int
operator|)
name|PRIV
argument_list|(
name|section_count
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PRIV
argument_list|(
name|sections
argument_list|)
index|[
name|PRIV
argument_list|(
name|section_count
argument_list|)
index|]
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|PRIV
argument_list|(
name|section_count
argument_list|)
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* tir_sta     vax stack commands     Handle sta_xxx commands in tir section    ptr points to data area in record     See table 7-3 of the VAX/VMS linker manual.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|tir_sta
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|)
block|{
name|int
name|cmd
init|=
operator|*
name|ptr
operator|++
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|5
argument_list|,
literal|"tir_sta %d\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* stack */
case|case
name|TIR_S_C_STA_GBL
case|:
comment|/* stack global 	 arg: cs	symbol name  	 stack 32 bit value of symbol (high bits set to 0).  */
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|vms_symbol_entry
modifier|*
name|entry
decl_stmt|;
name|name
operator|=
name|_bfd_vms_save_counted_string
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|entry
operator|=
name|_bfd_vms_enter_symbol
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
call|(
name|uquad
call|)
argument_list|(
name|entry
operator|->
name|symbol
operator|->
name|value
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ptr
operator|+=
operator|*
name|ptr
operator|+
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|TIR_S_C_STA_SB
case|:
comment|/* stack signed byte 	 arg: by	value  	 stack byte value, sign extend to 32 bit.  */
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
operator|*
name|ptr
operator|++
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_STA_SW
case|:
comment|/* stack signed short word 	 arg: sh	value  	 stack 16 bit value, sign extend to 32 bit.  */
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
name|bfd_getl16
argument_list|(
name|ptr
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|TIR_S_C_STA_LW
case|:
comment|/* stack signed longword 	 arg: lw	value  	 stack 32 bit value.  */
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
name|bfd_getl32
argument_list|(
name|ptr
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|TIR_S_C_STA_PB
case|:
case|case
name|TIR_S_C_STA_WPB
case|:
comment|/* stack psect base plus byte offset (word index) 	 arg: by	section index 		(sh	section index) 		by	signed byte offset.  */
block|{
name|unsigned
name|long
name|dummy
decl_stmt|;
name|unsigned
name|int
name|psect
decl_stmt|;
if|if
condition|(
name|cmd
operator|==
name|TIR_S_C_STA_PB
condition|)
name|psect
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
else|else
block|{
name|psect
operator|=
name|bfd_getl16
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|psect
operator|>=
name|PRIV
argument_list|(
name|section_count
argument_list|)
condition|)
name|alloc_section
argument_list|(
name|abfd
argument_list|,
name|psect
argument_list|)
expr_stmt|;
name|dummy
operator|=
operator|(
name|long
operator|)
operator|*
name|ptr
operator|++
expr_stmt|;
name|dummy
operator|+=
operator|(
name|PRIV
argument_list|(
name|sections
argument_list|)
index|[
name|psect
index|]
operator|)
operator|->
name|vma
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
name|dummy
argument_list|,
operator|(
name|int
operator|)
name|psect
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TIR_S_C_STA_PW
case|:
case|case
name|TIR_S_C_STA_WPW
case|:
comment|/* stack psect base plus word offset (word index) 	 arg: by	section index 		(sh	section index) 		sh	signed short offset.  */
block|{
name|unsigned
name|long
name|dummy
decl_stmt|;
name|unsigned
name|int
name|psect
decl_stmt|;
if|if
condition|(
name|cmd
operator|==
name|TIR_S_C_STA_PW
condition|)
name|psect
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
else|else
block|{
name|psect
operator|=
name|bfd_getl16
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|psect
operator|>=
name|PRIV
argument_list|(
name|section_count
argument_list|)
condition|)
name|alloc_section
argument_list|(
name|abfd
argument_list|,
name|psect
argument_list|)
expr_stmt|;
name|dummy
operator|=
name|bfd_getl16
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|2
expr_stmt|;
name|dummy
operator|+=
operator|(
name|PRIV
argument_list|(
name|sections
argument_list|)
index|[
name|psect
index|]
operator|)
operator|->
name|vma
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
name|dummy
argument_list|,
operator|(
name|int
operator|)
name|psect
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TIR_S_C_STA_PL
case|:
case|case
name|TIR_S_C_STA_WPL
case|:
comment|/* stack psect base plus long offset (word index) 	 arg: by	section index 		(sh	section index) 		lw	signed longword offset.	 */
block|{
name|unsigned
name|long
name|dummy
decl_stmt|;
name|unsigned
name|int
name|psect
decl_stmt|;
if|if
condition|(
name|cmd
operator|==
name|TIR_S_C_STA_PL
condition|)
name|psect
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
else|else
block|{
name|psect
operator|=
name|bfd_getl16
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|psect
operator|>=
name|PRIV
argument_list|(
name|section_count
argument_list|)
condition|)
name|alloc_section
argument_list|(
name|abfd
argument_list|,
name|psect
argument_list|)
expr_stmt|;
name|dummy
operator|=
name|bfd_getl32
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|4
expr_stmt|;
name|dummy
operator|+=
operator|(
name|PRIV
argument_list|(
name|sections
argument_list|)
index|[
name|psect
index|]
operator|)
operator|->
name|vma
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
name|dummy
argument_list|,
operator|(
name|int
operator|)
name|psect
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TIR_S_C_STA_UB
case|:
comment|/* stack unsigned byte 	 arg: by	value  	 stack byte value.  */
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
operator|*
name|ptr
operator|++
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_STA_UW
case|:
comment|/* stack unsigned short word 	 arg: sh	value  	 stack 16 bit value.  */
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
name|bfd_getl16
argument_list|(
name|ptr
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|TIR_S_C_STA_BFI
case|:
comment|/* stack byte from image 	 arg: none.  */
comment|/* FALLTHRU  */
case|case
name|TIR_S_C_STA_WFI
case|:
comment|/* stack byte from image 	 arg: none.  */
comment|/* FALLTHRU */
case|case
name|TIR_S_C_STA_LFI
case|:
comment|/* stack byte from image 	 arg: none.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"stack-from-image not implemented"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|TIR_S_C_STA_EPM
case|:
comment|/* stack entry point mask 	 arg: cs	symbol name  	 stack (unsigned) entry point mask of symbol 	 err if symbol is no entry point.  */
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|vms_symbol_entry
modifier|*
name|entry
decl_stmt|;
name|name
operator|=
name|_bfd_vms_save_counted_string
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|entry
operator|=
name|_bfd_vms_enter_symbol
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"stack-entry-mask not fully implemented"
argument_list|)
argument_list|)
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ptr
operator|+=
operator|*
name|ptr
operator|+
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|TIR_S_C_STA_CKARG
case|:
comment|/* compare procedure argument 	 arg: cs	symbol name 		by	argument index 		da	argument descriptor  	 compare argument descriptor with symbol argument (ARG$V_PASSMECH) 	 and stack TRUE (args match) or FALSE (args dont match) value.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"PASSMECH not fully implemented"
argument_list|)
argument_list|)
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_STA_LSY
case|:
comment|/* stack local symbol value 	 arg:	sh	environment index 		cs	symbol name.  */
block|{
name|int
name|envidx
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|vms_symbol_entry
modifier|*
name|entry
decl_stmt|;
name|envidx
operator|=
name|bfd_getl16
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|2
expr_stmt|;
name|name
operator|=
name|_bfd_vms_save_counted_string
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|entry
operator|=
name|_bfd_vms_enter_symbol
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"stack-local-symbol not fully implemented"
argument_list|)
argument_list|)
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ptr
operator|+=
operator|*
name|ptr
operator|+
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|TIR_S_C_STA_LIT
case|:
comment|/* stack literal 	 arg:	by	literal index  	 stack literal.  */
name|ptr
operator|++
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"stack-literal not fully implemented"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_STA_LEPM
case|:
comment|/* stack local symbol entry point mask 	 arg:	sh	environment index 		cs	symbol name  	 stack (unsigned) entry point mask of symbol 	 err if symbol is no entry point.  */
block|{
name|int
name|envidx
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|vms_symbol_entry
modifier|*
name|entry
decl_stmt|;
name|envidx
operator|=
name|bfd_getl16
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|2
expr_stmt|;
name|name
operator|=
name|_bfd_vms_save_counted_string
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|entry
operator|=
name|_bfd_vms_enter_symbol
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"stack-local-symbol-entry-point-mask not fully implemented"
argument_list|)
argument_list|)
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ptr
operator|+=
operator|*
name|ptr
operator|+
literal|1
expr_stmt|;
block|}
break|break;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"reserved STA cmd %d"
argument_list|)
argument_list|,
name|ptr
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
break|break;
block|}
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|tir_cmd_name
parameter_list|(
name|int
name|cmd
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIR_S_C_STO_RSB
case|:
return|return
literal|"TIR_S_C_STO_RSB"
return|;
case|case
name|TIR_S_C_STO_RSW
case|:
return|return
literal|"TIR_S_C_STO_RSW"
return|;
case|case
name|TIR_S_C_STO_RL
case|:
return|return
literal|"TIR_S_C_STO_RL"
return|;
case|case
name|TIR_S_C_STO_VPS
case|:
return|return
literal|"TIR_S_C_STO_VPS"
return|;
case|case
name|TIR_S_C_STO_USB
case|:
return|return
literal|"TIR_S_C_STO_USB"
return|;
case|case
name|TIR_S_C_STO_USW
case|:
return|return
literal|"TIR_S_C_STO_USW"
return|;
case|case
name|TIR_S_C_STO_RUB
case|:
return|return
literal|"TIR_S_C_STO_RUB"
return|;
case|case
name|TIR_S_C_STO_RUW
case|:
return|return
literal|"TIR_S_C_STO_RUW"
return|;
case|case
name|TIR_S_C_STO_PIRR
case|:
return|return
literal|"TIR_S_C_STO_PIRR"
return|;
case|case
name|TIR_S_C_OPR_INSV
case|:
return|return
literal|"TIR_S_C_OPR_INSV"
return|;
case|case
name|TIR_S_C_OPR_DFLIT
case|:
return|return
literal|"TIR_S_C_OPR_DFLIT"
return|;
case|case
name|TIR_S_C_OPR_REDEF
case|:
return|return
literal|"TIR_S_C_OPR_REDEF"
return|;
case|case
name|TIR_S_C_OPR_ROT
case|:
return|return
literal|"TIR_S_C_OPR_ROT"
return|;
case|case
name|TIR_S_C_OPR_USH
case|:
return|return
literal|"TIR_S_C_OPR_USH"
return|;
case|case
name|TIR_S_C_OPR_ASH
case|:
return|return
literal|"TIR_S_C_OPR_ASH"
return|;
case|case
name|TIR_S_C_CTL_DFLOC
case|:
return|return
literal|"TIR_S_C_CTL_DFLOC"
return|;
case|case
name|TIR_S_C_CTL_STLOC
case|:
return|return
literal|"TIR_S_C_CTL_STLOC"
return|;
case|case
name|TIR_S_C_CTL_STKDL
case|:
return|return
literal|"TIR_S_C_CTL_STKDL"
return|;
default|default:
comment|/* These strings have not been added yet.  */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* tir_sto     vax store commands     handle sto_xxx commands in tir section    ptr points to data area in record     See table 7-4 of the VAX/VMS linker manual.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|tir_sto
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|)
block|{
name|unsigned
name|long
name|dummy
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|psect
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|5
argument_list|,
literal|"tir_sto %d\n"
argument_list|,
operator|*
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
operator|*
name|ptr
operator|++
condition|)
block|{
case|case
name|TIR_S_C_STO_SB
case|:
comment|/* Store signed byte: pop stack, write byte 	 arg: none.  */
name|dummy
operator|=
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
operator|&
name|psect
argument_list|)
expr_stmt|;
name|image_write_b
argument_list|(
name|abfd
argument_list|,
name|dummy
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* FIXME: check top bits */
break|break;
case|case
name|TIR_S_C_STO_SW
case|:
comment|/* Store signed word: pop stack, write word 	 arg: none.  */
name|dummy
operator|=
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
operator|&
name|psect
argument_list|)
expr_stmt|;
name|image_write_w
argument_list|(
name|abfd
argument_list|,
name|dummy
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* FIXME: check top bits */
break|break;
case|case
name|TIR_S_C_STO_LW
case|:
comment|/* Store longword: pop stack, write longword 	 arg: none.  */
name|dummy
operator|=
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
operator|&
name|psect
argument_list|)
expr_stmt|;
name|image_write_l
argument_list|(
name|abfd
argument_list|,
name|dummy
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* FIXME: check top bits */
break|break;
case|case
name|TIR_S_C_STO_BD
case|:
comment|/* Store byte displaced: pop stack, sub lc+1, write byte 	 arg: none.  */
name|dummy
operator|=
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
operator|&
name|psect
argument_list|)
expr_stmt|;
name|dummy
operator|-=
operator|(
operator|(
name|PRIV
argument_list|(
name|sections
argument_list|)
index|[
name|psect
index|]
operator|)
operator|->
name|vma
operator|+
literal|1
operator|)
expr_stmt|;
name|image_write_b
argument_list|(
name|abfd
argument_list|,
name|dummy
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* FIXME: check top bits */
break|break;
case|case
name|TIR_S_C_STO_WD
case|:
comment|/* Store word displaced: pop stack, sub lc+2, write word 	 arg: none.  */
name|dummy
operator|=
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
operator|&
name|psect
argument_list|)
expr_stmt|;
name|dummy
operator|-=
operator|(
operator|(
name|PRIV
argument_list|(
name|sections
argument_list|)
index|[
name|psect
index|]
operator|)
operator|->
name|vma
operator|+
literal|2
operator|)
expr_stmt|;
name|image_write_w
argument_list|(
name|abfd
argument_list|,
name|dummy
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* FIXME: check top bits */
break|break;
case|case
name|TIR_S_C_STO_LD
case|:
comment|/* Store long displaced: pop stack, sub lc+4, write long 	 arg: none.  */
name|dummy
operator|=
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
operator|&
name|psect
argument_list|)
expr_stmt|;
name|dummy
operator|-=
operator|(
operator|(
name|PRIV
argument_list|(
name|sections
argument_list|)
index|[
name|psect
index|]
operator|)
operator|->
name|vma
operator|+
literal|4
operator|)
expr_stmt|;
name|image_write_l
argument_list|(
name|abfd
argument_list|,
name|dummy
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* FIXME: check top bits */
break|break;
case|case
name|TIR_S_C_STO_LI
case|:
comment|/* Store short literal: pop stack, write byte 	 arg: none.  */
name|dummy
operator|=
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
operator|&
name|psect
argument_list|)
expr_stmt|;
name|image_write_b
argument_list|(
name|abfd
argument_list|,
name|dummy
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* FIXME: check top bits */
break|break;
case|case
name|TIR_S_C_STO_PIDR
case|:
comment|/* Store position independent data reference: pop stack, write longword 	 arg: none. 	 FIXME: incomplete !  */
name|dummy
operator|=
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
operator|&
name|psect
argument_list|)
expr_stmt|;
name|image_write_l
argument_list|(
name|abfd
argument_list|,
name|dummy
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_STO_PICR
case|:
comment|/* Store position independent code reference: pop stack, write longword 	 arg: none. 	 FIXME: incomplete !  */
name|dummy
operator|=
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
operator|&
name|psect
argument_list|)
expr_stmt|;
name|image_write_b
argument_list|(
name|abfd
argument_list|,
literal|0x9f
argument_list|)
expr_stmt|;
name|image_write_l
argument_list|(
name|abfd
argument_list|,
name|dummy
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_STO_RIVB
case|:
comment|/* Store repeated immediate variable bytes 	 1-byte count n field followed by n bytes of data 	 pop stack, write n bytes<stack> times.  */
name|size
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
name|dummy
operator|=
operator|(
name|unsigned
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|dummy
operator|--
operator|>
literal|0L
condition|)
name|image_dump
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|size
expr_stmt|;
break|break;
case|case
name|TIR_S_C_STO_B
case|:
comment|/* Store byte from top longword.  */
name|dummy
operator|=
operator|(
name|unsigned
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|image_write_b
argument_list|(
name|abfd
argument_list|,
name|dummy
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_STO_W
case|:
comment|/* Store word from top longword.  */
name|dummy
operator|=
operator|(
name|unsigned
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|image_write_w
argument_list|(
name|abfd
argument_list|,
name|dummy
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_STO_RB
case|:
comment|/* Store repeated byte from top longword.  */
name|size
operator|=
operator|(
name|unsigned
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dummy
operator|=
operator|(
name|unsigned
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|--
operator|>
literal|0
condition|)
name|image_write_b
argument_list|(
name|abfd
argument_list|,
name|dummy
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_STO_RW
case|:
comment|/* Store repeated word from top longword.  */
name|size
operator|=
operator|(
name|unsigned
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dummy
operator|=
operator|(
name|unsigned
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|--
operator|>
literal|0
condition|)
name|image_write_w
argument_list|(
name|abfd
argument_list|,
name|dummy
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_STO_RSB
case|:
case|case
name|TIR_S_C_STO_RSW
case|:
case|case
name|TIR_S_C_STO_RL
case|:
case|case
name|TIR_S_C_STO_VPS
case|:
case|case
name|TIR_S_C_STO_USB
case|:
case|case
name|TIR_S_C_STO_USW
case|:
case|case
name|TIR_S_C_STO_RUB
case|:
case|case
name|TIR_S_C_STO_RUW
case|:
case|case
name|TIR_S_C_STO_PIRR
case|:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: not implemented"
argument_list|)
argument_list|,
name|tir_cmd_name
argument_list|(
name|ptr
index|[
operator|-
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"reserved STO cmd %d"
argument_list|)
argument_list|,
name|ptr
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Stack operator commands    All 32 bit signed arithmetic    All word just like a stack calculator    Arguments are popped from stack, results are pushed on stack     See table 7-5 of the VAX/VMS linker manual.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|tir_opr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|)
block|{
name|long
name|op1
decl_stmt|,
name|op2
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|5
argument_list|,
literal|"tir_opr %d\n"
argument_list|,
operator|*
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Operation.  */
switch|switch
condition|(
operator|*
name|ptr
operator|++
condition|)
block|{
case|case
name|TIR_S_C_OPR_NOP
case|:
comment|/* No-op.  */
break|break;
case|case
name|TIR_S_C_OPR_ADD
case|:
comment|/* Add.  */
name|op1
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op2
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
call|(
name|uquad
call|)
argument_list|(
name|op1
operator|+
name|op2
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_OPR_SUB
case|:
comment|/* Subtract.  */
name|op1
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op2
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
call|(
name|uquad
call|)
argument_list|(
name|op2
operator|-
name|op1
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_OPR_MUL
case|:
comment|/* Multiply.  */
name|op1
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op2
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
call|(
name|uquad
call|)
argument_list|(
name|op1
operator|*
name|op2
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_OPR_DIV
case|:
comment|/* Divide.  */
name|op1
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op2
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|op2
operator|==
literal|0
condition|)
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
call|(
name|uquad
call|)
argument_list|(
name|op2
operator|/
name|op1
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_OPR_AND
case|:
comment|/* Logical AND.  */
name|op1
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op2
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
call|(
name|uquad
call|)
argument_list|(
name|op1
operator|&
name|op2
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_OPR_IOR
case|:
comment|/* Logical inclusive OR.  */
name|op1
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op2
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
call|(
name|uquad
call|)
argument_list|(
name|op1
operator||
name|op2
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_OPR_EOR
case|:
comment|/* Logical exclusive OR.  */
name|op1
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op2
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
call|(
name|uquad
call|)
argument_list|(
name|op1
operator|^
name|op2
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_OPR_NEG
case|:
comment|/* Negate.  */
name|op1
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
call|(
name|uquad
call|)
argument_list|(
operator|-
name|op1
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_OPR_COM
case|:
comment|/* Complement.  */
name|op1
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
call|(
name|uquad
call|)
argument_list|(
name|op1
operator|^
operator|-
literal|1L
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_OPR_INSV
case|:
comment|/* Insert field.  */
operator|(
name|void
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: not fully implemented"
argument_list|)
argument_list|,
name|tir_cmd_name
argument_list|(
name|ptr
index|[
operator|-
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_OPR_ASH
case|:
comment|/* Arithmetic shift.  */
name|op1
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op2
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|HIGHBIT
argument_list|(
name|op1
argument_list|)
condition|)
comment|/* Shift right.  */
name|op2
operator|>>=
name|op1
expr_stmt|;
else|else
comment|/* Shift left.  */
name|op2
operator|<<=
name|op1
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
name|op2
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: not fully implemented"
argument_list|)
argument_list|,
name|tir_cmd_name
argument_list|(
name|ptr
index|[
operator|-
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_OPR_USH
case|:
comment|/* Unsigned shift.  */
name|op1
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op2
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|HIGHBIT
argument_list|(
name|op1
argument_list|)
condition|)
comment|/* Shift right.  */
name|op2
operator|>>=
name|op1
expr_stmt|;
else|else
comment|/* Shift left.  */
name|op2
operator|<<=
name|op1
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
name|op2
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: not fully implemented"
argument_list|)
argument_list|,
name|tir_cmd_name
argument_list|(
name|ptr
index|[
operator|-
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_OPR_ROT
case|:
comment|/* Rotate.  */
name|op1
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op2
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|HIGHBIT
argument_list|(
literal|0
argument_list|)
condition|)
comment|/* Shift right.  */
name|op2
operator|>>=
name|op1
expr_stmt|;
else|else
comment|/* Shift left.  */
name|op2
operator|<<=
name|op1
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
name|op2
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: not fully implemented"
argument_list|)
argument_list|,
name|tir_cmd_name
argument_list|(
name|ptr
index|[
operator|-
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_OPR_SEL
case|:
comment|/* Select.  */
if|if
condition|(
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
operator|&
literal|0x01L
condition|)
operator|(
name|void
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|op1
operator|=
operator|(
name|long
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_bfd_vms_push
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
name|op1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TIR_S_C_OPR_REDEF
case|:
comment|/* Redefine symbol to current location.  */
case|case
name|TIR_S_C_OPR_DFLIT
case|:
comment|/* Define a literal.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: not supported"
argument_list|)
argument_list|,
name|tir_cmd_name
argument_list|(
name|ptr
index|[
operator|-
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"reserved OPR cmd %d"
argument_list|)
argument_list|,
name|ptr
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Control commands     See table 7-6 of the VAX/VMS linker manual.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|tir_ctl
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|)
block|{
name|unsigned
name|long
name|dummy
decl_stmt|;
name|unsigned
name|int
name|psect
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|5
argument_list|,
literal|"tir_ctl %d\n"
argument_list|,
operator|*
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
operator|*
name|ptr
operator|++
condition|)
block|{
case|case
name|TIR_S_C_CTL_SETRB
case|:
comment|/* Set relocation base: pop stack, set image location counter 	 arg: none.  */
name|dummy
operator|=
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|psect
argument_list|)
expr_stmt|;
if|if
condition|(
name|psect
operator|>=
name|PRIV
argument_list|(
name|section_count
argument_list|)
condition|)
name|alloc_section
argument_list|(
name|abfd
argument_list|,
name|psect
argument_list|)
expr_stmt|;
name|image_set_ptr
argument_list|(
name|abfd
argument_list|,
operator|(
name|int
operator|)
name|psect
argument_list|,
operator|(
name|uquad
operator|)
name|dummy
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_CTL_AUGRB
case|:
comment|/* Augment relocation base: increment image location counter by offset 	 arg: lw	offset value.  */
name|dummy
operator|=
name|bfd_getl32
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|image_inc_ptr
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
name|dummy
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_CTL_DFLOC
case|:
comment|/* Define location: pop index, save location counter under index 	 arg: none.  */
name|dummy
operator|=
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: not fully implemented"
argument_list|)
argument_list|,
name|tir_cmd_name
argument_list|(
name|ptr
index|[
operator|-
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_CTL_STLOC
case|:
comment|/* Set location: pop index, restore location counter from index 	 arg: none.  */
name|dummy
operator|=
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|psect
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: not fully implemented"
argument_list|)
argument_list|,
name|tir_cmd_name
argument_list|(
name|ptr
index|[
operator|-
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIR_S_C_CTL_STKDL
case|:
comment|/* Stack defined location: pop index, push location counter from index 	 arg: none.  */
name|dummy
operator|=
name|_bfd_vms_pop
argument_list|(
name|abfd
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|psect
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: not fully implemented"
argument_list|)
argument_list|,
name|tir_cmd_name
argument_list|(
name|ptr
index|[
operator|-
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"reserved CTL cmd %d"
argument_list|)
argument_list|,
name|ptr
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Handle command from TIR section.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|tir_cmd
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|)
block|{
struct|struct
block|{
name|int
name|mincod
decl_stmt|;
name|int
name|maxcod
decl_stmt|;
name|unsigned
name|char
modifier|*
argument_list|(
operator|*
name|explain
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|,
name|unsigned
name|char
operator|*
argument_list|)
decl_stmt|;
block|}
name|tir_table
index|[]
init|=
block|{
block|{
literal|0
block|,
name|TIR_S_C_MAXSTACOD
block|,
name|tir_sta
block|}
block|,
block|{
name|TIR_S_C_MINSTOCOD
block|,
name|TIR_S_C_MAXSTOCOD
block|,
name|tir_sto
block|}
block|,
block|{
name|TIR_S_C_MINOPRCOD
block|,
name|TIR_S_C_MAXOPRCOD
block|,
name|tir_opr
block|}
block|,
block|{
name|TIR_S_C_MINCTLCOD
block|,
name|TIR_S_C_MAXCTLCOD
block|,
name|tir_ctl
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|NULL
block|}
block|}
struct|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|4
argument_list|,
literal|"tir_cmd %d/%x\n"
argument_list|,
operator|*
name|ptr
argument_list|,
operator|*
name|ptr
argument_list|)
expr_stmt|;
name|_bfd_hexdump
argument_list|(
literal|8
argument_list|,
name|ptr
argument_list|,
literal|16
argument_list|,
operator|(
name|int
operator|)
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|ptr
operator|&
literal|0x80
condition|)
block|{
comment|/* Store immediate.  */
name|i
operator|=
literal|128
operator|-
operator|(
operator|*
name|ptr
operator|++
operator|&
literal|0x7f
operator|)
expr_stmt|;
name|image_dump
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|i
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|tir_table
index|[
name|i
index|]
operator|.
name|mincod
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|tir_table
index|[
name|i
index|]
operator|.
name|mincod
operator|<=
operator|*
name|ptr
operator|)
operator|&&
operator|(
operator|*
name|ptr
operator|<=
name|tir_table
index|[
name|i
index|]
operator|.
name|maxcod
operator|)
condition|)
block|{
name|ptr
operator|=
name|tir_table
index|[
name|i
index|]
operator|.
name|explain
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tir_table
index|[
name|i
index|]
operator|.
name|mincod
operator|<
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"obj code %d not found"
argument_list|)
argument_list|,
operator|*
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Handle command from ETIR section.  */
end_comment

begin_function
specifier|static
name|int
name|etir_cmd
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|cmd
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|)
block|{
specifier|static
struct|struct
block|{
name|int
name|mincod
decl_stmt|;
name|int
name|maxcod
decl_stmt|;
name|bfd_boolean
function_decl|(
modifier|*
name|explain
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
block|}
name|etir_table
index|[]
init|=
block|{
block|{
name|ETIR_S_C_MINSTACOD
block|,
name|ETIR_S_C_MAXSTACOD
block|,
name|etir_sta
block|}
block|,
block|{
name|ETIR_S_C_MINSTOCOD
block|,
name|ETIR_S_C_MAXSTOCOD
block|,
name|etir_sto
block|}
block|,
block|{
name|ETIR_S_C_MINOPRCOD
block|,
name|ETIR_S_C_MAXOPRCOD
block|,
name|etir_opr
block|}
block|,
block|{
name|ETIR_S_C_MINCTLCOD
block|,
name|ETIR_S_C_MAXCTLCOD
block|,
name|etir_ctl
block|}
block|,
block|{
name|ETIR_S_C_MINSTCCOD
block|,
name|ETIR_S_C_MAXSTCCOD
block|,
name|etir_stc
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|NULL
block|}
block|}
struct|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|4
argument_list|,
literal|"etir_cmd %d/%x\n"
argument_list|,
name|cmd
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|_bfd_hexdump
argument_list|(
literal|8
argument_list|,
name|ptr
argument_list|,
literal|16
argument_list|,
operator|(
name|int
operator|)
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|etir_table
index|[
name|i
index|]
operator|.
name|mincod
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|etir_table
index|[
name|i
index|]
operator|.
name|mincod
operator|<=
name|cmd
operator|)
operator|&&
operator|(
name|cmd
operator|<=
name|etir_table
index|[
name|i
index|]
operator|.
name|maxcod
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|etir_table
index|[
name|i
index|]
operator|.
name|explain
argument_list|(
name|abfd
argument_list|,
name|cmd
argument_list|,
name|ptr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|4
argument_list|,
literal|"etir_cmd: = 0\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Text Information and Relocation Records (OBJ$C_TIR)    handle tir record.  */
end_comment

begin_function
specifier|static
name|int
name|analyze_tir
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|,
name|unsigned
name|int
name|length
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|maxptr
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|3
argument_list|,
literal|"analyze_tir: %d bytes\n"
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|maxptr
operator|=
name|ptr
operator|+
name|length
expr_stmt|;
while|while
condition|(
name|ptr
operator|<
name|maxptr
condition|)
block|{
name|ptr
operator|=
name|tir_cmd
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Text Information and Relocation Records (EOBJ$C_ETIR)    handle etir record.  */
end_comment

begin_function
specifier|static
name|int
name|analyze_etir
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|,
name|unsigned
name|int
name|length
parameter_list|)
block|{
name|int
name|cmd
decl_stmt|;
name|unsigned
name|char
modifier|*
name|maxptr
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|3
argument_list|,
literal|"analyze_etir: %d bytes\n"
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|maxptr
operator|=
name|ptr
operator|+
name|length
expr_stmt|;
while|while
condition|(
name|ptr
operator|<
name|maxptr
condition|)
block|{
name|cmd
operator|=
name|bfd_getl16
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|length
operator|=
name|bfd_getl16
argument_list|(
name|ptr
operator|+
literal|2
argument_list|)
expr_stmt|;
name|result
operator|=
name|etir_cmd
argument_list|(
name|abfd
argument_list|,
name|cmd
argument_list|,
name|ptr
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
break|break;
name|ptr
operator|+=
name|length
expr_stmt|;
block|}
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|3
argument_list|,
literal|"analyze_etir: = %d\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Process ETIR record    Return 0 on success, -1 on error.  */
end_comment

begin_function
name|int
name|_bfd_vms_slurp_tir
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|objtype
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|2
argument_list|,
literal|"TIR/ETIR\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|objtype
condition|)
block|{
case|case
name|EOBJ_S_C_ETIR
case|:
name|PRIV
argument_list|(
name|vms_rec
argument_list|)
operator|+=
literal|4
expr_stmt|;
comment|/* Skip type, size.  */
name|PRIV
argument_list|(
name|rec_size
argument_list|)
operator|-=
literal|4
expr_stmt|;
name|result
operator|=
name|analyze_etir
argument_list|(
name|abfd
argument_list|,
name|PRIV
argument_list|(
name|vms_rec
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|PRIV
argument_list|(
name|rec_size
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJ_S_C_TIR
case|:
name|PRIV
argument_list|(
name|vms_rec
argument_list|)
operator|+=
literal|1
expr_stmt|;
comment|/* Skip type.  */
name|PRIV
argument_list|(
name|rec_size
argument_list|)
operator|-=
literal|1
expr_stmt|;
name|result
operator|=
name|analyze_tir
argument_list|(
name|abfd
argument_list|,
name|PRIV
argument_list|(
name|vms_rec
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|PRIV
argument_list|(
name|rec_size
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Process EDBG record    Return 0 on success, -1 on error     Not implemented yet.  */
end_comment

begin_function
name|int
name|_bfd_vms_slurp_dbg
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|objtype
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|2
argument_list|,
literal|"DBG/EDBG\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|abfd
operator|->
name|flags
operator||=
operator|(
name|HAS_DEBUG
operator||
name|HAS_LINENO
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Process ETBT record    Return 0 on success, -1 on error     Not implemented yet.  */
end_comment

begin_function
name|int
name|_bfd_vms_slurp_tbt
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|objtype
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|2
argument_list|,
literal|"TBT/ETBT\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Process LNK record    Return 0 on success, -1 on error     Not implemented yet.  */
end_comment

begin_function
name|int
name|_bfd_vms_slurp_lnk
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|objtype
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|2
argument_list|,
literal|"LNK\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Start ETIR record for section #index at virtual addr offset.  */
end_comment

begin_function
specifier|static
name|void
name|start_etir_record
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|index
parameter_list|,
name|uquad
name|offset
parameter_list|,
name|bfd_boolean
name|justoffset
parameter_list|)
block|{
if|if
condition|(
operator|!
name|justoffset
condition|)
block|{
comment|/* One ETIR per section.  */
name|_bfd_vms_output_begin
argument_list|(
name|abfd
argument_list|,
name|EOBJ_S_C_ETIR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|_bfd_vms_output_push
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
comment|/* Push start offset.  */
name|_bfd_vms_output_begin
argument_list|(
name|abfd
argument_list|,
name|ETIR_S_C_STA_PQ
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|_bfd_vms_output_long
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|index
argument_list|)
expr_stmt|;
name|_bfd_vms_output_quad
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
name|offset
argument_list|)
expr_stmt|;
name|_bfd_vms_output_flush
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Start = pop ().  */
name|_bfd_vms_output_begin
argument_list|(
name|abfd
argument_list|,
name|ETIR_S_C_CTL_SETRB
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|_bfd_vms_output_flush
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|end_etir_record
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|_bfd_vms_output_pop
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|_bfd_vms_output_end
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* WRITE ETIR SECTION     This is still under construction and therefore not documented.  */
end_comment

begin_function
specifier|static
name|void
name|sto_imm
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|vms_section
modifier|*
name|sptr
parameter_list|,
name|bfd_vma
name|vaddr
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|int
name|ssize
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cptr
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|8
argument_list|,
literal|"sto_imm %d bytes\n"
argument_list|,
name|sptr
operator|->
name|size
argument_list|)
expr_stmt|;
name|_bfd_hexdump
argument_list|(
literal|9
argument_list|,
name|sptr
operator|->
name|contents
argument_list|,
operator|(
name|int
operator|)
name|sptr
operator|->
name|size
argument_list|,
operator|(
name|int
operator|)
name|vaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ssize
operator|=
name|sptr
operator|->
name|size
expr_stmt|;
name|cptr
operator|=
name|sptr
operator|->
name|contents
expr_stmt|;
while|while
condition|(
name|ssize
operator|>
literal|0
condition|)
block|{
comment|/* Try all the rest.  */
name|size
operator|=
name|ssize
expr_stmt|;
if|if
condition|(
name|_bfd_vms_output_check
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Doesn't fit, split !  */
name|end_etir_record
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|start_etir_record
argument_list|(
name|abfd
argument_list|,
name|index
argument_list|,
name|vaddr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Get max size.  */
name|size
operator|=
name|_bfd_vms_output_check
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* More than what's left ?  */
if|if
condition|(
name|size
operator|>
name|ssize
condition|)
name|size
operator|=
name|ssize
expr_stmt|;
block|}
name|_bfd_vms_output_begin
argument_list|(
name|abfd
argument_list|,
name|ETIR_S_C_STO_IMM
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|_bfd_vms_output_long
argument_list|(
name|abfd
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|_bfd_vms_output_dump
argument_list|(
name|abfd
argument_list|,
name|cptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|_bfd_vms_output_flush
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|10
argument_list|,
literal|"dumped %d bytes\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|_bfd_hexdump
argument_list|(
literal|10
argument_list|,
name|cptr
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|,
operator|(
name|int
operator|)
name|vaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vaddr
operator|+=
name|size
expr_stmt|;
name|ssize
operator|-=
name|size
expr_stmt|;
name|cptr
operator|+=
name|size
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write section contents for bfd abfd.  */
end_comment

begin_function
name|int
name|_bfd_vms_write_tir
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|objtype
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|asection
modifier|*
name|section
decl_stmt|;
name|vms_section
modifier|*
name|sptr
decl_stmt|;
name|int
name|nextoffset
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|2
argument_list|,
literal|"vms_write_tir (%p, %d)\n"
argument_list|,
name|abfd
argument_list|,
name|objtype
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_bfd_vms_output_alignment
argument_list|(
name|abfd
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|nextoffset
operator|=
literal|0
expr_stmt|;
name|PRIV
argument_list|(
name|vms_linkage_index
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Dump all other sections.  */
name|section
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
while|while
condition|(
name|section
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|4
argument_list|,
literal|"writing %d. section '%s' (%d bytes)\n"
argument_list|,
name|section
operator|->
name|index
argument_list|,
name|section
operator|->
name|name
argument_list|,
call|(
name|int
call|)
argument_list|(
name|section
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|section
operator|->
name|flags
operator|&
name|SEC_RELOC
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|section
operator|->
name|reloc_count
operator|)
operator|<=
literal|0
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"SEC_RELOC with no relocs in section %s"
argument_list|)
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
if|#
directive|if
name|VMS_DEBUG
else|else
block|{
name|arelent
modifier|*
modifier|*
name|rptr
decl_stmt|;
name|_bfd_vms_debug
argument_list|(
literal|4
argument_list|,
literal|"%d relocations:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rptr
operator|=
name|section
operator|->
name|orelocation
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
name|_bfd_vms_debug
argument_list|(
literal|4
argument_list|,
literal|"sym %s in sec %s, value %08lx, addr %08lx, off %08lx, len %d: %s\n"
argument_list|,
operator|(
operator|*
operator|(
operator|*
name|rptr
operator|)
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|name
argument_list|,
operator|(
operator|*
operator|(
operator|*
name|rptr
operator|)
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|section
operator|->
name|name
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
operator|(
operator|*
name|rptr
operator|)
operator|->
name|sym_ptr_ptr
argument_list|)
operator|->
name|value
argument_list|,
operator|(
operator|*
name|rptr
operator|)
operator|->
name|address
argument_list|,
operator|(
operator|*
name|rptr
operator|)
operator|->
name|addend
argument_list|,
name|bfd_get_reloc_size
argument_list|(
operator|(
operator|*
name|rptr
operator|)
operator|->
name|howto
argument_list|)
argument_list|,
operator|(
operator|*
name|rptr
operator|)
operator|->
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
name|rptr
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|&&
operator|(
operator|!
name|bfd_is_com_section
argument_list|(
name|section
argument_list|)
operator|)
condition|)
block|{
comment|/* Virtual addr in section.  */
name|bfd_vma
name|vaddr
decl_stmt|;
name|sptr
operator|=
name|_bfd_get_vms_section
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|sptr
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_contents
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|vaddr
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
name|sptr
operator|->
name|offset
argument_list|)
expr_stmt|;
name|start_etir_record
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|index
argument_list|,
operator|(
name|uquad
operator|)
name|sptr
operator|->
name|offset
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
while|while
condition|(
name|sptr
operator|!=
name|NULL
condition|)
block|{
comment|/* One STA_PQ, CTL_SETRB per vms_section.  */
if|if
condition|(
name|section
operator|->
name|flags
operator|&
name|SEC_RELOC
condition|)
block|{
comment|/* Check for relocs.  */
name|arelent
modifier|*
modifier|*
name|rptr
init|=
name|section
operator|->
name|orelocation
decl_stmt|;
name|int
name|i
init|=
name|section
operator|->
name|reloc_count
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bfd_size_type
name|addr
init|=
operator|(
operator|*
name|rptr
operator|)
operator|->
name|address
decl_stmt|;
name|bfd_size_type
name|len
init|=
name|bfd_get_reloc_size
argument_list|(
operator|(
operator|*
name|rptr
operator|)
operator|->
name|howto
argument_list|)
decl_stmt|;
if|if
condition|(
name|sptr
operator|->
name|offset
operator|<
name|addr
condition|)
block|{
comment|/* Sptr starts before reloc.  */
name|bfd_size_type
name|before
init|=
name|addr
operator|-
name|sptr
operator|->
name|offset
decl_stmt|;
if|if
condition|(
name|sptr
operator|->
name|size
operator|<=
name|before
condition|)
block|{
comment|/* Complete before.  */
name|sto_imm
argument_list|(
name|abfd
argument_list|,
name|sptr
argument_list|,
name|vaddr
argument_list|,
name|section
operator|->
name|index
argument_list|)
expr_stmt|;
name|vaddr
operator|+=
name|sptr
operator|->
name|size
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* Partly before.  */
name|int
name|after
init|=
name|sptr
operator|->
name|size
operator|-
name|before
decl_stmt|;
name|sptr
operator|->
name|size
operator|=
name|before
expr_stmt|;
name|sto_imm
argument_list|(
name|abfd
argument_list|,
name|sptr
argument_list|,
name|vaddr
argument_list|,
name|section
operator|->
name|index
argument_list|)
expr_stmt|;
name|vaddr
operator|+=
name|sptr
operator|->
name|size
expr_stmt|;
name|sptr
operator|->
name|contents
operator|+=
name|before
expr_stmt|;
name|sptr
operator|->
name|offset
operator|+=
name|before
expr_stmt|;
name|sptr
operator|->
name|size
operator|=
name|after
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sptr
operator|->
name|offset
operator|==
name|addr
condition|)
block|{
comment|/* Sptr starts at reloc.  */
name|asymbol
modifier|*
name|sym
init|=
operator|*
operator|(
operator|*
name|rptr
operator|)
operator|->
name|sym_ptr_ptr
decl_stmt|;
name|asection
modifier|*
name|sec
init|=
name|sym
operator|->
name|section
decl_stmt|;
switch|switch
condition|(
operator|(
operator|*
name|rptr
operator|)
operator|->
name|howto
operator|->
name|type
condition|)
block|{
case|case
name|ALPHA_R_IGNORE
case|:
break|break;
case|case
name|ALPHA_R_REFLONG
case|:
block|{
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
condition|)
block|{
name|int
name|slen
init|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sym
operator|->
name|name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|hash
decl_stmt|;
if|if
condition|(
name|_bfd_vms_output_check
argument_list|(
name|abfd
argument_list|,
name|slen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|end_etir_record
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|start_etir_record
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|index
argument_list|,
name|vaddr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|_bfd_vms_output_begin
argument_list|(
name|abfd
argument_list|,
name|ETIR_S_C_STO_GBL_LW
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|hash
operator|=
operator|(
name|_bfd_vms_length_hash_symbol
argument_list|(
name|abfd
argument_list|,
name|sym
operator|->
name|name
argument_list|,
name|EOBJ_S_C_SYMSIZ
argument_list|)
operator|)
expr_stmt|;
name|_bfd_vms_output_counted
argument_list|(
name|abfd
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|_bfd_vms_output_flush
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
condition|)
block|{
if|if
condition|(
name|_bfd_vms_output_check
argument_list|(
name|abfd
argument_list|,
literal|16
argument_list|)
operator|<
literal|0
condition|)
block|{
name|end_etir_record
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|start_etir_record
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|index
argument_list|,
name|vaddr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|_bfd_vms_output_begin
argument_list|(
name|abfd
argument_list|,
name|ETIR_S_C_STA_LW
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|_bfd_vms_output_quad
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
name|sym
operator|->
name|value
argument_list|)
expr_stmt|;
name|_bfd_vms_output_flush
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|_bfd_vms_output_begin
argument_list|(
name|abfd
argument_list|,
name|ETIR_S_C_STO_LW
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|_bfd_vms_output_flush
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|_bfd_vms_output_check
argument_list|(
name|abfd
argument_list|,
literal|32
argument_list|)
operator|<
literal|0
condition|)
block|{
name|end_etir_record
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|start_etir_record
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|index
argument_list|,
name|vaddr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|_bfd_vms_output_begin
argument_list|(
name|abfd
argument_list|,
name|ETIR_S_C_STA_PQ
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|_bfd_vms_output_long
argument_list|(
name|abfd
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|sec
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|_bfd_vms_output_quad
argument_list|(
name|abfd
argument_list|,
operator|(
call|(
name|uquad
call|)
argument_list|(
operator|*
name|rptr
argument_list|)
operator|->
name|addend
operator|+
operator|(
name|uquad
operator|)
name|sym
operator|->
name|value
operator|)
argument_list|)
expr_stmt|;
name|_bfd_vms_output_flush
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|_bfd_vms_output_begin
argument_list|(
name|abfd
argument_list|,
name|ETIR_S_C_STO_LW
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|_bfd_vms_output_flush
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ALPHA_R_REFQUAD
case|:
block|{
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
condition|)
block|{
name|int
name|slen
init|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sym
operator|->
name|name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|hash
decl_stmt|;
if|if
condition|(
name|_bfd_vms_output_check
argument_list|(
name|abfd
argument_list|,
name|slen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|end_etir_record
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|start_etir_record
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|index
argument_list|,
name|vaddr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|_bfd_vms_output_begin
argument_list|(
name|abfd
argument_list|,
name|ETIR_S_C_STO_GBL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|hash
operator|=
operator|(
name|_bfd_vms_length_hash_symbol
argument_list|(
name|abfd
argument_list|,
name|sym
operator|->
name|name
argument_list|,
name|EOBJ_S_C_SYMSIZ
argument_list|)
operator|)
expr_stmt|;
name|_bfd_vms_output_counted
argument_list|(
name|abfd
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|_bfd_vms_output_flush
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
condition|)
block|{
if|if
condition|(
name|_bfd_vms_output_check
argument_list|(
name|abfd
argument_list|,
literal|16
argument_list|)
operator|<
literal|0
condition|)
block|{
name|end_etir_record
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|start_etir_record
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|index
argument_list|,
name|vaddr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|_bfd_vms_output_begin
argument_list|(
name|abfd
argument_list|,
name|ETIR_S_C_STA_QW
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|_bfd_vms_output_quad
argument_list|(
name|abfd
argument_list|,
operator|(
name|uquad
operator|)
name|sym
operator|->
name|value
argument_list|)
expr_stmt|;
name|_bfd_vms_output_flush
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|_bfd_vms_output_begin
argument_list|(
name|abfd
argument_list|,
name|ETIR_S_C_STO_QW
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|_bfd_vms_output_flush
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|_bfd_vms_output_check
argument_list|(
name|abfd
argument_list|,
literal|32
argument_list|)
operator|<
literal|0
condition|)
block|{
name|end_etir_record
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|start_etir_record
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|index
argument_list|,
name|vaddr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|_bfd_vms_output_begin
argument_list|(
name|abfd
argument_list|,
name|ETIR_S_C_STA_PQ
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|_bfd_vms_output_long
argument_list|(
name|abfd
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|sec
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|_bfd_vms_output_quad
argument_list|(
name|abfd
argument_list|,
operator|(
call|(
name|uquad
call|)
argument_list|(
operator|*
name|rptr
argument_list|)
operator|->
name|addend
operator|+
operator|(
name|uquad
operator|)
name|sym
operator|->
name|value
operator|)
argument_list|)
expr_stmt|;
name|_bfd_vms_output_flush
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|_bfd_vms_output_begin
argument_list|(
name|abfd
argument_list|,
name|ETIR_S_C_STO_OFF
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|_bfd_vms_output_flush
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ALPHA_R_HINT
case|:
block|{
name|int
name|hint_size
decl_stmt|;
name|char
modifier|*
name|hash
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|hint_size
operator|=
name|sptr
operator|->
name|size
expr_stmt|;
name|sptr
operator|->
name|size
operator|=
name|len
expr_stmt|;
name|sto_imm
argument_list|(
name|abfd
argument_list|,
name|sptr
argument_list|,
name|vaddr
argument_list|,
name|section
operator|->
name|index
argument_list|)
expr_stmt|;
name|sptr
operator|->
name|size
operator|=
name|hint_size
expr_stmt|;
block|}
break|break;
case|case
name|ALPHA_R_LINKAGE
case|:
block|{
name|char
modifier|*
name|hash
decl_stmt|;
if|if
condition|(
name|_bfd_vms_output_check
argument_list|(
name|abfd
argument_list|,
literal|64
argument_list|)
operator|<
literal|0
condition|)
block|{
name|end_etir_record
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|start_etir_record
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|index
argument_list|,
name|vaddr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|_bfd_vms_output_begin
argument_list|(
name|abfd
argument_list|,
name|ETIR_S_C_STC_LP_PSB
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|_bfd_vms_output_long
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|PRIV
argument_list|(
name|vms_linkage_index
argument_list|)
argument_list|)
expr_stmt|;
name|PRIV
argument_list|(
name|vms_linkage_index
argument_list|)
operator|+=
literal|2
expr_stmt|;
name|hash
operator|=
operator|(
name|_bfd_vms_length_hash_symbol
argument_list|(
name|abfd
argument_list|,
name|sym
operator|->
name|name
argument_list|,
name|EOBJ_S_C_SYMSIZ
argument_list|)
operator|)
expr_stmt|;
name|_bfd_vms_output_counted
argument_list|(
name|abfd
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|_bfd_vms_output_byte
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_bfd_vms_output_flush
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ALPHA_R_CODEADDR
case|:
block|{
name|int
name|slen
init|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sym
operator|->
name|name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|hash
decl_stmt|;
if|if
condition|(
name|_bfd_vms_output_check
argument_list|(
name|abfd
argument_list|,
name|slen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|end_etir_record
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|start_etir_record
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|index
argument_list|,
name|vaddr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|_bfd_vms_output_begin
argument_list|(
name|abfd
argument_list|,
name|ETIR_S_C_STO_CA
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|hash
operator|=
operator|(
name|_bfd_vms_length_hash_symbol
argument_list|(
name|abfd
argument_list|,
name|sym
operator|->
name|name
argument_list|,
name|EOBJ_S_C_SYMSIZ
argument_list|)
operator|)
expr_stmt|;
name|_bfd_vms_output_counted
argument_list|(
name|abfd
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|_bfd_vms_output_flush
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Unhandled relocation %s"
argument_list|)
argument_list|,
operator|(
operator|*
name|rptr
operator|)
operator|->
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
name|vaddr
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|==
name|sptr
operator|->
name|size
condition|)
block|{
break|break;
block|}
else|else
block|{
name|sptr
operator|->
name|contents
operator|+=
name|len
expr_stmt|;
name|sptr
operator|->
name|offset
operator|+=
name|len
expr_stmt|;
name|sptr
operator|->
name|size
operator|-=
name|len
expr_stmt|;
name|i
operator|--
expr_stmt|;
name|rptr
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Sptr starts after reloc.  */
name|i
operator|--
expr_stmt|;
comment|/* Check next reloc.  */
name|rptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* All reloc checked.  */
if|if
condition|(
name|sptr
operator|->
name|size
operator|>
literal|0
condition|)
block|{
comment|/* Dump rest.  */
name|sto_imm
argument_list|(
name|abfd
argument_list|,
name|sptr
argument_list|,
name|vaddr
argument_list|,
name|section
operator|->
name|index
argument_list|)
expr_stmt|;
name|vaddr
operator|+=
name|sptr
operator|->
name|size
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
else|else
block|{
comment|/* No relocs, just dump.  */
name|sto_imm
argument_list|(
name|abfd
argument_list|,
name|sptr
argument_list|,
name|vaddr
argument_list|,
name|section
operator|->
name|index
argument_list|)
expr_stmt|;
name|vaddr
operator|+=
name|sptr
operator|->
name|size
expr_stmt|;
block|}
name|sptr
operator|=
name|sptr
operator|->
name|next
expr_stmt|;
block|}
name|end_etir_record
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
name|section
operator|=
name|section
operator|->
name|next
expr_stmt|;
block|}
name|_bfd_vms_output_alignment
argument_list|(
name|abfd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Write traceback data for bfd abfd.  */
end_comment

begin_function
name|int
name|_bfd_vms_write_tbt
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|objtype
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|2
argument_list|,
literal|"vms_write_tbt (%p, %d)\n"
argument_list|,
name|abfd
argument_list|,
name|objtype
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Write debug info for bfd abfd.  */
end_comment

begin_function
name|int
name|_bfd_vms_write_dbg
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|objtype
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|2
argument_list|,
literal|"vms_write_dbg (%p, objtype)\n"
argument_list|,
name|abfd
argument_list|,
name|objtype
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

end_unit

