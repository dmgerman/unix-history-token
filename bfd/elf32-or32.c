begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* OR32-specific support for 32-bit ELF    Copyright 2002, 2004, 2005 Free Software Foundation, Inc.    Contributed by Ivan Guzvinec<ivang@opencores.org>     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/or32.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_comment
comment|/* Try to minimize the amount of space occupied by relocation tables    on the ROM (not that the ROM won't be swamped by other ELF overhead).  */
end_comment

begin_define
define|#
directive|define
name|USE_REL
value|1
end_define

begin_comment
comment|/* Set the right machine number for an OR32 ELF file.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|or32_elf_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
operator|(
name|void
operator|)
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_or32
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The final processing done just before writing out an OR32 ELF object file.    This gets the OR32 architecture right based on the machine number.  */
end_comment

begin_function
specifier|static
name|void
name|or32_elf_final_write_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|linker
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
name|EF_OR32_MACH
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|or32_elf_32_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
name|bfd_size_type
name|addr
init|=
name|reloc_entry
operator|->
name|address
decl_stmt|;
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
expr_stmt|;
name|insn
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|insn
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|insn
operator|+=
name|symbol
operator|->
name|value
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|or32_elf_16_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|short
name|insn
decl_stmt|;
name|bfd_size_type
name|addr
init|=
name|reloc_entry
operator|->
name|address
decl_stmt|;
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
expr_stmt|;
name|insn
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|insn
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|insn
operator|+=
name|symbol
operator|->
name|value
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|or32_elf_8_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|char
name|insn
decl_stmt|;
name|bfd_size_type
name|addr
init|=
name|reloc_entry
operator|->
name|address
decl_stmt|;
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
name|insn
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
expr_stmt|;
name|insn
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|insn
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|insn
operator|+=
name|symbol
operator|->
name|value
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_comment
comment|/* Do a R_OR32_CONSTH relocation.  This has to be done in combination    with a R_OR32_CONST reloc, because there is a carry from the LO16 to    the HI16.  Here we just save the information we need; we do the    actual relocation when we see the LO16.  OR32 ELF requires that the    LO16 immediately follow the HI16.  As a GNU extension, we permit an    arbitrary number of HI16 relocs to be associated with a single LO16    reloc.  This extension permits gcc to output the HI and LO relocs    itself. This code is copied from the elf32-mips.c.  */
end_comment

begin_struct
struct|struct
name|or32_consth
block|{
name|struct
name|or32_consth
modifier|*
name|next
decl_stmt|;
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* FIXME: This should not be a static variable.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|or32_consth
modifier|*
name|or32_consth_list
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_reloc_status_type
name|or32_elf_consth_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_reloc_status_type
name|ret
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|struct
name|or32_consth
modifier|*
name|n
decl_stmt|;
name|ret
operator|=
name|bfd_reloc_ok
expr_stmt|;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|&&
name|output_bfd
operator|==
name|NULL
condition|)
name|ret
operator|=
name|bfd_reloc_undefined
expr_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|input_section
argument_list|)
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* Save the information, and let LO16 do the actual relocation.  */
name|n
operator|=
name|bfd_malloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|n
operator|->
name|addr
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
expr_stmt|;
name|n
operator|->
name|addend
operator|=
name|relocation
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|or32_consth_list
expr_stmt|;
name|or32_consth_list
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Do a R_OR32_CONST relocation.  This is a straightforward 16 bit    inplace relocation; this function exists in order to do the    R_OR32_CONSTH relocation described above.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|or32_elf_const_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
if|if
condition|(
name|or32_consth_list
operator|!=
name|NULL
condition|)
block|{
name|struct
name|or32_consth
modifier|*
name|l
decl_stmt|;
name|l
operator|=
name|or32_consth_list
expr_stmt|;
while|while
condition|(
name|l
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|unsigned
name|long
name|vallo
decl_stmt|;
name|struct
name|or32_consth
modifier|*
name|next
decl_stmt|;
comment|/* Do the HI16 relocation.  Note that we actually don't need 	     to know anything about the LO16 itself, except where to 	     find the low 16 bits of the addend needed by the LO16.  */
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|l
operator|->
name|addr
argument_list|)
expr_stmt|;
name|vallo
operator|=
operator|(
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|insn
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator|+
name|vallo
expr_stmt|;
name|val
operator|+=
name|l
operator|->
name|addend
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
literal|0xffff
operator|)
operator||
operator|(
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|l
operator|->
name|addr
argument_list|)
expr_stmt|;
name|next
operator|=
name|l
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
name|next
expr_stmt|;
block|}
name|or32_consth_list
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|long
name|insn
decl_stmt|,
name|tmp
decl_stmt|;
name|bfd_size_type
name|addr
init|=
name|reloc_entry
operator|->
name|address
decl_stmt|;
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|insn
operator|&
literal|0x0000ffff
expr_stmt|;
name|tmp
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|tmp
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|tmp
operator|+=
name|symbol
operator|->
name|value
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|tmp
operator|&
literal|0x0000ffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* Now do the LO16 reloc in the usual way.  */
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|or32_elf_jumptarg_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|long
name|insn
decl_stmt|,
name|tmp
decl_stmt|;
name|bfd_size_type
name|addr
init|=
name|reloc_entry
operator|->
name|address
decl_stmt|;
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|insn
operator||
literal|0xfc000000
expr_stmt|;
name|tmp
operator|-=
operator|(
name|input_section
operator|->
name|output_offset
operator|>>
literal|2
operator|)
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
literal|0xfc000000
operator|)
operator||
operator|(
name|tmp
operator|&
literal|0x03ffffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_or32_howto_table
index|[]
init|=
block|{
comment|/* This reloc does nothing.  */
name|HOWTO
argument_list|(
name|R_OR32_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_OR32_NONE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A standard 32 bit relocation.  */
name|HOWTO
argument_list|(
name|R_OR32_32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|or32_elf_32_reloc
argument_list|,
comment|/* special_function */
literal|"R_OR32_32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A standard 16 bit relocation.  */
name|HOWTO
argument_list|(
name|R_OR32_16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|or32_elf_16_reloc
argument_list|,
comment|/* special_function */
literal|"R_OR32_16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A standard 8 bit relocation.  */
name|HOWTO
argument_list|(
name|R_OR32_8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|or32_elf_8_reloc
argument_list|,
comment|/* special_function */
literal|"R_OR32_8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x000000ff
argument_list|,
comment|/* src_mask */
literal|0x000000ff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A standard low 16 bit relocation.  */
name|HOWTO
argument_list|(
name|R_OR32_CONST
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|or32_elf_const_reloc
argument_list|,
comment|/* special_function */
literal|"R_OR32_CONST"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A standard high 16 bit relocation.  */
name|HOWTO
argument_list|(
name|R_OR32_CONSTH
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|or32_elf_consth_reloc
argument_list|,
comment|/* special_function */
literal|"R_OR32_CONSTH"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff0000
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A standard branch relocation.  */
name|HOWTO
argument_list|(
name|R_OR32_JUMPTARG
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|28
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|or32_elf_jumptarg_reloc
argument_list|,
comment|/* special_function */
literal|"R_OR32_JUMPTARG"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x03ffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable hierarchy.  */
name|HOWTO
argument_list|(
name|R_OR32_GNU_VTINHERIT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_OR32_GNU_VTINHERIT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable member usage.  */
name|HOWTO
argument_list|(
name|R_OR32_GNU_VTENTRY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_elf_rel_vtable_reloc_fn
argument_list|,
comment|/* special_function */
literal|"R_OR32_GNU_VTENTRY"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map BFD reloc types to OR32 ELF reloc types.  */
end_comment

begin_struct
struct|struct
name|or32_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_val
decl_stmt|;
name|unsigned
name|char
name|elf_reloc_val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|or32_reloc_map
name|or32_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_OR32_NONE
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_OR32_32
block|}
block|,
block|{
name|BFD_RELOC_16
block|,
name|R_OR32_16
block|}
block|,
block|{
name|BFD_RELOC_8
block|,
name|R_OR32_8
block|}
block|,
block|{
name|BFD_RELOC_LO16
block|,
name|R_OR32_CONST
block|}
block|,
block|{
name|BFD_RELOC_HI16
block|,
name|R_OR32_CONSTH
block|}
block|,
block|{
name|BFD_RELOC_32_GOT_PCREL
block|,
name|R_OR32_JUMPTARG
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_INHERIT
block|,
name|R_OR32_GNU_VTINHERIT
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_ENTRY
block|,
name|R_OR32_GNU_VTENTRY
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|bfd_elf32_bfd_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ARRAY_SIZE
argument_list|(
name|or32_reloc_map
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
if|if
condition|(
name|or32_reloc_map
index|[
name|i
index|]
operator|.
name|bfd_reloc_val
operator|==
name|code
condition|)
return|return
operator|&
name|elf_or32_howto_table
index|[
name|or32_reloc_map
index|[
name|i
index|]
operator|.
name|elf_reloc_val
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set the howto pointer for an OR32 ELF reloc.  */
end_comment

begin_function
specifier|static
name|void
name|or32_info_to_howto_rel
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|cache_ptr
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|dst
parameter_list|)
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r_type
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_OR32_max
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf_or32_howto_table
index|[
name|r_type
index|]
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_or32_little_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-littleor32"
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_or32_big_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-or32"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_or32
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_OR32
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1000
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|0
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|or32_info_to_howto_rel
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|or32_elf_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
define|\
value|or32_elf_final_write_processing
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

