begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for Motorola 68000 COFF binaries.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999,    2000, 2001, 2002, 2003, 2005    Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"coff/m68k.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_comment
comment|/* This source file is compiled multiple times for various m68k COFF    variants.  The following macros control its behaviour:     TARGET_SYM      The C name of the BFD target vector.  The default is m68kcoff_vec.    TARGET_NAME      The user visible target name.  The default is "coff-m68k".    NAMES_HAVE_UNDERSCORE      Whether symbol names have an underscore.    ONLY_DECLARE_RELOCS      Only declare the relocation howto array.  Don't actually compile      it.  The actual array will be picked up in another version of the      file.    STATIC_RELOCS      Make the relocation howto array, and associated functions, static.    COFF_COMMON_ADDEND      If this is defined, then, for a relocation against a common      symbol, the object file holds the value (the size) of the common      symbol.  If this is not defined, then, for a relocation against a      common symbol, the object file holds zero.  */
end_comment

begin_define
define|#
directive|define
name|COFF_DEFAULT_SECTION_ALIGNMENT_POWER
value|(2)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|COFF_PAGE_SIZE
end_ifndef

begin_comment
comment|/* The page size is a guess based on ELF.  */
end_comment

begin_define
define|#
directive|define
name|COFF_PAGE_SIZE
value|0x2000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|COFF_COMMON_ADDEND
end_ifndef

begin_define
define|#
directive|define
name|RELOC_SPECIAL_FN
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|m68kcoff_common_addend_special_fn
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|m68kcoff_common_addend_rtype_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|internal_reloc
operator|*
operator|,
expr|struct
name|coff_link_hash_entry
operator|*
operator|,
expr|struct
name|internal_syment
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RELOC_SPECIAL_FN
value|m68kcoff_common_addend_special_fn
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|bfd_boolean
name|m68k_coff_is_local_label_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* On the delta, a symbol starting with L% is local.  We won't see    such a symbol on other platforms, so it should be safe to always    consider it local here.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m68k_coff_is_local_label_name
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'L'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'%'
condition|)
return|return
name|TRUE
return|;
return|return
name|_bfd_coff_is_local_label_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|STATIC_RELOCS
end_ifndef

begin_comment
comment|/* Clean up namespace.  */
end_comment

begin_define
define|#
directive|define
name|m68kcoff_howto_table
value|_bfd_m68kcoff_howto_table
end_define

begin_define
define|#
directive|define
name|m68k_rtype2howto
value|_bfd_m68kcoff_rtype2howto
end_define

begin_define
define|#
directive|define
name|m68k_howto2rtype
value|_bfd_m68kcoff_howto2rtype
end_define

begin_define
define|#
directive|define
name|m68k_reloc_type_lookup
value|_bfd_m68kcoff_reloc_type_lookup
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ONLY_DECLARE_RELOCS
end_ifdef

begin_decl_stmt
specifier|extern
name|reloc_howto_type
name|m68kcoff_howto_table
index|[]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|STATIC_RELOCS
end_ifdef

begin_decl_stmt
specifier|static
endif|#
directive|endif
name|reloc_howto_type
name|m68kcoff_howto_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|R_RELBYTE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|RELOC_SPECIAL_FN
argument_list|,
literal|"8"
argument_list|,
name|TRUE
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_RELWORD
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|RELOC_SPECIAL_FN
argument_list|,
literal|"16"
argument_list|,
name|TRUE
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_RELLONG
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|RELOC_SPECIAL_FN
argument_list|,
literal|"32"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_PCRBYTE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|RELOC_SPECIAL_FN
argument_list|,
literal|"DISP8"
argument_list|,
name|TRUE
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_PCRWORD
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|RELOC_SPECIAL_FN
argument_list|,
literal|"DISP16"
argument_list|,
name|TRUE
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_PCRLONG
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|RELOC_SPECIAL_FN
argument_list|,
literal|"DISP32"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_RELLONG_NEG
argument_list|,
literal|0
argument_list|,
operator|-
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|RELOC_SPECIAL_FN
argument_list|,
literal|"-32"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,   }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not ONLY_DECLARE_RELOCS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BADMAG
end_ifndef

begin_define
define|#
directive|define
name|BADMAG
parameter_list|(
name|x
parameter_list|)
value|M68KBADMAG(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|M68
value|1
end_define

begin_comment
comment|/* Customize coffcode.h */
end_comment

begin_comment
comment|/* Turn a howto into a reloc number */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ONLY_DECLARE_RELOCS
end_ifdef

begin_decl_stmt
specifier|extern
name|void
name|m68k_rtype2howto
name|PARAMS
argument_list|(
operator|(
name|arelent
operator|*
name|internal
operator|,
name|int
name|relocentry
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|m68k_howto2rtype
name|PARAMS
argument_list|(
operator|(
name|reloc_howto_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|reloc_howto_type
modifier|*
name|m68k_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|STATIC_RELOCS
end_ifdef

begin_define
define|#
directive|define
name|STAT_REL
value|static
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STAT_REL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|STAT_REL
name|reloc_howto_type
modifier|*
name|m68k_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STAT_REL
name|int
name|m68k_howto2rtype
name|PARAMS
argument_list|(
operator|(
name|reloc_howto_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STAT_REL
name|void
name|m68k_rtype2howto
name|PARAMS
argument_list|(
operator|(
name|arelent
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|STAT_REL
name|void
name|m68k_rtype2howto
parameter_list|(
name|internal
parameter_list|,
name|relocentry
parameter_list|)
name|arelent
modifier|*
name|internal
decl_stmt|;
name|int
name|relocentry
decl_stmt|;
block|{
switch|switch
condition|(
name|relocentry
condition|)
block|{
case|case
name|R_RELBYTE
case|:
name|internal
operator|->
name|howto
operator|=
name|m68kcoff_howto_table
operator|+
literal|0
expr_stmt|;
break|break;
case|case
name|R_RELWORD
case|:
name|internal
operator|->
name|howto
operator|=
name|m68kcoff_howto_table
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|R_RELLONG
case|:
name|internal
operator|->
name|howto
operator|=
name|m68kcoff_howto_table
operator|+
literal|2
expr_stmt|;
break|break;
case|case
name|R_PCRBYTE
case|:
name|internal
operator|->
name|howto
operator|=
name|m68kcoff_howto_table
operator|+
literal|3
expr_stmt|;
break|break;
case|case
name|R_PCRWORD
case|:
name|internal
operator|->
name|howto
operator|=
name|m68kcoff_howto_table
operator|+
literal|4
expr_stmt|;
break|break;
case|case
name|R_PCRLONG
case|:
name|internal
operator|->
name|howto
operator|=
name|m68kcoff_howto_table
operator|+
literal|5
expr_stmt|;
break|break;
case|case
name|R_RELLONG_NEG
case|:
name|internal
operator|->
name|howto
operator|=
name|m68kcoff_howto_table
operator|+
literal|6
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|STAT_REL
name|int
name|m68k_howto2rtype
parameter_list|(
name|internal
parameter_list|)
name|reloc_howto_type
modifier|*
name|internal
decl_stmt|;
block|{
if|if
condition|(
name|internal
operator|->
name|pc_relative
condition|)
block|{
switch|switch
condition|(
name|internal
operator|->
name|bitsize
condition|)
block|{
case|case
literal|32
case|:
return|return
name|R_PCRLONG
return|;
case|case
literal|16
case|:
return|return
name|R_PCRWORD
return|;
case|case
literal|8
case|:
return|return
name|R_PCRBYTE
return|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|internal
operator|->
name|bitsize
condition|)
block|{
case|case
literal|32
case|:
return|return
name|R_RELLONG
return|;
case|case
literal|16
case|:
return|return
name|R_RELWORD
return|;
case|case
literal|8
case|:
return|return
name|R_RELBYTE
return|;
block|}
block|}
return|return
name|R_RELLONG
return|;
block|}
end_function

begin_function
name|STAT_REL
name|reloc_howto_type
modifier|*
name|m68k_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
default|default:
return|return
name|NULL
return|;
case|case
name|BFD_RELOC_8
case|:
return|return
name|m68kcoff_howto_table
operator|+
literal|0
return|;
case|case
name|BFD_RELOC_16
case|:
return|return
name|m68kcoff_howto_table
operator|+
literal|1
return|;
case|case
name|BFD_RELOC_CTOR
case|:
case|case
name|BFD_RELOC_32
case|:
return|return
name|m68kcoff_howto_table
operator|+
literal|2
return|;
case|case
name|BFD_RELOC_8_PCREL
case|:
return|return
name|m68kcoff_howto_table
operator|+
literal|3
return|;
case|case
name|BFD_RELOC_16_PCREL
case|:
return|return
name|m68kcoff_howto_table
operator|+
literal|4
return|;
case|case
name|BFD_RELOC_32_PCREL
case|:
return|return
name|m68kcoff_howto_table
operator|+
literal|5
return|;
comment|/* FIXME: There doesn't seem to be a code for R_RELLONG_NEG.  */
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not ONLY_DECLARE_RELOCS */
end_comment

begin_define
define|#
directive|define
name|RTYPE2HOWTO
parameter_list|(
name|internal
parameter_list|,
name|relocentry
parameter_list|)
define|\
value|m68k_rtype2howto(internal, (relocentry)->r_type)
end_define

begin_define
define|#
directive|define
name|SELECT_RELOC
parameter_list|(
name|external
parameter_list|,
name|internal
parameter_list|)
define|\
value|external.r_type = m68k_howto2rtype (internal)
end_define

begin_define
define|#
directive|define
name|coff_bfd_reloc_type_lookup
value|m68k_reloc_type_lookup
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|COFF_COMMON_ADDEND
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|coff_rtype_to_howto
end_ifndef

begin_define
define|#
directive|define
name|coff_rtype_to_howto
value|m68kcoff_rtype_to_howto
end_define

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|m68kcoff_rtype_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|internal_reloc
operator|*
operator|,
expr|struct
name|coff_link_hash_entry
operator|*
operator|,
expr|struct
name|internal_syment
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|m68kcoff_rtype_to_howto
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|rel
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|,
name|addendp
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|h
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_vma
modifier|*
name|addendp
decl_stmt|;
block|{
name|arelent
name|relent
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|RTYPE2HOWTO
argument_list|(
operator|&
name|relent
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|howto
operator|=
name|relent
operator|.
name|howto
expr_stmt|;
if|if
condition|(
name|howto
operator|->
name|pc_relative
condition|)
operator|*
name|addendp
operator|+=
name|sec
operator|->
name|vma
expr_stmt|;
return|return
name|howto
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (coff_rtype_to_howto) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (COFF_COMMON_ADDEND) */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_COMMON_ADDEND
end_ifdef

begin_comment
comment|/* If COFF_COMMON_ADDEND is defined, then when using m68k COFF the    value stored in the .text section for a reference to a common    symbol is the value itself plus any desired offset.  (taken from    work done by Ian Taylor, Cygnus Support, for I386 COFF).  */
end_comment

begin_comment
comment|/* If we are producing relocatable output, we need to do some    adjustments to the object file that are not done by the    bfd_perform_relocation function.  This function is called by every    reloc type to make any required adjustments.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|m68kcoff_common_addend_special_fn
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|symvalue
name|diff
decl_stmt|;
if|if
condition|(
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
return|return
name|bfd_reloc_continue
return|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
block|{
comment|/* We are relocating a common symbol.  The current value in the 	 object file is ORIG + OFFSET, where ORIG is the value of the 	 common symbol as seen by the object file when it was compiled 	 (this may be zero if the symbol was undefined) and OFFSET is 	 the offset into the common symbol (normally zero, but may be 	 non-zero when referring to a field in a common structure). 	 ORIG is the negative of reloc_entry->addend, which is set by 	 the CALC_ADDEND macro below.  We want to replace the value in 	 the object file with NEW + OFFSET, where NEW is the value of 	 the common symbol which we are going to put in the final 	 object file.  NEW is symbol->value.  */
name|diff
operator|=
name|symbol
operator|->
name|value
operator|+
name|reloc_entry
operator|->
name|addend
expr_stmt|;
block|}
else|else
block|{
comment|/* For some reason bfd_perform_relocation always effectively 	 ignores the addend for a COFF target when producing 	 relocatable output.  This seems to be always wrong for 386 	 COFF, so we handle the addend here instead.  */
name|diff
operator|=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
block|}
define|#
directive|define
name|DOIT
parameter_list|(
name|x
parameter_list|)
define|\
value|x = ((x& ~howto->dst_mask) | (((x& howto->src_mask) + diff)& howto->dst_mask))
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
block|{
name|reloc_howto_type
modifier|*
name|howto
init|=
name|reloc_entry
operator|->
name|howto
decl_stmt|;
name|unsigned
name|char
modifier|*
name|addr
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
decl_stmt|;
switch|switch
condition|(
name|howto
operator|->
name|size
condition|)
block|{
case|case
literal|0
case|:
block|{
name|char
name|x
init|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
block|{
name|short
name|x
init|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|x
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
block|{
name|long
name|x
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|x
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Now let bfd_perform_relocation finish everything up.  */
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_comment
comment|/* Compute the addend of a reloc.  If the reloc is to a common symbol,    the object file contains the value of the common symbol.  By the    time this is called, the linker may be using a different symbol    from a different object file with a different value.  Therefore, we    hack wildly to locate the original symbol from this file so that we    can make the correct adjustment.  This macro sets coffsym to the    symbol from the original file, and uses it to set the addend value    correctly.  If this is not a common symbol, the usual addend    calculation is done, except that an additional tweak is needed for    PC relative relocs.    FIXME: This macro refers to symbols and asect; these are from the    calling function, not the macro arguments.  */
end_comment

begin_define
define|#
directive|define
name|CALC_ADDEND
parameter_list|(
name|abfd
parameter_list|,
name|ptr
parameter_list|,
name|reloc
parameter_list|,
name|cache_ptr
parameter_list|)
define|\
value|{								\     coff_symbol_type *coffsym = (coff_symbol_type *) NULL;	\     if (ptr&& bfd_asymbol_bfd (ptr) != abfd)			\       coffsym = (obj_symbols (abfd)				\ 	         + (cache_ptr->sym_ptr_ptr - symbols));		\     else if (ptr)						\       coffsym = coff_symbol_from (abfd, ptr);			\     if (coffsym != (coff_symbol_type *) NULL			\&& coffsym->native->u.syment.n_scnum == 0)		\       cache_ptr->addend = - coffsym->native->u.syment.n_value;	\     else if (ptr&& bfd_asymbol_bfd (ptr) == abfd		\&& ptr->section != (asection *) NULL)		\       cache_ptr->addend = - (ptr->section->vma + ptr->value);	\     else							\       cache_ptr->addend = 0;					\     if (ptr&& (reloc.r_type == R_PCRBYTE			\ 		|| reloc.r_type == R_PCRWORD			\ 		|| reloc.r_type == R_PCRLONG))			\       cache_ptr->addend += asect->vma;				\   }
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|coff_rtype_to_howto
end_ifndef

begin_comment
comment|/* coff-m68k.c uses the special COFF backend linker.  We need to    adjust common symbols.  */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|m68kcoff_common_addend_rtype_to_howto
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|rel
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|,
name|addendp
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
modifier|*
name|addendp
decl_stmt|;
block|{
name|arelent
name|relent
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|RTYPE2HOWTO
argument_list|(
operator|&
name|relent
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|howto
operator|=
name|relent
operator|.
name|howto
expr_stmt|;
if|if
condition|(
name|howto
operator|->
name|pc_relative
condition|)
operator|*
name|addendp
operator|+=
name|sec
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
name|sym
operator|->
name|n_scnum
operator|==
literal|0
operator|&&
name|sym
operator|->
name|n_value
operator|!=
literal|0
condition|)
block|{
comment|/* This is a common symbol.  The section contents include the 	 size (sym->n_value) as an addend.  The relocate_section 	 function will be adding in the final value of the symbol.  We 	 need to subtract out the current size in order to get the 	 correct result.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|addendp
operator|-=
name|sym
operator|->
name|n_value
expr_stmt|;
block|}
comment|/* If the output symbol is common (in which case this must be a      relocatable link), we need to add in the final size of the      common symbol.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
operator|*
name|addendp
operator|+=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|size
expr_stmt|;
return|return
name|howto
return|;
block|}
end_function

begin_define
define|#
directive|define
name|coff_rtype_to_howto
value|m68kcoff_common_addend_rtype_to_howto
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (coff_rtype_to_howto) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COFF_COMMON_ADDEND */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
name|ONLY_DECLARE_RELOCS
operator|&&
operator|!
name|defined
name|STATIC_RELOCS
end_if

begin_comment
comment|/* Given a .data section and a .emreloc in-memory section, store    relocation information into the .emreloc section which can be    used at runtime to relocate the section.  This is called by the    linker when the --embedded-relocs switch is used.  This is called    after the add_symbols entry point has been called for all the    objects, and before the final_link entry point is called.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_m68k_coff_create_embedded_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|datasec
parameter_list|,
name|relsec
parameter_list|,
name|errmsg
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|datasec
decl_stmt|;
name|asection
modifier|*
name|relsec
decl_stmt|;
name|char
modifier|*
modifier|*
name|errmsg
decl_stmt|;
block|{
name|char
modifier|*
name|extsyms
decl_stmt|;
name|bfd_size_type
name|symesz
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|BFD_ASSERT
argument_list|(
operator|!
name|info
operator|->
name|relocatable
argument_list|)
expr_stmt|;
operator|*
name|errmsg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|datasec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|extsyms
operator|=
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|symesz
operator|=
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|irel
operator|=
name|_bfd_coff_read_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|datasec
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|irelend
operator|=
name|irel
operator|+
name|datasec
operator|->
name|reloc_count
expr_stmt|;
name|amt
operator|=
operator|(
name|bfd_size_type
operator|)
name|datasec
operator|->
name|reloc_count
operator|*
literal|12
expr_stmt|;
name|relsec
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsec
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|p
operator|=
name|relsec
operator|->
name|contents
expr_stmt|;
for|for
control|(
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
operator|,
name|p
operator|+=
literal|12
control|)
block|{
name|asection
modifier|*
name|targetsec
decl_stmt|;
comment|/* We are going to write a four byte longword into the runtime        reloc section.  The longword will be the address in the data        section which must be relocated.  It is followed by the name        of the target section NUL-padded or truncated to 8        characters.  */
comment|/* We can only relocate absolute longword relocs at run time.  */
if|if
condition|(
name|irel
operator|->
name|r_type
operator|!=
name|R_RELLONG
condition|)
block|{
operator|*
name|errmsg
operator|=
name|_
argument_list|(
literal|"unsupported reloc type"
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|irel
operator|->
name|r_symndx
operator|==
operator|-
literal|1
condition|)
name|targetsec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
else|else
block|{
name|struct
name|coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|obj_coff_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|irel
operator|->
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
name|struct
name|internal_syment
name|isym
decl_stmt|;
name|bfd_coff_swap_sym_in
argument_list|(
name|abfd
argument_list|,
name|extsyms
operator|+
name|symesz
operator|*
name|irel
operator|->
name|r_symndx
argument_list|,
operator|&
name|isym
argument_list|)
expr_stmt|;
name|targetsec
operator|=
name|coff_section_from_bfd_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|.
name|n_scnum
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
name|targetsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
else|else
name|targetsec
operator|=
name|NULL
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|irel
operator|->
name|r_vaddr
operator|-
name|datasec
operator|->
name|vma
operator|+
name|datasec
operator|->
name|output_offset
operator|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
operator|+
literal|4
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetsec
operator|!=
name|NULL
condition|)
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|+
literal|4
argument_list|,
name|targetsec
operator|->
name|output_section
operator|->
name|name
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* neither ONLY_DECLARE_RELOCS not STATIC_RELOCS  */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|coff_bfd_is_local_label_name
value|m68k_coff_is_local_label_name
end_define

begin_define
define|#
directive|define
name|coff_relocate_section
value|_bfd_coff_generic_relocate_section
end_define

begin_include
include|#
directive|include
file|"coffcode.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_SYM
end_ifndef

begin_define
define|#
directive|define
name|TARGET_SYM
value|m68kcoff_vec
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_NAME
end_ifndef

begin_define
define|#
directive|define
name|TARGET_NAME
value|"coff-m68k"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NAMES_HAVE_UNDERSCORE
end_ifdef

begin_macro
name|CREATE_BIG_COFF_TARGET_VEC
argument_list|(
argument|TARGET_SYM
argument_list|,
argument|TARGET_NAME
argument_list|,
argument|D_PAGED
argument_list|,
literal|0
argument_list|,
literal|'_'
argument_list|,
argument|NULL
argument_list|,
argument|COFF_SWAP_TABLE
argument_list|)
end_macro

begin_else
else|#
directive|else
end_else

begin_macro
name|CREATE_BIG_COFF_TARGET_VEC
argument_list|(
argument|TARGET_SYM
argument_list|,
argument|TARGET_NAME
argument_list|,
argument|D_PAGED
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
argument|NULL
argument_list|,
argument|COFF_SWAP_TABLE
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

end_unit

