begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for Intel 960 b.out binaries.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.    Written by Cygnus Support.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"genlink.h"
end_include

begin_include
include|#
directive|include
file|"bout.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_comment
comment|/* BFD a.out internal data structures.  */
end_comment

begin_define
define|#
directive|define
name|ABS32CODE
value|0
end_define

begin_define
define|#
directive|define
name|ABS32CODE_SHRUNK
value|1
end_define

begin_define
define|#
directive|define
name|PCREL24
value|2
end_define

begin_define
define|#
directive|define
name|CALLJ
value|3
end_define

begin_define
define|#
directive|define
name|ABS32
value|4
end_define

begin_define
define|#
directive|define
name|PCREL13
value|5
end_define

begin_define
define|#
directive|define
name|ABS32_MAYBE_RELAXABLE
value|1
end_define

begin_define
define|#
directive|define
name|ABS32_WAS_RELAXABLE
value|2
end_define

begin_define
define|#
directive|define
name|ALIGNER
value|10
end_define

begin_define
define|#
directive|define
name|ALIGNDONE
value|11
end_define

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_reloc_callj
init|=
name|HOWTO
argument_list|(
name|CALLJ
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|24
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"callj"
argument_list|,
name|TRUE
argument_list|,
literal|0x00ffffff
argument_list|,
literal|0x00ffffff
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_reloc_abs32
init|=
name|HOWTO
argument_list|(
name|ABS32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"abs32"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_reloc_pcrel24
init|=
name|HOWTO
argument_list|(
name|PCREL24
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|24
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"pcrel24"
argument_list|,
name|TRUE
argument_list|,
literal|0x00ffffff
argument_list|,
literal|0x00ffffff
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_reloc_pcrel13
init|=
name|HOWTO
argument_list|(
name|PCREL13
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|13
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"pcrel13"
argument_list|,
name|TRUE
argument_list|,
literal|0x00001fff
argument_list|,
literal|0x00001fff
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_reloc_abs32codeshrunk
init|=
name|HOWTO
argument_list|(
name|ABS32CODE_SHRUNK
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|24
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"callx->callj"
argument_list|,
name|TRUE
argument_list|,
literal|0x00ffffff
argument_list|,
literal|0x00ffffff
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_reloc_abs32code
init|=
name|HOWTO
argument_list|(
name|ABS32CODE
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"callx"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_align_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|ALIGNER
argument_list|,
literal|0
argument_list|,
literal|0x1
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
literal|0
argument_list|,
literal|"align16"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ALIGNER
argument_list|,
literal|0
argument_list|,
literal|0x3
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
literal|0
argument_list|,
literal|"align32"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ALIGNER
argument_list|,
literal|0
argument_list|,
literal|0x7
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
literal|0
argument_list|,
literal|"align64"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ALIGNER
argument_list|,
literal|0
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
literal|0
argument_list|,
literal|"align128"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_done_align_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|ALIGNDONE
argument_list|,
literal|0x1
argument_list|,
literal|0x1
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
literal|0
argument_list|,
literal|"donealign16"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ALIGNDONE
argument_list|,
literal|0x3
argument_list|,
literal|0x3
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
literal|0
argument_list|,
literal|"donealign32"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ALIGNDONE
argument_list|,
literal|0x7
argument_list|,
literal|0x7
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
literal|0
argument_list|,
literal|"donealign64"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|ALIGNDONE
argument_list|,
literal|0xf
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
literal|0
argument_list|,
literal|"donealign128"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Swaps the information in an executable header taken from a raw byte    stream memory image, into the internal exec_header structure.  */
end_comment

begin_function
specifier|static
name|void
name|bout_swap_exec_header_in
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|external_exec
modifier|*
name|bytes
parameter_list|,
name|struct
name|internal_exec
modifier|*
name|execp
parameter_list|)
block|{
comment|/* Now fill in fields in the execp, from the bytes in the raw data.  */
name|execp
operator|->
name|a_info
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_info
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_text
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_text
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_data
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_data
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_bss
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_bss
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_syms
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_syms
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_entry
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_entry
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_trsize
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_trsize
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_drsize
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_drsize
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_tload
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_tload
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_dload
operator|=
name|GET_WORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|e_dload
argument_list|)
expr_stmt|;
name|execp
operator|->
name|a_talign
operator|=
name|bytes
operator|->
name|e_talign
index|[
literal|0
index|]
expr_stmt|;
name|execp
operator|->
name|a_dalign
operator|=
name|bytes
operator|->
name|e_dalign
index|[
literal|0
index|]
expr_stmt|;
name|execp
operator|->
name|a_balign
operator|=
name|bytes
operator|->
name|e_balign
index|[
literal|0
index|]
expr_stmt|;
name|execp
operator|->
name|a_relaxable
operator|=
name|bytes
operator|->
name|e_relaxable
index|[
literal|0
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swaps the information in an internal exec header structure into the    supplied buffer ready for writing to disk.  */
end_comment

begin_function
specifier|static
name|void
name|bout_swap_exec_header_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|internal_exec
modifier|*
name|execp
parameter_list|,
name|struct
name|external_exec
modifier|*
name|bytes
parameter_list|)
block|{
comment|/* Now fill in fields in the raw data, from the fields in the exec struct.  */
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_info
argument_list|,
name|bytes
operator|->
name|e_info
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_text
argument_list|,
name|bytes
operator|->
name|e_text
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_data
argument_list|,
name|bytes
operator|->
name|e_data
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_bss
argument_list|,
name|bytes
operator|->
name|e_bss
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_syms
argument_list|,
name|bytes
operator|->
name|e_syms
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_entry
argument_list|,
name|bytes
operator|->
name|e_entry
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_trsize
argument_list|,
name|bytes
operator|->
name|e_trsize
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_drsize
argument_list|,
name|bytes
operator|->
name|e_drsize
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_tload
argument_list|,
name|bytes
operator|->
name|e_tload
argument_list|)
expr_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|execp
operator|->
name|a_dload
argument_list|,
name|bytes
operator|->
name|e_dload
argument_list|)
expr_stmt|;
name|bytes
operator|->
name|e_talign
index|[
literal|0
index|]
operator|=
name|execp
operator|->
name|a_talign
expr_stmt|;
name|bytes
operator|->
name|e_dalign
index|[
literal|0
index|]
operator|=
name|execp
operator|->
name|a_dalign
expr_stmt|;
name|bytes
operator|->
name|e_balign
index|[
literal|0
index|]
operator|=
name|execp
operator|->
name|a_balign
expr_stmt|;
name|bytes
operator|->
name|e_relaxable
index|[
literal|0
index|]
operator|=
name|execp
operator|->
name|a_relaxable
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish up the opening of a b.out file for reading.  Fill in all the    fields that are not handled by common code.  */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|b_out_callback
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|internal_exec
modifier|*
name|execp
init|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|bss_start
decl_stmt|;
comment|/* Architecture and machine type.  */
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_i960
argument_list|,
comment|/* B.out only used on i960.  */
name|bfd_mach_i960_core
comment|/* Default.  */
argument_list|)
expr_stmt|;
comment|/* The positions of the string table and symbol table.  */
name|obj_str_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|N_STROFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|N_SYMOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
comment|/* The alignments of the sections.  */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
operator|=
name|execp
operator|->
name|a_talign
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
operator|=
name|execp
operator|->
name|a_dalign
expr_stmt|;
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
operator|=
name|execp
operator|->
name|a_balign
expr_stmt|;
comment|/* The starting addresses of the sections.  */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|execp
operator|->
name|a_tload
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|execp
operator|->
name|a_dload
expr_stmt|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|lma
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|lma
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
comment|/* And reload the sizes, since the aout module zaps them.  */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|size
operator|=
name|execp
operator|->
name|a_text
expr_stmt|;
name|bss_start
operator|=
name|execp
operator|->
name|a_dload
operator|+
name|execp
operator|->
name|a_data
expr_stmt|;
comment|/* BSS = end of data section.  */
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|align_power
argument_list|(
name|bss_start
argument_list|,
name|execp
operator|->
name|a_balign
argument_list|)
expr_stmt|;
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|lma
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
comment|/* The file positions of the sections.  */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|N_TXTOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|N_DATOFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
comment|/* The file positions of the relocation info.  */
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|rel_filepos
operator|=
name|N_TROFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|rel_filepos
operator|=
name|N_DROFF
argument_list|(
operator|*
name|execp
argument_list|)
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|page_size
operator|=
literal|1
expr_stmt|;
comment|/* Not applicable.  */
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|segment_size
operator|=
literal|1
expr_stmt|;
comment|/* Not applicable.  */
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|exec_bytes_size
operator|=
name|EXEC_BYTES_SIZE
expr_stmt|;
if|if
condition|(
name|execp
operator|->
name|a_relaxable
condition|)
name|abfd
operator|->
name|flags
operator||=
name|BFD_IS_RELAXABLE
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|b_out_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|internal_exec
name|anexec
decl_stmt|;
name|struct
name|external_exec
name|exec_bytes
decl_stmt|;
name|bfd_size_type
name|amt
init|=
name|EXEC_BYTES_SIZE
decl_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|exec_bytes
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|anexec
operator|.
name|a_info
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|exec_bytes
operator|.
name|e_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|N_BADMAG
argument_list|(
name|anexec
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bout_swap_exec_header_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|exec_bytes
argument_list|,
operator|&
name|anexec
argument_list|)
expr_stmt|;
return|return
name|aout_32_some_aout_object_p
argument_list|(
name|abfd
argument_list|,
operator|&
name|anexec
argument_list|,
name|b_out_callback
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|bout_data_struct
block|{
name|struct
name|aoutdata
name|a
decl_stmt|;
name|struct
name|internal_exec
name|e
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|bfd_boolean
name|b_out_mkobject
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|bout_data_struct
modifier|*
name|rawptr
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|bout_data_struct
argument_list|)
decl_stmt|;
name|rawptr
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rawptr
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|abfd
operator|->
name|tdata
operator|.
name|bout_data
operator|=
name|rawptr
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|=
operator|&
name|rawptr
operator|->
name|e
expr_stmt|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|b_out_symbol_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a_ptr
parameter_list|,
specifier|const
name|void
modifier|*
name|b_ptr
parameter_list|)
block|{
name|struct
name|aout_symbol
modifier|*
modifier|*
name|a
init|=
operator|(
expr|struct
name|aout_symbol
operator|*
operator|*
operator|)
name|a_ptr
decl_stmt|;
name|struct
name|aout_symbol
modifier|*
modifier|*
name|b
init|=
operator|(
expr|struct
name|aout_symbol
operator|*
operator|*
operator|)
name|b_ptr
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|av
decl_stmt|,
name|bv
decl_stmt|;
comment|/* Primary key is address.  */
name|sec
operator|=
name|bfd_get_section
argument_list|(
operator|&
operator|(
operator|*
name|a
operator|)
operator|->
name|symbol
argument_list|)
expr_stmt|;
name|av
operator|=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
operator|(
operator|*
name|a
operator|)
operator|->
name|symbol
operator|.
name|value
expr_stmt|;
name|sec
operator|=
name|bfd_get_section
argument_list|(
operator|&
operator|(
operator|*
name|b
operator|)
operator|->
name|symbol
argument_list|)
expr_stmt|;
name|bv
operator|=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
operator|(
operator|*
name|b
operator|)
operator|->
name|symbol
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|av
operator|<
name|bv
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|av
operator|>
name|bv
condition|)
return|return
literal|1
return|;
comment|/* Secondary key puts CALLNAME syms last and BALNAME syms first,      so that they have the best chance of being contiguous.  */
if|if
condition|(
name|IS_BALNAME
argument_list|(
operator|(
operator|*
name|a
operator|)
operator|->
name|other
argument_list|)
operator|||
name|IS_CALLNAME
argument_list|(
operator|(
operator|*
name|b
operator|)
operator|->
name|other
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|IS_CALLNAME
argument_list|(
operator|(
operator|*
name|a
operator|)
operator|->
name|other
argument_list|)
operator|||
name|IS_BALNAME
argument_list|(
operator|(
operator|*
name|b
operator|)
operator|->
name|other
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|b_out_squirt_out_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|)
block|{
name|arelent
modifier|*
modifier|*
name|generic
decl_stmt|;
name|int
name|r_extern
init|=
literal|0
decl_stmt|;
name|int
name|r_idx
decl_stmt|;
name|int
name|incode_mask
decl_stmt|;
name|int
name|len_1
decl_stmt|;
name|unsigned
name|int
name|count
init|=
name|section
operator|->
name|reloc_count
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|native
decl_stmt|,
modifier|*
name|natptr
decl_stmt|;
name|bfd_size_type
name|natsize
decl_stmt|;
name|int
name|extern_mask
decl_stmt|,
name|pcrel_mask
decl_stmt|,
name|len_2
decl_stmt|,
name|callj_mask
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|generic
operator|=
name|section
operator|->
name|orelocation
expr_stmt|;
name|natsize
operator|=
operator|(
name|bfd_size_type
operator|)
name|count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
expr_stmt|;
name|native
operator|=
name|bfd_malloc
argument_list|(
name|natsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|native
operator|&&
name|natsize
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/* Big-endian bit field allocation order.  */
name|pcrel_mask
operator|=
literal|0x80
expr_stmt|;
name|extern_mask
operator|=
literal|0x10
expr_stmt|;
name|len_2
operator|=
literal|0x40
expr_stmt|;
name|len_1
operator|=
literal|0x20
expr_stmt|;
name|callj_mask
operator|=
literal|0x02
expr_stmt|;
name|incode_mask
operator|=
literal|0x08
expr_stmt|;
block|}
else|else
block|{
comment|/* Little-endian bit field allocation order.  */
name|pcrel_mask
operator|=
literal|0x01
expr_stmt|;
name|extern_mask
operator|=
literal|0x08
expr_stmt|;
name|len_2
operator|=
literal|0x04
expr_stmt|;
name|len_1
operator|=
literal|0x02
expr_stmt|;
name|callj_mask
operator|=
literal|0x40
expr_stmt|;
name|incode_mask
operator|=
literal|0x10
expr_stmt|;
block|}
for|for
control|(
name|natptr
operator|=
name|native
init|;
name|count
operator|>
literal|0
condition|;
operator|--
name|count
operator|,
operator|++
name|natptr
operator|,
operator|++
name|generic
control|)
block|{
name|arelent
modifier|*
name|g
init|=
operator|*
name|generic
decl_stmt|;
name|unsigned
name|char
modifier|*
name|raw
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|natptr
decl_stmt|;
name|asymbol
modifier|*
name|sym
init|=
operator|*
operator|(
name|g
operator|->
name|sym_ptr_ptr
operator|)
decl_stmt|;
name|asection
modifier|*
name|output_section
init|=
name|sym
operator|->
name|section
operator|->
name|output_section
decl_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|g
operator|->
name|address
argument_list|,
name|raw
argument_list|)
expr_stmt|;
comment|/* Find a type in the output format which matches the input howto - 	 at the moment we assume input format == output format FIXME!!  */
name|r_idx
operator|=
literal|0
expr_stmt|;
comment|/* FIXME:  Need callj stuff here, and to check the howto entries to 	 be sure they are real for this architecture.  */
if|if
condition|(
name|g
operator|->
name|howto
operator|==
operator|&
name|howto_reloc_callj
condition|)
name|raw
index|[
literal|7
index|]
operator|=
name|callj_mask
operator|+
name|pcrel_mask
operator|+
name|len_2
expr_stmt|;
elseif|else
if|if
condition|(
name|g
operator|->
name|howto
operator|==
operator|&
name|howto_reloc_pcrel24
condition|)
name|raw
index|[
literal|7
index|]
operator|=
name|pcrel_mask
operator|+
name|len_2
expr_stmt|;
elseif|else
if|if
condition|(
name|g
operator|->
name|howto
operator|==
operator|&
name|howto_reloc_pcrel13
condition|)
name|raw
index|[
literal|7
index|]
operator|=
name|pcrel_mask
operator|+
name|len_1
expr_stmt|;
elseif|else
if|if
condition|(
name|g
operator|->
name|howto
operator|==
operator|&
name|howto_reloc_abs32code
condition|)
name|raw
index|[
literal|7
index|]
operator|=
name|len_2
operator|+
name|incode_mask
expr_stmt|;
elseif|else
if|if
condition|(
name|g
operator|->
name|howto
operator|>=
name|howto_align_table
operator|&&
name|g
operator|->
name|howto
operator|<=
operator|(
name|howto_align_table
operator|+
name|ARRAY_SIZE
argument_list|(
name|howto_align_table
argument_list|)
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* symnum == -2; extern_mask not set, pcrel_mask set.  */
name|r_idx
operator|=
operator|-
literal|2
expr_stmt|;
name|r_extern
operator|=
literal|0
expr_stmt|;
name|raw
index|[
literal|7
index|]
operator|=
operator|(
name|pcrel_mask
operator||
operator|(
operator|(
name|g
operator|->
name|howto
operator|-
name|howto_align_table
operator|)
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
block|}
else|else
name|raw
index|[
literal|7
index|]
operator|=
name|len_2
expr_stmt|;
if|if
condition|(
name|r_idx
operator|!=
literal|0
condition|)
comment|/* Already mucked with r_extern, r_idx.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|output_section
argument_list|)
operator|||
name|bfd_is_abs_section
argument_list|(
name|output_section
argument_list|)
operator|||
name|bfd_is_und_section
argument_list|(
name|output_section
argument_list|)
condition|)
block|{
if|if
condition|(
name|bfd_abs_section_ptr
operator|->
name|symbol
operator|==
name|sym
condition|)
block|{
comment|/* Whoops, looked like an abs symbol, but is really an offset 		 from the abs section.  */
name|r_idx
operator|=
literal|0
expr_stmt|;
name|r_extern
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Fill in symbol.  */
name|r_extern
operator|=
literal|1
expr_stmt|;
name|r_idx
operator|=
operator|(
operator|*
name|g
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|udata
operator|.
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Just an ordinary section.  */
name|r_extern
operator|=
literal|0
expr_stmt|;
name|r_idx
operator|=
name|output_section
operator|->
name|target_index
expr_stmt|;
block|}
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|raw
index|[
literal|4
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|r_idx
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|raw
index|[
literal|5
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|r_idx
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|raw
index|[
literal|6
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|r_idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|raw
index|[
literal|6
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|r_idx
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|raw
index|[
literal|5
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|r_idx
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|raw
index|[
literal|4
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|r_idx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_extern
condition|)
name|raw
index|[
literal|7
index|]
operator||=
name|extern_mask
expr_stmt|;
block|}
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|native
argument_list|,
name|natsize
argument_list|,
name|abfd
argument_list|)
operator|!=
name|natsize
condition|)
block|{
name|free
argument_list|(
name|native
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|free
argument_list|(
name|native
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|b_out_write_object_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|external_exec
name|swapped_hdr
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
operator|!
name|aout_32_make_sections
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_info
operator|=
name|BMAGIC
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_text
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|size
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_data
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|size
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_bss
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|size
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_syms
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|*
literal|12
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_entry
operator|=
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_trsize
operator|=
operator|(
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|reloc_count
operator|)
operator|*
literal|8
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_drsize
operator|=
operator|(
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|reloc_count
operator|)
operator|*
literal|8
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_talign
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_dalign
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_balign
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|alignment_power
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_tload
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_dload
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
name|bout_swap_exec_header_out
argument_list|(
name|abfd
argument_list|,
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|&
name|swapped_hdr
argument_list|)
expr_stmt|;
name|amt
operator|=
name|EXEC_BYTES_SIZE
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|swapped_hdr
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
comment|/* Now write out reloc info, followed by syms and strings */
if|if
condition|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Make sure {CALL,BAL}NAME symbols remain adjacent on output 	 by sorting.  This is complicated by the fact that stabs are 	 also ordered.  Solve this by shifting all stabs to the end 	 in order, then sorting the rest.  */
name|asymbol
modifier|*
modifier|*
name|outsyms
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|q
decl_stmt|;
name|outsyms
operator|=
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|p
operator|=
name|outsyms
operator|+
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|p
operator|--
init|;
name|p
operator|>=
name|outsyms
condition|;
name|p
operator|--
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|flags
operator|&
name|BSF_DEBUGGING
condition|)
block|{
name|asymbol
modifier|*
name|t
init|=
operator|*
operator|--
name|q
decl_stmt|;
operator|*
name|q
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
name|t
expr_stmt|;
block|}
block|}
if|if
condition|(
name|q
operator|>
name|outsyms
condition|)
name|qsort
argument_list|(
name|outsyms
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|q
operator|-
name|outsyms
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|,
name|b_out_symbol_cmp
argument_list|)
expr_stmt|;
comment|/* Back to your regularly scheduled program.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|N_SYMOFF
argument_list|(
operator|*
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|aout_32_write_syms
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|N_TROFF
argument_list|(
operator|*
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|b_out_squirt_out_relocs
argument_list|(
name|abfd
argument_list|,
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|N_DROFF
argument_list|(
operator|*
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|b_out_squirt_out_relocs
argument_list|(
name|abfd
argument_list|,
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Some reloc hackery.  */
end_comment

begin_define
define|#
directive|define
name|CALLS
value|0x66003800
end_define

begin_comment
comment|/* Template for 'calls' instruction	*/
end_comment

begin_define
define|#
directive|define
name|BAL
value|0x0b000000
end_define

begin_comment
comment|/* Template for 'bal' instruction 	*/
end_comment

begin_define
define|#
directive|define
name|BAL_MASK
value|0x00ffffff
end_define

begin_define
define|#
directive|define
name|BALX
value|0x85f00000
end_define

begin_comment
comment|/* Template for 'balx' instruction	*/
end_comment

begin_define
define|#
directive|define
name|BALX_MASK
value|0x0007ffff
end_define

begin_define
define|#
directive|define
name|CALL
value|0x09000000
end_define

begin_define
define|#
directive|define
name|PCREL13_MASK
value|0x1fff
end_define

begin_define
define|#
directive|define
name|output_addr
parameter_list|(
name|sec
parameter_list|)
value|((sec)->output_offset+(sec)->output_section->vma)
end_define

begin_function
specifier|static
name|bfd_vma
name|get_value
parameter_list|(
name|arelent
modifier|*
name|reloc
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|)
block|{
name|bfd_vma
name|value
decl_stmt|;
name|asymbol
modifier|*
name|symbol
init|=
operator|*
operator|(
name|reloc
operator|->
name|sym_ptr_ptr
operator|)
decl_stmt|;
comment|/* A symbol holds a pointer to a section, and an offset from the      base of the section.  To relocate, we find where the section will      live in the output and add that in.  */
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* The symbol is undefined in this BFD.  Look it up in the 	 global linker hash table.  FIXME: This should be changed when 	 we convert b.out to use a specific final_link function and 	 change the interface to bfd_relax_section to not require the 	 generic symbols.  */
name|h
operator|=
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|input_section
operator|->
name|owner
argument_list|,
name|link_info
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
name|value
operator|=
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|output_addr
argument_list|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_common
condition|)
name|value
operator|=
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|size
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|link_info
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|input_section
operator|->
name|owner
argument_list|,
name|input_section
argument_list|,
name|reloc
operator|->
name|address
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|value
operator|=
name|symbol
operator|->
name|value
operator|+
name|output_addr
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
expr_stmt|;
comment|/* Add the value contained in the relocation.  */
name|value
operator|+=
name|reloc
operator|->
name|addend
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Magic to turn callx into calljx.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|calljx_callback
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|void
modifier|*
name|src
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|)
block|{
name|int
name|word
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|src
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
name|symbol_in
init|=
operator|*
operator|(
name|reloc_entry
operator|->
name|sym_ptr_ptr
operator|)
decl_stmt|;
name|aout_symbol_type
modifier|*
name|symbol
init|=
name|aout_symbol
argument_list|(
name|symbol_in
argument_list|)
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|value
operator|=
name|get_value
argument_list|(
name|reloc_entry
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_CALLNAME
argument_list|(
name|symbol
operator|->
name|other
argument_list|)
condition|)
block|{
name|aout_symbol_type
modifier|*
name|balsym
init|=
name|symbol
operator|+
literal|1
decl_stmt|;
name|int
name|inst
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|src
operator|-
literal|4
argument_list|)
decl_stmt|;
comment|/* The next symbol should be an N_BALNAME.  */
name|BFD_ASSERT
argument_list|(
name|IS_BALNAME
argument_list|(
name|balsym
operator|->
name|other
argument_list|)
argument_list|)
expr_stmt|;
name|inst
operator|&=
name|BALX_MASK
expr_stmt|;
name|inst
operator||=
name|BALX
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|inst
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|dst
operator|-
literal|4
argument_list|)
expr_stmt|;
name|symbol
operator|=
name|balsym
expr_stmt|;
name|value
operator|=
operator|(
name|symbol
operator|->
name|symbol
operator|.
name|value
operator|+
name|output_addr
argument_list|(
name|symbol
operator|->
name|symbol
operator|.
name|section
argument_list|)
operator|)
expr_stmt|;
block|}
name|word
operator|+=
name|value
operator|+
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|word
argument_list|,
name|dst
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Magic to turn call into callj.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|callj_callback
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|unsigned
name|int
name|srcidx
parameter_list|,
name|unsigned
name|int
name|dstidx
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_boolean
name|shrinking
parameter_list|)
block|{
name|int
name|word
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|srcidx
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
name|symbol_in
init|=
operator|*
operator|(
name|reloc_entry
operator|->
name|sym_ptr_ptr
operator|)
decl_stmt|;
name|aout_symbol_type
modifier|*
name|symbol
init|=
name|aout_symbol
argument_list|(
name|symbol_in
argument_list|)
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|value
operator|=
name|get_value
argument_list|(
name|reloc_entry
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_OTHER
argument_list|(
name|symbol
operator|->
name|other
argument_list|)
condition|)
comment|/* Call to a system procedure - replace code with system        procedure number.  */
name|word
operator|=
name|CALLS
operator||
operator|(
name|symbol
operator|->
name|other
operator|-
literal|1
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_CALLNAME
argument_list|(
name|symbol
operator|->
name|other
argument_list|)
condition|)
block|{
name|aout_symbol_type
modifier|*
name|balsym
init|=
name|symbol
operator|+
literal|1
decl_stmt|;
comment|/* The next symbol should be an N_BALNAME.  */
name|BFD_ASSERT
argument_list|(
name|IS_BALNAME
argument_list|(
name|balsym
operator|->
name|other
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We are calling a leaf, so replace the call instruction with a 	 bal.  */
name|word
operator|=
name|BAL
operator||
operator|(
operator|(
name|word
operator|+
name|output_addr
argument_list|(
name|balsym
operator|->
name|symbol
operator|.
name|section
argument_list|)
operator|+
name|balsym
operator|->
name|symbol
operator|.
name|value
operator|+
name|reloc_entry
operator|->
name|addend
operator|-
name|dstidx
operator|-
name|output_addr
argument_list|(
name|input_section
argument_list|)
operator|)
operator|&
name|BAL_MASK
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|symbol
operator|->
name|symbol
operator|.
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* A callj against a symbol in the same section is a fully          resolved relative call.  We don't need to do anything here.          If the symbol is not in the same section, I'm not sure what          to do; fortunately, this case will probably never arise.  */
name|BFD_ASSERT
argument_list|(
operator|!
name|shrinking
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|symbol
operator|->
name|symbol
operator|.
name|section
operator|==
name|input_section
argument_list|)
expr_stmt|;
block|}
else|else
name|word
operator|=
name|CALL
operator||
operator|(
operator|(
operator|(
name|word
operator|&
name|BAL_MASK
operator|)
operator|+
name|value
operator|+
name|reloc_entry
operator|->
name|addend
operator|-
operator|(
name|shrinking
condition|?
name|dstidx
else|:
literal|0
operator|)
operator|-
name|output_addr
argument_list|(
name|input_section
argument_list|)
operator|)
operator|&
name|BAL_MASK
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|word
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|dstidx
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|b_out_bfd_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
default|default:
return|return
literal|0
return|;
case|case
name|BFD_RELOC_I960_CALLJ
case|:
return|return
operator|&
name|howto_reloc_callj
return|;
case|case
name|BFD_RELOC_32
case|:
case|case
name|BFD_RELOC_CTOR
case|:
return|return
operator|&
name|howto_reloc_abs32
return|;
case|case
name|BFD_RELOC_24_PCREL
case|:
return|return
operator|&
name|howto_reloc_pcrel24
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|b_out_bfd_reloc_name_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|r_name
parameter_list|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|howto_reloc_callj
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|howto_reloc_callj
return|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|howto_reloc_abs32
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|howto_reloc_abs32
return|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|howto_reloc_pcrel24
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|howto_reloc_pcrel24
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Allocate enough room for all the reloc entries, plus pointers to them all.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|b_out_slurp_reloc_table
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|sec_ptr
name|asect
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|)
block|{
name|struct
name|relocation_info
modifier|*
name|rptr
decl_stmt|;
name|unsigned
name|int
name|counter
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|int
name|extern_mask
decl_stmt|,
name|pcrel_mask
decl_stmt|,
name|callj_mask
decl_stmt|,
name|length_shift
decl_stmt|;
name|int
name|incode_mask
decl_stmt|;
name|int
name|size_mask
decl_stmt|;
name|bfd_vma
name|prev_addr
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|bfd_size_type
name|reloc_size
decl_stmt|,
name|amt
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|relocs
decl_stmt|;
name|arelent
modifier|*
name|reloc_cache
decl_stmt|;
if|if
condition|(
name|asect
operator|->
name|relocation
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|aout_32_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|asect
operator|==
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
condition|)
name|reloc_size
operator|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_drsize
expr_stmt|;
elseif|else
if|if
condition|(
name|asect
operator|==
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
condition|)
name|reloc_size
operator|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_trsize
expr_stmt|;
elseif|else
if|if
condition|(
name|asect
operator|==
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
condition|)
name|reloc_size
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|asect
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|count
operator|=
name|reloc_size
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
expr_stmt|;
name|relocs
operator|=
name|bfd_malloc
argument_list|(
name|reloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relocs
operator|&&
name|reloc_size
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|amt
operator|=
operator|(
operator|(
name|bfd_size_type
operator|)
name|count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
expr_stmt|;
name|reloc_cache
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reloc_cache
condition|)
block|{
if|if
condition|(
name|relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|relocs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
name|relocs
argument_list|,
name|reloc_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|reloc_size
condition|)
block|{
name|free
argument_list|(
name|reloc_cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|relocs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/* Big-endian bit field allocation order.  */
name|pcrel_mask
operator|=
literal|0x80
expr_stmt|;
name|extern_mask
operator|=
literal|0x10
expr_stmt|;
name|incode_mask
operator|=
literal|0x08
expr_stmt|;
name|callj_mask
operator|=
literal|0x02
expr_stmt|;
name|size_mask
operator|=
literal|0x20
expr_stmt|;
name|length_shift
operator|=
literal|5
expr_stmt|;
block|}
else|else
block|{
comment|/* Little-endian bit field allocation order.  */
name|pcrel_mask
operator|=
literal|0x01
expr_stmt|;
name|extern_mask
operator|=
literal|0x08
expr_stmt|;
name|incode_mask
operator|=
literal|0x10
expr_stmt|;
name|callj_mask
operator|=
literal|0x40
expr_stmt|;
name|size_mask
operator|=
literal|0x02
expr_stmt|;
name|length_shift
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|rptr
operator|=
name|relocs
operator|,
name|cache_ptr
operator|=
name|reloc_cache
operator|,
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|count
condition|;
name|counter
operator|++
operator|,
name|rptr
operator|++
operator|,
name|cache_ptr
operator|++
control|)
block|{
name|unsigned
name|char
modifier|*
name|raw
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|rptr
decl_stmt|;
name|unsigned
name|int
name|symnum
decl_stmt|;
name|cache_ptr
operator|->
name|address
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|raw
operator|+
literal|0
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
name|symnum
operator|=
operator|(
name|raw
index|[
literal|4
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|raw
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|raw
index|[
literal|6
index|]
expr_stmt|;
else|else
name|symnum
operator|=
operator|(
name|raw
index|[
literal|6
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|raw
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|raw
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|raw
index|[
literal|7
index|]
operator|&
name|extern_mask
condition|)
block|{
comment|/* If this is set then the r_index is an index into the symbol table; 	   if the bit is not set then r_index contains a section map. 	   We either fill in the sym entry with a pointer to the symbol, 	   or point to the correct section.  */
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|=
name|symbols
operator|+
name|symnum
expr_stmt|;
name|cache_ptr
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* In a.out symbols are relative to the beginning of the 	   file rather than sections ? 	   (look in translate_from_native_sym_flags) 	   The reloc entry addend has added to it the offset into the 	   file of the data, so subtract the base to make the reloc 	   section relative.  */
name|int
name|s
decl_stmt|;
comment|/* Sign-extend symnum from 24 bits to whatever host uses.  */
name|s
operator|=
name|symnum
expr_stmt|;
if|if
condition|(
name|s
operator|&
operator|(
literal|1
operator|<<
literal|23
operator|)
condition|)
name|s
operator||=
operator|(
operator|~
literal|0
operator|)
operator|<<
literal|24
expr_stmt|;
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|N_TEXT
case|:
case|case
name|N_TEXT
operator||
name|N_EXT
case|:
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|cache_ptr
operator|->
name|addend
operator|=
operator|-
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
case|case
name|N_DATA
operator||
name|N_EXT
case|:
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|=
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|cache_ptr
operator|->
name|addend
operator|=
operator|-
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
case|case
name|N_BSS
operator||
name|N_EXT
case|:
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|cache_ptr
operator|->
name|addend
operator|=
operator|-
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|N_ABS
case|:
case|case
name|N_ABS
operator||
name|N_EXT
case|:
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|=
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|cache_ptr
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
break|break;
case|case
operator|-
literal|2
case|:
comment|/* .align */
if|if
condition|(
name|raw
index|[
literal|7
index|]
operator|&
name|pcrel_mask
condition|)
block|{
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|howto_align_table
index|[
operator|(
name|raw
index|[
literal|7
index|]
operator|>>
name|length_shift
operator|)
operator|&
literal|3
index|]
expr_stmt|;
name|cache_ptr
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
block|}
else|else
block|{
comment|/* .org? */
name|abort
argument_list|()
expr_stmt|;
block|}
name|cache_ptr
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|BFD_ASSERT
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* The i960 only has a few relocation types:        abs 32-bit and pcrel 24bit.   except for callj's!  */
if|if
condition|(
name|cache_ptr
operator|->
name|howto
operator|!=
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|raw
index|[
literal|7
index|]
operator|&
name|callj_mask
condition|)
block|{
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|howto_reloc_callj
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|raw
index|[
literal|7
index|]
operator|&
name|pcrel_mask
condition|)
block|{
if|if
condition|(
name|raw
index|[
literal|7
index|]
operator|&
name|size_mask
condition|)
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|howto_reloc_pcrel13
expr_stmt|;
else|else
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|howto_reloc_pcrel24
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|raw
index|[
literal|7
index|]
operator|&
name|incode_mask
condition|)
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|howto_reloc_abs32code
expr_stmt|;
else|else
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|howto_reloc_abs32
expr_stmt|;
block|}
if|if
condition|(
name|cache_ptr
operator|->
name|address
operator|<
name|prev_addr
condition|)
block|{
comment|/* Ouch! this reloc is out of order, insert into the right place.  */
name|arelent
name|tmp
decl_stmt|;
name|arelent
modifier|*
name|cursor
init|=
name|cache_ptr
operator|-
literal|1
decl_stmt|;
name|bfd_vma
name|stop
init|=
name|cache_ptr
operator|->
name|address
decl_stmt|;
name|tmp
operator|=
operator|*
name|cache_ptr
expr_stmt|;
while|while
condition|(
name|cursor
operator|->
name|address
operator|>
name|stop
operator|&&
name|cursor
operator|>=
name|reloc_cache
condition|)
block|{
name|cursor
index|[
literal|1
index|]
operator|=
name|cursor
index|[
literal|0
index|]
expr_stmt|;
name|cursor
operator|--
expr_stmt|;
block|}
name|cursor
index|[
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
block|}
else|else
name|prev_addr
operator|=
name|cache_ptr
operator|->
name|address
expr_stmt|;
block|}
if|if
condition|(
name|relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|relocs
argument_list|)
expr_stmt|;
name|asect
operator|->
name|relocation
operator|=
name|reloc_cache
expr_stmt|;
name|asect
operator|->
name|reloc_count
operator|=
name|count
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This is stupid.  This function should be a boolean predicate.  */
end_comment

begin_function
specifier|static
name|long
name|b_out_canonicalize_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|sec_ptr
name|section
parameter_list|,
name|arelent
modifier|*
modifier|*
name|relptr
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|)
block|{
name|arelent
modifier|*
name|tblptr
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_CONSTRUCTOR
operator|)
operator|!=
literal|0
condition|)
block|{
name|arelent_chain
modifier|*
name|chain
init|=
name|section
operator|->
name|constructor_chain
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|section
operator|->
name|reloc_count
condition|;
name|count
operator|++
control|)
block|{
operator|*
name|relptr
operator|++
operator|=
operator|&
name|chain
operator|->
name|relent
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|section
operator|->
name|relocation
operator|==
name|NULL
operator|&&
operator|!
name|b_out_slurp_reloc_table
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|tblptr
operator|=
name|section
operator|->
name|relocation
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|++
operator|<
name|section
operator|->
name|reloc_count
condition|;
control|)
operator|*
name|relptr
operator|++
operator|=
name|tblptr
operator|++
expr_stmt|;
block|}
operator|*
name|relptr
operator|=
name|NULL
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|b_out_get_reloc_upper_bound
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|sec_ptr
name|asect
parameter_list|)
block|{
if|if
condition|(
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_object
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|asect
operator|->
name|flags
operator|&
name|SEC_CONSTRUCTOR
condition|)
return|return
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
operator|*
operator|(
name|asect
operator|->
name|reloc_count
operator|+
literal|1
operator|)
return|;
if|if
condition|(
name|asect
operator|==
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|(
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
operator|*
operator|(
operator|(
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_drsize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
operator|)
operator|+
literal|1
operator|)
operator|)
return|;
if|if
condition|(
name|asect
operator|==
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|(
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
operator|*
operator|(
operator|(
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_trsize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
operator|)
operator|+
literal|1
operator|)
operator|)
return|;
if|if
condition|(
name|asect
operator|==
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
literal|0
return|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|bfd_boolean
name|b_out_set_section_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
specifier|const
name|void
modifier|*
name|location
parameter_list|,
name|file_ptr
name|offset
parameter_list|,
name|bfd_size_type
name|count
parameter_list|)
block|{
if|if
condition|(
operator|!
name|abfd
operator|->
name|output_has_begun
condition|)
block|{
comment|/* Set by bfd.c handler.  */
if|if
condition|(
operator|!
name|aout_32_make_sections
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|external_exec
argument_list|)
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|+
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|size
expr_stmt|;
block|}
comment|/* Regardless, once we know what we're doing, we might as well get going.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|filepos
operator|+
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
return|return
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|location
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|==
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|b_out_set_arch_mach
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|enum
name|bfd_architecture
name|arch
parameter_list|,
name|unsigned
name|long
name|machine
parameter_list|)
block|{
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch
operator|==
name|bfd_arch_unknown
condition|)
comment|/* Unknown machine arch is OK.  */
return|return
name|TRUE
return|;
if|if
condition|(
name|arch
operator|==
name|bfd_arch_i960
condition|)
comment|/* i960 default is OK.  */
switch|switch
condition|(
name|machine
condition|)
block|{
case|case
name|bfd_mach_i960_core
case|:
case|case
name|bfd_mach_i960_kb_sb
case|:
case|case
name|bfd_mach_i960_mc
case|:
case|case
name|bfd_mach_i960_xa
case|:
case|case
name|bfd_mach_i960_ca
case|:
case|case
name|bfd_mach_i960_ka_sa
case|:
case|case
name|bfd_mach_i960_jx
case|:
case|case
name|bfd_mach_i960_hx
case|:
case|case
literal|0
case|:
return|return
name|TRUE
return|;
default|default:
return|return
name|FALSE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|b_out_sizeof_headers
parameter_list|(
name|bfd
modifier|*
name|ignore_abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|external_exec
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|perform_slip
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|int
name|slip
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_vma
name|value
parameter_list|)
block|{
name|asymbol
modifier|*
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|_bfd_generic_link_get_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* Find all symbols past this point, and make them know      what's happened.  */
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|asymbol
modifier|*
name|p
init|=
operator|*
name|s
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|section
operator|==
name|input_section
condition|)
block|{
comment|/* This was pointing into this section, so mangle it.  */
if|if
condition|(
name|p
operator|->
name|value
operator|>
name|value
condition|)
block|{
name|p
operator|->
name|value
operator|-=
name|slip
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|udata
operator|.
name|p
operator|!=
name|NULL
condition|)
block|{
name|struct
name|generic_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|(
expr|struct
name|generic_link_hash_entry
operator|*
operator|)
name|p
operator|->
name|udata
operator|.
name|p
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|-=
name|slip
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|==
name|p
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|s
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine works out if the thing we want to get to can be    reached with a 24bit offset instead of a 32 bit one.    If it can, then it changes the amode.  */
end_comment

begin_function
specifier|static
name|int
name|abs32code
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|arelent
modifier|*
name|r
parameter_list|,
name|unsigned
name|int
name|shrink
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|)
block|{
name|bfd_vma
name|value
init|=
name|get_value
argument_list|(
name|r
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
decl_stmt|;
name|bfd_vma
name|dot
init|=
name|output_addr
argument_list|(
name|input_section
argument_list|)
operator|+
name|r
operator|->
name|address
decl_stmt|;
name|bfd_vma
name|gap
decl_stmt|;
comment|/* See if the address we're looking at within 2^23 bytes of where      we are, if so then we can use a small branch rather than the      jump we were going to.  */
name|gap
operator|=
name|value
operator|-
operator|(
name|dot
operator|-
name|shrink
operator|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|<<
literal|23
operator|<
operator|(
name|long
operator|)
name|gap
operator|&&
operator|(
name|long
operator|)
name|gap
operator|<
literal|1
operator|<<
literal|23
condition|)
block|{
comment|/* Change the reloc type from 32bitcode possible 24, to 24bit 	 possible 32.  */
name|r
operator|->
name|howto
operator|=
operator|&
name|howto_reloc_abs32codeshrunk
expr_stmt|;
comment|/* The place to relc moves back by four bytes.  */
name|r
operator|->
name|address
operator|-=
literal|4
expr_stmt|;
comment|/* This will be four bytes smaller in the long run.  */
name|shrink
operator|+=
literal|4
expr_stmt|;
name|perform_slip
argument_list|(
name|abfd
argument_list|,
literal|4
argument_list|,
name|input_section
argument_list|,
name|r
operator|->
name|address
operator|-
name|shrink
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
name|shrink
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aligncode
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|arelent
modifier|*
name|r
parameter_list|,
name|unsigned
name|int
name|shrink
parameter_list|)
block|{
name|bfd_vma
name|dot
init|=
name|output_addr
argument_list|(
name|input_section
argument_list|)
operator|+
name|r
operator|->
name|address
decl_stmt|;
name|bfd_vma
name|gap
decl_stmt|;
name|bfd_vma
name|old_end
decl_stmt|;
name|bfd_vma
name|new_end
decl_stmt|;
name|unsigned
name|int
name|shrink_delta
decl_stmt|;
name|int
name|size
init|=
name|r
operator|->
name|howto
operator|->
name|size
decl_stmt|;
comment|/* Reduce the size of the alignment so that it's still aligned but      smaller  - the current size is already the same size as or bigger      than the alignment required.  */
comment|/* Calculate the first byte following the padding before we optimize.  */
name|old_end
operator|=
operator|(
operator|(
name|dot
operator|+
name|size
operator|)
operator|&
operator|~
name|size
operator|)
operator|+
name|size
operator|+
literal|1
expr_stmt|;
comment|/* Work out where the new end will be - remember that we're smaller      than we used to be.  */
name|new_end
operator|=
operator|(
operator|(
name|dot
operator|-
name|shrink
operator|+
name|size
operator|)
operator|&
operator|~
name|size
operator|)
expr_stmt|;
comment|/* This is the new end.  */
name|gap
operator|=
name|old_end
operator|-
operator|(
operator|(
name|dot
operator|+
name|size
operator|)
operator|&
operator|~
name|size
operator|)
expr_stmt|;
name|shrink_delta
operator|=
operator|(
name|old_end
operator|-
name|new_end
operator|)
operator|-
name|shrink
expr_stmt|;
if|if
condition|(
name|shrink_delta
condition|)
block|{
comment|/* Change the reloc so that it knows how far to align to.  */
name|r
operator|->
name|howto
operator|=
name|howto_done_align_table
operator|+
operator|(
name|r
operator|->
name|howto
operator|-
name|howto_align_table
operator|)
expr_stmt|;
comment|/* Encode the stuff into the addend - for future use we need to 	 know how big the reloc used to be.  */
name|r
operator|->
name|addend
operator|=
name|old_end
operator|-
name|dot
operator|+
name|r
operator|->
name|address
expr_stmt|;
comment|/* This will be N bytes smaller in the long run, adjust all the symbols.  */
name|perform_slip
argument_list|(
name|abfd
argument_list|,
name|shrink_delta
argument_list|,
name|input_section
argument_list|,
name|r
operator|->
name|address
operator|-
name|shrink
argument_list|)
expr_stmt|;
name|shrink
operator|+=
name|shrink_delta
expr_stmt|;
block|}
return|return
name|shrink
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|b_out_bfd_relax_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|i
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|bfd_boolean
modifier|*
name|again
parameter_list|)
block|{
comment|/* Get enough memory to hold the stuff.  */
name|bfd
modifier|*
name|input_bfd
init|=
name|i
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
name|input_section
init|=
name|i
decl_stmt|;
name|unsigned
name|int
name|shrink
init|=
literal|0
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|reloc_vector
init|=
name|NULL
decl_stmt|;
name|long
name|reloc_size
init|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
decl_stmt|;
if|if
condition|(
name|reloc_size
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* We only run this relaxation once.  It might work to run it      multiple times, but it hasn't been tested.  */
operator|*
name|again
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|reloc_size
condition|)
block|{
name|long
name|reloc_count
decl_stmt|;
name|reloc_vector
operator|=
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|reloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_vector
operator|==
name|NULL
operator|&&
name|reloc_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* Get the relocs and think about them.  */
name|reloc_count
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|reloc_vector
argument_list|,
name|_bfd_generic_link_get_symbols
argument_list|(
name|input_bfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_count
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|arelent
modifier|*
modifier|*
name|parent
decl_stmt|;
for|for
control|(
name|parent
operator|=
name|reloc_vector
init|;
operator|*
name|parent
condition|;
name|parent
operator|++
control|)
block|{
name|arelent
modifier|*
name|r
init|=
operator|*
name|parent
decl_stmt|;
switch|switch
condition|(
name|r
operator|->
name|howto
operator|->
name|type
condition|)
block|{
case|case
name|ALIGNER
case|:
comment|/* An alignment reloc.  */
name|shrink
operator|=
name|aligncode
argument_list|(
name|abfd
argument_list|,
name|input_section
argument_list|,
name|r
argument_list|,
name|shrink
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS32CODE
case|:
comment|/* A 32bit reloc in an addressing mode.  */
name|shrink
operator|=
name|abs32code
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|r
argument_list|,
name|shrink
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS32CODE_SHRUNK
case|:
name|shrink
operator|+=
literal|4
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|input_section
operator|->
name|size
operator|-=
name|shrink
expr_stmt|;
if|if
condition|(
name|reloc_vector
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|reloc_vector
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|reloc_vector
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|reloc_vector
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_byte
modifier|*
name|b_out_bfd_get_relocated_section_contents
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|struct
name|bfd_link_order
modifier|*
name|link_order
parameter_list|,
name|bfd_byte
modifier|*
name|data
parameter_list|,
name|bfd_boolean
name|relocatable
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|)
block|{
comment|/* Get enough memory to hold the stuff.  */
name|bfd
modifier|*
name|input_bfd
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
name|input_section
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
name|long
name|reloc_size
init|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|reloc_vector
init|=
name|NULL
decl_stmt|;
name|long
name|reloc_count
decl_stmt|;
if|if
condition|(
name|reloc_size
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* If producing relocatable output, don't bother to relax.  */
if|if
condition|(
name|relocatable
condition|)
return|return
name|bfd_generic_get_relocated_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|link_info
argument_list|,
name|link_order
argument_list|,
name|data
argument_list|,
name|relocatable
argument_list|,
name|symbols
argument_list|)
return|;
name|reloc_vector
operator|=
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|reloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_vector
operator|==
name|NULL
operator|&&
name|reloc_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* Read in the section.  */
name|BFD_ASSERT
argument_list|(
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|data
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_section
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|reloc_count
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|reloc_vector
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_count
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|arelent
modifier|*
modifier|*
name|parent
init|=
name|reloc_vector
decl_stmt|;
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|unsigned
name|int
name|dst_address
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|src_address
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|run
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
comment|/* Find how long a run we can do.  */
while|while
condition|(
name|dst_address
operator|<
name|link_order
operator|->
name|size
condition|)
block|{
name|reloc
operator|=
operator|*
name|parent
expr_stmt|;
if|if
condition|(
name|reloc
condition|)
block|{
comment|/* Note that the relaxing didn't tie up the addresses in the 		 relocation, so we use the original address to work out the 		 run of non-relocated data.  */
name|BFD_ASSERT
argument_list|(
name|reloc
operator|->
name|address
operator|>=
name|src_address
argument_list|)
expr_stmt|;
name|run
operator|=
name|reloc
operator|->
name|address
operator|-
name|src_address
expr_stmt|;
name|parent
operator|++
expr_stmt|;
block|}
else|else
name|run
operator|=
name|link_order
operator|->
name|size
operator|-
name|dst_address
expr_stmt|;
comment|/* Copy the bytes.  */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|run
condition|;
name|idx
operator|++
control|)
name|data
index|[
name|dst_address
operator|++
index|]
operator|=
name|data
index|[
name|src_address
operator|++
index|]
expr_stmt|;
comment|/* Now do the relocation.  */
if|if
condition|(
name|reloc
condition|)
block|{
switch|switch
condition|(
name|reloc
operator|->
name|howto
operator|->
name|type
condition|)
block|{
case|case
name|ABS32CODE
case|:
name|calljx_callback
argument_list|(
name|input_bfd
argument_list|,
name|link_info
argument_list|,
name|reloc
argument_list|,
name|src_address
operator|+
name|data
argument_list|,
name|dst_address
operator|+
name|data
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|src_address
operator|+=
literal|4
expr_stmt|;
name|dst_address
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|ABS32
case|:
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|data
operator|+
name|src_address
argument_list|)
operator|+
name|get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
operator|)
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
name|src_address
operator|+=
literal|4
expr_stmt|;
name|dst_address
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|CALLJ
case|:
name|callj_callback
argument_list|(
name|input_bfd
argument_list|,
name|link_info
argument_list|,
name|reloc
argument_list|,
name|data
argument_list|,
name|src_address
argument_list|,
name|dst_address
argument_list|,
name|input_section
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|src_address
operator|+=
literal|4
expr_stmt|;
name|dst_address
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|ALIGNDONE
case|:
name|BFD_ASSERT
argument_list|(
name|reloc
operator|->
name|addend
operator|>=
name|src_address
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|bfd_vma
operator|)
name|reloc
operator|->
name|addend
operator|<=
name|input_section
operator|->
name|size
argument_list|)
expr_stmt|;
name|src_address
operator|=
name|reloc
operator|->
name|addend
expr_stmt|;
name|dst_address
operator|=
operator|(
operator|(
name|dst_address
operator|+
name|reloc
operator|->
name|howto
operator|->
name|size
operator|)
operator|&
operator|~
name|reloc
operator|->
name|howto
operator|->
name|size
operator|)
expr_stmt|;
break|break;
case|case
name|ABS32CODE_SHRUNK
case|:
comment|/* This used to be a callx, but we've found out that a 		     callj will reach, so do the right thing.  */
name|callj_callback
argument_list|(
name|input_bfd
argument_list|,
name|link_info
argument_list|,
name|reloc
argument_list|,
name|data
argument_list|,
name|src_address
operator|+
literal|4
argument_list|,
name|dst_address
argument_list|,
name|input_section
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|dst_address
operator|+=
literal|4
expr_stmt|;
name|src_address
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|PCREL24
case|:
block|{
name|long
name|int
name|word
init|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|data
operator|+
name|src_address
argument_list|)
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|value
operator|=
name|get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|word
operator|=
operator|(
operator|(
name|word
operator|&
operator|~
name|BAL_MASK
operator|)
operator||
operator|(
operator|(
operator|(
name|word
operator|&
name|BAL_MASK
operator|)
operator|+
name|value
operator|-
name|output_addr
argument_list|(
name|input_section
argument_list|)
operator|+
name|reloc
operator|->
name|addend
operator|)
operator|&
name|BAL_MASK
operator|)
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|word
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
name|dst_address
operator|+=
literal|4
expr_stmt|;
name|src_address
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
case|case
name|PCREL13
case|:
block|{
name|long
name|int
name|word
init|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|data
operator|+
name|src_address
argument_list|)
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|value
operator|=
name|get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|word
operator|=
operator|(
operator|(
name|word
operator|&
operator|~
name|PCREL13_MASK
operator|)
operator||
operator|(
operator|(
operator|(
name|word
operator|&
name|PCREL13_MASK
operator|)
operator|+
name|value
operator|+
name|reloc
operator|->
name|addend
operator|-
name|output_addr
argument_list|(
name|input_section
argument_list|)
operator|)
operator|&
name|PCREL13_MASK
operator|)
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|word
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
name|dst_address
operator|+=
literal|4
expr_stmt|;
name|src_address
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|reloc_vector
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|reloc_vector
argument_list|)
expr_stmt|;
return|return
name|data
return|;
name|error_return
label|:
if|if
condition|(
name|reloc_vector
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|reloc_vector
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build the transfer vectors for Big and Little-Endian B.OUT files.  */
end_comment

begin_define
define|#
directive|define
name|aout_32_bfd_make_debug_symbol
value|_bfd_nosymbols_bfd_make_debug_symbol
end_define

begin_define
define|#
directive|define
name|aout_32_close_and_cleanup
value|aout_32_bfd_free_cached_info
end_define

begin_define
define|#
directive|define
name|b_out_bfd_link_hash_table_create
value|_bfd_generic_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|b_out_bfd_link_hash_table_free
value|_bfd_generic_link_hash_table_free
end_define

begin_define
define|#
directive|define
name|b_out_bfd_link_add_symbols
value|_bfd_generic_link_add_symbols
end_define

begin_define
define|#
directive|define
name|b_out_bfd_link_just_syms
value|_bfd_generic_link_just_syms
end_define

begin_define
define|#
directive|define
name|b_out_bfd_final_link
value|_bfd_generic_final_link
end_define

begin_define
define|#
directive|define
name|b_out_bfd_link_split_section
value|_bfd_generic_link_split_section
end_define

begin_define
define|#
directive|define
name|b_out_bfd_gc_sections
value|bfd_generic_gc_sections
end_define

begin_define
define|#
directive|define
name|b_out_bfd_merge_sections
value|bfd_generic_merge_sections
end_define

begin_define
define|#
directive|define
name|b_out_bfd_is_group_section
value|bfd_generic_is_group_section
end_define

begin_define
define|#
directive|define
name|b_out_bfd_discard_group
value|bfd_generic_discard_group
end_define

begin_define
define|#
directive|define
name|b_out_section_already_linked
value|_bfd_generic_section_already_linked
end_define

begin_define
define|#
directive|define
name|aout_32_get_section_contents_in_window
value|_bfd_generic_get_section_contents_in_window
end_define

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
name|b_out_vec_little_host
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|bfd_target
name|b_out_vec_big_host
init|=
block|{
literal|"b.out.big"
block|,
comment|/* Name.  */
name|bfd_target_aout_flavour
block|,
name|BFD_ENDIAN_LITTLE
block|,
comment|/* Data byte order.  */
name|BFD_ENDIAN_BIG
block|,
comment|/* Header byte order.  */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* Object flags.  */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|BFD_IS_RELAXABLE
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_CODE
operator||
name|SEC_DATA
operator|)
block|,
literal|'_'
block|,
comment|/* Symbol leading char.  */
literal|' '
block|,
comment|/* AR_pad_char.  */
literal|16
block|,
comment|/* AR_max_namelen.  */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* Data.  */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* Headers.  */
block|{
name|_bfd_dummy_target
block|,
name|b_out_object_p
block|,
comment|/* bfd_check_format.  */
name|bfd_generic_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|b_out_mkobject
block|,
comment|/* bfd_set_format.  */
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|b_out_write_object_contents
block|,
comment|/* bfd_write_contents.  */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|aout_32
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_archive_bsd
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|aout_32
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|b_out
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|b_out
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|b_out
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
operator|&
name|b_out_vec_little_host
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|bfd_target
name|b_out_vec_little_host
init|=
block|{
literal|"b.out.little"
block|,
comment|/* Name.  */
name|bfd_target_aout_flavour
block|,
name|BFD_ENDIAN_LITTLE
block|,
comment|/* Data byte order.  */
name|BFD_ENDIAN_LITTLE
block|,
comment|/* Header byte order.  */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* Object flags.  */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|BFD_IS_RELAXABLE
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_CODE
operator||
name|SEC_DATA
operator|)
block|,
literal|'_'
block|,
comment|/* Symbol leading char.  */
literal|' '
block|,
comment|/* AR_pad_char.  */
literal|16
block|,
comment|/* AR_max_namelen.  */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* Data.  */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* Headers.  */
block|{
name|_bfd_dummy_target
block|,
name|b_out_object_p
block|,
comment|/* bfd_check_format.  */
name|bfd_generic_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|b_out_mkobject
block|,
comment|/* bfd_set_format.  */
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|b_out_write_object_contents
block|,
comment|/* bfd_write_contents.  */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|aout_32
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_archive_bsd
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|aout_32
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|b_out
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|b_out
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|b_out
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
operator|&
name|b_out_vec_big_host
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

end_unit

