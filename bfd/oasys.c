begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for oasys objects.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2001,    2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Written by Steve Chamberlain of Cygnus Support,<sac@cygnus.com>.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_define
define|#
directive|define
name|UNDERSCORE_HACK
value|1
end_define

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"oasys.h"
end_include

begin_include
include|#
directive|include
file|"liboasys.h"
end_include

begin_comment
comment|/* Read in all the section data and relocation stuff too.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|oasys_read_record
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|oasys_record_union_type
modifier|*
name|record
parameter_list|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|record
operator|->
name|header
argument_list|)
decl_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
name|record
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
name|amt
operator|=
name|record
operator|->
name|header
operator|.
name|length
operator|-
sizeof|sizeof
argument_list|(
name|record
operator|->
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|amt
operator|<=
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|record
operator|+
sizeof|sizeof
argument_list|(
name|record
operator|->
name|header
argument_list|)
operator|)
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|oasys_string_length
parameter_list|(
name|oasys_record_union_type
modifier|*
name|record
parameter_list|)
block|{
return|return
name|record
operator|->
name|header
operator|.
name|length
operator|-
operator|(
operator|(
name|char
operator|*
operator|)
name|record
operator|->
name|symbol
operator|.
name|name
operator|-
operator|(
name|char
operator|*
operator|)
name|record
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Slurp the symbol table by reading in all the records at the start file    till we get to the first section record.     We'll sort the symbolss into  two lists, defined and undefined. The    undefined symbols will be placed into the table according to their    refno.     We do this by placing all undefined symbols at the front of the table    moving in, and the defined symbols at the end of the table moving back.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|oasys_slurp_symbol_table
parameter_list|(
name|bfd
modifier|*
specifier|const
name|abfd
parameter_list|)
block|{
name|oasys_record_union_type
name|record
decl_stmt|;
name|oasys_data_type
modifier|*
name|data
init|=
name|OASYS_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|bfd_boolean
name|loop
init|=
name|TRUE
decl_stmt|;
name|asymbol
modifier|*
name|dest_defined
decl_stmt|;
name|asymbol
modifier|*
name|dest
decl_stmt|;
name|char
modifier|*
name|string_ptr
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|symbols
operator|!=
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* Buy enough memory for all the symbols and all the names.  */
name|amt
operator|=
name|abfd
operator|->
name|symcount
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
expr_stmt|;
name|data
operator|->
name|symbols
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|amt
operator|=
name|data
operator|->
name|symbol_string_length
expr_stmt|;
ifdef|#
directive|ifdef
name|UNDERSCORE_HACK
comment|/* Buy 1 more char for each symbol to keep the underscore in.  */
name|amt
operator|+=
name|abfd
operator|->
name|symcount
expr_stmt|;
endif|#
directive|endif
name|data
operator|->
name|strings
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|symbols
operator|||
operator|!
name|data
operator|->
name|strings
condition|)
return|return
name|FALSE
return|;
name|dest_defined
operator|=
name|data
operator|->
name|symbols
operator|+
name|abfd
operator|->
name|symcount
operator|-
literal|1
expr_stmt|;
name|string_ptr
operator|=
name|data
operator|->
name|strings
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
while|while
condition|(
name|loop
condition|)
block|{
if|if
condition|(
operator|!
name|oasys_read_record
argument_list|(
name|abfd
argument_list|,
operator|&
name|record
argument_list|)
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|record
operator|.
name|header
operator|.
name|type
condition|)
block|{
case|case
name|oasys_record_is_header_enum
case|:
break|break;
case|case
name|oasys_record_is_local_enum
case|:
case|case
name|oasys_record_is_symbol_enum
case|:
block|{
name|int
name|flag
init|=
name|record
operator|.
name|header
operator|.
name|type
operator|==
operator|(
name|int
operator|)
name|oasys_record_is_local_enum
condition|?
operator|(
name|BSF_LOCAL
operator|)
else|:
operator|(
name|BSF_GLOBAL
operator||
name|BSF_EXPORT
operator|)
decl_stmt|;
name|size_t
name|length
init|=
name|oasys_string_length
argument_list|(
operator|&
name|record
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|record
operator|.
name|symbol
operator|.
name|relb
operator|&
name|RELOCATION_TYPE_BITS
condition|)
block|{
case|case
name|RELOCATION_TYPE_ABS
case|:
name|dest
operator|=
name|dest_defined
operator|--
expr_stmt|;
name|dest
operator|->
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|dest
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RELOCATION_TYPE_REL
case|:
name|dest
operator|=
name|dest_defined
operator|--
expr_stmt|;
name|dest
operator|->
name|section
operator|=
name|OASYS_DATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|sections
index|[
name|record
operator|.
name|symbol
operator|.
name|relb
operator|&
name|RELOCATION_SECT_BITS
index|]
expr_stmt|;
if|if
condition|(
name|record
operator|.
name|header
operator|.
name|type
operator|==
operator|(
name|int
operator|)
name|oasys_record_is_local_enum
condition|)
block|{
name|dest
operator|->
name|flags
operator|=
name|BSF_LOCAL
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|section
operator|==
operator|(
name|asection
operator|*
operator|)
operator|(
operator|~
literal|0
operator|)
condition|)
block|{
comment|/* It seems that sometimes internal symbols are tied up, but 		       still get output, even though there is no 		       section */
name|dest
operator|->
name|section
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|dest
operator|->
name|flags
operator|=
name|flag
expr_stmt|;
break|break;
case|case
name|RELOCATION_TYPE_UND
case|:
name|dest
operator|=
name|data
operator|->
name|symbols
operator|+
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|record
operator|.
name|symbol
operator|.
name|refno
argument_list|)
expr_stmt|;
name|dest
operator|->
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
break|break;
case|case
name|RELOCATION_TYPE_COM
case|:
name|dest
operator|=
name|dest_defined
operator|--
expr_stmt|;
name|dest
operator|->
name|name
operator|=
name|string_ptr
expr_stmt|;
name|dest
operator|->
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|dest
operator|->
name|section
operator|=
name|bfd_com_section_ptr
expr_stmt|;
break|break;
default|default:
name|dest
operator|=
name|dest_defined
operator|--
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
name|dest
operator|->
name|name
operator|=
name|string_ptr
expr_stmt|;
name|dest
operator|->
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|dest
operator|->
name|udata
operator|.
name|p
operator|=
name|NULL
expr_stmt|;
name|dest
operator|->
name|value
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|record
operator|.
name|symbol
operator|.
name|value
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNDERSCORE_HACK
if|if
condition|(
name|record
operator|.
name|symbol
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'_'
condition|)
block|{
name|string_ptr
index|[
literal|0
index|]
operator|=
literal|'_'
expr_stmt|;
name|string_ptr
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
name|memcpy
argument_list|(
name|string_ptr
argument_list|,
name|record
operator|.
name|symbol
operator|.
name|name
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|string_ptr
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|string_ptr
operator|+=
name|length
operator|+
literal|1
expr_stmt|;
block|}
break|break;
default|default:
name|loop
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|oasys_get_symtab_upper_bound
parameter_list|(
name|bfd
modifier|*
specifier|const
name|abfd
parameter_list|)
block|{
if|if
condition|(
operator|!
name|oasys_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|abfd
operator|->
name|symcount
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|oasys_symbol_type
operator|*
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
name|oasys_vec
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|long
name|oasys_canonicalize_symtab
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|location
parameter_list|)
block|{
name|asymbol
modifier|*
name|symbase
decl_stmt|;
name|unsigned
name|int
name|counter
decl_stmt|;
if|if
condition|(
operator|!
name|oasys_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|symbase
operator|=
name|OASYS_DATA
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbols
expr_stmt|;
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|abfd
operator|->
name|symcount
condition|;
name|counter
operator|++
control|)
operator|*
operator|(
name|location
operator|++
operator|)
operator|=
name|symbase
operator|++
expr_stmt|;
operator|*
name|location
operator|=
literal|0
expr_stmt|;
return|return
name|abfd
operator|->
name|symcount
return|;
block|}
end_function

begin_comment
comment|/* Archive stuff.  */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|oasys_archive_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|oasys_archive_header_type
name|header
decl_stmt|;
name|oasys_extarchive_header_type
name|header_ext
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|file_ptr
name|filepos
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|header_ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|header_ext
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|header
operator|.
name|version
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|header_ext
operator|.
name|version
argument_list|)
expr_stmt|;
name|header
operator|.
name|mod_count
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|header_ext
operator|.
name|mod_count
argument_list|)
expr_stmt|;
name|header
operator|.
name|mod_tbl_offset
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|header_ext
operator|.
name|mod_tbl_offset
argument_list|)
expr_stmt|;
name|header
operator|.
name|sym_tbl_size
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|header_ext
operator|.
name|sym_tbl_size
argument_list|)
expr_stmt|;
name|header
operator|.
name|sym_count
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|header_ext
operator|.
name|sym_count
argument_list|)
expr_stmt|;
name|header
operator|.
name|sym_tbl_offset
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|header_ext
operator|.
name|sym_tbl_offset
argument_list|)
expr_stmt|;
name|header
operator|.
name|xref_count
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|header_ext
operator|.
name|xref_count
argument_list|)
expr_stmt|;
name|header
operator|.
name|xref_lst_offset
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|header_ext
operator|.
name|xref_lst_offset
argument_list|)
expr_stmt|;
comment|/* There isn't a magic number in an Oasys archive, so the best we      can do to verify reasonableness is to make sure that the values in      the header are too weird.  */
if|if
condition|(
name|header
operator|.
name|version
operator|>
literal|10000
operator|||
name|header
operator|.
name|mod_count
operator|>
literal|10000
operator|||
name|header
operator|.
name|sym_count
operator|>
literal|100000
operator|||
name|header
operator|.
name|xref_count
operator|>
literal|100000
condition|)
return|return
name|NULL
return|;
comment|/* That all worked, let's buy the space for the header and read in      the headers.  */
block|{
name|oasys_ar_data_type
modifier|*
name|ar
decl_stmt|;
name|oasys_module_info_type
modifier|*
name|module
decl_stmt|;
name|oasys_module_table_type
name|record
decl_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|oasys_ar_data_type
argument_list|)
expr_stmt|;
name|ar
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|amt
operator|=
name|header
operator|.
name|mod_count
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|oasys_module_info_type
argument_list|)
expr_stmt|;
name|module
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ar
operator|||
operator|!
name|module
condition|)
return|return
name|NULL
return|;
name|abfd
operator|->
name|tdata
operator|.
name|oasys_ar_data
operator|=
name|ar
expr_stmt|;
name|ar
operator|->
name|module
operator|=
name|module
expr_stmt|;
name|ar
operator|->
name|module_count
operator|=
name|header
operator|.
name|mod_count
expr_stmt|;
name|filepos
operator|=
name|header
operator|.
name|mod_tbl_offset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|header
operator|.
name|mod_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* There are two ways of specifying the archive header.  */
block|{
name|oasys_extmodule_table_type_b_type
name|record_ext
decl_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|record_ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|record_ext
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|NULL
return|;
name|record
operator|.
name|mod_size
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|record_ext
operator|.
name|mod_size
argument_list|)
expr_stmt|;
name|record
operator|.
name|file_offset
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|record_ext
operator|.
name|file_offset
argument_list|)
expr_stmt|;
name|record
operator|.
name|dep_count
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|record_ext
operator|.
name|dep_count
argument_list|)
expr_stmt|;
name|record
operator|.
name|depee_count
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|record_ext
operator|.
name|depee_count
argument_list|)
expr_stmt|;
name|record
operator|.
name|sect_count
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|record_ext
operator|.
name|sect_count
argument_list|)
expr_stmt|;
name|record
operator|.
name|module_name_size
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|record_ext
operator|.
name|mod_name_length
argument_list|)
expr_stmt|;
name|amt
operator|=
name|record
operator|.
name|module_name_size
expr_stmt|;
name|module
index|[
name|i
index|]
operator|.
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|module
index|[
name|i
index|]
operator|.
name|name
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
name|module
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|NULL
return|;
name|module
index|[
name|i
index|]
operator|.
name|name
index|[
name|record
operator|.
name|module_name_size
index|]
operator|=
literal|0
expr_stmt|;
name|filepos
operator|+=
operator|(
sizeof|sizeof
argument_list|(
name|record_ext
argument_list|)
operator|+
name|record
operator|.
name|dep_count
operator|*
literal|4
operator|+
name|record
operator|.
name|module_name_size
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|module
index|[
name|i
index|]
operator|.
name|size
operator|=
name|record
operator|.
name|mod_size
expr_stmt|;
name|module
index|[
name|i
index|]
operator|.
name|pos
operator|=
name|record
operator|.
name|file_offset
expr_stmt|;
name|module
index|[
name|i
index|]
operator|.
name|abfd
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|oasys_mkobject
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|oasys_data_type
argument_list|)
decl_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|oasys_obj_data
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
return|return
name|abfd
operator|->
name|tdata
operator|.
name|oasys_obj_data
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* The howto table is build using the top two bits of a reloc byte to    index into it. The bits are PCREL,WORD/LONG.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"abs16"
argument_list|,
name|TRUE
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"abs32"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"pcrel16"
argument_list|,
name|TRUE
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
argument|TRUE
argument_list|,
literal|0
argument_list|,
argument|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"pcrel32"
argument_list|,
argument|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
argument|FALSE
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read in all the section data and relocation stuff too.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|oasys_slurp_section_data
parameter_list|(
name|bfd
modifier|*
specifier|const
name|abfd
parameter_list|)
block|{
name|oasys_record_union_type
name|record
decl_stmt|;
name|oasys_data_type
modifier|*
name|data
init|=
name|OASYS_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|bfd_boolean
name|loop
init|=
name|TRUE
decl_stmt|;
name|oasys_per_section_type
modifier|*
name|per
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* See if the data has been slurped already.  */
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|per
operator|=
name|oasys_per_section
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|per
operator|->
name|initialized
condition|)
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|data
operator|->
name|first_data_record
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|data
operator|->
name|first_data_record
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
while|while
condition|(
name|loop
condition|)
block|{
if|if
condition|(
operator|!
name|oasys_read_record
argument_list|(
name|abfd
argument_list|,
operator|&
name|record
argument_list|)
condition|)
return|return
name|FALSE
return|;
switch|switch
condition|(
name|record
operator|.
name|header
operator|.
name|type
condition|)
block|{
case|case
name|oasys_record_is_header_enum
case|:
break|break;
case|case
name|oasys_record_is_data_enum
case|:
block|{
name|bfd_byte
modifier|*
name|src
init|=
name|record
operator|.
name|data
operator|.
name|data
decl_stmt|;
name|bfd_byte
modifier|*
name|end_src
init|=
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
operator|&
name|record
operator|)
operator|+
name|record
operator|.
name|header
operator|.
name|length
decl_stmt|;
name|bfd_byte
modifier|*
name|dst_ptr
decl_stmt|;
name|bfd_byte
modifier|*
name|dst_base_ptr
decl_stmt|;
name|unsigned
name|int
name|relbit
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|asection
modifier|*
name|section
init|=
name|data
operator|->
name|sections
index|[
name|record
operator|.
name|data
operator|.
name|relb
operator|&
name|RELOCATION_SECT_BITS
index|]
decl_stmt|;
name|bfd_vma
name|dst_offset
decl_stmt|;
name|per
operator|=
name|oasys_per_section
argument_list|(
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|per
operator|->
name|initialized
condition|)
block|{
name|arelent
modifier|*
modifier|*
name|relpp
decl_stmt|;
name|per
operator|->
name|data
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|per
operator|->
name|data
condition|)
return|return
name|FALSE
return|;
name|relpp
operator|=
operator|&
name|section
operator|->
name|relocation
expr_stmt|;
name|per
operator|->
name|reloc_tail_ptr
operator|=
operator|(
name|oasys_reloc_type
operator|*
operator|*
operator|)
name|relpp
expr_stmt|;
name|per
operator|->
name|had_vma
operator|=
name|FALSE
expr_stmt|;
name|per
operator|->
name|initialized
operator|=
name|TRUE
expr_stmt|;
name|section
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|section
operator|->
name|flags
operator|=
name|SEC_ALLOC
expr_stmt|;
block|}
name|dst_offset
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|record
operator|.
name|data
operator|.
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|per
operator|->
name|had_vma
condition|)
block|{
comment|/* Take the first vma we see as the base.  */
name|section
operator|->
name|vma
operator|=
name|dst_offset
expr_stmt|;
name|per
operator|->
name|had_vma
operator|=
name|TRUE
expr_stmt|;
block|}
name|dst_offset
operator|-=
name|section
operator|->
name|vma
expr_stmt|;
name|dst_base_ptr
operator|=
name|oasys_per_section
argument_list|(
name|section
argument_list|)
operator|->
name|data
expr_stmt|;
name|dst_ptr
operator|=
name|oasys_per_section
argument_list|(
name|section
argument_list|)
operator|->
name|data
operator|+
name|dst_offset
expr_stmt|;
if|if
condition|(
name|src
operator|<
name|end_src
condition|)
name|section
operator|->
name|flags
operator||=
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
expr_stmt|;
while|while
condition|(
name|src
operator|<
name|end_src
condition|)
block|{
name|unsigned
name|char
name|mod_byte
init|=
operator|*
name|src
operator|++
decl_stmt|;
name|size_t
name|gap
init|=
name|end_src
operator|-
name|src
decl_stmt|;
name|count
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|mod_byte
operator|==
literal|0
operator|&&
name|gap
operator|>=
literal|8
condition|)
block|{
name|dst_ptr
index|[
literal|0
index|]
operator|=
name|src
index|[
literal|0
index|]
expr_stmt|;
name|dst_ptr
index|[
literal|1
index|]
operator|=
name|src
index|[
literal|1
index|]
expr_stmt|;
name|dst_ptr
index|[
literal|2
index|]
operator|=
name|src
index|[
literal|2
index|]
expr_stmt|;
name|dst_ptr
index|[
literal|3
index|]
operator|=
name|src
index|[
literal|3
index|]
expr_stmt|;
name|dst_ptr
index|[
literal|4
index|]
operator|=
name|src
index|[
literal|4
index|]
expr_stmt|;
name|dst_ptr
index|[
literal|5
index|]
operator|=
name|src
index|[
literal|5
index|]
expr_stmt|;
name|dst_ptr
index|[
literal|6
index|]
operator|=
name|src
index|[
literal|6
index|]
expr_stmt|;
name|dst_ptr
index|[
literal|7
index|]
operator|=
name|src
index|[
literal|7
index|]
expr_stmt|;
name|dst_ptr
operator|+=
literal|8
expr_stmt|;
name|src
operator|+=
literal|8
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|relbit
operator|=
literal|1
init|;
name|count
operator|--
operator|!=
literal|0
operator|&&
name|src
operator|<
name|end_src
condition|;
name|relbit
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|relbit
operator|&
name|mod_byte
condition|)
block|{
name|unsigned
name|char
name|reloc
init|=
operator|*
name|src
decl_stmt|;
comment|/* This item needs to be relocated.  */
switch|switch
condition|(
name|reloc
operator|&
name|RELOCATION_TYPE_BITS
condition|)
block|{
case|case
name|RELOCATION_TYPE_ABS
case|:
break|break;
case|case
name|RELOCATION_TYPE_REL
case|:
block|{
comment|/* Relocate the item relative to the section.  */
name|oasys_reloc_type
modifier|*
name|r
decl_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|oasys_reloc_type
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
name|FALSE
return|;
operator|*
operator|(
name|per
operator|->
name|reloc_tail_ptr
operator|)
operator|=
name|r
expr_stmt|;
name|per
operator|->
name|reloc_tail_ptr
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* Reference to undefined symbol.  */
name|src
operator|++
expr_stmt|;
comment|/* There is no symbol.  */
name|r
operator|->
name|symbol
operator|=
literal|0
expr_stmt|;
comment|/* Work out the howto.  */
name|abort
argument_list|()
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|address
operator|=
name|dst_ptr
operator|-
name|dst_base_ptr
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|howto
operator|=
operator|&
name|howto_table
index|[
name|reloc
operator|>>
literal|6
index|]
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|sym_ptr_ptr
operator|=
name|NULL
expr_stmt|;
name|section
operator|->
name|reloc_count
operator|++
expr_stmt|;
comment|/* Fake up the data to look like 				     it's got the -ve pc in it, this 				     makes it much easier to convert 				     into other formats.  This is done 				     by hitting the addend.  */
if|if
condition|(
name|r
operator|->
name|relent
operator|.
name|howto
operator|->
name|pc_relative
condition|)
name|r
operator|->
name|relent
operator|.
name|addend
operator|-=
name|dst_ptr
operator|-
name|dst_base_ptr
expr_stmt|;
block|}
break|break;
case|case
name|RELOCATION_TYPE_UND
case|:
block|{
name|oasys_reloc_type
modifier|*
name|r
decl_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|oasys_reloc_type
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
name|FALSE
return|;
operator|*
operator|(
name|per
operator|->
name|reloc_tail_ptr
operator|)
operator|=
name|r
expr_stmt|;
name|per
operator|->
name|reloc_tail_ptr
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* Reference to undefined symbol.  */
name|src
operator|++
expr_stmt|;
comment|/* Get symbol number.  */
name|r
operator|->
name|symbol
operator|=
operator|(
name|src
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|src
index|[
literal|1
index|]
expr_stmt|;
comment|/* Work out the howto.  */
name|abort
argument_list|()
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|addend
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|address
operator|=
name|dst_ptr
operator|-
name|dst_base_ptr
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|howto
operator|=
operator|&
name|howto_table
index|[
name|reloc
operator|>>
literal|6
index|]
expr_stmt|;
name|r
operator|->
name|relent
operator|.
name|sym_ptr_ptr
operator|=
name|NULL
expr_stmt|;
name|section
operator|->
name|reloc_count
operator|++
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
comment|/* Fake up the data to look like 				     it's got the -ve pc in it, this 				     makes it much easier to convert 				     into other formats.  This is done 				     by hitting the addend.  */
if|if
condition|(
name|r
operator|->
name|relent
operator|.
name|howto
operator|->
name|pc_relative
condition|)
name|r
operator|->
name|relent
operator|.
name|addend
operator|-=
name|dst_ptr
operator|-
name|dst_base_ptr
expr_stmt|;
block|}
break|break;
case|case
name|RELOCATION_TYPE_COM
case|:
name|BFD_FAIL
argument_list|()
expr_stmt|;
block|}
block|}
operator|*
name|dst_ptr
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
break|break;
case|case
name|oasys_record_is_local_enum
case|:
case|case
name|oasys_record_is_symbol_enum
case|:
case|case
name|oasys_record_is_section_enum
case|:
break|break;
default|default:
name|loop
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_SECS
value|16
end_define

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|oasys_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|oasys_data_type
modifier|*
name|oasys
decl_stmt|;
name|oasys_data_type
modifier|*
name|save
init|=
name|OASYS_DATA
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|bfd_boolean
name|loop
init|=
name|TRUE
decl_stmt|;
name|bfd_boolean
name|had_usefull
init|=
name|FALSE
decl_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|oasys_obj_data
operator|=
literal|0
expr_stmt|;
name|oasys_mkobject
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|oasys
operator|=
name|OASYS_DATA
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|oasys
operator|->
name|sections
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|oasys
operator|->
name|sections
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Point to the start of the file.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|oasys
operator|->
name|symbol_string_length
operator|=
literal|0
expr_stmt|;
comment|/* Inspect the records, but only keep the section info -      remember the size of the symbols.  */
name|oasys
operator|->
name|first_data_record
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|loop
condition|)
block|{
name|oasys_record_union_type
name|record
decl_stmt|;
if|if
condition|(
operator|!
name|oasys_read_record
argument_list|(
name|abfd
argument_list|,
operator|&
name|record
argument_list|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|record
operator|.
name|header
operator|.
name|length
operator|<
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|record
operator|.
name|header
argument_list|)
condition|)
goto|goto
name|fail
goto|;
switch|switch
condition|(
call|(
name|oasys_record_enum_type
call|)
argument_list|(
name|record
operator|.
name|header
operator|.
name|type
argument_list|)
condition|)
block|{
case|case
name|oasys_record_is_header_enum
case|:
name|had_usefull
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|oasys_record_is_symbol_enum
case|:
case|case
name|oasys_record_is_local_enum
case|:
comment|/* Count symbols and remember their size for a future malloc.  */
name|abfd
operator|->
name|symcount
operator|++
expr_stmt|;
name|oasys
operator|->
name|symbol_string_length
operator|+=
literal|1
operator|+
name|oasys_string_length
argument_list|(
operator|&
name|record
argument_list|)
expr_stmt|;
name|had_usefull
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|oasys_record_is_section_enum
case|:
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|unsigned
name|int
name|section_number
decl_stmt|;
if|if
condition|(
name|record
operator|.
name|section
operator|.
name|header
operator|.
name|length
operator|!=
sizeof|sizeof
argument_list|(
name|record
operator|.
name|section
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|buffer
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
goto|goto
name|fail
goto|;
name|section_number
operator|=
name|record
operator|.
name|section
operator|.
name|relb
operator|&
name|RELOCATION_SECT_BITS
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%u"
argument_list|,
name|section_number
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|oasys
operator|->
name|sections
index|[
name|section_number
index|]
operator|=
name|s
expr_stmt|;
switch|switch
condition|(
name|record
operator|.
name|section
operator|.
name|relb
operator|&
name|RELOCATION_TYPE_BITS
condition|)
block|{
case|case
name|RELOCATION_TYPE_ABS
case|:
case|case
name|RELOCATION_TYPE_REL
case|:
break|break;
case|case
name|RELOCATION_TYPE_UND
case|:
case|case
name|RELOCATION_TYPE_COM
case|:
name|BFD_FAIL
argument_list|()
expr_stmt|;
block|}
name|s
operator|->
name|size
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|record
operator|.
name|section
operator|.
name|value
argument_list|)
expr_stmt|;
name|s
operator|->
name|vma
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|record
operator|.
name|section
operator|.
name|vma
argument_list|)
expr_stmt|;
name|s
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|had_usefull
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|oasys_record_is_data_enum
case|:
name|oasys
operator|->
name|first_data_record
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
operator|-
name|record
operator|.
name|header
operator|.
name|length
expr_stmt|;
case|case
name|oasys_record_is_debug_enum
case|:
case|case
name|oasys_record_is_module_enum
case|:
case|case
name|oasys_record_is_named_section_enum
case|:
case|case
name|oasys_record_is_end_enum
case|:
if|if
condition|(
operator|!
name|had_usefull
condition|)
goto|goto
name|fail
goto|;
name|loop
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
goto|goto
name|fail
goto|;
block|}
block|}
name|oasys
operator|->
name|symbols
operator|=
name|NULL
expr_stmt|;
comment|/* Oasys support several architectures, but I can't see a simple way      to discover which one is in a particular file - we'll guess.  */
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_m68k
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|symcount
operator|!=
literal|0
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_SYMS
expr_stmt|;
comment|/* We don't know if a section has data until we've read it.  */
name|oasys_slurp_section_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
name|fail
label|:
operator|(
name|void
operator|)
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|oasys
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|oasys_obj_data
operator|=
name|save
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|oasys_get_symbol_info
parameter_list|(
name|bfd
modifier|*
name|ignore_abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|symbol_info
modifier|*
name|ret
parameter_list|)
block|{
name|bfd_symbol_info
argument_list|(
name|symbol
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symbol
operator|->
name|section
condition|)
name|ret
operator|->
name|type
operator|=
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_LOCAL
operator|)
condition|?
literal|'a'
else|:
literal|'A'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|oasys_print_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|void
modifier|*
name|afile
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|bfd_print_symbol_type
name|how
parameter_list|)
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|afile
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
case|case
name|bfd_print_symbol_more
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_all
case|:
block|{
specifier|const
name|char
modifier|*
name|section_name
init|=
name|symbol
operator|->
name|section
operator|==
name|NULL
condition|?
operator|(
specifier|const
name|char
operator|*
operator|)
literal|"*abs"
else|:
name|symbol
operator|->
name|section
operator|->
name|name
decl_stmt|;
name|bfd_print_symbol_vandf
argument_list|(
name|abfd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %-5s %s"
argument_list|,
name|section_name
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|oasys_new_section_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|newsect
parameter_list|)
block|{
name|newsect
operator|->
name|used_by_bfd
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|oasys_per_section_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newsect
operator|->
name|used_by_bfd
condition|)
return|return
name|FALSE
return|;
name|oasys_per_section
argument_list|(
name|newsect
argument_list|)
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|oasys_per_section
argument_list|(
name|newsect
argument_list|)
operator|->
name|section
operator|=
name|newsect
expr_stmt|;
name|oasys_per_section
argument_list|(
name|newsect
argument_list|)
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|oasys_per_section
argument_list|(
name|newsect
argument_list|)
operator|->
name|initialized
operator|=
name|FALSE
expr_stmt|;
name|newsect
operator|->
name|alignment_power
operator|=
literal|1
expr_stmt|;
comment|/* Turn the section string into an index.  */
name|sscanf
argument_list|(
name|newsect
operator|->
name|name
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|newsect
operator|->
name|target_index
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|oasys_get_reloc_upper_bound
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|sec_ptr
name|asect
parameter_list|)
block|{
if|if
condition|(
operator|!
name|oasys_slurp_section_data
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|asect
operator|->
name|reloc_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|oasys_get_section_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|sec_ptr
name|section
parameter_list|,
name|void
modifier|*
name|location
parameter_list|,
name|file_ptr
name|offset
parameter_list|,
name|bfd_size_type
name|count
parameter_list|)
block|{
name|oasys_per_section_type
modifier|*
name|p
init|=
name|oasys_per_section
argument_list|(
name|section
argument_list|)
decl_stmt|;
name|oasys_slurp_section_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|initialized
condition|)
operator|(
name|void
operator|)
name|memset
argument_list|(
name|location
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|)
name|count
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|location
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|p
operator|->
name|data
operator|+
name|offset
operator|)
argument_list|,
operator|(
name|size_t
operator|)
name|count
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|oasys_canonicalize_reloc
parameter_list|(
name|bfd
modifier|*
name|ignore_abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|sec_ptr
name|section
parameter_list|,
name|arelent
modifier|*
modifier|*
name|relptr
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|int
name|reloc_count
init|=
literal|0
decl_stmt|;
name|oasys_reloc_type
modifier|*
name|src
init|=
operator|(
name|oasys_reloc_type
operator|*
operator|)
operator|(
name|section
operator|->
name|relocation
operator|)
decl_stmt|;
if|if
condition|(
name|src
operator|!=
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|relptr
operator|=
name|NULL
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
operator|=
name|reloc_count
return|;
block|}
end_function

begin_comment
comment|/* Writing.  */
end_comment

begin_comment
comment|/* Calculate the checksum and write one record.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|oasys_write_record
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|oasys_record_enum_type
name|type
parameter_list|,
name|oasys_record_union_type
modifier|*
name|record
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|int
name|checksum
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
name|record
operator|->
name|header
operator|.
name|length
operator|=
name|size
expr_stmt|;
name|record
operator|->
name|header
operator|.
name|type
operator|=
operator|(
name|int
operator|)
name|type
expr_stmt|;
name|record
operator|->
name|header
operator|.
name|check_sum
operator|=
literal|0
expr_stmt|;
name|record
operator|->
name|header
operator|.
name|fill
operator|=
literal|0
expr_stmt|;
name|ptr
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|record
operator|->
name|pad
index|[
literal|0
index|]
expr_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|checksum
operator|+=
operator|*
name|ptr
operator|++
expr_stmt|;
name|record
operator|->
name|header
operator|.
name|check_sum
operator|=
literal|0xff
operator|&
operator|(
operator|-
name|checksum
operator|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|record
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|size
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Write out all the symbols.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|oasys_write_syms
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|generic
init|=
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|index
init|=
literal|0
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
condition|;
name|count
operator|++
control|)
block|{
name|oasys_symbol_record_type
name|symbol
decl_stmt|;
name|asymbol
modifier|*
specifier|const
name|g
init|=
name|generic
index|[
name|count
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
init|=
name|g
operator|->
name|name
decl_stmt|;
name|char
modifier|*
name|dst
init|=
name|symbol
operator|.
name|name
decl_stmt|;
name|unsigned
name|int
name|l
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|g
operator|->
name|section
argument_list|)
condition|)
block|{
name|symbol
operator|.
name|relb
operator|=
name|RELOCATION_TYPE_COM
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|index
argument_list|,
name|symbol
operator|.
name|refno
argument_list|)
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|g
operator|->
name|section
argument_list|)
condition|)
block|{
name|symbol
operator|.
name|relb
operator|=
name|RELOCATION_TYPE_ABS
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|symbol
operator|.
name|refno
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|g
operator|->
name|section
argument_list|)
condition|)
block|{
name|symbol
operator|.
name|relb
operator|=
name|RELOCATION_TYPE_UND
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|index
argument_list|,
name|symbol
operator|.
name|refno
argument_list|)
expr_stmt|;
comment|/* Overload the value field with the output index number */
name|index
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|g
operator|->
name|flags
operator|&
name|BSF_DEBUGGING
condition|)
comment|/* Throw it away.  */
continue|continue;
else|else
block|{
if|if
condition|(
name|g
operator|->
name|section
operator|==
name|NULL
condition|)
comment|/* Sometime, the oasys tools give out a symbol with illegal 	       bits in it, we'll output it in the same broken way.  */
name|symbol
operator|.
name|relb
operator|=
name|RELOCATION_TYPE_REL
operator||
literal|0
expr_stmt|;
else|else
name|symbol
operator|.
name|relb
operator|=
name|RELOCATION_TYPE_REL
operator||
name|g
operator|->
name|section
operator|->
name|output_section
operator|->
name|target_index
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|symbol
operator|.
name|refno
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|UNDERSCORE_HACK
if|if
condition|(
name|src
index|[
name|l
index|]
operator|==
literal|'_'
condition|)
name|dst
index|[
name|l
operator|++
index|]
operator|=
literal|'.'
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|src
index|[
name|l
index|]
condition|)
block|{
name|dst
index|[
name|l
index|]
operator|=
name|src
index|[
name|l
index|]
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|g
operator|->
name|value
argument_list|,
name|symbol
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|flags
operator|&
name|BSF_LOCAL
condition|)
block|{
if|if
condition|(
operator|!
name|oasys_write_record
argument_list|(
name|abfd
argument_list|,
name|oasys_record_is_local_enum
argument_list|,
operator|(
name|oasys_record_union_type
operator|*
operator|)
operator|&
name|symbol
argument_list|,
name|offsetof
argument_list|(
name|oasys_symbol_record_type
argument_list|,
name|name
index|[
literal|0
index|]
argument_list|)
operator|+
name|l
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|oasys_write_record
argument_list|(
name|abfd
argument_list|,
name|oasys_record_is_symbol_enum
argument_list|,
operator|(
name|oasys_record_union_type
operator|*
operator|)
operator|&
name|symbol
argument_list|,
name|offsetof
argument_list|(
name|oasys_symbol_record_type
argument_list|,
name|name
index|[
literal|0
index|]
argument_list|)
operator|+
name|l
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|g
operator|->
name|value
operator|=
name|index
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Write a section header for each section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|oasys_write_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
specifier|static
name|oasys_section_record_type
name|out
decl_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
name|s
operator|->
name|name
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: can not represent section `%s' in oasys"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_nonrepresentable_section
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|out
operator|.
name|relb
operator|=
name|RELOCATION_TYPE_REL
operator||
name|s
operator|->
name|target_index
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|size
argument_list|,
name|out
operator|.
name|value
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|vma
argument_list|,
name|out
operator|.
name|vma
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oasys_write_record
argument_list|(
name|abfd
argument_list|,
name|oasys_record_is_section_enum
argument_list|,
operator|(
name|oasys_record_union_type
operator|*
operator|)
operator|&
name|out
argument_list|,
sizeof|sizeof
argument_list|(
name|out
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|oasys_write_header
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
comment|/* Create and write the header.  */
name|oasys_header_record_type
name|r
decl_stmt|;
name|size_t
name|length
init|=
name|strlen
argument_list|(
name|abfd
operator|->
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|>
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|r
operator|.
name|module_name
argument_list|)
condition|)
name|length
operator|=
sizeof|sizeof
argument_list|(
name|r
operator|.
name|module_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|r
operator|.
name|module_name
argument_list|,
name|abfd
operator|->
name|filename
argument_list|,
name|length
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|r
operator|.
name|module_name
operator|+
name|length
argument_list|,
literal|' '
argument_list|,
sizeof|sizeof
argument_list|(
name|r
operator|.
name|module_name
argument_list|)
operator|-
name|length
argument_list|)
expr_stmt|;
name|r
operator|.
name|version_number
operator|=
name|OASYS_VERSION_NUMBER
expr_stmt|;
name|r
operator|.
name|rev_number
operator|=
name|OASYS_REV_NUMBER
expr_stmt|;
return|return
name|oasys_write_record
argument_list|(
name|abfd
argument_list|,
name|oasys_record_is_header_enum
argument_list|,
operator|(
name|oasys_record_union_type
operator|*
operator|)
operator|&
name|r
argument_list|,
name|offsetof
argument_list|(
name|oasys_header_record_type
argument_list|,
name|description
index|[
literal|0
index|]
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|oasys_write_end
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|oasys_end_record_type
name|end
decl_stmt|;
name|unsigned
name|char
name|null
init|=
literal|0
decl_stmt|;
name|end
operator|.
name|relb
operator|=
name|RELOCATION_TYPE_ABS
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|abfd
operator|->
name|start_address
argument_list|,
name|end
operator|.
name|entry
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|end
operator|.
name|fill
argument_list|)
expr_stmt|;
name|end
operator|.
name|zero
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|oasys_write_record
argument_list|(
name|abfd
argument_list|,
name|oasys_record_is_end_enum
argument_list|,
operator|(
name|oasys_record_union_type
operator|*
operator|)
operator|&
name|end
argument_list|,
sizeof|sizeof
argument_list|(
name|end
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|null
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|abfd
argument_list|)
operator|==
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|comp
parameter_list|(
specifier|const
name|void
modifier|*
name|ap
parameter_list|,
specifier|const
name|void
modifier|*
name|bp
parameter_list|)
block|{
name|arelent
modifier|*
name|a
init|=
operator|*
operator|(
operator|(
name|arelent
operator|*
operator|*
operator|)
name|ap
operator|)
decl_stmt|;
name|arelent
modifier|*
name|b
init|=
operator|*
operator|(
operator|(
name|arelent
operator|*
operator|*
operator|)
name|bp
operator|)
decl_stmt|;
return|return
name|a
operator|->
name|address
operator|-
name|b
operator|->
name|address
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|oasys_write_data
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
block|{
name|bfd_byte
modifier|*
name|raw_data
init|=
name|oasys_per_section
argument_list|(
name|s
argument_list|)
operator|->
name|data
decl_stmt|;
name|oasys_data_record_type
name|processed_data
decl_stmt|;
name|bfd_size_type
name|current_byte_index
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|relocs_to_go
init|=
name|s
operator|->
name|reloc_count
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|p
init|=
name|s
operator|->
name|orelocation
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|reloc_count
operator|!=
literal|0
condition|)
comment|/* Sort the reloc records so it's easy to insert the relocs into the 	       data.  */
name|qsort
argument_list|(
name|s
operator|->
name|orelocation
argument_list|,
name|s
operator|->
name|reloc_count
argument_list|,
sizeof|sizeof
argument_list|(
name|arelent
operator|*
operator|*
argument_list|)
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|current_byte_index
operator|=
literal|0
expr_stmt|;
name|processed_data
operator|.
name|relb
operator|=
name|s
operator|->
name|target_index
operator||
name|RELOCATION_TYPE_REL
expr_stmt|;
while|while
condition|(
name|current_byte_index
operator|<
name|s
operator|->
name|size
condition|)
block|{
comment|/* Scan forwards by eight bytes or however much is left and see if 	       there are any relocations going on.  */
name|bfd_byte
modifier|*
name|mod
init|=
operator|&
name|processed_data
operator|.
name|data
index|[
literal|0
index|]
decl_stmt|;
name|bfd_byte
modifier|*
name|dst
init|=
operator|&
name|processed_data
operator|.
name|data
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
operator|*
name|mod
operator|=
literal|0
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|s
operator|->
name|vma
operator|+
name|current_byte_index
argument_list|,
name|processed_data
operator|.
name|addr
argument_list|)
expr_stmt|;
comment|/* Don't start a relocation unless you're sure you can finish it 		 within the same data record.  The worst case relocation is a 		 4-byte relocatable value which is split across two modification 		 bytes (1 relocation byte + 2 symbol reference bytes + 2 data + 		 1 modification byte + 2 data = 8 bytes total).  That's where 		 the magic number 8 comes from.  */
while|while
condition|(
name|current_byte_index
operator|<
name|s
operator|->
name|size
operator|&&
name|dst
operator|<=
operator|&
name|processed_data
operator|.
name|data
index|[
sizeof|sizeof
argument_list|(
name|processed_data
operator|.
name|data
argument_list|)
operator|-
literal|8
index|]
condition|)
block|{
if|if
condition|(
name|relocs_to_go
operator|!=
literal|0
condition|)
block|{
name|arelent
modifier|*
name|r
init|=
operator|*
name|p
decl_stmt|;
comment|/* There is a relocation, is it for this byte ?  */
if|if
condition|(
name|r
operator|->
name|address
operator|==
name|current_byte_index
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If this is coming from an unloadable section then copy 		     zeros.  */
if|if
condition|(
name|raw_data
operator|==
name|NULL
condition|)
operator|*
name|dst
operator|++
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|dst
operator|++
operator|=
operator|*
name|raw_data
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|>=
literal|8
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|mod
operator|=
name|dst
operator|++
expr_stmt|;
operator|*
name|mod
operator|=
literal|0
expr_stmt|;
block|}
name|current_byte_index
operator|++
expr_stmt|;
block|}
comment|/* Don't write a useless null modification byte.  */
if|if
condition|(
name|dst
operator|==
name|mod
operator|+
literal|1
condition|)
operator|--
name|dst
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|oasys_write_record
argument_list|(
name|abfd
argument_list|,
name|oasys_record_is_data_enum
argument_list|,
operator|(
operator|(
name|oasys_record_union_type
operator|*
operator|)
operator|&
name|processed_data
operator|)
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|dst
operator|-
operator|(
name|bfd_byte
operator|*
operator|)
operator|&
name|processed_data
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|oasys_write_object_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
operator|!
name|oasys_write_header
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|oasys_write_syms
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|oasys_write_sections
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|oasys_write_data
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|oasys_write_end
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set section contents is complicated with OASYS since the format is    not a byte image, but a record stream.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|oasys_set_section_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|sec_ptr
name|section
parameter_list|,
specifier|const
name|void
modifier|*
name|location
parameter_list|,
name|file_ptr
name|offset
parameter_list|,
name|bfd_size_type
name|count
parameter_list|)
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|oasys_per_section
argument_list|(
name|section
argument_list|)
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|oasys_per_section
argument_list|(
name|section
argument_list|)
operator|->
name|data
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oasys_per_section
argument_list|(
name|section
argument_list|)
operator|->
name|data
condition|)
return|return
name|FALSE
return|;
block|}
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|oasys_per_section
argument_list|(
name|section
argument_list|)
operator|->
name|data
operator|+
name|offset
operator|)
argument_list|,
name|location
argument_list|,
operator|(
name|size_t
operator|)
name|count
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Native-level interface to symbols.  */
end_comment

begin_comment
comment|/* We read the symbols into a buffer, which is discarded when this    function exits.  We read the strings into a buffer large enough to    hold them all plus all the cached symbol entries.  */
end_comment

begin_function
specifier|static
name|asymbol
modifier|*
name|oasys_make_empty_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|oasys_symbol_type
argument_list|)
decl_stmt|;
name|oasys_symbol_type
modifier|*
name|new
init|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
return|return
name|NULL
return|;
name|new
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
operator|&
name|new
operator|->
name|symbol
return|;
block|}
end_function

begin_comment
comment|/* User should have checked the file flags; perhaps we should return    BFD_NO_MORE_SYMBOLS if there are none?  */
end_comment

begin_function
specifier|static
name|bfd
modifier|*
name|oasys_openr_next_archived_file
parameter_list|(
name|bfd
modifier|*
name|arch
parameter_list|,
name|bfd
modifier|*
name|prev
parameter_list|)
block|{
name|oasys_ar_data_type
modifier|*
name|ar
init|=
name|OASYS_AR_DATA
argument_list|(
name|arch
argument_list|)
decl_stmt|;
name|oasys_module_info_type
modifier|*
name|p
decl_stmt|;
comment|/* Take the next one from the arch state, or reset.  */
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
comment|/* Reset the index - the first two entries are bogus.  */
name|ar
operator|->
name|module_index
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|ar
operator|->
name|module
operator|+
name|ar
operator|->
name|module_index
expr_stmt|;
name|ar
operator|->
name|module_index
operator|++
expr_stmt|;
if|if
condition|(
name|ar
operator|->
name|module_index
operator|<=
name|ar
operator|->
name|module_count
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|abfd
operator|==
name|NULL
condition|)
block|{
name|p
operator|->
name|abfd
operator|=
name|_bfd_create_empty_archive_element_shell
argument_list|(
name|arch
argument_list|)
expr_stmt|;
name|p
operator|->
name|abfd
operator|->
name|origin
operator|=
name|p
operator|->
name|pos
expr_stmt|;
name|p
operator|->
name|abfd
operator|->
name|filename
operator|=
name|p
operator|->
name|name
expr_stmt|;
comment|/* Fixup a pointer to this element for the member.  */
name|p
operator|->
name|abfd
operator|->
name|arelt_data
operator|=
operator|(
name|void
operator|*
operator|)
name|p
expr_stmt|;
block|}
return|return
name|p
operator|->
name|abfd
return|;
block|}
name|bfd_set_error
argument_list|(
name|bfd_error_no_more_archived_files
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|oasys_find_nearest_line
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_vma
name|offset
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
modifier|*
name|line_ptr
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|oasys_find_inliner_info
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
modifier|*
name|line_ptr
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|oasys_generic_stat_arch_elt
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|stat
modifier|*
name|buf
parameter_list|)
block|{
name|oasys_module_info_type
modifier|*
name|mod
init|=
operator|(
name|oasys_module_info_type
operator|*
operator|)
name|abfd
operator|->
name|arelt_data
decl_stmt|;
if|if
condition|(
name|mod
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|buf
operator|->
name|st_size
operator|=
name|mod
operator|->
name|size
expr_stmt|;
name|buf
operator|->
name|st_mode
operator|=
literal|0666
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|oasys_sizeof_headers
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_boolean
name|exec
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|oasys_close_and_cleanup
value|_bfd_generic_close_and_cleanup
end_define

begin_define
define|#
directive|define
name|oasys_bfd_free_cached_info
value|_bfd_generic_bfd_free_cached_info
end_define

begin_define
define|#
directive|define
name|oasys_slurp_armap
value|bfd_true
end_define

begin_define
define|#
directive|define
name|oasys_slurp_extended_name_table
value|bfd_true
end_define

begin_define
define|#
directive|define
name|oasys_construct_extended_name_table
value|((bfd_boolean (*) (bfd *, char **, bfd_size_type *, const char **)) bfd_true)
end_define

begin_define
define|#
directive|define
name|oasys_truncate_arname
value|bfd_dont_truncate_arname
end_define

begin_define
define|#
directive|define
name|oasys_write_armap
value|((bfd_boolean (*) (bfd *, unsigned int, struct orl *, unsigned int, int)) bfd_true)
end_define

begin_define
define|#
directive|define
name|oasys_read_ar_hdr
value|bfd_nullvoidptr
end_define

begin_define
define|#
directive|define
name|oasys_get_elt_at_index
value|_bfd_generic_get_elt_at_index
end_define

begin_define
define|#
directive|define
name|oasys_update_armap_timestamp
value|bfd_true
end_define

begin_define
define|#
directive|define
name|oasys_bfd_is_local_label_name
value|bfd_generic_is_local_label_name
end_define

begin_define
define|#
directive|define
name|oasys_bfd_is_target_special_symbol
value|((bfd_boolean (*) (bfd *, asymbol *)) bfd_false)
end_define

begin_define
define|#
directive|define
name|oasys_get_lineno
value|_bfd_nosymbols_get_lineno
end_define

begin_define
define|#
directive|define
name|oasys_bfd_make_debug_symbol
value|_bfd_nosymbols_bfd_make_debug_symbol
end_define

begin_define
define|#
directive|define
name|oasys_read_minisymbols
value|_bfd_generic_read_minisymbols
end_define

begin_define
define|#
directive|define
name|oasys_minisymbol_to_symbol
value|_bfd_generic_minisymbol_to_symbol
end_define

begin_define
define|#
directive|define
name|oasys_bfd_reloc_type_lookup
value|_bfd_norelocs_bfd_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|oasys_set_arch_mach
value|bfd_default_set_arch_mach
end_define

begin_define
define|#
directive|define
name|oasys_get_section_contents_in_window
value|_bfd_generic_get_section_contents_in_window
end_define

begin_define
define|#
directive|define
name|oasys_bfd_get_relocated_section_contents
value|bfd_generic_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|oasys_bfd_relax_section
value|bfd_generic_relax_section
end_define

begin_define
define|#
directive|define
name|oasys_bfd_gc_sections
value|bfd_generic_gc_sections
end_define

begin_define
define|#
directive|define
name|oasys_bfd_merge_sections
value|bfd_generic_merge_sections
end_define

begin_define
define|#
directive|define
name|oasys_bfd_is_group_section
value|bfd_generic_is_group_section
end_define

begin_define
define|#
directive|define
name|oasys_bfd_discard_group
value|bfd_generic_discard_group
end_define

begin_define
define|#
directive|define
name|oasys_section_already_linked
value|_bfd_generic_section_already_linked
end_define

begin_define
define|#
directive|define
name|oasys_bfd_link_hash_table_create
value|_bfd_generic_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|oasys_bfd_link_hash_table_free
value|_bfd_generic_link_hash_table_free
end_define

begin_define
define|#
directive|define
name|oasys_bfd_link_add_symbols
value|_bfd_generic_link_add_symbols
end_define

begin_define
define|#
directive|define
name|oasys_bfd_link_just_syms
value|_bfd_generic_link_just_syms
end_define

begin_define
define|#
directive|define
name|oasys_bfd_final_link
value|_bfd_generic_final_link
end_define

begin_define
define|#
directive|define
name|oasys_bfd_link_split_section
value|_bfd_generic_link_split_section
end_define

begin_decl_stmt
specifier|const
name|bfd_target
name|oasys_vec
init|=
block|{
literal|"oasys"
block|,
comment|/* Name.  */
name|bfd_target_oasys_flavour
block|,
name|BFD_ENDIAN_BIG
block|,
comment|/* Target byte order.  */
name|BFD_ENDIAN_BIG
block|,
comment|/* Target headers byte order.  */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* Object flags.  */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_ROM
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* Section flags.  */
literal|0
block|,
comment|/* Leading underscore.  */
literal|' '
block|,
comment|/* AR_pad_char.  */
literal|16
block|,
comment|/* AR_max_namelen.  */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* Data.  */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* Headers.  */
block|{
name|_bfd_dummy_target
block|,
name|oasys_object_p
block|,
comment|/* bfd_check_format.  */
name|oasys_archive_p
block|,
name|_bfd_dummy_target
block|,   }
block|,
block|{
comment|/* bfd_set_format.  */
name|bfd_false
block|,
name|oasys_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
comment|/* bfd_write_contents.  */
name|bfd_false
block|,
name|oasys_write_object_contents
block|,
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|,   }
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|oasys
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|oasys
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|oasys
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|oasys
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|oasys
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|oasys
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

end_unit

