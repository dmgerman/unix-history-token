begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for Intel 386 COFF files (DJGPP variant with a stub).    Copyright 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Written by Robert Hoehne.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file handles now also stubbed coff images. The stub is a small    DOS executable program before the coff image to load it in memory    and execute it. This is needed, because DOS cannot run coff files.     All the functions below are called by the corresponding functions    from coffswap.h.    The only thing what they do is to adjust the information stored in    the COFF file which are offset into the file.    This is needed, because DJGPP uses a very special way to load and run    the coff image. It loads the image in memory and assumes then, that the    image had no stub by using the filepointers as pointers in the coff    image and NOT in the file.     To be compatible with any existing executables I have fixed this    here and NOT in the DJGPP startup code.  */
end_comment

begin_define
define|#
directive|define
name|TARGET_SYM
value|go32stubbedcoff_vec
end_define

begin_define
define|#
directive|define
name|TARGET_NAME
value|"coff-go32-exe"
end_define

begin_define
define|#
directive|define
name|TARGET_UNDERSCORE
value|'_'
end_define

begin_define
define|#
directive|define
name|COFF_GO32_EXE
end_define

begin_define
define|#
directive|define
name|COFF_LONG_SECTION_NAMES
end_define

begin_define
define|#
directive|define
name|COFF_SUPPORT_GNU_LINKONCE
end_define

begin_define
define|#
directive|define
name|COFF_LONG_FILENAMES
end_define

begin_define
define|#
directive|define
name|COFF_SECTION_ALIGNMENT_ENTRIES
define|\
value|{ COFF_SECTION_NAME_EXACT_MATCH (".data"), \   COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 4 }, \ { COFF_SECTION_NAME_EXACT_MATCH (".text"), \   COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 4 }, \ { COFF_SECTION_NAME_PARTIAL_MATCH (".debug"), \   COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 0 }, \ { COFF_SECTION_NAME_PARTIAL_MATCH (".gnu.linkonce.wi"), \   COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 0 }
end_define

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_comment
comment|/* At first the prototypes.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|adjust_filehdr_in_post
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adjust_filehdr_out_pre
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adjust_filehdr_out_post
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adjust_scnhdr_in_post
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adjust_scnhdr_out_pre
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adjust_scnhdr_out_post
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adjust_aux_in_post
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adjust_aux_out_pre
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adjust_aux_out_post
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|create_go32_stub
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All that ..._PRE and ...POST functions are called from the corresponding    coff_swap... functions. The ...PRE functions are called at the beginning    of the function and the ...POST functions at the end of the swap routines.  */
end_comment

begin_define
define|#
directive|define
name|COFF_ADJUST_FILEHDR_IN_POST
value|adjust_filehdr_in_post
end_define

begin_define
define|#
directive|define
name|COFF_ADJUST_FILEHDR_OUT_PRE
value|adjust_filehdr_out_pre
end_define

begin_define
define|#
directive|define
name|COFF_ADJUST_FILEHDR_OUT_POST
value|adjust_filehdr_out_post
end_define

begin_define
define|#
directive|define
name|COFF_ADJUST_SCNHDR_IN_POST
value|adjust_scnhdr_in_post
end_define

begin_define
define|#
directive|define
name|COFF_ADJUST_SCNHDR_OUT_PRE
value|adjust_scnhdr_out_pre
end_define

begin_define
define|#
directive|define
name|COFF_ADJUST_SCNHDR_OUT_POST
value|adjust_scnhdr_out_post
end_define

begin_define
define|#
directive|define
name|COFF_ADJUST_AUX_IN_POST
value|adjust_aux_in_post
end_define

begin_define
define|#
directive|define
name|COFF_ADJUST_AUX_OUT_PRE
value|adjust_aux_out_pre
end_define

begin_define
define|#
directive|define
name|COFF_ADJUST_AUX_OUT_POST
value|adjust_aux_out_post
end_define

begin_decl_stmt
specifier|static
name|bfd_boolean
name|go32_stubbed_coff_bfd_copy_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|coff_bfd_copy_private_bfd_data
value|go32_stubbed_coff_bfd_copy_private_bfd_data
end_define

begin_include
include|#
directive|include
file|"coff-i386.c"
end_include

begin_comment
comment|/* I hold in the usrdata the stub.  */
end_comment

begin_define
define|#
directive|define
name|bfd_coff_go32stub
value|bfd_usrdata
end_define

begin_comment
comment|/* This macro is used, because I cannot assume the endianess of the    host system.  */
end_comment

begin_define
define|#
directive|define
name|_H
parameter_list|(
name|index
parameter_list|)
value|(H_GET_16 (abfd, (header+index*2)))
end_define

begin_comment
comment|/* These bytes are a 2048-byte DOS executable, which loads the COFF    image into memory and then runs it. It is called 'stub'.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|stub_bytes
index|[
name|STUBSIZE
index|]
init|=
block|{
include|#
directive|include
file|"go32stub.h"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    I have not commented each swap function below, because the    technique is in any function the same. For the ...in function,    all the pointers are adjusted by adding STUBSIZE and for the    ...out function, it is subtracted first and after calling the    standard swap function it is reset to the old value.  */
end_comment

begin_comment
comment|/* This macro is used for adjusting the filepointers, which    is done only, if the pointer is nonzero.  */
end_comment

begin_define
define|#
directive|define
name|ADJUST_VAL
parameter_list|(
name|val
parameter_list|,
name|diff
parameter_list|)
define|\
value|if (val != 0) val += diff
end_define

begin_function
specifier|static
name|void
name|adjust_filehdr_in_post
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|src
decl_stmt|;
name|PTR
name|dst
decl_stmt|;
block|{
name|FILHDR
modifier|*
name|filehdr_src
init|=
operator|(
name|FILHDR
operator|*
operator|)
name|src
decl_stmt|;
name|struct
name|internal_filehdr
modifier|*
name|filehdr_dst
init|=
operator|(
expr|struct
name|internal_filehdr
operator|*
operator|)
name|dst
decl_stmt|;
name|ADJUST_VAL
argument_list|(
name|filehdr_dst
operator|->
name|f_symptr
argument_list|,
name|STUBSIZE
argument_list|)
expr_stmt|;
comment|/* Save now the stub to be used later.  */
name|bfd_coff_go32stub
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|STUBSIZE
argument_list|)
expr_stmt|;
comment|/* Since this function returns no status, I do not set here      any bfd_error_...      That means, before the use of bfd_coff_go32stub (), this value      should be checked if it is != NULL.  */
if|if
condition|(
name|bfd_coff_go32stub
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
return|return;
name|memcpy
argument_list|(
name|bfd_coff_go32stub
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|filehdr_src
operator|->
name|stub
argument_list|,
name|STUBSIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adjust_filehdr_out_pre
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|in
decl_stmt|;
name|PTR
name|out
decl_stmt|;
block|{
name|struct
name|internal_filehdr
modifier|*
name|filehdr_in
init|=
operator|(
expr|struct
name|internal_filehdr
operator|*
operator|)
name|in
decl_stmt|;
name|FILHDR
modifier|*
name|filehdr_out
init|=
operator|(
name|FILHDR
operator|*
operator|)
name|out
decl_stmt|;
comment|/* Generate the stub.  */
name|create_go32_stub
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Copy the stub to the file header.  */
if|if
condition|(
name|bfd_coff_go32stub
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
condition|)
name|memcpy
argument_list|(
name|filehdr_out
operator|->
name|stub
argument_list|,
name|bfd_coff_go32stub
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|STUBSIZE
argument_list|)
expr_stmt|;
else|else
comment|/* Use the default.  */
name|memcpy
argument_list|(
name|filehdr_out
operator|->
name|stub
argument_list|,
name|stub_bytes
argument_list|,
name|STUBSIZE
argument_list|)
expr_stmt|;
name|ADJUST_VAL
argument_list|(
name|filehdr_in
operator|->
name|f_symptr
argument_list|,
operator|-
name|STUBSIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adjust_filehdr_out_post
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|in
decl_stmt|;
name|PTR
name|out
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|internal_filehdr
modifier|*
name|filehdr_in
init|=
operator|(
expr|struct
name|internal_filehdr
operator|*
operator|)
name|in
decl_stmt|;
comment|/* Undo the above change.  */
name|ADJUST_VAL
argument_list|(
name|filehdr_in
operator|->
name|f_symptr
argument_list|,
name|STUBSIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adjust_scnhdr_in_post
parameter_list|(
name|abfd
parameter_list|,
name|ext
parameter_list|,
name|in
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|ext
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|in
decl_stmt|;
block|{
name|struct
name|internal_scnhdr
modifier|*
name|scnhdr_int
init|=
operator|(
expr|struct
name|internal_scnhdr
operator|*
operator|)
name|in
decl_stmt|;
name|ADJUST_VAL
argument_list|(
name|scnhdr_int
operator|->
name|s_scnptr
argument_list|,
name|STUBSIZE
argument_list|)
expr_stmt|;
name|ADJUST_VAL
argument_list|(
name|scnhdr_int
operator|->
name|s_relptr
argument_list|,
name|STUBSIZE
argument_list|)
expr_stmt|;
name|ADJUST_VAL
argument_list|(
name|scnhdr_int
operator|->
name|s_lnnoptr
argument_list|,
name|STUBSIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adjust_scnhdr_out_pre
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|in
decl_stmt|;
name|PTR
name|out
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|internal_scnhdr
modifier|*
name|scnhdr_int
init|=
operator|(
expr|struct
name|internal_scnhdr
operator|*
operator|)
name|in
decl_stmt|;
name|ADJUST_VAL
argument_list|(
name|scnhdr_int
operator|->
name|s_scnptr
argument_list|,
operator|-
name|STUBSIZE
argument_list|)
expr_stmt|;
name|ADJUST_VAL
argument_list|(
name|scnhdr_int
operator|->
name|s_relptr
argument_list|,
operator|-
name|STUBSIZE
argument_list|)
expr_stmt|;
name|ADJUST_VAL
argument_list|(
name|scnhdr_int
operator|->
name|s_lnnoptr
argument_list|,
operator|-
name|STUBSIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adjust_scnhdr_out_post
parameter_list|(
name|abfd
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|in
decl_stmt|;
name|PTR
name|out
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|internal_scnhdr
modifier|*
name|scnhdr_int
init|=
operator|(
expr|struct
name|internal_scnhdr
operator|*
operator|)
name|in
decl_stmt|;
name|ADJUST_VAL
argument_list|(
name|scnhdr_int
operator|->
name|s_scnptr
argument_list|,
name|STUBSIZE
argument_list|)
expr_stmt|;
name|ADJUST_VAL
argument_list|(
name|scnhdr_int
operator|->
name|s_relptr
argument_list|,
name|STUBSIZE
argument_list|)
expr_stmt|;
name|ADJUST_VAL
argument_list|(
name|scnhdr_int
operator|->
name|s_lnnoptr
argument_list|,
name|STUBSIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adjust_aux_in_post
parameter_list|(
name|abfd
parameter_list|,
name|ext1
parameter_list|,
name|type
parameter_list|,
name|class
parameter_list|,
name|indx
parameter_list|,
name|numaux
parameter_list|,
name|in1
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|ext1
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|class
decl_stmt|;
name|int
name|indx
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|numaux
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|in1
decl_stmt|;
block|{
name|union
name|internal_auxent
modifier|*
name|in
init|=
operator|(
expr|union
name|internal_auxent
operator|*
operator|)
name|in1
decl_stmt|;
if|if
condition|(
name|class
operator|==
name|C_BLOCK
operator|||
name|class
operator|==
name|C_FCN
operator|||
name|ISFCN
argument_list|(
name|type
argument_list|)
operator|||
name|ISTAG
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|ADJUST_VAL
argument_list|(
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
argument_list|,
name|STUBSIZE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|adjust_aux_out_pre
parameter_list|(
name|abfd
parameter_list|,
name|inp
parameter_list|,
name|type
parameter_list|,
name|class
parameter_list|,
name|indx
parameter_list|,
name|numaux
parameter_list|,
name|extp
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|inp
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|class
decl_stmt|;
name|int
name|indx
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|numaux
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|extp
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|union
name|internal_auxent
modifier|*
name|in
init|=
operator|(
expr|union
name|internal_auxent
operator|*
operator|)
name|inp
decl_stmt|;
if|if
condition|(
name|class
operator|==
name|C_BLOCK
operator|||
name|class
operator|==
name|C_FCN
operator|||
name|ISFCN
argument_list|(
name|type
argument_list|)
operator|||
name|ISTAG
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|ADJUST_VAL
argument_list|(
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
argument_list|,
operator|-
name|STUBSIZE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|adjust_aux_out_post
parameter_list|(
name|abfd
parameter_list|,
name|inp
parameter_list|,
name|type
parameter_list|,
name|class
parameter_list|,
name|indx
parameter_list|,
name|numaux
parameter_list|,
name|extp
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|inp
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|class
decl_stmt|;
name|int
name|indx
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|numaux
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|extp
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|union
name|internal_auxent
modifier|*
name|in
init|=
operator|(
expr|union
name|internal_auxent
operator|*
operator|)
name|inp
decl_stmt|;
if|if
condition|(
name|class
operator|==
name|C_BLOCK
operator|||
name|class
operator|==
name|C_FCN
operator|||
name|ISFCN
argument_list|(
name|type
argument_list|)
operator|||
name|ISTAG
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|ADJUST_VAL
argument_list|(
name|in
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
argument_list|,
name|STUBSIZE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* That's the function, which creates the stub. There are    different cases from where the stub is taken.    At first the environment variable $(GO32STUB) is checked and then    $(STUB) if it was not set.    If it exists and points to a valid stub the stub is taken from    that file. This file can be also a whole executable file, because    the stub is computed from the exe information at the start of that    file.     If there was any error, the standard stub (compiled in this file)    is taken.  */
end_comment

begin_function
specifier|static
name|void
name|create_go32_stub
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
comment|/* Do it only once.  */
if|if
condition|(
name|bfd_coff_go32stub
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|stub
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|f
decl_stmt|;
name|unsigned
name|char
name|header
index|[
literal|10
index|]
decl_stmt|;
name|char
name|magic
index|[
literal|8
index|]
decl_stmt|;
name|unsigned
name|long
name|coff_start
decl_stmt|;
name|long
name|exe_start
decl_stmt|;
comment|/* Check at first the environment variable $(GO32STUB).  */
name|stub
operator|=
name|getenv
argument_list|(
literal|"GO32STUB"
argument_list|)
expr_stmt|;
comment|/* Now check the environment variable $(STUB).  */
if|if
condition|(
name|stub
operator|==
name|NULL
condition|)
name|stub
operator|=
name|getenv
argument_list|(
literal|"STUB"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub
operator|==
name|NULL
condition|)
goto|goto
name|stub_end
goto|;
if|if
condition|(
name|stat
argument_list|(
name|stub
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|stub_end
goto|;
ifdef|#
directive|ifdef
name|O_BINARY
name|f
operator|=
name|open
argument_list|(
name|stub
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|)
expr_stmt|;
else|#
directive|else
name|f
operator|=
name|open
argument_list|(
name|stub
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|f
operator|<
literal|0
condition|)
goto|goto
name|stub_end
goto|;
if|if
condition|(
name|read
argument_list|(
name|f
argument_list|,
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
name|header
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
goto|goto
name|stub_end
goto|;
block|}
if|if
condition|(
name|_H
argument_list|(
literal|0
argument_list|)
operator|!=
literal|0x5a4d
condition|)
comment|/* It is not an exe file.  */
block|{
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
goto|goto
name|stub_end
goto|;
block|}
comment|/* Compute the size of the stub (it is every thing up          to the beginning of the coff image).  */
name|coff_start
operator|=
operator|(
name|long
operator|)
name|_H
argument_list|(
literal|2
argument_list|)
operator|*
literal|512L
expr_stmt|;
if|if
condition|(
name|_H
argument_list|(
literal|1
argument_list|)
condition|)
name|coff_start
operator|+=
operator|(
name|long
operator|)
name|_H
argument_list|(
literal|1
argument_list|)
operator|-
literal|512L
expr_stmt|;
comment|/* Currently there is only a fixed stub size of 2048 bytes          supported.  */
if|if
condition|(
name|coff_start
operator|!=
literal|2048
condition|)
block|{
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
goto|goto
name|stub_end
goto|;
block|}
name|exe_start
operator|=
name|_H
argument_list|(
literal|4
argument_list|)
operator|*
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|lseek
argument_list|(
name|f
argument_list|,
name|exe_start
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|exe_start
condition|)
block|{
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
goto|goto
name|stub_end
goto|;
block|}
if|if
condition|(
name|read
argument_list|(
name|f
argument_list|,
operator|&
name|magic
argument_list|,
literal|8
argument_list|)
operator|!=
literal|8
condition|)
block|{
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
goto|goto
name|stub_end
goto|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|magic
argument_list|,
literal|"go32stub"
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
goto|goto
name|stub_end
goto|;
block|}
comment|/* Now we found a correct stub (hopefully).  */
name|bfd_coff_go32stub
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|coff_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_coff_go32stub
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
name|lseek
argument_list|(
name|f
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|read
argument_list|(
name|f
argument_list|,
name|bfd_coff_go32stub
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|coff_start
argument_list|)
operator|!=
name|coff_start
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|bfd_coff_go32stub
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_coff_go32stub
argument_list|(
name|abfd
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|stub_end
label|:
comment|/* There was something wrong above, so use now the standard builtin      stub.  */
if|if
condition|(
name|bfd_coff_go32stub
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bfd_coff_go32stub
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|STUBSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_coff_go32stub
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
return|return;
name|memcpy
argument_list|(
name|bfd_coff_go32stub
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|stub_bytes
argument_list|,
name|STUBSIZE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If ibfd was a stubbed coff image, copy the stub from that bfd    to the new obfd.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|go32_stubbed_coff_bfd_copy_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
comment|/* Check if both are the same targets.  */
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|!=
name|obfd
operator|->
name|xvec
condition|)
return|return
name|TRUE
return|;
comment|/* Check if both have a valid stub.  */
if|if
condition|(
name|bfd_coff_go32stub
argument_list|(
name|ibfd
argument_list|)
operator|==
name|NULL
operator|||
name|bfd_coff_go32stub
argument_list|(
name|obfd
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* Now copy the stub.  */
name|memcpy
argument_list|(
name|bfd_coff_go32stub
argument_list|(
name|obfd
argument_list|)
argument_list|,
name|bfd_coff_go32stub
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|STUBSIZE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

end_unit

