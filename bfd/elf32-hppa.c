begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for HP PA-RISC ELF files.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1999, 2000, 2001,    2002, 2003, 2004 Free Software Foundation, Inc.     Original code by 	Center for Software Science 	Department of Computer Science 	University of Utah    Largely rewritten by Alan Modra<alan@linuxcare.com.au>     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/hppa.h"
end_include

begin_include
include|#
directive|include
file|"libhppa.h"
end_include

begin_include
include|#
directive|include
file|"elf32-hppa.h"
end_include

begin_define
define|#
directive|define
name|ARCH_SIZE
value|32
end_define

begin_include
include|#
directive|include
file|"elf32-hppa.h"
end_include

begin_include
include|#
directive|include
file|"elf-hppa.h"
end_include

begin_comment
comment|/* In order to gain some understanding of code in this file without    knowing all the intricate details of the linker, note the    following:     Functions named elf32_hppa_* are called by external routines, other    functions are only called locally.  elf32_hppa_* functions appear    in this file more or less in the order in which they are called    from external routines.  eg. elf32_hppa_check_relocs is called    early in the link process, elf32_hppa_finish_dynamic_sections is    one of the last functions.  */
end_comment

begin_comment
comment|/* We use two hash tables to hold information for linking PA ELF objects.     The first is the elf32_hppa_link_hash_table which is derived    from the standard ELF linker hash table.  We use this as a place to    attach other hash tables and static information.     The second is the stub hash table which is derived from the    base BFD hash table.  The stub hash table holds the information    necessary to build the linker stubs during a link.     There are a number of different stubs generated by the linker.     Long branch stub:    :		ldil LR'X,%r1    :		be,n RR'X(%sr4,%r1)     PIC long branch stub:    :		b,l .+8,%r1    :		addil LR'X - ($PIC_pcrel$0 - 4),%r1    :		be,n RR'X - ($PIC_pcrel$0 - 8)(%sr4,%r1)     Import stub to call shared library routine from normal object file    (single sub-space version)    :		addil LR'lt_ptr+ltoff,%dp	; get procedure entry point    :		ldw RR'lt_ptr+ltoff(%r1),%r21    :		bv %r0(%r21)    :		ldw RR'lt_ptr+ltoff+4(%r1),%r19	; get new dlt value.     Import stub to call shared library routine from shared library    (single sub-space version)    :		addil LR'ltoff,%r19		; get procedure entry point    :		ldw RR'ltoff(%r1),%r21    :		bv %r0(%r21)    :		ldw RR'ltoff+4(%r1),%r19	; get new dlt value.     Import stub to call shared library routine from normal object file    (multiple sub-space support)    :		addil LR'lt_ptr+ltoff,%dp	; get procedure entry point    :		ldw RR'lt_ptr+ltoff(%r1),%r21    :		ldw RR'lt_ptr+ltoff+4(%r1),%r19	; get new dlt value.    :		ldsid (%r21),%r1    :		mtsp %r1,%sr0    :		be 0(%sr0,%r21)			; branch to target    :		stw %rp,-24(%sp)		; save rp     Import stub to call shared library routine from shared library    (multiple sub-space support)    :		addil LR'ltoff,%r19		; get procedure entry point    :		ldw RR'ltoff(%r1),%r21    :		ldw RR'ltoff+4(%r1),%r19	; get new dlt value.    :		ldsid (%r21),%r1    :		mtsp %r1,%sr0    :		be 0(%sr0,%r21)			; branch to target    :		stw %rp,-24(%sp)		; save rp     Export stub to return from shared lib routine (multiple sub-space support)    One of these is created for each exported procedure in a shared    library (and stored in the shared lib).  Shared lib routines are    called via the first instruction in the export stub so that we can    do an inter-space return.  Not required for single sub-space.    :		bl,n X,%rp			; trap the return    :		nop    :		ldw -24(%sp),%rp		; restore the original rp    :		ldsid (%rp),%r1    :		mtsp %r1,%sr0    :		be,n 0(%sr0,%rp)		; inter-space return.  */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_SIZE
value|8
end_define

begin_define
define|#
directive|define
name|GOT_ENTRY_SIZE
value|4
end_define

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/lib/ld.so.1"
end_define

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|plt_stub
index|[]
init|=
block|{
literal|0x0e
block|,
literal|0x80
block|,
literal|0x10
block|,
literal|0x96
block|,
comment|/* 1: ldw	0(%r20),%r22		*/
literal|0xea
block|,
literal|0xc0
block|,
literal|0xc0
block|,
literal|0x00
block|,
comment|/*    bv	%r0(%r22)		*/
literal|0x0e
block|,
literal|0x88
block|,
literal|0x10
block|,
literal|0x95
block|,
comment|/*    ldw	4(%r20),%r21		*/
define|#
directive|define
name|PLT_STUB_ENTRY
value|(3*4)
literal|0xea
block|,
literal|0x9f
block|,
literal|0x1f
block|,
literal|0xdd
block|,
comment|/*    b,l	1b,%r20			*/
literal|0xd6
block|,
literal|0x80
block|,
literal|0x1c
block|,
literal|0x1e
block|,
comment|/*    depi	0,31,2,%r20		*/
literal|0x00
block|,
literal|0xc0
block|,
literal|0xff
block|,
literal|0xee
block|,
comment|/* 9: .word	fixup_func		*/
literal|0xde
block|,
literal|0xad
block|,
literal|0xbe
block|,
literal|0xef
comment|/*    .word	fixup_ltp		*/
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Section name for stubs is the associated section name plus this    string.  */
end_comment

begin_define
define|#
directive|define
name|STUB_SUFFIX
value|".stub"
end_define

begin_comment
comment|/* We don't need to copy certain PC- or GP-relative dynamic relocs    into a shared object's dynamic section.  All the relocs of the    limited class we are interested in, are absolute.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RELATIVE_DYNRELOCS
end_ifndef

begin_define
define|#
directive|define
name|RELATIVE_DYNRELOCS
value|0
end_define

begin_define
define|#
directive|define
name|IS_ABSOLUTE_RELOC
parameter_list|(
name|r_type
parameter_list|)
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid    copying dynamic variables from a shared lib into an app's dynbss    section, and instead use a dynamic relocation to point into the    shared lib.  */
end_comment

begin_define
define|#
directive|define
name|ELIMINATE_COPY_RELOCS
value|1
end_define

begin_enum
enum|enum
name|elf32_hppa_stub_type
block|{
name|hppa_stub_long_branch
block|,
name|hppa_stub_long_branch_shared
block|,
name|hppa_stub_import
block|,
name|hppa_stub_import_shared
block|,
name|hppa_stub_export
block|,
name|hppa_stub_none
block|}
enum|;
end_enum

begin_struct
struct|struct
name|elf32_hppa_stub_hash_entry
block|{
comment|/* Base hash table entry structure.  */
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
comment|/* The stub section.  */
name|asection
modifier|*
name|stub_sec
decl_stmt|;
comment|/* Offset within stub_sec of the beginning of this stub.  */
name|bfd_vma
name|stub_offset
decl_stmt|;
comment|/* Given the symbol's value and its section we can determine its final      value when building the stubs (so the stub knows where to jump.  */
name|bfd_vma
name|target_value
decl_stmt|;
name|asection
modifier|*
name|target_section
decl_stmt|;
name|enum
name|elf32_hppa_stub_type
name|stub_type
decl_stmt|;
comment|/* The symbol table entry, if any, that this was derived from.  */
name|struct
name|elf32_hppa_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* Where this stub is being called from, or, in the case of combined      stub sections, the first input section in the group.  */
name|asection
modifier|*
name|id_sec
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|elf32_hppa_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|elf
decl_stmt|;
comment|/* A pointer to the most recently used stub hash entry against this      symbol.  */
name|struct
name|elf32_hppa_stub_hash_entry
modifier|*
name|stub_cache
decl_stmt|;
comment|/* Used to count relocations for delayed sizing of relocation      sections.  */
struct|struct
name|elf32_hppa_dyn_reloc_entry
block|{
comment|/* Next relocation in the chain.  */
name|struct
name|elf32_hppa_dyn_reloc_entry
modifier|*
name|next
decl_stmt|;
comment|/* The input section of the reloc.  */
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* Number of relocs copied in this section.  */
name|bfd_size_type
name|count
decl_stmt|;
if|#
directive|if
name|RELATIVE_DYNRELOCS
comment|/* Number of relative relocs copied for the input section.  */
name|bfd_size_type
name|relative_count
decl_stmt|;
endif|#
directive|endif
block|}
modifier|*
name|dyn_relocs
struct|;
comment|/* Set if this symbol is used by a plabel reloc.  */
name|unsigned
name|int
name|plabel
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|elf32_hppa_link_hash_table
block|{
comment|/* The main hash table.  */
name|struct
name|elf_link_hash_table
name|elf
decl_stmt|;
comment|/* The stub hash table.  */
name|struct
name|bfd_hash_table
name|stub_hash_table
decl_stmt|;
comment|/* Linker stub bfd.  */
name|bfd
modifier|*
name|stub_bfd
decl_stmt|;
comment|/* Linker call-backs.  */
name|asection
modifier|*
function_decl|(
modifier|*
name|add_stub_section
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|layout_sections_again
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Array to keep track of which stub sections have been created, and      information on stub grouping.  */
struct|struct
name|map_stub
block|{
comment|/* This is the section to which stubs in the group will be        attached.  */
name|asection
modifier|*
name|link_sec
decl_stmt|;
comment|/* The stub section.  */
name|asection
modifier|*
name|stub_sec
decl_stmt|;
block|}
modifier|*
name|stub_group
struct|;
comment|/* Assorted information used by elf32_hppa_size_stubs.  */
name|unsigned
name|int
name|bfd_count
decl_stmt|;
name|int
name|top_index
decl_stmt|;
name|asection
modifier|*
modifier|*
name|input_list
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
modifier|*
name|all_local_syms
decl_stmt|;
comment|/* Short-cuts to get to dynamic linker sections.  */
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|srelplt
decl_stmt|;
name|asection
modifier|*
name|sdynbss
decl_stmt|;
name|asection
modifier|*
name|srelbss
decl_stmt|;
comment|/* Used during a final link to store the base of the text and data      segments so that we can perform SEGREL relocations.  */
name|bfd_vma
name|text_segment_base
decl_stmt|;
name|bfd_vma
name|data_segment_base
decl_stmt|;
comment|/* Whether we support multiple sub-spaces for shared libs.  */
name|unsigned
name|int
name|multi_subspace
range|:
literal|1
decl_stmt|;
comment|/* Flags set when various size branches are detected.  Used to      select suitable defaults for the stub group size.  */
name|unsigned
name|int
name|has_12bit_branch
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|has_17bit_branch
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|has_22bit_branch
range|:
literal|1
decl_stmt|;
comment|/* Set if we need a .plt stub to support lazy dynamic linking.  */
name|unsigned
name|int
name|need_plt_stub
range|:
literal|1
decl_stmt|;
comment|/* Small local sym to section mapping cache.  */
name|struct
name|sym_sec_cache
name|sym_sec
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Various hash macros and functions.  */
end_comment

begin_define
define|#
directive|define
name|hppa_link_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct elf32_hppa_link_hash_table *) ((p)->hash))
end_define

begin_define
define|#
directive|define
name|hppa_stub_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|)
define|\
value|((struct elf32_hppa_stub_hash_entry *) \    bfd_hash_lookup ((table), (string), (create), (copy)))
end_define

begin_comment
comment|/* Assorted hash table functions.  */
end_comment

begin_comment
comment|/* Initialize an entry in the stub hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|stub_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|entry
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf32_hppa_stub_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|entry
return|;
block|}
comment|/* Call the allocation method of the superclass.  */
name|entry
operator|=
name|bfd_hash_newfunc
argument_list|(
name|entry
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf32_hppa_stub_hash_entry
modifier|*
name|eh
decl_stmt|;
comment|/* Initialize the local fields.  */
name|eh
operator|=
operator|(
expr|struct
name|elf32_hppa_stub_hash_entry
operator|*
operator|)
name|entry
expr_stmt|;
name|eh
operator|->
name|stub_sec
operator|=
name|NULL
expr_stmt|;
name|eh
operator|->
name|stub_offset
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|target_value
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|target_section
operator|=
name|NULL
expr_stmt|;
name|eh
operator|->
name|stub_type
operator|=
name|hppa_stub_long_branch
expr_stmt|;
name|eh
operator|->
name|h
operator|=
name|NULL
expr_stmt|;
name|eh
operator|->
name|id_sec
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Initialize an entry in the link hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|hppa_link_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|entry
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf32_hppa_link_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|entry
return|;
block|}
comment|/* Call the allocation method of the superclass.  */
name|entry
operator|=
name|_bfd_elf_link_hash_newfunc
argument_list|(
name|entry
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf32_hppa_link_hash_entry
modifier|*
name|eh
decl_stmt|;
comment|/* Initialize the local fields.  */
name|eh
operator|=
operator|(
expr|struct
name|elf32_hppa_link_hash_entry
operator|*
operator|)
name|entry
expr_stmt|;
name|eh
operator|->
name|stub_cache
operator|=
name|NULL
expr_stmt|;
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
name|eh
operator|->
name|plabel
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Create the derived linker hash table.  The PA ELF port uses the derived    hash table to keep information specific to the PA ELF linker (without    using static variables).  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elf32_hppa_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|elf32_hppa_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
decl_stmt|;
name|ret
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|elf
argument_list|,
name|abfd
argument_list|,
name|hppa_link_hash_newfunc
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Init the stub hash table too.  */
if|if
condition|(
operator|!
name|bfd_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|stub_hash_table
argument_list|,
name|stub_hash_newfunc
argument_list|)
condition|)
return|return
name|NULL
return|;
name|ret
operator|->
name|stub_bfd
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|add_stub_section
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|layout_sections_again
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|stub_group
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|sgot
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|srelgot
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|splt
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|srelplt
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|sdynbss
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|srelbss
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|text_segment_base
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|data_segment_base
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|multi_subspace
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|has_12bit_branch
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|has_17bit_branch
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|has_22bit_branch
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|need_plt_stub
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|sym_sec
operator|.
name|abfd
operator|=
name|NULL
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|elf
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Free the derived linker hash table.  */
end_comment

begin_function
specifier|static
name|void
name|elf32_hppa_link_hash_table_free
parameter_list|(
name|struct
name|bfd_link_hash_table
modifier|*
name|hash
parameter_list|)
block|{
name|struct
name|elf32_hppa_link_hash_table
modifier|*
name|ret
init|=
operator|(
expr|struct
name|elf32_hppa_link_hash_table
operator|*
operator|)
name|hash
decl_stmt|;
name|bfd_hash_table_free
argument_list|(
operator|&
name|ret
operator|->
name|stub_hash_table
argument_list|)
expr_stmt|;
name|_bfd_generic_link_hash_table_free
argument_list|(
name|hash
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build a name for an entry in the stub hash table.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|hppa_stub_name
parameter_list|(
specifier|const
name|asection
modifier|*
name|input_section
parameter_list|,
specifier|const
name|asection
modifier|*
name|sym_sec
parameter_list|,
specifier|const
name|struct
name|elf32_hppa_link_hash_entry
modifier|*
name|hash
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|)
block|{
name|char
modifier|*
name|stub_name
decl_stmt|;
name|bfd_size_type
name|len
decl_stmt|;
if|if
condition|(
name|hash
condition|)
block|{
name|len
operator|=
literal|8
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
operator|+
literal|1
operator|+
literal|8
operator|+
literal|1
expr_stmt|;
name|stub_name
operator|=
name|bfd_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_name
operator|!=
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|stub_name
argument_list|,
literal|"%08x_%s+%x"
argument_list|,
name|input_section
operator|->
name|id
operator|&
literal|0xffffffff
argument_list|,
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
operator|(
name|int
operator|)
name|rel
operator|->
name|r_addend
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|len
operator|=
literal|8
operator|+
literal|1
operator|+
literal|8
operator|+
literal|1
operator|+
literal|8
operator|+
literal|1
operator|+
literal|8
operator|+
literal|1
expr_stmt|;
name|stub_name
operator|=
name|bfd_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_name
operator|!=
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|stub_name
argument_list|,
literal|"%08x_%x:%x+%x"
argument_list|,
name|input_section
operator|->
name|id
operator|&
literal|0xffffffff
argument_list|,
name|sym_sec
operator|->
name|id
operator|&
literal|0xffffffff
argument_list|,
operator|(
name|int
operator|)
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|&
literal|0xffffffff
argument_list|,
operator|(
name|int
operator|)
name|rel
operator|->
name|r_addend
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|stub_name
return|;
block|}
end_function

begin_comment
comment|/* Look up an entry in the stub hash.  Stub entries are cached because    creating the stub name takes a bit of time.  */
end_comment

begin_function
specifier|static
name|struct
name|elf32_hppa_stub_hash_entry
modifier|*
name|hppa_get_stub_entry
parameter_list|(
specifier|const
name|asection
modifier|*
name|input_section
parameter_list|,
specifier|const
name|asection
modifier|*
name|sym_sec
parameter_list|,
name|struct
name|elf32_hppa_link_hash_entry
modifier|*
name|hash
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|elf32_hppa_link_hash_table
modifier|*
name|htab
parameter_list|)
block|{
name|struct
name|elf32_hppa_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
specifier|const
name|asection
modifier|*
name|id_sec
decl_stmt|;
comment|/* If this input section is part of a group of sections sharing one      stub section, then use the id of the first section in the group.      Stub names need to include a section id, as there may well be      more than one stub used to reach say, printf, and we need to      distinguish between them.  */
name|id_sec
operator|=
name|htab
operator|->
name|stub_group
index|[
name|input_section
operator|->
name|id
index|]
operator|.
name|link_sec
expr_stmt|;
if|if
condition|(
name|hash
operator|!=
name|NULL
operator|&&
name|hash
operator|->
name|stub_cache
operator|!=
name|NULL
operator|&&
name|hash
operator|->
name|stub_cache
operator|->
name|h
operator|==
name|hash
operator|&&
name|hash
operator|->
name|stub_cache
operator|->
name|id_sec
operator|==
name|id_sec
condition|)
block|{
name|stub_entry
operator|=
name|hash
operator|->
name|stub_cache
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|stub_name
decl_stmt|;
name|stub_name
operator|=
name|hppa_stub_name
argument_list|(
name|id_sec
argument_list|,
name|sym_sec
argument_list|,
name|hash
argument_list|,
name|rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|stub_entry
operator|=
name|hppa_stub_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|stub_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash
operator|!=
name|NULL
condition|)
name|hash
operator|->
name|stub_cache
operator|=
name|stub_entry
expr_stmt|;
name|free
argument_list|(
name|stub_name
argument_list|)
expr_stmt|;
block|}
return|return
name|stub_entry
return|;
block|}
end_function

begin_comment
comment|/* Add a new stub entry to the stub hash.  Not all fields of the new    stub entry are initialised.  */
end_comment

begin_function
specifier|static
name|struct
name|elf32_hppa_stub_hash_entry
modifier|*
name|hppa_add_stub
parameter_list|(
specifier|const
name|char
modifier|*
name|stub_name
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|struct
name|elf32_hppa_link_hash_table
modifier|*
name|htab
parameter_list|)
block|{
name|asection
modifier|*
name|link_sec
decl_stmt|;
name|asection
modifier|*
name|stub_sec
decl_stmt|;
name|struct
name|elf32_hppa_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
name|link_sec
operator|=
name|htab
operator|->
name|stub_group
index|[
name|section
operator|->
name|id
index|]
operator|.
name|link_sec
expr_stmt|;
name|stub_sec
operator|=
name|htab
operator|->
name|stub_group
index|[
name|section
operator|->
name|id
index|]
operator|.
name|stub_sec
expr_stmt|;
if|if
condition|(
name|stub_sec
operator|==
name|NULL
condition|)
block|{
name|stub_sec
operator|=
name|htab
operator|->
name|stub_group
index|[
name|link_sec
operator|->
name|id
index|]
operator|.
name|stub_sec
expr_stmt|;
if|if
condition|(
name|stub_sec
operator|==
name|NULL
condition|)
block|{
name|size_t
name|namelen
decl_stmt|;
name|bfd_size_type
name|len
decl_stmt|;
name|char
modifier|*
name|s_name
decl_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|link_sec
operator|->
name|name
argument_list|)
expr_stmt|;
name|len
operator|=
name|namelen
operator|+
sizeof|sizeof
argument_list|(
name|STUB_SUFFIX
argument_list|)
expr_stmt|;
name|s_name
operator|=
name|bfd_alloc
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s_name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
name|s_name
argument_list|,
name|link_sec
operator|->
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s_name
operator|+
name|namelen
argument_list|,
name|STUB_SUFFIX
argument_list|,
sizeof|sizeof
argument_list|(
name|STUB_SUFFIX
argument_list|)
argument_list|)
expr_stmt|;
name|stub_sec
operator|=
call|(
modifier|*
name|htab
operator|->
name|add_stub_section
call|)
argument_list|(
name|s_name
argument_list|,
name|link_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_sec
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|htab
operator|->
name|stub_group
index|[
name|link_sec
operator|->
name|id
index|]
operator|.
name|stub_sec
operator|=
name|stub_sec
expr_stmt|;
block|}
name|htab
operator|->
name|stub_group
index|[
name|section
operator|->
name|id
index|]
operator|.
name|stub_sec
operator|=
name|stub_sec
expr_stmt|;
block|}
comment|/* Enter this entry into the linker stub hash table.  */
name|stub_entry
operator|=
name|hppa_stub_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|stub_name
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: cannot create stub entry %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|section
operator|->
name|owner
argument_list|)
argument_list|,
name|stub_name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|stub_entry
operator|->
name|stub_sec
operator|=
name|stub_sec
expr_stmt|;
name|stub_entry
operator|->
name|stub_offset
operator|=
literal|0
expr_stmt|;
name|stub_entry
operator|->
name|id_sec
operator|=
name|link_sec
expr_stmt|;
return|return
name|stub_entry
return|;
block|}
end_function

begin_comment
comment|/* Determine the type of stub needed, if any, for a call.  */
end_comment

begin_function
specifier|static
name|enum
name|elf32_hppa_stub_type
name|hppa_type_of_stub
parameter_list|(
name|asection
modifier|*
name|input_sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|elf32_hppa_link_hash_entry
modifier|*
name|hash
parameter_list|,
name|bfd_vma
name|destination
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd_vma
name|location
decl_stmt|;
name|bfd_vma
name|branch_offset
decl_stmt|;
name|bfd_vma
name|max_branch_offset
decl_stmt|;
name|unsigned
name|int
name|r_type
decl_stmt|;
if|if
condition|(
name|hash
operator|!=
name|NULL
operator|&&
name|hash
operator|->
name|elf
operator|.
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
name|hash
operator|->
name|elf
operator|.
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|hash
operator|->
name|plabel
operator|&&
operator|(
name|info
operator|->
name|shared
operator|||
operator|!
operator|(
name|hash
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|||
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
comment|/* We need an import stub.  Decide between hppa_stub_import 	 and hppa_stub_import_shared later.  */
return|return
name|hppa_stub_import
return|;
block|}
comment|/* Determine where the call point is.  */
name|location
operator|=
operator|(
name|input_sec
operator|->
name|output_offset
operator|+
name|input_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
name|branch_offset
operator|=
name|destination
operator|-
name|location
operator|-
literal|8
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
comment|/* Determine if a long branch stub is needed.  parisc branch offsets      are relative to the second instruction past the branch, ie. +8      bytes on from the branch instruction location.  The offset is      signed and counts in units of 4 bytes.  */
if|if
condition|(
name|r_type
operator|==
operator|(
name|unsigned
name|int
operator|)
name|R_PARISC_PCREL17F
condition|)
block|{
name|max_branch_offset
operator|=
operator|(
literal|1
operator|<<
operator|(
literal|17
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
operator|(
name|unsigned
name|int
operator|)
name|R_PARISC_PCREL12F
condition|)
block|{
name|max_branch_offset
operator|=
operator|(
literal|1
operator|<<
operator|(
literal|12
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|2
expr_stmt|;
block|}
else|else
comment|/* R_PARISC_PCREL22F.  */
block|{
name|max_branch_offset
operator|=
operator|(
literal|1
operator|<<
operator|(
literal|22
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|branch_offset
operator|+
name|max_branch_offset
operator|>=
literal|2
operator|*
name|max_branch_offset
condition|)
return|return
name|hppa_stub_long_branch
return|;
return|return
name|hppa_stub_none
return|;
block|}
end_function

begin_comment
comment|/* Build one linker stub as defined by the stub hash table entry GEN_ENTRY.    IN_ARG contains the link info pointer.  */
end_comment

begin_define
define|#
directive|define
name|LDIL_R1
value|0x20200000
end_define

begin_comment
comment|/* ldil  LR'XXX,%r1		*/
end_comment

begin_define
define|#
directive|define
name|BE_SR4_R1
value|0xe0202002
end_define

begin_comment
comment|/* be,n  RR'XXX(%sr4,%r1)	*/
end_comment

begin_define
define|#
directive|define
name|BL_R1
value|0xe8200000
end_define

begin_comment
comment|/* b,l   .+8,%r1		*/
end_comment

begin_define
define|#
directive|define
name|ADDIL_R1
value|0x28200000
end_define

begin_comment
comment|/* addil LR'XXX,%r1,%r1		*/
end_comment

begin_define
define|#
directive|define
name|DEPI_R1
value|0xd4201c1e
end_define

begin_comment
comment|/* depi  0,31,2,%r1		*/
end_comment

begin_define
define|#
directive|define
name|ADDIL_DP
value|0x2b600000
end_define

begin_comment
comment|/* addil LR'XXX,%dp,%r1		*/
end_comment

begin_define
define|#
directive|define
name|LDW_R1_R21
value|0x48350000
end_define

begin_comment
comment|/* ldw   RR'XXX(%sr0,%r1),%r21	*/
end_comment

begin_define
define|#
directive|define
name|BV_R0_R21
value|0xeaa0c000
end_define

begin_comment
comment|/* bv    %r0(%r21)		*/
end_comment

begin_define
define|#
directive|define
name|LDW_R1_R19
value|0x48330000
end_define

begin_comment
comment|/* ldw   RR'XXX(%sr0,%r1),%r19	*/
end_comment

begin_define
define|#
directive|define
name|ADDIL_R19
value|0x2a600000
end_define

begin_comment
comment|/* addil LR'XXX,%r19,%r1	*/
end_comment

begin_define
define|#
directive|define
name|LDW_R1_DP
value|0x483b0000
end_define

begin_comment
comment|/* ldw   RR'XXX(%sr0,%r1),%dp	*/
end_comment

begin_define
define|#
directive|define
name|LDSID_R21_R1
value|0x02a010a1
end_define

begin_comment
comment|/* ldsid (%sr0,%r21),%r1	*/
end_comment

begin_define
define|#
directive|define
name|MTSP_R1
value|0x00011820
end_define

begin_comment
comment|/* mtsp  %r1,%sr0		*/
end_comment

begin_define
define|#
directive|define
name|BE_SR0_R21
value|0xe2a00000
end_define

begin_comment
comment|/* be    0(%sr0,%r21)		*/
end_comment

begin_define
define|#
directive|define
name|STW_RP
value|0x6bc23fd1
end_define

begin_comment
comment|/* stw   %rp,-24(%sr0,%sp)	*/
end_comment

begin_define
define|#
directive|define
name|BL22_RP
value|0xe800a002
end_define

begin_comment
comment|/* b,l,n XXX,%rp		*/
end_comment

begin_define
define|#
directive|define
name|BL_RP
value|0xe8400002
end_define

begin_comment
comment|/* b,l,n XXX,%rp		*/
end_comment

begin_define
define|#
directive|define
name|NOP
value|0x08000240
end_define

begin_comment
comment|/* nop				*/
end_comment

begin_define
define|#
directive|define
name|LDW_RP
value|0x4bc23fd1
end_define

begin_comment
comment|/* ldw   -24(%sr0,%sp),%rp	*/
end_comment

begin_define
define|#
directive|define
name|LDSID_RP_R1
value|0x004010a1
end_define

begin_comment
comment|/* ldsid (%sr0,%rp),%r1		*/
end_comment

begin_define
define|#
directive|define
name|BE_SR0_RP
value|0xe0400002
end_define

begin_comment
comment|/* be,n  0(%sr0,%rp)		*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|R19_STUBS
end_ifndef

begin_define
define|#
directive|define
name|R19_STUBS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|R19_STUBS
end_if

begin_define
define|#
directive|define
name|LDW_R1_DLT
value|LDW_R1_R19
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LDW_R1_DLT
value|LDW_R1_DP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|bfd_boolean
name|hppa_build_one_stub
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|gen_entry
parameter_list|,
name|void
modifier|*
name|in_arg
parameter_list|)
block|{
name|struct
name|elf32_hppa_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf32_hppa_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|asection
modifier|*
name|stub_sec
decl_stmt|;
name|bfd
modifier|*
name|stub_bfd
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_vma
name|sym_value
decl_stmt|;
name|bfd_vma
name|insn
decl_stmt|;
name|bfd_vma
name|off
decl_stmt|;
name|int
name|val
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* Massage our args to the form they really have.  */
name|stub_entry
operator|=
operator|(
expr|struct
name|elf32_hppa_stub_hash_entry
operator|*
operator|)
name|gen_entry
expr_stmt|;
name|info
operator|=
name|in_arg
expr_stmt|;
name|htab
operator|=
name|hppa_link_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|stub_sec
operator|=
name|stub_entry
operator|->
name|stub_sec
expr_stmt|;
comment|/* Make a note of the offset within the stubs for this entry.  */
name|stub_entry
operator|->
name|stub_offset
operator|=
name|stub_sec
operator|->
name|_raw_size
expr_stmt|;
name|loc
operator|=
name|stub_sec
operator|->
name|contents
operator|+
name|stub_entry
operator|->
name|stub_offset
expr_stmt|;
name|stub_bfd
operator|=
name|stub_sec
operator|->
name|owner
expr_stmt|;
switch|switch
condition|(
name|stub_entry
operator|->
name|stub_type
condition|)
block|{
case|case
name|hppa_stub_long_branch
case|:
comment|/* Create the long branch.  A long branch is formed with "ldil" 	 loading the upper bits of the target address into a register, 	 then branching with "be" which adds in the lower bits. 	 The "be" has its delay slot nullified.  */
name|sym_value
operator|=
operator|(
name|stub_entry
operator|->
name|target_value
operator|+
name|stub_entry
operator|->
name|target_section
operator|->
name|output_offset
operator|+
name|stub_entry
operator|->
name|target_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|val
operator|=
name|hppa_field_adjust
argument_list|(
name|sym_value
argument_list|,
literal|0
argument_list|,
name|e_lrsel
argument_list|)
expr_stmt|;
name|insn
operator|=
name|hppa_rebuild_insn
argument_list|(
operator|(
name|int
operator|)
name|LDIL_R1
argument_list|,
name|val
argument_list|,
literal|21
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|insn
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|val
operator|=
name|hppa_field_adjust
argument_list|(
name|sym_value
argument_list|,
literal|0
argument_list|,
name|e_rrsel
argument_list|)
operator|>>
literal|2
expr_stmt|;
name|insn
operator|=
name|hppa_rebuild_insn
argument_list|(
operator|(
name|int
operator|)
name|BE_SR4_R1
argument_list|,
name|val
argument_list|,
literal|17
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|insn
argument_list|,
name|loc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|size
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|hppa_stub_long_branch_shared
case|:
comment|/* Branches are relative.  This is where we are going to.  */
name|sym_value
operator|=
operator|(
name|stub_entry
operator|->
name|target_value
operator|+
name|stub_entry
operator|->
name|target_section
operator|->
name|output_offset
operator|+
name|stub_entry
operator|->
name|target_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* And this is where we are coming from, more or less.  */
name|sym_value
operator|-=
operator|(
name|stub_entry
operator|->
name|stub_offset
operator|+
name|stub_sec
operator|->
name|output_offset
operator|+
name|stub_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|BL_R1
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|val
operator|=
name|hppa_field_adjust
argument_list|(
name|sym_value
argument_list|,
operator|(
name|bfd_signed_vma
operator|)
operator|-
literal|8
argument_list|,
name|e_lrsel
argument_list|)
expr_stmt|;
name|insn
operator|=
name|hppa_rebuild_insn
argument_list|(
operator|(
name|int
operator|)
name|ADDIL_R1
argument_list|,
name|val
argument_list|,
literal|21
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|insn
argument_list|,
name|loc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|val
operator|=
name|hppa_field_adjust
argument_list|(
name|sym_value
argument_list|,
operator|(
name|bfd_signed_vma
operator|)
operator|-
literal|8
argument_list|,
name|e_rrsel
argument_list|)
operator|>>
literal|2
expr_stmt|;
name|insn
operator|=
name|hppa_rebuild_insn
argument_list|(
operator|(
name|int
operator|)
name|BE_SR4_R1
argument_list|,
name|val
argument_list|,
literal|17
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|insn
argument_list|,
name|loc
operator|+
literal|8
argument_list|)
expr_stmt|;
name|size
operator|=
literal|12
expr_stmt|;
break|break;
case|case
name|hppa_stub_import
case|:
case|case
name|hppa_stub_import_shared
case|:
name|off
operator|=
name|stub_entry
operator|->
name|h
operator|->
name|elf
operator|.
name|plt
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|off
operator|>=
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
name|off
operator|&=
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
expr_stmt|;
name|sym_value
operator|=
operator|(
name|off
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|-
name|elf_gp
argument_list|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|owner
argument_list|)
operator|)
expr_stmt|;
name|insn
operator|=
name|ADDIL_DP
expr_stmt|;
if|#
directive|if
name|R19_STUBS
if|if
condition|(
name|stub_entry
operator|->
name|stub_type
operator|==
name|hppa_stub_import_shared
condition|)
name|insn
operator|=
name|ADDIL_R19
expr_stmt|;
endif|#
directive|endif
name|val
operator|=
name|hppa_field_adjust
argument_list|(
name|sym_value
argument_list|,
literal|0
argument_list|,
name|e_lrsel
argument_list|)
operator|,
name|insn
operator|=
name|hppa_rebuild_insn
argument_list|(
operator|(
name|int
operator|)
name|insn
argument_list|,
name|val
argument_list|,
literal|21
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|insn
argument_list|,
name|loc
argument_list|)
expr_stmt|;
comment|/* It is critical to use lrsel/rrsel here because we are using 	 two different offsets (+0 and +4) from sym_value.  If we use 	 lsel/rsel then with unfortunate sym_values we will round 	 sym_value+4 up to the next 2k block leading to a mis-match 	 between the lsel and rsel value.  */
name|val
operator|=
name|hppa_field_adjust
argument_list|(
name|sym_value
argument_list|,
literal|0
argument_list|,
name|e_rrsel
argument_list|)
expr_stmt|;
name|insn
operator|=
name|hppa_rebuild_insn
argument_list|(
operator|(
name|int
operator|)
name|LDW_R1_R21
argument_list|,
name|val
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|insn
argument_list|,
name|loc
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|multi_subspace
condition|)
block|{
name|val
operator|=
name|hppa_field_adjust
argument_list|(
name|sym_value
argument_list|,
operator|(
name|bfd_signed_vma
operator|)
literal|4
argument_list|,
name|e_rrsel
argument_list|)
expr_stmt|;
name|insn
operator|=
name|hppa_rebuild_insn
argument_list|(
operator|(
name|int
operator|)
name|LDW_R1_DLT
argument_list|,
name|val
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|insn
argument_list|,
name|loc
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|LDSID_R21_R1
argument_list|,
name|loc
operator|+
literal|12
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|MTSP_R1
argument_list|,
name|loc
operator|+
literal|16
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|BE_SR0_R21
argument_list|,
name|loc
operator|+
literal|20
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|STW_RP
argument_list|,
name|loc
operator|+
literal|24
argument_list|)
expr_stmt|;
name|size
operator|=
literal|28
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|BV_R0_R21
argument_list|,
name|loc
operator|+
literal|8
argument_list|)
expr_stmt|;
name|val
operator|=
name|hppa_field_adjust
argument_list|(
name|sym_value
argument_list|,
operator|(
name|bfd_signed_vma
operator|)
literal|4
argument_list|,
name|e_rrsel
argument_list|)
expr_stmt|;
name|insn
operator|=
name|hppa_rebuild_insn
argument_list|(
operator|(
name|int
operator|)
name|LDW_R1_DLT
argument_list|,
name|val
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|insn
argument_list|,
name|loc
operator|+
literal|12
argument_list|)
expr_stmt|;
name|size
operator|=
literal|16
expr_stmt|;
block|}
break|break;
case|case
name|hppa_stub_export
case|:
comment|/* Branches are relative.  This is where we are going to.  */
name|sym_value
operator|=
operator|(
name|stub_entry
operator|->
name|target_value
operator|+
name|stub_entry
operator|->
name|target_section
operator|->
name|output_offset
operator|+
name|stub_entry
operator|->
name|target_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* And this is where we are coming from.  */
name|sym_value
operator|-=
operator|(
name|stub_entry
operator|->
name|stub_offset
operator|+
name|stub_sec
operator|->
name|output_offset
operator|+
name|stub_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
if|if
condition|(
name|sym_value
operator|-
literal|8
operator|+
operator|(
literal|1
operator|<<
operator|(
literal|17
operator|+
literal|1
operator|)
operator|)
operator|>=
operator|(
literal|1
operator|<<
operator|(
literal|17
operator|+
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|!
name|htab
operator|->
name|has_22bit_branch
operator|||
name|sym_value
operator|-
literal|8
operator|+
operator|(
literal|1
operator|<<
operator|(
literal|22
operator|+
literal|1
operator|)
operator|)
operator|>=
operator|(
literal|1
operator|<<
operator|(
literal|22
operator|+
literal|2
operator|)
operator|)
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s(%s+0x%lx): cannot reach %s, recompile with -ffunction-sections"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|stub_entry
operator|->
name|target_section
operator|->
name|owner
argument_list|)
argument_list|,
name|stub_sec
operator|->
name|name
argument_list|,
operator|(
name|long
operator|)
name|stub_entry
operator|->
name|stub_offset
argument_list|,
name|stub_entry
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|val
operator|=
name|hppa_field_adjust
argument_list|(
name|sym_value
argument_list|,
operator|(
name|bfd_signed_vma
operator|)
operator|-
literal|8
argument_list|,
name|e_fsel
argument_list|)
operator|>>
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|has_22bit_branch
condition|)
name|insn
operator|=
name|hppa_rebuild_insn
argument_list|(
operator|(
name|int
operator|)
name|BL_RP
argument_list|,
name|val
argument_list|,
literal|17
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|hppa_rebuild_insn
argument_list|(
operator|(
name|int
operator|)
name|BL22_RP
argument_list|,
name|val
argument_list|,
literal|22
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
name|insn
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|NOP
argument_list|,
name|loc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|LDW_RP
argument_list|,
name|loc
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|LDSID_RP_R1
argument_list|,
name|loc
operator|+
literal|12
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|MTSP_R1
argument_list|,
name|loc
operator|+
literal|16
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|stub_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|BE_SR0_RP
argument_list|,
name|loc
operator|+
literal|20
argument_list|)
expr_stmt|;
comment|/* Point the function symbol at the stub.  */
name|stub_entry
operator|->
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|stub_sec
expr_stmt|;
name|stub_entry
operator|->
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|stub_sec
operator|->
name|_raw_size
expr_stmt|;
name|size
operator|=
literal|24
expr_stmt|;
break|break;
default|default:
name|BFD_FAIL
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|stub_sec
operator|->
name|_raw_size
operator|+=
name|size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|LDIL_R1
end_undef

begin_undef
undef|#
directive|undef
name|BE_SR4_R1
end_undef

begin_undef
undef|#
directive|undef
name|BL_R1
end_undef

begin_undef
undef|#
directive|undef
name|ADDIL_R1
end_undef

begin_undef
undef|#
directive|undef
name|DEPI_R1
end_undef

begin_undef
undef|#
directive|undef
name|LDW_R1_R21
end_undef

begin_undef
undef|#
directive|undef
name|LDW_R1_DLT
end_undef

begin_undef
undef|#
directive|undef
name|LDW_R1_R19
end_undef

begin_undef
undef|#
directive|undef
name|ADDIL_R19
end_undef

begin_undef
undef|#
directive|undef
name|LDW_R1_DP
end_undef

begin_undef
undef|#
directive|undef
name|LDSID_R21_R1
end_undef

begin_undef
undef|#
directive|undef
name|MTSP_R1
end_undef

begin_undef
undef|#
directive|undef
name|BE_SR0_R21
end_undef

begin_undef
undef|#
directive|undef
name|STW_RP
end_undef

begin_undef
undef|#
directive|undef
name|BV_R0_R21
end_undef

begin_undef
undef|#
directive|undef
name|BL_RP
end_undef

begin_undef
undef|#
directive|undef
name|NOP
end_undef

begin_undef
undef|#
directive|undef
name|LDW_RP
end_undef

begin_undef
undef|#
directive|undef
name|LDSID_RP_R1
end_undef

begin_undef
undef|#
directive|undef
name|BE_SR0_RP
end_undef

begin_comment
comment|/* As above, but don't actually build the stub.  Just bump offset so    we know stub section sizes.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|hppa_size_one_stub
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|gen_entry
parameter_list|,
name|void
modifier|*
name|in_arg
parameter_list|)
block|{
name|struct
name|elf32_hppa_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
name|struct
name|elf32_hppa_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* Massage our args to the form they really have.  */
name|stub_entry
operator|=
operator|(
expr|struct
name|elf32_hppa_stub_hash_entry
operator|*
operator|)
name|gen_entry
expr_stmt|;
name|htab
operator|=
name|in_arg
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|->
name|stub_type
operator|==
name|hppa_stub_long_branch
condition|)
name|size
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|stub_entry
operator|->
name|stub_type
operator|==
name|hppa_stub_long_branch_shared
condition|)
name|size
operator|=
literal|12
expr_stmt|;
elseif|else
if|if
condition|(
name|stub_entry
operator|->
name|stub_type
operator|==
name|hppa_stub_export
condition|)
name|size
operator|=
literal|24
expr_stmt|;
else|else
comment|/* hppa_stub_import or hppa_stub_import_shared.  */
block|{
if|if
condition|(
name|htab
operator|->
name|multi_subspace
condition|)
name|size
operator|=
literal|28
expr_stmt|;
else|else
name|size
operator|=
literal|16
expr_stmt|;
block|}
name|stub_entry
operator|->
name|stub_sec
operator|->
name|_raw_size
operator|+=
name|size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if ABFD represents an HPPA ELF32 file.    Additionally we set the default architecture and machine.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_hppa_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_target
argument_list|(
name|abfd
argument_list|)
argument_list|,
literal|"elf32-hppa-linux"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* GCC on hppa-linux produces binaries with OSABI=Linux, 	 but the kernel produces corefiles with OSABI=SysV.  */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|!=
name|ELFOSABI_LINUX
operator|&&
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|!=
name|ELFOSABI_NONE
condition|)
comment|/* aka SYSV */
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_target
argument_list|(
name|abfd
argument_list|)
argument_list|,
literal|"elf32-hppa-netbsd"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* GCC on hppa-netbsd produces binaries with OSABI=NetBSD, 	 but the kernel produces corefiles with OSABI=SysV.  */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|!=
name|ELFOSABI_NETBSD
operator|&&
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|!=
name|ELFOSABI_NONE
condition|)
comment|/* aka SYSV */
return|return
name|FALSE
return|;
block|}
else|else
block|{
if|if
condition|(
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|!=
name|ELFOSABI_HPUX
condition|)
return|return
name|FALSE
return|;
block|}
name|flags
operator|=
name|i_ehdrp
operator|->
name|e_flags
expr_stmt|;
switch|switch
condition|(
name|flags
operator|&
operator|(
name|EF_PARISC_ARCH
operator||
name|EF_PARISC_WIDE
operator|)
condition|)
block|{
case|case
name|EFA_PARISC_1_0
case|:
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_hppa
argument_list|,
literal|10
argument_list|)
return|;
case|case
name|EFA_PARISC_1_1
case|:
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_hppa
argument_list|,
literal|11
argument_list|)
return|;
case|case
name|EFA_PARISC_2_0
case|:
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_hppa
argument_list|,
literal|20
argument_list|)
return|;
case|case
name|EFA_PARISC_2_0
operator||
name|EF_PARISC_WIDE
case|:
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_hppa
argument_list|,
literal|25
argument_list|)
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create the .plt and .got sections, and set up our hash table    short-cuts to various dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_hppa_create_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf32_hppa_link_hash_table
modifier|*
name|htab
decl_stmt|;
comment|/* Don't try to create the .plt and .got twice.  */
name|htab
operator|=
name|hppa_link_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|splt
operator|!=
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* Call the generic code to do most of the work.  */
if|if
condition|(
operator|!
name|_bfd_elf_create_dynamic_sections
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|htab
operator|->
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|srelplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|srelgot
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|srelgot
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|htab
operator|->
name|srelgot
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|htab
operator|->
name|srelgot
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|htab
operator|->
name|sdynbss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|srelbss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rela.bss"
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Copy the extra info we tack onto an elf_link_hash_entry.  */
end_comment

begin_function
specifier|static
name|void
name|elf32_hppa_copy_indirect_symbol
parameter_list|(
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|dir
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|ind
parameter_list|)
block|{
name|struct
name|elf32_hppa_link_hash_entry
modifier|*
name|edir
decl_stmt|,
modifier|*
name|eind
decl_stmt|;
name|edir
operator|=
operator|(
expr|struct
name|elf32_hppa_link_hash_entry
operator|*
operator|)
name|dir
expr_stmt|;
name|eind
operator|=
operator|(
expr|struct
name|elf32_hppa_link_hash_entry
operator|*
operator|)
name|ind
expr_stmt|;
if|if
condition|(
name|eind
operator|->
name|dyn_relocs
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|edir
operator|->
name|dyn_relocs
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf32_hppa_dyn_reloc_entry
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|elf32_hppa_dyn_reloc_entry
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|ind
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Add reloc counts against the weak sym to the strong sym 	     list.  Merge any entries against the same section.  */
for|for
control|(
name|pp
operator|=
operator|&
name|eind
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|struct
name|elf32_hppa_dyn_reloc_entry
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|edir
operator|->
name|dyn_relocs
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
if|if
condition|(
name|q
operator|->
name|sec
operator|==
name|p
operator|->
name|sec
condition|)
block|{
if|#
directive|if
name|RELATIVE_DYNRELOCS
name|q
operator|->
name|relative_count
operator|+=
name|p
operator|->
name|relative_count
expr_stmt|;
endif|#
directive|endif
name|q
operator|->
name|count
operator|+=
name|p
operator|->
name|count
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|edir
operator|->
name|dyn_relocs
expr_stmt|;
block|}
name|edir
operator|->
name|dyn_relocs
operator|=
name|eind
operator|->
name|dyn_relocs
expr_stmt|;
name|eind
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ELIMINATE_COPY_RELOCS
operator|&&
name|ind
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_indirect
operator|&&
operator|(
name|dir
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DYNAMIC_ADJUSTED
operator|)
operator|!=
literal|0
condition|)
comment|/* If called to transfer flags for a weakdef during processing        of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.        We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
name|dir
operator|->
name|elf_link_hash_flags
operator||=
operator|(
name|ind
operator|->
name|elf_link_hash_flags
operator|&
operator|(
name|ELF_LINK_HASH_REF_DYNAMIC
operator||
name|ELF_LINK_HASH_REF_REGULAR
operator||
name|ELF_LINK_HASH_REF_REGULAR_NONWEAK
operator||
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|)
expr_stmt|;
else|else
name|_bfd_elf_link_hash_copy_indirect
argument_list|(
name|bed
argument_list|,
name|dir
argument_list|,
name|ind
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase, and    calculate needed space in the global offset table, procedure linkage    table, and dynamic reloc sections.  At this point we haven't    necessarily read all the input files.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_hppa_check_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|struct
name|elf32_hppa_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|asection
modifier|*
name|stubreloc
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|htab
operator|=
name|hppa_link_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|stubreloc
operator|=
name|NULL
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
enum|enum
block|{
name|NEED_GOT
init|=
literal|1
block|,
name|NEED_PLT
init|=
literal|2
block|,
name|NEED_DYNREL
init|=
literal|4
block|,
name|PLT_PLABEL
init|=
literal|8
block|}
enum|;
name|unsigned
name|int
name|r_symndx
decl_stmt|,
name|r_type
decl_stmt|;
name|struct
name|elf32_hppa_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|int
name|need_entry
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
name|h
operator|=
operator|(
operator|(
expr|struct
name|elf32_hppa_link_hash_entry
operator|*
operator|)
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
operator|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PARISC_DLTIND14F
case|:
case|case
name|R_PARISC_DLTIND14R
case|:
case|case
name|R_PARISC_DLTIND21L
case|:
comment|/* This symbol requires a global offset table entry.  */
name|need_entry
operator|=
name|NEED_GOT
expr_stmt|;
break|break;
case|case
name|R_PARISC_PLABEL14R
case|:
comment|/* "Official" procedure labels.  */
case|case
name|R_PARISC_PLABEL21L
case|:
case|case
name|R_PARISC_PLABEL32
case|:
comment|/* If the addend is non-zero, we break badly.  */
if|if
condition|(
name|rel
operator|->
name|r_addend
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If we are creating a shared library, then we need to 	     create a PLT entry for all PLABELs, because PLABELs with 	     local symbols may be passed via a pointer to another 	     object.  Additionally, output a dynamic relocation 	     pointing to the PLT entry. 	     For executables, the original 32-bit ABI allowed two 	     different styles of PLABELs (function pointers):  For 	     global functions, the PLABEL word points into the .plt 	     two bytes past a (function address, gp) pair, and for 	     local functions the PLABEL points directly at the 	     function.  The magic +2 for the first type allows us to 	     differentiate between the two.  As you can imagine, this 	     is a real pain when it comes to generating code to call 	     functions indirectly or to compare function pointers. 	     We avoid the mess by always pointing a PLABEL into the 	     .plt, even for local functions.  */
name|need_entry
operator|=
name|PLT_PLABEL
operator||
name|NEED_PLT
operator||
name|NEED_DYNREL
expr_stmt|;
break|break;
case|case
name|R_PARISC_PCREL12F
case|:
name|htab
operator|->
name|has_12bit_branch
operator|=
literal|1
expr_stmt|;
goto|goto
name|branch_common
goto|;
case|case
name|R_PARISC_PCREL17C
case|:
case|case
name|R_PARISC_PCREL17F
case|:
name|htab
operator|->
name|has_17bit_branch
operator|=
literal|1
expr_stmt|;
goto|goto
name|branch_common
goto|;
case|case
name|R_PARISC_PCREL22F
case|:
name|htab
operator|->
name|has_22bit_branch
operator|=
literal|1
expr_stmt|;
name|branch_common
label|:
comment|/* Function calls might need to go through the .plt, and 	     might require long branch stubs.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
comment|/* We know local syms won't need a .plt entry, and if 		 they need a long branch stub we can't guarantee that 		 we can reach the stub.  So just flag an error later 		 if we're doing a shared link and find we need a long 		 branch stub.  */
continue|continue;
block|}
else|else
block|{
comment|/* Global symbols will need a .plt entry if they remain 		 global, and in most cases won't need a long branch 		 stub.  Unfortunately, we have to cater for the case 		 where a symbol is forced local by versioning, or due 		 to symbolic linking, and we lose the .plt entry.  */
name|need_entry
operator|=
name|NEED_PLT
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|elf
operator|.
name|type
operator|==
name|STT_PARISC_MILLI
condition|)
name|need_entry
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|R_PARISC_SEGBASE
case|:
comment|/* Used to set segment base.  */
case|case
name|R_PARISC_SEGREL32
case|:
comment|/* Relative reloc, used for unwind.  */
case|case
name|R_PARISC_PCREL14F
case|:
comment|/* PC relative load/store.  */
case|case
name|R_PARISC_PCREL14R
case|:
case|case
name|R_PARISC_PCREL17R
case|:
comment|/* External branches.  */
case|case
name|R_PARISC_PCREL21L
case|:
comment|/* As above, and for load/store too.  */
case|case
name|R_PARISC_PCREL32
case|:
comment|/* We don't need to propagate the relocation if linking a 	     shared object since these are section relative.  */
continue|continue;
case|case
name|R_PARISC_DPREL14F
case|:
comment|/* Used for gp rel data load/store.  */
case|case
name|R_PARISC_DPREL14R
case|:
case|case
name|R_PARISC_DPREL21L
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: relocation %s can not be used when making a shared object; recompile with -fPIC"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|elf_hppa_howto_table
index|[
name|r_type
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Fall through.  */
case|case
name|R_PARISC_DIR17F
case|:
comment|/* Used for external branches.  */
case|case
name|R_PARISC_DIR17R
case|:
case|case
name|R_PARISC_DIR14F
case|:
comment|/* Used for load/store from absolute locn.  */
case|case
name|R_PARISC_DIR14R
case|:
case|case
name|R_PARISC_DIR21L
case|:
comment|/* As above, and for ext branches too.  */
if|#
directive|if
literal|0
comment|/* Help debug shared library creation.  Any of the above 	     relocs can be used in shared libs, but they may cause 	     pages to become unshared.  */
block|if (info->shared) 	    { 	      (*_bfd_error_handler) 		(_("%s: relocation %s should not be used when making a shared object; recompile with -fPIC"), 		 bfd_archive_filename (abfd), 		 elf_hppa_howto_table[r_type].name); 	    }
comment|/* Fall through.  */
endif|#
directive|endif
case|case
name|R_PARISC_DIR32
case|:
comment|/* .word relocs.  */
comment|/* We may want to output a dynamic relocation later.  */
name|need_entry
operator|=
name|NEED_DYNREL
expr_stmt|;
break|break;
comment|/* This relocation describes the C++ object vtable hierarchy. 	     Reconstruct it for later use during GC.  */
case|case
name|R_PARISC_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|&
name|h
operator|->
name|elf
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
continue|continue;
comment|/* This relocation describes which C++ vtable entries are actually 	     used.  Record for later use during GC.  */
case|case
name|R_PARISC_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|&
name|h
operator|->
name|elf
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|FALSE
return|;
continue|continue;
default|default:
continue|continue;
block|}
comment|/* Now carry out our orders.  */
if|if
condition|(
name|need_entry
operator|&
name|NEED_GOT
condition|)
block|{
comment|/* Allocate space for a GOT entry, as well as a dynamic 	     relocation for this entry.  */
if|if
condition|(
name|htab
operator|->
name|sgot
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|==
name|NULL
condition|)
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|elf32_hppa_create_dynamic_sections
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|h
operator|->
name|elf
operator|.
name|got
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
comment|/* This is a global offset table entry for a local symbol.  */
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
comment|/* Allocate space for local got offsets and local 		     plt offsets.  Done this way to save polluting 		     elf_obj_tdata with another target specific 		     pointer.  */
name|size
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|size
operator|*=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|bfd_signed_vma
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_got_refcounts
expr_stmt|;
block|}
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|+=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|need_entry
operator|&
name|NEED_PLT
condition|)
block|{
comment|/* If we are creating a shared library, and this is a reloc 	     against a weak symbol or a global symbol in a dynamic 	     object, then we will be creating an import stub and a 	     .plt entry for the symbol.  Similarly, on a normal link 	     to symbols defined in a dynamic object we'll need the 	     import stub and a .plt entry.  We don't know yet whether 	     the symbol is defined or not, so make an entry anyway and 	     clean up later in adjust_dynamic_symbol.  */
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|h
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
name|h
operator|->
name|elf
operator|.
name|plt
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
comment|/* If this .plt entry is for a plabel, mark it so 		     that adjust_dynamic_symbol will keep the entry 		     even if it appears to be local.  */
if|if
condition|(
name|need_entry
operator|&
name|PLT_PLABEL
condition|)
name|h
operator|->
name|plabel
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|need_entry
operator|&
name|PLT_PLABEL
condition|)
block|{
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|local_plt_refcounts
decl_stmt|;
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
comment|/* Allocate space for local got offsets and local 			 plt offsets.  */
name|size
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|size
operator|*=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|bfd_signed_vma
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_got_refcounts
expr_stmt|;
block|}
name|local_plt_refcounts
operator|=
operator|(
name|local_got_refcounts
operator|+
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|local_plt_refcounts
index|[
name|r_symndx
index|]
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|need_entry
operator|&
name|NEED_DYNREL
condition|)
block|{
comment|/* Flag this symbol as having a non-got, non-plt reference 	     so that we generate copy relocs if it turns out to be 	     dynamic.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|!
name|info
operator|->
name|shared
condition|)
name|h
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator||=
name|ELF_LINK_NON_GOT_REF
expr_stmt|;
comment|/* If we are creating a shared library then we need to copy 	     the reloc into the shared library.  However, if we are 	     linking with -Bsymbolic, we need only copy absolute 	     relocs or relocs against symbols that are not defined in 	     an object we are including in the link.  PC- or DP- or 	     DLT-relative relocs against any local sym or global sym 	     with DEF_REGULAR set, can be discarded.  At this point we 	     have not seen all the input files, so it is possible that 	     DEF_REGULAR is not set now but will be set later (it is 	     never cleared).  We account for that possibility below by 	     storing information in the dyn_relocs field of the 	     hash table entry.  	     A similar situation to the -Bsymbolic case occurs when 	     creating shared libraries and symbol visibility changes 	     render the symbol local.  	     As it turns out, all the relocs we will be creating here 	     are absolute, so we cannot remove them on -Bsymbolic 	     links or visibility changes anyway.  A STUB_REL reloc 	     is absolute too, as in that case it is the reloc in the 	     stub we will be creating, rather than copying the PCREL 	     reloc in the branch.  	     If on the other hand, we are creating an executable, we 	     may need to keep relocations for symbols satisfied by a 	     dynamic library if we manage to avoid copy relocs for the 	     symbol.  */
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|IS_ABSOLUTE_RELOC
argument_list|(
name|r_type
argument_list|)
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|(
name|h
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|ELIMINATE_COPY_RELOCS
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|(
name|h
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|struct
name|elf32_hppa_dyn_reloc_entry
modifier|*
name|p
decl_stmt|;
name|struct
name|elf32_hppa_dyn_reloc_entry
modifier|*
modifier|*
name|head
decl_stmt|;
comment|/* Create a reloc section in dynobj and make room for 		 this reloc.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Could not find relocation section for %s"
argument_list|)
argument_list|,
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|==
name|NULL
condition|)
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|=
name|abfd
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
name|sreloc
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sreloc
operator|=
name|sreloc
expr_stmt|;
block|}
comment|/* If this is a global symbol, we count the number of 		 relocations we need for this symbol.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|head
operator|=
operator|&
name|h
operator|->
name|dyn_relocs
expr_stmt|;
block|}
else|else
block|{
comment|/* Track dynamic relocs needed for local syms too. 		     We really need local syms available to do this 		     easily.  Oh well.  */
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|bfd_section_from_r_symndx
argument_list|(
name|abfd
argument_list|,
operator|&
name|htab
operator|->
name|sym_sec
argument_list|,
name|sec
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|head
operator|=
operator|(
operator|(
expr|struct
name|elf32_hppa_dyn_reloc_entry
operator|*
operator|*
operator|)
operator|&
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
operator|)
expr_stmt|;
block|}
name|p
operator|=
operator|*
name|head
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
operator|->
name|sec
operator|!=
name|sec
condition|)
block|{
name|p
operator|=
name|bfd_alloc
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
sizeof|sizeof
expr|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|p
operator|->
name|next
operator|=
operator|*
name|head
expr_stmt|;
operator|*
name|head
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
name|p
operator|->
name|count
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|RELATIVE_DYNRELOCS
name|p
operator|->
name|relative_count
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|p
operator|->
name|count
operator|+=
literal|1
expr_stmt|;
if|#
directive|if
name|RELATIVE_DYNRELOCS
if|if
condition|(
operator|!
name|IS_ABSOLUTE_RELOC
argument_list|(
name|rtype
argument_list|)
condition|)
name|p
operator|->
name|relative_count
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return the section that should be marked against garbage collection    for a given relocation.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|elf32_hppa_gc_mark_hook
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
operator|(
name|unsigned
name|int
operator|)
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_PARISC_GNU_VTINHERIT
case|:
case|case
name|R_PARISC_GNU_VTENTRY
case|:
break|break;
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
default|default:
break|break;
block|}
block|}
block|}
else|else
return|return
name|bfd_section_from_elf_index
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Update the got and plt entry reference counts for the section being    removed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_hppa_gc_sweep_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|local_plt_refcounts
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|local_dynrel
operator|=
name|NULL
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_plt_refcounts
operator|=
name|local_got_refcounts
expr_stmt|;
if|if
condition|(
name|local_plt_refcounts
operator|!=
name|NULL
condition|)
name|local_plt_refcounts
operator|+=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|unsigned
name|int
name|r_type
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|struct
name|elf32_hppa_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf32_hppa_dyn_reloc_entry
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|elf32_hppa_dyn_reloc_entry
modifier|*
name|p
decl_stmt|;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf32_hppa_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|sec
operator|==
name|sec
condition|)
block|{
comment|/* Everything must go for SEC.  */
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PARISC_DLTIND14F
case|:
case|case
name|R_PARISC_DLTIND14R
case|:
case|case
name|R_PARISC_DLTIND21L
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|got
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|local_got_refcounts
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|>
literal|0
condition|)
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|-=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|R_PARISC_PCREL12F
case|:
case|case
name|R_PARISC_PCREL17C
case|:
case|case
name|R_PARISC_PCREL17F
case|:
case|case
name|R_PARISC_PCREL22F
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|plt
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|R_PARISC_PLABEL14R
case|:
case|case
name|R_PARISC_PLABEL21L
case|:
case|case
name|R_PARISC_PLABEL32
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|plt
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|local_plt_refcounts
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|local_plt_refcounts
index|[
name|r_symndx
index|]
operator|>
literal|0
condition|)
name|local_plt_refcounts
index|[
name|r_symndx
index|]
operator|-=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Our own version of hide_symbol, so that we can keep plt entries for    plabels.  */
end_comment

begin_function
specifier|static
name|void
name|elf32_hppa_hide_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|bfd_boolean
name|force_local
parameter_list|)
block|{
if|if
condition|(
name|force_local
condition|)
block|{
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_FORCED_LOCAL
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
block|{
name|h
operator|->
name|dynindx
operator|=
operator|-
literal|1
expr_stmt|;
name|_bfd_elf_strtab_delref
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|h
operator|->
name|dynstr_index
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
operator|(
expr|struct
name|elf32_hppa_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|plabel
condition|)
block|{
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_hppa_adjust_dynamic_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
name|struct
name|elf32_hppa_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|power_of_two
decl_stmt|;
comment|/* If this is a function, put it in the procedure linkage table.  We      will fill in the contents of the procedure linkage table later.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|<=
literal|0
operator|||
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|&&
operator|!
operator|(
operator|(
expr|struct
name|elf32_hppa_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|plabel
operator|&&
operator|(
operator|!
name|info
operator|->
name|shared
operator|||
name|info
operator|->
name|symbolic
operator|)
operator|)
condition|)
block|{
comment|/* The .plt entry is not needed when: 	     a) Garbage collection has removed all references to the 	     symbol, or 	     b) We know for certain the symbol is defined in this 	     object, and it's not a weak definition, nor is the symbol 	     used by a plabel relocation.  Either this object is the 	     application or we are doing a shared symbolic link.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
else|else
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
name|abort
argument_list|()
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|ELIMINATE_COPY_RELOCS
condition|)
name|h
operator|->
name|elf_link_hash_flags
operator|=
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
operator|~
name|ELF_LINK_NON_GOT_REF
operator|)
operator||
operator|(
name|h
operator|->
name|weakdef
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_GOT_REF
operator|)
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
comment|/* If we are creating a shared library, we must presume that the      only references to the symbol are via the global offset table.      For such cases we need not do anything here; the relocations will      be handled correctly by relocate_section.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
return|return
name|TRUE
return|;
comment|/* If there are no references to this symbol that do not use the      GOT, we don't need to generate a copy reloc.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_GOT_REF
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|ELIMINATE_COPY_RELOCS
condition|)
block|{
name|struct
name|elf32_hppa_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf32_hppa_dyn_reloc_entry
modifier|*
name|p
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf32_hppa_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|s
operator|=
name|p
operator|->
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* If we didn't find any dynamic relocs in read-only sections, then 	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_GOT_REF
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
comment|/* We must allocate the symbol in our .dynbss section, which will      become part of the .bss section of the executable.  There will be      an entry for this symbol in the .dynsym section.  The dynamic      object will contain position independent code, so all references      from the dynamic object to this symbol will go through the global      offset table.  The dynamic linker will use the .dynsym entry to      determine the address it must put in the global offset table, so      both the dynamic object and the regular object will refer to the      same memory location for the variable.  */
name|htab
operator|=
name|hppa_link_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* We must generate a COPY reloc to tell the dynamic linker to      copy the initial value out of the dynamic object and into the      runtime process image.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|htab
operator|->
name|srelbss
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_COPY
expr_stmt|;
block|}
comment|/* We need to figure out the alignment required for this symbol.  I      have no idea how other ELF linkers handle this.  */
name|power_of_two
operator|=
name|bfd_log2
argument_list|(
name|h
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
literal|3
condition|)
name|power_of_two
operator|=
literal|3
expr_stmt|;
comment|/* Apply the required alignment.  */
name|s
operator|=
name|htab
operator|->
name|sdynbss
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
name|BFD_ALIGN
argument_list|(
name|s
operator|->
name|_raw_size
argument_list|,
call|(
name|bfd_size_type
call|)
argument_list|(
literal|1
operator|<<
name|power_of_two
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
name|bfd_get_section_alignment
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_alignment
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|s
argument_list|,
name|power_of_two
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Define the symbol as being at this point in the section.  */
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* Increment the section size to make room for the symbol.  */
name|s
operator|->
name|_raw_size
operator|+=
name|h
operator|->
name|size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Allocate space in the .plt for entries that won't have relocations.    ie. plabel entries.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|allocate_plt_static
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf32_hppa_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|info
operator|=
name|inf
expr_stmt|;
name|htab
operator|=
name|hppa_link_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
operator|&&
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol. 	 Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
operator|&&
name|h
operator|->
name|type
operator|!=
name|STT_PARISC_MILLI
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
literal|1
argument_list|,
name|info
operator|->
name|shared
argument_list|,
name|h
argument_list|)
condition|)
block|{
comment|/* Allocate these later.  From this point on, h->plabel 	     means that the plt entry is only used by a plabel. 	     We'll be using a normal plt entry for this symbol, so 	     clear the plabel indicator.  */
operator|(
operator|(
expr|struct
name|elf32_hppa_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|plabel
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
expr|struct
name|elf32_hppa_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|plabel
condition|)
block|{
comment|/* Make an entry in the .plt section for plabel references 	     that won't have a .plt entry for other reasons.  */
name|s
operator|=
name|htab
operator|->
name|splt
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
block|}
else|else
block|{
comment|/* No .plt entry needed.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
block|}
else|else
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Allocate space in .plt, .got and associated reloc sections for    global syms.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|allocate_dynrelocs
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf32_hppa_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf32_hppa_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf32_hppa_dyn_reloc_entry
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|info
operator|=
name|inf
expr_stmt|;
name|htab
operator|=
name|hppa_link_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
operator|&&
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
operator|!
operator|(
operator|(
expr|struct
name|elf32_hppa_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|plabel
condition|)
block|{
comment|/* Make an entry in the .plt section.  */
name|s
operator|=
name|htab
operator|->
name|splt
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* We also need to make an entry in the .rela.plt section.  */
name|htab
operator|->
name|srelplt
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|htab
operator|->
name|need_plt_stub
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol. 	 Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
operator|&&
name|h
operator|->
name|type
operator|!=
name|STT_PARISC_MILLI
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|s
operator|=
name|htab
operator|->
name|sgot
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
name|GOT_ENTRY_SIZE
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
operator|&&
operator|(
name|info
operator|->
name|shared
operator|||
operator|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|htab
operator|->
name|srelgot
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|h
operator|->
name|got
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf32_hppa_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|dyn_relocs
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* If this is a -Bsymbolic shared link, then we need to discard all      space allocated for dynamic pc-relative relocs against symbols      defined in a regular object.  For the normal shared case, discard      space for relocs that have become local due to symbol visibility      changes.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
if|#
directive|if
name|RELATIVE_DYNRELOCS
if|if
condition|(
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|struct
name|elf32_hppa_dyn_reloc_entry
modifier|*
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|p
operator|->
name|count
operator|-=
name|p
operator|->
name|relative_count
expr_stmt|;
name|p
operator|->
name|relative_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
else|else
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Also discard relocs on undefined weak syms with non-default 	 visibility.  */
if|if
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_DEFAULT
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* For the non-shared case, discard space for relocs against 	 symbols which turn out to need copy relocs or are not 	 dynamic.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_GOT_REF
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|ELIMINATE_COPY_RELOCS
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol. 	     Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
operator|&&
name|h
operator|->
name|type
operator|!=
name|STT_PARISC_MILLI
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If that succeeded, we know we'll be keeping all the 	     relocs.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
goto|goto
name|keep
goto|;
block|}
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
name|keep
label|:
empty_stmt|;
block|}
comment|/* Finally, allocate space.  */
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|sreloc
init|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|->
name|sreloc
decl_stmt|;
name|sreloc
operator|->
name|_raw_size
operator|+=
name|p
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This function is called via elf_link_hash_traverse to force    millicode symbols local so they do not end up as globals in the    dynamic symbol table.  We ought to be able to do this in    adjust_dynamic_symbol, but our adjust_dynamic_symbol is not called    for all dynamic symbols.  Arguably, this is a bug in    elf_adjust_dynamic_symbol.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|clobber_millicode_symbols
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_PARISC_MILLI
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
condition|)
block|{
name|elf32_hppa_hide_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Find any dynamic relocs that apply to read-only sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|readonly_dynrelocs
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|elf32_hppa_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf32_hppa_dyn_reloc_entry
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf32_hppa_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|s
init|=
name|p
operator|->
name|sec
operator|->
name|output_section
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
name|inf
decl_stmt|;
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
comment|/* Not an error, just cut short the traversal.  */
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_hppa_size_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf32_hppa_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_boolean
name|relocs
decl_stmt|;
name|htab
operator|=
name|hppa_link_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
comment|/* Force millicode symbols local.  */
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|clobber_millicode_symbols
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
comment|/* Set up .got and .plt offsets for local syms, and space for local      dynamic relocs.  */
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|bfd_signed_vma
modifier|*
name|local_got
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|end_local_got
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|local_plt
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|end_local_plt
decl_stmt|;
name|bfd_size_type
name|locsymcount
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
for|for
control|(
name|s
operator|=
name|ibfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|struct
name|elf32_hppa_dyn_reloc_entry
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|(
operator|(
expr|struct
name|elf32_hppa_dyn_reloc_entry
operator|*
operator|)
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
operator|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|&&
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|sec
operator|->
name|output_section
argument_list|)
condition|)
block|{
comment|/* Input section has been discarded, either because 		     it is a copy of a linkonce section or due to 		     linker script /DISCARD/, so we'll be discarding 		     the relocs too.  */
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|count
operator|!=
literal|0
condition|)
block|{
name|srel
operator|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|->
name|sreloc
expr_stmt|;
name|srel
operator|->
name|_raw_size
operator|+=
name|p
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|sec
operator|->
name|output_section
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
block|}
block|}
name|local_got
operator|=
name|elf_local_got_refcounts
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_got
condition|)
continue|continue;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|end_local_got
operator|=
name|local_got
operator|+
name|locsymcount
expr_stmt|;
name|s
operator|=
name|htab
operator|->
name|sgot
expr_stmt|;
name|srel
operator|=
name|htab
operator|->
name|srelgot
expr_stmt|;
for|for
control|(
init|;
name|local_got
operator|<
name|end_local_got
condition|;
operator|++
name|local_got
control|)
block|{
if|if
condition|(
operator|*
name|local_got
operator|>
literal|0
condition|)
block|{
operator|*
name|local_got
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
name|GOT_ENTRY_SIZE
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|srel
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|local_got
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|local_plt
operator|=
name|end_local_got
expr_stmt|;
name|end_local_plt
operator|=
name|local_plt
operator|+
name|locsymcount
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
comment|/* Won't be used, but be safe.  */
for|for
control|(
init|;
name|local_plt
operator|<
name|end_local_plt
condition|;
operator|++
name|local_plt
control|)
operator|*
name|local_plt
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|htab
operator|->
name|splt
expr_stmt|;
name|srel
operator|=
name|htab
operator|->
name|srelplt
expr_stmt|;
for|for
control|(
init|;
name|local_plt
operator|<
name|end_local_plt
condition|;
operator|++
name|local_plt
control|)
block|{
if|if
condition|(
operator|*
name|local_plt
operator|>
literal|0
condition|)
block|{
operator|*
name|local_plt
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|srel
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|local_plt
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Do all the .plt entries without relocs first.  The dynamic linker      uses the last .plt reloc to find the end of the .plt (and hence      the start of the .got) for lazy linking.  */
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|allocate_plt_static
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* Allocate global sym .plt and .got entries, and space for global      sym dynamic relocs.  */
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|allocate_dynrelocs
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* The check_relocs and adjust_dynamic_symbol entry points have      determined the sizes of the various dynamic sections.  Allocate      memory for them.  */
name|relocs
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|s
operator|==
name|htab
operator|->
name|splt
condition|)
block|{
if|if
condition|(
name|htab
operator|->
name|need_plt_stub
condition|)
block|{
comment|/* Make space for the plt stub at the end of the .plt 		 section.  We want this stub right at the end, up 		 against the .got section.  */
name|int
name|gotalign
init|=
name|bfd_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|sgot
argument_list|)
decl_stmt|;
name|int
name|pltalign
init|=
name|bfd_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
decl_stmt|;
name|bfd_size_type
name|mask
decl_stmt|;
if|if
condition|(
name|gotalign
operator|>
name|pltalign
condition|)
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
name|gotalign
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
name|bfd_size_type
operator|)
literal|1
operator|<<
name|gotalign
operator|)
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
operator|(
name|s
operator|->
name|_raw_size
operator|+
sizeof|sizeof
argument_list|(
name|plt_stub
argument_list|)
operator|+
name|mask
operator|)
operator|&
operator|~
name|mask
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|s
operator|==
name|htab
operator|->
name|sgot
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
comment|/* Remember whether there are any reloc sections other 		 than .rela.plt.  */
if|if
condition|(
name|s
operator|!=
name|htab
operator|->
name|srelplt
condition|)
name|relocs
operator|=
name|TRUE
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need 		 to copy relocs into the output file.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
comment|/* If we don't need this section, strip it from the 	     output file.  This is mostly to handle .rela.bss and 	     .rela.plt.  We must create both sections in 	     create_dynamic_sections, because they must be created 	     before the linker maps input sections to output 	     sections.  The linker does that before 	     adjust_dynamic_symbol is called, and it is that 	     function which decides whether anything needs to go 	     into these sections.  */
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Allocate memory for the section contents.  Zero it, because 	 we may not fill in all the reloc sections.  */
name|s
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|s
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
comment|/* Like IA-64 and HPPA64, always create a DT_PLTGOT.  It 	 actually has nothing to do with the PLT, it is how we 	 communicate the LTP value of a load module to the dynamic 	 linker.  */
define|#
directive|define
name|add_dynamic_entry
parameter_list|(
name|TAG
parameter_list|,
name|VAL
parameter_list|)
define|\
value|_bfd_elf_add_dynamic_entry (info, TAG, VAL)
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in elf32_hppa_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|srelplt
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTREL
argument_list|,
name|DT_RELA
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|relocs
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELA
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELAENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If any dynamic relocs apply to a read-only section, 	     then we need a DT_TEXTREL entry.  */
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|==
literal|0
condition|)
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|readonly_dynrelocs
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
block|}
undef|#
directive|undef
name|add_dynamic_entry
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* External entry points for sizing and building linker stubs.  */
end_comment

begin_comment
comment|/* Set up various things so that we can make a list of input sections    for each output section included in the link.  Returns -1 on error,    0 when no stubs will be needed, and 1 on success.  */
end_comment

begin_function
name|int
name|elf32_hppa_setup_section_lists
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|unsigned
name|int
name|bfd_count
decl_stmt|;
name|int
name|top_id
decl_stmt|,
name|top_index
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asection
modifier|*
modifier|*
name|input_list
decl_stmt|,
modifier|*
modifier|*
name|list
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|struct
name|elf32_hppa_link_hash_table
modifier|*
name|htab
init|=
name|hppa_link_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
comment|/* Count the number of input BFDs and find the top input section id.  */
for|for
control|(
name|input_bfd
operator|=
name|info
operator|->
name|input_bfds
operator|,
name|bfd_count
operator|=
literal|0
operator|,
name|top_id
operator|=
literal|0
init|;
name|input_bfd
operator|!=
name|NULL
condition|;
name|input_bfd
operator|=
name|input_bfd
operator|->
name|link_next
control|)
block|{
name|bfd_count
operator|+=
literal|1
expr_stmt|;
for|for
control|(
name|section
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
if|if
condition|(
name|top_id
operator|<
name|section
operator|->
name|id
condition|)
name|top_id
operator|=
name|section
operator|->
name|id
expr_stmt|;
block|}
block|}
name|htab
operator|->
name|bfd_count
operator|=
name|bfd_count
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|map_stub
argument_list|)
operator|*
operator|(
name|top_id
operator|+
literal|1
operator|)
expr_stmt|;
name|htab
operator|->
name|stub_group
operator|=
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|stub_group
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* We can't use output_bfd->section_count here to find the top output      section index as some sections may have been removed, and      _bfd_strip_section_from_output doesn't renumber the indices.  */
for|for
control|(
name|section
operator|=
name|output_bfd
operator|->
name|sections
operator|,
name|top_index
operator|=
literal|0
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
if|if
condition|(
name|top_index
operator|<
name|section
operator|->
name|index
condition|)
name|top_index
operator|=
name|section
operator|->
name|index
expr_stmt|;
block|}
name|htab
operator|->
name|top_index
operator|=
name|top_index
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
operator|*
operator|(
name|top_index
operator|+
literal|1
operator|)
expr_stmt|;
name|input_list
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
name|htab
operator|->
name|input_list
operator|=
name|input_list
expr_stmt|;
if|if
condition|(
name|input_list
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* For sections we aren't interested in, mark their entries with a      value we can check later.  */
name|list
operator|=
name|input_list
operator|+
name|top_index
expr_stmt|;
do|do
operator|*
name|list
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
do|while
condition|(
name|list
operator|--
operator|!=
name|input_list
condition|)
do|;
for|for
control|(
name|section
operator|=
name|output_bfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
name|input_list
index|[
name|section
operator|->
name|index
index|]
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The linker repeatedly calls this function for each input section,    in the order that input sections are linked into output sections.    Build lists of input sections to determine groupings between which    we may insert linker stubs.  */
end_comment

begin_function
name|void
name|elf32_hppa_next_input_section
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|isec
parameter_list|)
block|{
name|struct
name|elf32_hppa_link_hash_table
modifier|*
name|htab
init|=
name|hppa_link_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|isec
operator|->
name|output_section
operator|->
name|index
operator|<=
name|htab
operator|->
name|top_index
condition|)
block|{
name|asection
modifier|*
modifier|*
name|list
init|=
name|htab
operator|->
name|input_list
operator|+
name|isec
operator|->
name|output_section
operator|->
name|index
decl_stmt|;
if|if
condition|(
operator|*
name|list
operator|!=
name|bfd_abs_section_ptr
condition|)
block|{
comment|/* Steal the link_sec pointer for our list.  */
define|#
directive|define
name|PREV_SEC
parameter_list|(
name|sec
parameter_list|)
value|(htab->stub_group[(sec)->id].link_sec)
comment|/* This happens to make the list in reverse order, 	     which is what we want.  */
name|PREV_SEC
argument_list|(
name|isec
argument_list|)
operator|=
operator|*
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|isec
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* See whether we can group stub sections together.  Grouping stub    sections may result in fewer stubs.  More importantly, we need to    put all .init* and .fini* stubs at the beginning of the .init or    .fini output sections respectively, because glibc splits the    _init and _fini functions into multiple parts.  Putting a stub in    the middle of a function is not a good idea.  */
end_comment

begin_function
specifier|static
name|void
name|group_sections
parameter_list|(
name|struct
name|elf32_hppa_link_hash_table
modifier|*
name|htab
parameter_list|,
name|bfd_size_type
name|stub_group_size
parameter_list|,
name|bfd_boolean
name|stubs_always_before_branch
parameter_list|)
block|{
name|asection
modifier|*
modifier|*
name|list
init|=
name|htab
operator|->
name|input_list
operator|+
name|htab
operator|->
name|top_index
decl_stmt|;
do|do
block|{
name|asection
modifier|*
name|tail
init|=
operator|*
name|list
decl_stmt|;
if|if
condition|(
name|tail
operator|==
name|bfd_abs_section_ptr
condition|)
continue|continue;
while|while
condition|(
name|tail
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|curr
decl_stmt|;
name|asection
modifier|*
name|prev
decl_stmt|;
name|bfd_size_type
name|total
decl_stmt|;
name|bfd_boolean
name|big_sec
decl_stmt|;
name|curr
operator|=
name|tail
expr_stmt|;
if|if
condition|(
name|tail
operator|->
name|_cooked_size
condition|)
name|total
operator|=
name|tail
operator|->
name|_cooked_size
expr_stmt|;
else|else
name|total
operator|=
name|tail
operator|->
name|_raw_size
expr_stmt|;
name|big_sec
operator|=
name|total
operator|>=
name|stub_group_size
expr_stmt|;
while|while
condition|(
operator|(
name|prev
operator|=
name|PREV_SEC
argument_list|(
name|curr
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|total
operator|+=
name|curr
operator|->
name|output_offset
operator|-
name|prev
operator|->
name|output_offset
operator|)
operator|<
name|stub_group_size
operator|)
condition|)
name|curr
operator|=
name|prev
expr_stmt|;
comment|/* OK, the size from the start of CURR to the end is less 	     than 240000 bytes and thus can be handled by one stub 	     section.  (or the tail section is itself larger than 	     240000 bytes, in which case we may be toast.) 	     We should really be keeping track of the total size of 	     stubs added here, as stubs contribute to the final output 	     section size.  That's a little tricky, and this way will 	     only break if stubs added total more than 22144 bytes, or 	     2768 long branch stubs.  It seems unlikely for more than 	     2768 different functions to be called, especially from 	     code only 240000 bytes long.  This limit used to be 	     250000, but c++ code tends to generate lots of little 	     functions, and sometimes violated the assumption.  */
do|do
block|{
name|prev
operator|=
name|PREV_SEC
argument_list|(
name|tail
argument_list|)
expr_stmt|;
comment|/* Set up this stub group.  */
name|htab
operator|->
name|stub_group
index|[
name|tail
operator|->
name|id
index|]
operator|.
name|link_sec
operator|=
name|curr
expr_stmt|;
block|}
do|while
condition|(
name|tail
operator|!=
name|curr
operator|&&
operator|(
name|tail
operator|=
name|prev
operator|)
operator|!=
name|NULL
condition|)
do|;
comment|/* But wait, there's more!  Input sections up to 240000 	     bytes before the stub section can be handled by it too. 	     Don't do this if we have a really large section after the 	     stubs, as adding more stubs increases the chance that 	     branches may not reach into the stub section.  */
if|if
condition|(
operator|!
name|stubs_always_before_branch
operator|&&
operator|!
name|big_sec
condition|)
block|{
name|total
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|prev
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|total
operator|+=
name|tail
operator|->
name|output_offset
operator|-
name|prev
operator|->
name|output_offset
operator|)
operator|<
name|stub_group_size
operator|)
condition|)
block|{
name|tail
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|PREV_SEC
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|htab
operator|->
name|stub_group
index|[
name|tail
operator|->
name|id
index|]
operator|.
name|link_sec
operator|=
name|curr
expr_stmt|;
block|}
block|}
name|tail
operator|=
name|prev
expr_stmt|;
block|}
block|}
do|while
condition|(
name|list
operator|--
operator|!=
name|htab
operator|->
name|input_list
condition|)
do|;
name|free
argument_list|(
name|htab
operator|->
name|input_list
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PREV_SEC
block|}
end_function

begin_comment
comment|/* Read in all local syms for all input bfds, and create hash entries    for export stubs if we are building a multi-subspace shared lib.    Returns -1 on error, 1 if export stubs created, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|get_local_syms
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|unsigned
name|int
name|bfd_indx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|,
modifier|*
modifier|*
name|all_local_syms
decl_stmt|;
name|int
name|stub_changed
init|=
literal|0
decl_stmt|;
name|struct
name|elf32_hppa_link_hash_table
modifier|*
name|htab
init|=
name|hppa_link_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
comment|/* We want to read in symbol extension records only once.  To do this      we need to read in the local symbols in parallel and save them for      later use; so hold pointers to the local symbols in an array.  */
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|Elf_Internal_Sym
operator|*
argument_list|)
operator|*
name|htab
operator|->
name|bfd_count
decl_stmt|;
name|all_local_syms
operator|=
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
name|htab
operator|->
name|all_local_syms
operator|=
name|all_local_syms
expr_stmt|;
if|if
condition|(
name|all_local_syms
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Walk over all the input BFDs, swapping in local symbols.      If we are creating a shared library, create hash entries for the      export stubs.  */
for|for
control|(
name|bfd_indx
operator|=
literal|0
init|;
name|input_bfd
operator|!=
name|NULL
condition|;
name|input_bfd
operator|=
name|input_bfd
operator|->
name|link_next
operator|,
name|bfd_indx
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
comment|/* We'll need the symbol table in a second.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|symtab_hdr
operator|->
name|sh_info
operator|==
literal|0
condition|)
continue|continue;
comment|/* We need an array of the local symbols attached to the input bfd.  */
name|local_syms
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|local_syms
operator|==
name|NULL
condition|)
block|{
name|local_syms
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Cache them for elf_link_input_bfd.  */
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
expr_stmt|;
block|}
if|if
condition|(
name|local_syms
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|all_local_syms
index|[
name|bfd_indx
index|]
operator|=
name|local_syms
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
name|htab
operator|->
name|multi_subspace
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|end_hashes
decl_stmt|;
name|unsigned
name|int
name|symcount
decl_stmt|;
name|symcount
operator|=
operator|(
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|end_hashes
operator|=
name|sym_hashes
operator|+
name|symcount
expr_stmt|;
comment|/* Look through the global syms for functions;  We need to 	     build export stubs for all globally visible functions.  */
for|for
control|(
init|;
name|sym_hashes
operator|<
name|end_hashes
condition|;
name|sym_hashes
operator|++
control|)
block|{
name|struct
name|elf32_hppa_link_hash_entry
modifier|*
name|hash
decl_stmt|;
name|hash
operator|=
operator|(
expr|struct
name|elf32_hppa_link_hash_entry
operator|*
operator|)
operator|*
name|sym_hashes
expr_stmt|;
while|while
condition|(
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|hash
operator|=
operator|(
operator|(
expr|struct
name|elf32_hppa_link_hash_entry
operator|*
operator|)
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
operator|)
expr_stmt|;
comment|/* At this point in the link, undefined syms have been 		 resolved, so we need to check that the symbol was 		 defined in this BFD.  */
if|if
condition|(
operator|(
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|hash
operator|->
name|elf
operator|.
name|type
operator|==
name|STT_FUNC
operator|&&
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
operator|(
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|owner
operator|==
name|output_bfd
operator|)
operator|&&
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
operator|==
name|input_bfd
operator|&&
operator|(
name|hash
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|&&
operator|!
operator|(
name|hash
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|hash
operator|->
name|elf
operator|.
name|other
argument_list|)
operator|==
name|STV_DEFAULT
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|char
modifier|*
name|stub_name
decl_stmt|;
name|struct
name|elf32_hppa_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
name|sec
operator|=
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|stub_name
operator|=
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
name|stub_entry
operator|=
name|hppa_stub_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|stub_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|==
name|NULL
condition|)
block|{
name|stub_entry
operator|=
name|hppa_add_stub
argument_list|(
name|stub_name
argument_list|,
name|sec
argument_list|,
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stub_entry
condition|)
return|return
operator|-
literal|1
return|;
name|stub_entry
operator|->
name|target_value
operator|=
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|stub_entry
operator|->
name|target_section
operator|=
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|stub_entry
operator|->
name|stub_type
operator|=
name|hppa_stub_export
expr_stmt|;
name|stub_entry
operator|->
name|h
operator|=
name|hash
expr_stmt|;
name|stub_changed
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: duplicate export stub %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|stub_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|stub_changed
return|;
block|}
end_function

begin_comment
comment|/* Determine and set the size of the stub section for a final link.     The basic idea here is to examine all the relocations looking for    PC-relative calls to a target that is unreachable with a "bl"    instruction.  */
end_comment

begin_function
name|bfd_boolean
name|elf32_hppa_size_stubs
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|bfd
modifier|*
name|stub_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_boolean
name|multi_subspace
parameter_list|,
name|bfd_signed_vma
name|group_size
parameter_list|,
name|asection
modifier|*
function_decl|(
modifier|*
name|add_stub_section
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|layout_sections_again
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
block|{
name|bfd_size_type
name|stub_group_size
decl_stmt|;
name|bfd_boolean
name|stubs_always_before_branch
decl_stmt|;
name|bfd_boolean
name|stub_changed
decl_stmt|;
name|struct
name|elf32_hppa_link_hash_table
modifier|*
name|htab
init|=
name|hppa_link_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
comment|/* Stash our params away.  */
name|htab
operator|->
name|stub_bfd
operator|=
name|stub_bfd
expr_stmt|;
name|htab
operator|->
name|multi_subspace
operator|=
name|multi_subspace
expr_stmt|;
name|htab
operator|->
name|add_stub_section
operator|=
name|add_stub_section
expr_stmt|;
name|htab
operator|->
name|layout_sections_again
operator|=
name|layout_sections_again
expr_stmt|;
name|stubs_always_before_branch
operator|=
name|group_size
operator|<
literal|0
expr_stmt|;
if|if
condition|(
name|group_size
operator|<
literal|0
condition|)
name|stub_group_size
operator|=
operator|-
name|group_size
expr_stmt|;
else|else
name|stub_group_size
operator|=
name|group_size
expr_stmt|;
if|if
condition|(
name|stub_group_size
operator|==
literal|1
condition|)
block|{
comment|/* Default values.  */
if|if
condition|(
name|stubs_always_before_branch
condition|)
block|{
name|stub_group_size
operator|=
literal|7680000
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|has_17bit_branch
operator|||
name|htab
operator|->
name|multi_subspace
condition|)
name|stub_group_size
operator|=
literal|240000
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|has_12bit_branch
condition|)
name|stub_group_size
operator|=
literal|7500
expr_stmt|;
block|}
else|else
block|{
name|stub_group_size
operator|=
literal|6971392
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|has_17bit_branch
operator|||
name|htab
operator|->
name|multi_subspace
condition|)
name|stub_group_size
operator|=
literal|217856
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|has_12bit_branch
condition|)
name|stub_group_size
operator|=
literal|6808
expr_stmt|;
block|}
block|}
name|group_sections
argument_list|(
name|htab
argument_list|,
name|stub_group_size
argument_list|,
name|stubs_always_before_branch
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|get_local_syms
argument_list|(
name|output_bfd
argument_list|,
name|info
operator|->
name|input_bfds
argument_list|,
name|info
argument_list|)
condition|)
block|{
default|default:
if|if
condition|(
name|htab
operator|->
name|all_local_syms
condition|)
goto|goto
name|error_ret_free_local
goto|;
return|return
name|FALSE
return|;
case|case
literal|0
case|:
name|stub_changed
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|stub_changed
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|unsigned
name|int
name|bfd_indx
decl_stmt|;
name|asection
modifier|*
name|stub_sec
decl_stmt|;
for|for
control|(
name|input_bfd
operator|=
name|info
operator|->
name|input_bfds
operator|,
name|bfd_indx
operator|=
literal|0
init|;
name|input_bfd
operator|!=
name|NULL
condition|;
name|input_bfd
operator|=
name|input_bfd
operator|->
name|link_next
operator|,
name|bfd_indx
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
comment|/* We'll need the symbol table in a second.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|symtab_hdr
operator|->
name|sh_info
operator|==
literal|0
condition|)
continue|continue;
name|local_syms
operator|=
name|htab
operator|->
name|all_local_syms
index|[
name|bfd_indx
index|]
expr_stmt|;
comment|/* Walk over each section attached to the input bfd.  */
for|for
control|(
name|section
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|,
modifier|*
name|irelaend
decl_stmt|,
modifier|*
name|irela
decl_stmt|;
comment|/* If there aren't any relocs, then there's nothing more 		 to do.  */
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|section
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
comment|/* If this section is a link-once section that will be 		 discarded, then don't create any stubs.  */
if|if
condition|(
name|section
operator|->
name|output_section
operator|==
name|NULL
operator|||
name|section
operator|->
name|output_section
operator|->
name|owner
operator|!=
name|output_bfd
condition|)
continue|continue;
comment|/* Get the relocs.  */
name|internal_relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|input_bfd
argument_list|,
name|section
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_ret_free_local
goto|;
comment|/* Now examine each relocation.  */
name|irela
operator|=
name|internal_relocs
expr_stmt|;
name|irelaend
operator|=
name|irela
operator|+
name|section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|irela
operator|<
name|irelaend
condition|;
name|irela
operator|++
control|)
block|{
name|unsigned
name|int
name|r_type
decl_stmt|,
name|r_indx
decl_stmt|;
name|enum
name|elf32_hppa_stub_type
name|stub_type
decl_stmt|;
name|struct
name|elf32_hppa_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|bfd_vma
name|sym_value
decl_stmt|;
name|bfd_vma
name|destination
decl_stmt|;
name|struct
name|elf32_hppa_link_hash_entry
modifier|*
name|hash
decl_stmt|;
name|char
modifier|*
name|stub_name
decl_stmt|;
specifier|const
name|asection
modifier|*
name|id_sec
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|irela
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_indx
operator|=
name|ELF32_R_SYM
argument_list|(
name|irela
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|R_PARISC_UNIMPLEMENTED
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|error_ret_free_internal
label|:
if|if
condition|(
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|relocs
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
goto|goto
name|error_ret_free_local
goto|;
block|}
comment|/* Only look for stubs on call instructions.  */
if|if
condition|(
name|r_type
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|R_PARISC_PCREL12F
operator|&&
name|r_type
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|R_PARISC_PCREL17F
operator|&&
name|r_type
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|R_PARISC_PCREL22F
condition|)
continue|continue;
comment|/* Now determine the call target, its name, value, 		     section.  */
name|sym_sec
operator|=
name|NULL
expr_stmt|;
name|sym_value
operator|=
literal|0
expr_stmt|;
name|destination
operator|=
literal|0
expr_stmt|;
name|hash
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_indx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* It's a local symbol.  */
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|sym
operator|=
name|local_syms
operator|+
name|r_indx
expr_stmt|;
name|hdr
operator|=
name|elf_elfsections
argument_list|(
name|input_bfd
argument_list|)
index|[
name|sym
operator|->
name|st_shndx
index|]
expr_stmt|;
name|sym_sec
operator|=
name|hdr
operator|->
name|bfd_section
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_SECTION
condition|)
name|sym_value
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
name|destination
operator|=
operator|(
name|sym_value
operator|+
name|irela
operator|->
name|r_addend
operator|+
name|sym_sec
operator|->
name|output_offset
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It's an external symbol.  */
name|int
name|e_indx
decl_stmt|;
name|e_indx
operator|=
name|r_indx
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|hash
operator|=
operator|(
operator|(
expr|struct
name|elf32_hppa_link_hash_entry
operator|*
operator|)
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|e_indx
index|]
operator|)
expr_stmt|;
while|while
condition|(
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|hash
operator|=
operator|(
operator|(
expr|struct
name|elf32_hppa_link_hash_entry
operator|*
operator|)
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
operator|)
expr_stmt|;
if|if
condition|(
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sym_sec
operator|=
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|sym_value
operator|=
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|sym_sec
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|destination
operator|=
operator|(
name|sym_value
operator|+
name|irela
operator|->
name|r_addend
operator|+
name|sym_sec
operator|->
name|output_offset
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|hash
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|info
operator|->
name|unresolved_syms_in_objects
operator|==
name|RM_IGNORE
operator|&&
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|hash
operator|->
name|elf
operator|.
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|)
operator|&&
name|hash
operator|->
name|elf
operator|.
name|type
operator|!=
name|STT_PARISC_MILLI
operator|)
condition|)
continue|continue;
block|}
else|else
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_ret_free_internal
goto|;
block|}
block|}
comment|/* Determine what (if any) linker stub is needed.  */
name|stub_type
operator|=
name|hppa_type_of_stub
argument_list|(
name|section
argument_list|,
name|irela
argument_list|,
name|hash
argument_list|,
name|destination
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_type
operator|==
name|hppa_stub_none
condition|)
continue|continue;
comment|/* Support for grouping stub sections.  */
name|id_sec
operator|=
name|htab
operator|->
name|stub_group
index|[
name|section
operator|->
name|id
index|]
operator|.
name|link_sec
expr_stmt|;
comment|/* Get the name of this stub.  */
name|stub_name
operator|=
name|hppa_stub_name
argument_list|(
name|id_sec
argument_list|,
name|sym_sec
argument_list|,
name|hash
argument_list|,
name|irela
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stub_name
condition|)
goto|goto
name|error_ret_free_internal
goto|;
name|stub_entry
operator|=
name|hppa_stub_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|stub_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|!=
name|NULL
condition|)
block|{
comment|/* The proper stub has already been created.  */
name|free
argument_list|(
name|stub_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|stub_entry
operator|=
name|hppa_add_stub
argument_list|(
name|stub_name
argument_list|,
name|section
argument_list|,
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|stub_name
argument_list|)
expr_stmt|;
goto|goto
name|error_ret_free_internal
goto|;
block|}
name|stub_entry
operator|->
name|target_value
operator|=
name|sym_value
expr_stmt|;
name|stub_entry
operator|->
name|target_section
operator|=
name|sym_sec
expr_stmt|;
name|stub_entry
operator|->
name|stub_type
operator|=
name|stub_type
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
name|stub_type
operator|==
name|hppa_stub_import
condition|)
name|stub_entry
operator|->
name|stub_type
operator|=
name|hppa_stub_import_shared
expr_stmt|;
elseif|else
if|if
condition|(
name|stub_type
operator|==
name|hppa_stub_long_branch
condition|)
name|stub_entry
operator|->
name|stub_type
operator|=
name|hppa_stub_long_branch_shared
expr_stmt|;
block|}
name|stub_entry
operator|->
name|h
operator|=
name|hash
expr_stmt|;
name|stub_changed
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* We're done with the internal relocs, free them.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|relocs
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|stub_changed
condition|)
break|break;
comment|/* OK, we've added some stubs.  Find out the new size of the 	 stub sections.  */
for|for
control|(
name|stub_sec
operator|=
name|htab
operator|->
name|stub_bfd
operator|->
name|sections
init|;
name|stub_sec
operator|!=
name|NULL
condition|;
name|stub_sec
operator|=
name|stub_sec
operator|->
name|next
control|)
block|{
name|stub_sec
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|stub_sec
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
block|}
name|bfd_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|hppa_size_one_stub
argument_list|,
name|htab
argument_list|)
expr_stmt|;
comment|/* Ask the linker to do its stuff.  */
call|(
modifier|*
name|htab
operator|->
name|layout_sections_again
call|)
argument_list|()
expr_stmt|;
name|stub_changed
operator|=
name|FALSE
expr_stmt|;
block|}
name|free
argument_list|(
name|htab
operator|->
name|all_local_syms
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_ret_free_local
label|:
name|free
argument_list|(
name|htab
operator|->
name|all_local_syms
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* For a final link, this function is called after we have sized the    stubs to provide a value for __gp.  */
end_comment

begin_function
name|bfd_boolean
name|elf32_hppa_set_gp
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|asection
modifier|*
name|sec
init|=
name|NULL
decl_stmt|;
name|bfd_vma
name|gp_val
init|=
literal|0
decl_stmt|;
name|struct
name|elf32_hppa_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|hppa_link_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|elf
operator|.
name|root
argument_list|,
literal|"$global$"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
name|gp_val
operator|=
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|sec
operator|=
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
block|}
else|else
block|{
name|asection
modifier|*
name|splt
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".plt"
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|sgot
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
decl_stmt|;
comment|/* Choose to point our LTP at, in this order, one of .plt, .got, 	 or .data, if these sections exist.  In the case of choosing 	 .plt try to make the LTP ideal for addressing anywhere in the 	 .plt or .got with a 14 bit signed offset.  Typically, the end 	 of the .plt is the start of the .got, so choose .plt + 0x2000 	 if either the .plt or .got is larger than 0x2000.  If both 	 the .plt and .got are smaller than 0x2000, choose the end of 	 the .plt section.  */
name|sec
operator|=
name|strcmp
argument_list|(
name|bfd_get_target
argument_list|(
name|abfd
argument_list|)
argument_list|,
literal|"elf32-hppa-netbsd"
argument_list|)
operator|==
literal|0
condition|?
name|NULL
else|:
name|splt
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
block|{
name|gp_val
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|gp_val
operator|>
literal|0x2000
operator|||
operator|(
name|sgot
operator|&&
name|sgot
operator|->
name|_raw_size
operator|>
literal|0x2000
operator|)
condition|)
block|{
name|gp_val
operator|=
literal|0x2000
expr_stmt|;
block|}
block|}
else|else
block|{
name|sec
operator|=
name|sgot
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_target
argument_list|(
name|abfd
argument_list|)
argument_list|,
literal|"elf32-hppa-netbsd"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* We know we don't have a .plt.  If .got is large, 		     offset our LTP.  */
if|if
condition|(
name|sec
operator|->
name|_raw_size
operator|>
literal|0x2000
condition|)
name|gp_val
operator|=
literal|0x2000
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* No .plt or .got.  Who cares what the LTP is?  */
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".data"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|h
operator|->
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|gp_val
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|sec
expr_stmt|;
else|else
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|sec
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|gp_val
operator|+=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
expr_stmt|;
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|=
name|gp_val
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Build all the stubs associated with the current output file.  The    stubs are kept in a hash table attached to the main linker hash    table.  We also set up the .plt entries for statically linked PIC    functions here.  This function is called via hppaelf_finish in the    linker.  */
end_comment

begin_function
name|bfd_boolean
name|elf32_hppa_build_stubs
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|asection
modifier|*
name|stub_sec
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
name|struct
name|elf32_hppa_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|hppa_link_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
for|for
control|(
name|stub_sec
operator|=
name|htab
operator|->
name|stub_bfd
operator|->
name|sections
init|;
name|stub_sec
operator|!=
name|NULL
condition|;
name|stub_sec
operator|=
name|stub_sec
operator|->
name|next
control|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
comment|/* Allocate memory to hold the linker stubs.  */
name|size
operator|=
name|stub_sec
operator|->
name|_raw_size
expr_stmt|;
name|stub_sec
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_sec
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|size
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|stub_sec
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Build the stubs as directed by the stub hash table.  */
name|table
operator|=
operator|&
name|htab
operator|->
name|stub_hash_table
expr_stmt|;
name|bfd_hash_traverse
argument_list|(
name|table
argument_list|,
name|hppa_build_one_stub
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Perform a final link.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_hppa_final_link
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
comment|/* Invoke the regular ELF linker to do all the work.  */
if|if
condition|(
operator|!
name|bfd_elf_final_link
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If we're producing a final executable, sort the contents of the      unwind section.  */
return|return
name|elf_hppa_sort_unwind
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Record the lowest address for the data and text segments.  */
end_comment

begin_function
specifier|static
name|void
name|hppa_record_segment_addr
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|elf32_hppa_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
operator|(
expr|struct
name|elf32_hppa_link_hash_table
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
operator|)
operator|==
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
condition|)
block|{
name|bfd_vma
name|value
init|=
name|section
operator|->
name|vma
operator|-
name|section
operator|->
name|filepos
decl_stmt|;
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|<
name|htab
operator|->
name|text_segment_base
condition|)
name|htab
operator|->
name|text_segment_base
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|value
operator|<
name|htab
operator|->
name|data_segment_base
condition|)
name|htab
operator|->
name|data_segment_base
operator|=
name|value
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Perform a relocation as part of a final link.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|final_link_relocate
parameter_list|(
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|bfd_vma
name|value
parameter_list|,
name|struct
name|elf32_hppa_link_hash_table
modifier|*
name|htab
parameter_list|,
name|asection
modifier|*
name|sym_sec
parameter_list|,
name|struct
name|elf32_hppa_link_hash_entry
modifier|*
name|h
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|int
name|insn
decl_stmt|;
name|unsigned
name|int
name|r_type
init|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|orig_r_type
init|=
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
init|=
name|elf_hppa_howto_table
operator|+
name|r_type
decl_stmt|;
name|int
name|r_format
init|=
name|howto
operator|->
name|bitsize
decl_stmt|;
name|enum
name|hppa_reloc_field_selector_type_alt
name|r_field
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
init|=
name|input_section
operator|->
name|owner
decl_stmt|;
name|bfd_vma
name|offset
init|=
name|rel
operator|->
name|r_offset
decl_stmt|;
name|bfd_vma
name|max_branch_offset
init|=
literal|0
decl_stmt|;
name|bfd_byte
modifier|*
name|hit_data
init|=
name|contents
operator|+
name|offset
decl_stmt|;
name|bfd_signed_vma
name|addend
init|=
name|rel
operator|->
name|r_addend
decl_stmt|;
name|bfd_vma
name|location
decl_stmt|;
name|struct
name|elf32_hppa_stub_hash_entry
modifier|*
name|stub_entry
init|=
name|NULL
decl_stmt|;
name|int
name|val
decl_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_PARISC_NONE
condition|)
return|return
name|bfd_reloc_ok
return|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
comment|/* Find out where we are and where we're going.  */
name|location
operator|=
operator|(
name|offset
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* If we are not building a shared library, convert DLTIND relocs to      DPREL relocs.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PARISC_DLTIND21L
case|:
name|r_type
operator|=
name|R_PARISC_DPREL21L
expr_stmt|;
break|break;
case|case
name|R_PARISC_DLTIND14R
case|:
name|r_type
operator|=
name|R_PARISC_DPREL14R
expr_stmt|;
break|break;
case|case
name|R_PARISC_DLTIND14F
case|:
name|r_type
operator|=
name|R_PARISC_DPREL14F
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PARISC_PCREL12F
case|:
case|case
name|R_PARISC_PCREL17F
case|:
case|case
name|R_PARISC_PCREL22F
case|:
comment|/* If this call should go via the plt, find the import stub in 	 the stub hash.  */
if|if
condition|(
name|sym_sec
operator|==
name|NULL
operator|||
name|sym_sec
operator|->
name|output_section
operator|==
name|NULL
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|elf
operator|.
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
name|h
operator|->
name|elf
operator|.
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|plabel
operator|&&
operator|(
name|info
operator|->
name|shared
operator|||
operator|!
operator|(
name|h
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|||
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|)
condition|)
block|{
name|stub_entry
operator|=
name|hppa_get_stub_entry
argument_list|(
name|input_section
argument_list|,
name|sym_sec
argument_list|,
name|h
argument_list|,
name|rel
argument_list|,
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|!=
name|NULL
condition|)
block|{
name|value
operator|=
operator|(
name|stub_entry
operator|->
name|stub_offset
operator|+
name|stub_entry
operator|->
name|stub_sec
operator|->
name|output_offset
operator|+
name|stub_entry
operator|->
name|stub_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym_sec
operator|==
name|NULL
operator|&&
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
comment|/* It's OK if undefined weak.  Calls to undefined weak 		 symbols behave as if the "called" function 		 immediately returns.  We can thus call to a weak 		 function without first checking whether the function 		 is defined.  */
name|value
operator|=
name|location
expr_stmt|;
name|addend
operator|=
literal|8
expr_stmt|;
block|}
else|else
return|return
name|bfd_reloc_undefined
return|;
block|}
comment|/* Fall thru.  */
case|case
name|R_PARISC_PCREL21L
case|:
case|case
name|R_PARISC_PCREL17C
case|:
case|case
name|R_PARISC_PCREL17R
case|:
case|case
name|R_PARISC_PCREL14R
case|:
case|case
name|R_PARISC_PCREL14F
case|:
case|case
name|R_PARISC_PCREL32
case|:
comment|/* Make it a pc relative offset.  */
name|value
operator|-=
name|location
expr_stmt|;
name|addend
operator|-=
literal|8
expr_stmt|;
break|break;
case|case
name|R_PARISC_DPREL21L
case|:
case|case
name|R_PARISC_DPREL14R
case|:
case|case
name|R_PARISC_DPREL14F
case|:
comment|/* Convert instructions that use the linkage table pointer (r19) to 	 instructions that use the global data pointer (dp).  This is the 	 most efficient way of using PIC code in an incomplete executable, 	 but the user must follow the standard runtime conventions for 	 accessing data for this to work.  */
if|if
condition|(
name|orig_r_type
operator|==
name|R_PARISC_DLTIND21L
condition|)
block|{
comment|/* Convert addil instructions if the original reloc was a 	     DLTIND21L.  GCC sometimes uses a register other than r19 for 	     the operation, so we must convert any addil instruction 	     that uses this relocation.  */
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xfc000000
operator|)
operator|==
operator|(
operator|(
name|int
operator|)
name|OP_ADDIL
operator|<<
literal|26
operator|)
condition|)
name|insn
operator|=
name|ADDIL_DP
expr_stmt|;
else|else
comment|/* We must have a ldil instruction.  It's too hard to find 	       and convert the associated add instruction, so issue an 	       error.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s(%s+0x%lx): %s fixup for insn 0x%x is not supported in a non-shared link"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|input_section
operator|->
name|name
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|orig_r_type
operator|==
name|R_PARISC_DLTIND14F
condition|)
block|{
comment|/* This must be a format 1 load/store.  Change the base 	     register to dp.  */
name|insn
operator|=
operator|(
name|insn
operator|&
literal|0xfc1ffff
operator|)
operator||
operator|(
literal|27
operator|<<
literal|21
operator|)
expr_stmt|;
block|}
comment|/* For all the DP relative relocations, we need to examine the symbol's        section.  If it has no section or if it's a code section, then        "data pointer relative" makes no sense.  In that case we don't        adjust the "value", and for 21 bit addil instructions, we change the        source addend register from %dp to %r0.  This situation commonly        arises for undefined weak symbols and when a variable's "constness"        is declared differently from the way the variable is defined.  For        instance: "extern int foo" with foo defined as "const int foo".  */
if|if
condition|(
name|sym_sec
operator|==
name|NULL
operator|||
operator|(
name|sym_sec
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
operator|(
literal|0x3f
operator|<<
literal|26
operator|)
operator||
operator|(
literal|0x1f
operator|<<
literal|21
operator|)
operator|)
operator|)
operator|==
operator|(
operator|(
operator|(
name|int
operator|)
name|OP_ADDIL
operator|<<
literal|26
operator|)
operator||
operator|(
literal|27
operator|<<
literal|21
operator|)
operator|)
condition|)
block|{
name|insn
operator|&=
operator|~
operator|(
literal|0x1f
operator|<<
literal|21
operator|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* debug them.  */
block|(*_bfd_error_handler) 		(_("%s(%s+0x%lx): fixing %s"), 		 bfd_archive_filename (input_bfd), 		 input_section->name, 		 (long) rel->r_offset, 		 howto->name);
endif|#
directive|endif
block|}
comment|/* Now try to make things easy for the dynamic linker.  */
break|break;
block|}
comment|/* Fall thru.  */
case|case
name|R_PARISC_DLTIND21L
case|:
case|case
name|R_PARISC_DLTIND14R
case|:
case|case
name|R_PARISC_DLTIND14F
case|:
name|value
operator|-=
name|elf_gp
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|owner
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_PARISC_SEGREL32
case|:
if|if
condition|(
operator|(
name|sym_sec
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
name|value
operator|-=
name|htab
operator|->
name|text_segment_base
expr_stmt|;
else|else
name|value
operator|-=
name|htab
operator|->
name|data_segment_base
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PARISC_DIR32
case|:
case|case
name|R_PARISC_DIR14F
case|:
case|case
name|R_PARISC_DIR17F
case|:
case|case
name|R_PARISC_PCREL17C
case|:
case|case
name|R_PARISC_PCREL14F
case|:
case|case
name|R_PARISC_PCREL32
case|:
case|case
name|R_PARISC_DPREL14F
case|:
case|case
name|R_PARISC_PLABEL32
case|:
case|case
name|R_PARISC_DLTIND14F
case|:
case|case
name|R_PARISC_SEGBASE
case|:
case|case
name|R_PARISC_SEGREL32
case|:
name|r_field
operator|=
name|e_fsel
expr_stmt|;
break|break;
case|case
name|R_PARISC_DLTIND21L
case|:
case|case
name|R_PARISC_PCREL21L
case|:
case|case
name|R_PARISC_PLABEL21L
case|:
name|r_field
operator|=
name|e_lsel
expr_stmt|;
break|break;
case|case
name|R_PARISC_DIR21L
case|:
case|case
name|R_PARISC_DPREL21L
case|:
name|r_field
operator|=
name|e_lrsel
expr_stmt|;
break|break;
case|case
name|R_PARISC_PCREL17R
case|:
case|case
name|R_PARISC_PCREL14R
case|:
case|case
name|R_PARISC_PLABEL14R
case|:
case|case
name|R_PARISC_DLTIND14R
case|:
name|r_field
operator|=
name|e_rsel
expr_stmt|;
break|break;
case|case
name|R_PARISC_DIR17R
case|:
case|case
name|R_PARISC_DIR14R
case|:
case|case
name|R_PARISC_DPREL14R
case|:
name|r_field
operator|=
name|e_rrsel
expr_stmt|;
break|break;
case|case
name|R_PARISC_PCREL12F
case|:
case|case
name|R_PARISC_PCREL17F
case|:
case|case
name|R_PARISC_PCREL22F
case|:
name|r_field
operator|=
name|e_fsel
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
operator|(
name|unsigned
name|int
operator|)
name|R_PARISC_PCREL17F
condition|)
block|{
name|max_branch_offset
operator|=
operator|(
literal|1
operator|<<
operator|(
literal|17
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
operator|(
name|unsigned
name|int
operator|)
name|R_PARISC_PCREL12F
condition|)
block|{
name|max_branch_offset
operator|=
operator|(
literal|1
operator|<<
operator|(
literal|12
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|2
expr_stmt|;
block|}
else|else
block|{
name|max_branch_offset
operator|=
operator|(
literal|1
operator|<<
operator|(
literal|22
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|2
expr_stmt|;
block|}
comment|/* sym_sec is NULL on undefined weak syms or when shared on 	 undefined syms.  We've already checked for a stub for the 	 shared undefined case.  */
if|if
condition|(
name|sym_sec
operator|==
name|NULL
condition|)
break|break;
comment|/* If the branch is out of reach, then redirect the 	 call to the local stub for this function.  */
if|if
condition|(
name|value
operator|+
name|addend
operator|+
name|max_branch_offset
operator|>=
literal|2
operator|*
name|max_branch_offset
condition|)
block|{
name|stub_entry
operator|=
name|hppa_get_stub_entry
argument_list|(
name|input_section
argument_list|,
name|sym_sec
argument_list|,
name|h
argument_list|,
name|rel
argument_list|,
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|==
name|NULL
condition|)
return|return
name|bfd_reloc_undefined
return|;
comment|/* Munge up the value and addend so that we call the stub 	     rather than the procedure directly.  */
name|value
operator|=
operator|(
name|stub_entry
operator|->
name|stub_offset
operator|+
name|stub_entry
operator|->
name|stub_sec
operator|->
name|output_offset
operator|+
name|stub_entry
operator|->
name|stub_sec
operator|->
name|output_section
operator|->
name|vma
operator|-
name|location
operator|)
expr_stmt|;
name|addend
operator|=
operator|-
literal|8
expr_stmt|;
block|}
break|break;
comment|/* Something we don't know how to handle.  */
default|default:
return|return
name|bfd_reloc_notsupported
return|;
block|}
comment|/* Make sure we can reach the stub.  */
if|if
condition|(
name|max_branch_offset
operator|!=
literal|0
operator|&&
name|value
operator|+
name|addend
operator|+
name|max_branch_offset
operator|>=
literal|2
operator|*
name|max_branch_offset
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s(%s+0x%lx): cannot reach %s, recompile with -ffunction-sections"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|input_section
operator|->
name|name
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|stub_entry
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_notsupported
return|;
block|}
name|val
operator|=
name|hppa_field_adjust
argument_list|(
name|value
argument_list|,
name|addend
argument_list|,
name|r_field
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PARISC_PCREL12F
case|:
case|case
name|R_PARISC_PCREL17C
case|:
case|case
name|R_PARISC_PCREL17F
case|:
case|case
name|R_PARISC_PCREL17R
case|:
case|case
name|R_PARISC_PCREL22F
case|:
case|case
name|R_PARISC_DIR17F
case|:
case|case
name|R_PARISC_DIR17R
case|:
comment|/* This is a branch.  Divide the offset by four. 	 Note that we need to decide whether it's a branch or 	 otherwise by inspecting the reloc.  Inspecting insn won't 	 work as insn might be from a .word directive.  */
name|val
operator|>>=
literal|2
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|insn
operator|=
name|hppa_rebuild_insn
argument_list|(
name|insn
argument_list|,
name|val
argument_list|,
name|r_format
argument_list|)
expr_stmt|;
comment|/* Update the instruction word.  */
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Relocate an HPPA ELF section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_hppa_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
name|struct
name|elf32_hppa_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|htab
operator|=
name|hppa_link_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|int
name|r_symndx
decl_stmt|;
name|struct
name|elf32_hppa_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
name|bfd_boolean
name|plabel
decl_stmt|;
name|bfd_boolean
name|warned_undef
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|R_PARISC_UNIMPLEMENTED
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|r_type
operator|==
operator|(
name|unsigned
name|int
operator|)
name|R_PARISC_GNU_VTENTRY
operator|||
name|r_type
operator|==
operator|(
name|unsigned
name|int
operator|)
name|R_PARISC_GNU_VTINHERIT
condition|)
continue|continue;
comment|/* This is a final link.  */
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sym_sec
operator|=
name|NULL
expr_stmt|;
name|warned_undef
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* This is a local symbol, h defaults to NULL.  */
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sym_sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sym_sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|hh
decl_stmt|;
name|bfd_boolean
name|unresolved_reloc
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
init|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
decl_stmt|;
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|hh
argument_list|,
name|sym_sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned_undef
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocation
operator|==
literal|0
operator|&&
name|hh
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|hh
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|&&
name|hh
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|unresolved_syms_in_objects
operator|==
name|RM_IGNORE
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|hh
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|&&
name|hh
operator|->
name|type
operator|==
name|STT_PARISC_MILLI
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
argument_list|(
name|info
argument_list|,
name|hh
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|warned_undef
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|h
operator|=
operator|(
expr|struct
name|elf32_hppa_link_hash_entry
operator|*
operator|)
name|hh
expr_stmt|;
block|}
comment|/* Do any required modifications to the relocation value, and 	 determine what types of dynamic info we need to output, if 	 any.  */
name|plabel
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PARISC_DLTIND14F
case|:
case|case
name|R_PARISC_DLTIND14R
case|:
case|case
name|R_PARISC_DLTIND21L
case|:
block|{
name|bfd_vma
name|off
decl_stmt|;
name|bfd_boolean
name|do_got
init|=
literal|0
decl_stmt|;
comment|/* Relocation is to the entry for this symbol in the 	       global offset table.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|bfd_boolean
name|dyn
decl_stmt|;
name|off
operator|=
name|h
operator|->
name|elf
operator|.
name|got
operator|.
name|offset
expr_stmt|;
name|dyn
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
expr_stmt|;
if|if
condition|(
operator|!
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
operator|->
name|shared
argument_list|,
operator|&
name|h
operator|->
name|elf
argument_list|)
condition|)
block|{
comment|/* If we aren't going to call finish_dynamic_symbol, 		       then we need to handle initialisation of the .got 		       entry and create needed relocs here.  Since the 		       offset must always be a multiple of 4, we use the 		       least significant bit to record whether we have 		       initialised it already.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|h
operator|->
name|elf
operator|.
name|got
operator|.
name|offset
operator||=
literal|1
expr_stmt|;
name|do_got
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Local symbol case.  */
if|if
condition|(
name|local_got_offsets
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|off
operator|=
name|local_got_offsets
index|[
name|r_symndx
index|]
expr_stmt|;
comment|/* The offset must always be a multiple of 4.  We use 		   the least significant bit to record whether we have 		   already generated the necessary reloc.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|local_got_offsets
index|[
name|r_symndx
index|]
operator||=
literal|1
expr_stmt|;
name|do_got
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|do_got
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* Output a dynamic relocation for this GOT entry. 		       In this case it is relative to the base of the 		       object because the symbol index is zero.  */
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|asection
modifier|*
name|s
init|=
name|htab
operator|->
name|srelgot
decl_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|off
operator|+
name|htab
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_PARISC_DIR32
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
expr_stmt|;
name|loc
operator|=
name|s
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|s
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
else|else
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|off
operator|>=
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Add the base of the GOT to the relocation value.  */
name|relocation
operator|=
operator|(
name|off
operator|+
name|htab
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|R_PARISC_SEGREL32
case|:
comment|/* If this is the first SEGREL relocation, then initialize 	     the segment base values.  */
if|if
condition|(
name|htab
operator|->
name|text_segment_base
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|bfd_map_over_sections
argument_list|(
name|output_bfd
argument_list|,
name|hppa_record_segment_addr
argument_list|,
name|htab
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_PARISC_PLABEL14R
case|:
case|case
name|R_PARISC_PLABEL21L
case|:
case|case
name|R_PARISC_PLABEL32
case|:
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
name|bfd_vma
name|off
decl_stmt|;
name|bfd_boolean
name|do_plt
init|=
literal|0
decl_stmt|;
comment|/* If we have a global symbol with a PLT slot, then 		 redirect this relocation to it.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|off
operator|=
name|h
operator|->
name|elf
operator|.
name|plt
operator|.
name|offset
expr_stmt|;
if|if
condition|(
operator|!
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
literal|1
argument_list|,
name|info
operator|->
name|shared
argument_list|,
operator|&
name|h
operator|->
name|elf
argument_list|)
condition|)
block|{
comment|/* In a non-shared link, adjust_dynamic_symbols 			 isn't called for symbols forced local.  We 			 need to write out the plt entry here.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|h
operator|->
name|elf
operator|.
name|plt
operator|.
name|offset
operator||=
literal|1
expr_stmt|;
name|do_plt
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|bfd_vma
modifier|*
name|local_plt_offsets
decl_stmt|;
if|if
condition|(
name|local_got_offsets
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|local_plt_offsets
operator|=
name|local_got_offsets
operator|+
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|off
operator|=
name|local_plt_offsets
index|[
name|r_symndx
index|]
expr_stmt|;
comment|/* As for the local .got entry case, we use the last 		     bit to record whether we've already initialised 		     this local .plt entry.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|local_plt_offsets
index|[
name|r_symndx
index|]
operator||=
literal|1
expr_stmt|;
name|do_plt
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|do_plt
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* Output a dynamic IPLT relocation for this 			 PLT entry.  */
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|asection
modifier|*
name|s
init|=
name|htab
operator|->
name|srelplt
decl_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|off
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_PARISC_IPLT
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
expr_stmt|;
name|loc
operator|=
name|s
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|s
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|elf_gp
argument_list|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|owner
argument_list|)
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|off
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|off
operator|>=
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* PLABELs contain function pointers.  Relocation is to 		 the entry for the function in the .plt.  The magic +2 		 offset signals to $$dyncall that the function pointer 		 is in the .plt and thus has a gp pointer too. 		 Exception:  Undefined PLABELs should have a value of 		 zero.  */
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
operator|(
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|&&
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefined
operator|)
condition|)
block|{
name|relocation
operator|=
operator|(
name|off
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
literal|2
operator|)
expr_stmt|;
block|}
name|plabel
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Fall through and possibly emit a dynamic relocation.  */
case|case
name|R_PARISC_DIR17F
case|:
case|case
name|R_PARISC_DIR17R
case|:
case|case
name|R_PARISC_DIR14F
case|:
case|case
name|R_PARISC_DIR14R
case|:
case|case
name|R_PARISC_DIR21L
case|:
case|case
name|R_PARISC_DPREL14F
case|:
case|case
name|R_PARISC_DPREL14R
case|:
case|case
name|R_PARISC_DPREL21L
case|:
case|case
name|R_PARISC_DIR32
case|:
comment|/* r_symndx will be zero only for relocs against symbols 	     from removed linkonce sections, or sections discarded by 	     a linker script.  */
if|if
condition|(
name|r_symndx
operator|==
literal|0
operator|||
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* The reloc types handled here and this conditional 	     expression must match the code in ..check_relocs and 	     allocate_dynrelocs.  ie. We need exactly the same condition 	     as in ..check_relocs, with some extra conditions (dynindx 	     test in this case) to cater for relocs removed by 	     allocate_dynrelocs.  If you squint, the non-shared test 	     here does indeed match the one in ..check_relocs, the 	     difference being that here we test DEF_DYNAMIC as well as 	     !DEF_REGULAR.  All common syms end up with !DEF_REGULAR, 	     which is why we can't use just that test here. 	     Conversely, DEF_DYNAMIC can't be used in check_relocs as 	     there all files have not been loaded.  */
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|elf
operator|.
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
operator|&&
operator|(
name|IS_ABSOLUTE_RELOC
argument_list|(
name|r_type
argument_list|)
operator|||
operator|!
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
operator|&
name|h
operator|->
name|elf
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|elf
operator|.
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_GOT_REF
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|ELIMINATE_COPY_RELOCS
operator|&&
operator|(
name|h
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|||
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|)
operator|)
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_boolean
name|skip
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
comment|/* When generating a shared object, these relocations 		 are copied into the output file to be resolved at run 		 time.  */
name|outrel
operator|.
name|r_addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|skip
operator|=
operator|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|||
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
block|{
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|outrel
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|elf
operator|.
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|plabel
operator|||
operator|!
name|IS_ABSOLUTE_RELOC
argument_list|(
name|r_type
argument_list|)
operator|||
operator|!
name|info
operator|->
name|shared
operator|||
operator|!
name|info
operator|->
name|symbolic
operator|||
operator|(
name|h
operator|->
name|elf
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|elf
operator|.
name|dynindx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* It's a local symbol, or one marked to become local.  */
block|{
name|int
name|indx
init|=
literal|0
decl_stmt|;
comment|/* Add the absolute offset of the symbol.  */
name|outrel
operator|.
name|r_addend
operator|+=
name|relocation
expr_stmt|;
comment|/* Global plabels need to be processed by the 		     dynamic linker so that functions have at most one 		     fptr.  For this reason, we need to differentiate 		     between global and local plabels, which we do by 		     providing the function symbol for a global plabel 		     reloc, and no symbol for local plabels.  */
if|if
condition|(
operator|!
name|plabel
operator|&&
name|sym_sec
operator|!=
name|NULL
operator|&&
name|sym_sec
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|sym_sec
argument_list|)
condition|)
block|{
comment|/* Skip this relocation if the output section has 			 been discarded.  */
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sym_sec
operator|->
name|output_section
argument_list|)
condition|)
break|break;
name|indx
operator|=
name|elf_section_data
argument_list|(
name|sym_sec
operator|->
name|output_section
argument_list|)
operator|->
name|dynindx
expr_stmt|;
comment|/* We are turning this relocation into one 			 against a section symbol, so subtract out the 			 output section's address but not the offset 			 of the input section in the output section.  */
name|outrel
operator|.
name|r_addend
operator|-=
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
block|}
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* EH info can cause unaligned DIR32 relocs. 		 Tweak the reloc type for the dynamic linker.  */
block|if (r_type == R_PARISC_DIR32&& (outrel.r_offset& 3) != 0) 		outrel.r_info = ELF32_R_INFO (ELF32_R_SYM (outrel.r_info), 					      R_PARISC_DIR32U);
endif|#
directive|endif
name|sreloc
operator|=
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|sreloc
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|loc
operator|=
name|sreloc
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|sreloc
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
name|r
operator|=
name|final_link_relocate
argument_list|(
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
argument_list|,
name|relocation
argument_list|,
name|htab
argument_list|,
name|sym_sec
argument_list|,
name|h
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|bfd_reloc_ok
condition|)
continue|continue;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|sym_name
operator|=
name|h
operator|->
name|elf
operator|.
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|sym_name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|*
name|sym_name
operator|==
literal|'\0'
condition|)
name|sym_name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sym_sec
argument_list|)
expr_stmt|;
block|}
name|howto
operator|=
name|elf_hppa_howto_table
operator|+
name|r_type
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|bfd_reloc_undefined
operator|||
name|r
operator|==
name|bfd_reloc_notsupported
condition|)
block|{
if|if
condition|(
name|r
operator|==
name|bfd_reloc_notsupported
operator|||
operator|!
name|warned_undef
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s(%s+0x%lx): cannot handle %s for %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|input_section
operator|->
name|name
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|sym_name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_hppa_finish_dynamic_symbol
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
name|struct
name|elf32_hppa_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Rela
name|rel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|htab
operator|=
name|hppa_link_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|bfd_vma
name|value
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|&
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* This symbol has an entry in the procedure linkage table.  Set 	 it up.  	 The format of a plt entry is<funcaddr><__gp>       */
name|value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|value
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|value
operator|+=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
block|}
comment|/* Create a dynamic IPLT relocation for this entry.  */
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
block|{
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_PARISC_IPLT
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* This symbol has been marked to become local, and is 	     used by a plabel so must be kept in the .plt.  */
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_PARISC_IPLT
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
name|value
expr_stmt|;
block|}
name|loc
operator|=
name|htab
operator|->
name|srelplt
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|htab
operator|->
name|srelplt
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|owner
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Mark the symbol as undefined, rather than as defined in 	     the .plt section.  Leave the value alone.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
block|}
block|}
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* This symbol has an entry in the global offset table.  Set it 	 up.  */
name|rel
operator|.
name|r_offset
operator|=
operator|(
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
operator|)
operator|+
name|htab
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* If this is a -Bsymbolic link and the symbol is defined 	 locally or was forced to be local because of a version file, 	 we just want to emit a RELATIVE reloc.  The entry in the 	 global offset table will already have been initialized in the 	 relocate_section function.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
condition|)
block|{
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_PARISC_DIR32
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|h
operator|->
name|got
operator|.
name|offset
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_PARISC_DIR32
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
name|loc
operator|=
name|htab
operator|->
name|srelgot
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|htab
operator|->
name|srelgot
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_COPY
operator|)
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* This symbol needs a copy reloc.  Set it up.  */
if|if
condition|(
operator|!
operator|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|s
operator|=
name|htab
operator|->
name|srelbss
expr_stmt|;
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_PARISC_COPY
argument_list|)
expr_stmt|;
name|loc
operator|=
name|s
operator|->
name|contents
operator|+
name|s
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
comment|/* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
operator|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Used to decide how to sort relocs in an optimal manner for the    dynamic linker, before writing them out.  */
end_comment

begin_function
specifier|static
name|enum
name|elf_reloc_type_class
name|elf32_hppa_reloc_type_class
parameter_list|(
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rela
parameter_list|)
block|{
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
operator|==
literal|0
condition|)
return|return
name|reloc_class_relative
return|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|ELF32_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_PARISC_IPLT
case|:
return|return
name|reloc_class_plt
return|;
case|case
name|R_PARISC_COPY
case|:
return|return
name|reloc_class_copy
return|;
default|default:
return|return
name|reloc_class_normal
return|;
block|}
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_hppa_finish_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|elf32_hppa_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|htab
operator|=
name|hppa_link_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
name|Elf32_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
if|if
condition|(
name|sdyn
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|_raw_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_elf32_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
default|default:
continue|continue;
case|case
name|DT_PLTGOT
case|:
comment|/* Use PLTGOT to set the GOT register.  */
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|elf_gp
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_JMPREL
case|:
name|s
operator|=
name|htab
operator|->
name|srelplt
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|s
operator|=
name|htab
operator|->
name|srelplt
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
break|break;
case|case
name|DT_RELASZ
case|:
comment|/* Don't count procedure linkage table relocs in the 		 overall reloc count.  */
name|s
operator|=
name|htab
operator|->
name|srelplt
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
continue|continue;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|-=
name|s
operator|->
name|_raw_size
expr_stmt|;
break|break;
case|case
name|DT_RELA
case|:
comment|/* We may not be using the standard ELF linker script. 		 If .rela.plt is the first .rela section, we adjust 		 DT_RELA to not include it.  */
name|s
operator|=
name|htab
operator|->
name|srelplt
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|!=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
condition|)
continue|continue;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|+=
name|s
operator|->
name|_raw_size
expr_stmt|;
break|break;
block|}
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|htab
operator|->
name|sgot
operator|!=
name|NULL
operator|&&
name|htab
operator|->
name|sgot
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
comment|/* Fill in the first entry in the global offset table. 	 We use it to point to our dynamic section, if we have one.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sdyn
condition|?
name|sdyn
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sdyn
operator|->
name|output_offset
else|:
literal|0
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
comment|/* The second entry is reserved for use by the dynamic linker.  */
name|memset
argument_list|(
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|GOT_ENTRY_SIZE
argument_list|,
literal|0
argument_list|,
name|GOT_ENTRY_SIZE
argument_list|)
expr_stmt|;
comment|/* Set .got entry size.  */
name|elf_section_data
argument_list|(
name|htab
operator|->
name|sgot
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
name|GOT_ENTRY_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|splt
operator|!=
name|NULL
operator|&&
name|htab
operator|->
name|splt
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
comment|/* Set plt entry size.  */
name|elf_section_data
argument_list|(
name|htab
operator|->
name|splt
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
name|PLT_ENTRY_SIZE
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|need_plt_stub
condition|)
block|{
comment|/* Set up the .plt stub.  */
name|memcpy
argument_list|(
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|htab
operator|->
name|splt
operator|->
name|_raw_size
operator|-
sizeof|sizeof
argument_list|(
name|plt_stub
argument_list|)
argument_list|,
name|plt_stub
argument_list|,
sizeof|sizeof
argument_list|(
name|plt_stub
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|splt
operator|->
name|_raw_size
operator|)
operator|!=
operator|(
name|htab
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|".got section not immediately after .plt section"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Tweak the OSABI field of the elf header.  */
end_comment

begin_function
specifier|static
name|void
name|elf32_hppa_post_process_headers
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_target
argument_list|(
name|abfd
argument_list|)
argument_list|,
literal|"elf32-hppa-linux"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|=
name|ELFOSABI_LINUX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_target
argument_list|(
name|abfd
argument_list|)
argument_list|,
literal|"elf32-hppa-netbsd"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|=
name|ELFOSABI_NETBSD
expr_stmt|;
block|}
else|else
block|{
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|=
name|ELFOSABI_HPUX
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called when writing out an object file to decide the type of a    symbol.  */
end_comment

begin_function
specifier|static
name|int
name|elf32_hppa_elf_get_symbol_type
parameter_list|(
name|Elf_Internal_Sym
modifier|*
name|elf_sym
parameter_list|,
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|elf_sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_PARISC_MILLI
condition|)
return|return
name|STT_PARISC_MILLI
return|;
else|else
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Misc BFD support code.  */
end_comment

begin_define
define|#
directive|define
name|bfd_elf32_bfd_is_local_label_name
value|elf_hppa_is_local_label_name
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|elf_hppa_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|elf_hppa_info_to_howto
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|elf_hppa_info_to_howto_rel
end_define

begin_comment
comment|/* Stuff for the BFD linker.  */
end_comment

begin_define
define|#
directive|define
name|bfd_elf32_bfd_final_link
value|elf32_hppa_final_link
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
value|elf32_hppa_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_free
value|elf32_hppa_link_hash_table_free
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
value|elf32_hppa_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_copy_indirect_symbol
value|elf32_hppa_copy_indirect_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|elf32_hppa_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
value|elf32_hppa_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_fake_sections
value|elf_hppa_fake_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|elf32_hppa_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_hide_symbol
value|elf32_hppa_hide_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
value|elf32_hppa_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
value|elf32_hppa_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
value|elf32_hppa_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|elf32_hppa_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|elf32_hppa_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|elf32_hppa_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
value|elf_hppa_final_write_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_post_process_headers
value|elf32_hppa_post_process_headers
end_define

begin_define
define|#
directive|define
name|elf_backend_get_symbol_type
value|elf32_hppa_elf_get_symbol_type
end_define

begin_define
define|#
directive|define
name|elf_backend_reloc_type_class
value|elf32_hppa_reloc_type_class
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_can_refcount
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_alignment
value|2
end_define

begin_define
define|#
directive|define
name|elf_backend_want_got_plt
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_readonly
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|8
end_define

begin_define
define|#
directive|define
name|elf_backend_rela_normal
value|1
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_hppa_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-hppa"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_hppa
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_PARISC
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1000
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

begin_undef
undef|#
directive|undef
name|TARGET_BIG_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_hppa_linux_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BIG_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-hppa-linux"
end_define

begin_define
define|#
directive|define
name|INCLUDED_TARGET_FILE
value|1
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

begin_undef
undef|#
directive|undef
name|TARGET_BIG_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_hppa_nbsd_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BIG_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-hppa-netbsd"
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

