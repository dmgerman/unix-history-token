begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* MIPS-specific support for ELF    Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,    2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.     Most of the information added by Ian Lance Taylor, Cygnus Support,<ian@cygnus.com>.    N32/64 ABI support added by Mark Mitchell, CodeSourcery, LLC.<mark@codesourcery.com>    Traditional MIPS targets support added by Koundinya.K, Dansk Data    Elektronik& Operations Research Group.<kk@ddeorg.soft.net>     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This file handles functionality common to the different MIPS ABI's.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elfxx-mips.h"
end_include

begin_include
include|#
directive|include
file|"elf/mips.h"
end_include

begin_include
include|#
directive|include
file|"elf-vxworks.h"
end_include

begin_comment
comment|/* Get the ECOFF swapping routines.  */
end_comment

begin_include
include|#
directive|include
file|"coff/sym.h"
end_include

begin_include
include|#
directive|include
file|"coff/symconst.h"
end_include

begin_include
include|#
directive|include
file|"coff/ecoff.h"
end_include

begin_include
include|#
directive|include
file|"coff/mips.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_comment
comment|/* This structure is used to hold information about one GOT entry.    There are three types of entry:        (1) absolute addresses 	    (abfd == NULL)       (2) SYMBOL + OFFSET addresses, where SYMBOL is local to an input bfd 	    (abfd != NULL, symndx>= 0)       (3) global and forced-local symbols 	    (abfd != NULL, symndx == -1)     Type (3) entries are treated differently for different types of GOT.    In the "master" GOT -- i.e.  the one that describes every GOT    reference needed in the link -- the mips_got_entry is keyed on both    the symbol and the input bfd that references it.  If it turns out    that we need multiple GOTs, we can then use this information to    create separate GOTs for each input bfd.     However, we want each of these separate GOTs to have at most one    entry for a given symbol, so their type (3) entries are keyed only    on the symbol.  The input bfd given by the "abfd" field is somewhat    arbitrary in this case.     This means that when there are multiple GOTs, each GOT has a unique    mips_got_entry for every symbol within it.  We can therefore use the    mips_got_entry fields (tls_type and gotidx) to track the symbol's    GOT index.     However, if it turns out that we need only a single GOT, we continue    to use the master GOT to describe it.  There may therefore be several    mips_got_entries for the same symbol, each with a different input bfd.    We want to make sure that each symbol gets a unique GOT entry, so when    there's a single GOT, we use the symbol's hash entry, not the    mips_got_entry fields, to track a symbol's GOT index.  */
end_comment

begin_struct
struct|struct
name|mips_got_entry
block|{
comment|/* The input bfd in which the symbol is defined.  */
name|bfd
modifier|*
name|abfd
decl_stmt|;
comment|/* The index of the symbol, as stored in the relocation r_info, if      we have a local symbol; -1 otherwise.  */
name|long
name|symndx
decl_stmt|;
union|union
block|{
comment|/* If abfd == NULL, an address that must be stored in the got.  */
name|bfd_vma
name|address
decl_stmt|;
comment|/* If abfd != NULL&& symndx != -1, the addend of the relocation        that should be added to the symbol value.  */
name|bfd_vma
name|addend
decl_stmt|;
comment|/* If abfd != NULL&& symndx == -1, the hash table entry        corresponding to a global symbol in the got (or, local, if        h->forced_local).  */
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|}
name|d
union|;
comment|/* The TLS types included in this GOT entry (specifically, GD and      IE).  The GD and IE flags can be added as we encounter new      relocations.  LDM can also be set; it will always be alone, not      combined with any GD or IE flags.  An LDM GOT entry will be      a local symbol entry with r_symndx == 0.  */
name|unsigned
name|char
name|tls_type
decl_stmt|;
comment|/* The offset from the beginning of the .got section to the entry      corresponding to this symbol+addend.  If it's a global symbol      whose offset is yet to be decided, it's going to be -1.  */
name|long
name|gotidx
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure is used to hold .got information when linking.  */
end_comment

begin_struct
struct|struct
name|mips_got_info
block|{
comment|/* The global symbol in the GOT with the lowest index in the dynamic      symbol table.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|global_gotsym
decl_stmt|;
comment|/* The number of global .got entries.  */
name|unsigned
name|int
name|global_gotno
decl_stmt|;
comment|/* The number of .got slots used for TLS.  */
name|unsigned
name|int
name|tls_gotno
decl_stmt|;
comment|/* The first unused TLS .got entry.  Used only during      mips_elf_initialize_tls_index.  */
name|unsigned
name|int
name|tls_assigned_gotno
decl_stmt|;
comment|/* The number of local .got entries.  */
name|unsigned
name|int
name|local_gotno
decl_stmt|;
comment|/* The number of local .got entries we have used.  */
name|unsigned
name|int
name|assigned_gotno
decl_stmt|;
comment|/* A hash table holding members of the got.  */
name|struct
name|htab
modifier|*
name|got_entries
decl_stmt|;
comment|/* A hash table mapping input bfds to other mips_got_info.  NULL      unless multi-got was necessary.  */
name|struct
name|htab
modifier|*
name|bfd2got
decl_stmt|;
comment|/* In multi-got links, a pointer to the next got (err, rather, most      of the time, it points to the previous got).  */
name|struct
name|mips_got_info
modifier|*
name|next
decl_stmt|;
comment|/* This is the GOT index of the TLS LDM entry for the GOT, MINUS_ONE      for none, or MINUS_TWO for not yet assigned.  This is needed      because a single-GOT link may have multiple hash table entries      for the LDM.  It does not get initialized in multi-GOT mode.  */
name|bfd_vma
name|tls_ldm_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Map an input bfd to a got in a multi-got link.  */
end_comment

begin_struct
struct|struct
name|mips_elf_bfd2got_hash
block|{
name|bfd
modifier|*
name|bfd
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Structure passed when traversing the bfd2got hash table, used to    create and merge bfd's gots.  */
end_comment

begin_struct
struct|struct
name|mips_elf_got_per_bfd_arg
block|{
comment|/* A hashtable that maps bfds to gots.  */
name|htab_t
name|bfd2got
decl_stmt|;
comment|/* The output bfd.  */
name|bfd
modifier|*
name|obfd
decl_stmt|;
comment|/* The link information.  */
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
comment|/* A pointer to the primary got, i.e., the one that's going to get      the implicit relocations from DT_MIPS_LOCAL_GOTNO and      DT_MIPS_GOTSYM.  */
name|struct
name|mips_got_info
modifier|*
name|primary
decl_stmt|;
comment|/* A non-primary got we're trying to merge with other input bfd's      gots.  */
name|struct
name|mips_got_info
modifier|*
name|current
decl_stmt|;
comment|/* The maximum number of got entries that can be addressed with a      16-bit offset.  */
name|unsigned
name|int
name|max_count
decl_stmt|;
comment|/* The number of local and global entries in the primary got.  */
name|unsigned
name|int
name|primary_count
decl_stmt|;
comment|/* The number of local and global entries in the current got.  */
name|unsigned
name|int
name|current_count
decl_stmt|;
comment|/* The total number of global entries which will live in the      primary got and be automatically relocated.  This includes      those not referenced by the primary GOT but included in      the "master" GOT.  */
name|unsigned
name|int
name|global_count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Another structure used to pass arguments for got entries traversal.  */
end_comment

begin_struct
struct|struct
name|mips_elf_set_global_got_offset_arg
block|{
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|int
name|value
decl_stmt|;
name|unsigned
name|int
name|needed_relocs
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A structure used to count TLS relocations or GOT entries, for GOT    entry or ELF symbol table traversal.  */
end_comment

begin_struct
struct|struct
name|mips_elf_count_tls_arg
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|unsigned
name|int
name|needed
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_mips_elf_section_data
block|{
name|struct
name|bfd_elf_section_data
name|elf
decl_stmt|;
union|union
block|{
name|struct
name|mips_got_info
modifier|*
name|got_info
decl_stmt|;
name|bfd_byte
modifier|*
name|tdata
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|mips_elf_section_data
parameter_list|(
name|sec
parameter_list|)
define|\
value|((struct _mips_elf_section_data *) elf_section_data (sec))
end_define

begin_comment
comment|/* This structure is passed to mips_elf_sort_hash_table_f when sorting    the dynamic symbols.  */
end_comment

begin_struct
struct|struct
name|mips_elf_hash_sort_data
block|{
comment|/* The symbol in the global GOT with the lowest dynamic symbol table      index.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|low
decl_stmt|;
comment|/* The least dynamic symbol table index corresponding to a non-TLS      symbol with a GOT entry.  */
name|long
name|min_got_dynindx
decl_stmt|;
comment|/* The greatest dynamic symbol table index corresponding to a symbol      with a GOT entry that is not referenced (e.g., a dynamic symbol      with dynamic relocations pointing to it from non-primary GOTs).  */
name|long
name|max_unref_got_dynindx
decl_stmt|;
comment|/* The greatest dynamic symbol table index not corresponding to a      symbol without a GOT entry.  */
name|long
name|max_non_got_dynindx
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The MIPS ELF linker needs additional information for each symbol in    the global hash table.  */
end_comment

begin_struct
struct|struct
name|mips_elf_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|root
decl_stmt|;
comment|/* External symbol information.  */
name|EXTR
name|esym
decl_stmt|;
comment|/* Number of R_MIPS_32, R_MIPS_REL32, or R_MIPS_64 relocs against      this symbol.  */
name|unsigned
name|int
name|possibly_dynamic_relocs
decl_stmt|;
comment|/* If the R_MIPS_32, R_MIPS_REL32, or R_MIPS_64 reloc is against      a readonly section.  */
name|bfd_boolean
name|readonly_reloc
decl_stmt|;
comment|/* We must not create a stub for a symbol that has relocations      related to taking the function's address, i.e. any but      R_MIPS_CALL*16 ones -- see "MIPS ABI Supplement, 3rd Edition",      p. 4-20.  */
name|bfd_boolean
name|no_fn_stub
decl_stmt|;
comment|/* If there is a stub that 32 bit functions should use to call this      16 bit function, this points to the section containing the stub.  */
name|asection
modifier|*
name|fn_stub
decl_stmt|;
comment|/* Whether we need the fn_stub; this is set if this symbol appears      in any relocs other than a 16 bit call.  */
name|bfd_boolean
name|need_fn_stub
decl_stmt|;
comment|/* If there is a stub that 16 bit functions should use to call this      32 bit function, this points to the section containing the stub.  */
name|asection
modifier|*
name|call_stub
decl_stmt|;
comment|/* This is like the call_stub field, but it is used if the function      being called returns a floating point value.  */
name|asection
modifier|*
name|call_fp_stub
decl_stmt|;
comment|/* Are we forced local?  This will only be set if we have converted      the initial global GOT entry to a local GOT entry.  */
name|bfd_boolean
name|forced_local
decl_stmt|;
comment|/* Are we referenced by some kind of relocation?  */
name|bfd_boolean
name|is_relocation_target
decl_stmt|;
comment|/* Are we referenced by branch relocations?  */
name|bfd_boolean
name|is_branch_target
decl_stmt|;
define|#
directive|define
name|GOT_NORMAL
value|0
define|#
directive|define
name|GOT_TLS_GD
value|1
define|#
directive|define
name|GOT_TLS_LDM
value|2
define|#
directive|define
name|GOT_TLS_IE
value|4
define|#
directive|define
name|GOT_TLS_OFFSET_DONE
value|0x40
define|#
directive|define
name|GOT_TLS_DONE
value|0x80
name|unsigned
name|char
name|tls_type
decl_stmt|;
comment|/* This is only used in single-GOT mode; in multi-GOT mode there      is one mips_got_entry per GOT entry, so the offset is stored      there.  In single-GOT mode there may be many mips_got_entry      structures all referring to the same GOT slot.  It might be      possible to use root.got.offset instead, but that field is      overloaded already.  */
name|bfd_vma
name|tls_got_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* MIPS ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|mips_elf_link_hash_table
block|{
name|struct
name|elf_link_hash_table
name|root
decl_stmt|;
if|#
directive|if
literal|0
comment|/* We no longer use this.  */
comment|/* String section indices for the dynamic section symbols.  */
block|bfd_size_type dynsym_sec_strindex[SIZEOF_MIPS_DYNSYM_SECNAMES];
endif|#
directive|endif
comment|/* The number of .rtproc entries.  */
name|bfd_size_type
name|procedure_count
decl_stmt|;
comment|/* The size of the .compact_rel section (if SGI_COMPAT).  */
name|bfd_size_type
name|compact_rel_size
decl_stmt|;
comment|/* This flag indicates that the value of DT_MIPS_RLD_MAP dynamic      entry is set to the address of __rld_obj_head as in IRIX5.  */
name|bfd_boolean
name|use_rld_obj_head
decl_stmt|;
comment|/* This is the value of the __rld_map or __rld_obj_head symbol.  */
name|bfd_vma
name|rld_value
decl_stmt|;
comment|/* This is set if we see any mips16 stub sections.  */
name|bfd_boolean
name|mips16_stubs_seen
decl_stmt|;
comment|/* True if we're generating code for VxWorks.  */
name|bfd_boolean
name|is_vxworks
decl_stmt|;
comment|/* Shortcuts to some dynamic sections, or NULL if they are not      being used.  */
name|asection
modifier|*
name|srelbss
decl_stmt|;
name|asection
modifier|*
name|sdynbss
decl_stmt|;
name|asection
modifier|*
name|srelplt
decl_stmt|;
name|asection
modifier|*
name|srelplt2
decl_stmt|;
name|asection
modifier|*
name|sgotplt
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
comment|/* The size of the PLT header in bytes (VxWorks only).  */
name|bfd_vma
name|plt_header_size
decl_stmt|;
comment|/* The size of a PLT entry in bytes (VxWorks only).  */
name|bfd_vma
name|plt_entry_size
decl_stmt|;
comment|/* The size of a function stub entry in bytes.  */
name|bfd_vma
name|function_stub_size
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|TLS_RELOC_P
parameter_list|(
name|r_type
parameter_list|)
define|\
value|(r_type == R_MIPS_TLS_DTPMOD32		\    || r_type == R_MIPS_TLS_DTPMOD64		\    || r_type == R_MIPS_TLS_DTPREL32		\    || r_type == R_MIPS_TLS_DTPREL64		\    || r_type == R_MIPS_TLS_GD			\    || r_type == R_MIPS_TLS_LDM			\    || r_type == R_MIPS_TLS_DTPREL_HI16		\    || r_type == R_MIPS_TLS_DTPREL_LO16		\    || r_type == R_MIPS_TLS_GOTTPREL		\    || r_type == R_MIPS_TLS_TPREL32		\    || r_type == R_MIPS_TLS_TPREL64		\    || r_type == R_MIPS_TLS_TPREL_HI16		\    || r_type == R_MIPS_TLS_TPREL_LO16)
end_define

begin_comment
comment|/* Structure used to pass information to mips_elf_output_extsym.  */
end_comment

begin_struct
struct|struct
name|extsym_info
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|ecoff_debug_info
modifier|*
name|debug
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|bfd_boolean
name|failed
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The names of the runtime procedure table symbols used on IRIX5.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mips_elf_dynsym_rtproc_names
index|[]
init|=
block|{
literal|"_procedure_table"
block|,
literal|"_procedure_string_table"
block|,
literal|"_procedure_table_size"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These structures are used to generate the .compact_rel section on    IRIX5.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|long
name|id1
decl_stmt|;
comment|/* Always one?  */
name|unsigned
name|long
name|num
decl_stmt|;
comment|/* Number of compact relocation entries.  */
name|unsigned
name|long
name|id2
decl_stmt|;
comment|/* Always two?  */
name|unsigned
name|long
name|offset
decl_stmt|;
comment|/* The file offset of the first relocation.  */
name|unsigned
name|long
name|reserved0
decl_stmt|;
comment|/* Zero?  */
name|unsigned
name|long
name|reserved1
decl_stmt|;
comment|/* Zero?  */
block|}
name|Elf32_compact_rel
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|bfd_byte
name|id1
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|num
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|id2
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|offset
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|reserved0
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|reserved1
index|[
literal|4
index|]
decl_stmt|;
block|}
name|Elf32_External_compact_rel
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|int
name|ctype
range|:
literal|1
decl_stmt|;
comment|/* 1: long 0: short format. See below.  */
name|unsigned
name|int
name|rtype
range|:
literal|4
decl_stmt|;
comment|/* Relocation types. See below.  */
name|unsigned
name|int
name|dist2to
range|:
literal|8
decl_stmt|;
name|unsigned
name|int
name|relvaddr
range|:
literal|19
decl_stmt|;
comment|/* (VADDR - vaddr of the previous entry)/ 4 */
name|unsigned
name|long
name|konst
decl_stmt|;
comment|/* KONST field. See below.  */
name|unsigned
name|long
name|vaddr
decl_stmt|;
comment|/* VADDR to be relocated.  */
block|}
name|Elf32_crinfo
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|int
name|ctype
range|:
literal|1
decl_stmt|;
comment|/* 1: long 0: short format. See below.  */
name|unsigned
name|int
name|rtype
range|:
literal|4
decl_stmt|;
comment|/* Relocation types. See below.  */
name|unsigned
name|int
name|dist2to
range|:
literal|8
decl_stmt|;
name|unsigned
name|int
name|relvaddr
range|:
literal|19
decl_stmt|;
comment|/* (VADDR - vaddr of the previous entry)/ 4 */
name|unsigned
name|long
name|konst
decl_stmt|;
comment|/* KONST field. See below.  */
block|}
name|Elf32_crinfo2
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|bfd_byte
name|info
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|konst
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|vaddr
index|[
literal|4
index|]
decl_stmt|;
block|}
name|Elf32_External_crinfo
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|bfd_byte
name|info
index|[
literal|4
index|]
decl_stmt|;
name|bfd_byte
name|konst
index|[
literal|4
index|]
decl_stmt|;
block|}
name|Elf32_External_crinfo2
typedef|;
end_typedef

begin_comment
comment|/* These are the constants used to swap the bitfields in a crinfo.  */
end_comment

begin_define
define|#
directive|define
name|CRINFO_CTYPE
value|(0x1)
end_define

begin_define
define|#
directive|define
name|CRINFO_CTYPE_SH
value|(31)
end_define

begin_define
define|#
directive|define
name|CRINFO_RTYPE
value|(0xf)
end_define

begin_define
define|#
directive|define
name|CRINFO_RTYPE_SH
value|(27)
end_define

begin_define
define|#
directive|define
name|CRINFO_DIST2TO
value|(0xff)
end_define

begin_define
define|#
directive|define
name|CRINFO_DIST2TO_SH
value|(19)
end_define

begin_define
define|#
directive|define
name|CRINFO_RELVADDR
value|(0x7ffff)
end_define

begin_define
define|#
directive|define
name|CRINFO_RELVADDR_SH
value|(0)
end_define

begin_comment
comment|/* A compact relocation info has long (3 words) or short (2 words)    formats.  A short format doesn't have VADDR field and relvaddr    fields contains ((VADDR - vaddr of the previous entry)>> 2).  */
end_comment

begin_define
define|#
directive|define
name|CRF_MIPS_LONG
value|1
end_define

begin_define
define|#
directive|define
name|CRF_MIPS_SHORT
value|0
end_define

begin_comment
comment|/* There are 4 types of compact relocation at least. The value KONST    has different meaning for each type:     (type)		(konst)    CT_MIPS_REL32	Address in data    CT_MIPS_WORD		Address in word (XXX)    CT_MIPS_GPHI_LO	GP - vaddr    CT_MIPS_JMPAD	Address to jump    */
end_comment

begin_define
define|#
directive|define
name|CRT_MIPS_REL32
value|0xa
end_define

begin_define
define|#
directive|define
name|CRT_MIPS_WORD
value|0xb
end_define

begin_define
define|#
directive|define
name|CRT_MIPS_GPHI_LO
value|0xc
end_define

begin_define
define|#
directive|define
name|CRT_MIPS_JMPAD
value|0xd
end_define

begin_define
define|#
directive|define
name|mips_elf_set_cr_format
parameter_list|(
name|x
parameter_list|,
name|format
parameter_list|)
value|((x).ctype = (format))
end_define

begin_define
define|#
directive|define
name|mips_elf_set_cr_type
parameter_list|(
name|x
parameter_list|,
name|type
parameter_list|)
value|((x).rtype = (type))
end_define

begin_define
define|#
directive|define
name|mips_elf_set_cr_dist2to
parameter_list|(
name|x
parameter_list|,
name|v
parameter_list|)
value|((x).dist2to = (v))
end_define

begin_define
define|#
directive|define
name|mips_elf_set_cr_relvaddr
parameter_list|(
name|x
parameter_list|,
name|d
parameter_list|)
value|((x).relvaddr = (d)<<2)
end_define

begin_escape
end_escape

begin_comment
comment|/* The structure of the runtime procedure descriptor created by the    loader for use by the static exception system.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|runtime_pdr
block|{
name|bfd_vma
name|adr
decl_stmt|;
comment|/* Memory address of start of procedure.  */
name|long
name|regmask
decl_stmt|;
comment|/* Save register mask.  */
name|long
name|regoffset
decl_stmt|;
comment|/* Save register offset.  */
name|long
name|fregmask
decl_stmt|;
comment|/* Save floating point register mask.  */
name|long
name|fregoffset
decl_stmt|;
comment|/* Save floating point register offset.  */
name|long
name|frameoffset
decl_stmt|;
comment|/* Frame size.  */
name|short
name|framereg
decl_stmt|;
comment|/* Frame pointer register.  */
name|short
name|pcreg
decl_stmt|;
comment|/* Offset or reg of return pc.  */
name|long
name|irpss
decl_stmt|;
comment|/* Index into the runtime string table.  */
name|long
name|reserved
decl_stmt|;
name|struct
name|exception_info
modifier|*
name|exception_info
decl_stmt|;
comment|/* Pointer to exception array.  */
block|}
name|RPDR
operator|,
typedef|*
name|pRPDR
typedef|;
end_typedef

begin_define
define|#
directive|define
name|cbRPDR
value|sizeof (RPDR)
end_define

begin_define
define|#
directive|define
name|rpdNil
value|((pRPDR) 0)
end_define

begin_escape
end_escape

begin_function_decl
specifier|static
name|struct
name|mips_got_entry
modifier|*
name|mips_elf_create_local_got_entry
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|struct
name|mips_got_info
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|struct
name|mips_elf_link_hash_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|mips_elf_sort_hash_table_f
parameter_list|(
name|struct
name|mips_elf_link_hash_entry
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_vma
name|mips_elf_high
parameter_list|(
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|mips16_stub_section_p
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|mips_elf_create_dynamic_relocation
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|struct
name|mips_elf_link_hash_entry
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|bfd_vma
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|mips_elf_got_entry_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_vma
name|mips_elf_adjust_gp
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|mips_got_info
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mips_got_info
modifier|*
name|mips_elf_got_for_ibfd
parameter_list|(
name|struct
name|mips_got_info
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This will be used when we sort the dynamic relocation records.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|reldyn_sorting_bfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if ABFD is using the N32 ABI.  */
end_comment

begin_define
define|#
directive|define
name|ABI_N32_P
parameter_list|(
name|abfd
parameter_list|)
define|\
value|((elf_elfheader (abfd)->e_flags& EF_MIPS_ABI2) != 0)
end_define

begin_comment
comment|/* Nonzero if ABFD is using the N64 ABI.  */
end_comment

begin_define
define|#
directive|define
name|ABI_64_P
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->s->elfclass == ELFCLASS64)
end_define

begin_comment
comment|/* Nonzero if ABFD is using NewABI conventions.  */
end_comment

begin_define
define|#
directive|define
name|NEWABI_P
parameter_list|(
name|abfd
parameter_list|)
value|(ABI_N32_P (abfd) || ABI_64_P (abfd))
end_define

begin_comment
comment|/* The IRIX compatibility level we are striving for.  */
end_comment

begin_define
define|#
directive|define
name|IRIX_COMPAT
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->elf_backend_mips_irix_compat (abfd))
end_define

begin_comment
comment|/* Whether we are trying to be compatible with IRIX at all.  */
end_comment

begin_define
define|#
directive|define
name|SGI_COMPAT
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(IRIX_COMPAT (abfd) != ict_none)
end_define

begin_comment
comment|/* The name of the options section.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_OPTIONS_SECTION_NAME
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(NEWABI_P (abfd) ? ".MIPS.options" : ".options")
end_define

begin_comment
comment|/* True if NAME is the recognized name of any SHT_MIPS_OPTIONS section.    Some IRIX system files do not use MIPS_ELF_OPTIONS_SECTION_NAME.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_OPTIONS_SECTION_NAME_P
parameter_list|(
name|NAME
parameter_list|)
define|\
value|(strcmp (NAME, ".MIPS.options") == 0 || strcmp (NAME, ".options") == 0)
end_define

begin_comment
comment|/* Whether the section is readonly.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_READONLY_SECTION
parameter_list|(
name|sec
parameter_list|)
define|\
value|((sec->flags& (SEC_ALLOC | SEC_LOAD | SEC_READONLY))		\    == (SEC_ALLOC | SEC_LOAD | SEC_READONLY))
end_define

begin_comment
comment|/* The name of the stub section.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_STUB_SECTION_NAME
parameter_list|(
name|abfd
parameter_list|)
value|".MIPS.stubs"
end_define

begin_comment
comment|/* The size of an external REL relocation.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_REL_SIZE
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->s->sizeof_rel)
end_define

begin_comment
comment|/* The size of an external RELA relocation.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_RELA_SIZE
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->s->sizeof_rela)
end_define

begin_comment
comment|/* The size of an external dynamic table entry.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_DYN_SIZE
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->s->sizeof_dyn)
end_define

begin_comment
comment|/* The size of a GOT entry.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_GOT_SIZE
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->s->arch_size / 8)
end_define

begin_comment
comment|/* The size of a symbol-table entry.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_SYM_SIZE
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->s->sizeof_sym)
end_define

begin_comment
comment|/* The default alignment for sections, as a power of two.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_LOG_FILE_ALIGN
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->s->log_file_align)
end_define

begin_comment
comment|/* Get word-sized data.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_GET_WORD
parameter_list|(
name|abfd
parameter_list|,
name|ptr
parameter_list|)
define|\
value|(ABI_64_P (abfd) ? bfd_get_64 (abfd, ptr) : bfd_get_32 (abfd, ptr))
end_define

begin_comment
comment|/* Put out word-sized data.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_PUT_WORD
parameter_list|(
name|abfd
parameter_list|,
name|val
parameter_list|,
name|ptr
parameter_list|)
define|\
value|(ABI_64_P (abfd) 				\    ? bfd_put_64 (abfd, val, ptr) 		\    : bfd_put_32 (abfd, val, ptr))
end_define

begin_comment
comment|/* Add a dynamic symbol table-entry.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
parameter_list|(
name|info
parameter_list|,
name|tag
parameter_list|,
name|val
parameter_list|)
define|\
value|_bfd_elf_add_dynamic_entry (info, tag, val)
end_define

begin_define
define|#
directive|define
name|MIPS_ELF_RTYPE_TO_HOWTO
parameter_list|(
name|abfd
parameter_list|,
name|rtype
parameter_list|,
name|rela
parameter_list|)
define|\
value|(get_elf_backend_data (abfd)->elf_backend_mips_rtype_to_howto (rtype, rela))
end_define

begin_comment
comment|/* Determine whether the internal relocation of index REL_IDX is REL    (zero) or RELA (non-zero).  The assumption is that, if there are    two relocation sections for this section, one of them is REL and    the other is RELA.  If the index of the relocation we're testing is    in range for the first relocation section, check that the external    relocation size is that for RELA.  It is also assumed that, if    rel_idx is not in range for the first section, and this first    section contains REL relocs, then the relocation is in the second    section, that is RELA.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_RELOC_RELA_P
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|rel_idx
parameter_list|)
define|\
value|((NUM_SHDR_ENTRIES (&elf_section_data (sec)->rel_hdr)			\     * get_elf_backend_data (abfd)->s->int_rels_per_ext_rel		\> (bfd_vma)(rel_idx))						\    == (elf_section_data (sec)->rel_hdr.sh_entsize			\        == (ABI_64_P (abfd) ? sizeof (Elf64_External_Rela)		\ 	   : sizeof (Elf32_External_Rela))))
end_define

begin_comment
comment|/* The name of the dynamic relocation section.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_REL_DYN_NAME
parameter_list|(
name|INFO
parameter_list|)
define|\
value|(mips_elf_hash_table (INFO)->is_vxworks ? ".rela.dyn" : ".rel.dyn")
end_define

begin_comment
comment|/* In case we're on a 32-bit machine, construct a 64-bit "-1" value    from smaller values.  Start with zero, widen, *then* decrement.  */
end_comment

begin_define
define|#
directive|define
name|MINUS_ONE
value|(((bfd_vma)0) - 1)
end_define

begin_define
define|#
directive|define
name|MINUS_TWO
value|(((bfd_vma)0) - 2)
end_define

begin_comment
comment|/* The number of local .got entries we reserve.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_RESERVED_GOTNO
parameter_list|(
name|INFO
parameter_list|)
define|\
value|(mips_elf_hash_table (INFO)->is_vxworks ? 3 : 2)
end_define

begin_comment
comment|/* The offset of $gp from the beginning of the .got section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_MIPS_GP_OFFSET
parameter_list|(
name|INFO
parameter_list|)
define|\
value|(mips_elf_hash_table (INFO)->is_vxworks ? 0x0 : 0x7ff0)
end_define

begin_comment
comment|/* The maximum size of the GOT for it to be addressable using 16-bit    offsets from $gp.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_ELF_GOT_MAX_SIZE
parameter_list|(
name|INFO
parameter_list|)
value|(ELF_MIPS_GP_OFFSET (INFO) + 0x7fff)
end_define

begin_comment
comment|/* Instructions which appear in a stub.  */
end_comment

begin_define
define|#
directive|define
name|STUB_LW
parameter_list|(
name|abfd
parameter_list|)
define|\
value|((ABI_64_P (abfd)							\     ? 0xdf998010
comment|/* ld t9,0x8010(gp) */
value|\     : 0x8f998010))
end_define

begin_comment
comment|/* lw t9,0x8010(gp) */
end_comment

begin_define
define|#
directive|define
name|STUB_MOVE
parameter_list|(
name|abfd
parameter_list|)
define|\
value|((ABI_64_P (abfd)							\      ? 0x03e0782d
comment|/* daddu t7,ra */
value|\      : 0x03e07821))
end_define

begin_comment
comment|/* addu t7,ra */
end_comment

begin_define
define|#
directive|define
name|STUB_LUI
parameter_list|(
name|VAL
parameter_list|)
value|(0x3c180000 + (VAL))
end_define

begin_comment
comment|/* lui t8,VAL */
end_comment

begin_define
define|#
directive|define
name|STUB_JALR
value|0x0320f809
end_define

begin_comment
comment|/* jalr t9,ra */
end_comment

begin_define
define|#
directive|define
name|STUB_ORI
parameter_list|(
name|VAL
parameter_list|)
value|(0x37180000 + (VAL))
end_define

begin_comment
comment|/* ori t8,t8,VAL */
end_comment

begin_define
define|#
directive|define
name|STUB_LI16U
parameter_list|(
name|VAL
parameter_list|)
value|(0x34180000 + (VAL))
end_define

begin_comment
comment|/* ori t8,zero,VAL unsigned */
end_comment

begin_define
define|#
directive|define
name|STUB_LI16S
parameter_list|(
name|abfd
parameter_list|,
name|VAL
parameter_list|)
define|\
value|((ABI_64_P (abfd)							\     ? (0x64180000 + (VAL))
comment|/* daddiu t8,zero,VAL sign extended */
value|\     : (0x24180000 + (VAL))))
end_define

begin_comment
comment|/* addiu t8,zero,VAL sign extended */
end_comment

begin_define
define|#
directive|define
name|MIPS_FUNCTION_STUB_NORMAL_SIZE
value|16
end_define

begin_define
define|#
directive|define
name|MIPS_FUNCTION_STUB_BIG_SIZE
value|20
end_define

begin_comment
comment|/* The name of the dynamic interpreter.  This is put in the .interp    section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
parameter_list|(
name|abfd
parameter_list|)
define|\
value|(ABI_N32_P (abfd) ? "/usr/lib32/libc.so.1" 	\     : ABI_64_P (abfd) ? "/usr/lib64/libc.so.1" 	\     : "/usr/lib/libc.so.1")
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|BFD64
end_ifdef

begin_define
define|#
directive|define
name|MNAME
parameter_list|(
name|bfd
parameter_list|,
name|pre
parameter_list|,
name|pos
parameter_list|)
define|\
value|(ABI_64_P (bfd) ? CONCAT4 (pre,64,_,pos) : CONCAT4 (pre,32,_,pos))
end_define

begin_define
define|#
directive|define
name|ELF_R_SYM
parameter_list|(
name|bfd
parameter_list|,
name|i
parameter_list|)
define|\
value|(ABI_64_P (bfd) ? ELF64_R_SYM (i) : ELF32_R_SYM (i))
end_define

begin_define
define|#
directive|define
name|ELF_R_TYPE
parameter_list|(
name|bfd
parameter_list|,
name|i
parameter_list|)
define|\
value|(ABI_64_P (bfd) ? ELF64_MIPS_R_TYPE (i) : ELF32_R_TYPE (i))
end_define

begin_define
define|#
directive|define
name|ELF_R_INFO
parameter_list|(
name|bfd
parameter_list|,
name|s
parameter_list|,
name|t
parameter_list|)
define|\
value|(ABI_64_P (bfd) ? ELF64_R_INFO (s, t) : ELF32_R_INFO (s, t))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MNAME
parameter_list|(
name|bfd
parameter_list|,
name|pre
parameter_list|,
name|pos
parameter_list|)
value|CONCAT4 (pre,32,_,pos)
end_define

begin_define
define|#
directive|define
name|ELF_R_SYM
parameter_list|(
name|bfd
parameter_list|,
name|i
parameter_list|)
define|\
value|(ELF32_R_SYM (i))
end_define

begin_define
define|#
directive|define
name|ELF_R_TYPE
parameter_list|(
name|bfd
parameter_list|,
name|i
parameter_list|)
define|\
value|(ELF32_R_TYPE (i))
end_define

begin_define
define|#
directive|define
name|ELF_R_INFO
parameter_list|(
name|bfd
parameter_list|,
name|s
parameter_list|,
name|t
parameter_list|)
define|\
value|(ELF32_R_INFO (s, t))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* The mips16 compiler uses a couple of special sections to handle      floating point arguments.       Section names that look like .mips16.fn.FNNAME contain stubs that      copy floating point arguments from the fp regs to the gp regs and      then jump to FNNAME.  If any 32 bit function calls FNNAME, the      call should be redirected to the stub instead.  If no 32 bit      function calls FNNAME, the stub should be discarded.  We need to      consider any reference to the function, not just a call, because      if the address of the function is taken we will need the stub,      since the address might be passed to a 32 bit function.       Section names that look like .mips16.call.FNNAME contain stubs      that copy floating point arguments from the gp regs to the fp      regs and then jump to FNNAME.  If FNNAME is a 32 bit function,      then any 16 bit function that calls FNNAME should be redirected      to the stub instead.  If FNNAME is not a 32 bit function, the      stub should be discarded.       .mips16.call.fp.FNNAME sections are similar, but contain stubs      which call FNNAME and then copy the return value from the fp regs      to the gp regs.  These stubs store the return value in $18 while      calling FNNAME; any function which might call one of these stubs      must arrange to save $18 around the call.  (This case is not      needed for 32 bit functions that call 16 bit functions, because      16 bit functions always return floating point values in both      $f0/$f1 and $2/$3.)       Note that in all cases FNNAME might be defined statically.      Therefore, FNNAME is not used literally.  Instead, the relocation      information will indicate which symbol the section is for.       We record any stubs that we find in the symbol table.  */
end_comment

begin_define
define|#
directive|define
name|FN_STUB
value|".mips16.fn."
end_define

begin_define
define|#
directive|define
name|CALL_STUB
value|".mips16.call."
end_define

begin_define
define|#
directive|define
name|CALL_FP_STUB
value|".mips16.call.fp."
end_define

begin_define
define|#
directive|define
name|FN_STUB_P
parameter_list|(
name|name
parameter_list|)
value|CONST_STRNEQ (name, FN_STUB)
end_define

begin_define
define|#
directive|define
name|CALL_STUB_P
parameter_list|(
name|name
parameter_list|)
value|CONST_STRNEQ (name, CALL_STUB)
end_define

begin_define
define|#
directive|define
name|CALL_FP_STUB_P
parameter_list|(
name|name
parameter_list|)
value|CONST_STRNEQ (name, CALL_FP_STUB)
end_define

begin_escape
end_escape

begin_comment
comment|/* The format of the first PLT entry in a VxWorks executable.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|mips_vxworks_exec_plt0_entry
index|[]
init|=
block|{
literal|0x3c190000
block|,
comment|/* lui t9, %hi(_GLOBAL_OFFSET_TABLE_)		*/
literal|0x27390000
block|,
comment|/* addiu t9, t9, %lo(_GLOBAL_OFFSET_TABLE_)	*/
literal|0x8f390008
block|,
comment|/* lw t9, 8(t9)					*/
literal|0x00000000
block|,
comment|/* nop						*/
literal|0x03200008
block|,
comment|/* jr t9					*/
literal|0x00000000
comment|/* nop						*/
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The format of subsequent PLT entries.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|mips_vxworks_exec_plt_entry
index|[]
init|=
block|{
literal|0x10000000
block|,
comment|/* b .PLT_resolver			*/
literal|0x24180000
block|,
comment|/* li t8,<pltindex>			*/
literal|0x3c190000
block|,
comment|/* lui t9, %hi(<.got.plt slot>)		*/
literal|0x27390000
block|,
comment|/* addiu t9, t9, %lo(<.got.plt slot>)	*/
literal|0x8f390000
block|,
comment|/* lw t9, 0(t9)				*/
literal|0x00000000
block|,
comment|/* nop					*/
literal|0x03200008
block|,
comment|/* jr t9				*/
literal|0x00000000
comment|/* nop					*/
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The format of the first PLT entry in a VxWorks shared object.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|mips_vxworks_shared_plt0_entry
index|[]
init|=
block|{
literal|0x8f990008
block|,
comment|/* lw t9, 8(gp)		*/
literal|0x00000000
block|,
comment|/* nop			*/
literal|0x03200008
block|,
comment|/* jr t9		*/
literal|0x00000000
block|,
comment|/* nop			*/
literal|0x00000000
block|,
comment|/* nop			*/
literal|0x00000000
comment|/* nop			*/
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The format of subsequent PLT entries.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_vma
name|mips_vxworks_shared_plt_entry
index|[]
init|=
block|{
literal|0x10000000
block|,
comment|/* b .PLT_resolver	*/
literal|0x24180000
comment|/* li t8,<pltindex>	*/
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Look up an entry in a MIPS ELF linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|mips_elf_link_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|,
name|follow
parameter_list|)
define|\
value|((struct mips_elf_link_hash_entry *)					\    elf_link_hash_lookup (&(table)->root, (string), (create),		\ 			 (copy), (follow)))
end_define

begin_comment
comment|/* Traverse a MIPS ELF linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|mips_elf_link_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
define|\
value|(elf_link_hash_traverse						\    (&(table)->root,							\     (bfd_boolean (*) (struct elf_link_hash_entry *, void *)) (func),	\     (info)))
end_define

begin_comment
comment|/* Get the MIPS ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|mips_elf_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct mips_elf_link_hash_table *) ((p)->hash))
end_define

begin_comment
comment|/* Find the base offsets for thread-local storage in this object,    for GD/LD and IE/LE respectively.  */
end_comment

begin_define
define|#
directive|define
name|TP_OFFSET
value|0x7000
end_define

begin_define
define|#
directive|define
name|DTP_OFFSET
value|0x8000
end_define

begin_function
specifier|static
name|bfd_vma
name|dtprel_base
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
comment|/* If tls_sec is NULL, we should have signalled an error already.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|->
name|vma
operator|+
name|DTP_OFFSET
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|tprel_base
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
comment|/* If tls_sec is NULL, we should have signalled an error already.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|->
name|vma
operator|+
name|TP_OFFSET
return|;
block|}
end_function

begin_comment
comment|/* Create an entry in a MIPS ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|mips_elf_link_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_elf_link_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|_bfd_elf_link_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
block|{
comment|/* Set local fields.  */
name|memset
argument_list|(
operator|&
name|ret
operator|->
name|esym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|EXTR
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We use -2 as a marker to indicate that the information has 	 not been set.  -1 means there is no associated ifd.  */
name|ret
operator|->
name|esym
operator|.
name|ifd
operator|=
operator|-
literal|2
expr_stmt|;
name|ret
operator|->
name|possibly_dynamic_relocs
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|readonly_reloc
operator|=
name|FALSE
expr_stmt|;
name|ret
operator|->
name|no_fn_stub
operator|=
name|FALSE
expr_stmt|;
name|ret
operator|->
name|fn_stub
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|need_fn_stub
operator|=
name|FALSE
expr_stmt|;
name|ret
operator|->
name|call_stub
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|call_fp_stub
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|forced_local
operator|=
name|FALSE
expr_stmt|;
name|ret
operator|->
name|is_branch_target
operator|=
name|FALSE
expr_stmt|;
name|ret
operator|->
name|is_relocation_target
operator|=
name|FALSE
expr_stmt|;
name|ret
operator|->
name|tls_type
operator|=
name|GOT_NORMAL
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_mips_elf_new_section_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sec
operator|->
name|used_by_bfd
condition|)
block|{
name|struct
name|_mips_elf_section_data
modifier|*
name|sdata
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
operator|*
name|sdata
argument_list|)
decl_stmt|;
name|sdata
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdata
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sec
operator|->
name|used_by_bfd
operator|=
name|sdata
expr_stmt|;
block|}
return|return
name|_bfd_elf_new_section_hook
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read ECOFF debugging information from a .mdebug section into a    ecoff_debug_info structure.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_read_ecoff_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|struct
name|ecoff_debug_info
modifier|*
name|debug
parameter_list|)
block|{
name|HDRR
modifier|*
name|symhdr
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|char
modifier|*
name|ext_hdr
decl_stmt|;
name|swap
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
expr_stmt|;
name|memset
argument_list|(
name|debug
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|debug
argument_list|)
argument_list|)
expr_stmt|;
name|ext_hdr
operator|=
name|bfd_malloc
argument_list|(
name|swap
operator|->
name|external_hdr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_hdr
operator|==
name|NULL
operator|&&
name|swap
operator|->
name|external_hdr_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|ext_hdr
argument_list|,
literal|0
argument_list|,
name|swap
operator|->
name|external_hdr_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|symhdr
operator|=
operator|&
name|debug
operator|->
name|symbolic_header
expr_stmt|;
call|(
modifier|*
name|swap
operator|->
name|swap_hdr_in
call|)
argument_list|(
name|abfd
argument_list|,
name|ext_hdr
argument_list|,
name|symhdr
argument_list|)
expr_stmt|;
comment|/* The symbolic header contains absolute file offsets and sizes to      read.  */
define|#
directive|define
name|READ
parameter_list|(
name|ptr
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|,
name|size
parameter_list|,
name|type
parameter_list|)
define|\
value|if (symhdr->count == 0)						\     debug->ptr = NULL;							\   else									\     {									\       bfd_size_type amt = (bfd_size_type) size * symhdr->count;		\       debug->ptr = bfd_malloc (amt);					\       if (debug->ptr == NULL)						\ 	goto error_return;						\       if (bfd_seek (abfd, symhdr->offset, SEEK_SET) != 0		\ 	  || bfd_bread (debug->ptr, amt, abfd) != amt)			\ 	goto error_return;						\     }
name|READ
argument_list|(
argument|line
argument_list|,
argument|cbLineOffset
argument_list|,
argument|cbLine
argument_list|,
argument|sizeof (unsigned char)
argument_list|,
argument|unsigned char *
argument_list|)
empty_stmt|;
name|READ
argument_list|(
name|external_dnr
argument_list|,
name|cbDnOffset
argument_list|,
name|idnMax
argument_list|,
name|swap
operator|->
name|external_dnr_size
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_pdr
argument_list|,
name|cbPdOffset
argument_list|,
name|ipdMax
argument_list|,
name|swap
operator|->
name|external_pdr_size
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_sym
argument_list|,
name|cbSymOffset
argument_list|,
name|isymMax
argument_list|,
name|swap
operator|->
name|external_sym_size
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_opt
argument_list|,
name|cbOptOffset
argument_list|,
name|ioptMax
argument_list|,
name|swap
operator|->
name|external_opt_size
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_aux
argument_list|,
name|cbAuxOffset
argument_list|,
name|iauxMax
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|aux_ext
argument_list|)
argument_list|,
expr|union
name|aux_ext
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|ss
argument_list|,
name|cbSsOffset
argument_list|,
name|issMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|ssext
argument_list|,
name|cbSsExtOffset
argument_list|,
name|issExtMax
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_fdr
argument_list|,
name|cbFdOffset
argument_list|,
name|ifdMax
argument_list|,
name|swap
operator|->
name|external_fdr_size
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_rfd
argument_list|,
name|cbRfdOffset
argument_list|,
name|crfd
argument_list|,
name|swap
operator|->
name|external_rfd_size
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|READ
argument_list|(
name|external_ext
argument_list|,
name|cbExtOffset
argument_list|,
name|iextMax
argument_list|,
name|swap
operator|->
name|external_ext_size
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|READ
name|debug
operator|->
name|fdr
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|ext_hdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ext_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|line
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_dnr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_dnr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_pdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_pdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_sym
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_opt
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_aux
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_aux
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|ss
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|ssext
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|ssext
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_fdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_fdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_rfd
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_rfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|->
name|external_ext
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|debug
operator|->
name|external_ext
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Swap RPDR (runtime procedure table entry) for output.  */
end_comment

begin_function
specifier|static
name|void
name|ecoff_swap_rpdr_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|RPDR
modifier|*
name|in
parameter_list|,
name|struct
name|rpdr_ext
modifier|*
name|ex
parameter_list|)
block|{
name|H_PUT_S32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|adr
argument_list|,
name|ex
operator|->
name|p_adr
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|regmask
argument_list|,
name|ex
operator|->
name|p_regmask
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|regoffset
argument_list|,
name|ex
operator|->
name|p_regoffset
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|fregmask
argument_list|,
name|ex
operator|->
name|p_fregmask
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|fregoffset
argument_list|,
name|ex
operator|->
name|p_fregoffset
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|frameoffset
argument_list|,
name|ex
operator|->
name|p_frameoffset
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|framereg
argument_list|,
name|ex
operator|->
name|p_framereg
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|pcreg
argument_list|,
name|ex
operator|->
name|p_pcreg
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|irpss
argument_list|,
name|ex
operator|->
name|p_irpss
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a runtime procedure table from the .mdebug section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_create_procedure_table
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|s
parameter_list|,
name|struct
name|ecoff_debug_info
modifier|*
name|debug
parameter_list|)
block|{
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
decl_stmt|;
name|HDRR
modifier|*
name|hdr
init|=
operator|&
name|debug
operator|->
name|symbolic_header
decl_stmt|;
name|RPDR
modifier|*
name|rpdr
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|struct
name|rpdr_ext
modifier|*
name|erp
decl_stmt|;
name|void
modifier|*
name|rtproc
decl_stmt|;
name|struct
name|pdr_ext
modifier|*
name|epdr
decl_stmt|;
name|struct
name|sym_ext
modifier|*
name|esym
decl_stmt|;
name|char
modifier|*
name|ss
decl_stmt|,
modifier|*
modifier|*
name|sv
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
name|unsigned
name|long
name|sindex
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
name|PDR
name|pdr
decl_stmt|;
name|SYMR
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
name|no_name_func
init|=
name|_
argument_list|(
literal|"static procedure (no name)"
argument_list|)
decl_stmt|;
name|epdr
operator|=
name|NULL
expr_stmt|;
name|rpdr
operator|=
name|NULL
expr_stmt|;
name|esym
operator|=
name|NULL
expr_stmt|;
name|ss
operator|=
name|NULL
expr_stmt|;
name|sv
operator|=
name|NULL
expr_stmt|;
name|swap
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
expr_stmt|;
name|sindex
operator|=
name|strlen
argument_list|(
name|no_name_func
argument_list|)
operator|+
literal|1
expr_stmt|;
name|count
operator|=
name|hdr
operator|->
name|ipdMax
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|size
operator|=
name|swap
operator|->
name|external_pdr_size
expr_stmt|;
name|epdr
operator|=
name|bfd_malloc
argument_list|(
name|size
operator|*
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|epdr
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|_bfd_ecoff_get_accumulated_pdr
argument_list|(
name|handle
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|epdr
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|RPDR
argument_list|)
expr_stmt|;
name|rp
operator|=
name|rpdr
operator|=
name|bfd_malloc
argument_list|(
name|size
operator|*
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpdr
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
name|sv
operator|=
name|bfd_malloc
argument_list|(
name|size
operator|*
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|sv
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|count
operator|=
name|hdr
operator|->
name|isymMax
expr_stmt|;
name|size
operator|=
name|swap
operator|->
name|external_sym_size
expr_stmt|;
name|esym
operator|=
name|bfd_malloc
argument_list|(
name|size
operator|*
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|esym
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|_bfd_ecoff_get_accumulated_sym
argument_list|(
name|handle
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|esym
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|count
operator|=
name|hdr
operator|->
name|issMax
expr_stmt|;
name|ss
operator|=
name|bfd_malloc
argument_list|(
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|_bfd_ecoff_get_accumulated_ss
argument_list|(
name|handle
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|ss
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|count
operator|=
name|hdr
operator|->
name|ipdMax
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|unsigned
name|long
operator|)
name|count
condition|;
name|i
operator|++
operator|,
name|rp
operator|++
control|)
block|{
call|(
modifier|*
name|swap
operator|->
name|swap_pdr_in
call|)
argument_list|(
name|abfd
argument_list|,
name|epdr
operator|+
name|i
argument_list|,
operator|&
name|pdr
argument_list|)
expr_stmt|;
call|(
modifier|*
name|swap
operator|->
name|swap_sym_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|&
name|esym
index|[
name|pdr
operator|.
name|isym
index|]
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
name|rp
operator|->
name|adr
operator|=
name|sym
operator|.
name|value
expr_stmt|;
name|rp
operator|->
name|regmask
operator|=
name|pdr
operator|.
name|regmask
expr_stmt|;
name|rp
operator|->
name|regoffset
operator|=
name|pdr
operator|.
name|regoffset
expr_stmt|;
name|rp
operator|->
name|fregmask
operator|=
name|pdr
operator|.
name|fregmask
expr_stmt|;
name|rp
operator|->
name|fregoffset
operator|=
name|pdr
operator|.
name|fregoffset
expr_stmt|;
name|rp
operator|->
name|frameoffset
operator|=
name|pdr
operator|.
name|frameoffset
expr_stmt|;
name|rp
operator|->
name|framereg
operator|=
name|pdr
operator|.
name|framereg
expr_stmt|;
name|rp
operator|->
name|pcreg
operator|=
name|pdr
operator|.
name|pcreg
expr_stmt|;
name|rp
operator|->
name|irpss
operator|=
name|sindex
expr_stmt|;
name|sv
index|[
name|i
index|]
operator|=
name|ss
operator|+
name|sym
operator|.
name|iss
expr_stmt|;
name|sindex
operator|+=
name|strlen
argument_list|(
name|sv
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|rpdr_ext
argument_list|)
operator|*
operator|(
name|count
operator|+
literal|2
operator|)
operator|+
name|sindex
expr_stmt|;
name|size
operator|=
name|BFD_ALIGN
argument_list|(
name|size
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|rtproc
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtproc
operator|==
name|NULL
condition|)
block|{
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|procedure_count
operator|=
literal|0
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|procedure_count
operator|=
name|count
operator|+
literal|2
expr_stmt|;
name|erp
operator|=
name|rtproc
expr_stmt|;
name|memset
argument_list|(
name|erp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpdr_ext
argument_list|)
argument_list|)
expr_stmt|;
name|erp
operator|++
expr_stmt|;
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|rtproc
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|rpdr_ext
argument_list|)
operator|*
operator|(
name|count
operator|+
literal|2
operator|)
expr_stmt|;
name|strcpy
argument_list|(
name|str
argument_list|,
name|no_name_func
argument_list|)
expr_stmt|;
name|str
operator|+=
name|strlen
argument_list|(
name|no_name_func
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|ecoff_swap_rpdr_out
argument_list|(
name|abfd
argument_list|,
name|rpdr
operator|+
name|i
argument_list|,
name|erp
operator|+
name|i
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|str
argument_list|,
name|sv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|str
operator|+=
name|strlen
argument_list|(
name|sv
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|H_PUT_S32
argument_list|(
name|abfd
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|erp
operator|+
name|count
operator|)
operator|->
name|p_adr
argument_list|)
expr_stmt|;
comment|/* Set the size and contents of .rtproc section.  */
name|s
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|s
operator|->
name|contents
operator|=
name|rtproc
expr_stmt|;
comment|/* Skip this section later on (I don't think this currently      matters, but someday it might).  */
name|s
operator|->
name|map_head
operator|.
name|link_order
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|epdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|epdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rpdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|esym
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|esym
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|sv
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|epdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|epdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rpdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|esym
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|esym
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|sv
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sv
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Check the mips16 stubs for a particular symbol, and see if we can    discard them.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_check_mips16_stubs
parameter_list|(
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|fn_stub
operator|!=
name|NULL
operator|&&
operator|!
name|h
operator|->
name|need_fn_stub
condition|)
block|{
comment|/* We don't need the fn_stub; the only references to this symbol          are 16 bit calls.  Clobber the size to 0 to prevent it from          being included in the link.  */
name|h
operator|->
name|fn_stub
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|fn_stub
operator|->
name|flags
operator|&=
operator|~
name|SEC_RELOC
expr_stmt|;
name|h
operator|->
name|fn_stub
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|fn_stub
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|call_stub
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|other
operator|==
name|STO_MIPS16
condition|)
block|{
comment|/* We don't need the call_stub; this is a 16 bit function, so          calls from other 16 bit functions are OK.  Clobber the size          to 0 to prevent it from being included in the link.  */
name|h
operator|->
name|call_stub
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_stub
operator|->
name|flags
operator|&=
operator|~
name|SEC_RELOC
expr_stmt|;
name|h
operator|->
name|call_stub
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_stub
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|call_fp_stub
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|other
operator|==
name|STO_MIPS16
condition|)
block|{
comment|/* We don't need the call_stub; this is a 16 bit function, so          calls from other 16 bit functions are OK.  Clobber the size          to 0 to prevent it from being included in the link.  */
name|h
operator|->
name|call_fp_stub
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_fp_stub
operator|->
name|flags
operator|&=
operator|~
name|SEC_RELOC
expr_stmt|;
name|h
operator|->
name|call_fp_stub
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|call_fp_stub
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* R_MIPS16_26 is used for the mips16 jal and jalx instructions.    Most mips16 instructions are 16 bits, but these instructions    are 32 bits.     The format of these instructions is:     +--------------+--------------------------------+    |     JALX     | X|   Imm 20:16  |   Imm 25:21  |    +--------------+--------------------------------+    |                Immediate  15:0                |    +-----------------------------------------------+     JALX is the 5-bit value 00011.  X is 0 for jal, 1 for jalx.    Note that the immediate value in the first word is swapped.     When producing a relocatable object file, R_MIPS16_26 is    handled mostly like R_MIPS_26.  In particular, the addend is    stored as a straight 26-bit value in a 32-bit instruction.    (gas makes life simpler for itself by never adjusting a    R_MIPS16_26 reloc to be against a section, so the addend is    always zero).  However, the 32 bit instruction is stored as 2    16-bit values, rather than a single 32-bit value.  In a    big-endian file, the result is the same; in a little-endian    file, the two 16-bit halves of the 32 bit value are swapped.    This is so that a disassembler can recognize the jal    instruction.     When doing a final link, R_MIPS16_26 is treated as a 32 bit    instruction stored as two 16-bit values.  The addend A is the    contents of the targ26 field.  The calculation is the same as    R_MIPS_26.  When storing the calculated value, reorder the    immediate value as shown above, and don't forget to store the    value as two 16-bit values.     To put it in MIPS ABI terms, the relocation field is T-targ26-16,    defined as     big-endian:    +--------+----------------------+    |        |                      |    |        |    targ26-16         |    |31    26|25                   0|    +--------+----------------------+     little-endian:    +----------+------+-------------+    |          |      |             |    |  sub1    |      |     sub2    |    |0        9|10  15|16         31|    +----------+--------------------+    where targ26-16 is sub1 followed by sub2 (i.e., the addend field A is    ((sub1<< 16) | sub2)).     When producing a relocatable object file, the calculation is    (((A< 2) | ((P + 4)& 0xf0000000) + S)>> 2)    When producing a fully linked file, the calculation is    let R = (((A< 2) | ((P + 4)& 0xf0000000) + S)>> 2)    ((R& 0x1f0000)<< 5) | ((R& 0x3e00000)>> 5) | (R& 0xffff)     R_MIPS16_GPREL is used for GP-relative addressing in mips16    mode.  A typical instruction will have a format like this:     +--------------+--------------------------------+    |    EXTEND    |     Imm 10:5    |   Imm 15:11  |    +--------------+--------------------------------+    |    Major     |   rx   |   ry   |   Imm  4:0   |    +--------------+--------------------------------+     EXTEND is the five bit value 11110.  Major is the instruction    opcode.     This is handled exactly like R_MIPS_GPREL16, except that the    addend is retrieved and stored as shown in this diagram; that    is, the Imm fields above replace the V-rel16 field.     All we need to do here is shuffle the bits appropriately.  As    above, the two 16-bit halves must be swapped on a    little-endian system.     R_MIPS16_HI16 and R_MIPS16_LO16 are used in mips16 mode to    access data when neither GP-relative nor PC-relative addressing    can be used.  They are handled like R_MIPS_HI16 and R_MIPS_LO16,    except that the addend is retrieved and stored as shown above    for R_MIPS16_GPREL.   */
end_comment

begin_function
name|void
name|_bfd_mips16_elf_reloc_unshuffle
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|r_type
parameter_list|,
name|bfd_boolean
name|jal_shuffle
parameter_list|,
name|bfd_byte
modifier|*
name|data
parameter_list|)
block|{
name|bfd_vma
name|extend
decl_stmt|,
name|insn
decl_stmt|,
name|val
decl_stmt|;
if|if
condition|(
name|r_type
operator|!=
name|R_MIPS16_26
operator|&&
name|r_type
operator|!=
name|R_MIPS16_GPREL
operator|&&
name|r_type
operator|!=
name|R_MIPS16_HI16
operator|&&
name|r_type
operator|!=
name|R_MIPS16_LO16
condition|)
return|return;
comment|/* Pick up the mips16 extend instruction and the real instruction.  */
name|extend
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_26
condition|)
block|{
if|if
condition|(
name|jal_shuffle
condition|)
name|val
operator|=
operator|(
operator|(
name|extend
operator|&
literal|0xfc00
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|extend
operator|&
literal|0x3e0
operator|)
operator|<<
literal|11
operator|)
operator||
operator|(
operator|(
name|extend
operator|&
literal|0x1f
operator|)
operator|<<
literal|21
operator|)
operator||
name|insn
expr_stmt|;
else|else
name|val
operator|=
name|extend
operator|<<
literal|16
operator||
name|insn
expr_stmt|;
block|}
else|else
name|val
operator|=
operator|(
operator|(
name|extend
operator|&
literal|0xf800
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|insn
operator|&
literal|0xffe0
operator|)
operator|<<
literal|11
operator|)
operator||
operator|(
operator|(
name|extend
operator|&
literal|0x1f
operator|)
operator|<<
literal|11
operator|)
operator||
operator|(
name|extend
operator|&
literal|0x7e0
operator|)
operator||
operator|(
name|insn
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|val
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_bfd_mips16_elf_reloc_shuffle
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|r_type
parameter_list|,
name|bfd_boolean
name|jal_shuffle
parameter_list|,
name|bfd_byte
modifier|*
name|data
parameter_list|)
block|{
name|bfd_vma
name|extend
decl_stmt|,
name|insn
decl_stmt|,
name|val
decl_stmt|;
if|if
condition|(
name|r_type
operator|!=
name|R_MIPS16_26
operator|&&
name|r_type
operator|!=
name|R_MIPS16_GPREL
operator|&&
name|r_type
operator|!=
name|R_MIPS16_HI16
operator|&&
name|r_type
operator|!=
name|R_MIPS16_LO16
condition|)
return|return;
name|val
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_26
condition|)
block|{
if|if
condition|(
name|jal_shuffle
condition|)
block|{
name|insn
operator|=
name|val
operator|&
literal|0xffff
expr_stmt|;
name|extend
operator|=
operator|(
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0xfc00
operator|)
operator||
operator|(
operator|(
name|val
operator|>>
literal|11
operator|)
operator|&
literal|0x3e0
operator|)
operator||
operator|(
operator|(
name|val
operator|>>
literal|21
operator|)
operator|&
literal|0x1f
operator|)
expr_stmt|;
block|}
else|else
block|{
name|insn
operator|=
name|val
operator|&
literal|0xffff
expr_stmt|;
name|extend
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
block|}
block|}
else|else
block|{
name|insn
operator|=
operator|(
operator|(
name|val
operator|>>
literal|11
operator|)
operator|&
literal|0xffe0
operator|)
operator||
operator|(
name|val
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|extend
operator|=
operator|(
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0xf800
operator|)
operator||
operator|(
operator|(
name|val
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
operator|)
operator||
operator|(
name|val
operator|&
literal|0x7e0
operator|)
expr_stmt|;
block|}
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|extend
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bfd_reloc_status_type
name|_bfd_mips_elf_gprel16_with_gp
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_boolean
name|relocatable
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|bfd_vma
name|gp
parameter_list|)
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_signed_vma
name|val
decl_stmt|;
name|bfd_reloc_status_type
name|status
decl_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|input_section
argument_list|)
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* Set val to the offset into the section or symbol.  */
name|val
operator|=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|_bfd_mips_elf_sign_extend
argument_list|(
name|val
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Adjust val for the final section location and GP value.  If we      are producing relocatable output, we don't want to do this for      an external symbol.  */
if|if
condition|(
operator|!
name|relocatable
operator|||
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
condition|)
name|val
operator|+=
name|relocation
operator|-
name|gp
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|howto
operator|->
name|partial_inplace
condition|)
block|{
name|status
operator|=
name|_bfd_relocate_contents
argument_list|(
name|reloc_entry
operator|->
name|howto
argument_list|,
name|abfd
argument_list|,
name|val
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|status
return|;
block|}
else|else
name|reloc_entry
operator|->
name|addend
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|relocatable
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Used to store a REL high-part relocation such as R_MIPS_HI16 or    R_MIPS_GOT16.  REL is the relocation, INPUT_SECTION is the section    that contains the relocation field and DATA points to the start of    INPUT_SECTION.  */
end_comment

begin_struct
struct|struct
name|mips_hi16
block|{
name|struct
name|mips_hi16
modifier|*
name|next
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|arelent
name|rel
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* FIXME: This should not be a static variable.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mips_hi16
modifier|*
name|mips_hi16_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A howto special_function for REL *HI16 relocations.  We can only    calculate the correct value once we've seen the partnering    *LO16 relocation, so just save the information for later.     The ABI requires that the *LO16 immediately follow the *HI16.    However, as a GNU extension, we permit an arbitrary number of    *HI16s to be associated with a single *LO16.  This significantly    simplies the relocation handling in gcc.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|_bfd_mips_elf_hi16_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|mips_hi16
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|input_section
argument_list|)
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|n
operator|=
name|bfd_malloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|n
operator|->
name|next
operator|=
name|mips_hi16_list
expr_stmt|;
name|n
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|n
operator|->
name|input_section
operator|=
name|input_section
expr_stmt|;
name|n
operator|->
name|rel
operator|=
operator|*
name|reloc_entry
expr_stmt|;
name|mips_hi16_list
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* A howto special_function for REL R_MIPS_GOT16 relocations.  This is just    like any other 16-bit relocation when applied to global symbols, but is    treated in the same as R_MIPS_HI16 when applied to local symbols.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|_bfd_mips_elf_got16_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
if|if
condition|(
operator|(
name|symbol
operator|->
name|flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_WEAK
operator|)
operator|)
operator|!=
literal|0
operator|||
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|symbol
argument_list|)
argument_list|)
operator|||
name|bfd_is_com_section
argument_list|(
name|bfd_get_section
argument_list|(
name|symbol
argument_list|)
argument_list|)
condition|)
comment|/* The relocation is against a global symbol.  */
return|return
name|_bfd_mips_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
return|return
name|_bfd_mips_elf_hi16_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A howto special_function for REL *LO16 relocations.  The *LO16 itself    is a straightforward 16 bit inplace relocation, but we must deal with    any partnering high-part relocations as well.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|_bfd_mips_elf_lo16_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
name|bfd_vma
name|vallo
decl_stmt|;
name|bfd_byte
modifier|*
name|location
init|=
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
decl_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|input_section
argument_list|)
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|_bfd_mips16_elf_reloc_unshuffle
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
operator|->
name|howto
operator|->
name|type
argument_list|,
name|FALSE
argument_list|,
name|location
argument_list|)
expr_stmt|;
name|vallo
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|location
argument_list|)
expr_stmt|;
name|_bfd_mips16_elf_reloc_shuffle
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
operator|->
name|howto
operator|->
name|type
argument_list|,
name|FALSE
argument_list|,
name|location
argument_list|)
expr_stmt|;
while|while
condition|(
name|mips_hi16_list
operator|!=
name|NULL
condition|)
block|{
name|bfd_reloc_status_type
name|ret
decl_stmt|;
name|struct
name|mips_hi16
modifier|*
name|hi
decl_stmt|;
name|hi
operator|=
name|mips_hi16_list
expr_stmt|;
comment|/* R_MIPS_GOT16 relocations are something of a special case.  We 	 want to install the addend in the same way as for a R_MIPS_HI16 	 relocation (with a rightshift of 16).  However, since GOT16 	 relocations can also be used with global symbols, their howto 	 has a rightshift of 0.  */
if|if
condition|(
name|hi
operator|->
name|rel
operator|.
name|howto
operator|->
name|type
operator|==
name|R_MIPS_GOT16
condition|)
name|hi
operator|->
name|rel
operator|.
name|howto
operator|=
name|MIPS_ELF_RTYPE_TO_HOWTO
argument_list|(
name|abfd
argument_list|,
name|R_MIPS_HI16
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* VALLO is a signed 16-bit number.  Bias it by 0x8000 so that any 	 carry or borrow will induce a change of +1 or -1 in the high part.  */
name|hi
operator|->
name|rel
operator|.
name|addend
operator|+=
operator|(
name|vallo
operator|+
literal|0x8000
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|ret
operator|=
name|_bfd_mips_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
operator|&
name|hi
operator|->
name|rel
argument_list|,
name|symbol
argument_list|,
name|hi
operator|->
name|data
argument_list|,
name|hi
operator|->
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|ret
return|;
name|mips_hi16_list
operator|=
name|hi
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|hi
argument_list|)
expr_stmt|;
block|}
return|return
name|_bfd_mips_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A generic howto special_function.  This calculates and installs the    relocation itself, thus avoiding the oft-discussed problems in    bfd_perform_relocation and bfd_install_relocation.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|_bfd_mips_elf_generic_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_signed_vma
name|val
decl_stmt|;
name|bfd_reloc_status_type
name|status
decl_stmt|;
name|bfd_boolean
name|relocatable
decl_stmt|;
name|relocatable
operator|=
operator|(
name|output_bfd
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|input_section
argument_list|)
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* Build up the field adjustment in VAL.  */
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|relocatable
operator|||
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Either we're calculating the final field value or we have a 	 relocation against a section symbol.  Add in the section's 	 offset or address.  */
name|val
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|val
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|relocatable
condition|)
block|{
comment|/* We're calculating the final field value.  Add in the symbol's value 	 and, if pc-relative, subtract the address of the field itself.  */
name|val
operator|+=
name|symbol
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|howto
operator|->
name|pc_relative
condition|)
block|{
name|val
operator|-=
name|input_section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|val
operator|-=
name|input_section
operator|->
name|output_offset
expr_stmt|;
name|val
operator|-=
name|reloc_entry
operator|->
name|address
expr_stmt|;
block|}
block|}
comment|/* VAL is now the final adjustment.  If we're keeping this relocation      in the output file, and if the relocation uses a separate addend,      we just need to add VAL to that addend.  Otherwise we need to add      VAL to the relocation field itself.  */
if|if
condition|(
name|relocatable
operator|&&
operator|!
name|reloc_entry
operator|->
name|howto
operator|->
name|partial_inplace
condition|)
name|reloc_entry
operator|->
name|addend
operator|+=
name|val
expr_stmt|;
else|else
block|{
name|bfd_byte
modifier|*
name|location
init|=
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
decl_stmt|;
comment|/* Add in the separate addend, if any.  */
name|val
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
comment|/* Add VAL to the relocation field.  */
name|_bfd_mips16_elf_reloc_unshuffle
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
operator|->
name|howto
operator|->
name|type
argument_list|,
name|FALSE
argument_list|,
name|location
argument_list|)
expr_stmt|;
name|status
operator|=
name|_bfd_relocate_contents
argument_list|(
name|reloc_entry
operator|->
name|howto
argument_list|,
name|abfd
argument_list|,
name|val
argument_list|,
name|location
argument_list|)
expr_stmt|;
name|_bfd_mips16_elf_reloc_shuffle
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
operator|->
name|howto
operator|->
name|type
argument_list|,
name|FALSE
argument_list|,
name|location
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|status
return|;
block|}
if|if
condition|(
name|relocatable
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Swap an entry in a .gptab section.  Note that these routines rely    on the equivalence of the two elements of the union.  */
end_comment

begin_function
specifier|static
name|void
name|bfd_mips_elf32_swap_gptab_in
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf32_External_gptab
modifier|*
name|ex
parameter_list|,
name|Elf32_gptab
modifier|*
name|in
parameter_list|)
block|{
name|in
operator|->
name|gt_entry
operator|.
name|gt_g_value
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|gt_entry
operator|.
name|gt_g_value
argument_list|)
expr_stmt|;
name|in
operator|->
name|gt_entry
operator|.
name|gt_bytes
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|gt_entry
operator|.
name|gt_bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bfd_mips_elf32_swap_gptab_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf32_gptab
modifier|*
name|in
parameter_list|,
name|Elf32_External_gptab
modifier|*
name|ex
parameter_list|)
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|gt_entry
operator|.
name|gt_g_value
argument_list|,
name|ex
operator|->
name|gt_entry
operator|.
name|gt_g_value
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|gt_entry
operator|.
name|gt_bytes
argument_list|,
name|ex
operator|->
name|gt_entry
operator|.
name|gt_bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bfd_elf32_swap_compact_rel_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf32_compact_rel
modifier|*
name|in
parameter_list|,
name|Elf32_External_compact_rel
modifier|*
name|ex
parameter_list|)
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|id1
argument_list|,
name|ex
operator|->
name|id1
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|num
argument_list|,
name|ex
operator|->
name|num
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|id2
argument_list|,
name|ex
operator|->
name|id2
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|offset
argument_list|,
name|ex
operator|->
name|offset
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|reserved0
argument_list|,
name|ex
operator|->
name|reserved0
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|reserved1
argument_list|,
name|ex
operator|->
name|reserved1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bfd_elf32_swap_crinfo_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf32_crinfo
modifier|*
name|in
parameter_list|,
name|Elf32_External_crinfo
modifier|*
name|ex
parameter_list|)
block|{
name|unsigned
name|long
name|l
decl_stmt|;
name|l
operator|=
operator|(
operator|(
operator|(
name|in
operator|->
name|ctype
operator|&
name|CRINFO_CTYPE
operator|)
operator|<<
name|CRINFO_CTYPE_SH
operator|)
operator||
operator|(
operator|(
name|in
operator|->
name|rtype
operator|&
name|CRINFO_RTYPE
operator|)
operator|<<
name|CRINFO_RTYPE_SH
operator|)
operator||
operator|(
operator|(
name|in
operator|->
name|dist2to
operator|&
name|CRINFO_DIST2TO
operator|)
operator|<<
name|CRINFO_DIST2TO_SH
operator|)
operator||
operator|(
operator|(
name|in
operator|->
name|relvaddr
operator|&
name|CRINFO_RELVADDR
operator|)
operator|<<
name|CRINFO_RELVADDR_SH
operator|)
operator|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|l
argument_list|,
name|ex
operator|->
name|info
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|konst
argument_list|,
name|ex
operator|->
name|konst
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|vaddr
argument_list|,
name|ex
operator|->
name|vaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A .reginfo section holds a single Elf32_RegInfo structure.  These    routines swap this structure in and out.  They are used outside of    BFD, so they are globally visible.  */
end_comment

begin_function
name|void
name|bfd_mips_elf32_swap_reginfo_in
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf32_External_RegInfo
modifier|*
name|ex
parameter_list|,
name|Elf32_RegInfo
modifier|*
name|in
parameter_list|)
block|{
name|in
operator|->
name|ri_gprmask
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_gprmask
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|0
index|]
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|1
index|]
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|2
index|]
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|3
index|]
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_gp_value
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_gp_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bfd_mips_elf32_swap_reginfo_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf32_RegInfo
modifier|*
name|in
parameter_list|,
name|Elf32_External_RegInfo
modifier|*
name|ex
parameter_list|)
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_gprmask
argument_list|,
name|ex
operator|->
name|ri_gprmask
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_gp_value
argument_list|,
name|ex
operator|->
name|ri_gp_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* In the 64 bit ABI, the .MIPS.options section holds register    information in an Elf64_Reginfo structure.  These routines swap    them in and out.  They are globally visible because they are used    outside of BFD.  These routines are here so that gas can call them    without worrying about whether the 64 bit ABI has been included.  */
end_comment

begin_function
name|void
name|bfd_mips_elf64_swap_reginfo_in
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf64_External_RegInfo
modifier|*
name|ex
parameter_list|,
name|Elf64_Internal_RegInfo
modifier|*
name|in
parameter_list|)
block|{
name|in
operator|->
name|ri_gprmask
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_gprmask
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_pad
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_pad
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|0
index|]
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|1
index|]
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|2
index|]
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_cprmask
index|[
literal|3
index|]
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|in
operator|->
name|ri_gp_value
operator|=
name|H_GET_64
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|ri_gp_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bfd_mips_elf64_swap_reginfo_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf64_Internal_RegInfo
modifier|*
name|in
parameter_list|,
name|Elf64_External_RegInfo
modifier|*
name|ex
parameter_list|)
block|{
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_gprmask
argument_list|,
name|ex
operator|->
name|ri_gprmask
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_pad
argument_list|,
name|ex
operator|->
name|ri_pad
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|,
name|ex
operator|->
name|ri_cprmask
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|H_PUT_64
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|ri_gp_value
argument_list|,
name|ex
operator|->
name|ri_gp_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap in an options header.  */
end_comment

begin_function
name|void
name|bfd_mips_elf_swap_options_in
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf_External_Options
modifier|*
name|ex
parameter_list|,
name|Elf_Internal_Options
modifier|*
name|in
parameter_list|)
block|{
name|in
operator|->
name|kind
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|kind
argument_list|)
expr_stmt|;
name|in
operator|->
name|size
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|size
argument_list|)
expr_stmt|;
name|in
operator|->
name|section
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|section
argument_list|)
expr_stmt|;
name|in
operator|->
name|info
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|ex
operator|->
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap out an options header.  */
end_comment

begin_function
name|void
name|bfd_mips_elf_swap_options_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf_Internal_Options
modifier|*
name|in
parameter_list|,
name|Elf_External_Options
modifier|*
name|ex
parameter_list|)
block|{
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|kind
argument_list|,
name|ex
operator|->
name|kind
argument_list|)
expr_stmt|;
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|size
argument_list|,
name|ex
operator|->
name|size
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|section
argument_list|,
name|ex
operator|->
name|section
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|in
operator|->
name|info
argument_list|,
name|ex
operator|->
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function is called via qsort() to sort the dynamic relocation    entries by increasing r_symndx value.  */
end_comment

begin_function
specifier|static
name|int
name|sort_dynamic_relocs
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|Elf_Internal_Rela
name|int_reloc1
decl_stmt|;
name|Elf_Internal_Rela
name|int_reloc2
decl_stmt|;
name|int
name|diff
decl_stmt|;
name|bfd_elf32_swap_reloc_in
argument_list|(
name|reldyn_sorting_bfd
argument_list|,
name|arg1
argument_list|,
operator|&
name|int_reloc1
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_in
argument_list|(
name|reldyn_sorting_bfd
argument_list|,
name|arg2
argument_list|,
operator|&
name|int_reloc2
argument_list|)
expr_stmt|;
name|diff
operator|=
name|ELF32_R_SYM
argument_list|(
name|int_reloc1
operator|.
name|r_info
argument_list|)
operator|-
name|ELF32_R_SYM
argument_list|(
name|int_reloc2
operator|.
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|!=
literal|0
condition|)
return|return
name|diff
return|;
if|if
condition|(
name|int_reloc1
operator|.
name|r_offset
operator|<
name|int_reloc2
operator|.
name|r_offset
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|int_reloc1
operator|.
name|r_offset
operator|>
name|int_reloc2
operator|.
name|r_offset
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Like sort_dynamic_relocs, but used for elf64 relocations.  */
end_comment

begin_function
specifier|static
name|int
name|sort_dynamic_relocs_64
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BFD64
name|Elf_Internal_Rela
name|int_reloc1
index|[
literal|3
index|]
decl_stmt|;
name|Elf_Internal_Rela
name|int_reloc2
index|[
literal|3
index|]
decl_stmt|;
operator|(
operator|*
name|get_elf_backend_data
argument_list|(
name|reldyn_sorting_bfd
argument_list|)
operator|->
name|s
operator|->
name|swap_reloc_in
operator|)
operator|(
name|reldyn_sorting_bfd
operator|,
name|arg1
operator|,
name|int_reloc1
operator|)
expr_stmt|;
operator|(
operator|*
name|get_elf_backend_data
argument_list|(
name|reldyn_sorting_bfd
argument_list|)
operator|->
name|s
operator|->
name|swap_reloc_in
operator|)
operator|(
name|reldyn_sorting_bfd
operator|,
name|arg2
operator|,
name|int_reloc2
operator|)
expr_stmt|;
if|if
condition|(
name|ELF64_R_SYM
argument_list|(
name|int_reloc1
index|[
literal|0
index|]
operator|.
name|r_info
argument_list|)
operator|<
name|ELF64_R_SYM
argument_list|(
name|int_reloc2
index|[
literal|0
index|]
operator|.
name|r_info
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ELF64_R_SYM
argument_list|(
name|int_reloc1
index|[
literal|0
index|]
operator|.
name|r_info
argument_list|)
operator|>
name|ELF64_R_SYM
argument_list|(
name|int_reloc2
index|[
literal|0
index|]
operator|.
name|r_info
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|int_reloc1
index|[
literal|0
index|]
operator|.
name|r_offset
operator|<
name|int_reloc2
index|[
literal|0
index|]
operator|.
name|r_offset
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|int_reloc1
index|[
literal|0
index|]
operator|.
name|r_offset
operator|>
name|int_reloc2
index|[
literal|0
index|]
operator|.
name|r_offset
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This routine is used to write out ECOFF debugging external symbol    information.  It is called via mips_elf_link_hash_traverse.  The    ECOFF external symbol information must match the ELF external    symbol information.  Unfortunately, at this point we don't know    whether a symbol is required by reloc information, so the two    tables may wind up being different.  We must sort out the external    symbol information before we can set the final size of the .mdebug    section, and we must set the size of the .mdebug section before we    can relocate any sections, and we can't know which symbols are    required by relocation until we relocate the sections.    Fortunately, it is relatively unlikely that any symbol will be    stripped but required by a reloc.  In particular, it can not happen    when generating a final executable.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_output_extsym
parameter_list|(
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|extsym_info
modifier|*
name|einfo
init|=
name|data
decl_stmt|;
name|bfd_boolean
name|strip
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|,
modifier|*
name|output_section
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|indx
operator|==
operator|-
literal|2
condition|)
name|strip
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|def_dynamic
operator|||
name|h
operator|->
name|root
operator|.
name|ref_dynamic
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
operator|)
operator|&&
operator|!
name|h
operator|->
name|root
operator|.
name|def_regular
operator|&&
operator|!
name|h
operator|->
name|root
operator|.
name|ref_regular
condition|)
name|strip
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|einfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_all
operator|||
operator|(
name|einfo
operator|->
name|info
operator|->
name|strip
operator|==
name|strip_some
operator|&&
name|bfd_hash_lookup
argument_list|(
name|einfo
operator|->
name|info
operator|->
name|keep_hash
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|strip
operator|=
name|TRUE
expr_stmt|;
else|else
name|strip
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|strip
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|ifd
operator|==
operator|-
literal|2
condition|)
block|{
name|h
operator|->
name|esym
operator|.
name|jmptbl
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|cobol_main
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|weakext
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|ifd
operator|=
name|ifdNil
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stGlobal
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Use undefined class.  Also, set class and type for some              special symbols.  */
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|mips_elf_dynsym_rtproc_names
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
name|mips_elf_dynsym_rtproc_names
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scData
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stLabel
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|mips_elf_dynsym_rtproc_names
index|[
literal|2
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stLabel
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|mips_elf_hash_table
argument_list|(
name|einfo
operator|->
name|info
argument_list|)
operator|->
name|procedure_count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_gp_disp"
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|NEWABI_P
argument_list|(
name|einfo
operator|->
name|abfd
argument_list|)
condition|)
block|{
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stLabel
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|elf_gp
argument_list|(
name|einfo
operator|->
name|abfd
argument_list|)
expr_stmt|;
block|}
else|else
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scUndefined
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|output_section
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
comment|/* When making a shared library and symbol h is the one from 	     the another shared library, OUTPUT_SECTION may be null.  */
if|if
condition|(
name|output_section
operator|==
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scUndefined
expr_stmt|;
else|else
block|{
name|name
operator|=
name|bfd_section_name
argument_list|(
name|output_section
operator|->
name|owner
argument_list|,
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scText
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rodata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rdata"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scRData
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scBss
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSBss
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".init"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scInit
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".fini"
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scFini
expr_stmt|;
else|else
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scAbs
expr_stmt|;
block|}
block|}
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|index
operator|=
name|indexNil
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_common
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|size
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|==
name|scCommon
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scBss
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|==
name|scSCommon
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|scSBss
expr_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|output_section
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|output_section
operator|!=
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
else|else
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|needs_plt
condition|)
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|hd
init|=
name|h
decl_stmt|;
name|bfd_boolean
name|no_fn_stub
init|=
name|h
operator|->
name|no_fn_stub
decl_stmt|;
while|while
condition|(
name|hd
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
block|{
name|hd
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|no_fn_stub
operator|=
name|no_fn_stub
operator|||
name|hd
operator|->
name|no_fn_stub
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|no_fn_stub
condition|)
block|{
comment|/* Set type and value for a symbol with a function stub.  */
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stProc
expr_stmt|;
name|sec
operator|=
name|hd
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|output_section
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|output_section
operator|!=
name|NULL
condition|)
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
operator|(
name|hd
operator|->
name|root
operator|.
name|plt
operator|.
name|offset
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
else|else
name|h
operator|->
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|bfd_ecoff_debug_one_external
argument_list|(
name|einfo
operator|->
name|abfd
argument_list|,
name|einfo
operator|->
name|debug
argument_list|,
name|einfo
operator|->
name|swap
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
operator|&
name|h
operator|->
name|esym
argument_list|)
condition|)
block|{
name|einfo
operator|->
name|failed
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* A comparison routine used to sort .gptab entries.  */
end_comment

begin_function
specifier|static
name|int
name|gptab_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|Elf32_gptab
modifier|*
name|a1
init|=
name|p1
decl_stmt|;
specifier|const
name|Elf32_gptab
modifier|*
name|a2
init|=
name|p2
decl_stmt|;
return|return
name|a1
operator|->
name|gt_entry
operator|.
name|gt_g_value
operator|-
name|a2
operator|->
name|gt_entry
operator|.
name|gt_g_value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions to manage the got entry hash table.  */
end_comment

begin_comment
comment|/* Use all 64 bits of a bfd_vma for the computation of a 32-bit    hash number.  */
end_comment

begin_function
specifier|static
name|INLINE
name|hashval_t
name|mips_elf_hash_bfd_vma
parameter_list|(
name|bfd_vma
name|addr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BFD64
return|return
name|addr
operator|+
operator|(
name|addr
operator|>>
literal|32
operator|)
return|;
else|#
directive|else
return|return
name|addr
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* got_entries only match if they're identical, except for gotidx, so    use all fields to compute the hash, and compare the appropriate    union members.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|mips_elf_got_entry_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|entry_
parameter_list|)
block|{
specifier|const
name|struct
name|mips_got_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
name|entry_
decl_stmt|;
return|return
name|entry
operator|->
name|symndx
operator|+
operator|(
operator|(
name|entry
operator|->
name|tls_type
operator|&
name|GOT_TLS_LDM
operator|)
operator|<<
literal|17
operator|)
operator|+
operator|(
operator|!
name|entry
operator|->
name|abfd
condition|?
name|mips_elf_hash_bfd_vma
argument_list|(
name|entry
operator|->
name|d
operator|.
name|address
argument_list|)
else|:
name|entry
operator|->
name|abfd
operator|->
name|id
operator|+
operator|(
name|entry
operator|->
name|symndx
operator|>=
literal|0
condition|?
name|mips_elf_hash_bfd_vma
argument_list|(
name|entry
operator|->
name|d
operator|.
name|addend
argument_list|)
else|:
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|hash
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mips_elf_got_entry_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|entry1
parameter_list|,
specifier|const
name|void
modifier|*
name|entry2
parameter_list|)
block|{
specifier|const
name|struct
name|mips_got_entry
modifier|*
name|e1
init|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
name|entry1
decl_stmt|;
specifier|const
name|struct
name|mips_got_entry
modifier|*
name|e2
init|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
name|entry2
decl_stmt|;
comment|/* An LDM entry can only match another LDM entry.  */
if|if
condition|(
operator|(
name|e1
operator|->
name|tls_type
operator|^
name|e2
operator|->
name|tls_type
operator|)
operator|&
name|GOT_TLS_LDM
condition|)
return|return
literal|0
return|;
return|return
name|e1
operator|->
name|abfd
operator|==
name|e2
operator|->
name|abfd
operator|&&
name|e1
operator|->
name|symndx
operator|==
name|e2
operator|->
name|symndx
operator|&&
operator|(
operator|!
name|e1
operator|->
name|abfd
condition|?
name|e1
operator|->
name|d
operator|.
name|address
operator|==
name|e2
operator|->
name|d
operator|.
name|address
else|:
name|e1
operator|->
name|symndx
operator|>=
literal|0
condition|?
name|e1
operator|->
name|d
operator|.
name|addend
operator|==
name|e2
operator|->
name|d
operator|.
name|addend
else|:
name|e1
operator|->
name|d
operator|.
name|h
operator|==
name|e2
operator|->
name|d
operator|.
name|h
operator|)
return|;
block|}
end_function

begin_comment
comment|/* multi_got_entries are still a match in the case of global objects,    even if the input bfd in which they're referenced differs, so the    hash computation and compare functions are adjusted    accordingly.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|mips_elf_multi_got_entry_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|entry_
parameter_list|)
block|{
specifier|const
name|struct
name|mips_got_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
name|entry_
decl_stmt|;
return|return
name|entry
operator|->
name|symndx
operator|+
operator|(
operator|!
name|entry
operator|->
name|abfd
condition|?
name|mips_elf_hash_bfd_vma
argument_list|(
name|entry
operator|->
name|d
operator|.
name|address
argument_list|)
else|:
name|entry
operator|->
name|symndx
operator|>=
literal|0
condition|?
operator|(
operator|(
name|entry
operator|->
name|tls_type
operator|&
name|GOT_TLS_LDM
operator|)
condition|?
operator|(
name|GOT_TLS_LDM
operator|<<
literal|17
operator|)
else|:
operator|(
name|entry
operator|->
name|abfd
operator|->
name|id
operator|+
name|mips_elf_hash_bfd_vma
argument_list|(
name|entry
operator|->
name|d
operator|.
name|addend
argument_list|)
operator|)
operator|)
else|:
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|hash
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mips_elf_multi_got_entry_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|entry1
parameter_list|,
specifier|const
name|void
modifier|*
name|entry2
parameter_list|)
block|{
specifier|const
name|struct
name|mips_got_entry
modifier|*
name|e1
init|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
name|entry1
decl_stmt|;
specifier|const
name|struct
name|mips_got_entry
modifier|*
name|e2
init|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
name|entry2
decl_stmt|;
comment|/* Any two LDM entries match.  */
if|if
condition|(
name|e1
operator|->
name|tls_type
operator|&
name|e2
operator|->
name|tls_type
operator|&
name|GOT_TLS_LDM
condition|)
return|return
literal|1
return|;
comment|/* Nothing else matches an LDM entry.  */
if|if
condition|(
operator|(
name|e1
operator|->
name|tls_type
operator|^
name|e2
operator|->
name|tls_type
operator|)
operator|&
name|GOT_TLS_LDM
condition|)
return|return
literal|0
return|;
return|return
name|e1
operator|->
name|symndx
operator|==
name|e2
operator|->
name|symndx
operator|&&
operator|(
name|e1
operator|->
name|symndx
operator|>=
literal|0
condition|?
name|e1
operator|->
name|abfd
operator|==
name|e2
operator|->
name|abfd
operator|&&
name|e1
operator|->
name|d
operator|.
name|addend
operator|==
name|e2
operator|->
name|d
operator|.
name|addend
else|:
name|e1
operator|->
name|abfd
operator|==
name|NULL
operator|||
name|e2
operator|->
name|abfd
operator|==
name|NULL
condition|?
name|e1
operator|->
name|abfd
operator|==
name|e2
operator|->
name|abfd
operator|&&
name|e1
operator|->
name|d
operator|.
name|address
operator|==
name|e2
operator|->
name|d
operator|.
name|address
else|:
name|e1
operator|->
name|d
operator|.
name|h
operator|==
name|e2
operator|->
name|d
operator|.
name|h
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the dynamic relocation section.  If it doesn't exist, try to    create a new it if CREATE_P, otherwise return NULL.  Also return NULL    if creation fails.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|mips_elf_rel_dyn_section
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_boolean
name|create_p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dname
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|dname
operator|=
name|MIPS_ELF_REL_DYN_NAME
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|&&
name|create_p
condition|)
block|{
name|sreloc
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
name|dname
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
name|MIPS_ELF_LOG_FILE_ALIGN
argument_list|(
name|dynobj
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|sreloc
return|;
block|}
end_function

begin_comment
comment|/* Returns the GOT section for ABFD.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|mips_elf_got_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|maybe_excluded
parameter_list|)
block|{
name|asection
modifier|*
name|sgot
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
decl_stmt|;
if|if
condition|(
name|sgot
operator|==
name|NULL
operator|||
operator|(
operator|!
name|maybe_excluded
operator|&&
operator|(
name|sgot
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|NULL
return|;
return|return
name|sgot
return|;
block|}
end_function

begin_comment
comment|/* Returns the GOT information associated with the link indicated by    INFO.  If SGOTP is non-NULL, it is filled in with the GOT    section.  */
end_comment

begin_function
specifier|static
name|struct
name|mips_got_info
modifier|*
name|mips_elf_got_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
modifier|*
name|sgotp
parameter_list|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|sgot
operator|=
name|mips_elf_got_section
argument_list|(
name|abfd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|mips_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
name|mips_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|u
operator|.
name|got_info
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgotp
condition|)
operator|*
name|sgotp
operator|=
operator|(
name|sgot
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
operator|==
literal|0
condition|?
name|sgot
else|:
name|NULL
expr_stmt|;
return|return
name|g
return|;
block|}
end_function

begin_comment
comment|/* Count the number of relocations needed for a TLS GOT entry, with    access types from TLS_TYPE, and symbol H (or a local symbol if H    is NULL).  */
end_comment

begin_function
specifier|static
name|int
name|mips_tls_got_relocs
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|unsigned
name|char
name|tls_type
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
name|int
name|indx
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|bfd_boolean
name|need_relocs
init|=
name|FALSE
decl_stmt|;
name|bfd_boolean
name|dyn
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
decl_stmt|;
if|if
condition|(
name|h
operator|&&
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
operator|->
name|shared
argument_list|,
name|h
argument_list|)
operator|&&
operator|(
operator|!
name|info
operator|->
name|shared
operator|||
operator|!
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|)
condition|)
name|indx
operator|=
name|h
operator|->
name|dynindx
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|||
name|indx
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
condition|)
name|need_relocs
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|need_relocs
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|tls_type
operator|&
name|GOT_TLS_GD
condition|)
block|{
name|ret
operator|++
expr_stmt|;
if|if
condition|(
name|indx
operator|!=
literal|0
condition|)
name|ret
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tls_type
operator|&
name|GOT_TLS_IE
condition|)
name|ret
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|tls_type
operator|&
name|GOT_TLS_LDM
operator|)
operator|&&
name|info
operator|->
name|shared
condition|)
name|ret
operator|++
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Count the number of TLS relocations required for the GOT entry in    ARG1, if it describes a local symbol.  */
end_comment

begin_function
specifier|static
name|int
name|mips_elf_count_local_tls_relocs
parameter_list|(
name|void
modifier|*
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|struct
name|mips_got_entry
modifier|*
name|entry
init|=
operator|*
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|mips_elf_count_tls_arg
modifier|*
name|arg
init|=
name|arg2
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|abfd
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
condition|)
name|arg
operator|->
name|needed
operator|+=
name|mips_tls_got_relocs
argument_list|(
name|arg
operator|->
name|info
argument_list|,
name|entry
operator|->
name|tls_type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Count the number of TLS GOT entries required for the global (or    forced-local) symbol in ARG1.  */
end_comment

begin_function
specifier|static
name|int
name|mips_elf_count_global_tls_entries
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|hm
init|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|mips_elf_count_tls_arg
modifier|*
name|arg
init|=
name|arg2
decl_stmt|;
if|if
condition|(
name|hm
operator|->
name|tls_type
operator|&
name|GOT_TLS_GD
condition|)
name|arg
operator|->
name|needed
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|hm
operator|->
name|tls_type
operator|&
name|GOT_TLS_IE
condition|)
name|arg
operator|->
name|needed
operator|+=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Count the number of TLS relocations required for the global (or    forced-local) symbol in ARG1.  */
end_comment

begin_function
specifier|static
name|int
name|mips_elf_count_global_tls_relocs
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|hm
init|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|mips_elf_count_tls_arg
modifier|*
name|arg
init|=
name|arg2
decl_stmt|;
name|arg
operator|->
name|needed
operator|+=
name|mips_tls_got_relocs
argument_list|(
name|arg
operator|->
name|info
argument_list|,
name|hm
operator|->
name|tls_type
argument_list|,
operator|&
name|hm
operator|->
name|root
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Output a simple dynamic relocation into SRELOC.  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf_output_dynamic_relocation
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|asection
modifier|*
name|sreloc
parameter_list|,
name|unsigned
name|long
name|indx
parameter_list|,
name|int
name|r_type
parameter_list|,
name|bfd_vma
name|offset
parameter_list|)
block|{
name|Elf_Internal_Rela
name|rel
index|[
literal|3
index|]
decl_stmt|;
name|memset
argument_list|(
name|rel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rel
argument_list|)
argument_list|)
expr_stmt|;
name|rel
index|[
literal|0
index|]
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|output_bfd
argument_list|,
name|indx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|rel
index|[
literal|0
index|]
operator|.
name|r_offset
operator|=
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|=
name|rel
index|[
literal|2
index|]
operator|.
name|r_offset
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
operator|(
operator|*
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|s
operator|->
name|swap_reloc_out
operator|)
operator|(
name|output_bfd
operator|,
operator|&
name|rel
index|[
literal|0
index|]
operator|,
operator|(
name|sreloc
operator|->
name|contents
operator|+
name|sreloc
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_Mips_External_Rel
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
else|else
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
index|[
literal|0
index|]
argument_list|,
operator|(
name|sreloc
operator|->
name|contents
operator|+
name|sreloc
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
operator|)
argument_list|)
expr_stmt|;
operator|++
name|sreloc
operator|->
name|reloc_count
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize a set of TLS GOT entries for one symbol.  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf_initialize_tls_slots
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_vma
name|got_offset
parameter_list|,
name|unsigned
name|char
modifier|*
name|tls_type_p
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|bfd_vma
name|value
parameter_list|)
block|{
name|int
name|indx
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|,
modifier|*
name|sgot
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|,
name|offset2
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|bfd_boolean
name|need_relocs
init|=
name|FALSE
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sgot
operator|=
name|mips_elf_got_section
argument_list|(
name|dynobj
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|indx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|bfd_boolean
name|dyn
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
decl_stmt|;
if|if
condition|(
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
operator|->
name|shared
argument_list|,
operator|&
name|h
operator|->
name|root
argument_list|)
operator|&&
operator|(
operator|!
name|info
operator|->
name|shared
operator|||
operator|!
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
operator|&
name|h
operator|->
name|root
argument_list|)
operator|)
condition|)
name|indx
operator|=
name|h
operator|->
name|root
operator|.
name|dynindx
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|tls_type_p
operator|&
name|GOT_TLS_DONE
condition|)
return|return;
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|||
name|indx
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|root
operator|.
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
condition|)
name|need_relocs
operator|=
name|TRUE
expr_stmt|;
comment|/* MINUS_ONE means the symbol is not defined in this object.  It may not      be defined at all; assume that the value doesn't matter in that      case.  Otherwise complain if we would use the value.  */
name|BFD_ASSERT
argument_list|(
name|value
operator|!=
name|MINUS_ONE
operator|||
operator|(
name|indx
operator|!=
literal|0
operator|&&
name|need_relocs
operator|)
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
argument_list|)
expr_stmt|;
comment|/* Emit necessary relocations.  */
name|sreloc
operator|=
name|mips_elf_rel_dyn_section
argument_list|(
name|info
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* General Dynamic.  */
if|if
condition|(
operator|*
name|tls_type_p
operator|&
name|GOT_TLS_GD
condition|)
block|{
name|offset
operator|=
name|got_offset
expr_stmt|;
name|offset2
operator|=
name|offset
operator|+
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_relocs
condition|)
block|{
name|mips_elf_output_dynamic_relocation
argument_list|(
name|abfd
argument_list|,
name|sreloc
argument_list|,
name|indx
argument_list|,
name|ABI_64_P
argument_list|(
name|abfd
argument_list|)
condition|?
name|R_MIPS_TLS_DTPMOD64
else|:
name|R_MIPS_TLS_DTPMOD32
argument_list|,
name|sgot
operator|->
name|output_offset
operator|+
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|indx
condition|)
name|mips_elf_output_dynamic_relocation
argument_list|(
name|abfd
argument_list|,
name|sreloc
argument_list|,
name|indx
argument_list|,
name|ABI_64_P
argument_list|(
name|abfd
argument_list|)
condition|?
name|R_MIPS_TLS_DTPREL64
else|:
name|R_MIPS_TLS_DTPREL32
argument_list|,
name|sgot
operator|->
name|output_offset
operator|+
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|offset2
argument_list|)
expr_stmt|;
else|else
name|MIPS_ELF_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|value
operator|-
name|dtprel_base
argument_list|(
name|info
argument_list|)
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|offset2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MIPS_ELF_PUT_WORD
argument_list|(
name|abfd
argument_list|,
literal|1
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
name|MIPS_ELF_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|value
operator|-
name|dtprel_base
argument_list|(
name|info
argument_list|)
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|offset2
argument_list|)
expr_stmt|;
block|}
name|got_offset
operator|+=
literal|2
operator|*
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
comment|/* Initial Exec model.  */
if|if
condition|(
operator|*
name|tls_type_p
operator|&
name|GOT_TLS_IE
condition|)
block|{
name|offset
operator|=
name|got_offset
expr_stmt|;
if|if
condition|(
name|need_relocs
condition|)
block|{
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
name|MIPS_ELF_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|value
operator|-
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|->
name|vma
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
else|else
name|MIPS_ELF_PUT_WORD
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
name|mips_elf_output_dynamic_relocation
argument_list|(
name|abfd
argument_list|,
name|sreloc
argument_list|,
name|indx
argument_list|,
name|ABI_64_P
argument_list|(
name|abfd
argument_list|)
condition|?
name|R_MIPS_TLS_TPREL64
else|:
name|R_MIPS_TLS_TPREL32
argument_list|,
name|sgot
operator|->
name|output_offset
operator|+
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
name|MIPS_ELF_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|value
operator|-
name|tprel_base
argument_list|(
name|info
argument_list|)
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|tls_type_p
operator|&
name|GOT_TLS_LDM
condition|)
block|{
comment|/* The initial offset is zero, and the LD offsets will include the 	 bias by DTP_OFFSET.  */
name|MIPS_ELF_PUT_WORD
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|got_offset
operator|+
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
name|MIPS_ELF_PUT_WORD
argument_list|(
name|abfd
argument_list|,
literal|1
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|got_offset
argument_list|)
expr_stmt|;
else|else
name|mips_elf_output_dynamic_relocation
argument_list|(
name|abfd
argument_list|,
name|sreloc
argument_list|,
name|indx
argument_list|,
name|ABI_64_P
argument_list|(
name|abfd
argument_list|)
condition|?
name|R_MIPS_TLS_DTPMOD64
else|:
name|R_MIPS_TLS_DTPMOD32
argument_list|,
name|sgot
operator|->
name|output_offset
operator|+
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|got_offset
argument_list|)
expr_stmt|;
block|}
operator|*
name|tls_type_p
operator||=
name|GOT_TLS_DONE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the GOT index to use for a relocation of type R_TYPE against    a symbol accessed using TLS_TYPE models.  The GOT entries for this    symbol in this GOT start at GOT_INDEX.  This function initializes the    GOT entries and corresponding relocations.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_tls_got_index
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_vma
name|got_index
parameter_list|,
name|unsigned
name|char
modifier|*
name|tls_type
parameter_list|,
name|int
name|r_type
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|bfd_vma
name|symbol
parameter_list|)
block|{
name|BFD_ASSERT
argument_list|(
name|r_type
operator|==
name|R_MIPS_TLS_GOTTPREL
operator|||
name|r_type
operator|==
name|R_MIPS_TLS_GD
operator|||
name|r_type
operator|==
name|R_MIPS_TLS_LDM
argument_list|)
expr_stmt|;
name|mips_elf_initialize_tls_slots
argument_list|(
name|abfd
argument_list|,
name|got_index
argument_list|,
name|tls_type
argument_list|,
name|info
argument_list|,
name|h
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_TLS_GOTTPREL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|*
name|tls_type
operator|&
name|GOT_TLS_IE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tls_type
operator|&
name|GOT_TLS_GD
condition|)
return|return
name|got_index
operator|+
literal|2
operator|*
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
return|;
else|else
return|return
name|got_index
return|;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_TLS_GD
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|*
name|tls_type
operator|&
name|GOT_TLS_GD
argument_list|)
expr_stmt|;
return|return
name|got_index
return|;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_TLS_LDM
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|*
name|tls_type
operator|&
name|GOT_TLS_LDM
argument_list|)
expr_stmt|;
return|return
name|got_index
return|;
block|}
return|return
name|got_index
return|;
block|}
end_function

begin_comment
comment|/* Return the offset from _GLOBAL_OFFSET_TABLE_ of the .got.plt entry    for global symbol H.  .got.plt comes before the GOT, so the offset    will be negative.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_gotplt_index
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
name|bfd_vma
name|plt_index
decl_stmt|,
name|got_address
decl_stmt|,
name|got_value
decl_stmt|;
name|struct
name|mips_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Calculate the index of the symbol's PLT entry.  */
name|plt_index
operator|=
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|-
name|htab
operator|->
name|plt_header_size
operator|)
operator|/
name|htab
operator|->
name|plt_entry_size
expr_stmt|;
comment|/* Calculate the address of the associated .got.plt entry.  */
name|got_address
operator|=
operator|(
name|htab
operator|->
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgotplt
operator|->
name|output_offset
operator|+
name|plt_index
operator|*
literal|4
operator|)
expr_stmt|;
comment|/* Calculate the value of _GLOBAL_OFFSET_TABLE_.  */
name|got_value
operator|=
operator|(
name|htab
operator|->
name|root
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|root
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|root
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|)
expr_stmt|;
return|return
name|got_address
operator|-
name|got_value
return|;
block|}
end_function

begin_comment
comment|/* Return the GOT offset for address VALUE.   If there is not yet a GOT    entry for this value, create one.  If R_SYMNDX refers to a TLS symbol,    create a TLS GOT entry instead.  Return -1 if no satisfactory GOT    offset can be found.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_local_got_index
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_vma
name|value
parameter_list|,
name|unsigned
name|long
name|r_symndx
parameter_list|,
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|int
name|r_type
parameter_list|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|struct
name|mips_got_entry
modifier|*
name|entry
decl_stmt|;
name|g
operator|=
name|mips_elf_got_info
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
name|entry
operator|=
name|mips_elf_create_local_got_entry
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|ibfd
argument_list|,
name|g
argument_list|,
name|sgot
argument_list|,
name|value
argument_list|,
name|r_symndx
argument_list|,
name|h
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
return|return
name|MINUS_ONE
return|;
if|if
condition|(
name|TLS_RELOC_P
argument_list|(
name|r_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
name|g
operator|->
name|next
operator|==
name|NULL
condition|)
comment|/* A type (3) entry in the single-GOT case.  We use the symbol's 	   hash table entry to track the index.  */
return|return
name|mips_tls_got_index
argument_list|(
name|abfd
argument_list|,
name|h
operator|->
name|tls_got_offset
argument_list|,
operator|&
name|h
operator|->
name|tls_type
argument_list|,
name|r_type
argument_list|,
name|info
argument_list|,
name|h
argument_list|,
name|value
argument_list|)
return|;
else|else
return|return
name|mips_tls_got_index
argument_list|(
name|abfd
argument_list|,
name|entry
operator|->
name|gotidx
argument_list|,
operator|&
name|entry
operator|->
name|tls_type
argument_list|,
name|r_type
argument_list|,
name|info
argument_list|,
name|h
argument_list|,
name|value
argument_list|)
return|;
block|}
else|else
return|return
name|entry
operator|->
name|gotidx
return|;
block|}
end_function

begin_comment
comment|/* Returns the GOT index for the global symbol indicated by H.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_global_got_index
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|int
name|r_type
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd_vma
name|index
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|,
modifier|*
name|gg
decl_stmt|;
name|long
name|global_got_dynindx
init|=
literal|0
decl_stmt|;
name|gg
operator|=
name|g
operator|=
name|mips_elf_got_info
argument_list|(
name|abfd
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|bfd2got
operator|&&
name|ibfd
condition|)
block|{
name|struct
name|mips_got_entry
name|e
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|g
operator|=
name|mips_elf_got_for_ibfd
argument_list|(
name|g
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|next
operator|!=
name|gg
operator|||
name|TLS_RELOC_P
argument_list|(
name|r_type
argument_list|)
condition|)
block|{
name|e
operator|.
name|abfd
operator|=
name|ibfd
expr_stmt|;
name|e
operator|.
name|symndx
operator|=
operator|-
literal|1
expr_stmt|;
name|e
operator|.
name|d
operator|.
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|e
operator|.
name|tls_type
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|htab_find
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|p
operator|->
name|gotidx
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TLS_RELOC_P
argument_list|(
name|r_type
argument_list|)
condition|)
block|{
name|bfd_vma
name|value
init|=
name|MINUS_ONE
decl_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
condition|)
name|value
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
return|return
name|mips_tls_got_index
argument_list|(
name|abfd
argument_list|,
name|p
operator|->
name|gotidx
argument_list|,
operator|&
name|p
operator|->
name|tls_type
argument_list|,
name|r_type
argument_list|,
name|info
argument_list|,
name|e
operator|.
name|d
operator|.
name|h
argument_list|,
name|value
argument_list|)
return|;
block|}
else|else
return|return
name|p
operator|->
name|gotidx
return|;
block|}
block|}
if|if
condition|(
name|gg
operator|->
name|global_gotsym
operator|!=
name|NULL
condition|)
name|global_got_dynindx
operator|=
name|gg
operator|->
name|global_gotsym
operator|->
name|dynindx
expr_stmt|;
if|if
condition|(
name|TLS_RELOC_P
argument_list|(
name|r_type
argument_list|)
condition|)
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|hm
init|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
decl_stmt|;
name|bfd_vma
name|value
init|=
name|MINUS_ONE
decl_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
condition|)
name|value
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|index
operator|=
name|mips_tls_got_index
argument_list|(
name|abfd
argument_list|,
name|hm
operator|->
name|tls_got_offset
argument_list|,
operator|&
name|hm
operator|->
name|tls_type
argument_list|,
name|r_type
argument_list|,
name|info
argument_list|,
name|hm
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Once we determine the global GOT entry with the lowest dynamic 	 symbol table index, we must put all dynamic symbols with greater 	 indices into the GOT.  That makes it easy to calculate the GOT 	 offset.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|>=
name|global_got_dynindx
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
operator|(
name|h
operator|->
name|dynindx
operator|-
name|global_got_dynindx
operator|+
name|g
operator|->
name|local_gotno
operator|)
operator|*
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
operator|)
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|index
operator|<
name|sgot
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
name|index
return|;
block|}
end_function

begin_comment
comment|/* Find a GOT page entry that points to within 32KB of VALUE.  These    entries are supposed to be placed at small offsets in the GOT, i.e.,    within 32KB of GP.  Return the index of the GOT entry, or -1 if no    entry could be created.  If OFFSETP is nonnull, use it to return the    offset of the GOT entry from VALUE.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_got_page
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_vma
name|value
parameter_list|,
name|bfd_vma
modifier|*
name|offsetp
parameter_list|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|bfd_vma
name|page
decl_stmt|,
name|index
decl_stmt|;
name|struct
name|mips_got_entry
modifier|*
name|entry
decl_stmt|;
name|g
operator|=
name|mips_elf_got_info
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
name|page
operator|=
operator|(
name|value
operator|+
literal|0x8000
operator|)
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0xffff
expr_stmt|;
name|entry
operator|=
name|mips_elf_create_local_got_entry
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|ibfd
argument_list|,
name|g
argument_list|,
name|sgot
argument_list|,
name|page
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|R_MIPS_GOT_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
return|return
name|MINUS_ONE
return|;
name|index
operator|=
name|entry
operator|->
name|gotidx
expr_stmt|;
if|if
condition|(
name|offsetp
condition|)
operator|*
name|offsetp
operator|=
name|value
operator|-
name|entry
operator|->
name|d
operator|.
name|address
expr_stmt|;
return|return
name|index
return|;
block|}
end_function

begin_comment
comment|/* Find a local GOT entry for an R_MIPS_GOT16 relocation against VALUE.    EXTERNAL is true if the relocation was against a global symbol    that has been forced local.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_got16_entry
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_vma
name|value
parameter_list|,
name|bfd_boolean
name|external
parameter_list|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|struct
name|mips_got_entry
modifier|*
name|entry
decl_stmt|;
comment|/* GOT16 relocations against local symbols are followed by a LO16      relocation; those against global symbols are not.  Thus if the      symbol was originally local, the GOT16 relocation should load the      equivalent of %hi(VALUE), otherwise it should load VALUE itself.  */
if|if
condition|(
operator|!
name|external
condition|)
name|value
operator|=
name|mips_elf_high
argument_list|(
name|value
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|g
operator|=
name|mips_elf_got_info
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
name|entry
operator|=
name|mips_elf_create_local_got_entry
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|ibfd
argument_list|,
name|g
argument_list|,
name|sgot
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|R_MIPS_GOT16
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
return|return
name|entry
operator|->
name|gotidx
return|;
else|else
return|return
name|MINUS_ONE
return|;
block|}
end_function

begin_comment
comment|/* Returns the offset for the entry at the INDEXth position    in the GOT.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_got_offset_from_index
parameter_list|(
name|bfd
modifier|*
name|dynobj
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|bfd_vma
name|index
parameter_list|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|g
operator|=
name|mips_elf_got_info
argument_list|(
name|dynobj
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
operator|+
name|mips_elf_adjust_gp
argument_list|(
name|output_bfd
argument_list|,
name|g
argument_list|,
name|input_bfd
argument_list|)
expr_stmt|;
return|return
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|index
operator|-
name|gp
return|;
block|}
end_function

begin_comment
comment|/* Create and return a local GOT entry for VALUE, which was calculated    from a symbol belonging to INPUT_SECTON.  Return NULL if it could not    be created.  If R_SYMNDX refers to a TLS symbol, create a TLS entry    instead.  */
end_comment

begin_function
specifier|static
name|struct
name|mips_got_entry
modifier|*
name|mips_elf_create_local_got_entry
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|struct
name|mips_got_info
modifier|*
name|gg
parameter_list|,
name|asection
modifier|*
name|sgot
parameter_list|,
name|bfd_vma
name|value
parameter_list|,
name|unsigned
name|long
name|r_symndx
parameter_list|,
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|int
name|r_type
parameter_list|)
block|{
name|struct
name|mips_got_entry
name|entry
decl_stmt|,
modifier|*
modifier|*
name|loc
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|struct
name|mips_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|entry
operator|.
name|abfd
operator|=
name|NULL
expr_stmt|;
name|entry
operator|.
name|symndx
operator|=
operator|-
literal|1
expr_stmt|;
name|entry
operator|.
name|d
operator|.
name|address
operator|=
name|value
expr_stmt|;
name|entry
operator|.
name|tls_type
operator|=
literal|0
expr_stmt|;
name|g
operator|=
name|mips_elf_got_for_ibfd
argument_list|(
name|gg
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
block|{
name|g
operator|=
name|mips_elf_got_for_ibfd
argument_list|(
name|gg
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* We might have a symbol, H, if it has been forced local.  Use the      global entry then.  It doesn't matter whether an entry is local      or global for TLS, since the dynamic linker does not      automatically relocate TLS GOT entries.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|==
name|NULL
operator|||
name|h
operator|->
name|root
operator|.
name|forced_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|TLS_RELOC_P
argument_list|(
name|r_type
argument_list|)
condition|)
block|{
name|struct
name|mips_got_entry
modifier|*
name|p
decl_stmt|;
name|entry
operator|.
name|abfd
operator|=
name|ibfd
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_TLS_LDM
condition|)
block|{
name|entry
operator|.
name|tls_type
operator|=
name|GOT_TLS_LDM
expr_stmt|;
name|entry
operator|.
name|symndx
operator|=
literal|0
expr_stmt|;
name|entry
operator|.
name|d
operator|.
name|addend
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
name|entry
operator|.
name|symndx
operator|=
name|r_symndx
expr_stmt|;
name|entry
operator|.
name|d
operator|.
name|addend
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|entry
operator|.
name|d
operator|.
name|h
operator|=
name|h
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
name|htab_find
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
operator|&
name|entry
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
name|loc
operator|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
operator|&
name|entry
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|loc
condition|)
return|return
operator|*
name|loc
return|;
name|entry
operator|.
name|gotidx
operator|=
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
operator|*
name|g
operator|->
name|assigned_gotno
operator|++
expr_stmt|;
name|entry
operator|.
name|tls_type
operator|=
literal|0
expr_stmt|;
operator|*
name|loc
operator|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|loc
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
operator|*
name|loc
argument_list|,
operator|&
name|entry
argument_list|,
sizeof|sizeof
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|assigned_gotno
operator|>=
name|g
operator|->
name|local_gotno
condition|)
block|{
operator|(
operator|*
name|loc
operator|)
operator|->
name|gotidx
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We didn't allocate enough space in the GOT.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"not enough GOT space for local GOT entries"
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|MIPS_ELF_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
operator|(
name|sgot
operator|->
name|contents
operator|+
name|entry
operator|.
name|gotidx
operator|)
argument_list|)
expr_stmt|;
comment|/* These GOT entries need a dynamic relocation on VxWorks.  */
if|if
condition|(
name|htab
operator|->
name|is_vxworks
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_vma
name|got_address
decl_stmt|;
name|s
operator|=
name|mips_elf_rel_dyn_section
argument_list|(
name|info
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|got_address
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|entry
operator|.
name|gotidx
operator|)
expr_stmt|;
name|loc
operator|=
name|s
operator|->
name|contents
operator|+
operator|(
name|s
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|got_address
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|STN_UNDEF
argument_list|,
name|R_MIPS_32
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|value
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
return|return
operator|*
name|loc
return|;
block|}
end_function

begin_comment
comment|/* Sort the dynamic symbol table so that symbols that need GOT entries    appear towards the end.  This reduces the amount of GOT space    required.  MAX_LOCAL is used to set the number of local symbols    known to be in the dynamic symbol table.  During    _bfd_mips_elf_size_dynamic_sections, this value is 1.  Afterward, the    section symbols are added and the count is higher.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_sort_hash_table
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|unsigned
name|long
name|max_local
parameter_list|)
block|{
name|struct
name|mips_elf_hash_sort_data
name|hsd
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|g
operator|=
name|mips_elf_got_info
argument_list|(
name|dynobj
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|hsd
operator|.
name|low
operator|=
name|NULL
expr_stmt|;
name|hsd
operator|.
name|max_unref_got_dynindx
operator|=
name|hsd
operator|.
name|min_got_dynindx
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
comment|/* In the multi-got case, assigned_gotno of the master got_info        indicate the number of entries that aren't referenced in the        primary GOT, but that must have entries because there are        dynamic relocations that reference it.  Since they aren't        referenced, we move them to the end of the GOT, so that they        don't prevent other entries that are referenced from getting        too large offsets.  */
operator|-
operator|(
name|g
operator|->
name|next
condition|?
name|g
operator|->
name|assigned_gotno
else|:
literal|0
operator|)
expr_stmt|;
name|hsd
operator|.
name|max_non_got_dynindx
operator|=
name|max_local
expr_stmt|;
name|mips_elf_link_hash_traverse
argument_list|(
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_table
operator|*
operator|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|)
argument_list|,
name|mips_elf_sort_hash_table_f
argument_list|,
operator|&
name|hsd
argument_list|)
expr_stmt|;
comment|/* There should have been enough room in the symbol table to      accommodate both the GOT and non-GOT symbols.  */
name|BFD_ASSERT
argument_list|(
name|hsd
operator|.
name|max_non_got_dynindx
operator|<=
name|hsd
operator|.
name|min_got_dynindx
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|hsd
operator|.
name|max_unref_got_dynindx
operator|<=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
argument_list|)
expr_stmt|;
comment|/* Now we know which dynamic symbol has the lowest dynamic symbol      table index in the GOT.  */
name|g
operator|->
name|global_gotsym
operator|=
name|hsd
operator|.
name|low
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* If H needs a GOT entry, assign it the highest available dynamic    index.  Otherwise, assign it the lowest available dynamic    index.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_sort_hash_table_f
parameter_list|(
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|mips_elf_hash_sort_data
modifier|*
name|hsd
init|=
name|data
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Symbols without dynamic symbol table entries aren't interesting      at all.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|dynindx
operator|==
operator|-
literal|1
condition|)
return|return
name|TRUE
return|;
comment|/* Global symbols that need GOT entries that are not explicitly      referenced are marked with got offset 2.  Those that are      referenced get a 1, and those that don't need GOT entries get      -1.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|got
operator|.
name|offset
operator|==
literal|2
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|tls_type
operator|==
name|GOT_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hsd
operator|->
name|max_unref_got_dynindx
operator|==
name|hsd
operator|->
name|min_got_dynindx
condition|)
name|hsd
operator|->
name|low
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|dynindx
operator|=
name|hsd
operator|->
name|max_unref_got_dynindx
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|got
operator|.
name|offset
operator|!=
literal|1
condition|)
name|h
operator|->
name|root
operator|.
name|dynindx
operator|=
name|hsd
operator|->
name|max_non_got_dynindx
operator|++
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|tls_type
operator|==
name|GOT_NORMAL
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|dynindx
operator|=
operator|--
name|hsd
operator|->
name|min_got_dynindx
expr_stmt|;
name|hsd
operator|->
name|low
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* If H is a symbol that needs a global GOT entry, but has a dynamic    symbol table index lower than any we've seen to date, record it for    posterity.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_record_global_got_symbol
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|mips_got_info
modifier|*
name|g
parameter_list|,
name|unsigned
name|char
name|tls_flag
parameter_list|)
block|{
name|struct
name|mips_got_entry
name|entry
decl_stmt|,
modifier|*
modifier|*
name|loc
decl_stmt|;
comment|/* A global symbol in the GOT must also be in the dynamic symbol      table.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
condition|)
block|{
case|case
name|STV_INTERNAL
case|:
case|case
name|STV_HIDDEN
case|:
name|_bfd_mips_elf_hide_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Make sure we have a GOT to put this entry into.  */
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|entry
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|entry
operator|.
name|symndx
operator|=
operator|-
literal|1
expr_stmt|;
name|entry
operator|.
name|d
operator|.
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|entry
operator|.
name|tls_type
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
operator|&
name|entry
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
comment|/* If we've already marked this entry as needing GOT space, we don't      need to do it again.  */
if|if
condition|(
operator|*
name|loc
condition|)
block|{
operator|(
operator|*
name|loc
operator|)
operator|->
name|tls_type
operator||=
name|tls_flag
expr_stmt|;
return|return
name|TRUE
return|;
block|}
operator|*
name|loc
operator|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|loc
condition|)
return|return
name|FALSE
return|;
name|entry
operator|.
name|gotidx
operator|=
operator|-
literal|1
expr_stmt|;
name|entry
operator|.
name|tls_type
operator|=
name|tls_flag
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|loc
argument_list|,
operator|&
name|entry
argument_list|,
sizeof|sizeof
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
name|MINUS_ONE
condition|)
return|return
name|TRUE
return|;
comment|/* By setting this to a value other than -1, we are indicating that      there needs to be a GOT entry for H.  Avoid using zero, as the      generic ELF copy_indirect_symbol tests for<= 0.  */
if|if
condition|(
name|tls_flag
operator|==
literal|0
condition|)
name|h
operator|->
name|got
operator|.
name|offset
operator|=
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Reserve space in G for a GOT entry containing the value of symbol    SYMNDX in input bfd ABDF, plus ADDEND.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_record_local_got_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|long
name|symndx
parameter_list|,
name|bfd_vma
name|addend
parameter_list|,
name|struct
name|mips_got_info
modifier|*
name|g
parameter_list|,
name|unsigned
name|char
name|tls_flag
parameter_list|)
block|{
name|struct
name|mips_got_entry
name|entry
decl_stmt|,
modifier|*
modifier|*
name|loc
decl_stmt|;
name|entry
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|entry
operator|.
name|symndx
operator|=
name|symndx
expr_stmt|;
name|entry
operator|.
name|d
operator|.
name|addend
operator|=
name|addend
expr_stmt|;
name|entry
operator|.
name|tls_type
operator|=
name|tls_flag
expr_stmt|;
name|loc
operator|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
operator|&
name|entry
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|loc
condition|)
block|{
if|if
condition|(
name|tls_flag
operator|==
name|GOT_TLS_GD
operator|&&
operator|!
operator|(
operator|(
operator|*
name|loc
operator|)
operator|->
name|tls_type
operator|&
name|GOT_TLS_GD
operator|)
condition|)
block|{
name|g
operator|->
name|tls_gotno
operator|+=
literal|2
expr_stmt|;
operator|(
operator|*
name|loc
operator|)
operator|->
name|tls_type
operator||=
name|tls_flag
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tls_flag
operator|==
name|GOT_TLS_IE
operator|&&
operator|!
operator|(
operator|(
operator|*
name|loc
operator|)
operator|->
name|tls_type
operator|&
name|GOT_TLS_IE
operator|)
condition|)
block|{
name|g
operator|->
name|tls_gotno
operator|+=
literal|1
expr_stmt|;
operator|(
operator|*
name|loc
operator|)
operator|->
name|tls_type
operator||=
name|tls_flag
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|tls_flag
operator|!=
literal|0
condition|)
block|{
name|entry
operator|.
name|gotidx
operator|=
operator|-
literal|1
expr_stmt|;
name|entry
operator|.
name|tls_type
operator|=
name|tls_flag
expr_stmt|;
if|if
condition|(
name|tls_flag
operator|==
name|GOT_TLS_IE
condition|)
name|g
operator|->
name|tls_gotno
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|tls_flag
operator|==
name|GOT_TLS_GD
condition|)
name|g
operator|->
name|tls_gotno
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|g
operator|->
name|tls_ldm_offset
operator|==
name|MINUS_ONE
condition|)
block|{
name|g
operator|->
name|tls_ldm_offset
operator|=
name|MINUS_TWO
expr_stmt|;
name|g
operator|->
name|tls_gotno
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
name|entry
operator|.
name|gotidx
operator|=
name|g
operator|->
name|local_gotno
operator|++
expr_stmt|;
name|entry
operator|.
name|tls_type
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|loc
operator|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|loc
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
operator|*
name|loc
argument_list|,
operator|&
name|entry
argument_list|,
sizeof|sizeof
name|entry
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the hash value of the bfd in a bfd2got hash entry.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|mips_elf_bfd2got_entry_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|entry_
parameter_list|)
block|{
specifier|const
name|struct
name|mips_elf_bfd2got_hash
modifier|*
name|entry
init|=
operator|(
expr|struct
name|mips_elf_bfd2got_hash
operator|*
operator|)
name|entry_
decl_stmt|;
return|return
name|entry
operator|->
name|bfd
operator|->
name|id
return|;
block|}
end_function

begin_comment
comment|/* Check whether two hash entries have the same bfd.  */
end_comment

begin_function
specifier|static
name|int
name|mips_elf_bfd2got_entry_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|entry1
parameter_list|,
specifier|const
name|void
modifier|*
name|entry2
parameter_list|)
block|{
specifier|const
name|struct
name|mips_elf_bfd2got_hash
modifier|*
name|e1
init|=
operator|(
specifier|const
expr|struct
name|mips_elf_bfd2got_hash
operator|*
operator|)
name|entry1
decl_stmt|;
specifier|const
name|struct
name|mips_elf_bfd2got_hash
modifier|*
name|e2
init|=
operator|(
specifier|const
expr|struct
name|mips_elf_bfd2got_hash
operator|*
operator|)
name|entry2
decl_stmt|;
return|return
name|e1
operator|->
name|bfd
operator|==
name|e2
operator|->
name|bfd
return|;
block|}
end_function

begin_comment
comment|/* In a multi-got link, determine the GOT to be used for IBFD.  G must    be the master GOT data.  */
end_comment

begin_function
specifier|static
name|struct
name|mips_got_info
modifier|*
name|mips_elf_got_for_ibfd
parameter_list|(
name|struct
name|mips_got_info
modifier|*
name|g
parameter_list|,
name|bfd
modifier|*
name|ibfd
parameter_list|)
block|{
name|struct
name|mips_elf_bfd2got_hash
name|e
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|g
operator|->
name|bfd2got
condition|)
return|return
name|g
return|;
name|e
operator|.
name|bfd
operator|=
name|ibfd
expr_stmt|;
name|p
operator|=
name|htab_find
argument_list|(
name|g
operator|->
name|bfd2got
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
return|return
name|p
condition|?
name|p
operator|->
name|g
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Create one separate got for each bfd that has entries in the global    got, such that we can tell how many local and global entries each    bfd requires.  */
end_comment

begin_function
specifier|static
name|int
name|mips_elf_make_got_per_bfd
parameter_list|(
name|void
modifier|*
modifier|*
name|entryp
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|mips_got_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
operator|*
name|entryp
decl_stmt|;
name|struct
name|mips_elf_got_per_bfd_arg
modifier|*
name|arg
init|=
operator|(
expr|struct
name|mips_elf_got_per_bfd_arg
operator|*
operator|)
name|p
decl_stmt|;
name|htab_t
name|bfd2got
init|=
name|arg
operator|->
name|bfd2got
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|struct
name|mips_elf_bfd2got_hash
name|bfdgot_entry
decl_stmt|,
modifier|*
name|bfdgot
decl_stmt|;
name|void
modifier|*
modifier|*
name|bfdgotp
decl_stmt|;
comment|/* Find the got_info for this GOT entry's input bfd.  Create one if      none exists.  */
name|bfdgot_entry
operator|.
name|bfd
operator|=
name|entry
operator|->
name|abfd
expr_stmt|;
name|bfdgotp
operator|=
name|htab_find_slot
argument_list|(
name|bfd2got
argument_list|,
operator|&
name|bfdgot_entry
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|bfdgot
operator|=
operator|(
expr|struct
name|mips_elf_bfd2got_hash
operator|*
operator|)
operator|*
name|bfdgotp
expr_stmt|;
if|if
condition|(
name|bfdgot
operator|!=
name|NULL
condition|)
name|g
operator|=
name|bfdgot
operator|->
name|g
expr_stmt|;
else|else
block|{
name|bfdgot
operator|=
operator|(
expr|struct
name|mips_elf_bfd2got_hash
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|arg
operator|->
name|obfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_elf_bfd2got_hash
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfdgot
operator|==
name|NULL
condition|)
block|{
name|arg
operator|->
name|obfd
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|bfdgotp
operator|=
name|bfdgot
expr_stmt|;
name|bfdgot
operator|->
name|bfd
operator|=
name|entry
operator|->
name|abfd
expr_stmt|;
name|bfdgot
operator|->
name|g
operator|=
name|g
operator|=
operator|(
expr|struct
name|mips_got_info
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|arg
operator|->
name|obfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_got_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
block|{
name|arg
operator|->
name|obfd
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|g
operator|->
name|global_gotsym
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|global_gotno
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|local_gotno
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|assigned_gotno
operator|=
operator|-
literal|1
expr_stmt|;
name|g
operator|->
name|tls_gotno
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|tls_assigned_gotno
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|tls_ldm_offset
operator|=
name|MINUS_ONE
expr_stmt|;
name|g
operator|->
name|got_entries
operator|=
name|htab_try_create
argument_list|(
literal|1
argument_list|,
name|mips_elf_multi_got_entry_hash
argument_list|,
name|mips_elf_multi_got_entry_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|got_entries
operator|==
name|NULL
condition|)
block|{
name|arg
operator|->
name|obfd
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|g
operator|->
name|bfd2got
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Insert the GOT entry in the bfd's got entry hash table.  */
name|entryp
operator|=
name|htab_find_slot
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
name|entry
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|entryp
operator|!=
name|NULL
condition|)
return|return
literal|1
return|;
operator|*
name|entryp
operator|=
name|entry
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|tls_type
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|tls_type
operator|&
operator|(
name|GOT_TLS_GD
operator||
name|GOT_TLS_LDM
operator|)
condition|)
name|g
operator|->
name|tls_gotno
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|tls_type
operator|&
name|GOT_TLS_IE
condition|)
name|g
operator|->
name|tls_gotno
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|symndx
operator|>=
literal|0
operator|||
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|forced_local
condition|)
operator|++
name|g
operator|->
name|local_gotno
expr_stmt|;
else|else
operator|++
name|g
operator|->
name|global_gotno
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Attempt to merge gots of different input bfds.  Try to use as much    as possible of the primary got, since it doesn't require explicit    dynamic relocations, but don't use bfds that would reference global    symbols out of the addressable range.  Failing the primary got,    attempt to merge with the current got, or finish the current got    and then make make the new got current.  */
end_comment

begin_function
specifier|static
name|int
name|mips_elf_merge_gots
parameter_list|(
name|void
modifier|*
modifier|*
name|bfd2got_
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|mips_elf_bfd2got_hash
modifier|*
name|bfd2got
init|=
operator|(
expr|struct
name|mips_elf_bfd2got_hash
operator|*
operator|)
operator|*
name|bfd2got_
decl_stmt|;
name|struct
name|mips_elf_got_per_bfd_arg
modifier|*
name|arg
init|=
operator|(
expr|struct
name|mips_elf_got_per_bfd_arg
operator|*
operator|)
name|p
decl_stmt|;
name|unsigned
name|int
name|lcount
init|=
name|bfd2got
operator|->
name|g
operator|->
name|local_gotno
decl_stmt|;
name|unsigned
name|int
name|gcount
init|=
name|bfd2got
operator|->
name|g
operator|->
name|global_gotno
decl_stmt|;
name|unsigned
name|int
name|tcount
init|=
name|bfd2got
operator|->
name|g
operator|->
name|tls_gotno
decl_stmt|;
name|unsigned
name|int
name|maxcnt
init|=
name|arg
operator|->
name|max_count
decl_stmt|;
name|bfd_boolean
name|too_many_for_tls
init|=
name|FALSE
decl_stmt|;
comment|/* We place TLS GOT entries after both locals and globals.  The globals      for the primary GOT may overflow the normal GOT size limit, so be      sure not to merge a GOT which requires TLS with the primary GOT in that      case.  This doesn't affect non-primary GOTs.  */
if|if
condition|(
name|tcount
operator|>
literal|0
condition|)
block|{
name|unsigned
name|int
name|primary_total
init|=
name|lcount
operator|+
name|tcount
operator|+
name|arg
operator|->
name|global_count
decl_stmt|;
if|if
condition|(
name|primary_total
operator|>
name|maxcnt
condition|)
name|too_many_for_tls
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If we don't have a primary GOT and this is not too big, use it as      a starting point for the primary GOT.  */
if|if
condition|(
operator|!
name|arg
operator|->
name|primary
operator|&&
name|lcount
operator|+
name|gcount
operator|+
name|tcount
operator|<=
name|maxcnt
operator|&&
operator|!
name|too_many_for_tls
condition|)
block|{
name|arg
operator|->
name|primary
operator|=
name|bfd2got
operator|->
name|g
expr_stmt|;
name|arg
operator|->
name|primary_count
operator|=
name|lcount
operator|+
name|gcount
expr_stmt|;
block|}
comment|/* If it looks like we can merge this bfd's entries with those of      the primary, merge them.  The heuristics is conservative, but we      don't have to squeeze it too hard.  */
elseif|else
if|if
condition|(
name|arg
operator|->
name|primary
operator|&&
operator|!
name|too_many_for_tls
operator|&&
operator|(
name|arg
operator|->
name|primary_count
operator|+
name|lcount
operator|+
name|gcount
operator|+
name|tcount
operator|)
operator|<=
name|maxcnt
condition|)
block|{
name|struct
name|mips_got_info
modifier|*
name|g
init|=
name|bfd2got
operator|->
name|g
decl_stmt|;
name|int
name|old_lcount
init|=
name|arg
operator|->
name|primary
operator|->
name|local_gotno
decl_stmt|;
name|int
name|old_gcount
init|=
name|arg
operator|->
name|primary
operator|->
name|global_gotno
decl_stmt|;
name|int
name|old_tcount
init|=
name|arg
operator|->
name|primary
operator|->
name|tls_gotno
decl_stmt|;
name|bfd2got
operator|->
name|g
operator|=
name|arg
operator|->
name|primary
expr_stmt|;
name|htab_traverse
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
name|mips_elf_make_got_per_bfd
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|obfd
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|htab_delete
argument_list|(
name|g
operator|->
name|got_entries
argument_list|)
expr_stmt|;
comment|/* We don't have to worry about releasing memory of the actual 	 got entries, since they're all in the master got_entries hash 	 table anyway.  */
name|BFD_ASSERT
argument_list|(
name|old_lcount
operator|+
name|lcount
operator|>=
name|arg
operator|->
name|primary
operator|->
name|local_gotno
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|old_gcount
operator|+
name|gcount
operator|>=
name|arg
operator|->
name|primary
operator|->
name|global_gotno
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|old_tcount
operator|+
name|tcount
operator|>=
name|arg
operator|->
name|primary
operator|->
name|tls_gotno
argument_list|)
expr_stmt|;
name|arg
operator|->
name|primary_count
operator|=
name|arg
operator|->
name|primary
operator|->
name|local_gotno
operator|+
name|arg
operator|->
name|primary
operator|->
name|global_gotno
operator|+
name|arg
operator|->
name|primary
operator|->
name|tls_gotno
expr_stmt|;
block|}
comment|/* If we can merge with the last-created got, do it.  */
elseif|else
if|if
condition|(
name|arg
operator|->
name|current
operator|&&
name|arg
operator|->
name|current_count
operator|+
name|lcount
operator|+
name|gcount
operator|+
name|tcount
operator|<=
name|maxcnt
condition|)
block|{
name|struct
name|mips_got_info
modifier|*
name|g
init|=
name|bfd2got
operator|->
name|g
decl_stmt|;
name|int
name|old_lcount
init|=
name|arg
operator|->
name|current
operator|->
name|local_gotno
decl_stmt|;
name|int
name|old_gcount
init|=
name|arg
operator|->
name|current
operator|->
name|global_gotno
decl_stmt|;
name|int
name|old_tcount
init|=
name|arg
operator|->
name|current
operator|->
name|tls_gotno
decl_stmt|;
name|bfd2got
operator|->
name|g
operator|=
name|arg
operator|->
name|current
expr_stmt|;
name|htab_traverse
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
name|mips_elf_make_got_per_bfd
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|obfd
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|htab_delete
argument_list|(
name|g
operator|->
name|got_entries
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|old_lcount
operator|+
name|lcount
operator|>=
name|arg
operator|->
name|current
operator|->
name|local_gotno
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|old_gcount
operator|+
name|gcount
operator|>=
name|arg
operator|->
name|current
operator|->
name|global_gotno
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|old_tcount
operator|+
name|tcount
operator|>=
name|arg
operator|->
name|current
operator|->
name|tls_gotno
argument_list|)
expr_stmt|;
name|arg
operator|->
name|current_count
operator|=
name|arg
operator|->
name|current
operator|->
name|local_gotno
operator|+
name|arg
operator|->
name|current
operator|->
name|global_gotno
operator|+
name|arg
operator|->
name|current
operator|->
name|tls_gotno
expr_stmt|;
block|}
comment|/* Well, we couldn't merge, so create a new GOT.  Don't check if it      fits; if it turns out that it doesn't, we'll get relocation      overflows anyway.  */
else|else
block|{
name|bfd2got
operator|->
name|g
operator|->
name|next
operator|=
name|arg
operator|->
name|current
expr_stmt|;
name|arg
operator|->
name|current
operator|=
name|bfd2got
operator|->
name|g
expr_stmt|;
name|arg
operator|->
name|current_count
operator|=
name|lcount
operator|+
name|gcount
operator|+
literal|2
operator|*
name|tcount
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Set the TLS GOT index for the GOT entry in ENTRYP.  ENTRYP's NEXT field    is null iff there is just a single GOT.  */
end_comment

begin_function
specifier|static
name|int
name|mips_elf_initialize_tls_index
parameter_list|(
name|void
modifier|*
modifier|*
name|entryp
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|mips_got_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
operator|*
name|entryp
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
init|=
name|p
decl_stmt|;
name|bfd_vma
name|next_index
decl_stmt|;
name|unsigned
name|char
name|tls_type
decl_stmt|;
comment|/* We're only interested in TLS symbols.  */
if|if
condition|(
name|entry
operator|->
name|tls_type
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|next_index
operator|=
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|entry
operator|->
name|abfd
argument_list|)
operator|*
operator|(
name|long
operator|)
name|g
operator|->
name|tls_assigned_gotno
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
name|g
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
comment|/* A type (3) got entry in the single-GOT case.  We use the symbol's 	 hash table entry to track its index.  */
if|if
condition|(
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|tls_type
operator|&
name|GOT_TLS_OFFSET_DONE
condition|)
return|return
literal|1
return|;
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|tls_type
operator||=
name|GOT_TLS_OFFSET_DONE
expr_stmt|;
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|tls_got_offset
operator|=
name|next_index
expr_stmt|;
name|tls_type
operator|=
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|tls_type
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|entry
operator|->
name|tls_type
operator|&
name|GOT_TLS_LDM
condition|)
block|{
comment|/* There are separate mips_got_entry objects for each input bfd 	     that requires an LDM entry.  Make sure that all LDM entries in 	     a GOT resolve to the same index.  */
if|if
condition|(
name|g
operator|->
name|tls_ldm_offset
operator|!=
name|MINUS_TWO
operator|&&
name|g
operator|->
name|tls_ldm_offset
operator|!=
name|MINUS_ONE
condition|)
block|{
name|entry
operator|->
name|gotidx
operator|=
name|g
operator|->
name|tls_ldm_offset
expr_stmt|;
return|return
literal|1
return|;
block|}
name|g
operator|->
name|tls_ldm_offset
operator|=
name|next_index
expr_stmt|;
block|}
name|entry
operator|->
name|gotidx
operator|=
name|next_index
expr_stmt|;
name|tls_type
operator|=
name|entry
operator|->
name|tls_type
expr_stmt|;
block|}
comment|/* Account for the entries we've just allocated.  */
if|if
condition|(
name|tls_type
operator|&
operator|(
name|GOT_TLS_GD
operator||
name|GOT_TLS_LDM
operator|)
condition|)
name|g
operator|->
name|tls_assigned_gotno
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|tls_type
operator|&
name|GOT_TLS_IE
condition|)
name|g
operator|->
name|tls_assigned_gotno
operator|+=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* If passed a NULL mips_got_info in the argument, set the marker used    to tell whether a global symbol needs a got entry (in the primary    got) to the given VALUE.     If passed a pointer G to a mips_got_info in the argument (it must    not be the primary GOT), compute the offset from the beginning of    the (primary) GOT section to the entry in G corresponding to the    global symbol.  G's assigned_gotno must contain the index of the    first available global GOT entry in G.  VALUE must contain the size    of a GOT entry in bytes.  For each global GOT entry that requires a    dynamic relocation, NEEDED_RELOCS is incremented, and the symbol is    marked as not eligible for lazy resolution through a function    stub.  */
end_comment

begin_function
specifier|static
name|int
name|mips_elf_set_global_got_offset
parameter_list|(
name|void
modifier|*
modifier|*
name|entryp
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|mips_got_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
operator|*
name|entryp
decl_stmt|;
name|struct
name|mips_elf_set_global_got_offset_arg
modifier|*
name|arg
init|=
operator|(
expr|struct
name|mips_elf_set_global_got_offset_arg
operator|*
operator|)
name|p
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
init|=
name|arg
operator|->
name|g
decl_stmt|;
if|if
condition|(
name|g
operator|&&
name|entry
operator|->
name|tls_type
operator|!=
name|GOT_NORMAL
condition|)
name|arg
operator|->
name|needed_relocs
operator|+=
name|mips_tls_got_relocs
argument_list|(
name|arg
operator|->
name|info
argument_list|,
name|entry
operator|->
name|tls_type
argument_list|,
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
condition|?
operator|&
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|abfd
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|tls_type
operator|==
name|GOT_NORMAL
condition|)
block|{
if|if
condition|(
name|g
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|g
operator|->
name|global_gotsym
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|entry
operator|->
name|gotidx
operator|=
name|arg
operator|->
name|value
operator|*
operator|(
name|long
operator|)
name|g
operator|->
name|assigned_gotno
operator|++
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|info
operator|->
name|shared
operator|||
operator|(
name|elf_hash_table
argument_list|(
name|arg
operator|->
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|&&
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|def_dynamic
operator|&&
operator|!
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|def_regular
operator|)
condition|)
operator|++
name|arg
operator|->
name|needed_relocs
expr_stmt|;
block|}
else|else
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|got
operator|.
name|offset
operator|=
name|arg
operator|->
name|value
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Mark any global symbols referenced in the GOT we are iterating over    as inelligible for lazy resolution stubs.  */
end_comment

begin_function
specifier|static
name|int
name|mips_elf_set_no_stub
parameter_list|(
name|void
modifier|*
modifier|*
name|entryp
parameter_list|,
name|void
modifier|*
name|p
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|mips_got_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
operator|*
name|entryp
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|abfd
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|dynindx
operator|!=
operator|-
literal|1
condition|)
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|no_fn_stub
operator|=
name|TRUE
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Follow indirect and warning hash entries so that each got entry    points to the final symbol definition.  P must point to a pointer    to the hash table we're traversing.  Since this traversal may    modify the hash table, we set this pointer to NULL to indicate    we've made a potentially-destructive change to the hash table, so    the traversal must be restarted.  */
end_comment

begin_function
specifier|static
name|int
name|mips_elf_resolve_final_got_entry
parameter_list|(
name|void
modifier|*
modifier|*
name|entryp
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|mips_got_entry
modifier|*
name|entry
init|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
operator|*
name|entryp
decl_stmt|;
name|htab_t
name|got_entries
init|=
operator|*
operator|(
name|htab_t
operator|*
operator|)
name|p
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|abfd
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
condition|)
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
init|=
name|entry
operator|->
name|d
operator|.
name|h
decl_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|d
operator|.
name|h
operator|==
name|h
condition|)
return|return
literal|1
return|;
name|entry
operator|->
name|d
operator|.
name|h
operator|=
name|h
expr_stmt|;
comment|/* If we can't find this entry with the new bfd hash, re-insert 	 it, and get the traversal restarted.  */
if|if
condition|(
operator|!
name|htab_find
argument_list|(
name|got_entries
argument_list|,
name|entry
argument_list|)
condition|)
block|{
name|htab_clear_slot
argument_list|(
name|got_entries
argument_list|,
name|entryp
argument_list|)
expr_stmt|;
name|entryp
operator|=
name|htab_find_slot
argument_list|(
name|got_entries
argument_list|,
name|entry
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|entryp
condition|)
operator|*
name|entryp
operator|=
name|entry
expr_stmt|;
comment|/* Abort the traversal, since the whole table may have 	     moved, and leave it up to the parent to restart the 	     process.  */
operator|*
operator|(
name|htab_t
operator|*
operator|)
name|p
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* We might want to decrement the global_gotno count, but it's 	 either too early or too late for that at this point.  */
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Turn indirect got entries in a got_entries table into their final    locations.  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf_resolve_final_got_entries
parameter_list|(
name|struct
name|mips_got_info
modifier|*
name|g
parameter_list|)
block|{
name|htab_t
name|got_entries
decl_stmt|;
do|do
block|{
name|got_entries
operator|=
name|g
operator|->
name|got_entries
expr_stmt|;
name|htab_traverse
argument_list|(
name|got_entries
argument_list|,
name|mips_elf_resolve_final_got_entry
argument_list|,
operator|&
name|got_entries
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|got_entries
operator|==
name|NULL
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Return the offset of an input bfd IBFD's GOT from the beginning of    the primary GOT.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_adjust_gp
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|mips_got_info
modifier|*
name|g
parameter_list|,
name|bfd
modifier|*
name|ibfd
parameter_list|)
block|{
if|if
condition|(
name|g
operator|->
name|bfd2got
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|g
operator|=
name|mips_elf_got_for_ibfd
argument_list|(
name|g
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g
condition|)
return|return
literal|0
return|;
name|BFD_ASSERT
argument_list|(
name|g
operator|->
name|next
argument_list|)
expr_stmt|;
name|g
operator|=
name|g
operator|->
name|next
expr_stmt|;
return|return
operator|(
name|g
operator|->
name|local_gotno
operator|+
name|g
operator|->
name|global_gotno
operator|+
name|g
operator|->
name|tls_gotno
operator|)
operator|*
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Turn a single GOT that is too big for 16-bit addressing into    a sequence of GOTs, each one 16-bit addressable.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_multi_got
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|mips_got_info
modifier|*
name|g
parameter_list|,
name|asection
modifier|*
name|got
parameter_list|,
name|bfd_size_type
name|pages
parameter_list|)
block|{
name|struct
name|mips_elf_got_per_bfd_arg
name|got_per_bfd_arg
decl_stmt|;
name|struct
name|mips_elf_set_global_got_offset_arg
name|set_got_offset_arg
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|gg
decl_stmt|;
name|unsigned
name|int
name|assign
decl_stmt|;
name|g
operator|->
name|bfd2got
operator|=
name|htab_try_create
argument_list|(
literal|1
argument_list|,
name|mips_elf_bfd2got_entry_hash
argument_list|,
name|mips_elf_bfd2got_entry_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|bfd2got
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|got_per_bfd_arg
operator|.
name|bfd2got
operator|=
name|g
operator|->
name|bfd2got
expr_stmt|;
name|got_per_bfd_arg
operator|.
name|obfd
operator|=
name|abfd
expr_stmt|;
name|got_per_bfd_arg
operator|.
name|info
operator|=
name|info
expr_stmt|;
comment|/* Count how many GOT entries each input bfd requires, creating a      map from bfd to got info while at that.  */
name|htab_traverse
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
name|mips_elf_make_got_per_bfd
argument_list|,
operator|&
name|got_per_bfd_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|got_per_bfd_arg
operator|.
name|obfd
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|got_per_bfd_arg
operator|.
name|current
operator|=
name|NULL
expr_stmt|;
name|got_per_bfd_arg
operator|.
name|primary
operator|=
name|NULL
expr_stmt|;
comment|/* Taking out PAGES entries is a worst-case estimate.  We could      compute the maximum number of pages that each separate input bfd      uses, but it's probably not worth it.  */
name|got_per_bfd_arg
operator|.
name|max_count
operator|=
operator|(
operator|(
name|MIPS_ELF_GOT_MAX_SIZE
argument_list|(
name|info
argument_list|)
operator|/
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
operator|)
operator|-
name|MIPS_RESERVED_GOTNO
argument_list|(
name|info
argument_list|)
operator|-
name|pages
operator|)
expr_stmt|;
comment|/* The number of globals that will be included in the primary GOT.      See the calls to mips_elf_set_global_got_offset below for more      information.  */
name|got_per_bfd_arg
operator|.
name|global_count
operator|=
name|g
operator|->
name|global_gotno
expr_stmt|;
comment|/* Try to merge the GOTs of input bfds together, as long as they      don't seem to exceed the maximum GOT size, choosing one of them      to be the primary GOT.  */
name|htab_traverse
argument_list|(
name|g
operator|->
name|bfd2got
argument_list|,
name|mips_elf_merge_gots
argument_list|,
operator|&
name|got_per_bfd_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|got_per_bfd_arg
operator|.
name|obfd
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* If we do not find any suitable primary GOT, create an empty one.  */
if|if
condition|(
name|got_per_bfd_arg
operator|.
name|primary
operator|==
name|NULL
condition|)
block|{
name|g
operator|->
name|next
operator|=
operator|(
expr|struct
name|mips_got_info
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_got_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|next
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|g
operator|->
name|next
operator|->
name|global_gotsym
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|next
operator|->
name|global_gotno
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|next
operator|->
name|local_gotno
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|next
operator|->
name|tls_gotno
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|next
operator|->
name|assigned_gotno
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|next
operator|->
name|tls_assigned_gotno
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|next
operator|->
name|tls_ldm_offset
operator|=
name|MINUS_ONE
expr_stmt|;
name|g
operator|->
name|next
operator|->
name|got_entries
operator|=
name|htab_try_create
argument_list|(
literal|1
argument_list|,
name|mips_elf_multi_got_entry_hash
argument_list|,
name|mips_elf_multi_got_entry_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|next
operator|->
name|got_entries
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|g
operator|->
name|next
operator|->
name|bfd2got
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|g
operator|->
name|next
operator|=
name|got_per_bfd_arg
operator|.
name|primary
expr_stmt|;
name|g
operator|->
name|next
operator|->
name|next
operator|=
name|got_per_bfd_arg
operator|.
name|current
expr_stmt|;
comment|/* GG is now the master GOT, and G is the primary GOT.  */
name|gg
operator|=
name|g
expr_stmt|;
name|g
operator|=
name|g
operator|->
name|next
expr_stmt|;
comment|/* Map the output bfd to the primary got.  That's what we're going      to use for bfds that use GOT16 or GOT_PAGE relocations that we      didn't mark in check_relocs, and we want a quick way to find it.      We can't just use gg->next because we're going to reverse the      list.  */
block|{
name|struct
name|mips_elf_bfd2got_hash
modifier|*
name|bfdgot
decl_stmt|;
name|void
modifier|*
modifier|*
name|bfdgotp
decl_stmt|;
name|bfdgot
operator|=
operator|(
expr|struct
name|mips_elf_bfd2got_hash
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_elf_bfd2got_hash
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfdgot
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|bfdgot
operator|->
name|bfd
operator|=
name|abfd
expr_stmt|;
name|bfdgot
operator|->
name|g
operator|=
name|g
expr_stmt|;
name|bfdgotp
operator|=
name|htab_find_slot
argument_list|(
name|gg
operator|->
name|bfd2got
argument_list|,
name|bfdgot
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|*
name|bfdgotp
operator|==
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|bfdgotp
operator|=
name|bfdgot
expr_stmt|;
block|}
comment|/* The IRIX dynamic linker requires every symbol that is referenced      in a dynamic relocation to be present in the primary GOT, so      arrange for them to appear after those that are actually      referenced.       GNU/Linux could very well do without it, but it would slow down      the dynamic linker, since it would have to resolve every dynamic      symbol referenced in other GOTs more than once, without help from      the cache.  Also, knowing that every external symbol has a GOT      helps speed up the resolution of local symbols too, so GNU/Linux      follows IRIX's practice.       The number 2 is used by mips_elf_sort_hash_table_f to count      global GOT symbols that are unreferenced in the primary GOT, with      an initial dynamic index computed from gg->assigned_gotno, where      the number of unreferenced global entries in the primary GOT is      preserved.  */
if|if
condition|(
literal|1
condition|)
block|{
name|gg
operator|->
name|assigned_gotno
operator|=
name|gg
operator|->
name|global_gotno
operator|-
name|g
operator|->
name|global_gotno
expr_stmt|;
name|g
operator|->
name|global_gotno
operator|=
name|gg
operator|->
name|global_gotno
expr_stmt|;
name|set_got_offset_arg
operator|.
name|value
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* This could be used for dynamic linkers that don't optimize 	 symbol resolution while applying relocations so as to use 	 primary GOT entries or assuming the symbol is locally-defined. 	 With this code, we assign lower dynamic indices to global 	 symbols that are not referenced in the primary GOT, so that 	 their entries can be omitted.  */
name|gg
operator|->
name|assigned_gotno
operator|=
literal|0
expr_stmt|;
name|set_got_offset_arg
operator|.
name|value
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Reorder dynamic symbols as described above (which behavior      depends on the setting of VALUE).  */
name|set_got_offset_arg
operator|.
name|g
operator|=
name|NULL
expr_stmt|;
name|htab_traverse
argument_list|(
name|gg
operator|->
name|got_entries
argument_list|,
name|mips_elf_set_global_got_offset
argument_list|,
operator|&
name|set_got_offset_arg
argument_list|)
expr_stmt|;
name|set_got_offset_arg
operator|.
name|value
operator|=
literal|1
expr_stmt|;
name|htab_traverse
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
name|mips_elf_set_global_got_offset
argument_list|,
operator|&
name|set_got_offset_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mips_elf_sort_hash_table
argument_list|(
name|info
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Now go through the GOTs assigning them offset ranges.      [assigned_gotno, local_gotno[ will be set to the range of local      entries in each GOT.  We can then compute the end of a GOT by      adding local_gotno to global_gotno.  We reverse the list and make      it circular since then we'll be able to quickly compute the      beginning of a GOT, by computing the end of its predecessor.  To      avoid special cases for the primary GOT, while still preserving      assertions that are valid for both single- and multi-got links,      we arrange for the main got struct to have the right number of      global entries, but set its local_gotno such that the initial      offset of the primary GOT is zero.  Remember that the primary GOT      will become the last item in the circular linked list, so it      points back to the master GOT.  */
name|gg
operator|->
name|local_gotno
operator|=
operator|-
name|g
operator|->
name|global_gotno
expr_stmt|;
name|gg
operator|->
name|global_gotno
operator|=
name|g
operator|->
name|global_gotno
expr_stmt|;
name|gg
operator|->
name|tls_gotno
operator|=
literal|0
expr_stmt|;
name|assign
operator|=
literal|0
expr_stmt|;
name|gg
operator|->
name|next
operator|=
name|gg
expr_stmt|;
do|do
block|{
name|struct
name|mips_got_info
modifier|*
name|gn
decl_stmt|;
name|assign
operator|+=
name|MIPS_RESERVED_GOTNO
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|g
operator|->
name|assigned_gotno
operator|=
name|assign
expr_stmt|;
name|g
operator|->
name|local_gotno
operator|+=
name|assign
operator|+
name|pages
expr_stmt|;
name|assign
operator|=
name|g
operator|->
name|local_gotno
operator|+
name|g
operator|->
name|global_gotno
operator|+
name|g
operator|->
name|tls_gotno
expr_stmt|;
comment|/* Take g out of the direct list, and push it onto the reversed 	 list that gg points to.  g->next is guaranteed to be nonnull after 	 this operation, as required by mips_elf_initialize_tls_index. */
name|gn
operator|=
name|g
operator|->
name|next
expr_stmt|;
name|g
operator|->
name|next
operator|=
name|gg
operator|->
name|next
expr_stmt|;
name|gg
operator|->
name|next
operator|=
name|g
expr_stmt|;
comment|/* Set up any TLS entries.  We always place the TLS entries after 	 all non-TLS entries.  */
name|g
operator|->
name|tls_assigned_gotno
operator|=
name|g
operator|->
name|local_gotno
operator|+
name|g
operator|->
name|global_gotno
expr_stmt|;
name|htab_traverse
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
name|mips_elf_initialize_tls_index
argument_list|,
name|g
argument_list|)
expr_stmt|;
comment|/* Move onto the next GOT.  It will be a secondary GOT if nonull.  */
name|g
operator|=
name|gn
expr_stmt|;
comment|/* Mark global symbols in every non-primary GOT as ineligible for 	 stubs.  */
if|if
condition|(
name|g
condition|)
name|htab_traverse
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
name|mips_elf_set_no_stub
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|g
condition|)
do|;
name|got
operator|->
name|size
operator|=
operator|(
name|gg
operator|->
name|next
operator|->
name|local_gotno
operator|+
name|gg
operator|->
name|next
operator|->
name|global_gotno
operator|+
name|gg
operator|->
name|next
operator|->
name|tls_gotno
operator|)
operator|*
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns the first relocation of type r_type found, beginning with    RELOCATION.  RELEND is one-past-the-end of the relocation table.  */
end_comment

begin_function
specifier|static
specifier|const
name|Elf_Internal_Rela
modifier|*
name|mips_elf_next_relocation
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|r_type
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocation
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relend
parameter_list|)
block|{
name|unsigned
name|long
name|r_symndx
init|=
name|ELF_R_SYM
argument_list|(
name|abfd
argument_list|,
name|relocation
operator|->
name|r_info
argument_list|)
decl_stmt|;
while|while
condition|(
name|relocation
operator|<
name|relend
condition|)
block|{
if|if
condition|(
name|ELF_R_TYPE
argument_list|(
name|abfd
argument_list|,
name|relocation
operator|->
name|r_info
argument_list|)
operator|==
name|r_type
operator|&&
name|ELF_R_SYM
argument_list|(
name|abfd
argument_list|,
name|relocation
operator|->
name|r_info
argument_list|)
operator|==
name|r_symndx
condition|)
return|return
name|relocation
return|;
operator|++
name|relocation
expr_stmt|;
block|}
comment|/* We didn't find it.  */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return whether a relocation is against a local symbol.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_local_relocation_p
parameter_list|(
name|bfd
modifier|*
name|input_bfd
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocation
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|,
name|bfd_boolean
name|check_forced
parameter_list|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
name|r_symndx
operator|=
name|ELF_R_SYM
argument_list|(
name|input_bfd
argument_list|,
name|relocation
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|extsymoff
operator|=
operator|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
operator|)
condition|?
literal|0
else|:
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|extsymoff
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
operator|&&
name|local_sections
index|[
name|r_symndx
index|]
operator|!=
name|NULL
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|check_forced
condition|)
block|{
comment|/* Look up the hash table to check whether the symbol  	 was forced local.  */
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
expr_stmt|;
comment|/* Find the real hash-table entry for this symbol.  */
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|forced_local
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Sign-extend VALUE, which has the indicated number of BITS.  */
end_comment

begin_function
name|bfd_vma
name|_bfd_mips_elf_sign_extend
parameter_list|(
name|bfd_vma
name|value
parameter_list|,
name|int
name|bits
parameter_list|)
block|{
if|if
condition|(
name|value
operator|&
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
condition|)
comment|/* VALUE is negative.  */
name|value
operator||=
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|)
operator|<<
name|bits
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the indicated VALUE has overflowed the maximum    range expressible by a signed number with the indicated number of    BITS.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_overflow_p
parameter_list|(
name|bfd_vma
name|value
parameter_list|,
name|int
name|bits
parameter_list|)
block|{
name|bfd_signed_vma
name|svalue
init|=
operator|(
name|bfd_signed_vma
operator|)
name|value
decl_stmt|;
if|if
condition|(
name|svalue
operator|>
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
condition|)
comment|/* The value is too big.  */
return|return
name|TRUE
return|;
elseif|else
if|if
condition|(
name|svalue
operator|<
operator|-
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
condition|)
comment|/* The value is too small.  */
return|return
name|TRUE
return|;
comment|/* All is well.  */
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Calculate the %high function.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_high
parameter_list|(
name|bfd_vma
name|value
parameter_list|)
block|{
return|return
operator|(
operator|(
name|value
operator|+
operator|(
name|bfd_vma
operator|)
literal|0x8000
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
return|;
block|}
end_function

begin_comment
comment|/* Calculate the %higher function.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_higher
parameter_list|(
name|bfd_vma
name|value
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BFD64
return|return
operator|(
operator|(
name|value
operator|+
operator|(
name|bfd_vma
operator|)
literal|0x80008000
operator|)
operator|>>
literal|32
operator|)
operator|&
literal|0xffff
return|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
return|return
name|MINUS_ONE
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Calculate the %highest function.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_highest
parameter_list|(
name|bfd_vma
name|value
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BFD64
return|return
operator|(
operator|(
name|value
operator|+
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
literal|0x8000
operator|<<
literal|32
operator|)
operator||
literal|0x80008000
operator|)
operator|)
operator|>>
literal|48
operator|)
operator|&
literal|0xffff
return|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
return|return
name|MINUS_ONE
return|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the .compact_rel section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_create_compact_rel_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|flagword
name|flags
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".compact_rel"
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
expr_stmt|;
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".compact_rel"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|MIPS_ELF_LOG_FILE_ALIGN
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|s
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_compact_rel
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create the .got section to hold the global offset table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_create_got_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_boolean
name|maybe_exclude
parameter_list|)
block|{
name|flagword
name|flags
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|struct
name|mips_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* This function may be called more than once.  */
name|s
operator|=
name|mips_elf_got_section
argument_list|(
name|abfd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
operator|!
name|maybe_exclude
condition|)
name|s
operator|->
name|flags
operator|&=
operator|~
name|SEC_EXCLUDE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
if|if
condition|(
name|maybe_exclude
condition|)
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
comment|/* We have to use an alignment of 2**4 here because this is hardcoded      in the function stub generation and in the linker script.  */
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Define the symbol _GLOBAL_OFFSET_TABLE_.  We don't do this in the      linker script because we don't want to define the symbol if we      are not creating a global offset table.  */
name|bh
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|non_elf
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hgot
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mips_got_info
argument_list|)
expr_stmt|;
name|g
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|g
operator|->
name|global_gotsym
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|global_gotno
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|tls_gotno
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|local_gotno
operator|=
name|MIPS_RESERVED_GOTNO
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|g
operator|->
name|assigned_gotno
operator|=
name|MIPS_RESERVED_GOTNO
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|g
operator|->
name|bfd2got
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|tls_ldm_offset
operator|=
name|MINUS_ONE
expr_stmt|;
name|g
operator|->
name|got_entries
operator|=
name|htab_try_create
argument_list|(
literal|1
argument_list|,
name|mips_elf_got_entry_hash
argument_list|,
name|mips_elf_got_entry_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|got_entries
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|mips_elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|u
operator|.
name|got_info
operator|=
name|g
expr_stmt|;
name|mips_elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|elf
operator|.
name|this_hdr
operator|.
name|sh_flags
operator||=
name|SHF_ALLOC
operator||
name|SHF_WRITE
operator||
name|SHF_MIPS_GPREL
expr_stmt|;
comment|/* VxWorks also needs a .got.plt section.  */
if|if
condition|(
name|htab
operator|->
name|is_vxworks
condition|)
block|{
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".got.plt"
argument_list|,
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|htab
operator|->
name|sgotplt
operator|=
name|s
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if H refers to the special VxWorks __GOTT_BASE__ or    __GOTT_INDEX__ symbols.  These symbols are only special for    shared objects; they are not used in executables.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|is_gott_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
return|return
operator|(
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|is_vxworks
operator|&&
name|info
operator|->
name|shared
operator|&&
operator|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"__GOTT_BASE__"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"__GOTT_INDEX__"
argument_list|)
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Calculate the value produced by the RELOCATION (which comes from    the INPUT_BFD).  The ADDEND is the addend to use for this    RELOCATION; RELOCATION->R_ADDEND is ignored.     The result of the relocation calculation is stored in VALUEP.    REQUIRE_JALXP indicates whether or not the opcode used with this    relocation must be JALX.     This function returns bfd_reloc_continue if the caller need take no    further action regarding this relocation, bfd_reloc_notsupported if    something goes dramatically wrong, bfd_reloc_overflow if an    overflow occurs, and bfd_reloc_ok to indicate success.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mips_elf_calculate_relocation
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocation
parameter_list|,
name|bfd_vma
name|addend
parameter_list|,
name|reloc_howto_type
modifier|*
name|howto
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|,
name|bfd_vma
modifier|*
name|valuep
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|namep
parameter_list|,
name|bfd_boolean
modifier|*
name|require_jalxp
parameter_list|,
name|bfd_boolean
name|save_addend
parameter_list|)
block|{
comment|/* The eventual value we will return.  */
name|bfd_vma
name|value
decl_stmt|;
comment|/* The address of the symbol against which the relocation is      occurring.  */
name|bfd_vma
name|symbol
init|=
literal|0
decl_stmt|;
comment|/* The final GP value to be used for the relocatable, executable, or      shared object file being produced.  */
name|bfd_vma
name|gp
init|=
name|MINUS_ONE
decl_stmt|;
comment|/* The place (section offset or address) of the storage unit being      relocated.  */
name|bfd_vma
name|p
decl_stmt|;
comment|/* The value of GP used to create the relocatable object.  */
name|bfd_vma
name|gp0
init|=
name|MINUS_ONE
decl_stmt|;
comment|/* The offset into the global offset table at which the address of      the relocation entry symbol, adjusted by the addend, resides      during execution.  */
name|bfd_vma
name|g
init|=
name|MINUS_ONE
decl_stmt|;
comment|/* The section in which the symbol referenced by the relocation is      located.  */
name|asection
modifier|*
name|sec
init|=
name|NULL
decl_stmt|;
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
comment|/* TRUE if the symbol referred to by this relocation is a local      symbol.  */
name|bfd_boolean
name|local_p
decl_stmt|,
name|was_local_p
decl_stmt|;
comment|/* TRUE if the symbol referred to by this relocation is "_gp_disp".  */
name|bfd_boolean
name|gp_disp_p
init|=
name|FALSE
decl_stmt|;
comment|/* TRUE if the symbol referred to by this relocation is      "__gnu_local_gp".  */
name|bfd_boolean
name|gnu_local_gp_p
init|=
name|FALSE
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|int
name|r_type
decl_stmt|;
comment|/* TRUE if overflow occurred during the calculation of the      relocation value.  */
name|bfd_boolean
name|overflowed_p
decl_stmt|;
comment|/* TRUE if this relocation refers to a MIPS16 function.  */
name|bfd_boolean
name|target_is_16_bit_code_p
init|=
name|FALSE
decl_stmt|;
name|struct
name|mips_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|htab
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Parse the relocation.  */
name|r_symndx
operator|=
name|ELF_R_SYM
argument_list|(
name|input_bfd
argument_list|,
name|relocation
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF_R_TYPE
argument_list|(
name|input_bfd
argument_list|,
name|relocation
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|relocation
operator|->
name|r_offset
operator|)
expr_stmt|;
comment|/* Assume that there will be no overflow.  */
name|overflowed_p
operator|=
name|FALSE
expr_stmt|;
comment|/* Figure out whether or not the symbol is local, and get the offset      used in the array of hash table entries.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|local_p
operator|=
name|mips_elf_local_relocation_p
argument_list|(
name|input_bfd
argument_list|,
name|relocation
argument_list|,
name|local_sections
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|was_local_p
operator|=
name|local_p
expr_stmt|;
if|if
condition|(
operator|!
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
condition|)
name|extsymoff
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
else|else
block|{
comment|/* The symbol table does not follow the rule that local symbols 	 must come before globals.  */
name|extsymoff
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Figure out the value of the symbol.  */
if|if
condition|(
name|local_p
condition|)
block|{
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|symbol
operator|=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_SECTION
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
condition|)
name|symbol
operator|+=
name|sym
operator|->
name|st_value
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
name|addend
operator|=
name|_bfd_elf_rel_local_sym
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|addend
argument_list|)
expr_stmt|;
name|addend
operator|-=
name|symbol
expr_stmt|;
name|addend
operator|+=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
expr_stmt|;
block|}
comment|/* MIPS16 text labels should be treated as odd.  */
if|if
condition|(
name|sym
operator|->
name|st_other
operator|==
name|STO_MIPS16
condition|)
operator|++
name|symbol
expr_stmt|;
comment|/* Record the name of this symbol, for our caller.  */
operator|*
name|namep
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|namep
operator|==
literal|'\0'
condition|)
operator|*
name|namep
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|target_is_16_bit_code_p
operator|=
operator|(
name|sym
operator|->
name|st_other
operator|==
name|STO_MIPS16
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ??? Could we use RELOC_FOR_GLOBAL_SYMBOL here ?  */
comment|/* For global symbols we look up the symbol in the hash-table.  */
name|h
operator|=
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|)
expr_stmt|;
comment|/* Find the real hash-table entry for this symbol.  */
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* Record the name of this symbol, for our caller.  */
operator|*
name|namep
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
comment|/* See if this is the special _gp_disp symbol.  Note that such a 	 symbol must always be a global symbol.  */
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|namep
argument_list|,
literal|"_gp_disp"
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|NEWABI_P
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
comment|/* Relocations against _gp_disp are permitted only with 	     R_MIPS_HI16 and R_MIPS_LO16 relocations.  */
if|if
condition|(
name|r_type
operator|!=
name|R_MIPS_HI16
operator|&&
name|r_type
operator|!=
name|R_MIPS_LO16
operator|&&
name|r_type
operator|!=
name|R_MIPS16_HI16
operator|&&
name|r_type
operator|!=
name|R_MIPS16_LO16
condition|)
return|return
name|bfd_reloc_notsupported
return|;
name|gp_disp_p
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* See if this is the special _gp symbol.  Note that such a 	 symbol must always be a global symbol.  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|namep
argument_list|,
literal|"__gnu_local_gp"
argument_list|)
operator|==
literal|0
condition|)
name|gnu_local_gp_p
operator|=
name|TRUE
expr_stmt|;
comment|/* If this symbol is defined, calculate its address.  Note that 	 _gp_disp is a magic symbol, always implicitly defined by the 	 linker, so it's inappropriate to check to see whether or not 	 its defined.  */
elseif|else
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|output_section
condition|)
name|symbol
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
else|else
name|symbol
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
comment|/* We allow relocations against undefined weak symbols, giving 	   it the value zero, so that you can undefined weak functions 	   and check to see if they exist by looking at their 	   addresses.  */
name|symbol
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|unresolved_syms_in_objects
operator|==
name|RM_IGNORE
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|root
operator|.
name|other
argument_list|)
operator|==
name|STV_DEFAULT
condition|)
name|symbol
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|namep
argument_list|,
name|SGI_COMPAT
argument_list|(
name|input_bfd
argument_list|)
condition|?
literal|"_DYNAMIC_LINK"
else|:
literal|"_DYNAMIC_LINKING"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If this is a dynamic link, we should have created a 	     _DYNAMIC_LINK symbol or _DYNAMIC_LINKING(for normal mips) symbol 	     in in _bfd_mips_elf_create_dynamic_sections. 	     Otherwise, we should define the symbol with a value of 0. 	     FIXME: It should probably get into the symbol table 	     somehow as well.  */
name|BFD_ASSERT
argument_list|(
operator|!
name|info
operator|->
name|shared
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|symbol
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ELF_MIPS_IS_OPTIONAL
argument_list|(
name|h
operator|->
name|root
operator|.
name|other
argument_list|)
condition|)
block|{
comment|/* This is an optional symbol - an Irix specific extension to the 	     ELF spec.  Ignore it for now. 	     XXX - FIXME - there is more to the spec for OPTIONAL symbols 	     than simply ignoring them, but we do not handle this for now. 	     For information see the "64-bit ELF Object File Specification" 	     which is available from here: 	     http://techpubs.sgi.com/library/manuals/4000/007-4658-001/pdf/007-4658-001.pdf  */
name|symbol
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|relocation
operator|->
name|r_offset
argument_list|,
operator|(
name|info
operator|->
name|unresolved_syms_in_objects
operator|==
name|RM_GENERATE_ERROR
operator|)
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|root
operator|.
name|other
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|bfd_reloc_undefined
return|;
name|symbol
operator|=
literal|0
expr_stmt|;
block|}
name|target_is_16_bit_code_p
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|other
operator|==
name|STO_MIPS16
operator|)
expr_stmt|;
block|}
comment|/* If this is a 32- or 64-bit call to a 16-bit function with a stub, we      need to redirect the call to the stub, unless we're already *in*      a stub.  */
if|if
condition|(
name|r_type
operator|!=
name|R_MIPS16_26
operator|&&
operator|!
name|info
operator|->
name|relocatable
operator|&&
operator|(
operator|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|fn_stub
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|local_p
operator|&&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|local_stubs
operator|!=
name|NULL
operator|&&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|local_stubs
index|[
name|r_symndx
index|]
operator|!=
name|NULL
operator|)
operator|)
operator|&&
operator|!
name|mips16_stub_section_p
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
condition|)
block|{
comment|/* This is a 32- or 64-bit call to a 16-bit function.  We should 	 have already noticed that we were going to need the 	 stub.  */
if|if
condition|(
name|local_p
condition|)
name|sec
operator|=
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|local_stubs
index|[
name|r_symndx
index|]
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|need_fn_stub
argument_list|)
expr_stmt|;
name|sec
operator|=
name|h
operator|->
name|fn_stub
expr_stmt|;
block|}
name|symbol
operator|=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
expr_stmt|;
comment|/* The target is 16-bit, but the stub isn't.  */
name|target_is_16_bit_code_p
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* If this is a 16-bit call to a 32- or 64-bit function with a stub, we      need to redirect the call to the stub.  */
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_26
operator|&&
operator|!
name|info
operator|->
name|relocatable
operator|&&
operator|(
operator|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|call_stub
operator|!=
name|NULL
operator|||
name|h
operator|->
name|call_fp_stub
operator|!=
name|NULL
operator|)
operator|)
operator|||
operator|(
name|local_p
operator|&&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|local_call_stubs
operator|!=
name|NULL
operator|&&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|local_call_stubs
index|[
name|r_symndx
index|]
operator|!=
name|NULL
operator|)
operator|)
operator|&&
operator|!
name|target_is_16_bit_code_p
condition|)
block|{
if|if
condition|(
name|local_p
condition|)
name|sec
operator|=
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|local_call_stubs
index|[
name|r_symndx
index|]
expr_stmt|;
else|else
block|{
comment|/* If both call_stub and call_fp_stub are defined, we can figure 	     out which one to use by checking which one appears in the input 	     file.  */
if|if
condition|(
name|h
operator|->
name|call_stub
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|call_fp_stub
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|o
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
name|CALL_FP_STUB_P
argument_list|(
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|o
argument_list|)
argument_list|)
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|call_fp_stub
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
name|sec
operator|=
name|h
operator|->
name|call_stub
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|call_stub
operator|!=
name|NULL
condition|)
name|sec
operator|=
name|h
operator|->
name|call_stub
expr_stmt|;
else|else
name|sec
operator|=
name|h
operator|->
name|call_fp_stub
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|sec
operator|->
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|symbol
operator|=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
expr_stmt|;
block|}
comment|/* Calls from 16-bit code to 32-bit code and vice versa require the      special jalx instruction.  */
operator|*
name|require_jalxp
operator|=
operator|(
operator|!
name|info
operator|->
name|relocatable
operator|&&
operator|(
operator|(
operator|(
name|r_type
operator|==
name|R_MIPS16_26
operator|)
operator|&&
operator|!
name|target_is_16_bit_code_p
operator|)
operator|||
operator|(
operator|(
name|r_type
operator|==
name|R_MIPS_26
operator|)
operator|&&
name|target_is_16_bit_code_p
operator|)
operator|)
operator|)
expr_stmt|;
name|local_p
operator|=
name|mips_elf_local_relocation_p
argument_list|(
name|input_bfd
argument_list|,
name|relocation
argument_list|,
name|local_sections
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* If we haven't already determined the GOT offset, or the GP value,      and we're going to need it, get it now.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_MIPS_GOT_PAGE
case|:
case|case
name|R_MIPS_GOT_OFST
case|:
comment|/* We need to decay to GOT_DISP/addend if the symbol doesn't 	 bind locally.  */
name|local_p
operator|=
name|local_p
operator|||
name|_bfd_elf_symbol_refs_local_p
argument_list|(
operator|&
name|h
operator|->
name|root
argument_list|,
name|info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_p
operator|||
name|r_type
operator|==
name|R_MIPS_GOT_OFST
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|R_MIPS_CALL16
case|:
case|case
name|R_MIPS_GOT16
case|:
case|case
name|R_MIPS_GOT_DISP
case|:
case|case
name|R_MIPS_GOT_HI16
case|:
case|case
name|R_MIPS_CALL_HI16
case|:
case|case
name|R_MIPS_GOT_LO16
case|:
case|case
name|R_MIPS_CALL_LO16
case|:
case|case
name|R_MIPS_TLS_GD
case|:
case|case
name|R_MIPS_TLS_GOTTPREL
case|:
case|case
name|R_MIPS_TLS_LDM
case|:
comment|/* Find the index into the GOT where this value is located.  */
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_TLS_LDM
condition|)
block|{
name|g
operator|=
name|mips_elf_local_got_index
argument_list|(
name|abfd
argument_list|,
name|input_bfd
argument_list|,
name|info
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|MINUS_ONE
condition|)
return|return
name|bfd_reloc_outofrange
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|local_p
condition|)
block|{
comment|/* On VxWorks, CALL relocations should refer to the .got.plt 	     entry, which is initialized to point at the PLT stub.  */
if|if
condition|(
name|htab
operator|->
name|is_vxworks
operator|&&
operator|(
name|r_type
operator|==
name|R_MIPS_CALL_HI16
operator|||
name|r_type
operator|==
name|R_MIPS_CALL_LO16
operator|||
name|r_type
operator|==
name|R_MIPS_CALL16
operator|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|addend
operator|==
literal|0
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|root
operator|.
name|needs_plt
argument_list|)
expr_stmt|;
name|g
operator|=
name|mips_elf_gotplt_index
argument_list|(
name|info
argument_list|,
operator|&
name|h
operator|->
name|root
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* GOT_PAGE may take a non-zero addend, that is ignored in a 		 GOT_PAGE relocation that decays to GOT_DISP because the 		 symbol turns out to be global.  The addend is then added 		 as GOT_OFST.  */
name|BFD_ASSERT
argument_list|(
name|addend
operator|==
literal|0
operator|||
name|r_type
operator|==
name|R_MIPS_GOT_PAGE
argument_list|)
expr_stmt|;
name|g
operator|=
name|mips_elf_global_got_index
argument_list|(
name|dynobj
argument_list|,
name|input_bfd
argument_list|,
operator|&
name|h
operator|->
name|root
argument_list|,
name|r_type
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|tls_type
operator|==
name|GOT_NORMAL
operator|&&
operator|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|root
operator|.
name|forced_local
operator|)
operator|&&
name|h
operator|->
name|root
operator|.
name|def_regular
operator|)
operator|)
condition|)
block|{
comment|/* This is a static link or a -Bsymbolic link.  The 		     symbol is defined locally, or was forced to be local. 		     We must initialize this entry in the GOT.  */
name|asection
modifier|*
name|sgot
init|=
name|mips_elf_got_section
argument_list|(
name|dynobj
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
name|MIPS_ELF_PUT_WORD
argument_list|(
name|dynobj
argument_list|,
name|symbol
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|g
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|htab
operator|->
name|is_vxworks
operator|&&
operator|(
name|r_type
operator|==
name|R_MIPS_CALL16
operator|||
operator|(
name|r_type
operator|==
name|R_MIPS_GOT16
operator|)
operator|)
condition|)
comment|/* The calculation below does not involve "g".  */
break|break;
else|else
block|{
name|g
operator|=
name|mips_elf_local_got_index
argument_list|(
name|abfd
argument_list|,
name|input_bfd
argument_list|,
name|info
argument_list|,
name|symbol
operator|+
name|addend
argument_list|,
name|r_symndx
argument_list|,
name|h
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|MINUS_ONE
condition|)
return|return
name|bfd_reloc_outofrange
return|;
block|}
comment|/* Convert GOT indices to actual offsets.  */
name|g
operator|=
name|mips_elf_got_offset_from_index
argument_list|(
name|dynobj
argument_list|,
name|abfd
argument_list|,
name|input_bfd
argument_list|,
name|g
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_HI16
case|:
case|case
name|R_MIPS_LO16
case|:
case|case
name|R_MIPS_GPREL16
case|:
case|case
name|R_MIPS_GPREL32
case|:
case|case
name|R_MIPS_LITERAL
case|:
case|case
name|R_MIPS16_HI16
case|:
case|case
name|R_MIPS16_LO16
case|:
case|case
name|R_MIPS16_GPREL
case|:
name|gp0
operator|=
name|_bfd_get_gp_value
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|gp
operator|=
name|_bfd_get_gp_value
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynobj
condition|)
name|gp
operator|+=
name|mips_elf_adjust_gp
argument_list|(
name|abfd
argument_list|,
name|mips_elf_got_info
argument_list|(
name|dynobj
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|input_bfd
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|gnu_local_gp_p
condition|)
name|symbol
operator|=
name|gp
expr_stmt|;
comment|/* Relocations against the VxWorks __GOTT_BASE__ and __GOTT_INDEX__      symbols are resolved by the loader.  Add them to .rela.dyn.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|is_gott_symbol
argument_list|(
name|info
argument_list|,
operator|&
name|h
operator|->
name|root
argument_list|)
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|mips_elf_rel_dyn_section
argument_list|(
name|info
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|loc
operator|=
name|s
operator|->
name|contents
operator|+
name|s
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|relocation
operator|->
name|r_offset
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|root
operator|.
name|dynindx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|addend
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
comment|/* If we've written this relocation for a readonly section, 	 we need to set DF_TEXTREL again, so that we do not delete the 	 DT_TEXTREL tag.  */
if|if
condition|(
name|MIPS_ELF_READONLY_SECTION
argument_list|(
name|input_section
argument_list|)
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
operator|*
name|valuep
operator|=
literal|0
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* Figure out what kind of relocation is being performed.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_MIPS_NONE
case|:
return|return
name|bfd_reloc_continue
return|;
case|case
name|R_MIPS_16
case|:
name|value
operator|=
name|symbol
operator|+
name|_bfd_mips_elf_sign_extend
argument_list|(
name|addend
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_32
case|:
case|case
name|R_MIPS_REL32
case|:
case|case
name|R_MIPS_64
case|:
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|||
operator|(
operator|!
name|htab
operator|->
name|is_vxworks
operator|&&
name|htab
operator|->
name|root
operator|.
name|dynamic_sections_created
operator|&&
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|def_dynamic
operator|&&
operator|!
name|h
operator|->
name|root
operator|.
name|def_regular
operator|)
operator|)
operator|&&
name|r_symndx
operator|!=
literal|0
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* If we're creating a shared library, or this relocation is 	     against a symbol in a shared library, then we can't know 	     where the symbol will end up.  So, we create a relocation 	     record in the output, and leave the job up to the dynamic 	     linker.  	     In VxWorks executables, references to external symbols 	     are handled using copy relocs or PLT stubs, so there's 	     no need to add a dynamic relocation here.  */
name|value
operator|=
name|addend
expr_stmt|;
if|if
condition|(
operator|!
name|mips_elf_create_dynamic_relocation
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|relocation
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|symbol
argument_list|,
operator|&
name|value
argument_list|,
name|input_section
argument_list|)
condition|)
return|return
name|bfd_reloc_undefined
return|;
block|}
else|else
block|{
if|if
condition|(
name|r_type
operator|!=
name|R_MIPS_REL32
condition|)
name|value
operator|=
name|symbol
operator|+
name|addend
expr_stmt|;
else|else
name|value
operator|=
name|addend
expr_stmt|;
block|}
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_PC32
case|:
name|value
operator|=
name|symbol
operator|+
name|addend
operator|-
name|p
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS16_26
case|:
comment|/* The calculation for R_MIPS16_26 is just the same as for an 	 R_MIPS_26.  It's only the storage of the relocated field into 	 the output file that's different.  That's handled in 	 mips_elf_perform_relocation.  So, we just fall through to the 	 R_MIPS_26 case here.  */
case|case
name|R_MIPS_26
case|:
if|if
condition|(
name|local_p
condition|)
name|value
operator|=
operator|(
operator|(
name|addend
operator||
operator|(
operator|(
name|p
operator|+
literal|4
operator|)
operator|&
literal|0xf0000000
operator|)
operator|)
operator|+
name|symbol
operator|)
operator|>>
literal|2
expr_stmt|;
else|else
block|{
name|value
operator|=
operator|(
name|_bfd_mips_elf_sign_extend
argument_list|(
name|addend
argument_list|,
literal|28
argument_list|)
operator|+
name|symbol
operator|)
operator|>>
literal|2
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
condition|)
name|overflowed_p
operator|=
operator|(
name|value
operator|>>
literal|26
operator|)
operator|!=
operator|(
operator|(
name|p
operator|+
literal|4
operator|)
operator|>>
literal|28
operator|)
expr_stmt|;
block|}
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_TLS_DTPREL_HI16
case|:
name|value
operator|=
operator|(
name|mips_elf_high
argument_list|(
name|addend
operator|+
name|symbol
operator|-
name|dtprel_base
argument_list|(
name|info
argument_list|)
argument_list|)
operator|&
name|howto
operator|->
name|dst_mask
operator|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_TLS_DTPREL_LO16
case|:
case|case
name|R_MIPS_TLS_DTPREL32
case|:
case|case
name|R_MIPS_TLS_DTPREL64
case|:
name|value
operator|=
operator|(
name|symbol
operator|+
name|addend
operator|-
name|dtprel_base
argument_list|(
name|info
argument_list|)
operator|)
operator|&
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_TLS_TPREL_HI16
case|:
name|value
operator|=
operator|(
name|mips_elf_high
argument_list|(
name|addend
operator|+
name|symbol
operator|-
name|tprel_base
argument_list|(
name|info
argument_list|)
argument_list|)
operator|&
name|howto
operator|->
name|dst_mask
operator|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_TLS_TPREL_LO16
case|:
name|value
operator|=
operator|(
name|symbol
operator|+
name|addend
operator|-
name|tprel_base
argument_list|(
name|info
argument_list|)
operator|)
operator|&
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_HI16
case|:
case|case
name|R_MIPS16_HI16
case|:
if|if
condition|(
operator|!
name|gp_disp_p
condition|)
block|{
name|value
operator|=
name|mips_elf_high
argument_list|(
name|addend
operator|+
name|symbol
argument_list|)
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
block|}
else|else
block|{
comment|/* For MIPS16 ABI code we generate this sequence 	        0: li      $v0,%hi(_gp_disp) 	        4: addiupc $v1,%lo(_gp_disp) 	        8: sll     $v0,16 	       12: addu    $v0,$v1 	       14: move    $gp,$v0 	     So the offsets of hi and lo relocs are the same, but the 	     $pc is four higher than $t9 would be, so reduce 	     both reloc addends by 4. */
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_HI16
condition|)
name|value
operator|=
name|mips_elf_high
argument_list|(
name|addend
operator|+
name|gp
operator|-
name|p
operator|-
literal|4
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|mips_elf_high
argument_list|(
name|addend
operator|+
name|gp
operator|-
name|p
argument_list|)
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_MIPS_LO16
case|:
case|case
name|R_MIPS16_LO16
case|:
if|if
condition|(
operator|!
name|gp_disp_p
condition|)
name|value
operator|=
operator|(
name|symbol
operator|+
name|addend
operator|)
operator|&
name|howto
operator|->
name|dst_mask
expr_stmt|;
else|else
block|{
comment|/* See the comment for R_MIPS16_HI16 above for the reason 	     for this conditional.  */
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_LO16
condition|)
name|value
operator|=
name|addend
operator|+
name|gp
operator|-
name|p
expr_stmt|;
else|else
name|value
operator|=
name|addend
operator|+
name|gp
operator|-
name|p
operator|+
literal|4
expr_stmt|;
comment|/* The MIPS ABI requires checking the R_MIPS_LO16 relocation 	     for overflow.  But, on, say, IRIX5, relocations against 	     _gp_disp are normally generated from the .cpload 	     pseudo-op.  It generates code that normally looks like 	     this:  	       lui    $gp,%hi(_gp_disp) 	       addiu  $gp,$gp,%lo(_gp_disp) 	       addu   $gp,$gp,$t9  	     Here $t9 holds the address of the function being called, 	     as required by the MIPS ELF ABI.  The R_MIPS_LO16 	     relocation can easily overflow in this situation, but the 	     R_MIPS_HI16 relocation will handle the overflow. 	     Therefore, we consider this a bug in the MIPS ABI, and do 	     not check for overflow here.  */
block|}
break|break;
case|case
name|R_MIPS_LITERAL
case|:
comment|/* Because we don't merge literal sections, we can handle this 	 just like R_MIPS_GPREL16.  In the long run, we should merge 	 shared literals, and then we will need to additional work 	 here.  */
comment|/* Fall through.  */
case|case
name|R_MIPS16_GPREL
case|:
comment|/* The R_MIPS16_GPREL performs the same calculation as 	 R_MIPS_GPREL16, but stores the relocated bits in a different 	 order.  We don't need to do anything special here; the 	 differences are handled in mips_elf_perform_relocation.  */
case|case
name|R_MIPS_GPREL16
case|:
comment|/* Only sign-extend the addend if it was extracted from the 	 instruction.  If the addend was separate, leave it alone, 	 otherwise we may lose significant bits.  */
if|if
condition|(
name|howto
operator|->
name|partial_inplace
condition|)
name|addend
operator|=
name|_bfd_mips_elf_sign_extend
argument_list|(
name|addend
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|value
operator|=
name|symbol
operator|+
name|addend
operator|-
name|gp
expr_stmt|;
comment|/* If the symbol was local, any earlier relocatable links will 	 have adjusted its addend with the gp offset, so compensate 	 for that now.  Don't do it for symbols forced local in this 	 link, though, since they won't have had the gp offset applied 	 to them before.  */
if|if
condition|(
name|was_local_p
condition|)
name|value
operator|+=
name|gp0
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_GOT16
case|:
case|case
name|R_MIPS_CALL16
case|:
comment|/* VxWorks does not have separate local and global semantics for 	 R_MIPS_GOT16; every relocation evaluates to "G".  */
if|if
condition|(
operator|!
name|htab
operator|->
name|is_vxworks
operator|&&
name|local_p
condition|)
block|{
name|bfd_boolean
name|forced
decl_stmt|;
name|forced
operator|=
operator|!
name|mips_elf_local_relocation_p
argument_list|(
name|input_bfd
argument_list|,
name|relocation
argument_list|,
name|local_sections
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|value
operator|=
name|mips_elf_got16_entry
argument_list|(
name|abfd
argument_list|,
name|input_bfd
argument_list|,
name|info
argument_list|,
name|symbol
operator|+
name|addend
argument_list|,
name|forced
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|MINUS_ONE
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|value
operator|=
name|mips_elf_got_offset_from_index
argument_list|(
name|dynobj
argument_list|,
name|abfd
argument_list|,
name|input_bfd
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|R_MIPS_TLS_GD
case|:
case|case
name|R_MIPS_TLS_GOTTPREL
case|:
case|case
name|R_MIPS_TLS_LDM
case|:
case|case
name|R_MIPS_GOT_DISP
case|:
name|got_disp
label|:
name|value
operator|=
name|g
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_GPREL32
case|:
name|value
operator|=
operator|(
name|addend
operator|+
name|symbol
operator|+
name|gp0
operator|-
name|gp
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|save_addend
condition|)
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_PC16
case|:
case|case
name|R_MIPS_GNU_REL16_S2
case|:
name|value
operator|=
name|symbol
operator|+
name|_bfd_mips_elf_sign_extend
argument_list|(
name|addend
argument_list|,
literal|18
argument_list|)
operator|-
name|p
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf_overflow_p
argument_list|(
name|value
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|value
operator|>>=
name|howto
operator|->
name|rightshift
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_GOT_HI16
case|:
case|case
name|R_MIPS_CALL_HI16
case|:
comment|/* We're allowed to handle these two relocations identically. 	 The dynamic linker is allowed to handle the CALL relocations 	 differently by creating a lazy evaluation stub.  */
name|value
operator|=
name|g
expr_stmt|;
name|value
operator|=
name|mips_elf_high
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_GOT_LO16
case|:
case|case
name|R_MIPS_CALL_LO16
case|:
name|value
operator|=
name|g
operator|&
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_GOT_PAGE
case|:
comment|/* GOT_PAGE relocations that reference non-local symbols decay 	 to GOT_DISP.  The corresponding GOT_OFST relocation decays to 	 0.  */
if|if
condition|(
operator|!
name|local_p
condition|)
goto|goto
name|got_disp
goto|;
name|value
operator|=
name|mips_elf_got_page
argument_list|(
name|abfd
argument_list|,
name|input_bfd
argument_list|,
name|info
argument_list|,
name|symbol
operator|+
name|addend
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|MINUS_ONE
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|value
operator|=
name|mips_elf_got_offset_from_index
argument_list|(
name|dynobj
argument_list|,
name|abfd
argument_list|,
name|input_bfd
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_GOT_OFST
case|:
if|if
condition|(
name|local_p
condition|)
name|mips_elf_got_page
argument_list|(
name|abfd
argument_list|,
name|input_bfd
argument_list|,
name|info
argument_list|,
name|symbol
operator|+
name|addend
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|addend
expr_stmt|;
name|overflowed_p
operator|=
name|mips_elf_overflow_p
argument_list|(
name|value
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_SUB
case|:
name|value
operator|=
name|symbol
operator|-
name|addend
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_HIGHER
case|:
name|value
operator|=
name|mips_elf_higher
argument_list|(
name|addend
operator|+
name|symbol
argument_list|)
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_HIGHEST
case|:
name|value
operator|=
name|mips_elf_highest
argument_list|(
name|addend
operator|+
name|symbol
argument_list|)
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_SCN_DISP
case|:
name|value
operator|=
name|symbol
operator|+
name|addend
operator|-
name|sec
operator|->
name|output_offset
expr_stmt|;
name|value
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
break|break;
case|case
name|R_MIPS_JALR
case|:
comment|/* This relocation is only a hint.  In some cases, we optimize 	 it into a bal instruction.  But we don't try to optimize 	 branches to the PLT; that will wind up wasting time.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
return|return
name|bfd_reloc_continue
return|;
name|value
operator|=
name|symbol
operator|+
name|addend
expr_stmt|;
break|break;
case|case
name|R_MIPS_PJUMP
case|:
case|case
name|R_MIPS_GNU_VTINHERIT
case|:
case|case
name|R_MIPS_GNU_VTENTRY
case|:
comment|/* We don't do anything with these at present.  */
return|return
name|bfd_reloc_continue
return|;
default|default:
comment|/* An unrecognized relocation type.  */
return|return
name|bfd_reloc_notsupported
return|;
block|}
comment|/* Store the VALUE for our caller.  */
operator|*
name|valuep
operator|=
name|value
expr_stmt|;
return|return
name|overflowed_p
condition|?
name|bfd_reloc_overflow
else|:
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Obtain the field relocated by RELOCATION.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|mips_elf_obtain_contents
parameter_list|(
name|reloc_howto_type
modifier|*
name|howto
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocation
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|)
block|{
name|bfd_vma
name|x
decl_stmt|;
name|bfd_byte
modifier|*
name|location
init|=
name|contents
operator|+
name|relocation
operator|->
name|r_offset
decl_stmt|;
comment|/* Obtain the bytes.  */
name|x
operator|=
name|bfd_get
argument_list|(
operator|(
literal|8
operator|*
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
operator|)
argument_list|,
name|input_bfd
argument_list|,
name|location
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* It has been determined that the result of the RELOCATION is the    VALUE.  Use HOWTO to place VALUE into the output file at the    appropriate position.  The SECTION is the section to which the    relocation applies.  If REQUIRE_JALX is TRUE, then the opcode used    for the relocation must be either JAL or JALX, and it is    unconditionally converted to JALX.     Returns FALSE if anything goes wrong.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_perform_relocation
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|reloc_howto_type
modifier|*
name|howto
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocation
parameter_list|,
name|bfd_vma
name|value
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|bfd_boolean
name|require_jalx
parameter_list|)
block|{
name|bfd_vma
name|x
decl_stmt|;
name|bfd_byte
modifier|*
name|location
decl_stmt|;
name|int
name|r_type
init|=
name|ELF_R_TYPE
argument_list|(
name|input_bfd
argument_list|,
name|relocation
operator|->
name|r_info
argument_list|)
decl_stmt|;
comment|/* Figure out where the relocation is occurring.  */
name|location
operator|=
name|contents
operator|+
name|relocation
operator|->
name|r_offset
expr_stmt|;
name|_bfd_mips16_elf_reloc_unshuffle
argument_list|(
name|input_bfd
argument_list|,
name|r_type
argument_list|,
name|FALSE
argument_list|,
name|location
argument_list|)
expr_stmt|;
comment|/* Obtain the current value.  */
name|x
operator|=
name|mips_elf_obtain_contents
argument_list|(
name|howto
argument_list|,
name|relocation
argument_list|,
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
comment|/* Clear the field we are setting.  */
name|x
operator|&=
operator|~
name|howto
operator|->
name|dst_mask
expr_stmt|;
comment|/* Set the field.  */
name|x
operator||=
operator|(
name|value
operator|&
name|howto
operator|->
name|dst_mask
operator|)
expr_stmt|;
comment|/* If required, turn JAL into JALX.  */
if|if
condition|(
name|require_jalx
condition|)
block|{
name|bfd_boolean
name|ok
decl_stmt|;
name|bfd_vma
name|opcode
init|=
name|x
operator|>>
literal|26
decl_stmt|;
name|bfd_vma
name|jalx_opcode
decl_stmt|;
comment|/* Check to see if the opcode is already JAL or JALX.  */
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_26
condition|)
block|{
name|ok
operator|=
operator|(
operator|(
name|opcode
operator|==
literal|0x6
operator|)
operator|||
operator|(
name|opcode
operator|==
literal|0x7
operator|)
operator|)
expr_stmt|;
name|jalx_opcode
operator|=
literal|0x7
expr_stmt|;
block|}
else|else
block|{
name|ok
operator|=
operator|(
operator|(
name|opcode
operator|==
literal|0x3
operator|)
operator|||
operator|(
name|opcode
operator|==
literal|0x1d
operator|)
operator|)
expr_stmt|;
name|jalx_opcode
operator|=
literal|0x1d
expr_stmt|;
block|}
comment|/* If the opcode is not JAL or JALX, there's a problem.  */
if|if
condition|(
operator|!
name|ok
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: %A+0x%lx: jump to stub routine which is not jal"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|relocation
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Make this the JALX opcode.  */
name|x
operator|=
operator|(
name|x
operator|&
operator|~
operator|(
literal|0x3f
operator|<<
literal|26
operator|)
operator|)
operator||
operator|(
name|jalx_opcode
operator|<<
literal|26
operator|)
expr_stmt|;
block|}
comment|/* On the RM9000, bal is faster than jal, because bal uses branch      prediction hardware.  If we are linking for the RM9000, and we      see jal, and bal fits, use it instead.  Note that this      transformation should be safe for all architectures.  */
if|if
condition|(
name|bfd_get_mach
argument_list|(
name|input_bfd
argument_list|)
operator|==
name|bfd_mach_mips9000
operator|&&
operator|!
name|info
operator|->
name|relocatable
operator|&&
operator|!
name|require_jalx
operator|&&
operator|(
operator|(
name|r_type
operator|==
name|R_MIPS_26
operator|&&
operator|(
name|x
operator|>>
literal|26
operator|)
operator|==
literal|0x3
operator|)
comment|/* jal addr */
operator|||
operator|(
name|r_type
operator|==
name|R_MIPS_JALR
operator|&&
name|x
operator|==
literal|0x0320f809
operator|)
operator|)
condition|)
comment|/* jalr t9 */
block|{
name|bfd_vma
name|addr
decl_stmt|;
name|bfd_vma
name|dest
decl_stmt|;
name|bfd_signed_vma
name|off
decl_stmt|;
name|addr
operator|=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|relocation
operator|->
name|r_offset
operator|+
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_26
condition|)
name|dest
operator|=
operator|(
name|value
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|addr
operator|>>
literal|28
operator|)
operator|<<
literal|28
operator|)
expr_stmt|;
else|else
name|dest
operator|=
name|value
expr_stmt|;
name|off
operator|=
name|dest
operator|-
name|addr
expr_stmt|;
if|if
condition|(
name|off
operator|<=
literal|0x1ffff
operator|&&
name|off
operator|>=
operator|-
literal|0x20000
condition|)
name|x
operator|=
literal|0x04110000
operator||
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|off
operator|>>
literal|2
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
comment|/* bal addr */
block|}
comment|/* Put the value into the output.  */
name|bfd_put
argument_list|(
literal|8
operator|*
name|bfd_get_reloc_size
argument_list|(
name|howto
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|x
argument_list|,
name|location
argument_list|)
expr_stmt|;
name|_bfd_mips16_elf_reloc_shuffle
argument_list|(
name|input_bfd
argument_list|,
name|r_type
argument_list|,
operator|!
name|info
operator|->
name|relocatable
argument_list|,
name|location
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if SECTION is a MIPS16 stub section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips16_stub_section_p
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
decl_stmt|;
return|return
name|FN_STUB_P
argument_list|(
name|name
argument_list|)
operator|||
name|CALL_STUB_P
argument_list|(
name|name
argument_list|)
operator|||
name|CALL_FP_STUB_P
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add room for N relocations to the .rel(a).dyn section in ABFD.  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf_allocate_dynamic_relocations
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|mips_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|s
operator|=
name|mips_elf_rel_dyn_section
argument_list|(
name|info
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|is_vxworks
condition|)
name|s
operator|->
name|size
operator|+=
name|n
operator|*
name|MIPS_ELF_RELA_SIZE
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
block|{
comment|/* Make room for a null element.  */
name|s
operator|->
name|size
operator|+=
name|MIPS_ELF_REL_SIZE
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
operator|++
name|s
operator|->
name|reloc_count
expr_stmt|;
block|}
name|s
operator|->
name|size
operator|+=
name|n
operator|*
name|MIPS_ELF_REL_SIZE
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create a rel.dyn relocation for the dynamic linker to resolve.  REL    is the original relocation, which is now being transformed into a    dynamic relocation.  The ADDENDP is adjusted if necessary; the    caller should store the result in place of the original addend.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_create_dynamic_relocation
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|symbol
parameter_list|,
name|bfd_vma
modifier|*
name|addendp
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|)
block|{
name|Elf_Internal_Rela
name|outrel
index|[
literal|3
index|]
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|int
name|r_type
decl_stmt|;
name|long
name|indx
decl_stmt|;
name|bfd_boolean
name|defined_p
decl_stmt|;
name|struct
name|mips_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF_R_TYPE
argument_list|(
name|output_bfd
argument_list|,
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sreloc
operator|=
name|mips_elf_rel_dyn_section
argument_list|(
name|info
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|->
name|contents
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|->
name|reloc_count
operator|*
name|MIPS_ELF_REL_SIZE
argument_list|(
name|output_bfd
argument_list|)
operator|<
name|sreloc
operator|->
name|size
argument_list|)
expr_stmt|;
name|outrel
index|[
literal|0
index|]
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
index|[
literal|0
index|]
operator|.
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|outrel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
argument_list|)
expr_stmt|;
name|outrel
index|[
literal|2
index|]
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
index|[
literal|2
index|]
operator|.
name|r_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outrel
index|[
literal|0
index|]
operator|.
name|r_offset
operator|==
name|MINUS_ONE
condition|)
comment|/* The relocation field has been deleted.  */
return|return
name|TRUE
return|;
if|if
condition|(
name|outrel
index|[
literal|0
index|]
operator|.
name|r_offset
operator|==
name|MINUS_TWO
condition|)
block|{
comment|/* The relocation field has been converted into a relative value of 	 some sort.  Functions like _bfd_elf_write_section_eh_frame expect 	 the field to be fully relocated, so add in the symbol's value.  */
operator|*
name|addendp
operator|+=
name|symbol
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* We must now calculate the dynamic symbol table index to use      in the relocation.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|h
operator|->
name|root
operator|.
name|def_regular
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|info
operator|->
name|symbolic
operator|&&
operator|!
name|h
operator|->
name|root
operator|.
name|forced_local
operator|)
operator|)
condition|)
block|{
name|indx
operator|=
name|h
operator|->
name|root
operator|.
name|dynindx
expr_stmt|;
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|defined_p
operator|=
name|h
operator|->
name|root
operator|.
name|def_regular
expr_stmt|;
else|else
comment|/* ??? glibc's ld.so just adds the final GOT entry to the 	   relocation field.  It therefore treats relocs against 	   defined symbols in the same way as relocs against 	   undefined symbols.  */
name|defined_p
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
condition|)
name|indx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
name|sec
operator|->
name|owner
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|indx
operator|=
name|elf_section_data
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
operator|->
name|dynindx
expr_stmt|;
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
block|{
name|asection
modifier|*
name|osec
init|=
name|htab
operator|->
name|root
operator|.
name|text_index_section
decl_stmt|;
name|indx
operator|=
name|elf_section_data
argument_list|(
name|osec
argument_list|)
operator|->
name|dynindx
expr_stmt|;
block|}
if|if
condition|(
name|indx
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Instead of generating a relocation using the section 	 symbol, we may as well make it a fully relative 	 relocation.  We want to avoid generating relocations to 	 local symbols because we used to generate them 	 incorrectly, without adding the original symbol value, 	 which is mandated by the ABI for section symbols.  In 	 order to give dynamic loaders and applications time to 	 phase out the incorrect use, we refrain from emitting 	 section-relative relocations.  It's not like they're 	 useful, after all.  This should be a bit more efficient 	 as well.  */
comment|/* ??? Although this behavior is compatible with glibc's ld.so, 	 the ABI says that relocations against STN_UNDEF should have 	 a symbol value of 0.  Irix rld honors this, so relocations 	 against STN_UNDEF have no effect.  */
if|if
condition|(
operator|!
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|indx
operator|=
literal|0
expr_stmt|;
name|defined_p
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If the relocation was previously an absolute relocation and      this symbol will not be referred to by the relocation, we must      adjust it by the value we give it in the dynamic symbol table.      Otherwise leave the job up to the dynamic linker.  */
if|if
condition|(
name|defined_p
operator|&&
name|r_type
operator|!=
name|R_MIPS_REL32
condition|)
operator|*
name|addendp
operator|+=
name|symbol
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|is_vxworks
condition|)
comment|/* VxWorks uses non-relative relocations for this.  */
name|outrel
index|[
literal|0
index|]
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|R_MIPS_32
argument_list|)
expr_stmt|;
else|else
comment|/* The relocation is always an REL32 relocation because we don't        know where the shared library will wind up at load-time.  */
name|outrel
index|[
literal|0
index|]
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|indx
argument_list|,
name|R_MIPS_REL32
argument_list|)
expr_stmt|;
comment|/* For strict adherence to the ABI specification, we should      generate a R_MIPS_64 relocation record by itself before the      _REL32/_64 record as well, such that the addend is read in as      a 64-bit value (REL32 is a 32-bit relocation, after all).      However, since none of the existing ELF64 MIPS dynamic      loaders seems to care, we don't waste space with these      artificial relocations.  If this turns out to not be true,      mips_elf_allocate_dynamic_relocation() should be tweaked so      as to make room for a pair of dynamic relocations per      invocation if ABI_64_P, and here we should generate an      additional relocation record with R_MIPS_64 by itself for a      NULL symbol before this relocation record.  */
name|outrel
index|[
literal|1
index|]
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
condition|?
name|R_MIPS_64
else|:
name|R_MIPS_NONE
argument_list|)
expr_stmt|;
name|outrel
index|[
literal|2
index|]
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|R_MIPS_NONE
argument_list|)
expr_stmt|;
comment|/* Adjust the output offset of the relocation to reference the      correct location in the output file.  */
name|outrel
index|[
literal|0
index|]
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|outrel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|outrel
index|[
literal|2
index|]
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
comment|/* Put the relocation back out.  We have to use the special      relocation outputter in the 64-bit case since the 64-bit      relocation format is non-standard.  */
if|if
condition|(
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
operator|(
operator|*
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|s
operator|->
name|swap_reloc_out
operator|)
operator|(
name|output_bfd
operator|,
operator|&
name|outrel
index|[
literal|0
index|]
operator|,
operator|(
name|sreloc
operator|->
name|contents
operator|+
name|sreloc
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_Mips_External_Rel
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|htab
operator|->
name|is_vxworks
condition|)
block|{
comment|/* VxWorks uses RELA rather than REL dynamic relocations.  */
name|outrel
index|[
literal|0
index|]
operator|.
name|r_addend
operator|=
operator|*
name|addendp
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
index|[
literal|0
index|]
argument_list|,
operator|(
name|sreloc
operator|->
name|contents
operator|+
name|sreloc
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
index|[
literal|0
index|]
argument_list|,
operator|(
name|sreloc
operator|->
name|contents
operator|+
name|sreloc
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* We've now added another relocation.  */
operator|++
name|sreloc
operator|->
name|reloc_count
expr_stmt|;
comment|/* Make sure the output section is writable.  The dynamic linker      will be writing to it.  */
name|elf_section_data
argument_list|(
name|input_section
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_flags
operator||=
name|SHF_WRITE
expr_stmt|;
comment|/* On IRIX5, make an entry of compact relocation info.  */
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|output_bfd
argument_list|)
operator|==
name|ict_irix5
condition|)
block|{
name|asection
modifier|*
name|scpt
init|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".compact_rel"
argument_list|)
decl_stmt|;
name|bfd_byte
modifier|*
name|cr
decl_stmt|;
if|if
condition|(
name|scpt
condition|)
block|{
name|Elf32_crinfo
name|cptrel
decl_stmt|;
name|mips_elf_set_cr_format
argument_list|(
name|cptrel
argument_list|,
name|CRF_MIPS_LONG
argument_list|)
expr_stmt|;
name|cptrel
operator|.
name|vaddr
operator|=
operator|(
name|rel
operator|->
name|r_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_REL32
condition|)
name|mips_elf_set_cr_type
argument_list|(
name|cptrel
argument_list|,
name|CRT_MIPS_REL32
argument_list|)
expr_stmt|;
else|else
name|mips_elf_set_cr_type
argument_list|(
name|cptrel
argument_list|,
name|CRT_MIPS_WORD
argument_list|)
expr_stmt|;
name|mips_elf_set_cr_dist2to
argument_list|(
name|cptrel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cptrel
operator|.
name|konst
operator|=
operator|*
name|addendp
expr_stmt|;
name|cr
operator|=
operator|(
name|scpt
operator|->
name|contents
operator|+
sizeof|sizeof
argument_list|(
name|Elf32_External_compact_rel
argument_list|)
operator|)
expr_stmt|;
name|mips_elf_set_cr_relvaddr
argument_list|(
name|cptrel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_crinfo_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|cptrel
argument_list|,
operator|(
operator|(
name|Elf32_External_crinfo
operator|*
operator|)
name|cr
operator|+
name|scpt
operator|->
name|reloc_count
operator|)
argument_list|)
expr_stmt|;
operator|++
name|scpt
operator|->
name|reloc_count
expr_stmt|;
block|}
block|}
comment|/* If we've written this relocation for a readonly section,      we need to set DF_TEXTREL again, so that we do not delete the      DT_TEXTREL tag.  */
if|if
condition|(
name|MIPS_ELF_READONLY_SECTION
argument_list|(
name|input_section
argument_list|)
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the MACH for a MIPS e_flags value.  */
end_comment

begin_function
name|unsigned
name|long
name|_bfd_elf_mips_mach
parameter_list|(
name|flagword
name|flags
parameter_list|)
block|{
switch|switch
condition|(
name|flags
operator|&
name|EF_MIPS_MACH
condition|)
block|{
case|case
name|E_MIPS_MACH_3900
case|:
return|return
name|bfd_mach_mips3900
return|;
case|case
name|E_MIPS_MACH_4010
case|:
return|return
name|bfd_mach_mips4010
return|;
case|case
name|E_MIPS_MACH_4100
case|:
return|return
name|bfd_mach_mips4100
return|;
case|case
name|E_MIPS_MACH_4111
case|:
return|return
name|bfd_mach_mips4111
return|;
case|case
name|E_MIPS_MACH_4120
case|:
return|return
name|bfd_mach_mips4120
return|;
case|case
name|E_MIPS_MACH_4650
case|:
return|return
name|bfd_mach_mips4650
return|;
case|case
name|E_MIPS_MACH_5400
case|:
return|return
name|bfd_mach_mips5400
return|;
case|case
name|E_MIPS_MACH_5500
case|:
return|return
name|bfd_mach_mips5500
return|;
case|case
name|E_MIPS_MACH_9000
case|:
return|return
name|bfd_mach_mips9000
return|;
case|case
name|E_MIPS_MACH_SB1
case|:
return|return
name|bfd_mach_mips_sb1
return|;
default|default:
switch|switch
condition|(
name|flags
operator|&
name|EF_MIPS_ARCH
condition|)
block|{
default|default:
case|case
name|E_MIPS_ARCH_1
case|:
return|return
name|bfd_mach_mips3000
return|;
case|case
name|E_MIPS_ARCH_2
case|:
return|return
name|bfd_mach_mips6000
return|;
case|case
name|E_MIPS_ARCH_3
case|:
return|return
name|bfd_mach_mips4000
return|;
case|case
name|E_MIPS_ARCH_4
case|:
return|return
name|bfd_mach_mips8000
return|;
case|case
name|E_MIPS_ARCH_5
case|:
return|return
name|bfd_mach_mips5
return|;
case|case
name|E_MIPS_ARCH_32
case|:
return|return
name|bfd_mach_mipsisa32
return|;
case|case
name|E_MIPS_ARCH_64
case|:
return|return
name|bfd_mach_mipsisa64
return|;
case|case
name|E_MIPS_ARCH_32R2
case|:
return|return
name|bfd_mach_mipsisa32r2
return|;
case|case
name|E_MIPS_ARCH_64R2
case|:
return|return
name|bfd_mach_mipsisa64r2
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return printable name for ABI.  */
end_comment

begin_function
specifier|static
name|INLINE
name|char
modifier|*
name|elf_mips_abi_name
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|flagword
name|flags
decl_stmt|;
name|flags
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
switch|switch
condition|(
name|flags
operator|&
name|EF_MIPS_ABI
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|ABI_N32_P
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
literal|"N32"
return|;
elseif|else
if|if
condition|(
name|ABI_64_P
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
literal|"64"
return|;
else|else
return|return
literal|"none"
return|;
case|case
name|E_MIPS_ABI_O32
case|:
return|return
literal|"O32"
return|;
case|case
name|E_MIPS_ABI_O64
case|:
return|return
literal|"O64"
return|;
case|case
name|E_MIPS_ABI_EABI32
case|:
return|return
literal|"EABI32"
return|;
case|case
name|E_MIPS_ABI_EABI64
case|:
return|return
literal|"EABI64"
return|;
default|default:
return|return
literal|"unknown abi"
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* MIPS ELF uses two common sections.  One is the usual one, and the    other is for small objects.  All the small objects are kept    together, and then referenced via the gp pointer, which yields    faster assembler code.  This is what we use for the small common    section.  This approach is copied from ecoff.c.  */
end_comment

begin_decl_stmt
specifier|static
name|asection
name|mips_elf_scom_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
name|mips_elf_scom_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|mips_elf_scom_symbol_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MIPS ELF also uses an acommon section, which represents an    allocated common symbol which may be overridden by a    definition in a shared library.  */
end_comment

begin_decl_stmt
specifier|static
name|asection
name|mips_elf_acom_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
name|mips_elf_acom_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|mips_elf_acom_symbol_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle the special MIPS section numbers that a symbol may use.    This is used for both the 32-bit and the 64-bit ABI.  */
end_comment

begin_function
name|void
name|_bfd_mips_elf_symbol_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asymbol
modifier|*
name|asym
parameter_list|)
block|{
name|elf_symbol_type
modifier|*
name|elfsym
decl_stmt|;
name|elfsym
operator|=
operator|(
name|elf_symbol_type
operator|*
operator|)
name|asym
expr_stmt|;
switch|switch
condition|(
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_shndx
condition|)
block|{
case|case
name|SHN_MIPS_ACOMMON
case|:
comment|/* This section is used in a dynamically linked executable file. 	 It is an allocated common section.  The dynamic linker can 	 either resolve these symbols to something in a shared 	 library, or it can just leave them here.  For our purposes, 	 we can consider these symbols to be in a new section.  */
if|if
condition|(
name|mips_elf_acom_section
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* Initialize the acommon section.  */
name|mips_elf_acom_section
operator|.
name|name
operator|=
literal|".acommon"
expr_stmt|;
name|mips_elf_acom_section
operator|.
name|flags
operator|=
name|SEC_ALLOC
expr_stmt|;
name|mips_elf_acom_section
operator|.
name|output_section
operator|=
operator|&
name|mips_elf_acom_section
expr_stmt|;
name|mips_elf_acom_section
operator|.
name|symbol
operator|=
operator|&
name|mips_elf_acom_symbol
expr_stmt|;
name|mips_elf_acom_section
operator|.
name|symbol_ptr_ptr
operator|=
operator|&
name|mips_elf_acom_symbol_ptr
expr_stmt|;
name|mips_elf_acom_symbol
operator|.
name|name
operator|=
literal|".acommon"
expr_stmt|;
name|mips_elf_acom_symbol
operator|.
name|flags
operator|=
name|BSF_SECTION_SYM
expr_stmt|;
name|mips_elf_acom_symbol
operator|.
name|section
operator|=
operator|&
name|mips_elf_acom_section
expr_stmt|;
name|mips_elf_acom_symbol_ptr
operator|=
operator|&
name|mips_elf_acom_symbol
expr_stmt|;
block|}
name|asym
operator|->
name|section
operator|=
operator|&
name|mips_elf_acom_section
expr_stmt|;
break|break;
case|case
name|SHN_COMMON
case|:
comment|/* Common symbols less than the GP size are automatically 	 treated as SHN_MIPS_SCOMMON symbols on IRIX5.  */
if|if
condition|(
name|asym
operator|->
name|value
operator|>
name|elf_gp_size
argument_list|(
name|abfd
argument_list|)
operator|||
name|ELF_ST_TYPE
argument_list|(
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_info
argument_list|)
operator|==
name|STT_TLS
operator|||
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_irix6
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|SHN_MIPS_SCOMMON
case|:
if|if
condition|(
name|mips_elf_scom_section
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* Initialize the small common section.  */
name|mips_elf_scom_section
operator|.
name|name
operator|=
literal|".scommon"
expr_stmt|;
name|mips_elf_scom_section
operator|.
name|flags
operator|=
name|SEC_IS_COMMON
expr_stmt|;
name|mips_elf_scom_section
operator|.
name|output_section
operator|=
operator|&
name|mips_elf_scom_section
expr_stmt|;
name|mips_elf_scom_section
operator|.
name|symbol
operator|=
operator|&
name|mips_elf_scom_symbol
expr_stmt|;
name|mips_elf_scom_section
operator|.
name|symbol_ptr_ptr
operator|=
operator|&
name|mips_elf_scom_symbol_ptr
expr_stmt|;
name|mips_elf_scom_symbol
operator|.
name|name
operator|=
literal|".scommon"
expr_stmt|;
name|mips_elf_scom_symbol
operator|.
name|flags
operator|=
name|BSF_SECTION_SYM
expr_stmt|;
name|mips_elf_scom_symbol
operator|.
name|section
operator|=
operator|&
name|mips_elf_scom_section
expr_stmt|;
name|mips_elf_scom_symbol_ptr
operator|=
operator|&
name|mips_elf_scom_symbol
expr_stmt|;
block|}
name|asym
operator|->
name|section
operator|=
operator|&
name|mips_elf_scom_section
expr_stmt|;
name|asym
operator|->
name|value
operator|=
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_size
expr_stmt|;
break|break;
case|case
name|SHN_MIPS_SUNDEFINED
case|:
name|asym
operator|->
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
break|break;
case|case
name|SHN_MIPS_TEXT
case|:
block|{
name|asection
modifier|*
name|section
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".text"
argument_list|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|!=
name|NULL
condition|)
block|{
name|asym
operator|->
name|section
operator|=
name|section
expr_stmt|;
comment|/* MIPS_TEXT is a bit special, the address is not an offset 	       to the base of the .text section.  So substract the section 	       base address to make it an offset.  */
name|asym
operator|->
name|value
operator|-=
name|section
operator|->
name|vma
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SHN_MIPS_DATA
case|:
block|{
name|asection
modifier|*
name|section
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".data"
argument_list|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|!=
name|NULL
condition|)
block|{
name|asym
operator|->
name|section
operator|=
name|section
expr_stmt|;
comment|/* MIPS_DATA is a bit special, the address is not an offset 	       to the base of the .data section.  So substract the section 	       base address to make it an offset.  */
name|asym
operator|->
name|value
operator|-=
name|section
operator|->
name|vma
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Implement elf_backend_eh_frame_address_size.  This differs from    the default in the way it handles EABI64.     EABI64 was originally specified as an LP64 ABI, and that is what    -mabi=eabi normally gives on a 64-bit target.  However, gcc has    historically accepted the combination of -mabi=eabi and -mlong32,    and this ILP32 variation has become semi-official over time.    Both forms use elf32 and have pointer-sized FDE addresses.     If an EABI object was generated by GCC 4.0 or above, it will have    an empty .gcc_compiled_longXX section, where XX is the size of longs    in bits.  Unfortunately, ILP32 objects generated by earlier compilers    have no special marking to distinguish them from LP64 objects.     We don't want users of the official LP64 ABI to be punished for the    existence of the ILP32 variant, but at the same time, we don't want    to mistakenly interpret pre-4.0 ILP32 objects as being LP64 objects.    We therefore take the following approach:        - If ABFD contains a .gcc_compiled_longXX section, use it to         determine the pointer size.        - Otherwise check the type of the first relocation.  Assume that         the LP64 ABI is being used if the relocation is of type R_MIPS_64.        - Otherwise punt.     The second check is enough to detect LP64 objects generated by pre-4.0    compilers because, in the kind of output generated by those compilers,    the first relocation will be associated with either a CIE personality    routine or an FDE start address.  Furthermore, the compilers never    used a special (non-pointer) encoding for this ABI.     Checking the relocation type should also be safe because there is no    reason to use R_MIPS_64 in an ILP32 object.  Pre-4.0 compilers never    did so.  */
end_comment

begin_function
name|unsigned
name|int
name|_bfd_mips_elf_eh_frame_address_size
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|ELFCLASS64
condition|)
return|return
literal|8
return|;
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|==
name|E_MIPS_ABI_EABI64
condition|)
block|{
name|bfd_boolean
name|long32_p
decl_stmt|,
name|long64_p
decl_stmt|;
name|long32_p
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".gcc_compiled_long32"
argument_list|)
operator|!=
literal|0
expr_stmt|;
name|long64_p
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".gcc_compiled_long64"
argument_list|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|long32_p
operator|&&
name|long64_p
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|long32_p
condition|)
return|return
literal|4
return|;
if|if
condition|(
name|long64_p
condition|)
return|return
literal|8
return|;
if|if
condition|(
name|sec
operator|->
name|reloc_count
operator|>
literal|0
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|NULL
operator|&&
operator|(
name|ELF32_R_TYPE
argument_list|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
index|[
literal|0
index|]
operator|.
name|r_info
argument_list|)
operator|==
name|R_MIPS_64
operator|)
condition|)
return|return
literal|8
return|;
return|return
literal|0
return|;
block|}
return|return
literal|4
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* There appears to be a bug in the MIPSpro linker that causes GOT_DISP    relocations against two unnamed section symbols to resolve to the    same address.  For example, if we have code like:  	lw	$4,%got_disp(.data)($gp) 	lw	$25,%got_disp(.text)($gp) 	jalr	$25     then the linker will resolve both relocations to .data and the program    will jump there rather than to .text.     We can work around this problem by giving names to local section symbols.    This is also what the MIPSpro tools do.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_name_local_section_symbols
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
return|return
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Work over a section just before writing it out.  This routine is    used by both the 32-bit and the 64-bit ABI.  FIXME: We recognize    sections that need the SHF_MIPS_GPREL flag by name; there has to be    a better way.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_section_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|hdr
parameter_list|)
block|{
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_MIPS_REGINFO
operator|&&
name|hdr
operator|->
name|sh_size
operator|>
literal|0
condition|)
block|{
name|bfd_byte
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|hdr
operator|->
name|sh_size
operator|==
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|hdr
operator|->
name|contents
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_offset
operator|+
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
operator|-
literal|4
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|elf_gp
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_MIPS_OPTIONS
operator|&&
name|hdr
operator|->
name|bfd_section
operator|!=
name|NULL
operator|&&
name|mips_elf_section_data
argument_list|(
name|hdr
operator|->
name|bfd_section
argument_list|)
operator|!=
name|NULL
operator|&&
name|mips_elf_section_data
argument_list|(
name|hdr
operator|->
name|bfd_section
argument_list|)
operator|->
name|u
operator|.
name|tdata
operator|!=
name|NULL
condition|)
block|{
name|bfd_byte
modifier|*
name|contents
decl_stmt|,
modifier|*
name|l
decl_stmt|,
modifier|*
name|lend
decl_stmt|;
comment|/* We stored the section contents in the tdata field in the 	 set_section_contents routine.  We save the section contents 	 so that we don't have to read them again. 	 At this point we know that elf_gp is set, so we can look 	 through the section contents to see if there is an 	 ODK_REGINFO structure.  */
name|contents
operator|=
name|mips_elf_section_data
argument_list|(
name|hdr
operator|->
name|bfd_section
argument_list|)
operator|->
name|u
operator|.
name|tdata
expr_stmt|;
name|l
operator|=
name|contents
expr_stmt|;
name|lend
operator|=
name|contents
operator|+
name|hdr
operator|->
name|sh_size
expr_stmt|;
while|while
condition|(
name|l
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
operator|<=
name|lend
condition|)
block|{
name|Elf_Internal_Options
name|intopt
decl_stmt|;
name|bfd_mips_elf_swap_options_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|Elf_External_Options
operator|*
operator|)
name|l
argument_list|,
operator|&
name|intopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|intopt
operator|.
name|size
operator|<
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: Warning: bad `%s' option size %u smaller than its header"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|MIPS_ELF_OPTIONS_SECTION_NAME
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|intopt
operator|.
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ABI_64_P
argument_list|(
name|abfd
argument_list|)
operator|&&
name|intopt
operator|.
name|kind
operator|==
name|ODK_REGINFO
condition|)
block|{
name|bfd_byte
name|buf
index|[
literal|8
index|]
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|hdr
operator|->
name|sh_offset
operator|+
operator|(
name|l
operator|-
name|contents
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|Elf64_External_RegInfo
argument_list|)
operator|-
literal|8
operator|)
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|H_PUT_64
argument_list|(
name|abfd
argument_list|,
name|elf_gp
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|8
condition|)
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|intopt
operator|.
name|kind
operator|==
name|ODK_REGINFO
condition|)
block|{
name|bfd_byte
name|buf
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|hdr
operator|->
name|sh_offset
operator|+
operator|(
name|l
operator|-
name|contents
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
operator|-
literal|4
operator|)
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|elf_gp
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|FALSE
return|;
block|}
name|l
operator|+=
name|intopt
operator|.
name|size
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hdr
operator|->
name|bfd_section
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit8"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit4"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_ALLOC
operator||
name|SHF_WRITE
operator||
name|SHF_MIPS_GPREL
expr_stmt|;
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_ALLOC
operator||
name|SHF_WRITE
operator||
name|SHF_MIPS_GPREL
expr_stmt|;
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_NOBITS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".srdata"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_ALLOC
operator||
name|SHF_MIPS_GPREL
expr_stmt|;
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".compact_rel"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_flags
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rtproc"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|hdr
operator|->
name|sh_addralign
operator|!=
literal|0
operator|&&
name|hdr
operator|->
name|sh_entsize
operator|==
literal|0
condition|)
block|{
name|unsigned
name|int
name|adjust
decl_stmt|;
name|adjust
operator|=
name|hdr
operator|->
name|sh_size
operator|%
name|hdr
operator|->
name|sh_addralign
expr_stmt|;
if|if
condition|(
name|adjust
operator|!=
literal|0
condition|)
name|hdr
operator|->
name|sh_size
operator|+=
name|hdr
operator|->
name|sh_addralign
operator|-
name|adjust
expr_stmt|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Handle a MIPS specific section when reading an object file.  This    is called when elfcode.h finds a section with an unknown type.    This routine supports both the 32-bit and 64-bit ELF ABI.     FIXME: We need to handle the SHF_MIPS_GPREL flag, but I'm not sure    how to.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_section_from_shdr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|hdr
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|shindex
parameter_list|)
block|{
name|flagword
name|flags
init|=
literal|0
decl_stmt|;
comment|/* There ought to be a place to keep ELF backend specific flags, but      at the moment there isn't one.  We just keep track of the      sections by their name, instead.  Fortunately, the ABI gives      suggested names for all the MIPS specific sections, so we will      probably get away with this.  */
switch|switch
condition|(
name|hdr
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_MIPS_LIBLIST
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".liblist"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|SHT_MIPS_MSYM
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".msym"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|SHT_MIPS_CONFLICT
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".conflict"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|SHT_MIPS_GPTAB
case|:
if|if
condition|(
operator|!
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".gptab."
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|SHT_MIPS_UCODE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".ucode"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|SHT_MIPS_DEBUG
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".mdebug"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|flags
operator|=
name|SEC_DEBUGGING
expr_stmt|;
break|break;
case|case
name|SHT_MIPS_REGINFO
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".reginfo"
argument_list|)
operator|!=
literal|0
operator|||
name|hdr
operator|->
name|sh_size
operator|!=
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|flags
operator|=
operator|(
name|SEC_LINK_ONCE
operator||
name|SEC_LINK_DUPLICATES_SAME_SIZE
operator|)
expr_stmt|;
break|break;
case|case
name|SHT_MIPS_IFACE
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.interfaces"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|SHT_MIPS_CONTENT
case|:
if|if
condition|(
operator|!
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".MIPS.content"
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|SHT_MIPS_OPTIONS
case|:
if|if
condition|(
operator|!
name|MIPS_ELF_OPTIONS_SECTION_NAME_P
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|SHT_MIPS_DWARF
case|:
if|if
condition|(
operator|!
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".debug_"
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|SHT_MIPS_SYMBOL_LIB
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.symlib"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|SHT_MIPS_EVENTS
case|:
if|if
condition|(
operator|!
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".MIPS.events"
argument_list|)
operator|&&
operator|!
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".MIPS.post_rel"
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|,
name|shindex
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|flags
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|,
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|)
operator||
name|flags
operator|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* FIXME: We should record sh_info for a .gptab section.  */
comment|/* For a .reginfo section, set the gp value in the tdata information      from the contents of this section.  We need the gp value while      processing relocs, so we just get it now.  The .reginfo section      is not used in the 64-bit MIPS ELF ABI.  */
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_MIPS_REGINFO
condition|)
block|{
name|Elf32_External_RegInfo
name|ext
decl_stmt|;
name|Elf32_RegInfo
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|,
operator|&
name|ext
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ext
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|bfd_mips_elf32_swap_reginfo_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|ext
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|=
name|s
operator|.
name|ri_gp_value
expr_stmt|;
block|}
comment|/* For a SHT_MIPS_OPTIONS section, look for a ODK_REGINFO entry, and      set the gp value based on what we find.  We may see both      SHT_MIPS_REGINFO and SHT_MIPS_OPTIONS/ODK_REGINFO; in that case,      they should agree.  */
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_MIPS_OPTIONS
condition|)
block|{
name|bfd_byte
modifier|*
name|contents
decl_stmt|,
modifier|*
name|l
decl_stmt|,
modifier|*
name|lend
decl_stmt|;
name|contents
operator|=
name|bfd_malloc
argument_list|(
name|hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|,
name|contents
argument_list|,
literal|0
argument_list|,
name|hdr
operator|->
name|sh_size
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|l
operator|=
name|contents
expr_stmt|;
name|lend
operator|=
name|contents
operator|+
name|hdr
operator|->
name|sh_size
expr_stmt|;
while|while
condition|(
name|l
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
operator|<=
name|lend
condition|)
block|{
name|Elf_Internal_Options
name|intopt
decl_stmt|;
name|bfd_mips_elf_swap_options_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|Elf_External_Options
operator|*
operator|)
name|l
argument_list|,
operator|&
name|intopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|intopt
operator|.
name|size
operator|<
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: Warning: bad `%s' option size %u smaller than its header"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|MIPS_ELF_OPTIONS_SECTION_NAME
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|intopt
operator|.
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ABI_64_P
argument_list|(
name|abfd
argument_list|)
operator|&&
name|intopt
operator|.
name|kind
operator|==
name|ODK_REGINFO
condition|)
block|{
name|Elf64_Internal_RegInfo
name|intreg
decl_stmt|;
name|bfd_mips_elf64_swap_reginfo_in
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|Elf64_External_RegInfo
operator|*
operator|)
operator|(
name|l
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
operator|)
operator|)
argument_list|,
operator|&
name|intreg
argument_list|)
expr_stmt|;
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|=
name|intreg
operator|.
name|ri_gp_value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intopt
operator|.
name|kind
operator|==
name|ODK_REGINFO
condition|)
block|{
name|Elf32_RegInfo
name|intreg
decl_stmt|;
name|bfd_mips_elf32_swap_reginfo_in
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|Elf32_External_RegInfo
operator|*
operator|)
operator|(
name|l
operator|+
sizeof|sizeof
argument_list|(
name|Elf_External_Options
argument_list|)
operator|)
operator|)
argument_list|,
operator|&
name|intreg
argument_list|)
expr_stmt|;
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|=
name|intreg
operator|.
name|ri_gp_value
expr_stmt|;
block|}
name|l
operator|+=
name|intopt
operator|.
name|size
expr_stmt|;
block|}
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the correct type for a MIPS ELF section.  We do this by the    section name, which is a hack, but ought to work.  This routine is    used by both the 32-bit and the 64-bit ABI.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_fake_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|hdr
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".liblist"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_LIBLIST
expr_stmt|;
name|hdr
operator|->
name|sh_info
operator|=
name|sec
operator|->
name|size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_Lib
argument_list|)
expr_stmt|;
comment|/* The sh_link field is set in final_write_processing.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".conflict"
argument_list|)
operator|==
literal|0
condition|)
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_CONFLICT
expr_stmt|;
elseif|else
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".gptab."
argument_list|)
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_GPTAB
expr_stmt|;
name|hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
expr_stmt|;
comment|/* The sh_info field is set in final_write_processing.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".ucode"
argument_list|)
operator|==
literal|0
condition|)
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_UCODE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".mdebug"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_DEBUG
expr_stmt|;
comment|/* In a shared object on IRIX 5.3, the .mdebug section has an          entsize of 0.  FIXME: Does this matter?  */
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
name|hdr
operator|->
name|sh_entsize
operator|=
literal|0
expr_stmt|;
else|else
name|hdr
operator|->
name|sh_entsize
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".reginfo"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_REGINFO
expr_stmt|;
comment|/* In a shared object on IRIX 5.3, the .reginfo section has an          entsize of 0x18.  FIXME: Does this matter?  */
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
name|hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
expr_stmt|;
else|else
name|hdr
operator|->
name|sh_entsize
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".hash"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".dynamic"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".dynstr"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
name|hdr
operator|->
name|sh_entsize
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This isn't how the IRIX6 linker behaves.  */
block|hdr->sh_info = SIZEOF_MIPS_DYNSYM_SECNAMES;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".got"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".srdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit4"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".lit8"
argument_list|)
operator|==
literal|0
condition|)
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_MIPS_GPREL
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.interfaces"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_IFACE
expr_stmt|;
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_MIPS_NOSTRIP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".MIPS.content"
argument_list|)
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_CONTENT
expr_stmt|;
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_MIPS_NOSTRIP
expr_stmt|;
comment|/* The sh_info field is set in final_write_processing.  */
block|}
elseif|else
if|if
condition|(
name|MIPS_ELF_OPTIONS_SECTION_NAME_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_OPTIONS
expr_stmt|;
name|hdr
operator|->
name|sh_entsize
operator|=
literal|1
expr_stmt|;
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_MIPS_NOSTRIP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".debug_"
argument_list|)
condition|)
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_DWARF
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".MIPS.symlib"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_SYMBOL_LIB
expr_stmt|;
comment|/* The sh_link and sh_info fields are set in          final_write_processing.  */
block|}
elseif|else
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".MIPS.events"
argument_list|)
operator|||
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".MIPS.post_rel"
argument_list|)
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_EVENTS
expr_stmt|;
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_MIPS_NOSTRIP
expr_stmt|;
comment|/* The sh_link field is set in final_write_processing.  */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".msym"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_MIPS_MSYM
expr_stmt|;
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_ALLOC
expr_stmt|;
name|hdr
operator|->
name|sh_entsize
operator|=
literal|8
expr_stmt|;
block|}
comment|/* The generic elf_fake_sections will set up REL_HDR using the default    kind of relocations.  We used to set up a second header for the    non-default kind of relocations here, but only NewABI would use    these, and the IRIX ld doesn't like resulting empty RELA sections.    Thus we create those header only on demand now.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Given a BFD section, try to locate the corresponding ELF section    index.  This is used by both the 32-bit and the 64-bit ABI.    Actually, it's not clear to me that the 64-bit ABI supports these,    but for non-PIC objects we will certainly want support for at least    the .scommon section.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_section_from_bfd_section
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
literal|".scommon"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|retval
operator|=
name|SHN_MIPS_SCOMMON
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
literal|".acommon"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|retval
operator|=
name|SHN_MIPS_ACOMMON
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hook called by the linker routine which adds symbols from an object    file.  We must handle the special MIPS section numbers here.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_add_symbol_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|namep
parameter_list|,
name|flagword
modifier|*
name|flagsp
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
modifier|*
name|secp
parameter_list|,
name|bfd_vma
modifier|*
name|valp
parameter_list|)
block|{
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
operator|*
name|namep
argument_list|,
literal|"_rld_new_interface"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Skip IRIX5 rld entry name.  */
operator|*
name|namep
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Shared objects may have a dynamic symbol '_gp_disp' defined as      a SECTION *ABS*.  This causes ld to think it can resolve _gp_disp      by setting a DT_NEEDED for the shared object.  Since _gp_disp is      a magic symbol resolved by the linker, we ignore this bogus definition      of _gp_disp.  New ABI objects do not suffer from this problem so this      is not done for them. */
if|if
condition|(
operator|!
name|NEWABI_P
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
operator|*
name|namep
argument_list|,
literal|"_gp_disp"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|namep
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
switch|switch
condition|(
name|sym
operator|->
name|st_shndx
condition|)
block|{
case|case
name|SHN_COMMON
case|:
comment|/* Common symbols less than the GP size are automatically 	 treated as SHN_MIPS_SCOMMON symbols.  */
if|if
condition|(
name|sym
operator|->
name|st_size
operator|>
name|elf_gp_size
argument_list|(
name|abfd
argument_list|)
operator|||
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_TLS
operator|||
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_irix6
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|SHN_MIPS_SCOMMON
case|:
operator|*
name|secp
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".scommon"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|secp
operator|)
operator|->
name|flags
operator||=
name|SEC_IS_COMMON
expr_stmt|;
operator|*
name|valp
operator|=
name|sym
operator|->
name|st_size
expr_stmt|;
break|break;
case|case
name|SHN_MIPS_TEXT
case|:
comment|/* This section is used in a shared object.  */
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_text_section
operator|==
name|NULL
condition|)
block|{
name|asymbol
modifier|*
name|elf_text_symbol
decl_stmt|;
name|asection
modifier|*
name|elf_text_section
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
decl_stmt|;
name|elf_text_section
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_text_section
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
expr_stmt|;
name|elf_text_symbol
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_text_symbol
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Initialize the section.  */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_text_section
operator|=
name|elf_text_section
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_text_symbol
operator|=
name|elf_text_symbol
expr_stmt|;
name|elf_text_section
operator|->
name|symbol
operator|=
name|elf_text_symbol
expr_stmt|;
name|elf_text_section
operator|->
name|symbol_ptr_ptr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_text_symbol
expr_stmt|;
name|elf_text_section
operator|->
name|name
operator|=
literal|".text"
expr_stmt|;
name|elf_text_section
operator|->
name|flags
operator|=
name|SEC_NO_FLAGS
expr_stmt|;
name|elf_text_section
operator|->
name|output_section
operator|=
name|NULL
expr_stmt|;
name|elf_text_section
operator|->
name|owner
operator|=
name|abfd
expr_stmt|;
name|elf_text_symbol
operator|->
name|name
operator|=
literal|".text"
expr_stmt|;
name|elf_text_symbol
operator|->
name|flags
operator|=
name|BSF_SECTION_SYM
operator||
name|BSF_DYNAMIC
expr_stmt|;
name|elf_text_symbol
operator|->
name|section
operator|=
name|elf_text_section
expr_stmt|;
block|}
comment|/* This code used to do *secp = bfd_und_section_ptr if          info->shared.  I don't know why, and that doesn't make sense,          so I took it out.  */
operator|*
name|secp
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_text_section
expr_stmt|;
break|break;
case|case
name|SHN_MIPS_ACOMMON
case|:
comment|/* Fall through. XXX Can we treat this as allocated data?  */
case|case
name|SHN_MIPS_DATA
case|:
comment|/* This section is used in a shared object.  */
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_data_section
operator|==
name|NULL
condition|)
block|{
name|asymbol
modifier|*
name|elf_data_symbol
decl_stmt|;
name|asection
modifier|*
name|elf_data_section
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|asection
argument_list|)
decl_stmt|;
name|elf_data_section
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_data_section
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
expr_stmt|;
name|elf_data_symbol
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_data_symbol
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Initialize the section.  */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_data_section
operator|=
name|elf_data_section
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_data_symbol
operator|=
name|elf_data_symbol
expr_stmt|;
name|elf_data_section
operator|->
name|symbol
operator|=
name|elf_data_symbol
expr_stmt|;
name|elf_data_section
operator|->
name|symbol_ptr_ptr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_data_symbol
expr_stmt|;
name|elf_data_section
operator|->
name|name
operator|=
literal|".data"
expr_stmt|;
name|elf_data_section
operator|->
name|flags
operator|=
name|SEC_NO_FLAGS
expr_stmt|;
name|elf_data_section
operator|->
name|output_section
operator|=
name|NULL
expr_stmt|;
name|elf_data_section
operator|->
name|owner
operator|=
name|abfd
expr_stmt|;
name|elf_data_symbol
operator|->
name|name
operator|=
literal|".data"
expr_stmt|;
name|elf_data_symbol
operator|->
name|flags
operator|=
name|BSF_SECTION_SYM
operator||
name|BSF_DYNAMIC
expr_stmt|;
name|elf_data_symbol
operator|->
name|section
operator|=
name|elf_data_section
expr_stmt|;
block|}
comment|/* This code used to do *secp = bfd_und_section_ptr if          info->shared.  I don't know why, and that doesn't make sense,          so I took it out.  */
operator|*
name|secp
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_data_section
expr_stmt|;
break|break;
case|case
name|SHN_MIPS_SUNDEFINED
case|:
operator|*
name|secp
operator|=
name|bfd_und_section_ptr
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
name|info
operator|->
name|hash
operator|->
name|creator
operator|==
name|abfd
operator|->
name|xvec
operator|&&
name|strcmp
argument_list|(
operator|*
name|namep
argument_list|,
literal|"__rld_obj_head"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
decl_stmt|;
comment|/* Mark __rld_obj_head as dynamic.  */
name|bh
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
operator|*
name|namep
argument_list|,
name|BSF_GLOBAL
argument_list|,
operator|*
name|secp
argument_list|,
operator|*
name|valp
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|non_elf
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|use_rld_obj_head
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If this is a mips16 text symbol, add 1 to the value to make it      odd.  This will cause something like .word SYM to come up with      the right value when it is loaded into the PC.  */
if|if
condition|(
name|sym
operator|->
name|st_other
operator|==
name|STO_MIPS16
condition|)
operator|++
operator|*
name|valp
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This hook function is called before the linker writes out a global    symbol.  We mark symbols as small common if appropriate.  This is    also where we undo the increment of the value for a mips16 symbol.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_link_output_symbol_hook
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|,
name|asection
modifier|*
name|input_sec
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* If we see a common symbol, which implies a relocatable link, then      if a symbol was small common in an input file, mark it as small      common in the output file.  */
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
operator|&&
name|strcmp
argument_list|(
name|input_sec
operator|->
name|name
argument_list|,
literal|".scommon"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_MIPS_SCOMMON
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|st_other
operator|==
name|STO_MIPS16
condition|)
name|sym
operator|->
name|st_value
operator|&=
operator|~
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for the dynamic linker.  */
end_comment

begin_comment
comment|/* Create dynamic sections when linking against a dynamic object.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_create_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|namep
decl_stmt|;
name|struct
name|mips_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
expr_stmt|;
comment|/* The psABI requires a read-only .dynamic section, but the VxWorks      EABI doesn't.  */
if|if
condition|(
operator|!
name|htab
operator|->
name|is_vxworks
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
comment|/* We need to create .got section.  */
if|if
condition|(
operator|!
name|mips_elf_create_got_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|mips_elf_rel_dyn_section
argument_list|(
name|info
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Create .stub section.  */
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|MIPS_ELF_STUB_SECTION_NAME
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
name|MIPS_ELF_STUB_SECTION_NAME
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|flags
operator||
name|SEC_CODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|MIPS_ELF_LOG_FILE_ALIGN
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_irix5
operator|||
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_none
operator|)
operator|&&
operator|!
name|info
operator|->
name|shared
operator|&&
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rld_map"
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".rld_map"
argument_list|,
name|flags
operator|&
operator|~
operator|(
name|flagword
operator|)
name|SEC_READONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|MIPS_ELF_LOG_FILE_ALIGN
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* On IRIX5, we adjust add some additional symbols and change the      alignments of several sections.  There is no ABI documentation      indicating that this is necessary on IRIX6, nor any evidence that      the linker takes such action.  */
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_irix5
condition|)
block|{
for|for
control|(
name|namep
operator|=
name|mips_elf_dynsym_rtproc_names
init|;
operator|*
name|namep
operator|!=
name|NULL
condition|;
name|namep
operator|++
control|)
block|{
name|bh
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
operator|*
name|namep
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|bfd_und_section_ptr
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|non_elf
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_SECTION
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* We need to create a .compact_rel section.  */
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|mips_elf_create_compact_rel_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Change alignments of some sections.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".hash"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|MIPS_ELF_LOG_FILE_ALIGN
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|MIPS_ELF_LOG_FILE_ALIGN
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynstr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|MIPS_ELF_LOG_FILE_ALIGN
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".reginfo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|MIPS_ELF_LOG_FILE_ALIGN
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|MIPS_ELF_LOG_FILE_ALIGN
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|?
literal|"_DYNAMIC_LINK"
else|:
literal|"_DYNAMIC_LINKING"
expr_stmt|;
name|bh
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|bfd_abs_section_ptr
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|non_elf
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_SECTION
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|use_rld_obj_head
condition|)
block|{
comment|/* __rld_map is a four byte word located in the .data section 	     and is filled in by the rtld to contain a pointer to 	     the _r_debug structure. Its symbol value will be set in 	     _bfd_mips_elf_finish_dynamic_symbol.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rld_map"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|name
operator|=
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|?
literal|"__rld_map"
else|:
literal|"__RLD_MAP"
expr_stmt|;
name|bh
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|non_elf
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|htab
operator|->
name|is_vxworks
condition|)
block|{
comment|/* Create the .plt, .rela.plt, .dynbss and .rela.bss sections. 	 Also create the _PROCEDURE_LINKAGE_TABLE symbol.  */
if|if
condition|(
operator|!
name|_bfd_elf_create_dynamic_sections
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Cache the sections created above.  */
name|htab
operator|->
name|sdynbss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|srelbss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rela.bss"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|srelplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|sdynbss
operator|||
operator|(
operator|!
name|htab
operator|->
name|srelbss
operator|&&
operator|!
name|info
operator|->
name|shared
operator|)
operator|||
operator|!
name|htab
operator|->
name|srelplt
operator|||
operator|!
name|htab
operator|->
name|splt
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Do the usual VxWorks handling.  */
if|if
condition|(
operator|!
name|elf_vxworks_create_dynamic_sections
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
operator|&
name|htab
operator|->
name|srelplt2
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Work out the PLT sizes.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|htab
operator|->
name|plt_header_size
operator|=
literal|4
operator|*
name|ARRAY_SIZE
argument_list|(
name|mips_vxworks_shared_plt0_entry
argument_list|)
expr_stmt|;
name|htab
operator|->
name|plt_entry_size
operator|=
literal|4
operator|*
name|ARRAY_SIZE
argument_list|(
name|mips_vxworks_shared_plt_entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|htab
operator|->
name|plt_header_size
operator|=
literal|4
operator|*
name|ARRAY_SIZE
argument_list|(
name|mips_vxworks_exec_plt0_entry
argument_list|)
expr_stmt|;
name|htab
operator|->
name|plt_entry_size
operator|=
literal|4
operator|*
name|ARRAY_SIZE
argument_list|(
name|mips_vxworks_exec_plt_entry
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look through the relocs for a section during the first phase, and    allocate space in the global offset table.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_check_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|struct
name|mips_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|htab
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|extsymoff
operator|=
operator|(
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
operator|)
condition|?
literal|0
else|:
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
comment|/* Check for the mips16 stub sections.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|FN_STUB_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
comment|/* Look at the relocation information to figure out which symbol          this is for.  */
name|r_symndx
operator|=
name|ELF_R_SYM
argument_list|(
name|abfd
argument_list|,
name|relocs
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|extsymoff
operator|||
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|==
name|NULL
condition|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
comment|/* This stub is for a local symbol.  This stub will only be              needed if there is some relocation in this BFD, other              than a 16 bit function call, which refers to this symbol.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|sec_relocs
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|r
decl_stmt|,
modifier|*
name|rend
decl_stmt|;
comment|/* We can ignore stub sections when looking for relocs.  */
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|o
operator|->
name|reloc_count
operator|==
literal|0
operator|||
name|mips16_stub_section_p
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
condition|)
continue|continue;
name|sec_relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec_relocs
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|rend
operator|=
name|sec_relocs
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|r
operator|=
name|sec_relocs
init|;
name|r
operator|<
name|rend
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|ELF_R_SYM
argument_list|(
name|abfd
argument_list|,
name|r
operator|->
name|r_info
argument_list|)
operator|==
name|r_symndx
operator|&&
name|ELF_R_TYPE
argument_list|(
name|abfd
argument_list|,
name|r
operator|->
name|r_info
argument_list|)
operator|!=
name|R_MIPS16_26
condition|)
break|break;
if|if
condition|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|relocs
operator|!=
name|sec_relocs
condition|)
name|free
argument_list|(
name|sec_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|rend
condition|)
break|break;
block|}
if|if
condition|(
name|o
operator|==
name|NULL
condition|)
block|{
comment|/* There is no non-call reloc for this stub, so we do                  not need it.  Since this function is called before                  the linker maps input sections to output sections, we                  can easily discard it by setting the SEC_EXCLUDE                  flag.  */
name|sec
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Record this stub in an array of local symbol stubs for              this BFD.  */
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_stubs
operator|==
name|NULL
condition|)
block|{
name|unsigned
name|long
name|symcount
decl_stmt|;
name|asection
modifier|*
modifier|*
name|n
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|symcount
operator|=
name|NUM_SHDR_ENTRIES
argument_list|(
name|symtab_hdr
argument_list|)
expr_stmt|;
else|else
name|symcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|amt
operator|=
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|n
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_stubs
operator|=
name|n
expr_stmt|;
block|}
name|sec
operator|->
name|flags
operator||=
name|SEC_KEEP
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_stubs
index|[
name|r_symndx
index|]
operator|=
name|sec
expr_stmt|;
comment|/* We don't need to set mips16_stubs_seen in this case.              That flag is used to see whether we need to look through              the global symbol table for stubs.  We don't need to set              it here, because we just have a local stub.  */
block|}
else|else
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|)
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* H is the symbol this stub is for.  */
comment|/* If we already have an appropriate stub for this function, we 	     don't need another one, so we can discard this one.  Since 	     this function is called before the linker maps input sections 	     to output sections, we can easily discard it by setting the 	     SEC_EXCLUDE flag.  */
if|if
condition|(
name|h
operator|->
name|fn_stub
operator|!=
name|NULL
condition|)
block|{
name|sec
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|sec
operator|->
name|flags
operator||=
name|SEC_KEEP
expr_stmt|;
name|h
operator|->
name|fn_stub
operator|=
name|sec
expr_stmt|;
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|mips16_stubs_seen
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|CALL_STUB_P
argument_list|(
name|name
argument_list|)
operator|||
name|CALL_FP_STUB_P
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|asection
modifier|*
modifier|*
name|loc
decl_stmt|;
comment|/* Look at the relocation information to figure out which symbol          this is for.  */
name|r_symndx
operator|=
name|ELF_R_SYM
argument_list|(
name|abfd
argument_list|,
name|relocs
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|extsymoff
operator|||
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|==
name|NULL
condition|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
comment|/* This stub is for a local symbol.  This stub will only be              needed if there is some relocation (R_MIPS16_26) in this BFD              that refers to this symbol.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|sec_relocs
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|r
decl_stmt|,
modifier|*
name|rend
decl_stmt|;
comment|/* We can ignore stub sections when looking for relocs.  */
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|o
operator|->
name|reloc_count
operator|==
literal|0
operator|||
name|mips16_stub_section_p
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
condition|)
continue|continue;
name|sec_relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec_relocs
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|rend
operator|=
name|sec_relocs
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|r
operator|=
name|sec_relocs
init|;
name|r
operator|<
name|rend
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|ELF_R_SYM
argument_list|(
name|abfd
argument_list|,
name|r
operator|->
name|r_info
argument_list|)
operator|==
name|r_symndx
operator|&&
name|ELF_R_TYPE
argument_list|(
name|abfd
argument_list|,
name|r
operator|->
name|r_info
argument_list|)
operator|==
name|R_MIPS16_26
condition|)
break|break;
if|if
condition|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|relocs
operator|!=
name|sec_relocs
condition|)
name|free
argument_list|(
name|sec_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|rend
condition|)
break|break;
block|}
if|if
condition|(
name|o
operator|==
name|NULL
condition|)
block|{
comment|/* There is no non-call reloc for this stub, so we do                  not need it.  Since this function is called before                  the linker maps input sections to output sections, we                  can easily discard it by setting the SEC_EXCLUDE                  flag.  */
name|sec
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Record this stub in an array of local symbol call_stubs for              this BFD.  */
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_call_stubs
operator|==
name|NULL
condition|)
block|{
name|unsigned
name|long
name|symcount
decl_stmt|;
name|asection
modifier|*
modifier|*
name|n
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|symcount
operator|=
name|NUM_SHDR_ENTRIES
argument_list|(
name|symtab_hdr
argument_list|)
expr_stmt|;
else|else
name|symcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|amt
operator|=
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|n
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_call_stubs
operator|=
name|n
expr_stmt|;
block|}
name|sec
operator|->
name|flags
operator||=
name|SEC_KEEP
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_call_stubs
index|[
name|r_symndx
index|]
operator|=
name|sec
expr_stmt|;
comment|/* We don't need to set mips16_stubs_seen in this case.              That flag is used to see whether we need to look through              the global symbol table for stubs.  We don't need to set              it here, because we just have a local stub.  */
block|}
else|else
block|{
name|h
operator|=
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|)
expr_stmt|;
comment|/* H is the symbol this stub is for.  */
if|if
condition|(
name|CALL_FP_STUB_P
argument_list|(
name|name
argument_list|)
condition|)
name|loc
operator|=
operator|&
name|h
operator|->
name|call_fp_stub
expr_stmt|;
else|else
name|loc
operator|=
operator|&
name|h
operator|->
name|call_stub
expr_stmt|;
comment|/* If we already have an appropriate stub for this function, we 	     don't need another one, so we can discard this one.  Since 	     this function is called before the linker maps input sections 	     to output sections, we can easily discard it by setting the 	     SEC_EXCLUDE flag.  */
if|if
condition|(
operator|*
name|loc
operator|!=
name|NULL
condition|)
block|{
name|sec
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|sec
operator|->
name|flags
operator||=
name|SEC_KEEP
expr_stmt|;
operator|*
name|loc
operator|=
name|sec
expr_stmt|;
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|mips16_stubs_seen
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
block|{
name|sgot
operator|=
name|NULL
expr_stmt|;
name|g
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|sgot
operator|=
name|mips_elf_got_section
argument_list|(
name|dynobj
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
name|g
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|mips_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
name|mips_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|u
operator|.
name|got_info
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
operator|++
name|rel
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|unsigned
name|int
name|r_type
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|r_symndx
operator|=
name|ELF_R_SYM
argument_list|(
name|abfd
argument_list|,
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF_R_TYPE
argument_list|(
name|abfd
argument_list|,
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|extsymoff
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|r_symndx
operator|>=
name|extsymoff
operator|+
name|NUM_SHDR_ENTRIES
argument_list|(
name|symtab_hdr
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: Malformed reloc detected for section %s"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
expr_stmt|;
comment|/* This may be an indirect symbol created because of a version.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
block|}
comment|/* Some relocs require a global offset table.  */
if|if
condition|(
name|dynobj
operator|==
name|NULL
operator|||
name|sgot
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_MIPS_GOT16
case|:
case|case
name|R_MIPS_CALL16
case|:
case|case
name|R_MIPS_CALL_HI16
case|:
case|case
name|R_MIPS_CALL_LO16
case|:
case|case
name|R_MIPS_GOT_HI16
case|:
case|case
name|R_MIPS_GOT_LO16
case|:
case|case
name|R_MIPS_GOT_PAGE
case|:
case|case
name|R_MIPS_GOT_OFST
case|:
case|case
name|R_MIPS_GOT_DISP
case|:
case|case
name|R_MIPS_TLS_GOTTPREL
case|:
case|case
name|R_MIPS_TLS_GD
case|:
case|case
name|R_MIPS_TLS_LDM
case|:
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|mips_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|g
operator|=
name|mips_elf_got_info
argument_list|(
name|dynobj
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|is_vxworks
operator|&&
operator|!
name|info
operator|->
name|shared
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: GOT reloc at 0x%lx not expected in executables"
argument_list|)
argument_list|,
name|abfd
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
case|case
name|R_MIPS_32
case|:
case|case
name|R_MIPS_REL32
case|:
case|case
name|R_MIPS_64
case|:
comment|/* In VxWorks executables, references to external symbols 		 are handled using copy relocs or PLT stubs, so there's 		 no need to add a dynamic relocation here.  */
if|if
condition|(
name|dynobj
operator|==
name|NULL
operator|&&
operator|(
name|info
operator|->
name|shared
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
operator|!
name|htab
operator|->
name|is_vxworks
operator|)
operator|)
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|h
condition|)
block|{
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_relocation_target
operator|=
name|TRUE
expr_stmt|;
comment|/* Relocations against the special VxWorks __GOTT_BASE__ and 	     __GOTT_INDEX__ symbols must be left to the loader.  Allocate 	     room for them in .rela.dyn.  */
if|if
condition|(
name|is_gott_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|sreloc
operator|=
name|mips_elf_rel_dyn_section
argument_list|(
name|info
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
name|mips_elf_allocate_dynamic_relocations
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|MIPS_ELF_READONLY_SECTION
argument_list|(
name|sec
argument_list|)
condition|)
comment|/* We tell the dynamic linker that there are 		   relocations against the text segment.  */
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_CALL_LO16
operator|||
name|r_type
operator|==
name|R_MIPS_GOT_LO16
operator|||
name|r_type
operator|==
name|R_MIPS_GOT_DISP
operator|||
operator|(
name|r_type
operator|==
name|R_MIPS_GOT16
operator|&&
name|htab
operator|->
name|is_vxworks
operator|)
condition|)
block|{
comment|/* We may need a local GOT entry for this relocation.  We 	     don't count R_MIPS_GOT_PAGE because we can estimate the 	     maximum number of pages needed by looking at the size of 	     the segment.  Similar comments apply to R_MIPS_GOT16 and 	     R_MIPS_CALL16, except on VxWorks, where GOT relocations 	     always evaluate to "G".  We don't count R_MIPS_GOT_HI16, or 	     R_MIPS_CALL_HI16 because these are always followed by an 	     R_MIPS_GOT_LO16 or R_MIPS_CALL_LO16.  */
if|if
condition|(
operator|!
name|mips_elf_record_local_got_symbol
argument_list|(
name|abfd
argument_list|,
name|r_symndx
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|g
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_MIPS_CALL16
case|:
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: CALL16 reloc at 0x%lx not against global symbol"
argument_list|)
argument_list|,
name|abfd
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Fall through.  */
case|case
name|R_MIPS_CALL_HI16
case|:
case|case
name|R_MIPS_CALL_LO16
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* VxWorks call relocations point the function's .got.plt 		 entry, which will be allocated by adjust_dynamic_symbol. 		 Otherwise, this symbol requires a global GOT entry.  */
if|if
condition|(
operator|!
name|htab
operator|->
name|is_vxworks
operator|&&
operator|!
name|mips_elf_record_global_got_symbol
argument_list|(
name|h
argument_list|,
name|abfd
argument_list|,
name|info
argument_list|,
name|g
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* We need a stub, not a plt entry for the undefined 		 function.  But we record it as if it needs plt.  See 		 _bfd_elf_adjust_dynamic_symbol.  */
name|h
operator|->
name|needs_plt
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_FUNC
expr_stmt|;
block|}
break|break;
case|case
name|R_MIPS_GOT_PAGE
case|:
comment|/* If this is a global, overridable symbol, GOT_PAGE will 	     decay to GOT_DISP, so we'll need a GOT entry for it.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
break|break;
else|else
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|hmips
init|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
decl_stmt|;
while|while
condition|(
name|hmips
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|hmips
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|hmips
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|hmips
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|hmips
operator|->
name|root
operator|.
name|def_regular
operator|&&
operator|!
operator|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|info
operator|->
name|symbolic
operator|&&
operator|!
name|hmips
operator|->
name|root
operator|.
name|forced_local
operator|)
condition|)
break|break;
block|}
comment|/* Fall through.  */
case|case
name|R_MIPS_GOT16
case|:
case|case
name|R_MIPS_GOT_HI16
case|:
case|case
name|R_MIPS_GOT_LO16
case|:
case|case
name|R_MIPS_GOT_DISP
case|:
if|if
condition|(
name|h
operator|&&
operator|!
name|mips_elf_record_global_got_symbol
argument_list|(
name|h
argument_list|,
name|abfd
argument_list|,
name|info
argument_list|,
name|g
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|R_MIPS_TLS_GOTTPREL
case|:
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_STATIC_TLS
expr_stmt|;
comment|/* Fall through */
case|case
name|R_MIPS_TLS_LDM
case|:
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_TLS_LDM
condition|)
block|{
name|r_symndx
operator|=
literal|0
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Fall through */
case|case
name|R_MIPS_TLS_GD
case|:
comment|/* This symbol requires a global offset table entry, or two 	     for TLS GD relocations.  */
block|{
name|unsigned
name|char
name|flag
init|=
operator|(
name|r_type
operator|==
name|R_MIPS_TLS_GD
condition|?
name|GOT_TLS_GD
else|:
name|r_type
operator|==
name|R_MIPS_TLS_LDM
condition|?
name|GOT_TLS_LDM
else|:
name|GOT_TLS_IE
operator|)
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|hmips
init|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
decl_stmt|;
name|hmips
operator|->
name|tls_type
operator||=
name|flag
expr_stmt|;
if|if
condition|(
name|h
operator|&&
operator|!
name|mips_elf_record_global_got_symbol
argument_list|(
name|h
argument_list|,
name|abfd
argument_list|,
name|info
argument_list|,
name|g
argument_list|,
name|flag
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|flag
operator|==
name|GOT_TLS_LDM
operator|||
name|r_symndx
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mips_elf_record_local_got_symbol
argument_list|(
name|abfd
argument_list|,
name|r_symndx
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|g
argument_list|,
name|flag
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
break|break;
case|case
name|R_MIPS_32
case|:
case|case
name|R_MIPS_REL32
case|:
case|case
name|R_MIPS_64
case|:
comment|/* In VxWorks executables, references to external symbols 	     are handled using copy relocs or PLT stubs, so there's 	     no need to add a .rela.dyn entry for this relocation.  */
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
operator|!
name|htab
operator|->
name|is_vxworks
operator|)
operator|)
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|sreloc
operator|=
name|mips_elf_rel_dyn_section
argument_list|(
name|info
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* When creating a shared object, we must copy these 		     reloc types into the output file as R_MIPS_REL32 		     relocs.  Make room for this reloc in .rel(a).dyn.  */
name|mips_elf_allocate_dynamic_relocations
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|MIPS_ELF_READONLY_SECTION
argument_list|(
name|sec
argument_list|)
condition|)
comment|/* We tell the dynamic linker that there are 		       relocations against the text segment.  */
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
else|else
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|hmips
decl_stmt|;
comment|/* We only need to copy this reloc if the symbol is                      defined in a dynamic object.  */
name|hmips
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
operator|++
name|hmips
operator|->
name|possibly_dynamic_relocs
expr_stmt|;
if|if
condition|(
name|MIPS_ELF_READONLY_SECTION
argument_list|(
name|sec
argument_list|)
condition|)
comment|/* We need it to tell the dynamic linker if there 		       are relocations against the text segment.  */
name|hmips
operator|->
name|readonly_reloc
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Even though we don't directly need a GOT entry for 		 this symbol, a symbol must have a dynamic symbol 		 table index greater that DT_MIPS_GOTSYM if there are 		 dynamic relocations against it.  This does not apply 		 to VxWorks, which does not have the usual coupling 		 between global GOT entries and .dynsym entries.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|!
name|htab
operator|->
name|is_vxworks
condition|)
block|{
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|mips_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|g
operator|=
name|mips_elf_got_info
argument_list|(
name|dynobj
argument_list|,
operator|&
name|sgot
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mips_elf_record_global_got_symbol
argument_list|(
name|h
argument_list|,
name|abfd
argument_list|,
name|info
argument_list|,
name|g
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|compact_rel_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_crinfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MIPS_PC16
case|:
if|if
condition|(
name|h
condition|)
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_branch_target
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|R_MIPS_26
case|:
if|if
condition|(
name|h
condition|)
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|is_branch_target
operator|=
name|TRUE
expr_stmt|;
comment|/* Fall through.  */
case|case
name|R_MIPS_GPREL16
case|:
case|case
name|R_MIPS_LITERAL
case|:
case|case
name|R_MIPS_GPREL32
case|:
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|compact_rel_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_crinfo
argument_list|)
expr_stmt|;
break|break;
comment|/* This relocation describes the C++ object vtable hierarchy. 	     Reconstruct it for later use during GC.  */
case|case
name|R_MIPS_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually 	     used.  Record for later use during GC.  */
case|case
name|R_MIPS_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
default|default:
break|break;
block|}
comment|/* We must not create a stub for a symbol that has relocations 	 related to taking the function's address.  This doesn't apply to 	 VxWorks, where CALL relocs refer to a .got.plt entry instead of 	 a normal .got entry.  */
if|if
condition|(
operator|!
name|htab
operator|->
name|is_vxworks
operator|&&
name|h
operator|!=
name|NULL
condition|)
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|no_fn_stub
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|R_MIPS_CALL16
case|:
case|case
name|R_MIPS_CALL_HI16
case|:
case|case
name|R_MIPS_CALL_LO16
case|:
case|case
name|R_MIPS_JALR
case|:
break|break;
block|}
comment|/* If this reloc is not a 16 bit call, and it has a global          symbol, then we will need the fn_stub if there is one.          References from a stub section do not count.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|r_type
operator|!=
name|R_MIPS16_26
operator|&&
operator|!
name|mips16_stub_section_p
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
condition|)
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|mh
decl_stmt|;
name|mh
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|mh
operator|->
name|need_fn_stub
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|bfd_boolean
name|_bfd_mips_relax_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|bfd_boolean
modifier|*
name|again
parameter_list|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|size_t
name|extsymoff
decl_stmt|;
name|bfd_boolean
name|changed_contents
init|=
name|FALSE
decl_stmt|;
name|bfd_vma
name|sec_start
init|=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
comment|/* We are not currently changing any sizes, so only one pass.  */
operator|*
name|again
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|link_info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|internal_relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
operator|*
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|extsymoff
operator|=
operator|(
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
operator|)
condition|?
literal|0
else|:
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|symval
decl_stmt|;
name|bfd_signed_vma
name|sym_offset
decl_stmt|;
name|unsigned
name|int
name|r_type
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|unsigned
name|long
name|instruction
decl_stmt|;
comment|/* Turn jalr into bgezal, and jr into beq, if they're marked 	 with a JALR relocation, that indicate where they jump to. 	 This saves some pipeline bubbles.  */
name|r_type
operator|=
name|ELF_R_TYPE
argument_list|(
name|abfd
argument_list|,
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|!=
name|R_MIPS_JALR
condition|)
continue|continue;
name|r_symndx
operator|=
name|ELF_R_SYM
argument_list|(
name|abfd
argument_list|,
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
comment|/* Compute the address of the jump target.  */
if|if
condition|(
name|r_symndx
operator|>=
name|extsymoff
condition|)
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
init|=
operator|(
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
operator|)
decl_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* If a symbol is undefined, or if it may be overridden, 	     skip it.  */
if|if
condition|(
operator|!
operator|(
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|)
operator|||
operator|(
name|link_info
operator|->
name|shared
operator|&&
operator|!
name|link_info
operator|->
name|symbolic
operator|&&
operator|!
name|h
operator|->
name|root
operator|.
name|forced_local
operator|)
condition|)
continue|continue;
name|sym_sec
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|sym_sec
operator|->
name|output_section
condition|)
name|symval
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sym_sec
operator|->
name|output_offset
operator|)
expr_stmt|;
else|else
name|symval
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
else|else
block|{
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
comment|/* Read this BFD's symbols if we haven't done so already.  */
if|if
condition|(
name|isymbuf
operator|==
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|relax_return
goto|;
block|}
name|isym
operator|=
name|isymbuf
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|sym_sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|sym_sec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
name|sym_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|symval
operator|=
name|isym
operator|->
name|st_value
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sym_sec
operator|->
name|output_offset
expr_stmt|;
block|}
comment|/* Compute branch offset, from delay slot of the jump to the 	 branch target.  */
name|sym_offset
operator|=
operator|(
name|symval
operator|+
name|irel
operator|->
name|r_addend
operator|)
operator|-
operator|(
name|sec_start
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|4
operator|)
expr_stmt|;
comment|/* Branch offset must be properly aligned.  */
if|if
condition|(
operator|(
name|sym_offset
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|sym_offset
operator|>>=
literal|2
expr_stmt|;
comment|/* Check that it's in range.  */
if|if
condition|(
name|sym_offset
operator|<
operator|-
literal|0x8000
operator|||
name|sym_offset
operator|>=
literal|0x8000
condition|)
continue|continue;
comment|/* Get the section contents if we haven't done so already.  */
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
block|{
comment|/* Get cached copy if it exists.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|&
name|contents
argument_list|)
condition|)
goto|goto
name|relax_return
goto|;
block|}
block|}
name|instruction
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* If it was jalr<reg>, turn it into bgezal $zero,<target>.  */
if|if
condition|(
operator|(
name|instruction
operator|&
literal|0xfc1fffff
operator|)
operator|==
literal|0x0000f809
condition|)
name|instruction
operator|=
literal|0x04110000
expr_stmt|;
comment|/* If it was jr<reg>, turn it into b<target>.  */
elseif|else
if|if
condition|(
operator|(
name|instruction
operator|&
literal|0xfc1fffff
operator|)
operator|==
literal|0x00000008
condition|)
name|instruction
operator|=
literal|0x10000000
expr_stmt|;
else|else
continue|continue;
name|instruction
operator||=
operator|(
name|sym_offset
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|instruction
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|changed_contents
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
block|{
if|if
condition|(
operator|!
name|changed_contents
operator|&&
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the section contents for elf_link_input_bfd.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
name|relax_return
label|:
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_adjust_dynamic_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|hmips
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|mips_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* Make sure we know what is going on here.  */
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|needs_plt
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
operator|||
operator|(
name|h
operator|->
name|def_dynamic
operator|&&
name|h
operator|->
name|ref_regular
operator|&&
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If this symbol is defined in a dynamic object, we need to copy      any R_MIPS_32 or R_MIPS_REL32 relocs against it into the output      file.  */
name|hmips
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
operator|&&
name|hmips
operator|->
name|possibly_dynamic_relocs
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
condition|)
block|{
name|mips_elf_allocate_dynamic_relocations
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|,
name|hmips
operator|->
name|possibly_dynamic_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|hmips
operator|->
name|readonly_reloc
condition|)
comment|/* We tell the dynamic linker that there are relocations 	   against the text segment.  */
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
comment|/* For a function, create a stub, if allowed.  */
if|if
condition|(
operator|!
name|hmips
operator|->
name|no_fn_stub
operator|&&
name|h
operator|->
name|needs_plt
condition|)
block|{
if|if
condition|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
return|return
name|TRUE
return|;
comment|/* If this symbol is not defined in a regular file, then set 	 the symbol to the stub location.  This is required to make 	 function pointers compare as equal between the normal 	 executable and the shared library.  */
if|if
condition|(
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
comment|/* We need .stub section.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|MIPS_ELF_STUB_SECTION_NAME
argument_list|(
name|dynobj
argument_list|)
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|size
expr_stmt|;
comment|/* XXX Write this stub address somewhere.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|size
expr_stmt|;
comment|/* Make room for this stub code.  */
name|s
operator|->
name|size
operator|+=
name|htab
operator|->
name|function_stub_size
expr_stmt|;
comment|/* The last half word of the stub will be filled with the index 	     of this symbol in .dynsym section.  */
return|return
name|TRUE
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|)
operator|&&
operator|!
name|h
operator|->
name|needs_plt
condition|)
block|{
comment|/* This will set the entry for this symbol in the GOT to 0, and          the dynamic linker will take care of this.  */
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Likewise, for VxWorks.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_vxworks_adjust_dynamic_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|hmips
decl_stmt|;
name|struct
name|mips_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|hmips
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
comment|/* Make sure we know what is going on here.  */
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|needs_plt
operator|||
name|h
operator|->
name|needs_copy
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
operator|||
operator|(
name|h
operator|->
name|def_dynamic
operator|&&
name|h
operator|->
name|ref_regular
operator|&&
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If the symbol is defined by a dynamic object, we need a PLT stub if      either (a) we want to branch to the symbol or (b) we're linking an      executable that needs a canonical function address.  In the latter      case, the canonical address will be the address of the executable's      load stub.  */
if|if
condition|(
operator|(
name|hmips
operator|->
name|is_branch_target
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|&&
name|hmips
operator|->
name|is_relocation_target
operator|)
operator|)
operator|&&
name|h
operator|->
name|def_dynamic
operator|&&
name|h
operator|->
name|ref_regular
operator|&&
operator|!
name|h
operator|->
name|def_regular
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
name|h
operator|->
name|needs_plt
operator|=
literal|1
expr_stmt|;
comment|/* Locally-binding symbols do not need a PLT stub; we can refer to      the functions directly.  */
elseif|else
if|if
condition|(
name|h
operator|->
name|needs_plt
operator|&&
operator|(
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|||
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_DEFAULT
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
operator|)
condition|)
block|{
name|h
operator|->
name|needs_plt
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|h
operator|->
name|needs_plt
condition|)
block|{
comment|/* If this is the first symbol to need a PLT entry, allocate room 	 for the header, and for the header's .rela.plt.unloaded entries.  */
if|if
condition|(
name|htab
operator|->
name|splt
operator|->
name|size
operator|==
literal|0
condition|)
block|{
name|htab
operator|->
name|splt
operator|->
name|size
operator|+=
name|htab
operator|->
name|plt_header_size
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
name|htab
operator|->
name|srelplt2
operator|->
name|size
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
comment|/* Assign the next .plt entry to this symbol.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|htab
operator|->
name|splt
operator|->
name|size
expr_stmt|;
name|htab
operator|->
name|splt
operator|->
name|size
operator|+=
name|htab
operator|->
name|plt_entry_size
expr_stmt|;
comment|/* If the output file has no definition of the symbol, set the 	 symbol's value to the address of the stub.  For executables, 	 point at the PLT load stub rather than the lazy resolution stub; 	 this stub will become the canonical function address.  */
if|if
condition|(
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|htab
operator|->
name|splt
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* Make room for the .got.plt entry and the R_JUMP_SLOT relocation.  */
name|htab
operator|->
name|sgotplt
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
name|htab
operator|->
name|srelplt
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
comment|/* Make room for the .rela.plt.unloaded relocations.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
name|htab
operator|->
name|srelplt2
operator|->
name|size
operator|+=
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* If a function symbol is defined by a dynamic object, and we do not      need a PLT stub for it, the symbol's value should be zero.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|&&
name|h
operator|->
name|def_dynamic
operator|&&
name|h
operator|->
name|ref_regular
operator|&&
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
return|return
name|TRUE
return|;
comment|/* We must allocate the symbol in our .dynbss section, which will      become part of the .bss section of the executable.  There will be      an entry for this symbol in the .dynsym section.  The dynamic      object will contain position independent code, so all references      from the dynamic object to this symbol will go through the global      offset table.  The dynamic linker will use the .dynsym entry to      determine the address it must put in the global offset table, so      both the dynamic object and the regular object will refer to the      same memory location for the variable.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|htab
operator|->
name|srelbss
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|h
operator|->
name|needs_copy
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|_bfd_elf_adjust_dynamic_copy
argument_list|(
name|h
argument_list|,
name|htab
operator|->
name|sdynbss
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the number of dynamic section symbols required by OUTPUT_BFD.    The number might be exact or a worst-case estimate, depending on how    much information is available to elf_backend_omit_section_dynsym at    the current linking stage.  */
end_comment

begin_function
specifier|static
name|bfd_size_type
name|count_section_dynsyms
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd_size_type
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|is_relocatable_executable
condition|)
block|{
name|asection
modifier|*
name|p
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|output_bfd
operator|->
name|sections
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|p
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|p
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|!
call|(
modifier|*
name|bed
operator|->
name|elf_backend_omit_section_dynsym
call|)
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|p
argument_list|)
condition|)
operator|++
name|count
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* This function is called after all the input files have been read,    and the input sections have been assigned to output sections.  We    check for any mips16 stub sections that we can discard.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_always_size_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|asection
modifier|*
name|ri
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bfd_size_type
name|loadable_size
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|local_gotno
decl_stmt|;
name|bfd_size_type
name|dynsymcount
decl_stmt|;
name|bfd
modifier|*
name|sub
decl_stmt|;
name|struct
name|mips_elf_count_tls_arg
name|count_tls_arg
decl_stmt|;
name|struct
name|mips_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* The .reginfo section has a fixed size.  */
name|ri
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".reginfo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ri
operator|!=
name|NULL
condition|)
name|bfd_set_section_size
argument_list|(
name|output_bfd
argument_list|,
name|ri
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|info
operator|->
name|relocatable
operator|||
operator|!
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|mips16_stubs_seen
operator|)
condition|)
name|mips_elf_link_hash_traverse
argument_list|(
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|mips_elf_check_mips16_stubs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
comment|/* Relocatable links don't have it.  */
return|return
name|TRUE
return|;
name|g
operator|=
name|mips_elf_got_info
argument_list|(
name|dynobj
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* Calculate the total loadable size of the output.  That      will give us the maximum number of GOT_PAGE entries      required.  */
for|for
control|(
name|sub
operator|=
name|info
operator|->
name|input_bfds
init|;
name|sub
condition|;
name|sub
operator|=
name|sub
operator|->
name|link_next
control|)
block|{
name|asection
modifier|*
name|subsection
decl_stmt|;
for|for
control|(
name|subsection
operator|=
name|sub
operator|->
name|sections
init|;
name|subsection
condition|;
name|subsection
operator|=
name|subsection
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|loadable_size
operator|+=
operator|(
operator|(
name|subsection
operator|->
name|size
operator|+
literal|0xf
operator|)
operator|&
operator|~
operator|(
name|bfd_size_type
operator|)
literal|0xf
operator|)
expr_stmt|;
block|}
block|}
comment|/* There has to be a global GOT entry for every symbol with      a dynamic symbol table index of DT_MIPS_GOTSYM or      higher.  Therefore, it make sense to put those symbols      that need GOT entries at the end of the symbol table.  We      do that here.  */
if|if
condition|(
operator|!
name|mips_elf_sort_hash_table
argument_list|(
name|info
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|g
operator|->
name|global_gotsym
operator|!=
name|NULL
condition|)
name|i
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
operator|-
name|g
operator|->
name|global_gotsym
operator|->
name|dynindx
expr_stmt|;
else|else
comment|/* If there are no global symbols, or none requiring        relocations, then GLOBAL_GOTSYM will be NULL.  */
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Get a worst-case estimate of the number of dynamic symbols needed.      At this point, dynsymcount does not account for section symbols      and count_section_dynsyms may overestimate the number that will      be needed.  */
name|dynsymcount
operator|=
operator|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
operator|+
name|count_section_dynsyms
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|)
operator|)
expr_stmt|;
comment|/* Determine the size of one stub entry.  */
name|htab
operator|->
name|function_stub_size
operator|=
operator|(
name|dynsymcount
operator|>
literal|0x10000
condition|?
name|MIPS_FUNCTION_STUB_BIG_SIZE
else|:
name|MIPS_FUNCTION_STUB_NORMAL_SIZE
operator|)
expr_stmt|;
comment|/* In the worst case, we'll get one stub per dynamic symbol, plus      one to account for the dummy entry at the end required by IRIX      rld.  */
name|loadable_size
operator|+=
name|htab
operator|->
name|function_stub_size
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|is_vxworks
condition|)
comment|/* There's no need to allocate page entries for VxWorks; R_MIPS_GOT16        relocations against local symbols evaluate to "G", and the EABI does        not include R_MIPS_GOT_PAGE.  */
name|local_gotno
operator|=
literal|0
expr_stmt|;
else|else
comment|/* Assume there are two loadable segments consisting of contiguous        sections.  Is 5 enough?  */
name|local_gotno
operator|=
operator|(
name|loadable_size
operator|>>
literal|16
operator|)
operator|+
literal|5
expr_stmt|;
name|g
operator|->
name|local_gotno
operator|+=
name|local_gotno
expr_stmt|;
name|s
operator|->
name|size
operator|+=
name|g
operator|->
name|local_gotno
operator|*
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|g
operator|->
name|global_gotno
operator|=
name|i
expr_stmt|;
name|s
operator|->
name|size
operator|+=
name|i
operator|*
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* We need to calculate tls_gotno for global symbols at this point      instead of building it up earlier, to avoid doublecounting      entries for one global symbol from multiple input files.  */
name|count_tls_arg
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|count_tls_arg
operator|.
name|needed
operator|=
literal|0
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|mips_elf_count_global_tls_entries
argument_list|,
operator|&
name|count_tls_arg
argument_list|)
expr_stmt|;
name|g
operator|->
name|tls_gotno
operator|+=
name|count_tls_arg
operator|.
name|needed
expr_stmt|;
name|s
operator|->
name|size
operator|+=
name|g
operator|->
name|tls_gotno
operator|*
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|mips_elf_resolve_final_got_entries
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|/* VxWorks does not support multiple GOTs.  It initializes $gp to      __GOTT_BASE__[__GOTT_INDEX__], the value of which is set by the      dynamic loader.  */
if|if
condition|(
operator|!
name|htab
operator|->
name|is_vxworks
operator|&&
name|s
operator|->
name|size
operator|>
name|MIPS_ELF_GOT_MAX_SIZE
argument_list|(
name|info
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|mips_elf_multi_got
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|g
argument_list|,
name|s
argument_list|,
name|local_gotno
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
comment|/* Set up TLS entries for the first GOT.  */
name|g
operator|->
name|tls_assigned_gotno
operator|=
name|g
operator|->
name|global_gotno
operator|+
name|g
operator|->
name|local_gotno
expr_stmt|;
name|htab_traverse
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
name|mips_elf_initialize_tls_index
argument_list|,
name|g
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_size_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|,
modifier|*
name|sreldyn
decl_stmt|;
name|bfd_boolean
name|reltext
decl_stmt|;
name|struct
name|mips_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|=
name|strlen
argument_list|(
name|ELF_DYNAMIC_INTERPRETER
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The check_relocs and adjust_dynamic_symbol entry points have      determined the sizes of the various dynamic sections.  Allocate      memory for them.  */
name|reltext
operator|=
name|FALSE
expr_stmt|;
name|sreldyn
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* It's OK to base decisions on the section name, because none 	 of the dynobj section names depend upon the input files.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".rel"
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|outname
decl_stmt|;
name|asection
modifier|*
name|target
decl_stmt|;
comment|/* If this relocation section applies to a read only                  section, then we probably need a DT_TEXTREL entry.                  If the relocation section is .rel(a).dyn, we always                  assert a DT_TEXTREL entry rather than testing whether                  there exists a relocation to a read only section or                  not.  */
name|outname
operator|=
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|output_section
argument_list|)
expr_stmt|;
name|target
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|outname
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|target
operator|!=
name|NULL
operator|&&
operator|(
name|target
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|target
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|)
operator|||
name|strcmp
argument_list|(
name|outname
argument_list|,
name|MIPS_ELF_REL_DYN_NAME
argument_list|(
name|info
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|reltext
operator|=
name|TRUE
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need 		 to copy relocs into the output file.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|MIPS_ELF_REL_DYN_NAME
argument_list|(
name|info
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
comment|/* If combreloc is enabled, elf_link_sort_relocs() will 		 sort relocations, but in a different way than we do, 		 and before we're done creating relocations.  Also, it 		 will move them around between input sections' 		 relocation's contents, so our sorting would be 		 broken, so don't let it run.  */
name|info
operator|->
name|combreloc
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|htab
operator|->
name|is_vxworks
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".got"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Executables do not need a GOT.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* Allocate relocations for all but the reserved entries.  */
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|g
operator|=
name|mips_elf_got_info
argument_list|(
name|dynobj
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|count
operator|=
operator|(
name|g
operator|->
name|global_gotno
operator|+
name|g
operator|->
name|local_gotno
operator|-
name|MIPS_RESERVED_GOTNO
argument_list|(
name|info
argument_list|)
operator|)
expr_stmt|;
name|mips_elf_allocate_dynamic_relocations
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|htab
operator|->
name|is_vxworks
operator|&&
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".got"
argument_list|)
condition|)
block|{
comment|/* _bfd_mips_elf_always_size_sections() has already done 	     most of the work, but some symbols may have been mapped 	     to versions that we must now resolve in the got_entries 	     hash tables.  */
name|struct
name|mips_got_info
modifier|*
name|gg
init|=
name|mips_elf_got_info
argument_list|(
name|dynobj
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
init|=
name|gg
decl_stmt|;
name|struct
name|mips_elf_set_global_got_offset_arg
name|set_got_offset_arg
decl_stmt|;
name|unsigned
name|int
name|needed_relocs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|gg
operator|->
name|next
condition|)
block|{
name|set_got_offset_arg
operator|.
name|value
operator|=
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|set_got_offset_arg
operator|.
name|info
operator|=
name|info
expr_stmt|;
comment|/* NOTE 2005-02-03: How can this call, or the next, ever 		 find any indirect entries to resolve?  They were all 		 resolved in mips_elf_multi_got.  */
name|mips_elf_resolve_final_got_entries
argument_list|(
name|gg
argument_list|)
expr_stmt|;
for|for
control|(
name|g
operator|=
name|gg
operator|->
name|next
init|;
name|g
operator|&&
name|g
operator|->
name|next
operator|!=
name|gg
condition|;
name|g
operator|=
name|g
operator|->
name|next
control|)
block|{
name|unsigned
name|int
name|save_assign
decl_stmt|;
name|mips_elf_resolve_final_got_entries
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|/* Assign offsets to global GOT entries.  */
name|save_assign
operator|=
name|g
operator|->
name|assigned_gotno
expr_stmt|;
name|g
operator|->
name|assigned_gotno
operator|=
name|g
operator|->
name|local_gotno
expr_stmt|;
name|set_got_offset_arg
operator|.
name|g
operator|=
name|g
expr_stmt|;
name|set_got_offset_arg
operator|.
name|needed_relocs
operator|=
literal|0
expr_stmt|;
name|htab_traverse
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
name|mips_elf_set_global_got_offset
argument_list|,
operator|&
name|set_got_offset_arg
argument_list|)
expr_stmt|;
name|needed_relocs
operator|+=
name|set_got_offset_arg
operator|.
name|needed_relocs
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|->
name|assigned_gotno
operator|-
name|g
operator|->
name|local_gotno
operator|<=
name|g
operator|->
name|global_gotno
argument_list|)
expr_stmt|;
name|g
operator|->
name|assigned_gotno
operator|=
name|save_assign
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|needed_relocs
operator|+=
name|g
operator|->
name|local_gotno
operator|-
name|g
operator|->
name|assigned_gotno
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|->
name|assigned_gotno
operator|==
name|g
operator|->
name|next
operator|->
name|local_gotno
operator|+
name|g
operator|->
name|next
operator|->
name|global_gotno
operator|+
name|g
operator|->
name|next
operator|->
name|tls_gotno
operator|+
name|MIPS_RESERVED_GOTNO
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|struct
name|mips_elf_count_tls_arg
name|arg
decl_stmt|;
name|arg
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|arg
operator|.
name|needed
operator|=
literal|0
expr_stmt|;
name|htab_traverse
argument_list|(
name|gg
operator|->
name|got_entries
argument_list|,
name|mips_elf_count_local_tls_relocs
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|mips_elf_count_global_tls_relocs
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
name|needed_relocs
operator|+=
name|arg
operator|.
name|needed
expr_stmt|;
block|}
if|if
condition|(
name|needed_relocs
condition|)
name|mips_elf_allocate_dynamic_relocations
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|,
name|needed_relocs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|MIPS_ELF_STUB_SECTION_NAME
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* IRIX rld assumes that the function stub isn't at the end 	     of .text section.  So put a dummy.  XXX  */
name|s
operator|->
name|size
operator|+=
name|htab
operator|->
name|function_stub_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|use_rld_obj_head
operator|&&
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".rld_map"
argument_list|)
condition|)
block|{
comment|/* We add a room for __rld_map.  It will be filled in by the 	     rtld to contain a pointer to the _r_debug structure.  */
name|s
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
operator|&&
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".compact_rel"
argument_list|)
condition|)
name|s
operator|->
name|size
operator|+=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|compact_rel_size
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".init"
argument_list|)
operator|&&
name|s
operator|!=
name|htab
operator|->
name|sgotplt
operator|&&
name|s
operator|!=
name|htab
operator|->
name|splt
condition|)
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Allocate memory for this section last, since we may increase its 	 size above.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|MIPS_ELF_REL_DYN_NAME
argument_list|(
name|info
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sreldyn
operator|=
name|s
expr_stmt|;
continue|continue;
block|}
comment|/* Allocate memory for the section contents.  */
name|s
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Allocate memory for the .rel(a).dyn section.  */
if|if
condition|(
name|sreldyn
operator|!=
name|NULL
condition|)
block|{
name|sreldyn
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|sreldyn
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreldyn
operator|->
name|contents
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in _bfd_mips_elf_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  */
comment|/* SGI object has the equivalence of DT_DEBUG in the 	 DT_MIPS_RLD_MAP entry.  This must come first because glibc 	 only fills in DT_MIPS_RLD_MAP (not DT_DEBUG) and GDB only 	 looks at the first one it sees.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_RLD_MAP
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* The DT_DEBUG entry may be filled in by the dynamic linker and 	 used by the debugger.  */
if|if
condition|(
name|info
operator|->
name|executable
operator|&&
operator|!
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
operator|&&
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|reltext
operator|&&
operator|(
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
operator|||
name|htab
operator|->
name|is_vxworks
operator|)
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Clear the DF_TEXTREL flag.  It will be set again if we 	     write out an actual text relocation; we may not, because 	     at this point we do not know whether e.g. any .eh_frame 	     absolute relocations have been converted to PC-relative.  */
name|info
operator|->
name|flags
operator|&=
operator|~
name|DF_TEXTREL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|htab
operator|->
name|is_vxworks
condition|)
block|{
comment|/* VxWorks uses .rela.dyn instead of .rel.dyn.  It does not 	     use any of the DT_MIPS_* tags.  */
if|if
condition|(
name|mips_elf_rel_dyn_section
argument_list|(
name|info
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_RELA
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_RELAENT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|splt
operator|->
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_PLTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|mips_elf_rel_dyn_section
argument_list|(
name|info
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_REL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_RELSZ
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_RELENT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_RLD_VERSION
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_FLAGS
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_BASE_ADDRESS
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_LOCAL_GOTNO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_SYMTABNO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_UNREFEXTNO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_GOTSYM
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|dynobj
argument_list|)
operator|==
name|ict_irix5
operator|&&
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_HIPAGENO
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|dynobj
argument_list|)
operator|==
name|ict_irix6
operator|&&
operator|(
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|MIPS_ELF_OPTIONS_SECTION_NAME
argument_list|(
name|dynobj
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|MIPS_ELF_ADD_DYNAMIC_ENTRY
argument_list|(
name|info
argument_list|,
name|DT_MIPS_OPTIONS
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* REL is a relocation in INPUT_BFD that is being copied to OUTPUT_BFD.    Adjust its R_ADDEND field so that it is correct for the output file.    LOCAL_SYMS and LOCAL_SECTIONS are arrays of INPUT_BFD's local symbols    and sections respectively; both use symbol indexes.  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf_adjust_addend
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|)
block|{
name|unsigned
name|int
name|r_type
decl_stmt|,
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
if|if
condition|(
name|mips_elf_local_relocation_p
argument_list|(
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|local_sections
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|r_type
operator|=
name|ELF_R_TYPE
argument_list|(
name|output_bfd
argument_list|,
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_GPREL
operator|||
name|r_type
operator|==
name|R_MIPS_GPREL16
operator|||
name|r_type
operator|==
name|R_MIPS_GPREL32
operator|||
name|r_type
operator|==
name|R_MIPS_LITERAL
condition|)
block|{
name|rel
operator|->
name|r_addend
operator|+=
name|_bfd_get_gp_value
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|-=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
block|}
name|r_symndx
operator|=
name|ELF_R_SYM
argument_list|(
name|output_bfd
argument_list|,
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
comment|/* Adjust REL's addend to account for section merging.  */
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
condition|)
block|{
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
comment|/* This would normally be done by the rela_normal code in elflink.c.  */
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
name|rel
operator|->
name|r_addend
operator|+=
name|local_sections
index|[
name|r_symndx
index|]
operator|->
name|output_offset
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Relocate a MIPS ELF section.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|bfd_vma
name|addend
init|=
literal|0
decl_stmt|;
name|bfd_boolean
name|use_saved_addend_p
init|=
name|FALSE
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
decl_stmt|;
name|bed
operator|=
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
operator|++
name|rel
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_vma
name|value
init|=
literal|0
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|bfd_boolean
name|require_jalx
decl_stmt|;
comment|/* TRUE if the relocation is a RELA relocation, rather than a          REL relocation.  */
name|bfd_boolean
name|rela_relocation_p
init|=
name|TRUE
decl_stmt|;
name|unsigned
name|int
name|r_type
init|=
name|ELF_R_TYPE
argument_list|(
name|output_bfd
argument_list|,
name|rel
operator|->
name|r_info
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* Find the relocation howto for this relocation.  */
name|howto
operator|=
name|MIPS_ELF_RTYPE_TO_HOWTO
argument_list|(
name|input_bfd
argument_list|,
name|r_type
argument_list|,
name|NEWABI_P
argument_list|(
name|input_bfd
argument_list|)
operator|&&
operator|(
name|MIPS_RELOC_RELA_P
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|-
name|relocs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|ELF_R_SYM
argument_list|(
name|input_bfd
argument_list|,
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|mips_elf_local_relocation_p
argument_list|(
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|local_sections
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|extsymoff
decl_stmt|;
name|extsymoff
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
condition|)
name|extsymoff
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|r_symndx
operator|-
name|extsymoff
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
block|}
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|elf_discarded_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
comment|/* For relocs against symbols from removed linkonce sections, 	     or sections discarded by a linker script, we just want the 	     section contents zeroed.  Avoid any special processing.  */
name|_bfd_clear_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_64
operator|&&
operator|!
name|NEWABI_P
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
comment|/* Some 32-bit code uses R_MIPS_64.  In particular, people use 	     64-bit code, but make sure all their addresses are in the 	     lowermost or uppermost 32-bit section of the 64-bit address 	     space.  Thus, when they use an R_MIPS_64 they mean what is 	     usually meant by R_MIPS_32, with the exception that the 	     stored value is sign-extended to 64 bits.  */
name|howto
operator|=
name|MIPS_ELF_RTYPE_TO_HOWTO
argument_list|(
name|input_bfd
argument_list|,
name|R_MIPS_32
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* On big-endian systems, we need to lie about the position 	     of the reloc.  */
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
name|rel
operator|->
name|r_offset
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|use_saved_addend_p
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
decl_stmt|;
comment|/* If these relocations were originally of the REL variety, 	     we must pull the addend out of the field that will be 	     relocated.  Otherwise, we simply use the contents of the 	     RELA relocation.  To determine which flavor or relocation 	     this is, we depend on the fact that the INPUT_SECTION's 	     REL_HDR is read before its REL_HDR2.  */
name|rel_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|rel
operator|-
name|relocs
argument_list|)
operator|>=
operator|(
name|NUM_SHDR_ENTRIES
argument_list|(
name|rel_hdr
argument_list|)
operator|*
name|bed
operator|->
name|s
operator|->
name|int_rels_per_ext_rel
operator|)
condition|)
name|rel_hdr
operator|=
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|rel_hdr2
expr_stmt|;
if|if
condition|(
name|rel_hdr
operator|->
name|sh_entsize
operator|==
name|MIPS_ELF_REL_SIZE
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
name|bfd_byte
modifier|*
name|location
init|=
name|contents
operator|+
name|rel
operator|->
name|r_offset
decl_stmt|;
comment|/* Note that this is a REL relocation.  */
name|rela_relocation_p
operator|=
name|FALSE
expr_stmt|;
comment|/* Get the addend, which is stored in the input file.  */
name|_bfd_mips16_elf_reloc_unshuffle
argument_list|(
name|input_bfd
argument_list|,
name|r_type
argument_list|,
name|FALSE
argument_list|,
name|location
argument_list|)
expr_stmt|;
name|addend
operator|=
name|mips_elf_obtain_contents
argument_list|(
name|howto
argument_list|,
name|rel
argument_list|,
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|_bfd_mips16_elf_reloc_shuffle
argument_list|(
name|input_bfd
argument_list|,
name|r_type
argument_list|,
name|FALSE
argument_list|,
name|location
argument_list|)
expr_stmt|;
name|addend
operator|&=
name|howto
operator|->
name|src_mask
expr_stmt|;
comment|/* For some kinds of relocations, the ADDEND is a 		 combination of the addend stored in two different 		 relocations.   */
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_HI16
operator|||
name|r_type
operator|==
name|R_MIPS16_HI16
operator|||
operator|(
name|r_type
operator|==
name|R_MIPS_GOT16
operator|&&
name|mips_elf_local_relocation_p
argument_list|(
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|local_sections
argument_list|,
name|FALSE
argument_list|)
operator|)
condition|)
block|{
specifier|const
name|Elf_Internal_Rela
modifier|*
name|lo16_relocation
decl_stmt|;
name|reloc_howto_type
modifier|*
name|lo16_howto
decl_stmt|;
name|int
name|lo16_type
decl_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_MIPS16_HI16
condition|)
name|lo16_type
operator|=
name|R_MIPS16_LO16
expr_stmt|;
else|else
name|lo16_type
operator|=
name|R_MIPS_LO16
expr_stmt|;
comment|/* The combined value is the sum of the HI16 addend, 		     left-shifted by sixteen bits, and the LO16 		     addend, sign extended.  (Usually, the code does 		     a `lui' of the HI16 value, and then an `addiu' of 		     the LO16 value.)  		     Scan ahead to find a matching LO16 relocation.  		     According to the MIPS ELF ABI, the R_MIPS_LO16 		     relocation must be immediately following. 		     However, for the IRIX6 ABI, the next relocation 		     may be a composed relocation consisting of 		     several relocations for the same address.  In 		     that case, the R_MIPS_LO16 relocation may occur 		     as one of these.  We permit a similar extension 		     in general, as that is useful for GCC.  		     In some cases GCC dead code elimination removes 		     the LO16 but keeps the corresponding HI16.  This 		     is strictly speaking a violation of the ABI but 		     not immediately harmful.  */
name|lo16_relocation
operator|=
name|mips_elf_next_relocation
argument_list|(
name|input_bfd
argument_list|,
name|lo16_type
argument_list|,
name|rel
argument_list|,
name|relend
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo16_relocation
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|h
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
name|name
operator|=
name|bfd_elf_sym_name
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|local_syms
operator|+
name|r_symndx
argument_list|,
name|sec
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: Can't find matching LO16 reloc against `%s' for %s at 0x%lx in section `%A'"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_byte
modifier|*
name|lo16_location
decl_stmt|;
name|bfd_vma
name|l
decl_stmt|;
name|lo16_location
operator|=
name|contents
operator|+
name|lo16_relocation
operator|->
name|r_offset
expr_stmt|;
comment|/* Obtain the addend kept there.  */
name|lo16_howto
operator|=
name|MIPS_ELF_RTYPE_TO_HOWTO
argument_list|(
name|input_bfd
argument_list|,
name|lo16_type
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|_bfd_mips16_elf_reloc_unshuffle
argument_list|(
name|input_bfd
argument_list|,
name|lo16_type
argument_list|,
name|FALSE
argument_list|,
name|lo16_location
argument_list|)
expr_stmt|;
name|l
operator|=
name|mips_elf_obtain_contents
argument_list|(
name|lo16_howto
argument_list|,
name|lo16_relocation
argument_list|,
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|_bfd_mips16_elf_reloc_shuffle
argument_list|(
name|input_bfd
argument_list|,
name|lo16_type
argument_list|,
name|FALSE
argument_list|,
name|lo16_location
argument_list|)
expr_stmt|;
name|l
operator|&=
name|lo16_howto
operator|->
name|src_mask
expr_stmt|;
name|l
operator|<<=
name|lo16_howto
operator|->
name|rightshift
expr_stmt|;
name|l
operator|=
name|_bfd_mips_elf_sign_extend
argument_list|(
name|l
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|addend
operator|<<=
literal|16
expr_stmt|;
comment|/* Compute the combined addend.  */
name|addend
operator|+=
name|l
expr_stmt|;
block|}
block|}
else|else
name|addend
operator|<<=
name|howto
operator|->
name|rightshift
expr_stmt|;
block|}
else|else
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|mips_elf_adjust_addend
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_bfd
argument_list|,
name|local_syms
argument_list|,
name|local_sections
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
block|{
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_64
operator|&&
operator|!
name|NEWABI_P
argument_list|(
name|output_bfd
argument_list|)
operator|&&
name|bfd_big_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
name|rel
operator|->
name|r_offset
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|rela_relocation_p
operator|&&
name|rel
operator|->
name|r_addend
condition|)
block|{
name|addend
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_HI16
operator|||
name|r_type
operator|==
name|R_MIPS_GOT16
condition|)
name|addend
operator|=
name|mips_elf_high
argument_list|(
name|addend
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_HIGHER
condition|)
name|addend
operator|=
name|mips_elf_higher
argument_list|(
name|addend
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_HIGHEST
condition|)
name|addend
operator|=
name|mips_elf_highest
argument_list|(
name|addend
argument_list|)
expr_stmt|;
else|else
name|addend
operator|>>=
name|howto
operator|->
name|rightshift
expr_stmt|;
comment|/* We use the source mask, rather than the destination 		 mask because the place to which we are writing will be 		 source of the addend in the final link.  */
name|addend
operator|&=
name|howto
operator|->
name|src_mask
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_64
operator|&&
operator|!
name|NEWABI_P
argument_list|(
name|output_bfd
argument_list|)
condition|)
comment|/* See the comment above about using R_MIPS_64 in the 32-bit 		   ABI.  Here, we need to update the addend.  It would be 		   possible to get away with just using the R_MIPS_32 reloc 		   but for endianness.  */
block|{
name|bfd_vma
name|sign_bits
decl_stmt|;
name|bfd_vma
name|low_bits
decl_stmt|;
name|bfd_vma
name|high_bits
decl_stmt|;
if|if
condition|(
name|addend
operator|&
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|31
operator|)
condition|)
ifdef|#
directive|ifdef
name|BFD64
name|sign_bits
operator|=
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|32
operator|)
operator|-
literal|1
expr_stmt|;
else|#
directive|else
name|sign_bits
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
else|else
name|sign_bits
operator|=
literal|0
expr_stmt|;
comment|/* If we don't know that we have a 64-bit type, 		     do two separate stores.  */
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
comment|/* Store the sign-bits (which are most significant) 			 first.  */
name|low_bits
operator|=
name|sign_bits
expr_stmt|;
name|high_bits
operator|=
name|addend
expr_stmt|;
block|}
else|else
block|{
name|low_bits
operator|=
name|addend
expr_stmt|;
name|high_bits
operator|=
name|sign_bits
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|low_bits
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|high_bits
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|mips_elf_perform_relocation
argument_list|(
name|info
argument_list|,
name|howto
argument_list|,
name|rel
argument_list|,
name|addend
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Go on to the next relocation.  */
continue|continue;
block|}
comment|/* In the N32 and 64-bit ABIs there may be multiple consecutive 	 relocations for the same offset.  In that case we are 	 supposed to treat the output of each relocation as the addend 	 for the next.  */
if|if
condition|(
name|rel
operator|+
literal|1
operator|<
name|relend
operator|&&
name|rel
operator|->
name|r_offset
operator|==
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|&&
name|ELF_R_TYPE
argument_list|(
name|input_bfd
argument_list|,
name|rel
index|[
literal|1
index|]
operator|.
name|r_info
argument_list|)
operator|!=
name|R_MIPS_NONE
condition|)
name|use_saved_addend_p
operator|=
name|TRUE
expr_stmt|;
else|else
name|use_saved_addend_p
operator|=
name|FALSE
expr_stmt|;
comment|/* Figure out what value we are supposed to relocate.  */
switch|switch
condition|(
name|mips_elf_calculate_relocation
argument_list|(
name|output_bfd
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|info
argument_list|,
name|rel
argument_list|,
name|addend
argument_list|,
name|howto
argument_list|,
name|local_syms
argument_list|,
name|local_sections
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|require_jalx
argument_list|,
name|use_saved_addend_p
argument_list|)
condition|)
block|{
case|case
name|bfd_reloc_continue
case|:
comment|/* There's nothing to do.  */
continue|continue;
case|case
name|bfd_reloc_undefined
case|:
comment|/* mips_elf_calculate_relocation already called the 	     undefined_symbol callback.  There's no real point in 	     trying to perform the relocation at this point, so we 	     just skip ahead to the next relocation.  */
continue|continue;
case|case
name|bfd_reloc_notsupported
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unsupported relocation error"
argument_list|)
expr_stmt|;
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
name|use_saved_addend_p
condition|)
comment|/* Ignore overflow until we reach the last relocation for 	       a given location.  */
empty_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|NULL
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
break|break;
case|case
name|bfd_reloc_ok
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* If we've got another relocation for the address, keep going 	 until we reach the last one.  */
if|if
condition|(
name|use_saved_addend_p
condition|)
block|{
name|addend
operator|=
name|value
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_MIPS_64
operator|&&
operator|!
name|NEWABI_P
argument_list|(
name|output_bfd
argument_list|)
condition|)
comment|/* See the comment above about using R_MIPS_64 in the 32-bit 	   ABI.  Until now, we've been using the HOWTO for R_MIPS_32; 	   that calculated the right value.  Now, however, we 	   sign-extend the 32-bit result to 64-bits, and store it as a 	   64-bit value.  We are especially generous here in that we 	   go to extreme lengths to support this usage on systems with 	   only a 32-bit VMA.  */
block|{
name|bfd_vma
name|sign_bits
decl_stmt|;
name|bfd_vma
name|low_bits
decl_stmt|;
name|bfd_vma
name|high_bits
decl_stmt|;
if|if
condition|(
name|value
operator|&
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|31
operator|)
condition|)
ifdef|#
directive|ifdef
name|BFD64
name|sign_bits
operator|=
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|32
operator|)
operator|-
literal|1
expr_stmt|;
else|#
directive|else
name|sign_bits
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
else|else
name|sign_bits
operator|=
literal|0
expr_stmt|;
comment|/* If we don't know that we have a 64-bit type, 	     do two separate stores.  */
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
comment|/* Undo what we did above.  */
name|rel
operator|->
name|r_offset
operator|-=
literal|4
expr_stmt|;
comment|/* Store the sign-bits (which are most significant) 		 first.  */
name|low_bits
operator|=
name|sign_bits
expr_stmt|;
name|high_bits
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
name|low_bits
operator|=
name|value
expr_stmt|;
name|high_bits
operator|=
name|sign_bits
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|low_bits
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|high_bits
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Actually perform the relocation.  */
if|if
condition|(
operator|!
name|mips_elf_perform_relocation
argument_list|(
name|info
argument_list|,
name|howto
argument_list|,
name|rel
argument_list|,
name|value
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|require_jalx
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If NAME is one of the special IRIX6 symbols defined by the linker,    adjust it appropriately now.  */
end_comment

begin_function
specifier|static
name|void
name|mips_elf_irix6_finish_dynamic_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
comment|/* The linker script takes care of providing names and values for      these, but we must place them into the right sections.  */
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|text_section_symbols
index|[]
init|=
block|{
literal|"_ftext"
block|,
literal|"_etext"
block|,
literal|"__dso_displacement"
block|,
literal|"__elf_header"
block|,
literal|"__program_header_table"
block|,
name|NULL
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|data_section_symbols
index|[]
init|=
block|{
literal|"_fdata"
block|,
literal|"_edata"
block|,
literal|"_end"
block|,
literal|"_fbss"
block|,
name|NULL
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
for|for
control|(
name|p
operator|=
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
name|text_section_symbols
else|:
name|data_section_symbols
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|p
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* All of these symbols are given type STT_SECTION by the 	     IRIX6 linker.  */
name|sym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_other
operator|=
name|STO_PROTECTED
expr_stmt|;
comment|/* The IRIX linker puts these symbols in special sections.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_MIPS_TEXT
expr_stmt|;
else|else
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_MIPS_DATA
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_finish_dynamic_symbol
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|,
modifier|*
name|gg
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|struct
name|mips_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
name|MINUS_ONE
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_byte
name|stub
index|[
name|MIPS_FUNCTION_STUB_BIG_SIZE
index|]
decl_stmt|;
comment|/* This symbol has a stub.  Set it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|MIPS_ELF_STUB_SECTION_NAME
argument_list|(
name|dynobj
argument_list|)
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
name|htab
operator|->
name|function_stub_size
operator|==
name|MIPS_FUNCTION_STUB_BIG_SIZE
operator|)
operator|||
operator|(
name|h
operator|->
name|dynindx
operator|<=
literal|0xffff
operator|)
argument_list|)
expr_stmt|;
comment|/* Values up to 2^31 - 1 are allowed.  Larger values would cause 	 sign extension at runtime in the stub, resulting in a negative 	 index value.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|&
operator|~
literal|0x7fffffff
condition|)
return|return
name|FALSE
return|;
comment|/* Fill the stub.  */
name|idx
operator|=
literal|0
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|STUB_LW
argument_list|(
name|output_bfd
argument_list|)
argument_list|,
name|stub
operator|+
name|idx
argument_list|)
expr_stmt|;
name|idx
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|STUB_MOVE
argument_list|(
name|output_bfd
argument_list|)
argument_list|,
name|stub
operator|+
name|idx
argument_list|)
expr_stmt|;
name|idx
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|function_stub_size
operator|==
name|MIPS_FUNCTION_STUB_BIG_SIZE
condition|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|STUB_LUI
argument_list|(
operator|(
name|h
operator|->
name|dynindx
operator|>>
literal|16
operator|)
operator|&
literal|0x7fff
argument_list|)
argument_list|,
name|stub
operator|+
name|idx
argument_list|)
expr_stmt|;
name|idx
operator|+=
literal|4
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|STUB_JALR
argument_list|,
name|stub
operator|+
name|idx
argument_list|)
expr_stmt|;
name|idx
operator|+=
literal|4
expr_stmt|;
comment|/* If a large stub is not required and sign extension is not a          problem, then use legacy code in the stub.  */
if|if
condition|(
name|htab
operator|->
name|function_stub_size
operator|==
name|MIPS_FUNCTION_STUB_BIG_SIZE
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|STUB_ORI
argument_list|(
name|h
operator|->
name|dynindx
operator|&
literal|0xffff
argument_list|)
argument_list|,
name|stub
operator|+
name|idx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|dynindx
operator|&
operator|~
literal|0x7fff
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|STUB_LI16U
argument_list|(
name|h
operator|->
name|dynindx
operator|&
literal|0xffff
argument_list|)
argument_list|,
name|stub
operator|+
name|idx
argument_list|)
expr_stmt|;
else|else
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|STUB_LI16S
argument_list|(
name|output_bfd
argument_list|,
name|h
operator|->
name|dynindx
argument_list|)
argument_list|,
name|stub
operator|+
name|idx
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|<=
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|,
name|stub
argument_list|,
name|htab
operator|->
name|function_stub_size
argument_list|)
expr_stmt|;
comment|/* Mark the symbol as undefined.  plt.offset != -1 occurs 	 only for the referenced symbol.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
comment|/* The run-time linker uses the st_value field of the symbol 	 to reset the global offset table entry for this external 	 to its stub address when unlinking a shared object.  */
name|sym
operator|->
name|st_value
operator|=
operator|(
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|||
name|h
operator|->
name|forced_local
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|mips_elf_got_section
argument_list|(
name|dynobj
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|mips_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
name|mips_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|u
operator|.
name|got_info
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Run through the global symbol table, creating GOT entries for all      the symbols that need them.  */
if|if
condition|(
name|g
operator|->
name|global_gotsym
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|>=
name|g
operator|->
name|global_gotsym
operator|->
name|dynindx
condition|)
block|{
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|value
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
name|offset
operator|=
name|mips_elf_global_got_index
argument_list|(
name|dynobj
argument_list|,
name|output_bfd
argument_list|,
name|h
argument_list|,
name|R_MIPS_GOT16
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|MIPS_ELF_PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|g
operator|->
name|next
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
name|h
operator|->
name|type
operator|!=
name|STT_TLS
condition|)
block|{
name|struct
name|mips_got_entry
name|e
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|bfd_vma
name|entry
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|gg
operator|=
name|g
expr_stmt|;
name|e
operator|.
name|abfd
operator|=
name|output_bfd
expr_stmt|;
name|e
operator|.
name|symndx
operator|=
operator|-
literal|1
expr_stmt|;
name|e
operator|.
name|d
operator|.
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|e
operator|.
name|tls_type
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|g
operator|=
name|g
operator|->
name|next
init|;
name|g
operator|->
name|next
operator|!=
name|gg
condition|;
name|g
operator|=
name|g
operator|->
name|next
control|)
block|{
if|if
condition|(
name|g
operator|->
name|got_entries
operator|&&
operator|(
name|p
operator|=
operator|(
expr|struct
name|mips_got_entry
operator|*
operator|)
name|htab_find
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
operator|&
name|e
argument_list|)
operator|)
condition|)
block|{
name|offset
operator|=
name|p
operator|->
name|gotidx
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|||
operator|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|&&
name|p
operator|->
name|d
operator|.
name|h
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|def_dynamic
operator|&&
operator|!
name|p
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|def_regular
operator|)
condition|)
block|{
comment|/* Create an R_MIPS_REL32 relocation for this entry.  Due to 		     the various compatibility problems, it's easier to mock 		     up an R_MIPS_32 or R_MIPS_64 relocation and leave 		     mips_elf_create_dynamic_relocation to calculate the 		     appropriate addend.  */
name|Elf_Internal_Rela
name|rel
index|[
literal|3
index|]
decl_stmt|;
name|memset
argument_list|(
name|rel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|rel
index|[
literal|0
index|]
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|R_MIPS_64
argument_list|)
expr_stmt|;
else|else
name|rel
index|[
literal|0
index|]
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|R_MIPS_32
argument_list|)
expr_stmt|;
name|rel
index|[
literal|0
index|]
operator|.
name|r_offset
operator|=
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|=
name|rel
index|[
literal|2
index|]
operator|.
name|r_offset
operator|=
name|offset
expr_stmt|;
name|entry
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mips_elf_create_dynamic_relocation
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|rel
argument_list|,
name|e
operator|.
name|d
operator|.
name|h
argument_list|,
name|NULL
argument_list|,
name|sym
operator|->
name|st_value
argument_list|,
operator|&
name|entry
argument_list|,
name|sgot
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
name|entry
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
name|MIPS_ELF_PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
name|entry
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
name|h
operator|==
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hgot
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_DYNAMIC_LINK"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_DYNAMIC_LINKING"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
name|sym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_gp_disp"
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|NEWABI_P
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
name|sym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
name|elf_gp
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|mips_elf_dynsym_rtproc_names
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
name|mips_elf_dynsym_rtproc_names
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_other
operator|=
name|STO_PROTECTED
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_MIPS_DATA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|mips_elf_dynsym_rtproc_names
index|[
literal|2
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_other
operator|=
name|STO_PROTECTED
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|procedure_count
expr_stmt|;
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_ABS
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_MIPS_TEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_OBJECT
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_MIPS_DATA
expr_stmt|;
block|}
block|}
comment|/* Handle the IRIX6-specific symbols.  */
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|output_bfd
argument_list|)
operator|==
name|ict_irix6
condition|)
name|mips_elf_irix6_finish_dynamic_symbol
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|,
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|!
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|use_rld_obj_head
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__rld_map"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__RLD_MAP"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|asection
modifier|*
name|s
init|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rld_map"
argument_list|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sym
operator|->
name|st_value
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|rld_value
operator|==
literal|0
condition|)
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|rld_value
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|use_rld_obj_head
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__rld_obj_head"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* IRIX6 does not use a .rld_map section.  */
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|output_bfd
argument_list|)
operator|==
name|ict_irix5
operator|||
name|IRIX_COMPAT
argument_list|(
name|output_bfd
argument_list|)
operator|==
name|ict_none
condition|)
name|BFD_ASSERT
argument_list|(
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rld_map"
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|rld_value
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
block|}
block|}
comment|/* If this is a mips16 symbol, force the value to be even.  */
if|if
condition|(
name|sym
operator|->
name|st_other
operator|==
name|STO_MIPS16
condition|)
name|sym
operator|->
name|st_value
operator|&=
operator|~
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Likewise, for VxWorks.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_vxworks_finish_dynamic_symbol
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|struct
name|mips_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_vma
name|plt_address
decl_stmt|,
name|plt_index
decl_stmt|,
name|got_address
decl_stmt|,
name|got_offset
decl_stmt|,
name|branch_offset
decl_stmt|;
name|Elf_Internal_Rela
name|rel
decl_stmt|;
specifier|static
specifier|const
name|bfd_vma
modifier|*
name|plt_entry
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|htab
operator|->
name|splt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|<=
name|htab
operator|->
name|splt
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* Calculate the address of the .plt entry.  */
name|plt_address
operator|=
operator|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
comment|/* Calculate the index of the entry.  */
name|plt_index
operator|=
operator|(
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|-
name|htab
operator|->
name|plt_header_size
operator|)
operator|/
name|htab
operator|->
name|plt_entry_size
operator|)
expr_stmt|;
comment|/* Calculate the address of the .got.plt entry.  */
name|got_address
operator|=
operator|(
name|htab
operator|->
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgotplt
operator|->
name|output_offset
operator|+
name|plt_index
operator|*
literal|4
operator|)
expr_stmt|;
comment|/* Calculate the offset of the .got.plt entry from 	 _GLOBAL_OFFSET_TABLE_.  */
name|got_offset
operator|=
name|mips_elf_gotplt_index
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/* Calculate the offset for the branch at the start of the PLT 	 entry.  The branch jumps to the beginning of .plt.  */
name|branch_offset
operator|=
operator|-
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|/
literal|4
operator|+
literal|1
operator|)
operator|&
literal|0xffff
expr_stmt|;
comment|/* Fill in the initial value of the .got.plt entry.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_address
argument_list|,
name|htab
operator|->
name|sgotplt
operator|->
name|contents
operator|+
name|plt_index
operator|*
literal|4
argument_list|)
expr_stmt|;
comment|/* Find out where the .plt entry should go.  */
name|loc
operator|=
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|plt_entry
operator|=
name|mips_vxworks_shared_plt_entry
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|0
index|]
operator||
name|branch_offset
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|1
index|]
operator||
name|plt_index
argument_list|,
name|loc
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_vma
name|got_address_high
decl_stmt|,
name|got_address_low
decl_stmt|;
name|plt_entry
operator|=
name|mips_vxworks_exec_plt_entry
expr_stmt|;
name|got_address_high
operator|=
operator|(
operator|(
name|got_address
operator|+
literal|0x8000
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|got_address_low
operator|=
name|got_address
operator|&
literal|0xffff
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|0
index|]
operator||
name|branch_offset
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|1
index|]
operator||
name|plt_index
argument_list|,
name|loc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|2
index|]
operator||
name|got_address_high
argument_list|,
name|loc
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|3
index|]
operator||
name|got_address_low
argument_list|,
name|loc
operator|+
literal|12
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|4
index|]
argument_list|,
name|loc
operator|+
literal|16
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|5
index|]
argument_list|,
name|loc
operator|+
literal|20
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|6
index|]
argument_list|,
name|loc
operator|+
literal|24
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|7
index|]
argument_list|,
name|loc
operator|+
literal|28
argument_list|)
expr_stmt|;
name|loc
operator|=
operator|(
name|htab
operator|->
name|srelplt2
operator|->
name|contents
operator|+
operator|(
name|plt_index
operator|*
literal|3
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
expr_stmt|;
comment|/* Emit a relocation for the .got.plt entry.  */
name|rel
operator|.
name|r_offset
operator|=
name|got_address
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|root
operator|.
name|hplt
operator|->
name|indx
argument_list|,
name|R_MIPS_32
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
name|h
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
comment|/* Emit a relocation for the lui of %hi(<.got.plt slot>).  */
name|loc
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_offset
operator|=
name|plt_address
operator|+
literal|8
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|root
operator|.
name|hgot
operator|->
name|indx
argument_list|,
name|R_MIPS_HI16
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
name|got_offset
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
comment|/* Emit a relocation for the addiu of %lo(<.got.plt slot>).  */
name|loc
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_offset
operator|+=
literal|4
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|root
operator|.
name|hgot
operator|->
name|indx
argument_list|,
name|R_MIPS_LO16
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
comment|/* Emit an R_MIPS_JUMP_SLOT relocation against the .got.plt entry.  */
name|loc
operator|=
name|htab
operator|->
name|srelplt
operator|->
name|contents
operator|+
name|plt_index
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_offset
operator|=
name|got_address
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_MIPS_JUMP_SLOT
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h
operator|->
name|def_regular
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|||
name|h
operator|->
name|forced_local
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|mips_elf_got_section
argument_list|(
name|dynobj
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|mips_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
name|mips_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|u
operator|.
name|got_info
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* See if this symbol has an entry in the GOT.  */
if|if
condition|(
name|g
operator|->
name|global_gotsym
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|>=
name|g
operator|->
name|global_gotsym
operator|->
name|dynindx
condition|)
block|{
name|bfd_vma
name|offset
decl_stmt|;
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* Install the symbol value in the GOT.   */
name|offset
operator|=
name|mips_elf_global_got_index
argument_list|(
name|dynobj
argument_list|,
name|output_bfd
argument_list|,
name|h
argument_list|,
name|R_MIPS_GOT16
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|MIPS_ELF_PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
name|sym
operator|->
name|st_value
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
comment|/* Add a dynamic relocation for it.  */
name|s
operator|=
name|mips_elf_rel_dyn_section
argument_list|(
name|info
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|loc
operator|=
name|s
operator|->
name|contents
operator|+
operator|(
name|s
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|offset
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_MIPS_32
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|dynobj
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
comment|/* Emit a copy reloc, if needed.  */
if|if
condition|(
name|h
operator|->
name|needs_copy
condition|)
block|{
name|Elf_Internal_Rela
name|rel
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_MIPS_COPY
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|htab
operator|->
name|srelbss
operator|->
name|contents
operator|+
operator|(
name|htab
operator|->
name|srelbss
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
argument_list|)
expr_stmt|;
operator|++
name|htab
operator|->
name|srelbss
operator|->
name|reloc_count
expr_stmt|;
block|}
comment|/* If this is a mips16 symbol, force the value to be even.  */
if|if
condition|(
name|sym
operator|->
name|st_other
operator|==
name|STO_MIPS16
condition|)
name|sym
operator|->
name|st_value
operator|&=
operator|~
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Install the PLT header for a VxWorks executable and finalize the    contents of .rela.plt.unloaded.  */
end_comment

begin_function
specifier|static
name|void
name|mips_vxworks_finish_exec_plt
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_vma
name|got_value
decl_stmt|,
name|got_value_high
decl_stmt|,
name|got_value_low
decl_stmt|,
name|plt_address
decl_stmt|;
specifier|static
specifier|const
name|bfd_vma
modifier|*
name|plt_entry
decl_stmt|;
name|struct
name|mips_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|plt_entry
operator|=
name|mips_vxworks_exec_plt0_entry
expr_stmt|;
comment|/* Calculate the value of _GLOBAL_OFFSET_TABLE_.  */
name|got_value
operator|=
operator|(
name|htab
operator|->
name|root
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|root
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|htab
operator|->
name|root
operator|.
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|)
expr_stmt|;
name|got_value_high
operator|=
operator|(
operator|(
name|got_value
operator|+
literal|0x8000
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|got_value_low
operator|=
name|got_value
operator|&
literal|0xffff
expr_stmt|;
comment|/* Calculate the address of the PLT header.  */
name|plt_address
operator|=
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_offset
expr_stmt|;
comment|/* Install the PLT header.  */
name|loc
operator|=
name|htab
operator|->
name|splt
operator|->
name|contents
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|0
index|]
operator||
name|got_value_high
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|1
index|]
operator||
name|got_value_low
argument_list|,
name|loc
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|2
index|]
argument_list|,
name|loc
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|3
index|]
argument_list|,
name|loc
operator|+
literal|12
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|4
index|]
argument_list|,
name|loc
operator|+
literal|16
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_entry
index|[
literal|5
index|]
argument_list|,
name|loc
operator|+
literal|20
argument_list|)
expr_stmt|;
comment|/* Output the relocation for the lui of %hi(_GLOBAL_OFFSET_TABLE_).  */
name|loc
operator|=
name|htab
operator|->
name|srelplt2
operator|->
name|contents
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
name|plt_address
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|root
operator|.
name|hgot
operator|->
name|indx
argument_list|,
name|R_MIPS_HI16
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
comment|/* Output the relocation for the following addiu of      %lo(_GLOBAL_OFFSET_TABLE_).  */
name|rela
operator|.
name|r_offset
operator|+=
literal|4
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|root
operator|.
name|hgot
operator|->
name|indx
argument_list|,
name|R_MIPS_LO16
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
comment|/* Fix up the remaining relocations.  They may have the wrong      symbol index for _G_O_T_ or _P_L_T_ depending on the order      in which symbols were output.  */
while|while
condition|(
name|loc
operator|<
name|htab
operator|->
name|srelplt2
operator|->
name|contents
operator|+
name|htab
operator|->
name|srelplt2
operator|->
name|size
condition|)
block|{
name|Elf_Internal_Rela
name|rel
decl_stmt|;
name|bfd_elf32_swap_reloca_in
argument_list|(
name|output_bfd
argument_list|,
name|loc
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|root
operator|.
name|hplt
operator|->
name|indx
argument_list|,
name|R_MIPS_32
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_in
argument_list|(
name|output_bfd
argument_list|,
name|loc
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|root
operator|.
name|hgot
operator|->
name|indx
argument_list|,
name|R_MIPS_HI16
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_in
argument_list|(
name|output_bfd
argument_list|,
name|loc
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|htab
operator|->
name|root
operator|.
name|hgot
operator|->
name|indx
argument_list|,
name|R_MIPS_LO16
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|loc
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Install the PLT header for a VxWorks shared library.  */
end_comment

begin_function
specifier|static
name|void
name|mips_vxworks_finish_shared_plt
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|mips_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* We just need to copy the entry byte-by-byte.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|mips_vxworks_shared_plt0_entry
argument_list|)
condition|;
name|i
operator|++
control|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|mips_vxworks_shared_plt0_entry
index|[
name|i
index|]
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_finish_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|gg
decl_stmt|,
modifier|*
name|g
decl_stmt|;
name|struct
name|mips_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|mips_elf_got_section
argument_list|(
name|dynobj
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
name|gg
operator|=
name|g
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|mips_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gg
operator|=
name|mips_elf_section_data
argument_list|(
name|sgot
argument_list|)
operator|->
name|u
operator|.
name|got_info
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|gg
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|g
operator|=
name|mips_elf_got_for_ibfd
argument_list|(
name|gg
argument_list|,
name|output_bfd
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|bfd_byte
modifier|*
name|b
decl_stmt|;
name|int
name|dyn_to_skip
init|=
literal|0
decl_stmt|,
name|dyn_skipped
init|=
literal|0
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|g
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|sdyn
operator|->
name|contents
init|;
name|b
operator|<
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|size
condition|;
name|b
operator|+=
name|MIPS_ELF_DYN_SIZE
argument_list|(
name|dynobj
argument_list|)
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|elemsize
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_boolean
name|swap_out_p
decl_stmt|;
comment|/* Read in the current dynamic entry.  */
operator|(
operator|*
name|get_elf_backend_data
argument_list|(
name|dynobj
argument_list|)
operator|->
name|s
operator|->
name|swap_dyn_in
operator|)
operator|(
name|dynobj
operator|,
name|b
operator|,
operator|&
name|dyn
operator|)
expr_stmt|;
comment|/* Assume that we're going to modify it and write it out.  */
name|swap_out_p
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
case|case
name|DT_RELENT
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|MIPS_ELF_REL_SIZE
argument_list|(
name|dynobj
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_RELAENT
case|:
name|BFD_ASSERT
argument_list|(
name|htab
operator|->
name|is_vxworks
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|MIPS_ELF_RELA_SIZE
argument_list|(
name|dynobj
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_STRSZ
case|:
comment|/* Rewrite DT_STRSZ.  */
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|_bfd_elf_strtab_size
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_PLTGOT
case|:
name|name
operator|=
literal|".got"
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|is_vxworks
condition|)
block|{
comment|/* _GLOBAL_OFFSET_TABLE_ is defined to be the beginning 		     of the ".got" section in DYNOBJ.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
block|}
break|break;
case|case
name|DT_MIPS_RLD_VERSION
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
break|break;
case|case
name|DT_MIPS_FLAGS
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|RHF_NOTPOT
expr_stmt|;
comment|/* XXX */
break|break;
case|case
name|DT_MIPS_TIME_STAMP
case|:
block|{
name|time_t
name|t
decl_stmt|;
name|time
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|t
expr_stmt|;
block|}
break|break;
case|case
name|DT_MIPS_ICHECKSUM
case|:
comment|/* XXX FIXME: */
name|swap_out_p
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|DT_MIPS_IVERSION
case|:
comment|/* XXX FIXME: */
name|swap_out_p
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|DT_MIPS_BASE_ADDRESS
case|:
name|s
operator|=
name|output_bfd
operator|->
name|sections
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0xffff
expr_stmt|;
break|break;
case|case
name|DT_MIPS_LOCAL_GOTNO
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|g
operator|->
name|local_gotno
expr_stmt|;
break|break;
case|case
name|DT_MIPS_UNREFEXTNO
case|:
comment|/* The index into the dynamic symbol table which is the 		 entry of the first external symbol that is not 		 referenced within the same object.  */
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|bfd_count_sections
argument_list|(
name|output_bfd
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|DT_MIPS_GOTSYM
case|:
if|if
condition|(
name|gg
operator|->
name|global_gotsym
condition|)
block|{
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|gg
operator|->
name|global_gotsym
operator|->
name|dynindx
expr_stmt|;
break|break;
block|}
comment|/* In case if we don't have global got symbols we default 		 to setting DT_MIPS_GOTSYM to the same value as 		 DT_MIPS_SYMTABNO, so we just fall through.  */
case|case
name|DT_MIPS_SYMTABNO
case|:
name|name
operator|=
literal|".dynsym"
expr_stmt|;
name|elemsize
operator|=
name|MIPS_ELF_SYM_SIZE
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|size
operator|/
name|elemsize
expr_stmt|;
break|break;
case|case
name|DT_MIPS_HIPAGENO
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|g
operator|->
name|local_gotno
operator|-
name|MIPS_RESERVED_GOTNO
argument_list|(
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_MIPS_RLD_MAP
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|rld_value
expr_stmt|;
break|break;
case|case
name|DT_MIPS_OPTIONS
case|:
name|s
operator|=
operator|(
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|MIPS_ELF_OPTIONS_SECTION_NAME
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|DT_RELASZ
case|:
name|BFD_ASSERT
argument_list|(
name|htab
operator|->
name|is_vxworks
argument_list|)
expr_stmt|;
comment|/* The count does not include the JUMP_SLOT relocations.  */
if|if
condition|(
name|htab
operator|->
name|srelplt
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|-=
name|htab
operator|->
name|srelplt
operator|->
name|size
expr_stmt|;
break|break;
case|case
name|DT_PLTREL
case|:
name|BFD_ASSERT
argument_list|(
name|htab
operator|->
name|is_vxworks
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|DT_RELA
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|BFD_ASSERT
argument_list|(
name|htab
operator|->
name|is_vxworks
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|htab
operator|->
name|srelplt
operator|->
name|size
expr_stmt|;
break|break;
case|case
name|DT_JMPREL
case|:
name|BFD_ASSERT
argument_list|(
name|htab
operator|->
name|is_vxworks
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
operator|(
name|htab
operator|->
name|srelplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|srelplt
operator|->
name|output_offset
operator|)
expr_stmt|;
break|break;
case|case
name|DT_TEXTREL
case|:
comment|/* If we didn't need any text relocations after all, delete 		 the dynamic tag.  */
if|if
condition|(
operator|!
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
condition|)
block|{
name|dyn_to_skip
operator|=
name|MIPS_ELF_DYN_SIZE
argument_list|(
name|dynobj
argument_list|)
expr_stmt|;
name|swap_out_p
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
case|case
name|DT_FLAGS
case|:
comment|/* If we didn't need any text relocations after all, clear 		 DF_TEXTREL from DT_FLAGS.  */
if|if
condition|(
operator|!
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|&=
operator|~
name|DF_TEXTREL
expr_stmt|;
else|else
name|swap_out_p
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|swap_out_p
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|swap_out_p
operator|||
name|dyn_skipped
condition|)
operator|(
operator|*
name|get_elf_backend_data
argument_list|(
name|dynobj
argument_list|)
operator|->
name|s
operator|->
name|swap_dyn_out
operator|)
operator|(
name|dynobj
operator|,
operator|&
name|dyn
operator|,
name|b
operator|-
name|dyn_skipped
operator|)
expr_stmt|;
if|if
condition|(
name|dyn_to_skip
condition|)
block|{
name|dyn_skipped
operator|+=
name|dyn_to_skip
expr_stmt|;
name|dyn_to_skip
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Wipe out any trailing entries if we shifted down a dynamic tag.  */
if|if
condition|(
name|dyn_skipped
operator|>
literal|0
condition|)
name|memset
argument_list|(
name|b
operator|-
name|dyn_skipped
argument_list|,
literal|0
argument_list|,
name|dyn_skipped
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sgot
operator|!=
name|NULL
operator|&&
name|sgot
operator|->
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|htab
operator|->
name|is_vxworks
condition|)
block|{
comment|/* The first entry of the global offset table points to the 	     ".dynamic" section.  The second is initialized by the 	     loader and contains the shared library identifier. 	     The third is also initialized by the loader and points 	     to the lazy resolution stub.  */
name|MIPS_ELF_PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
name|sdyn
operator|->
name|output_offset
operator|+
name|sdyn
operator|->
name|output_section
operator|->
name|vma
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
name|MIPS_ELF_PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|MIPS_ELF_PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
literal|2
operator|*
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The first entry of the global offset table will be filled at 	     runtime. The second entry will be used by some runtime loaders. 	     This isn't the case of IRIX rld.  */
name|MIPS_ELF_PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
name|MIPS_ELF_PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0x80000000
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|elf_section_data
argument_list|(
name|sgot
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
block|}
comment|/* Generate dynamic relocations for the non-primary gots.  */
if|if
condition|(
name|gg
operator|!=
name|NULL
operator|&&
name|gg
operator|->
name|next
condition|)
block|{
name|Elf_Internal_Rela
name|rel
index|[
literal|3
index|]
decl_stmt|;
name|bfd_vma
name|addend
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
name|rel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rel
argument_list|)
argument_list|)
expr_stmt|;
name|rel
index|[
literal|0
index|]
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|R_MIPS_REL32
argument_list|)
expr_stmt|;
for|for
control|(
name|g
operator|=
name|gg
operator|->
name|next
init|;
name|g
operator|->
name|next
operator|!=
name|gg
condition|;
name|g
operator|=
name|g
operator|->
name|next
control|)
block|{
name|bfd_vma
name|index
init|=
name|g
operator|->
name|next
operator|->
name|local_gotno
operator|+
name|g
operator|->
name|next
operator|->
name|global_gotno
operator|+
name|g
operator|->
name|next
operator|->
name|tls_gotno
decl_stmt|;
name|MIPS_ELF_PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|index
operator|++
operator|*
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|MIPS_ELF_PUT_WORD
argument_list|(
name|output_bfd
argument_list|,
literal|0x80000000
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|index
operator|++
operator|*
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|output_bfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
continue|continue;
while|while
condition|(
name|index
operator|<
name|g
operator|->
name|assigned_gotno
condition|)
block|{
name|rel
index|[
literal|0
index|]
operator|.
name|r_offset
operator|=
name|rel
index|[
literal|1
index|]
operator|.
name|r_offset
operator|=
name|rel
index|[
literal|2
index|]
operator|.
name|r_offset
operator|=
name|index
operator|++
operator|*
name|MIPS_ELF_GOT_SIZE
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mips_elf_create_dynamic_relocation
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|rel
argument_list|,
name|NULL
argument_list|,
name|bfd_abs_section_ptr
argument_list|,
literal|0
argument_list|,
operator|&
name|addend
argument_list|,
name|sgot
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|BFD_ASSERT
argument_list|(
name|addend
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* The generation of dynamic relocations for the non-primary gots      adds more dynamic relocations.  We cannot count them until      here.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|bfd_byte
modifier|*
name|b
decl_stmt|;
name|bfd_boolean
name|swap_out_p
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|sdyn
operator|->
name|contents
init|;
name|b
operator|<
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|size
condition|;
name|b
operator|+=
name|MIPS_ELF_DYN_SIZE
argument_list|(
name|dynobj
argument_list|)
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* Read in the current dynamic entry.  */
operator|(
operator|*
name|get_elf_backend_data
argument_list|(
name|dynobj
argument_list|)
operator|->
name|s
operator|->
name|swap_dyn_in
operator|)
operator|(
name|dynobj
operator|,
name|b
operator|,
operator|&
name|dyn
operator|)
expr_stmt|;
comment|/* Assume that we're going to modify it and write it out.  */
name|swap_out_p
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
case|case
name|DT_RELSZ
case|:
comment|/* Reduce DT_RELSZ to account for any relocations we 		 decided not to make.  This is for the n64 irix rld, 		 which doesn't seem to apply any relocations if there 		 are trailing null entries.  */
name|s
operator|=
name|mips_elf_rel_dyn_section
argument_list|(
name|info
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
operator|(
name|s
operator|->
name|reloc_count
operator|*
operator|(
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
name|Elf64_Mips_External_Rel
argument_list|)
else|:
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/* Adjust the section size too.  Tools like the prelinker 		 can reasonably expect the values to the same.  */
name|elf_section_data
argument_list|(
name|s
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_size
operator|=
name|dyn
operator|.
name|d_un
operator|.
name|d_val
expr_stmt|;
break|break;
default|default:
name|swap_out_p
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|swap_out_p
condition|)
operator|(
operator|*
name|get_elf_backend_data
argument_list|(
name|dynobj
argument_list|)
operator|->
name|s
operator|->
name|swap_dyn_out
operator|)
operator|(
name|dynobj
operator|,
operator|&
name|dyn
operator|,
name|b
operator|)
expr_stmt|;
block|}
block|}
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|Elf32_compact_rel
name|cpt
decl_stmt|;
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
comment|/* Write .compact_rel section out.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".compact_rel"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|cpt
operator|.
name|id1
operator|=
literal|1
expr_stmt|;
name|cpt
operator|.
name|num
operator|=
name|s
operator|->
name|reloc_count
expr_stmt|;
name|cpt
operator|.
name|id2
operator|=
literal|2
expr_stmt|;
name|cpt
operator|.
name|offset
operator|=
operator|(
name|s
operator|->
name|output_section
operator|->
name|filepos
operator|+
sizeof|sizeof
argument_list|(
name|Elf32_External_compact_rel
argument_list|)
operator|)
expr_stmt|;
name|cpt
operator|.
name|reserved0
operator|=
literal|0
expr_stmt|;
name|cpt
operator|.
name|reserved1
operator|=
literal|0
expr_stmt|;
name|bfd_elf32_swap_compact_rel_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|cpt
argument_list|,
operator|(
operator|(
name|Elf32_External_compact_rel
operator|*
operator|)
name|s
operator|->
name|contents
operator|)
argument_list|)
expr_stmt|;
comment|/* Clean up a dummy stub function entry in .text.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|MIPS_ELF_STUB_SECTION_NAME
argument_list|(
name|dynobj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|file_ptr
name|dummy_offset
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|->
name|size
operator|>=
name|htab
operator|->
name|function_stub_size
argument_list|)
expr_stmt|;
name|dummy_offset
operator|=
name|s
operator|->
name|size
operator|-
name|htab
operator|->
name|function_stub_size
expr_stmt|;
name|memset
argument_list|(
name|s
operator|->
name|contents
operator|+
name|dummy_offset
argument_list|,
literal|0
argument_list|,
name|htab
operator|->
name|function_stub_size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* The psABI says that the dynamic relocations must be sorted in        increasing order of r_symndx.  The VxWorks EABI doesn't require        this, and because the code below handles REL rather than RELA        relocations, using it for VxWorks would be outright harmful.  */
if|if
condition|(
operator|!
name|htab
operator|->
name|is_vxworks
condition|)
block|{
name|s
operator|=
name|mips_elf_rel_dyn_section
argument_list|(
name|info
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|size
operator|>
operator|(
name|bfd_vma
operator|)
literal|2
operator|*
name|MIPS_ELF_REL_SIZE
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|reldyn_sorting_bfd
operator|=
name|output_bfd
expr_stmt|;
if|if
condition|(
name|ABI_64_P
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|qsort
argument_list|(
operator|(
name|Elf64_External_Rel
operator|*
operator|)
name|s
operator|->
name|contents
operator|+
literal|1
argument_list|,
name|s
operator|->
name|reloc_count
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf64_Mips_External_Rel
argument_list|)
argument_list|,
name|sort_dynamic_relocs_64
argument_list|)
expr_stmt|;
else|else
name|qsort
argument_list|(
operator|(
name|Elf32_External_Rel
operator|*
operator|)
name|s
operator|->
name|contents
operator|+
literal|1
argument_list|,
name|s
operator|->
name|reloc_count
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
argument_list|,
name|sort_dynamic_relocs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|htab
operator|->
name|is_vxworks
operator|&&
name|htab
operator|->
name|splt
operator|->
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|mips_vxworks_finish_shared_plt
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
else|else
name|mips_vxworks_finish_exec_plt
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set ABFD's EF_MIPS_ARCH and EF_MIPS_MACH flags.  */
end_comment

begin_function
specifier|static
name|void
name|mips_set_isa_flags
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|flagword
name|val
decl_stmt|;
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
default|default:
case|case
name|bfd_mach_mips3000
case|:
name|val
operator|=
name|E_MIPS_ARCH_1
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips3900
case|:
name|val
operator|=
name|E_MIPS_ARCH_1
operator||
name|E_MIPS_MACH_3900
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips6000
case|:
name|val
operator|=
name|E_MIPS_ARCH_2
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips4000
case|:
case|case
name|bfd_mach_mips4300
case|:
case|case
name|bfd_mach_mips4400
case|:
case|case
name|bfd_mach_mips4600
case|:
name|val
operator|=
name|E_MIPS_ARCH_3
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips4010
case|:
name|val
operator|=
name|E_MIPS_ARCH_3
operator||
name|E_MIPS_MACH_4010
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips4100
case|:
name|val
operator|=
name|E_MIPS_ARCH_3
operator||
name|E_MIPS_MACH_4100
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips4111
case|:
name|val
operator|=
name|E_MIPS_ARCH_3
operator||
name|E_MIPS_MACH_4111
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips4120
case|:
name|val
operator|=
name|E_MIPS_ARCH_3
operator||
name|E_MIPS_MACH_4120
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips4650
case|:
name|val
operator|=
name|E_MIPS_ARCH_3
operator||
name|E_MIPS_MACH_4650
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips5400
case|:
name|val
operator|=
name|E_MIPS_ARCH_4
operator||
name|E_MIPS_MACH_5400
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips5500
case|:
name|val
operator|=
name|E_MIPS_ARCH_4
operator||
name|E_MIPS_MACH_5500
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips9000
case|:
name|val
operator|=
name|E_MIPS_ARCH_4
operator||
name|E_MIPS_MACH_9000
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips5000
case|:
case|case
name|bfd_mach_mips7000
case|:
case|case
name|bfd_mach_mips8000
case|:
case|case
name|bfd_mach_mips10000
case|:
case|case
name|bfd_mach_mips12000
case|:
name|val
operator|=
name|E_MIPS_ARCH_4
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips5
case|:
name|val
operator|=
name|E_MIPS_ARCH_5
expr_stmt|;
break|break;
case|case
name|bfd_mach_mips_sb1
case|:
name|val
operator|=
name|E_MIPS_ARCH_64
operator||
name|E_MIPS_MACH_SB1
expr_stmt|;
break|break;
case|case
name|bfd_mach_mipsisa32
case|:
name|val
operator|=
name|E_MIPS_ARCH_32
expr_stmt|;
break|break;
case|case
name|bfd_mach_mipsisa64
case|:
name|val
operator|=
name|E_MIPS_ARCH_64
expr_stmt|;
break|break;
case|case
name|bfd_mach_mipsisa32r2
case|:
name|val
operator|=
name|E_MIPS_ARCH_32R2
expr_stmt|;
break|break;
case|case
name|bfd_mach_mipsisa64r2
case|:
name|val
operator|=
name|E_MIPS_ARCH_64R2
expr_stmt|;
break|break;
block|}
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
operator|(
name|EF_MIPS_ARCH
operator||
name|EF_MIPS_MACH
operator|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator||=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The final processing done just before writing out a MIPS ELF object    file.  This gets the MIPS architecture right based on the machine    number.  This is used by both the 32-bit and the 64-bit ABI.  */
end_comment

begin_function
name|void
name|_bfd_mips_elf_final_write_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|linker
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|hdrpp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* Keep the existing EF_MIPS_MACH and EF_MIPS_ARCH flags if the former      is nonzero.  This is for compatibility with old objects, which used      a combination of a 32-bit EF_MIPS_ARCH and a 64-bit EF_MIPS_MACH.  */
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_MACH
operator|)
operator|==
literal|0
condition|)
name|mips_set_isa_flags
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Set the sh_info field for .gptab sections and other appropriate      info for each special section.  */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|hdrpp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
init|;
name|i
operator|<
name|elf_numsections
argument_list|(
name|abfd
argument_list|)
condition|;
name|i
operator|++
operator|,
name|hdrpp
operator|++
control|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_MIPS_MSYM
case|:
case|case
name|SHT_MIPS_LIBLIST
case|:
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynstr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_link
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
case|case
name|SHT_MIPS_GPTAB
case|:
name|BFD_ASSERT
argument_list|(
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|bfd_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|bfd_section
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|name
operator|!=
name|NULL
operator|&&
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".gptab."
argument_list|)
argument_list|)
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
operator|+
sizeof|sizeof
expr|".gptab"
operator|-
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_info
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
case|case
name|SHT_MIPS_CONTENT
case|:
name|BFD_ASSERT
argument_list|(
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|bfd_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|bfd_section
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|name
operator|!=
name|NULL
operator|&&
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".MIPS.content"
argument_list|)
argument_list|)
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
operator|+
sizeof|sizeof
expr|".MIPS.content"
operator|-
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_link
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
case|case
name|SHT_MIPS_SYMBOL_LIB
case|:
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_link
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_idx
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".liblist"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_info
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
case|case
name|SHT_MIPS_EVENTS
case|:
name|BFD_ASSERT
argument_list|(
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|bfd_section
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|bfd_section
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".MIPS.events"
argument_list|)
condition|)
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
operator|+
sizeof|sizeof
expr|".MIPS.events"
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|CONST_STRNEQ
argument_list|(
name|name
argument_list|,
literal|".MIPS.post_rel"
argument_list|)
argument_list|)
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
operator|(
name|name
operator|+
sizeof|sizeof
expr|".MIPS.post_rel"
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
operator|*
name|hdrpp
operator|)
operator|->
name|sh_link
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* When creating an IRIX5 executable, we need REGINFO and RTPROC    segments.  */
end_comment

begin_function
name|int
name|_bfd_mips_elf_additional_program_headers
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* See if we need a PT_MIPS_REGINFO segment.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".reginfo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
condition|)
operator|++
name|ret
expr_stmt|;
comment|/* See if we need a PT_MIPS_OPTIONS segment.  */
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_irix6
operator|&&
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|MIPS_ELF_OPTIONS_SECTION_NAME
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
operator|++
name|ret
expr_stmt|;
comment|/* See if we need a PT_MIPS_RTPROC segment.  */
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_irix5
operator|&&
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
operator|&&
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".mdebug"
argument_list|)
condition|)
operator|++
name|ret
expr_stmt|;
comment|/* Allocate a PT_NULL header in dynamic objects.  See      _bfd_mips_elf_modify_segment_map for details.  */
if|if
condition|(
operator|!
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|&&
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
condition|)
operator|++
name|ret
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Modify the segment map for an IRIX5 executable.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_modify_segment_map
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|,
modifier|*
modifier|*
name|pm
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* If there is a .reginfo section, we need a PT_MIPS_REGINFO      segment.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".reginfo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|p_type
operator|==
name|PT_MIPS_REGINFO
condition|)
break|break;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|amt
operator|=
sizeof|sizeof
expr|*
name|m
expr_stmt|;
name|m
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|m
operator|->
name|p_type
operator|=
name|PT_MIPS_REGINFO
expr_stmt|;
name|m
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
comment|/* We want to put it after the PHDR and INTERP segments.  */
name|pm
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
expr_stmt|;
while|while
condition|(
operator|*
name|pm
operator|!=
name|NULL
operator|&&
operator|(
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|==
name|PT_PHDR
operator|||
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|==
name|PT_INTERP
operator|)
condition|)
name|pm
operator|=
operator|&
operator|(
operator|*
name|pm
operator|)
operator|->
name|next
expr_stmt|;
name|m
operator|->
name|next
operator|=
operator|*
name|pm
expr_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
block|}
block|}
comment|/* For IRIX 6, we don't have .mdebug sections, nor does anything but      .dynamic end up in PT_DYNAMIC.  However, we do have to insert a      PT_MIPS_OPTIONS segment immediately following the program header      table.  */
if|if
condition|(
name|NEWABI_P
argument_list|(
name|abfd
argument_list|)
comment|/* On non-IRIX6 new abi, we'll have already created a segment 	 for this section, so don't create another.  I'm not sure this 	 is not also the case for IRIX 6, but I can't test it right 	 now.  */
operator|&&
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_irix6
condition|)
block|{
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|==
name|SHT_MIPS_OPTIONS
condition|)
break|break;
if|if
condition|(
name|s
condition|)
block|{
name|struct
name|elf_segment_map
modifier|*
name|options_segment
decl_stmt|;
name|pm
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
expr_stmt|;
while|while
condition|(
operator|*
name|pm
operator|!=
name|NULL
operator|&&
operator|(
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|==
name|PT_PHDR
operator|||
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|==
name|PT_INTERP
operator|)
condition|)
name|pm
operator|=
operator|&
operator|(
operator|*
name|pm
operator|)
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|*
name|pm
operator|==
name|NULL
operator|||
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|!=
name|PT_MIPS_OPTIONS
condition|)
block|{
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf_segment_map
argument_list|)
expr_stmt|;
name|options_segment
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|options_segment
operator|->
name|next
operator|=
operator|*
name|pm
expr_stmt|;
name|options_segment
operator|->
name|p_type
operator|=
name|PT_MIPS_OPTIONS
expr_stmt|;
name|options_segment
operator|->
name|p_flags
operator|=
name|PF_R
expr_stmt|;
name|options_segment
operator|->
name|p_flags_valid
operator|=
name|TRUE
expr_stmt|;
name|options_segment
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|options_segment
operator|->
name|sections
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
operator|*
name|pm
operator|=
name|options_segment
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_irix5
condition|)
block|{
comment|/* If there are .dynamic and .mdebug sections, we make a room 	     for the RTPROC header.  FIXME: Rewrite without section names.  */
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".interp"
argument_list|)
operator|==
name|NULL
operator|&&
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
operator|!=
name|NULL
operator|&&
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".mdebug"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|p_type
operator|==
name|PT_MIPS_RTPROC
condition|)
break|break;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|amt
operator|=
sizeof|sizeof
expr|*
name|m
expr_stmt|;
name|m
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|m
operator|->
name|p_type
operator|=
name|PT_MIPS_RTPROC
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rtproc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|m
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|p_flags
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|p_flags_valid
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
block|}
comment|/* We want to put it after the DYNAMIC segment.  */
name|pm
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
expr_stmt|;
while|while
condition|(
operator|*
name|pm
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|!=
name|PT_DYNAMIC
condition|)
name|pm
operator|=
operator|&
operator|(
operator|*
name|pm
operator|)
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|*
name|pm
operator|!=
name|NULL
condition|)
name|pm
operator|=
operator|&
operator|(
operator|*
name|pm
operator|)
operator|->
name|next
expr_stmt|;
name|m
operator|->
name|next
operator|=
operator|*
name|pm
expr_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
block|}
block|}
block|}
comment|/* On IRIX5, the PT_DYNAMIC segment includes the .dynamic, 	 .dynstr, .dynsym, and .hash sections, and everything in 	 between.  */
for|for
control|(
name|pm
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
operator|*
name|pm
operator|!=
name|NULL
condition|;
name|pm
operator|=
operator|&
operator|(
operator|*
name|pm
operator|)
operator|->
name|next
control|)
if|if
condition|(
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|==
name|PT_DYNAMIC
condition|)
break|break;
name|m
operator|=
operator|*
name|pm
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|IRIX_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|==
name|ict_none
condition|)
block|{
comment|/* For a normal mips executable the permissions for the PT_DYNAMIC 	     segment are read, write and execute. We do that here since 	     the code in elf.c sets only the read permission. This matters 	     sometimes for the dynamic linker.  */
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|m
operator|->
name|p_flags
operator|=
name|PF_R
operator||
name|PF_W
operator||
name|PF_X
expr_stmt|;
name|m
operator|->
name|p_flags_valid
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* GNU/Linux binaries do not need the extended PT_DYNAMIC section. 	 glibc's dynamic linker has traditionally derived the number of 	 tags from the p_filesz field, and sometimes allocates stack 	 arrays of that size.  An overly-big PT_DYNAMIC segment can 	 be actively harmful in such cases.  Making PT_DYNAMIC contain 	 other sections can also make life hard for the prelinker, 	 which might move one of the other sections to a different 	 PT_LOAD segment.  */
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|&&
name|m
operator|!=
name|NULL
operator|&&
name|m
operator|->
name|count
operator|==
literal|1
operator|&&
name|strcmp
argument_list|(
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|->
name|name
argument_list|,
literal|".dynamic"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|sec_names
index|[]
init|=
block|{
literal|".dynamic"
block|,
literal|".dynstr"
block|,
literal|".dynsym"
block|,
literal|".hash"
block|}
decl_stmt|;
name|bfd_vma
name|low
decl_stmt|,
name|high
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|struct
name|elf_segment_map
modifier|*
name|n
decl_stmt|;
name|low
operator|=
operator|~
operator|(
name|bfd_vma
operator|)
literal|0
expr_stmt|;
name|high
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|sec_names
operator|/
sizeof|sizeof
name|sec_names
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|sec_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|sz
decl_stmt|;
if|if
condition|(
name|low
operator|>
name|s
operator|->
name|vma
condition|)
name|low
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|sz
operator|=
name|s
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|high
operator|<
name|s
operator|->
name|vma
operator|+
name|sz
condition|)
name|high
operator|=
name|s
operator|->
name|vma
operator|+
name|sz
expr_stmt|;
block|}
block|}
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
operator|&&
name|s
operator|->
name|vma
operator|>=
name|low
operator|&&
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|size
operator|<=
name|high
condition|)
operator|++
name|c
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
expr|*
name|n
operator|+
call|(
name|bfd_size_type
call|)
argument_list|(
name|c
operator|-
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|n
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
operator|*
name|n
operator|=
operator|*
name|m
expr_stmt|;
name|n
operator|->
name|count
operator|=
name|c
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
operator|&&
name|s
operator|->
name|vma
operator|>=
name|low
operator|&&
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|size
operator|<=
name|high
condition|)
block|{
name|n
operator|->
name|sections
index|[
name|i
index|]
operator|=
name|s
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
operator|*
name|pm
operator|=
name|n
expr_stmt|;
block|}
block|}
comment|/* Allocate a spare program header in dynamic objects so that tools      like the prelinker can add an extra PT_LOAD entry.       If the prelinker needs to make room for a new PT_LOAD entry, its      standard procedure is to move the first (read-only) sections into      the new (writable) segment.  However, the MIPS ABI requires      .dynamic to be in a read-only segment, and the section will often      start within sizeof (ElfNN_Phdr) bytes of the last program header.       Although the prelinker could in principle move .dynamic to a      writable segment, it seems better to allocate a spare program      header instead, and avoid the need to move any sections.      There is a long tradition of allocating spare dynamic tags,      so allocating a spare program header seems like a natural      extension.  */
if|if
condition|(
operator|!
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|&&
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
condition|)
block|{
for|for
control|(
name|pm
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
operator|*
name|pm
operator|!=
name|NULL
condition|;
name|pm
operator|=
operator|&
operator|(
operator|*
name|pm
operator|)
operator|->
name|next
control|)
if|if
condition|(
operator|(
operator|*
name|pm
operator|)
operator|->
name|p_type
operator|==
name|PT_NULL
condition|)
break|break;
if|if
condition|(
operator|*
name|pm
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|m
operator|->
name|p_type
operator|=
name|PT_NULL
expr_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the section that should be marked against GC for a given    relocation.  */
end_comment

begin_function
name|asection
modifier|*
name|_bfd_mips_elf_gc_mark_hook
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
comment|/* ??? Do mips16 stub sections need to be handled special?  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
switch|switch
condition|(
name|ELF_R_TYPE
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_MIPS_GNU_VTINHERIT
case|:
case|case
name|R_MIPS_GNU_VTENTRY
case|:
return|return
name|NULL
return|;
block|}
return|return
name|_bfd_elf_gc_mark_hook
argument_list|(
name|sec
argument_list|,
name|info
argument_list|,
name|rel
argument_list|,
name|h
argument_list|,
name|sym
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Update the got entry reference counts for the section being removed.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_gc_sweep_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
literal|0
block|Elf_Internal_Shdr *symtab_hdr;   struct elf_link_hash_entry **sym_hashes;   bfd_signed_vma *local_got_refcounts;   const Elf_Internal_Rela *rel, *relend;   unsigned long r_symndx;   struct elf_link_hash_entry *h;    symtab_hdr =&elf_tdata (abfd)->symtab_hdr;   sym_hashes = elf_sym_hashes (abfd);   local_got_refcounts = elf_local_got_refcounts (abfd);    relend = relocs + sec->reloc_count;   for (rel = relocs; rel< relend; rel++)     switch (ELF_R_TYPE (abfd, rel->r_info))       {       case R_MIPS_GOT16:       case R_MIPS_CALL16:       case R_MIPS_CALL_HI16:       case R_MIPS_CALL_LO16:       case R_MIPS_GOT_HI16:       case R_MIPS_GOT_LO16:       case R_MIPS_GOT_DISP:       case R_MIPS_GOT_PAGE:       case R_MIPS_GOT_OFST:
comment|/* ??? It would seem that the existing MIPS code does no sort 	   of reference counting or whatnot on its GOT and PLT entries, 	   so it is not possible to garbage collect them at this time.  */
block|break;        default: 	break;       }
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy data from a MIPS ELF indirect symbol to its direct symbol,    hiding the old indirect symbol.  Process additional relocation    information.  Also called for weakdefs, in which case we just let    _bfd_elf_link_hash_copy_indirect copy the flags for us.  */
end_comment

begin_function
name|void
name|_bfd_mips_elf_copy_indirect_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|dir
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|ind
parameter_list|)
block|{
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|dirmips
decl_stmt|,
modifier|*
name|indmips
decl_stmt|;
name|_bfd_elf_link_hash_copy_indirect
argument_list|(
name|info
argument_list|,
name|dir
argument_list|,
name|ind
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_indirect
condition|)
return|return;
name|dirmips
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|dir
expr_stmt|;
name|indmips
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|ind
expr_stmt|;
name|dirmips
operator|->
name|possibly_dynamic_relocs
operator|+=
name|indmips
operator|->
name|possibly_dynamic_relocs
expr_stmt|;
if|if
condition|(
name|indmips
operator|->
name|readonly_reloc
condition|)
name|dirmips
operator|->
name|readonly_reloc
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|indmips
operator|->
name|no_fn_stub
condition|)
name|dirmips
operator|->
name|no_fn_stub
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|dirmips
operator|->
name|tls_type
operator|==
literal|0
condition|)
name|dirmips
operator|->
name|tls_type
operator|=
name|indmips
operator|->
name|tls_type
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_bfd_mips_elf_hide_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|entry
parameter_list|,
name|bfd_boolean
name|force_local
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|got
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_entry
operator|*
operator|)
name|entry
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|forced_local
condition|)
return|return;
name|h
operator|->
name|forced_local
operator|=
name|force_local
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|dynobj
operator|!=
name|NULL
operator|&&
name|force_local
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|STT_TLS
operator|&&
operator|(
name|got
operator|=
name|mips_elf_got_section
argument_list|(
name|dynobj
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|g
operator|=
name|mips_elf_section_data
argument_list|(
name|got
argument_list|)
operator|->
name|u
operator|.
name|got_info
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|g
operator|->
name|next
condition|)
block|{
name|struct
name|mips_got_entry
name|e
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|gg
init|=
name|g
decl_stmt|;
comment|/* Since we're turning what used to be a global symbol into a 	     local one, bump up the number of local entries of each GOT 	     that had an entry for it.  This will automatically decrease 	     the number of global entries, since global_gotno is actually 	     the upper limit of global entries.  */
name|e
operator|.
name|abfd
operator|=
name|dynobj
expr_stmt|;
name|e
operator|.
name|symndx
operator|=
operator|-
literal|1
expr_stmt|;
name|e
operator|.
name|d
operator|.
name|h
operator|=
name|h
expr_stmt|;
name|e
operator|.
name|tls_type
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|g
operator|=
name|g
operator|->
name|next
init|;
name|g
operator|!=
name|gg
condition|;
name|g
operator|=
name|g
operator|->
name|next
control|)
if|if
condition|(
name|htab_find
argument_list|(
name|g
operator|->
name|got_entries
argument_list|,
operator|&
name|e
argument_list|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|g
operator|->
name|global_gotno
operator|>
literal|0
argument_list|)
expr_stmt|;
name|g
operator|->
name|local_gotno
operator|++
expr_stmt|;
name|g
operator|->
name|global_gotno
operator|--
expr_stmt|;
block|}
comment|/* If this was a global symbol forced into the primary GOT, we 	     no longer need an entry for it.  We can't release the entry 	     at this point, but we must at least stop counting it as one 	     of the symbols that required a forced got entry.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|got
operator|.
name|offset
operator|==
literal|2
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|gg
operator|->
name|assigned_gotno
operator|>
literal|0
argument_list|)
expr_stmt|;
name|gg
operator|->
name|assigned_gotno
operator|--
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|g
operator|->
name|global_gotno
operator|==
literal|0
operator|&&
name|g
operator|->
name|global_gotsym
operator|==
name|NULL
condition|)
comment|/* If we haven't got through GOT allocation yet, just bump up the 	   number of local entries, as this symbol won't be counted as 	   global.  */
name|g
operator|->
name|local_gotno
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|got
operator|.
name|offset
operator|==
literal|1
condition|)
block|{
comment|/* If we're past non-multi-GOT allocation and this symbol had 	     been marked for a global got entry, give it a local entry 	     instead.  */
name|BFD_ASSERT
argument_list|(
name|g
operator|->
name|global_gotno
operator|>
literal|0
argument_list|)
expr_stmt|;
name|g
operator|->
name|local_gotno
operator|++
expr_stmt|;
name|g
operator|->
name|global_gotno
operator|--
expr_stmt|;
block|}
block|}
name|_bfd_elf_link_hash_hide_symbol
argument_list|(
name|info
argument_list|,
operator|&
name|h
operator|->
name|root
argument_list|,
name|force_local
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|PDR_SIZE
value|32
end_define

begin_function
name|bfd_boolean
name|_bfd_mips_elf_discard_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|elf_reloc_cookie
modifier|*
name|cookie
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
name|bfd_boolean
name|ret
init|=
name|FALSE
decl_stmt|;
name|unsigned
name|char
modifier|*
name|tdata
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|skip
decl_stmt|;
name|o
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".pdr"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|o
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|o
operator|->
name|size
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|o
operator|->
name|size
operator|%
name|PDR_SIZE
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|o
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
name|bfd_is_abs_section
argument_list|(
name|o
operator|->
name|output_section
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|tdata
operator|=
name|bfd_zmalloc
argument_list|(
name|o
operator|->
name|size
operator|/
name|PDR_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tdata
condition|)
return|return
name|FALSE
return|;
name|cookie
operator|->
name|rels
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cookie
operator|->
name|rels
condition|)
block|{
name|free
argument_list|(
name|tdata
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|cookie
operator|->
name|rel
operator|=
name|cookie
operator|->
name|rels
expr_stmt|;
name|cookie
operator|->
name|relend
operator|=
name|cookie
operator|->
name|rels
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|skip
operator|=
literal|0
init|;
name|i
operator|<
name|o
operator|->
name|size
operator|/
name|PDR_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bfd_elf_reloc_symbol_deleted_p
argument_list|(
name|i
operator|*
name|PDR_SIZE
argument_list|,
name|cookie
argument_list|)
condition|)
block|{
name|tdata
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|skip
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|skip
operator|!=
literal|0
condition|)
block|{
name|mips_elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|u
operator|.
name|tdata
operator|=
name|tdata
expr_stmt|;
name|o
operator|->
name|size
operator|-=
name|skip
operator|*
name|PDR_SIZE
expr_stmt|;
name|ret
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|free
argument_list|(
name|tdata
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|cookie
operator|->
name|rels
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_mips_elf_ignore_discarded_relocs
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".pdr"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_mips_elf_write_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|to
decl_stmt|,
modifier|*
name|from
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".pdr"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|mips_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|u
operator|.
name|tdata
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|to
operator|=
name|contents
expr_stmt|;
name|end
operator|=
name|contents
operator|+
name|sec
operator|->
name|size
expr_stmt|;
for|for
control|(
name|from
operator|=
name|contents
operator|,
name|i
operator|=
literal|0
init|;
name|from
operator|<
name|end
condition|;
name|from
operator|+=
name|PDR_SIZE
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|mips_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|u
operator|.
name|tdata
operator|)
index|[
name|i
index|]
operator|==
literal|1
condition|)
continue|continue;
if|if
condition|(
name|to
operator|!=
name|from
condition|)
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|PDR_SIZE
argument_list|)
expr_stmt|;
name|to
operator|+=
name|PDR_SIZE
expr_stmt|;
block|}
name|bfd_set_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|,
name|contents
argument_list|,
name|sec
operator|->
name|output_offset
argument_list|,
name|sec
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* MIPS ELF uses a special find_nearest_line routine in order the    handle the ECOFF debugging information.  */
end_comment

begin_struct
struct|struct
name|mips_elf_find_line
block|{
name|struct
name|ecoff_debug_info
name|d
decl_stmt|;
name|struct
name|ecoff_find_line
name|i
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|bfd_boolean
name|_bfd_mips_elf_find_nearest_line
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
parameter_list|,
name|unsigned
name|int
modifier|*
name|line_ptr
parameter_list|)
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
if|if
condition|(
name|_bfd_dwarf1_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|offset
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|_bfd_dwarf2_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|offset
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|,
name|ABI_64_P
argument_list|(
name|abfd
argument_list|)
condition|?
literal|8
else|:
literal|0
argument_list|,
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dwarf2_find_line_info
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|msec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".mdebug"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msec
operator|!=
name|NULL
condition|)
block|{
name|flagword
name|origflags
decl_stmt|;
name|struct
name|mips_elf_find_line
modifier|*
name|fi
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
specifier|const
name|swap
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
decl_stmt|;
comment|/* If we are called during a link, mips_elf_final_link may have 	 cleared the SEC_HAS_CONTENTS field.  We force it back on here 	 if appropriate (which it normally will be).  */
name|origflags
operator|=
name|msec
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|msec
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|!=
name|SHT_NOBITS
condition|)
name|msec
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|fi
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|find_line_info
expr_stmt|;
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|external_fdr_size
decl_stmt|;
name|char
modifier|*
name|fraw_src
decl_stmt|;
name|char
modifier|*
name|fraw_end
decl_stmt|;
name|struct
name|fdr
modifier|*
name|fdr_ptr
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|mips_elf_find_line
argument_list|)
decl_stmt|;
name|fi
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
block|{
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|_bfd_mips_elf_read_ecoff_info
argument_list|(
name|abfd
argument_list|,
name|msec
argument_list|,
operator|&
name|fi
operator|->
name|d
argument_list|)
condition|)
block|{
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Swap in the FDR information.  */
name|amt
operator|=
name|fi
operator|->
name|d
operator|.
name|symbolic_header
operator|.
name|ifdMax
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fdr
argument_list|)
expr_stmt|;
name|fi
operator|->
name|d
operator|.
name|fdr
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|d
operator|.
name|fdr
operator|==
name|NULL
condition|)
block|{
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|external_fdr_size
operator|=
name|swap
operator|->
name|external_fdr_size
expr_stmt|;
name|fdr_ptr
operator|=
name|fi
operator|->
name|d
operator|.
name|fdr
expr_stmt|;
name|fraw_src
operator|=
operator|(
name|char
operator|*
operator|)
name|fi
operator|->
name|d
operator|.
name|external_fdr
expr_stmt|;
name|fraw_end
operator|=
operator|(
name|fraw_src
operator|+
name|fi
operator|->
name|d
operator|.
name|symbolic_header
operator|.
name|ifdMax
operator|*
name|external_fdr_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|fraw_src
operator|<
name|fraw_end
condition|;
name|fraw_src
operator|+=
name|external_fdr_size
operator|,
name|fdr_ptr
operator|++
control|)
call|(
modifier|*
name|swap
operator|->
name|swap_fdr_in
call|)
argument_list|(
name|abfd
argument_list|,
name|fraw_src
argument_list|,
name|fdr_ptr
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|find_line_info
operator|=
name|fi
expr_stmt|;
comment|/* Note that we don't bother to ever free this information.              find_nearest_line is either called all the time, as in              objdump -l, so the information should be saved, or it is              rarely called, as in ld error messages, so the memory              wasted is unimportant.  Still, it would probably be a              good idea for free_cached_info to throw it away.  */
block|}
if|if
condition|(
name|_bfd_ecoff_locate_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|offset
argument_list|,
operator|&
name|fi
operator|->
name|d
argument_list|,
name|swap
argument_list|,
operator|&
name|fi
operator|->
name|i
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|)
condition|)
block|{
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|msec
operator|->
name|flags
operator|=
name|origflags
expr_stmt|;
block|}
comment|/* Fall back on the generic ELF find_nearest_line routine.  */
return|return
name|_bfd_elf_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|offset
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_mips_elf_find_inliner_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
parameter_list|,
name|unsigned
name|int
modifier|*
name|line_ptr
parameter_list|)
block|{
name|bfd_boolean
name|found
decl_stmt|;
name|found
operator|=
name|_bfd_dwarf2_find_inliner_info
argument_list|(
name|abfd
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dwarf2_find_line_info
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* When are writing out the .options or .MIPS.options section,    remember the bytes we are writing out, so that we can install the    GP value in the section_processing routine.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_set_section_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|sec_ptr
name|section
parameter_list|,
specifier|const
name|void
modifier|*
name|location
parameter_list|,
name|file_ptr
name|offset
parameter_list|,
name|bfd_size_type
name|count
parameter_list|)
block|{
if|if
condition|(
name|MIPS_ELF_OPTIONS_SECTION_NAME_P
argument_list|(
name|section
operator|->
name|name
argument_list|)
condition|)
block|{
name|bfd_byte
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_elf_section_data
argument_list|)
decl_stmt|;
name|section
operator|->
name|used_by_bfd
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
name|c
operator|=
name|mips_elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|u
operator|.
name|tdata
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|c
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|mips_elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|u
operator|.
name|tdata
operator|=
name|c
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|c
operator|+
name|offset
argument_list|,
name|location
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
return|return
name|_bfd_elf_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|location
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This is almost identical to bfd_generic_get_... except that some    MIPS relocations need to be handled specially.  Sigh.  */
end_comment

begin_function
name|bfd_byte
modifier|*
name|_bfd_elf_mips_get_relocated_section_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|struct
name|bfd_link_order
modifier|*
name|link_order
parameter_list|,
name|bfd_byte
modifier|*
name|data
parameter_list|,
name|bfd_boolean
name|relocatable
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|)
block|{
comment|/* Get enough memory to hold the stuff */
name|bfd
modifier|*
name|input_bfd
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
name|input_section
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
name|bfd_size_type
name|sz
decl_stmt|;
name|long
name|reloc_size
init|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|reloc_vector
init|=
name|NULL
decl_stmt|;
name|long
name|reloc_count
decl_stmt|;
if|if
condition|(
name|reloc_size
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|reloc_vector
operator|=
name|bfd_malloc
argument_list|(
name|reloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_vector
operator|==
name|NULL
operator|&&
name|reloc_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* read in the section */
name|sz
operator|=
name|input_section
operator|->
name|rawsize
condition|?
name|input_section
operator|->
name|rawsize
else|:
name|input_section
operator|->
name|size
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|sz
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|reloc_count
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|reloc_vector
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_count
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|arelent
modifier|*
modifier|*
name|parent
decl_stmt|;
comment|/* for mips */
name|int
name|gp_found
decl_stmt|;
name|bfd_vma
name|gp
init|=
literal|0x12345678
decl_stmt|;
comment|/* initialize just to shut gcc up */
block|{
name|struct
name|bfd_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|lh
decl_stmt|;
comment|/* Skip all this stuff if we aren't mixing formats.  */
if|if
condition|(
name|abfd
operator|&&
name|input_bfd
operator|&&
name|abfd
operator|->
name|xvec
operator|==
name|input_bfd
operator|->
name|xvec
condition|)
name|lh
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|h
operator|=
name|bfd_hash_lookup
argument_list|(
operator|&
name|link_info
operator|->
name|hash
operator|->
name|table
argument_list|,
literal|"_gp"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|lh
operator|=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
block|}
name|lookup
label|:
if|if
condition|(
name|lh
condition|)
block|{
switch|switch
condition|(
name|lh
operator|->
name|type
condition|)
block|{
case|case
name|bfd_link_hash_undefined
case|:
case|case
name|bfd_link_hash_undefweak
case|:
case|case
name|bfd_link_hash_common
case|:
name|gp_found
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
name|gp_found
operator|=
literal|1
expr_stmt|;
name|gp
operator|=
name|lh
operator|->
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
break|break;
case|case
name|bfd_link_hash_indirect
case|:
case|case
name|bfd_link_hash_warning
case|:
name|lh
operator|=
name|lh
operator|->
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* @@FIXME  ignoring warning for now */
goto|goto
name|lookup
goto|;
case|case
name|bfd_link_hash_new
case|:
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|gp_found
operator|=
literal|0
expr_stmt|;
block|}
comment|/* end mips */
for|for
control|(
name|parent
operator|=
name|reloc_vector
init|;
operator|*
name|parent
operator|!=
name|NULL
condition|;
name|parent
operator|++
control|)
block|{
name|char
modifier|*
name|error_message
init|=
name|NULL
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
comment|/* Specific to MIPS: Deal with relocation types that require 	     knowing the gp of the output bfd.  */
name|asymbol
modifier|*
name|sym
init|=
operator|*
operator|(
operator|*
name|parent
operator|)
operator|->
name|sym_ptr_ptr
decl_stmt|;
comment|/* If we've managed to find the gp and have a special 	     function for the relocation then go ahead, else default 	     to the generic handling.  */
if|if
condition|(
name|gp_found
operator|&&
operator|(
operator|*
name|parent
operator|)
operator|->
name|howto
operator|->
name|special_function
operator|==
name|_bfd_mips_elf32_gprel16_reloc
condition|)
name|r
operator|=
name|_bfd_mips_elf_gprel16_with_gp
argument_list|(
name|input_bfd
argument_list|,
name|sym
argument_list|,
operator|*
name|parent
argument_list|,
name|input_section
argument_list|,
name|relocatable
argument_list|,
name|data
argument_list|,
name|gp
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|bfd_perform_relocation
argument_list|(
name|input_bfd
argument_list|,
operator|*
name|parent
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|relocatable
condition|?
name|abfd
else|:
name|NULL
argument_list|,
operator|&
name|error_message
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocatable
condition|)
block|{
name|asection
modifier|*
name|os
init|=
name|input_section
operator|->
name|output_section
decl_stmt|;
comment|/* A partial link, so keep the relocs */
name|os
operator|->
name|orelocation
index|[
name|os
operator|->
name|reloc_count
index|]
operator|=
operator|*
name|parent
expr_stmt|;
name|os
operator|->
name|reloc_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_undefined
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|link_info
argument_list|,
name|bfd_asymbol_name
argument_list|(
operator|*
operator|(
operator|*
name|parent
operator|)
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
operator|*
name|parent
operator|)
operator|->
name|address
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
break|break;
case|case
name|bfd_reloc_dangerous
case|:
name|BFD_ASSERT
argument_list|(
name|error_message
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|link_info
argument_list|,
name|error_message
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
operator|*
name|parent
operator|)
operator|->
name|address
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
break|break;
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|link_info
argument_list|,
name|NULL
argument_list|,
name|bfd_asymbol_name
argument_list|(
operator|*
operator|(
operator|*
name|parent
operator|)
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
operator|(
operator|*
name|parent
operator|)
operator|->
name|howto
operator|->
name|name
argument_list|,
operator|(
operator|*
name|parent
operator|)
operator|->
name|addend
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
operator|*
name|parent
operator|)
operator|->
name|address
argument_list|)
operator|)
condition|)
goto|goto
name|error_return
goto|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|reloc_vector
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|reloc_vector
argument_list|)
expr_stmt|;
return|return
name|data
return|;
name|error_return
label|:
if|if
condition|(
name|reloc_vector
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|reloc_vector
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a MIPS ELF linker hash table.  */
end_comment

begin_function
name|struct
name|bfd_link_hash_table
modifier|*
name|_bfd_mips_elf_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|mips_elf_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|mips_elf_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|mips_elf_link_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mips_elf_link_hash_entry
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|#
directive|if
literal|0
comment|/* We no longer use this.  */
block|for (i = 0; i< SIZEOF_MIPS_DYNSYM_SECNAMES; i++)     ret->dynsym_sec_strindex[i] = (bfd_size_type) -1;
endif|#
directive|endif
name|ret
operator|->
name|procedure_count
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|compact_rel_size
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|use_rld_obj_head
operator|=
name|FALSE
expr_stmt|;
name|ret
operator|->
name|rld_value
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|mips16_stubs_seen
operator|=
name|FALSE
expr_stmt|;
name|ret
operator|->
name|is_vxworks
operator|=
name|FALSE
expr_stmt|;
name|ret
operator|->
name|srelbss
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|sdynbss
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|srelplt
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|srelplt2
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|sgotplt
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|splt
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|plt_header_size
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|plt_entry_size
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|function_stub_size
operator|=
literal|0
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Likewise, but indicate that the target is VxWorks.  */
end_comment

begin_function
name|struct
name|bfd_link_hash_table
modifier|*
name|_bfd_mips_vxworks_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|bfd_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|_bfd_mips_elf_link_hash_table_create
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|struct
name|mips_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
operator|(
expr|struct
name|mips_elf_link_hash_table
operator|*
operator|)
name|ret
expr_stmt|;
name|htab
operator|->
name|is_vxworks
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We need to use a special link routine to handle the .reginfo and    the .mdebug sections.  We need to merge all instances of these    sections together, not write them all out sequentially.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_final_link
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|p
decl_stmt|;
name|asection
modifier|*
name|reginfo_sec
decl_stmt|,
modifier|*
name|mdebug_sec
decl_stmt|,
modifier|*
name|gptab_data_sec
decl_stmt|,
modifier|*
name|gptab_bss_sec
decl_stmt|;
name|asection
modifier|*
name|rtproc_sec
decl_stmt|;
name|Elf32_RegInfo
name|reginfo
decl_stmt|;
name|struct
name|ecoff_debug_info
name|debug
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|swap
init|=
name|bed
operator|->
name|elf_backend_ecoff_debug_swap
decl_stmt|;
name|HDRR
modifier|*
name|symhdr
init|=
operator|&
name|debug
operator|.
name|symbolic_header
decl_stmt|;
name|void
modifier|*
name|mdebug_handle
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|EXTR
name|esym
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|struct
name|mips_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|secname
index|[]
init|=
block|{
literal|".text"
block|,
literal|".init"
block|,
literal|".fini"
block|,
literal|".data"
block|,
literal|".rodata"
block|,
literal|".sdata"
block|,
literal|".sbss"
block|,
literal|".bss"
block|}
decl_stmt|;
specifier|static
specifier|const
name|int
name|sc
index|[]
init|=
block|{
name|scText
block|,
name|scInit
block|,
name|scFini
block|,
name|scData
block|,
name|scRData
block|,
name|scSData
block|,
name|scSBss
block|,
name|scBss
block|}
decl_stmt|;
comment|/* We'd carefully arranged the dynamic symbol indices, and then the      generic size_dynamic_sections renumbered them out from under us.      Rather than trying somehow to prevent the renumbering, just do      the sort again.  */
name|htab
operator|=
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|got
decl_stmt|;
name|struct
name|mips_got_info
modifier|*
name|g
decl_stmt|;
name|bfd_size_type
name|dynsecsymcount
decl_stmt|;
comment|/* When we resort, we must tell mips_elf_sort_hash_table what 	 the lowest index it may use is.  That's the number of section 	 symbols we're going to add.  The generic ELF linker only 	 adds these symbols when building a shared object.  Note that 	 we count the sections after (possibly) removing the .options 	 section above.  */
name|dynsecsymcount
operator|=
name|count_section_dynsyms
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mips_elf_sort_hash_table
argument_list|(
name|info
argument_list|,
name|dynsecsymcount
operator|+
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Make sure we didn't grow the global .got region.  */
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|got
operator|=
name|mips_elf_got_section
argument_list|(
name|dynobj
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|g
operator|=
name|mips_elf_section_data
argument_list|(
name|got
argument_list|)
operator|->
name|u
operator|.
name|got_info
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|global_gotsym
operator|!=
name|NULL
condition|)
name|BFD_ASSERT
argument_list|(
operator|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynsymcount
operator|-
name|g
operator|->
name|global_gotsym
operator|->
name|dynindx
operator|)
operator|<=
name|g
operator|->
name|global_gotno
argument_list|)
expr_stmt|;
block|}
comment|/* Get a value for the GP register.  */
if|if
condition|(
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
literal|"_gp"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
condition|)
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|htab
operator|->
name|is_vxworks
operator|&&
operator|(
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|&&
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
condition|)
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
block|{
name|bfd_vma
name|lo
init|=
name|MINUS_ONE
decl_stmt|;
comment|/* Find the GP-relative section with the lowest offset.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
if|if
condition|(
name|o
operator|->
name|vma
operator|<
name|lo
operator|&&
operator|(
name|elf_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_flags
operator|&
name|SHF_MIPS_GPREL
operator|)
condition|)
name|lo
operator|=
name|o
operator|->
name|vma
expr_stmt|;
comment|/* And calculate GP relative to that.  */
name|elf_gp
argument_list|(
name|abfd
argument_list|)
operator|=
name|lo
operator|+
name|ELF_MIPS_GP_OFFSET
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the relocate_section function needs to do a reloc 	     involving the GP value, it should make a reloc_dangerous 	     callback to warn that GP is not defined.  */
block|}
block|}
comment|/* Go through the sections and collect the .reginfo and .mdebug      information.  */
name|reginfo_sec
operator|=
name|NULL
expr_stmt|;
name|mdebug_sec
operator|=
name|NULL
expr_stmt|;
name|gptab_data_sec
operator|=
name|NULL
expr_stmt|;
name|gptab_bss_sec
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".reginfo"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|memset
argument_list|(
operator|&
name|reginfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|reginfo
argument_list|)
expr_stmt|;
comment|/* We have found the .reginfo section in the output file. 	     Look through all the link_orders comprising it and merge 	     the information together.  */
for|for
control|(
name|p
operator|=
name|o
operator|->
name|map_head
operator|.
name|link_order
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|Elf32_External_RegInfo
name|ext
decl_stmt|;
name|Elf32_RegInfo
name|sub
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|bfd_indirect_link_order
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_data_link_order
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
block|}
name|input_section
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
name|input_bfd
operator|=
name|input_section
operator|->
name|owner
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|&
name|ext
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ext
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|bfd_mips_elf32_swap_reginfo_in
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|ext
argument_list|,
operator|&
name|sub
argument_list|)
expr_stmt|;
name|reginfo
operator|.
name|ri_gprmask
operator||=
name|sub
operator|.
name|ri_gprmask
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|0
index|]
operator||=
name|sub
operator|.
name|ri_cprmask
index|[
literal|0
index|]
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|1
index|]
operator||=
name|sub
operator|.
name|ri_cprmask
index|[
literal|1
index|]
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|2
index|]
operator||=
name|sub
operator|.
name|ri_cprmask
index|[
literal|2
index|]
expr_stmt|;
name|reginfo
operator|.
name|ri_cprmask
index|[
literal|3
index|]
operator||=
name|sub
operator|.
name|ri_cprmask
index|[
literal|3
index|]
expr_stmt|;
comment|/* ri_gp_value is set by the function 		 mips_elf32_section_processing when the section is 		 finally written out.  */
comment|/* Hack: reset the SEC_HAS_CONTENTS flag so that 		 elf_link_input_bfd ignores this section.  */
name|input_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
comment|/* Size has been set in _bfd_mips_elf_always_size_sections.  */
name|BFD_ASSERT
argument_list|(
name|o
operator|->
name|size
operator|==
sizeof|sizeof
argument_list|(
name|Elf32_External_RegInfo
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip this section later on (I don't think this currently 	     matters, but someday it might).  */
name|o
operator|->
name|map_head
operator|.
name|link_order
operator|=
name|NULL
expr_stmt|;
name|reginfo_sec
operator|=
name|o
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".mdebug"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|extsym_info
name|einfo
decl_stmt|;
name|bfd_vma
name|last
decl_stmt|;
comment|/* We have found the .mdebug section in the output file. 	     Look through all the link_orders comprising it and merge 	     the information together.  */
name|symhdr
operator|->
name|magic
operator|=
name|swap
operator|->
name|sym_magic
expr_stmt|;
comment|/* FIXME: What should the version stamp be?  */
name|symhdr
operator|->
name|vstamp
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ilineMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|cbLine
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|idnMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ipdMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|isymMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ioptMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|iauxMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|issMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|issExtMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|ifdMax
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|crfd
operator|=
literal|0
expr_stmt|;
name|symhdr
operator|->
name|iextMax
operator|=
literal|0
expr_stmt|;
comment|/* We accumulate the debugging information itself in the 	     debug_info structure.  */
name|debug
operator|.
name|line
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_dnr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_pdr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_sym
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_opt
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_aux
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|ss
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|ssext
operator|=
name|debug
operator|.
name|ssext_end
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_fdr
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_rfd
operator|=
name|NULL
expr_stmt|;
name|debug
operator|.
name|external_ext
operator|=
name|debug
operator|.
name|external_ext_end
operator|=
name|NULL
expr_stmt|;
name|mdebug_handle
operator|=
name|bfd_ecoff_debug_init
argument_list|(
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdebug_handle
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|esym
operator|.
name|jmptbl
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|cobol_main
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|weakext
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|ifd
operator|=
name|ifdNil
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|iss
operator|=
name|issNil
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|st
operator|=
name|stLocal
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|esym
operator|.
name|asym
operator|.
name|index
operator|=
name|indexNil
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|secname
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|secname
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|esym
operator|.
name|asym
operator|.
name|sc
operator|=
name|sc
index|[
name|i
index|]
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|secname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|last
operator|=
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|size
expr_stmt|;
block|}
else|else
name|esym
operator|.
name|asym
operator|.
name|value
operator|=
name|last
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_ecoff_debug_one_external
argument_list|(
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|secname
index|[
name|i
index|]
argument_list|,
operator|&
name|esym
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|p
operator|=
name|o
operator|->
name|map_head
operator|.
name|link_order
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
specifier|const
name|struct
name|ecoff_debug_swap
modifier|*
name|input_swap
decl_stmt|;
name|struct
name|ecoff_debug_info
name|input_debug
decl_stmt|;
name|char
modifier|*
name|eraw_src
decl_stmt|;
name|char
modifier|*
name|eraw_end
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|bfd_indirect_link_order
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_data_link_order
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
block|}
name|input_section
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
name|input_bfd
operator|=
name|input_section
operator|->
name|owner
expr_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|input_bfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
operator|(
name|get_elf_backend_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* I don't know what a non MIPS ELF bfd would be 		     doing with a .mdebug section, but I don't really 		     want to deal with it.  */
continue|continue;
block|}
name|input_swap
operator|=
operator|(
name|get_elf_backend_data
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|elf_backend_ecoff_debug_swap
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|p
operator|->
name|size
operator|==
name|input_section
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* The ECOFF linking code expects that we have already 		 read in the debugging information and set up an 		 ecoff_debug_info structure, so we do that now.  */
if|if
condition|(
operator|!
name|_bfd_mips_elf_read_ecoff_info
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|&
name|input_debug
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
operator|(
name|bfd_ecoff_debug_accumulate
argument_list|(
name|mdebug_handle
argument_list|,
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|input_bfd
argument_list|,
operator|&
name|input_debug
argument_list|,
name|input_swap
argument_list|,
name|info
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* Loop through the external symbols.  For each one with 		 interesting information, try to find the symbol in 		 the linker global hash table and save the information 		 for the output external symbols.  */
name|eraw_src
operator|=
name|input_debug
operator|.
name|external_ext
expr_stmt|;
name|eraw_end
operator|=
operator|(
name|eraw_src
operator|+
operator|(
name|input_debug
operator|.
name|symbolic_header
operator|.
name|iextMax
operator|*
name|input_swap
operator|->
name|external_ext_size
operator|)
operator|)
expr_stmt|;
for|for
control|(
init|;
name|eraw_src
operator|<
name|eraw_end
condition|;
name|eraw_src
operator|+=
name|input_swap
operator|->
name|external_ext_size
control|)
block|{
name|EXTR
name|ext
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|mips_elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
call|(
modifier|*
name|input_swap
operator|->
name|swap_ext_in
call|)
argument_list|(
name|input_bfd
argument_list|,
name|eraw_src
argument_list|,
operator|&
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
operator|.
name|asym
operator|.
name|sc
operator|==
name|scNil
operator|||
name|ext
operator|.
name|asym
operator|.
name|sc
operator|==
name|scUndefined
operator|||
name|ext
operator|.
name|asym
operator|.
name|sc
operator|==
name|scSUndefined
condition|)
continue|continue;
name|name
operator|=
name|input_debug
operator|.
name|ssext
operator|+
name|ext
operator|.
name|asym
operator|.
name|iss
expr_stmt|;
name|h
operator|=
name|mips_elf_link_hash_lookup
argument_list|(
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|h
operator|->
name|esym
operator|.
name|ifd
operator|!=
operator|-
literal|2
condition|)
continue|continue;
if|if
condition|(
name|ext
operator|.
name|ifd
operator|!=
operator|-
literal|1
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|ext
operator|.
name|ifd
operator|<
name|input_debug
operator|.
name|symbolic_header
operator|.
name|ifdMax
argument_list|)
expr_stmt|;
name|ext
operator|.
name|ifd
operator|=
name|input_debug
operator|.
name|ifdmap
index|[
name|ext
operator|.
name|ifd
index|]
expr_stmt|;
block|}
name|h
operator|->
name|esym
operator|=
name|ext
expr_stmt|;
block|}
comment|/* Free up the information we just read.  */
name|free
argument_list|(
name|input_debug
operator|.
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_dnr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_pdr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_sym
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_opt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_aux
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|ss
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|ssext
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_fdr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_rfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_debug
operator|.
name|external_ext
argument_list|)
expr_stmt|;
comment|/* Hack: reset the SEC_HAS_CONTENTS flag so that 		 elf_link_input_bfd ignores this section.  */
name|input_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
operator|&&
name|info
operator|->
name|shared
condition|)
block|{
comment|/* Create .rtproc section.  */
name|rtproc_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rtproc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtproc_sec
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
init|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
decl_stmt|;
name|rtproc_sec
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".rtproc"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtproc_sec
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|rtproc_sec
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|mips_elf_create_procedure_table
argument_list|(
name|mdebug_handle
argument_list|,
name|abfd
argument_list|,
name|info
argument_list|,
name|rtproc_sec
argument_list|,
operator|&
name|debug
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Build the external symbol information.  */
name|einfo
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|einfo
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|einfo
operator|.
name|debug
operator|=
operator|&
name|debug
expr_stmt|;
name|einfo
operator|.
name|swap
operator|=
name|swap
expr_stmt|;
name|einfo
operator|.
name|failed
operator|=
name|FALSE
expr_stmt|;
name|mips_elf_link_hash_traverse
argument_list|(
name|mips_elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|mips_elf_output_extsym
argument_list|,
operator|&
name|einfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|einfo
operator|.
name|failed
condition|)
return|return
name|FALSE
return|;
comment|/* Set the size of the .mdebug section.  */
name|o
operator|->
name|size
operator|=
name|bfd_ecoff_debug_size
argument_list|(
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|)
expr_stmt|;
comment|/* Skip this section later on (I don't think this currently 	     matters, but someday it might).  */
name|o
operator|->
name|map_head
operator|.
name|link_order
operator|=
name|NULL
expr_stmt|;
name|mdebug_sec
operator|=
name|o
expr_stmt|;
block|}
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".gptab."
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|subname
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|Elf32_gptab
modifier|*
name|tab
decl_stmt|;
name|Elf32_External_gptab
modifier|*
name|ext_tab
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
comment|/* The .gptab.sdata and .gptab.sbss sections hold 	     information describing how the small data area would 	     change depending upon the -G switch.  These sections 	     not used in executables files.  */
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
condition|)
block|{
for|for
control|(
name|p
operator|=
name|o
operator|->
name|map_head
operator|.
name|link_order
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|bfd_indirect_link_order
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_data_link_order
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
block|}
name|input_section
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
comment|/* Hack: reset the SEC_HAS_CONTENTS flag so that 		     elf_link_input_bfd ignores this section.  */
name|input_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
comment|/* Skip this section later on (I don't think this 		 currently matters, but someday it might).  */
name|o
operator|->
name|map_head
operator|.
name|link_order
operator|=
name|NULL
expr_stmt|;
comment|/* Really remove the section.  */
name|bfd_section_list_remove
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
expr_stmt|;
operator|--
name|abfd
operator|->
name|section_count
expr_stmt|;
continue|continue;
block|}
comment|/* There is one gptab for initialized data, and one for 	     uninitialized data.  */
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".gptab.sdata"
argument_list|)
operator|==
literal|0
condition|)
name|gptab_data_sec
operator|=
name|o
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|o
operator|->
name|name
argument_list|,
literal|".gptab.sbss"
argument_list|)
operator|==
literal|0
condition|)
name|gptab_bss_sec
operator|=
name|o
expr_stmt|;
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: illegal section name `%s'"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|o
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_nonrepresentable_section
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* The linker script always combines .gptab.data and 	     .gptab.sdata into .gptab.sdata, and likewise for 	     .gptab.bss and .gptab.sbss.  It is possible that there is 	     no .sdata or .sbss section in the output file, in which 	     case we must change the name of the output section.  */
name|subname
operator|=
name|o
operator|->
name|name
operator|+
sizeof|sizeof
expr|".gptab"
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|subname
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|o
operator|==
name|gptab_data_sec
condition|)
name|o
operator|->
name|name
operator|=
literal|".gptab.data"
expr_stmt|;
else|else
name|o
operator|->
name|name
operator|=
literal|".gptab.bss"
expr_stmt|;
name|subname
operator|=
name|o
operator|->
name|name
operator|+
sizeof|sizeof
expr|".gptab"
operator|-
literal|1
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|subname
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Set up the first entry.  */
name|c
operator|=
literal|1
expr_stmt|;
name|amt
operator|=
name|c
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_gptab
argument_list|)
expr_stmt|;
name|tab
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|tab
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|tab
index|[
literal|0
index|]
operator|.
name|gt_header
operator|.
name|gt_current_g_value
operator|=
name|elf_gp_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|tab
index|[
literal|0
index|]
operator|.
name|gt_header
operator|.
name|gt_unused
operator|=
literal|0
expr_stmt|;
comment|/* Combine the input sections.  */
for|for
control|(
name|p
operator|=
name|o
operator|->
name|map_head
operator|.
name|link_order
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|unsigned
name|long
name|last
decl_stmt|;
name|bfd_size_type
name|gpentry
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|bfd_indirect_link_order
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|bfd_data_link_order
condition|)
continue|continue;
name|abort
argument_list|()
expr_stmt|;
block|}
name|input_section
operator|=
name|p
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
expr_stmt|;
name|input_bfd
operator|=
name|input_section
operator|->
name|owner
expr_stmt|;
comment|/* Combine the gptab entries for this input section one 		 by one.  We know that the input gptab entries are 		 sorted by ascending -G value.  */
name|size
operator|=
name|input_section
operator|->
name|size
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|gpentry
operator|=
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
init|;
name|gpentry
operator|<
name|size
condition|;
name|gpentry
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
control|)
block|{
name|Elf32_External_gptab
name|ext_gptab
decl_stmt|;
name|Elf32_gptab
name|int_gptab
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|unsigned
name|long
name|add
decl_stmt|;
name|bfd_boolean
name|exact
decl_stmt|;
name|unsigned
name|int
name|look
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|&
name|ext_gptab
argument_list|,
name|gpentry
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|tab
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|bfd_mips_elf32_swap_gptab_in
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|ext_gptab
argument_list|,
operator|&
name|int_gptab
argument_list|)
expr_stmt|;
name|val
operator|=
name|int_gptab
operator|.
name|gt_entry
operator|.
name|gt_g_value
expr_stmt|;
name|add
operator|=
name|int_gptab
operator|.
name|gt_entry
operator|.
name|gt_bytes
operator|-
name|last
expr_stmt|;
name|exact
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|look
operator|=
literal|1
init|;
name|look
operator|<
name|c
condition|;
name|look
operator|++
control|)
block|{
if|if
condition|(
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|>=
name|val
condition|)
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_bytes
operator|+=
name|add
expr_stmt|;
if|if
condition|(
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|==
name|val
condition|)
name|exact
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|exact
condition|)
block|{
name|Elf32_gptab
modifier|*
name|new_tab
decl_stmt|;
name|unsigned
name|int
name|max
decl_stmt|;
comment|/* We need a new table entry.  */
name|amt
operator|=
call|(
name|bfd_size_type
call|)
argument_list|(
name|c
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_gptab
argument_list|)
expr_stmt|;
name|new_tab
operator|=
name|bfd_realloc
argument_list|(
name|tab
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tab
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tab
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|tab
operator|=
name|new_tab
expr_stmt|;
name|tab
index|[
name|c
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|=
name|val
expr_stmt|;
name|tab
index|[
name|c
index|]
operator|.
name|gt_entry
operator|.
name|gt_bytes
operator|=
name|add
expr_stmt|;
comment|/* Merge in the size for the next smallest -G 			 value, since that will be implied by this new 			 value.  */
name|max
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|look
operator|=
literal|1
init|;
name|look
operator|<
name|c
condition|;
name|look
operator|++
control|)
block|{
if|if
condition|(
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|<
name|val
operator|&&
operator|(
name|max
operator|==
literal|0
operator|||
operator|(
name|tab
index|[
name|look
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|>
name|tab
index|[
name|max
index|]
operator|.
name|gt_entry
operator|.
name|gt_g_value
operator|)
operator|)
condition|)
name|max
operator|=
name|look
expr_stmt|;
block|}
if|if
condition|(
name|max
operator|!=
literal|0
condition|)
name|tab
index|[
name|c
index|]
operator|.
name|gt_entry
operator|.
name|gt_bytes
operator|+=
name|tab
index|[
name|max
index|]
operator|.
name|gt_entry
operator|.
name|gt_bytes
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
name|last
operator|=
name|int_gptab
operator|.
name|gt_entry
operator|.
name|gt_bytes
expr_stmt|;
block|}
comment|/* Hack: reset the SEC_HAS_CONTENTS flag so that 		 elf_link_input_bfd ignores this section.  */
name|input_section
operator|->
name|flags
operator|&=
operator|~
name|SEC_HAS_CONTENTS
expr_stmt|;
block|}
comment|/* The table must be sorted by -G value.  */
if|if
condition|(
name|c
operator|>
literal|2
condition|)
name|qsort
argument_list|(
name|tab
operator|+
literal|1
argument_list|,
name|c
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|tab
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|gptab_compare
argument_list|)
expr_stmt|;
comment|/* Swap out the table.  */
name|amt
operator|=
operator|(
name|bfd_size_type
operator|)
name|c
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
expr_stmt|;
name|ext_tab
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_tab
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tab
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|c
condition|;
name|j
operator|++
control|)
name|bfd_mips_elf32_swap_gptab_out
argument_list|(
name|abfd
argument_list|,
name|tab
operator|+
name|j
argument_list|,
name|ext_tab
operator|+
name|j
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tab
argument_list|)
expr_stmt|;
name|o
operator|->
name|size
operator|=
name|c
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_gptab
argument_list|)
expr_stmt|;
name|o
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|ext_tab
expr_stmt|;
comment|/* Skip this section later on (I don't think this currently 	     matters, but someday it might).  */
name|o
operator|->
name|map_head
operator|.
name|link_order
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Invoke the regular ELF backend linker to do all the work.  */
if|if
condition|(
operator|!
name|bfd_elf_final_link
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Now write out the computed sections.  */
if|if
condition|(
name|reginfo_sec
operator|!=
name|NULL
condition|)
block|{
name|Elf32_External_RegInfo
name|ext
decl_stmt|;
name|bfd_mips_elf32_swap_reginfo_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|reginfo
argument_list|,
operator|&
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|reginfo_sec
argument_list|,
operator|&
name|ext
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ext
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|mdebug_sec
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|abfd
operator|->
name|output_has_begun
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_ecoff_write_accumulated_debug
argument_list|(
name|mdebug_handle
argument_list|,
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|info
argument_list|,
name|mdebug_sec
operator|->
name|filepos
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|bfd_ecoff_debug_free
argument_list|(
name|mdebug_handle
argument_list|,
name|abfd
argument_list|,
operator|&
name|debug
argument_list|,
name|swap
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gptab_data_sec
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|gptab_data_sec
argument_list|,
name|gptab_data_sec
operator|->
name|contents
argument_list|,
literal|0
argument_list|,
name|gptab_data_sec
operator|->
name|size
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|gptab_bss_sec
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|gptab_bss_sec
argument_list|,
name|gptab_bss_sec
operator|->
name|contents
argument_list|,
literal|0
argument_list|,
name|gptab_bss_sec
operator|->
name|size
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|SGI_COMPAT
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|rtproc_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".rtproc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtproc_sec
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|rtproc_sec
argument_list|,
name|rtproc_sec
operator|->
name|contents
argument_list|,
literal|0
argument_list|,
name|rtproc_sec
operator|->
name|size
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Structure for saying that BFD machine EXTENSION extends BASE.  */
end_comment

begin_struct
struct|struct
name|mips_mach_extension
block|{
name|unsigned
name|long
name|extension
decl_stmt|,
name|base
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* An array describing how BFD machines relate to one another.  The entries    are ordered topologically with MIPS I extensions listed last.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|mips_mach_extension
name|mips_mach_extensions
index|[]
init|=
block|{
comment|/* MIPS64 extensions.  */
block|{
name|bfd_mach_mipsisa64r2
block|,
name|bfd_mach_mipsisa64
block|}
block|,
block|{
name|bfd_mach_mips_sb1
block|,
name|bfd_mach_mipsisa64
block|}
block|,
comment|/* MIPS V extensions.  */
block|{
name|bfd_mach_mipsisa64
block|,
name|bfd_mach_mips5
block|}
block|,
comment|/* R10000 extensions.  */
block|{
name|bfd_mach_mips12000
block|,
name|bfd_mach_mips10000
block|}
block|,
comment|/* R5000 extensions.  Note: the vr5500 ISA is an extension of the core      vr5400 ISA, but doesn't include the multimedia stuff.  It seems      better to allow vr5400 and vr5500 code to be merged anyway, since      many libraries will just use the core ISA.  Perhaps we could add      some sort of ASE flag if this ever proves a problem.  */
block|{
name|bfd_mach_mips5500
block|,
name|bfd_mach_mips5400
block|}
block|,
block|{
name|bfd_mach_mips5400
block|,
name|bfd_mach_mips5000
block|}
block|,
comment|/* MIPS IV extensions.  */
block|{
name|bfd_mach_mips5
block|,
name|bfd_mach_mips8000
block|}
block|,
block|{
name|bfd_mach_mips10000
block|,
name|bfd_mach_mips8000
block|}
block|,
block|{
name|bfd_mach_mips5000
block|,
name|bfd_mach_mips8000
block|}
block|,
block|{
name|bfd_mach_mips7000
block|,
name|bfd_mach_mips8000
block|}
block|,
block|{
name|bfd_mach_mips9000
block|,
name|bfd_mach_mips8000
block|}
block|,
comment|/* VR4100 extensions.  */
block|{
name|bfd_mach_mips4120
block|,
name|bfd_mach_mips4100
block|}
block|,
block|{
name|bfd_mach_mips4111
block|,
name|bfd_mach_mips4100
block|}
block|,
comment|/* MIPS III extensions.  */
block|{
name|bfd_mach_mips8000
block|,
name|bfd_mach_mips4000
block|}
block|,
block|{
name|bfd_mach_mips4650
block|,
name|bfd_mach_mips4000
block|}
block|,
block|{
name|bfd_mach_mips4600
block|,
name|bfd_mach_mips4000
block|}
block|,
block|{
name|bfd_mach_mips4400
block|,
name|bfd_mach_mips4000
block|}
block|,
block|{
name|bfd_mach_mips4300
block|,
name|bfd_mach_mips4000
block|}
block|,
block|{
name|bfd_mach_mips4100
block|,
name|bfd_mach_mips4000
block|}
block|,
block|{
name|bfd_mach_mips4010
block|,
name|bfd_mach_mips4000
block|}
block|,
comment|/* MIPS32 extensions.  */
block|{
name|bfd_mach_mipsisa32r2
block|,
name|bfd_mach_mipsisa32
block|}
block|,
comment|/* MIPS II extensions.  */
block|{
name|bfd_mach_mips4000
block|,
name|bfd_mach_mips6000
block|}
block|,
block|{
name|bfd_mach_mipsisa32
block|,
name|bfd_mach_mips6000
block|}
block|,
comment|/* MIPS I extensions.  */
block|{
name|bfd_mach_mips6000
block|,
name|bfd_mach_mips3000
block|}
block|,
block|{
name|bfd_mach_mips3900
block|,
name|bfd_mach_mips3000
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return true if bfd machine EXTENSION is an extension of machine BASE.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_mach_extends_p
parameter_list|(
name|unsigned
name|long
name|base
parameter_list|,
name|unsigned
name|long
name|extension
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|extension
operator|==
name|base
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|base
operator|==
name|bfd_mach_mipsisa32
operator|&&
name|mips_mach_extends_p
argument_list|(
name|bfd_mach_mipsisa64
argument_list|,
name|extension
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|base
operator|==
name|bfd_mach_mipsisa32r2
operator|&&
name|mips_mach_extends_p
argument_list|(
name|bfd_mach_mipsisa64r2
argument_list|,
name|extension
argument_list|)
condition|)
return|return
name|TRUE
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|mips_mach_extensions
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|extension
operator|==
name|mips_mach_extensions
index|[
name|i
index|]
operator|.
name|extension
condition|)
block|{
name|extension
operator|=
name|mips_mach_extensions
index|[
name|i
index|]
operator|.
name|base
expr_stmt|;
if|if
condition|(
name|extension
operator|==
name|base
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return true if the given ELF header flags describe a 32-bit binary.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_32bit_flags_p
parameter_list|(
name|flagword
name|flags
parameter_list|)
block|{
return|return
operator|(
operator|(
name|flags
operator|&
name|EF_MIPS_32BITMODE
operator|)
operator|!=
literal|0
operator|||
operator|(
name|flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|==
name|E_MIPS_ABI_O32
operator|||
operator|(
name|flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|==
name|E_MIPS_ABI_EABI32
operator|||
operator|(
name|flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_1
operator|||
operator|(
name|flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_2
operator|||
operator|(
name|flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_32
operator|||
operator|(
name|flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_32R2
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Merge object attributes from IBFD into OBFD.  Raise an error if    there are conflicting attributes.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mips_elf_merge_obj_attributes
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|obj_attribute
modifier|*
name|in_attr
decl_stmt|;
name|obj_attribute
modifier|*
name|out_attr
decl_stmt|;
if|if
condition|(
operator|!
name|elf_known_obj_attributes_proc
argument_list|(
name|obfd
argument_list|)
index|[
literal|0
index|]
operator|.
name|i
condition|)
block|{
comment|/* This is the first object.  Copy the attributes.  */
name|_bfd_elf_copy_obj_attributes
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
comment|/* Use the Tag_null value to indicate the attributes have been 	 initialized.  */
name|elf_known_obj_attributes_proc
argument_list|(
name|obfd
argument_list|)
index|[
literal|0
index|]
operator|.
name|i
operator|=
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Check for conflicting Tag_GNU_MIPS_ABI_FP attributes and merge      non-conflicting ones.  */
name|in_attr
operator|=
name|elf_known_obj_attributes
argument_list|(
name|ibfd
argument_list|)
index|[
name|OBJ_ATTR_GNU
index|]
expr_stmt|;
name|out_attr
operator|=
name|elf_known_obj_attributes
argument_list|(
name|obfd
argument_list|)
index|[
name|OBJ_ATTR_GNU
index|]
expr_stmt|;
if|if
condition|(
name|in_attr
index|[
name|Tag_GNU_MIPS_ABI_FP
index|]
operator|.
name|i
operator|!=
name|out_attr
index|[
name|Tag_GNU_MIPS_ABI_FP
index|]
operator|.
name|i
condition|)
block|{
name|out_attr
index|[
name|Tag_GNU_MIPS_ABI_FP
index|]
operator|.
name|type
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|out_attr
index|[
name|Tag_GNU_MIPS_ABI_FP
index|]
operator|.
name|i
operator|==
literal|0
condition|)
name|out_attr
index|[
name|Tag_GNU_MIPS_ABI_FP
index|]
operator|.
name|i
operator|=
name|in_attr
index|[
name|Tag_GNU_MIPS_ABI_FP
index|]
operator|.
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|in_attr
index|[
name|Tag_GNU_MIPS_ABI_FP
index|]
operator|.
name|i
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|in_attr
index|[
name|Tag_GNU_MIPS_ABI_FP
index|]
operator|.
name|i
operator|>
literal|3
condition|)
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"Warning: %B uses unknown floating point ABI %d"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|in_attr
index|[
name|Tag_GNU_MIPS_ABI_FP
index|]
operator|.
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|out_attr
index|[
name|Tag_GNU_MIPS_ABI_FP
index|]
operator|.
name|i
operator|>
literal|3
condition|)
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"Warning: %B uses unknown floating point ABI %d"
argument_list|)
argument_list|,
name|obfd
argument_list|,
name|out_attr
index|[
name|Tag_GNU_MIPS_ABI_FP
index|]
operator|.
name|i
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|out_attr
index|[
name|Tag_GNU_MIPS_ABI_FP
index|]
operator|.
name|i
condition|)
block|{
case|case
literal|1
case|:
switch|switch
condition|(
name|in_attr
index|[
name|Tag_GNU_MIPS_ABI_FP
index|]
operator|.
name|i
condition|)
block|{
case|case
literal|2
case|:
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"Warning: %B uses -msingle-float, %B uses -mdouble-float"
argument_list|)
argument_list|,
name|obfd
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"Warning: %B uses hard float, %B uses soft float"
argument_list|)
argument_list|,
name|obfd
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
switch|switch
condition|(
name|in_attr
index|[
name|Tag_GNU_MIPS_ABI_FP
index|]
operator|.
name|i
condition|)
block|{
case|case
literal|1
case|:
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"Warning: %B uses -msingle-float, %B uses -mdouble-float"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"Warning: %B uses hard float, %B uses soft float"
argument_list|)
argument_list|,
name|obfd
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
switch|switch
condition|(
name|in_attr
index|[
name|Tag_GNU_MIPS_ABI_FP
index|]
operator|.
name|i
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"Warning: %B uses hard float, %B uses soft float"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Merge Tag_compatibility attributes and any common GNU ones.  */
name|_bfd_elf_merge_object_attributes
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_merge_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|flagword
name|old_flags
decl_stmt|;
name|flagword
name|new_flags
decl_stmt|;
name|bfd_boolean
name|ok
decl_stmt|;
name|bfd_boolean
name|null_input_bfd
init|=
name|TRUE
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* Check if we have the same endianess */
if|if
condition|(
operator|!
name|_bfd_generic_verify_endian_match
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: endianness incompatible with that of the selected emulation"
argument_list|)
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_target
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_target
argument_list|(
name|obfd
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: ABI is incompatible with that of the selected emulation"
argument_list|)
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|mips_elf_merge_obj_attributes
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|new_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator||=
name|new_flags
operator|&
name|EF_MIPS_NOREORDER
expr_stmt|;
name|old_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|new_flags
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
expr_stmt|;
if|if
condition|(
name|bfd_get_arch
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
operator|&&
operator|(
name|bfd_get_arch_info
argument_list|(
name|obfd
argument_list|)
operator|->
name|the_default
operator|||
name|mips_mach_extends_p
argument_list|(
name|bfd_get_mach
argument_list|(
name|obfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
comment|/* Check flag compatibility.  */
name|new_flags
operator|&=
operator|~
name|EF_MIPS_NOREORDER
expr_stmt|;
name|old_flags
operator|&=
operator|~
name|EF_MIPS_NOREORDER
expr_stmt|;
comment|/* Some IRIX 6 BSD-compatibility objects have this bit set.  It      doesn't seem to matter.  */
name|new_flags
operator|&=
operator|~
name|EF_MIPS_XGOT
expr_stmt|;
name|old_flags
operator|&=
operator|~
name|EF_MIPS_XGOT
expr_stmt|;
comment|/* MIPSpro generates ucode info in n64 objects.  Again, we should      just be able to ignore this.  */
name|new_flags
operator|&=
operator|~
name|EF_MIPS_UCODE
expr_stmt|;
name|old_flags
operator|&=
operator|~
name|EF_MIPS_UCODE
expr_stmt|;
comment|/* Don't care about the PIC flags from dynamic objects; they are      PIC by design.  */
if|if
condition|(
operator|(
name|new_flags
operator|&
operator|(
name|EF_MIPS_PIC
operator||
name|EF_MIPS_CPIC
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ibfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
name|new_flags
operator|&=
operator|~
operator|(
name|EF_MIPS_PIC
operator||
name|EF_MIPS_CPIC
operator|)
expr_stmt|;
if|if
condition|(
name|new_flags
operator|==
name|old_flags
condition|)
return|return
name|TRUE
return|;
comment|/* Check to see if the input BFD actually contains any sections.      If not, its flags may not have been initialised either, but it cannot      actually cause any incompatibility.  */
for|for
control|(
name|sec
operator|=
name|ibfd
operator|->
name|sections
init|;
name|sec
operator|!=
name|NULL
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
comment|/* Ignore synthetic sections and empty .text, .data and .bss sections 	  which are automatically generated by gas.  */
if|if
condition|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".reginfo"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".mdebug"
argument_list|)
operator|&&
operator|(
name|sec
operator|->
name|size
operator|!=
literal|0
operator|||
operator|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".text"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".data"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".bss"
argument_list|)
operator|)
operator|)
condition|)
block|{
name|null_input_bfd
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|null_input_bfd
condition|)
return|return
name|TRUE
return|;
name|ok
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|new_flags
operator|&
operator|(
name|EF_MIPS_PIC
operator||
name|EF_MIPS_CPIC
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|(
name|old_flags
operator|&
operator|(
name|EF_MIPS_PIC
operator||
name|EF_MIPS_CPIC
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: warning: linking PIC files with non-PIC files"
argument_list|)
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
name|ok
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|new_flags
operator|&
operator|(
name|EF_MIPS_PIC
operator||
name|EF_MIPS_CPIC
operator|)
condition|)
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_MIPS_CPIC
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|new_flags
operator|&
name|EF_MIPS_PIC
operator|)
condition|)
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
name|EF_MIPS_PIC
expr_stmt|;
name|new_flags
operator|&=
operator|~
operator|(
name|EF_MIPS_PIC
operator||
name|EF_MIPS_CPIC
operator|)
expr_stmt|;
name|old_flags
operator|&=
operator|~
operator|(
name|EF_MIPS_PIC
operator||
name|EF_MIPS_CPIC
operator|)
expr_stmt|;
comment|/* Compare the ISAs.  */
if|if
condition|(
name|mips_32bit_flags_p
argument_list|(
name|old_flags
argument_list|)
operator|!=
name|mips_32bit_flags_p
argument_list|(
name|new_flags
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: linking 32-bit code with 64-bit code"
argument_list|)
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|mips_mach_extends_p
argument_list|(
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|obfd
argument_list|)
argument_list|)
condition|)
block|{
comment|/* OBFD's ISA isn't the same as, or an extension of, IBFD's.  */
if|if
condition|(
name|mips_mach_extends_p
argument_list|(
name|bfd_get_mach
argument_list|(
name|obfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Copy the architecture info from IBFD to OBFD.  Also copy 	     the 32-bit flag (if set) so that we continue to recognise 	     OBFD as a 32-bit binary.  */
name|bfd_set_arch_info
argument_list|(
name|obfd
argument_list|,
name|bfd_get_arch_info
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
operator|(
name|EF_MIPS_ARCH
operator||
name|EF_MIPS_MACH
operator|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator||=
name|new_flags
operator|&
operator|(
name|EF_MIPS_ARCH
operator||
name|EF_MIPS_MACH
operator||
name|EF_MIPS_32BITMODE
operator|)
expr_stmt|;
comment|/* Copy across the ABI flags if OBFD doesn't use them 	     and if that was what caused us to treat IBFD as 32-bit.  */
if|if
condition|(
operator|(
name|old_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|==
literal|0
operator|&&
name|mips_32bit_flags_p
argument_list|(
name|new_flags
argument_list|)
operator|&&
operator|!
name|mips_32bit_flags_p
argument_list|(
name|new_flags
operator|&
operator|~
name|EF_MIPS_ABI
argument_list|)
condition|)
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator||=
name|new_flags
operator|&
name|EF_MIPS_ABI
expr_stmt|;
block|}
else|else
block|{
comment|/* The ISAs aren't compatible.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: linking %s module with previous %s modules"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|bfd_printable_name
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_printable_name
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|new_flags
operator|&=
operator|~
operator|(
name|EF_MIPS_ARCH
operator||
name|EF_MIPS_MACH
operator||
name|EF_MIPS_32BITMODE
operator|)
expr_stmt|;
name|old_flags
operator|&=
operator|~
operator|(
name|EF_MIPS_ARCH
operator||
name|EF_MIPS_MACH
operator||
name|EF_MIPS_32BITMODE
operator|)
expr_stmt|;
comment|/* Compare ABIs.  The 64-bit ABI does not use EF_MIPS_ABI.  But, it      does set EI_CLASS differently from any 32-bit ABI.  */
if|if
condition|(
operator|(
name|new_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|!=
operator|(
name|old_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|||
operator|(
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|!=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|)
condition|)
block|{
comment|/* Only error if both are set (to different values).  */
if|if
condition|(
operator|(
operator|(
name|new_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|&&
operator|(
name|old_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|)
operator|||
operator|(
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|!=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: ABI mismatch: linking %s module with previous %s modules"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
name|elf_mips_abi_name
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|elf_mips_abi_name
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
name|new_flags
operator|&=
operator|~
name|EF_MIPS_ABI
expr_stmt|;
name|old_flags
operator|&=
operator|~
name|EF_MIPS_ABI
expr_stmt|;
block|}
comment|/* For now, allow arbitrary mixing of ASEs (retain the union).  */
if|if
condition|(
operator|(
name|new_flags
operator|&
name|EF_MIPS_ARCH_ASE
operator|)
operator|!=
operator|(
name|old_flags
operator|&
name|EF_MIPS_ARCH_ASE
operator|)
condition|)
block|{
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator||=
name|new_flags
operator|&
name|EF_MIPS_ARCH_ASE
expr_stmt|;
name|new_flags
operator|&=
operator|~
name|EF_MIPS_ARCH_ASE
expr_stmt|;
name|old_flags
operator|&=
operator|~
name|EF_MIPS_ARCH_ASE
expr_stmt|;
block|}
comment|/* Warn about any other mismatches */
if|if
condition|(
name|new_flags
operator|!=
name|old_flags
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"
argument_list|)
argument_list|,
name|ibfd
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|new_flags
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|old_flags
argument_list|)
expr_stmt|;
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Function to keep MIPS specific file flags like as EF_MIPS_PIC.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_set_private_flags
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|flagword
name|flags
parameter_list|)
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|||
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|==
name|flags
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_mips_elf_print_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|FILE
modifier|*
name|file
init|=
name|ptr
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|abfd
operator|!=
name|NULL
operator|&&
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Print normal ELF private data.  */
name|_bfd_elf_print_private_bfd_data
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* xgettext:c-format */
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"private flags = %lx:"
argument_list|)
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|==
name|E_MIPS_ABI_O32
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [abi=O32]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|==
name|E_MIPS_ABI_O64
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [abi=O64]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|==
name|E_MIPS_ABI_EABI32
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [abi=EABI32]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ABI
operator|)
operator|==
name|E_MIPS_ABI_EABI64
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [abi=EABI64]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ABI
operator|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [abi unknown]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ABI_N32_P
argument_list|(
name|abfd
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [abi=N32]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ABI_64_P
argument_list|(
name|abfd
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [abi=64]"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [no abi set]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [mips1]"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_2
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [mips2]"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_3
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [mips3]"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_4
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [mips4]"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_5
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [mips5]"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_32
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [mips32]"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_64
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [mips64]"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_32R2
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [mips32r2]"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH
operator|)
operator|==
name|E_MIPS_ARCH_64R2
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [mips64r2]"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [unknown ISA]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH_ASE_MDMX
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [mdmx]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_ARCH_ASE_M16
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [mips16]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_32BITMODE
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [32bitmode]"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [not 32bitmode]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_NOREORDER
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [noreorder]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_PIC
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [PIC]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_CPIC
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [CPIC]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_XGOT
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [XGOT]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MIPS_UCODE
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [UCODE]"
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|bfd_elf_special_section
name|_bfd_mips_elf_special_sections
index|[]
init|=
block|{
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".lit4"
argument_list|)
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
operator|+
name|SHF_MIPS_GPREL
block|}
block|,
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".lit8"
argument_list|)
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
operator|+
name|SHF_MIPS_GPREL
block|}
block|,
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".mdebug"
argument_list|)
block|,
literal|0
block|,
name|SHT_MIPS_DEBUG
block|,
literal|0
block|}
block|,
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".sbss"
argument_list|)
block|,
operator|-
literal|2
block|,
name|SHT_NOBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
operator|+
name|SHF_MIPS_GPREL
block|}
block|,
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".sdata"
argument_list|)
block|,
operator|-
literal|2
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
operator|+
name|SHF_MIPS_GPREL
block|}
block|,
block|{
name|STRING_COMMA_LEN
argument_list|(
literal|".ucode"
argument_list|)
block|,
literal|0
block|,
name|SHT_MIPS_UCODE
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Merge non visibility st_other attributes.  Ensure that the    STO_OPTIONAL flag is copied into h->other, even if this is not a    definiton of the symbol.  */
end_comment

begin_function
name|void
name|_bfd_mips_elf_merge_symbol_attribute
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
specifier|const
name|Elf_Internal_Sym
modifier|*
name|isym
parameter_list|,
name|bfd_boolean
name|definition
parameter_list|,
name|bfd_boolean
name|dynamic
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
operator|(
name|isym
operator|->
name|st_other
operator|&
operator|~
name|ELF_ST_VISIBILITY
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|char
name|other
decl_stmt|;
name|other
operator|=
operator|(
name|definition
condition|?
name|isym
operator|->
name|st_other
else|:
name|h
operator|->
name|other
operator|)
expr_stmt|;
name|other
operator|&=
operator|~
name|ELF_ST_VISIBILITY
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|h
operator|->
name|other
operator|=
name|other
operator||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|definition
operator|&&
name|ELF_MIPS_IS_OPTIONAL
argument_list|(
name|isym
operator|->
name|st_other
argument_list|)
condition|)
name|h
operator|->
name|other
operator||=
name|STO_OPTIONAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decide whether an undefined symbol is special and can be ignored.    This is the case for OPTIONAL symbols on IRIX.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mips_elf_ignore_undef_symbol
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
return|return
name|ELF_MIPS_IS_OPTIONAL
argument_list|(
name|h
operator|->
name|other
argument_list|)
condition|?
name|TRUE
else|:
name|FALSE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_mips_elf_common_definition
parameter_list|(
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
return|return
operator|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
operator|||
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_MIPS_ACOMMON
operator|||
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_MIPS_SCOMMON
operator|)
return|;
block|}
end_function

end_unit

