begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for i386 a.out binaries under LynxOS.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1999, 2001, 2002,    2003, 2007 Free Software Foundation, Inc.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_define
define|#
directive|define
name|N_SHARED_LIB
parameter_list|(
name|x
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|TEXT_START_ADDR
value|0
end_define

begin_define
define|#
directive|define
name|TARGET_PAGE_SIZE
value|4096
end_define

begin_define
define|#
directive|define
name|SEGMENT_SIZE
value|TARGET_PAGE_SIZE
end_define

begin_define
define|#
directive|define
name|DEFAULT_ARCH
value|bfd_arch_i386
end_define

begin_comment
comment|/* Do not "beautify" the CONCAT* macro args.  Traditional C will not    remove whitespace added here, and thus will fail to concatenate    the tokens.  */
end_comment

begin_define
define|#
directive|define
name|MY
parameter_list|(
name|OP
parameter_list|)
value|CONCAT2 (i386lynx_aout_,OP)
end_define

begin_define
define|#
directive|define
name|TARGETNAME
value|"a.out-i386-lynx"
end_define

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|WRITE_HEADERS
end_ifndef

begin_define
define|#
directive|define
name|WRITE_HEADERS
parameter_list|(
name|abfd
parameter_list|,
name|execp
parameter_list|)
define|\
value|{									      \ 	bfd_size_type text_size;
comment|/* dummy vars */
value|\ 	file_ptr text_end;						      \ 	if (adata(abfd).magic == undecided_magic)			      \ 	  NAME(aout,adjust_sizes_and_vmas) (abfd,&text_size,&text_end);     \     									      \ 	execp->a_syms = bfd_get_symcount (abfd) * EXTERNAL_NLIST_SIZE;	      \ 	execp->a_entry = bfd_get_start_address (abfd);			      \     									      \ 	execp->a_trsize = ((obj_textsec (abfd)->reloc_count) *		      \ 			   obj_reloc_entry_size (abfd));		      \ 	execp->a_drsize = ((obj_datasec (abfd)->reloc_count) *		      \ 			   obj_reloc_entry_size (abfd));		      \ 	NAME(aout,swap_exec_header_out) (abfd, execp,&exec_bytes);	      \ 									      \ 	if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0		      \ 	    || bfd_bwrite ((PTR)&exec_bytes, (bfd_size_type) EXEC_BYTES_SIZE, \ 			  abfd) != EXEC_BYTES_SIZE)			      \ 	  return FALSE;							      \
comment|/* Now write out reloc info, followed by syms and strings */
value|\   									      \ 	if (bfd_get_symcount (abfd) != 0) 				      \ 	    {								      \ 	      if (bfd_seek (abfd, (file_ptr) (N_SYMOFF(*execp)), SEEK_SET)    \ 		  != 0)							      \ 	        return FALSE;						      \ 									      \ 	      if (! NAME(aout,write_syms) (abfd)) return FALSE;		      \ 									      \ 	      if (bfd_seek (abfd, (file_ptr) (N_TRELOFF(*execp)), SEEK_SET)   \ 		  != 0)							      \ 	        return FALSE;						      \ 									      \ 	      if (!NAME(lynx,squirt_out_relocs) (abfd, obj_textsec (abfd)))   \ 		return FALSE;						      \ 	      if (bfd_seek (abfd, (file_ptr) (N_DRELOFF(*execp)), SEEK_SET)   \ 		  != 0)							      \ 	        return 0;						      \ 									      \ 	      if (!NAME(lynx,squirt_out_relocs) (abfd, obj_datasec (abfd)))   \ 		return FALSE;						      \ 	    }								      \       }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_include
include|#
directive|include
file|"aout/aout64.h"
end_include

begin_function_decl
name|void
name|NAME
parameter_list|(
name|lynx
parameter_list|,
name|swap_std_reloc_out
parameter_list|)
function_decl|PARAMS
parameter_list|(
function_decl|(bfd *
operator|,
function_decl|arelent *
operator|,
function_decl|struct reloc_std_external *
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
name|void
name|NAME
parameter_list|(
name|lynx
parameter_list|,
name|swap_ext_reloc_out
parameter_list|)
function_decl|PARAMS
parameter_list|(
function_decl|(bfd *
operator|,
function_decl|arelent *
operator|,
function_decl|struct reloc_ext_external *
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
name|void
name|NAME
parameter_list|(
name|lynx
parameter_list|,
name|swap_ext_reloc_in
parameter_list|)
function_decl|PARAMS
parameter_list|(
function_decl|(bfd *
operator|,
function_decl|struct reloc_ext_external *
operator|,
function_decl|arelent *
operator|,
function_decl|asymbol **
operator|,
function_decl|bfd_size_type
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
name|void
name|NAME
parameter_list|(
name|lynx
parameter_list|,
name|swap_std_reloc_in
parameter_list|)
function_decl|PARAMS
parameter_list|(
function_decl|(bfd *
operator|,
function_decl|struct reloc_std_external *
operator|,
function_decl|arelent *
operator|,
function_decl|asymbol **
operator|,
function_decl|bfd_size_type
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
name|bfd_boolean
name|NAME
parameter_list|(
name|lynx
parameter_list|,
name|slurp_reloc_table
parameter_list|)
function_decl|PARAMS
parameter_list|(
function_decl|(bfd *
operator|,
function_decl|sec_ptr
operator|,
function_decl|asymbol **
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
name|bfd_boolean
name|NAME
parameter_list|(
name|lynx
parameter_list|,
name|squirt_out_relocs
parameter_list|)
function_decl|PARAMS
parameter_list|(
function_decl|(bfd *
operator|,
function_decl|asection *
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
name|long
name|NAME
parameter_list|(
name|lynx
parameter_list|,
name|canonicalize_reloc
parameter_list|)
function_decl|PARAMS
parameter_list|(
function_decl|(bfd *
operator|,
function_decl|sec_ptr
operator|,
function_decl|arelent **
operator|,
function_decl|asymbol **
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LYNX_CORE
end_ifdef

begin_function_decl
name|char
modifier|*
name|lynx_core_file_failing_command
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|lynx_core_file_failing_signal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|bfd_boolean
name|lynx_core_file_matches_executable_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|bfd_target
modifier|*
name|lynx_core_file_p
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MY_core_file_failing_command
value|lynx_core_file_failing_command
end_define

begin_define
define|#
directive|define
name|MY_core_file_failing_signal
value|lynx_core_file_failing_signal
end_define

begin_define
define|#
directive|define
name|MY_core_file_matches_executable_p
value|lynx_core_file_matches_executable_p
end_define

begin_define
define|#
directive|define
name|MY_core_file_p
value|lynx_core_file_p
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LYNX_CORE */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|KEEPIT
value|udata.i
end_define

begin_decl_stmt
specifier|extern
name|reloc_howto_type
name|aout_32_ext_howto_table
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|reloc_howto_type
name|aout_32_std_howto_table
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Standard reloc stuff */
end_comment

begin_comment
comment|/* Output standard relocation information to a file in target byte order. */
end_comment

begin_decl_stmt
name|void
name|NAME
argument_list|(
name|lynx
argument_list|,
name|swap_std_reloc_out
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|g
argument_list|,
name|natptr
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|arelent
modifier|*
name|g
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|reloc_std_external
modifier|*
name|natptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|r_index
decl_stmt|;
name|asymbol
modifier|*
name|sym
init|=
operator|*
operator|(
name|g
operator|->
name|sym_ptr_ptr
operator|)
decl_stmt|;
name|int
name|r_extern
decl_stmt|;
name|unsigned
name|int
name|r_length
decl_stmt|;
name|int
name|r_pcrel
decl_stmt|;
name|int
name|r_baserel
decl_stmt|,
name|r_jmptable
decl_stmt|,
name|r_relative
decl_stmt|;
name|unsigned
name|int
name|r_addend
decl_stmt|;
name|asection
modifier|*
name|output_section
init|=
name|sym
operator|->
name|section
operator|->
name|output_section
decl_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|g
operator|->
name|address
argument_list|,
name|natptr
operator|->
name|r_address
argument_list|)
expr_stmt|;
name|r_length
operator|=
name|g
operator|->
name|howto
operator|->
name|size
expr_stmt|;
comment|/* Size as a power of two */
name|r_pcrel
operator|=
operator|(
name|int
operator|)
name|g
operator|->
name|howto
operator|->
name|pc_relative
expr_stmt|;
comment|/* Relative to PC? */
comment|/* r_baserel, r_jmptable, r_relative???  FIXME-soon */
name|r_baserel
operator|=
literal|0
expr_stmt|;
name|r_jmptable
operator|=
literal|0
expr_stmt|;
name|r_relative
operator|=
literal|0
expr_stmt|;
name|r_addend
operator|=
name|g
operator|->
name|addend
operator|+
operator|(
operator|*
operator|(
name|g
operator|->
name|sym_ptr_ptr
operator|)
operator|)
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
comment|/* name was clobbered by aout_write_syms to be symbol index */
comment|/* If this relocation is relative to a symbol then set the      r_index to the symbols index, and the r_extern bit.       Absolute symbols can come in in two ways, either as an offset      from the abs section, or as a symbol which has an abs value.      check for that here   */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|output_section
argument_list|)
operator|||
name|bfd_is_abs_section
argument_list|(
name|output_section
argument_list|)
operator|||
name|bfd_is_und_section
argument_list|(
name|output_section
argument_list|)
condition|)
block|{
if|if
condition|(
name|bfd_abs_section_ptr
operator|->
name|symbol
operator|==
name|sym
condition|)
block|{
comment|/* Whoops, looked like an abs symbol, but is really an offset 	     from the abs section */
name|r_index
operator|=
literal|0
expr_stmt|;
name|r_extern
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Fill in symbol */
name|r_extern
operator|=
literal|1
expr_stmt|;
name|r_index
operator|=
operator|(
operator|*
name|g
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|KEEPIT
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Just an ordinary section */
name|r_extern
operator|=
literal|0
expr_stmt|;
name|r_index
operator|=
name|output_section
operator|->
name|target_index
expr_stmt|;
block|}
comment|/* now the fun stuff */
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|natptr
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
name|r_index
operator|>>
literal|16
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
name|r_index
operator|>>
literal|8
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
name|r_index
expr_stmt|;
name|natptr
operator|->
name|r_type
index|[
literal|0
index|]
operator|=
operator|(
name|r_extern
condition|?
name|RELOC_STD_BITS_EXTERN_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|r_pcrel
condition|?
name|RELOC_STD_BITS_PCREL_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|r_baserel
condition|?
name|RELOC_STD_BITS_BASEREL_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|r_jmptable
condition|?
name|RELOC_STD_BITS_JMPTABLE_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|r_relative
condition|?
name|RELOC_STD_BITS_RELATIVE_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|r_length
operator|<<
name|RELOC_STD_BITS_LENGTH_SH_BIG
operator|)
expr_stmt|;
block|}
else|else
block|{
name|natptr
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
name|r_index
operator|>>
literal|16
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
name|r_index
operator|>>
literal|8
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
name|r_index
expr_stmt|;
name|natptr
operator|->
name|r_type
index|[
literal|0
index|]
operator|=
operator|(
name|r_extern
condition|?
name|RELOC_STD_BITS_EXTERN_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|r_pcrel
condition|?
name|RELOC_STD_BITS_PCREL_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|r_baserel
condition|?
name|RELOC_STD_BITS_BASEREL_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|r_jmptable
condition|?
name|RELOC_STD_BITS_JMPTABLE_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|r_relative
condition|?
name|RELOC_STD_BITS_RELATIVE_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|r_length
operator|<<
name|RELOC_STD_BITS_LENGTH_SH_LITTLE
operator|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Extended stuff */
end_comment

begin_comment
comment|/* Output extended relocation information to a file in target byte order. */
end_comment

begin_decl_stmt
name|void
name|NAME
argument_list|(
name|lynx
argument_list|,
name|swap_ext_reloc_out
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|g
argument_list|,
name|natptr
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|arelent
modifier|*
name|g
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|reloc_ext_external
modifier|*
name|natptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|r_index
decl_stmt|;
name|int
name|r_extern
decl_stmt|;
name|unsigned
name|int
name|r_type
decl_stmt|;
name|unsigned
name|int
name|r_addend
decl_stmt|;
name|asymbol
modifier|*
name|sym
init|=
operator|*
operator|(
name|g
operator|->
name|sym_ptr_ptr
operator|)
decl_stmt|;
name|asection
modifier|*
name|output_section
init|=
name|sym
operator|->
name|section
operator|->
name|output_section
decl_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|g
operator|->
name|address
argument_list|,
name|natptr
operator|->
name|r_address
argument_list|)
expr_stmt|;
name|r_type
operator|=
operator|(
name|unsigned
name|int
operator|)
name|g
operator|->
name|howto
operator|->
name|type
expr_stmt|;
name|r_addend
operator|=
name|g
operator|->
name|addend
operator|+
operator|(
operator|*
operator|(
name|g
operator|->
name|sym_ptr_ptr
operator|)
operator|)
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
comment|/* If this relocation is relative to a symbol then set the      r_index to the symbols index, and the r_extern bit.       Absolute symbols can come in in two ways, either as an offset      from the abs section, or as a symbol which has an abs value.      check for that here      */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|output_section
argument_list|)
operator|||
name|bfd_is_abs_section
argument_list|(
name|output_section
argument_list|)
operator|||
name|bfd_is_und_section
argument_list|(
name|output_section
argument_list|)
condition|)
block|{
if|if
condition|(
name|bfd_abs_section_ptr
operator|->
name|symbol
operator|==
name|sym
condition|)
block|{
comment|/* Whoops, looked like an abs symbol, but is really an offset 	 from the abs section */
name|r_index
operator|=
literal|0
expr_stmt|;
name|r_extern
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|r_extern
operator|=
literal|1
expr_stmt|;
name|r_index
operator|=
operator|(
operator|*
name|g
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|KEEPIT
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Just an ordinary section */
name|r_extern
operator|=
literal|0
expr_stmt|;
name|r_index
operator|=
name|output_section
operator|->
name|target_index
expr_stmt|;
block|}
comment|/* now the fun stuff */
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|natptr
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
name|r_index
operator|>>
literal|16
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
name|r_index
operator|>>
literal|8
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
name|r_index
expr_stmt|;
name|natptr
operator|->
name|r_type
index|[
literal|0
index|]
operator|=
operator|(
name|r_extern
condition|?
name|RELOC_EXT_BITS_EXTERN_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|r_type
operator|<<
name|RELOC_EXT_BITS_TYPE_SH_BIG
operator|)
expr_stmt|;
block|}
else|else
block|{
name|natptr
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
name|r_index
operator|>>
literal|16
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
name|r_index
operator|>>
literal|8
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
name|r_index
expr_stmt|;
name|natptr
operator|->
name|r_type
index|[
literal|0
index|]
operator|=
operator|(
name|r_extern
condition|?
name|RELOC_EXT_BITS_EXTERN_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|r_type
operator|<<
name|RELOC_EXT_BITS_TYPE_SH_LITTLE
operator|)
expr_stmt|;
block|}
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|r_addend
argument_list|,
name|natptr
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* BFD deals internally with all things based from the section they're    in. so, something in 10 bytes into a text section  with a base of    50 would have a symbol (.text+10) and know .text vma was 50.     Aout keeps all it's symbols based from zero, so the symbol would    contain 60. This macro subs the base of each section from the value    to give the true offset from the section */
end_comment

begin_define
define|#
directive|define
name|MOVE_ADDRESS
parameter_list|(
name|ad
parameter_list|)
define|\
value|if (r_extern) {							\
comment|/* undefined symbol */
value|\      cache_ptr->sym_ptr_ptr = symbols + r_index;			\      cache_ptr->addend = ad;						\      } else {								\
comment|/* defined, section relative. replace symbol with pointer to    	\        symbol which points to section  */
value|\     switch (r_index) {							\     case N_TEXT:							\     case N_TEXT | N_EXT:						\       cache_ptr->sym_ptr_ptr  = obj_textsec(abfd)->symbol_ptr_ptr;	\       cache_ptr->addend = ad  - su->textsec->vma;			\       break;								\     case N_DATA:							\     case N_DATA | N_EXT:						\       cache_ptr->sym_ptr_ptr  = obj_datasec(abfd)->symbol_ptr_ptr;	\       cache_ptr->addend = ad - su->datasec->vma;			\       break;								\     case N_BSS:								\     case N_BSS | N_EXT:							\       cache_ptr->sym_ptr_ptr  = obj_bsssec(abfd)->symbol_ptr_ptr;	\       cache_ptr->addend = ad - su->bsssec->vma;				\       break;								\     default:								\     case N_ABS:								\     case N_ABS | N_EXT:							\      cache_ptr->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;	\       cache_ptr->addend = ad;						\       break;								\     }									\   }     								\  void
end_define

begin_macro
name|NAME
argument_list|(
argument|lynx
argument_list|,
argument|swap_ext_reloc_in
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|abfd
operator|,
name|bytes
operator|,
name|cache_ptr
operator|,
name|symbols
operator|,
name|symcount
operator|)
name|bfd
operator|*
name|abfd
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|reloc_ext_external
modifier|*
name|bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_size_type
name|symcount
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|r_index
decl_stmt|;
name|int
name|r_extern
decl_stmt|;
name|unsigned
name|int
name|r_type
decl_stmt|;
name|struct
name|aoutdata
modifier|*
name|su
init|=
operator|&
operator|(
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|->
name|a
operator|)
decl_stmt|;
name|cache_ptr
operator|->
name|address
operator|=
operator|(
name|GET_SWORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|r_address
argument_list|)
operator|)
expr_stmt|;
name|r_index
operator|=
name|bytes
operator|->
name|r_index
index|[
literal|1
index|]
expr_stmt|;
name|r_extern
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_index
index|[
literal|0
index|]
operator|&
name|RELOC_EXT_BITS_EXTERN_BIG
operator|)
operator|)
expr_stmt|;
name|r_type
operator|=
operator|(
name|bytes
operator|->
name|r_index
index|[
literal|0
index|]
operator|&
name|RELOC_EXT_BITS_TYPE_BIG
operator|)
operator|>>
name|RELOC_EXT_BITS_TYPE_SH_BIG
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
name|aout_32_ext_howto_table
operator|+
name|r_type
expr_stmt|;
name|MOVE_ADDRESS
argument_list|(
name|GET_SWORD
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|r_addend
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|void
name|NAME
argument_list|(
name|lynx
argument_list|,
name|swap_std_reloc_in
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|bytes
argument_list|,
name|cache_ptr
argument_list|,
name|symbols
argument_list|,
name|symcount
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|reloc_std_external
modifier|*
name|bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_size_type
name|symcount
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|r_index
decl_stmt|;
name|int
name|r_extern
decl_stmt|;
name|unsigned
name|int
name|r_length
decl_stmt|;
name|int
name|r_pcrel
decl_stmt|;
name|int
name|r_baserel
decl_stmt|,
name|r_jmptable
decl_stmt|,
name|r_relative
decl_stmt|;
name|struct
name|aoutdata
modifier|*
name|su
init|=
operator|&
operator|(
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|->
name|a
operator|)
decl_stmt|;
name|cache_ptr
operator|->
name|address
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|bytes
operator|->
name|r_address
argument_list|)
expr_stmt|;
name|r_index
operator|=
name|bytes
operator|->
name|r_index
index|[
literal|1
index|]
expr_stmt|;
name|r_extern
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_index
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_EXTERN_BIG
operator|)
operator|)
expr_stmt|;
name|r_pcrel
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_index
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_PCREL_BIG
operator|)
operator|)
expr_stmt|;
name|r_baserel
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_index
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_BASEREL_BIG
operator|)
operator|)
expr_stmt|;
name|r_jmptable
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_index
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_JMPTABLE_BIG
operator|)
operator|)
expr_stmt|;
name|r_relative
operator|=
operator|(
literal|0
operator|!=
operator|(
name|bytes
operator|->
name|r_index
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_RELATIVE_BIG
operator|)
operator|)
expr_stmt|;
name|r_length
operator|=
operator|(
name|bytes
operator|->
name|r_index
index|[
literal|0
index|]
operator|&
name|RELOC_STD_BITS_LENGTH_BIG
operator|)
operator|>>
name|RELOC_STD_BITS_LENGTH_SH_BIG
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
name|aout_32_std_howto_table
operator|+
name|r_length
operator|+
literal|4
operator|*
name|r_pcrel
expr_stmt|;
comment|/* FIXME-soon:  Roll baserel, jmptable, relative bits into howto setting */
name|MOVE_ADDRESS
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Reloc hackery */
end_comment

begin_decl_stmt
name|bfd_boolean
name|NAME
argument_list|(
name|lynx
argument_list|,
name|slurp_reloc_table
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|,
name|symbols
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|sec_ptr
name|asect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bfd_size_type
name|count
decl_stmt|;
name|bfd_size_type
name|reloc_size
decl_stmt|;
name|PTR
name|relocs
decl_stmt|;
name|arelent
modifier|*
name|reloc_cache
decl_stmt|;
name|size_t
name|each_size
decl_stmt|;
if|if
condition|(
name|asect
operator|->
name|relocation
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|asect
operator|->
name|flags
operator|&
name|SEC_CONSTRUCTOR
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|asect
operator|==
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|reloc_size
operator|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_drsize
expr_stmt|;
goto|goto
name|doit
goto|;
block|}
if|if
condition|(
name|asect
operator|==
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|reloc_size
operator|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|a_trsize
expr_stmt|;
goto|goto
name|doit
goto|;
block|}
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
name|doit
label|:
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|asect
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|each_size
operator|=
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|count
operator|=
name|reloc_size
operator|/
name|each_size
expr_stmt|;
name|reloc_cache
operator|=
operator|(
name|arelent
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reloc_cache
operator|&&
name|count
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|relocs
operator|=
operator|(
name|PTR
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|reloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relocs
operator|&&
name|reloc_size
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|reloc_cache
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|bfd_bread
argument_list|(
name|relocs
argument_list|,
name|reloc_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|reloc_size
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|relocs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reloc_cache
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|each_size
operator|==
name|RELOC_EXT_SIZE
condition|)
block|{
specifier|register
name|struct
name|reloc_ext_external
modifier|*
name|rptr
init|=
operator|(
expr|struct
name|reloc_ext_external
operator|*
operator|)
name|relocs
decl_stmt|;
name|unsigned
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
init|=
name|reloc_cache
decl_stmt|;
for|for
control|(
init|;
name|counter
operator|<
name|count
condition|;
name|counter
operator|++
operator|,
name|rptr
operator|++
operator|,
name|cache_ptr
operator|++
control|)
block|{
name|NAME
argument_list|(
name|lynx
argument_list|,
name|swap_ext_reloc_in
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|rptr
argument_list|,
name|cache_ptr
argument_list|,
name|symbols
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|register
name|struct
name|reloc_std_external
modifier|*
name|rptr
init|=
operator|(
expr|struct
name|reloc_std_external
operator|*
operator|)
name|relocs
decl_stmt|;
name|unsigned
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
init|=
name|reloc_cache
decl_stmt|;
for|for
control|(
init|;
name|counter
operator|<
name|count
condition|;
name|counter
operator|++
operator|,
name|rptr
operator|++
operator|,
name|cache_ptr
operator|++
control|)
block|{
name|NAME
argument_list|(
name|lynx
argument_list|,
name|swap_std_reloc_in
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|rptr
argument_list|,
name|cache_ptr
argument_list|,
name|symbols
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|relocs
argument_list|)
expr_stmt|;
name|asect
operator|->
name|relocation
operator|=
name|reloc_cache
expr_stmt|;
name|asect
operator|->
name|reloc_count
operator|=
name|count
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block

begin_comment
comment|/* Write out a relocation section into an object file.  */
end_comment

begin_decl_stmt
name|bfd_boolean
name|NAME
argument_list|(
name|lynx
argument_list|,
name|squirt_out_relocs
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asection
modifier|*
name|section
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|arelent
modifier|*
modifier|*
name|generic
decl_stmt|;
name|unsigned
name|char
modifier|*
name|native
decl_stmt|,
modifier|*
name|natptr
decl_stmt|;
name|size_t
name|each_size
decl_stmt|;
name|unsigned
name|int
name|count
init|=
name|section
operator|->
name|reloc_count
decl_stmt|;
name|bfd_size_type
name|natsize
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|each_size
operator|=
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|natsize
operator|=
name|count
expr_stmt|;
name|natsize
operator|*=
name|each_size
expr_stmt|;
name|native
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|natsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|native
condition|)
return|return
name|FALSE
return|;
name|generic
operator|=
name|section
operator|->
name|orelocation
expr_stmt|;
if|if
condition|(
name|each_size
operator|==
name|RELOC_EXT_SIZE
condition|)
block|{
for|for
control|(
name|natptr
operator|=
name|native
init|;
name|count
operator|!=
literal|0
condition|;
operator|--
name|count
operator|,
name|natptr
operator|+=
name|each_size
operator|,
operator|++
name|generic
control|)
name|NAME
argument_list|(
name|lynx
argument_list|,
name|swap_ext_reloc_out
argument_list|)
argument_list|(
name|abfd
argument_list|,
operator|*
name|generic
argument_list|,
operator|(
expr|struct
name|reloc_ext_external
operator|*
operator|)
name|natptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|natptr
operator|=
name|native
init|;
name|count
operator|!=
literal|0
condition|;
operator|--
name|count
operator|,
name|natptr
operator|+=
name|each_size
operator|,
operator|++
name|generic
control|)
name|NAME
argument_list|(
name|lynx
argument_list|,
name|swap_std_reloc_out
argument_list|)
argument_list|(
name|abfd
argument_list|,
operator|*
name|generic
argument_list|,
operator|(
expr|struct
name|reloc_std_external
operator|*
operator|)
name|natptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|native
argument_list|,
name|natsize
argument_list|,
name|abfd
argument_list|)
operator|!=
name|natsize
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|native
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|native
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block

begin_comment
comment|/* This is stupid.  This function should be a boolean predicate */
end_comment

begin_decl_stmt
name|long
name|NAME
argument_list|(
name|lynx
argument_list|,
name|canonicalize_reloc
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|relptr
argument_list|,
name|symbols
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|sec_ptr
name|section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|arelent
modifier|*
modifier|*
name|relptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|arelent
modifier|*
name|tblptr
init|=
name|section
operator|->
name|relocation
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|tblptr
operator|||
name|NAME
argument_list|(
name|lynx
argument_list|,
name|slurp_reloc_table
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|section
operator|->
name|flags
operator|&
name|SEC_CONSTRUCTOR
condition|)
block|{
name|arelent_chain
modifier|*
name|chain
init|=
name|section
operator|->
name|constructor_chain
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|section
operator|->
name|reloc_count
condition|;
name|count
operator|++
control|)
block|{
operator|*
name|relptr
operator|++
operator|=
operator|&
name|chain
operator|->
name|relent
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
name|tblptr
operator|=
name|section
operator|->
name|relocation
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|++
operator|<
name|section
operator|->
name|reloc_count
condition|;
control|)
block|{
operator|*
name|relptr
operator|++
operator|=
name|tblptr
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|relptr
operator|=
literal|0
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
return|;
block|}
end_block

begin_define
define|#
directive|define
name|MY_canonicalize_reloc
value|NAME(lynx,canonicalize_reloc)
end_define

begin_include
include|#
directive|include
file|"aout-target.h"
end_include

end_unit

