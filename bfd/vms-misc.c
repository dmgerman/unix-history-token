begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* vms-misc.c -- Miscellaneous functions for VAX (openVMS/VAX) and    EVAX (openVMS/Alpha) files.    Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.     Written by Klaus K"ampf (kkaempf@rmi.de)     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"vms.h"
end_include

begin_escape
end_escape

begin_if
if|#
directive|if
name|VMS_DEBUG
end_if

begin_comment
comment|/* Debug functions.  */
end_comment

begin_comment
comment|/* Debug function for all vms extensions    evaluates environment variable VMS_DEBUG for a    numerical value on the first call    all error levels below this value are printed     levels:    1	toplevel bfd calls (functions from the bfd vector)    2	functions called by bfd calls    ...    9	almost everything     level is also indentation level. Indentation is performed    if level> 0.  */
end_comment

begin_function
name|void
name|_bfd_vms_debug
parameter_list|(
name|int
name|level
parameter_list|,
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
specifier|static
name|int
name|min_level
init|=
operator|-
literal|1
decl_stmt|;
specifier|static
name|FILE
modifier|*
name|output
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|eptr
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|int
name|abslvl
init|=
operator|(
name|level
operator|>
literal|0
operator|)
condition|?
name|level
else|:
operator|-
name|level
decl_stmt|;
if|if
condition|(
name|min_level
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|eptr
operator|=
name|getenv
argument_list|(
literal|"VMS_DEBUG"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|min_level
operator|=
name|atoi
argument_list|(
name|eptr
argument_list|)
expr_stmt|;
name|output
operator|=
name|stderr
expr_stmt|;
block|}
else|else
name|min_level
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|output
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|abslvl
operator|>
name|min_level
condition|)
return|return;
while|while
condition|(
operator|--
name|level
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|output
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|output
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A debug function    hex dump 'size' bytes starting at 'ptr'.  */
end_comment

begin_function
name|void
name|_bfd_hexdump
parameter_list|(
name|int
name|level
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|lptr
init|=
name|ptr
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|long
name|start
init|=
name|offset
decl_stmt|;
while|while
condition|(
name|size
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|count
operator|%
literal|16
operator|)
operator|==
literal|0
condition|)
name|vms_debug
argument_list|(
name|level
argument_list|,
literal|"%08lx:"
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|vms_debug
argument_list|(
operator|-
name|level
argument_list|,
literal|" %02x"
argument_list|,
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|start
operator|++
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|count
operator|%
literal|16
operator|)
operator|!=
literal|0
condition|)
block|{
name|vms_debug
argument_list|(
operator|-
name|level
argument_list|,
literal|"   "
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|count
operator|%
literal|16
operator|)
operator|==
literal|0
condition|)
block|{
name|vms_debug
argument_list|(
operator|-
name|level
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
while|while
condition|(
name|lptr
operator|<
name|ptr
condition|)
block|{
name|vms_debug
argument_list|(
operator|-
name|level
argument_list|,
literal|"%c"
argument_list|,
operator|(
operator|*
name|lptr
operator|<
literal|32
operator|)
condition|?
literal|'.'
else|:
operator|*
name|lptr
argument_list|)
expr_stmt|;
name|lptr
operator|++
expr_stmt|;
block|}
name|vms_debug
argument_list|(
operator|-
name|level
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|count
operator|%
literal|16
operator|)
operator|!=
literal|0
condition|)
name|vms_debug
argument_list|(
operator|-
name|level
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Hash functions     These are needed when reading an object file.  */
end_comment

begin_comment
comment|/* Allocate new vms_hash_entry    keep the symbol name and a pointer to the bfd symbol in the table.  */
end_comment

begin_function
name|struct
name|bfd_hash_entry
modifier|*
name|_bfd_vms_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|vms_symbol_entry
modifier|*
name|ret
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|5
argument_list|,
literal|"_bfd_vms_hash_newfunc (%p, %p, %s)\n"
argument_list|,
name|entry
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|(
name|vms_symbol_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
name|vms_symbol_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|entry
operator|=
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
expr_stmt|;
block|}
comment|/* Call the allocation method of the base class.  */
name|ret
operator|=
operator|(
name|vms_symbol_entry
operator|*
operator|)
name|bfd_hash_newfunc
argument_list|(
name|entry
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|6
argument_list|,
literal|"_bfd_vms_hash_newfunc ret %p\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ret
operator|->
name|symbol
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Object file input functions.  */
end_comment

begin_comment
comment|/* Return type and length from record header (buf) on Alpha.  */
end_comment

begin_function
name|void
name|_bfd_vms_get_header_values
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|type
parameter_list|,
name|int
modifier|*
name|length
parameter_list|)
block|{
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
operator|*
name|type
operator|=
name|bfd_getl16
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|length
operator|!=
literal|0
condition|)
operator|*
name|length
operator|=
name|bfd_getl16
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|10
argument_list|,
literal|"_bfd_vms_get_header_values type %x, length %x\n"
argument_list|,
operator|(
name|type
condition|?
operator|*
name|type
else|:
literal|0
operator|)
argument_list|,
operator|(
name|length
condition|?
operator|*
name|length
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Get next record from object file to vms_buf.    Set PRIV(buf_size) and return it     This is a little tricky since it should be portable.     The openVMS object file has 'variable length' which means that    read() returns data in chunks of (hopefully) correct and expected    size. The linker (and other tools on vms) depend on that. Unix doesn't    know about 'formatted' files, so reading and writing such an object    file in a unix environment is not trivial.     With the tool 'file' (available on all vms ftp sites), one    can view and change the attributes of a file. Changing from    'variable length' to 'fixed length, 512 bytes' reveals the    record length at the first 2 bytes of every record. The same    happens during the transfer of object files from vms to unix,    at least with ucx, dec's implementation of tcp/ip.     The vms format repeats the length at bytes 2& 3 of every record.     On the first call (file_format == FF_UNKNOWN) we check if    the first and the third byte pair (!) of the record match.    If they do it's an object file in an unix environment or with    wrong attributes (FF_FOREIGN), else we should be in a vms    environment where read() returns the record size (FF_NATIVE).     Reading is always done in 2 steps.    First just the record header is read and the length extracted    by get_header_values,    then the read buffer is adjusted and the remaining bytes are    read in.     All file i/o is always done on even file positions.  */
end_comment

begin_function
name|int
name|_bfd_vms_get_record
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|int
name|test_len
decl_stmt|,
name|test_start
decl_stmt|,
name|remaining
decl_stmt|;
name|unsigned
name|char
modifier|*
name|vms_buf
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|8
argument_list|,
literal|"_bfd_vms_get_record\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Minimum is 6 bytes on Alpha      (2 bytes length, 2 bytes record id, 2 bytes length repeated)       On the VAX there's no length information in the record      so start with OBJ_S_C_MAXRECSIZ.   */
if|if
condition|(
name|PRIV
argument_list|(
name|buf_size
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|PRIV
argument_list|(
name|is_vax
argument_list|)
condition|)
block|{
name|amt
operator|=
name|OBJ_S_C_MAXRECSIZ
expr_stmt|;
name|PRIV
argument_list|(
name|file_format
argument_list|)
operator|=
name|FF_VAX
expr_stmt|;
block|}
else|else
name|amt
operator|=
literal|6
expr_stmt|;
name|PRIV
argument_list|(
name|vms_buf
argument_list|)
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
name|PRIV
argument_list|(
name|buf_size
argument_list|)
operator|=
name|amt
expr_stmt|;
block|}
name|vms_buf
operator|=
name|PRIV
argument_list|(
name|vms_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|vms_buf
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|PRIV
argument_list|(
name|file_format
argument_list|)
condition|)
block|{
case|case
name|FF_UNKNOWN
case|:
case|case
name|FF_FOREIGN
case|:
name|test_len
operator|=
literal|6
expr_stmt|;
comment|/* Probe 6 bytes.  */
name|test_start
operator|=
literal|2
expr_stmt|;
comment|/* Where the record starts.  */
break|break;
case|case
name|FF_NATIVE
case|:
name|test_len
operator|=
literal|4
expr_stmt|;
name|test_start
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
case|case
name|FF_VAX
case|:
name|test_len
operator|=
literal|0
expr_stmt|;
name|test_start
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Skip odd alignment byte.  */
if|if
condition|(
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|bfd_bread
argument_list|(
name|PRIV
argument_list|(
name|vms_buf
argument_list|)
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* Read the record header on Alpha.  */
if|if
condition|(
operator|(
name|test_len
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|bfd_bread
argument_list|(
name|PRIV
argument_list|(
name|vms_buf
argument_list|)
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|test_len
argument_list|,
name|abfd
argument_list|)
operator|!=
operator|(
name|bfd_size_type
operator|)
name|test_len
operator|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check file format on first call.  */
if|if
condition|(
name|PRIV
argument_list|(
name|file_format
argument_list|)
operator|==
name|FF_UNKNOWN
condition|)
block|{
comment|/* Record length repeats ?  */
if|if
condition|(
name|vms_buf
index|[
literal|0
index|]
operator|==
name|vms_buf
index|[
literal|4
index|]
operator|&&
name|vms_buf
index|[
literal|1
index|]
operator|==
name|vms_buf
index|[
literal|5
index|]
condition|)
block|{
name|PRIV
argument_list|(
name|file_format
argument_list|)
operator|=
name|FF_FOREIGN
expr_stmt|;
comment|/* Y: foreign environment.  */
name|test_start
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|PRIV
argument_list|(
name|file_format
argument_list|)
operator|=
name|FF_NATIVE
expr_stmt|;
comment|/* N: native environment.  */
name|test_start
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|PRIV
argument_list|(
name|is_vax
argument_list|)
condition|)
block|{
name|PRIV
argument_list|(
name|rec_length
argument_list|)
operator|=
name|bfd_bread
argument_list|(
name|vms_buf
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|PRIV
argument_list|(
name|buf_size
argument_list|)
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|PRIV
argument_list|(
name|rec_length
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|PRIV
argument_list|(
name|vms_rec
argument_list|)
operator|=
name|vms_buf
expr_stmt|;
block|}
else|else
block|{
comment|/* Alpha.   */
comment|/* Extract vms record length.  */
name|_bfd_vms_get_header_values
argument_list|(
name|abfd
argument_list|,
name|vms_buf
operator|+
name|test_start
argument_list|,
name|NULL
argument_list|,
operator|&
name|PRIV
argument_list|(
name|rec_length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PRIV
argument_list|(
name|rec_length
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* That's what the linker manual says.  */
if|if
condition|(
name|PRIV
argument_list|(
name|rec_length
argument_list|)
operator|>
name|EOBJ_S_C_MAXRECSIZ
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Adjust the buffer.  */
if|if
condition|(
name|PRIV
argument_list|(
name|rec_length
argument_list|)
operator|>
name|PRIV
argument_list|(
name|buf_size
argument_list|)
condition|)
block|{
name|PRIV
argument_list|(
name|vms_buf
argument_list|)
operator|=
name|bfd_realloc
argument_list|(
name|vms_buf
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|PRIV
argument_list|(
name|rec_length
argument_list|)
argument_list|)
expr_stmt|;
name|vms_buf
operator|=
name|PRIV
argument_list|(
name|vms_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|vms_buf
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|PRIV
argument_list|(
name|buf_size
argument_list|)
operator|=
name|PRIV
argument_list|(
name|rec_length
argument_list|)
expr_stmt|;
block|}
comment|/* Read the remaining record.  */
name|remaining
operator|=
name|PRIV
argument_list|(
name|rec_length
argument_list|)
operator|-
name|test_len
operator|+
name|test_start
expr_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|10
argument_list|,
literal|"bfd_bread remaining %d\n"
argument_list|,
name|remaining
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bfd_bread
argument_list|(
name|vms_buf
operator|+
name|test_len
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|remaining
argument_list|,
name|abfd
argument_list|)
operator|!=
operator|(
name|bfd_size_type
operator|)
name|remaining
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|PRIV
argument_list|(
name|vms_rec
argument_list|)
operator|=
name|vms_buf
operator|+
name|test_start
expr_stmt|;
block|}
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|11
argument_list|,
literal|"bfd_bread rec_length %d\n"
argument_list|,
name|PRIV
argument_list|(
name|rec_length
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|PRIV
argument_list|(
name|rec_length
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get next vms record from file    update vms_rec and rec_length to new (remaining) values.  */
end_comment

begin_function
name|int
name|_bfd_vms_next_record
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|8
argument_list|,
literal|"_bfd_vms_next_record (len %d, size %d)\n"
argument_list|,
name|PRIV
argument_list|(
name|rec_length
argument_list|)
argument_list|,
name|PRIV
argument_list|(
name|rec_size
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|PRIV
argument_list|(
name|rec_length
argument_list|)
operator|>
literal|0
condition|)
name|PRIV
argument_list|(
name|vms_rec
argument_list|)
operator|+=
name|PRIV
argument_list|(
name|rec_size
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|_bfd_vms_get_record
argument_list|(
name|abfd
argument_list|)
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|PRIV
argument_list|(
name|vms_rec
argument_list|)
operator|||
operator|!
name|PRIV
argument_list|(
name|vms_buf
argument_list|)
operator|||
name|PRIV
argument_list|(
name|vms_rec
argument_list|)
operator|>=
operator|(
name|PRIV
argument_list|(
name|vms_buf
argument_list|)
operator|+
name|PRIV
argument_list|(
name|buf_size
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|PRIV
argument_list|(
name|is_vax
argument_list|)
condition|)
block|{
name|PRIV
argument_list|(
name|rec_type
argument_list|)
operator|=
operator|*
operator|(
name|PRIV
argument_list|(
name|vms_rec
argument_list|)
operator|)
expr_stmt|;
name|PRIV
argument_list|(
name|rec_size
argument_list|)
operator|=
name|PRIV
argument_list|(
name|rec_length
argument_list|)
expr_stmt|;
block|}
else|else
name|_bfd_vms_get_header_values
argument_list|(
name|abfd
argument_list|,
name|PRIV
argument_list|(
name|vms_rec
argument_list|)
argument_list|,
operator|&
name|PRIV
argument_list|(
name|rec_type
argument_list|)
argument_list|,
operator|&
name|PRIV
argument_list|(
name|rec_size
argument_list|)
argument_list|)
expr_stmt|;
name|PRIV
argument_list|(
name|rec_length
argument_list|)
operator|-=
name|PRIV
argument_list|(
name|rec_size
argument_list|)
expr_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|8
argument_list|,
literal|"_bfd_vms_next_record: rec %p, size %d, length %d, type %d\n"
argument_list|,
name|PRIV
argument_list|(
name|vms_rec
argument_list|)
argument_list|,
name|PRIV
argument_list|(
name|rec_size
argument_list|)
argument_list|,
name|PRIV
argument_list|(
name|rec_length
argument_list|)
argument_list|,
name|PRIV
argument_list|(
name|rec_type
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|PRIV
argument_list|(
name|rec_type
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy sized string (string with fixed length) to new allocated area    size is string length (size of record)  */
end_comment

begin_function
name|char
modifier|*
name|_bfd_vms_save_sized_string
parameter_list|(
name|unsigned
name|char
modifier|*
name|str
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|char
modifier|*
name|newstr
init|=
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|newstr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|strncpy
argument_list|(
name|newstr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|str
argument_list|,
operator|(
name|size_t
operator|)
name|size
argument_list|)
expr_stmt|;
name|newstr
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|newstr
return|;
block|}
end_function

begin_comment
comment|/* Copy counted string (string with length at first byte) to new allocated area    ptr points to length byte on entry  */
end_comment

begin_function
name|char
modifier|*
name|_bfd_vms_save_counted_string
parameter_list|(
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|)
block|{
name|int
name|len
init|=
operator|*
name|ptr
operator|++
decl_stmt|;
return|return
name|_bfd_vms_save_sized_string
argument_list|(
name|ptr
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Stack routines for vms ETIR commands.  */
end_comment

begin_comment
comment|/* Push value and section index.  */
end_comment

begin_function
name|void
name|_bfd_vms_push
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|uquad
name|val
parameter_list|,
name|int
name|psect
parameter_list|)
block|{
specifier|static
name|int
name|last_psect
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|4
argument_list|,
literal|"<push %016lx (%d) at %d>\n"
argument_list|,
name|val
argument_list|,
name|psect
argument_list|,
name|PRIV
argument_list|(
name|stackptr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|psect
operator|>=
literal|0
condition|)
name|last_psect
operator|=
name|psect
expr_stmt|;
name|PRIV
argument_list|(
name|stack
index|[
name|PRIV
argument_list|(
name|stackptr
argument_list|)
index|]
argument_list|)
operator|.
name|value
operator|=
name|val
expr_stmt|;
name|PRIV
argument_list|(
name|stack
index|[
name|PRIV
argument_list|(
name|stackptr
argument_list|)
index|]
argument_list|)
operator|.
name|psect
operator|=
name|last_psect
expr_stmt|;
name|PRIV
argument_list|(
name|stackptr
argument_list|)
operator|++
expr_stmt|;
if|if
condition|(
name|PRIV
argument_list|(
name|stackptr
argument_list|)
operator|>=
name|STACKSIZE
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Stack overflow (%d) in _bfd_vms_push"
argument_list|)
argument_list|,
name|PRIV
argument_list|(
name|stackptr
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Pop value and section index.  */
end_comment

begin_function
name|uquad
name|_bfd_vms_pop
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
modifier|*
name|psect
parameter_list|)
block|{
name|uquad
name|value
decl_stmt|;
if|if
condition|(
name|PRIV
argument_list|(
name|stackptr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Stack underflow in _bfd_vms_pop"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|PRIV
argument_list|(
name|stackptr
argument_list|)
operator|--
expr_stmt|;
name|value
operator|=
name|PRIV
argument_list|(
name|stack
index|[
name|PRIV
argument_list|(
name|stackptr
argument_list|)
index|]
argument_list|)
operator|.
name|value
expr_stmt|;
if|if
condition|(
operator|(
name|psect
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|PRIV
argument_list|(
name|stack
index|[
name|PRIV
argument_list|(
name|stackptr
argument_list|)
index|]
argument_list|)
operator|.
name|psect
operator|>=
literal|0
operator|)
condition|)
operator|*
name|psect
operator|=
name|PRIV
argument_list|(
name|stack
index|[
name|PRIV
argument_list|(
name|stackptr
argument_list|)
index|]
argument_list|)
operator|.
name|psect
expr_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|4
argument_list|,
literal|"<pop %016lx(%d)>\n"
argument_list|,
name|value
argument_list|,
name|PRIV
argument_list|(
name|stack
index|[
name|PRIV
argument_list|(
name|stackptr
argument_list|)
index|]
argument_list|)
operator|.
name|psect
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Object file output functions.  */
end_comment

begin_comment
comment|/* GAS tends to write sections in little chunks (bfd_set_section_contents)    which we can't use directly. So we save the little chunks in linked    lists (one per section) and write them later.  */
end_comment

begin_comment
comment|/* Add a new vms_section structure to vms_section_table    - forward chaining -.  */
end_comment

begin_function
specifier|static
name|vms_section
modifier|*
name|add_new_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|sec_ptr
name|section
parameter_list|)
block|{
name|vms_section
modifier|*
name|sptr
decl_stmt|,
modifier|*
name|newptr
decl_stmt|;
name|sptr
operator|=
name|PRIV
argument_list|(
name|vms_section_table
argument_list|)
index|[
name|section
operator|->
name|index
index|]
expr_stmt|;
if|if
condition|(
name|sptr
operator|!=
name|NULL
condition|)
return|return
name|sptr
return|;
name|newptr
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|vms_section
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newptr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|newptr
operator|->
name|contents
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|newptr
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|newptr
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|newptr
operator|->
name|size
operator|=
name|section
operator|->
name|size
expr_stmt|;
name|newptr
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|PRIV
argument_list|(
name|vms_section_table
argument_list|)
index|[
name|section
operator|->
name|index
index|]
operator|=
name|newptr
expr_stmt|;
return|return
name|newptr
return|;
block|}
end_function

begin_comment
comment|/* Save section data& offset to a vms_section structure    vms_section_table[] holds the vms_section chain.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_save_vms_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|sec_ptr
name|section
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|file_ptr
name|offset
parameter_list|,
name|bfd_size_type
name|count
parameter_list|)
block|{
name|vms_section
modifier|*
name|sptr
decl_stmt|;
if|if
condition|(
name|section
operator|->
name|index
operator|>=
name|VMS_SECTION_COUNT
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_nonrepresentable_section
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|count
operator|==
operator|(
name|bfd_size_type
operator|)
literal|0
condition|)
return|return
name|TRUE
return|;
name|sptr
operator|=
name|add_new_contents
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|sptr
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
name|sptr
operator|->
name|contents
operator|+
name|offset
argument_list|,
name|data
argument_list|,
operator|(
name|size_t
operator|)
name|count
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Get vms_section pointer to saved contents for section # index  */
end_comment

begin_function
name|vms_section
modifier|*
name|_bfd_get_vms_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|index
operator|>=
name|VMS_SECTION_COUNT
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_nonrepresentable_section
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|PRIV
argument_list|(
name|vms_section_table
argument_list|)
index|[
name|index
index|]
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Object output routines.   */
end_comment

begin_comment
comment|/* Begin new record or record header    write 2 bytes rectype    write 2 bytes record length (filled in at flush)    write 2 bytes header type (ommitted if rechead == -1).   */
end_comment

begin_function
name|void
name|_bfd_vms_output_begin
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|rectype
parameter_list|,
name|int
name|rechead
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|6
argument_list|,
literal|"_bfd_vms_output_begin (type %d, head %d)\n"
argument_list|,
name|rectype
argument_list|,
name|rechead
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_bfd_vms_output_short
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|rectype
argument_list|)
expr_stmt|;
comment|/* Save current output position to fill in length later.   */
if|if
condition|(
name|PRIV
argument_list|(
name|push_level
argument_list|)
operator|>
literal|0
condition|)
name|PRIV
argument_list|(
name|length_pos
argument_list|)
operator|=
name|PRIV
argument_list|(
name|output_size
argument_list|)
expr_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|6
argument_list|,
literal|"_bfd_vms_output_begin: length_pos = %d\n"
argument_list|,
name|PRIV
argument_list|(
name|length_pos
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Placeholder for length.  */
name|_bfd_vms_output_short
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rechead
operator|!=
operator|-
literal|1
condition|)
name|_bfd_vms_output_short
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|rechead
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set record/subrecord alignment.   */
end_comment

begin_function
name|void
name|_bfd_vms_output_alignment
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|alignto
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|6
argument_list|,
literal|"_bfd_vms_output_alignment (%d)\n"
argument_list|,
name|alignto
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PRIV
argument_list|(
name|output_alignment
argument_list|)
operator|=
name|alignto
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prepare for subrecord fields.  */
end_comment

begin_function
name|void
name|_bfd_vms_output_push
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|6
argument_list|,
literal|"vms_output_push (pushed_size = %d)\n"
argument_list|,
name|PRIV
argument_list|(
name|output_size
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PRIV
argument_list|(
name|push_level
argument_list|)
operator|++
expr_stmt|;
name|PRIV
argument_list|(
name|pushed_size
argument_list|)
operator|=
name|PRIV
argument_list|(
name|output_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End of subrecord fields.   */
end_comment

begin_function
name|void
name|_bfd_vms_output_pop
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|6
argument_list|,
literal|"vms_output_pop (pushed_size = %d)\n"
argument_list|,
name|PRIV
argument_list|(
name|pushed_size
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_bfd_vms_output_flush
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|PRIV
argument_list|(
name|length_pos
argument_list|)
operator|=
literal|2
expr_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|6
argument_list|,
literal|"vms_output_pop: length_pos = %d\n"
argument_list|,
name|PRIV
argument_list|(
name|length_pos
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PRIV
argument_list|(
name|pushed_size
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PRIV
argument_list|(
name|push_level
argument_list|)
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flush unwritten output, ends current record.  */
end_comment

begin_function
name|void
name|_bfd_vms_output_flush
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|int
name|real_size
init|=
name|PRIV
argument_list|(
name|output_size
argument_list|)
decl_stmt|;
name|int
name|aligncount
decl_stmt|;
name|int
name|length
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|6
argument_list|,
literal|"_bfd_vms_output_flush (real_size = %d, pushed_size %d at lenpos %d)\n"
argument_list|,
name|real_size
argument_list|,
name|PRIV
argument_list|(
name|pushed_size
argument_list|)
argument_list|,
name|PRIV
argument_list|(
name|length_pos
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|PRIV
argument_list|(
name|push_level
argument_list|)
operator|>
literal|0
condition|)
name|length
operator|=
name|real_size
operator|-
name|PRIV
argument_list|(
name|pushed_size
argument_list|)
expr_stmt|;
else|else
name|length
operator|=
name|real_size
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
return|return;
name|aligncount
operator|=
operator|(
name|PRIV
argument_list|(
name|output_alignment
argument_list|)
operator|-
operator|(
name|length
operator|%
name|PRIV
argument_list|(
name|output_alignment
argument_list|)
operator|)
operator|)
operator|%
name|PRIV
argument_list|(
name|output_alignment
argument_list|)
expr_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|6
argument_list|,
literal|"align: adding %d bytes\n"
argument_list|,
name|aligncount
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|aligncount
operator|--
operator|>
literal|0
condition|)
block|{
name|PRIV
argument_list|(
name|output_buf
argument_list|)
index|[
name|real_size
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|length
operator|++
expr_stmt|;
block|}
comment|/* Put length to buffer.  */
name|PRIV
argument_list|(
name|output_size
argument_list|)
operator|=
name|PRIV
argument_list|(
name|length_pos
argument_list|)
expr_stmt|;
name|_bfd_vms_output_short
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|PRIV
argument_list|(
name|push_level
argument_list|)
operator|==
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|VMS
comment|/* Write length first, see FF_FOREIGN in the input routines.  */
name|fwrite
argument_list|(
name|PRIV
argument_list|(
name|output_buf
argument_list|)
operator|+
literal|2
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
operator|(
name|FILE
operator|*
operator|)
name|abfd
operator|->
name|iostream
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fwrite
argument_list|(
name|PRIV
argument_list|(
name|output_buf
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|real_size
argument_list|,
literal|1
argument_list|,
operator|(
name|FILE
operator|*
operator|)
name|abfd
operator|->
name|iostream
argument_list|)
expr_stmt|;
name|PRIV
argument_list|(
name|output_size
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|PRIV
argument_list|(
name|output_size
argument_list|)
operator|=
name|real_size
expr_stmt|;
name|PRIV
argument_list|(
name|pushed_size
argument_list|)
operator|=
name|PRIV
argument_list|(
name|output_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* End record output.   */
end_comment

begin_function
name|void
name|_bfd_vms_output_end
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|6
argument_list|,
literal|"_bfd_vms_output_end\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_bfd_vms_output_flush
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check remaining buffer size     Return what's left.  */
end_comment

begin_function
name|int
name|_bfd_vms_output_check
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|6
argument_list|,
literal|"_bfd_vms_output_check (%d)\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|MAX_OUTREC_SIZE
operator|-
operator|(
name|PRIV
argument_list|(
name|output_size
argument_list|)
operator|+
name|size
operator|+
name|MIN_OUTREC_LUFT
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Output byte (8 bit) value.  */
end_comment

begin_function
name|void
name|_bfd_vms_output_byte
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|int
name|value
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|6
argument_list|,
literal|"_bfd_vms_output_byte (%02x)\n"
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|value
operator|&
literal|0xff
argument_list|,
name|PRIV
argument_list|(
name|output_buf
argument_list|)
operator|+
name|PRIV
argument_list|(
name|output_size
argument_list|)
argument_list|)
expr_stmt|;
name|PRIV
argument_list|(
name|output_size
argument_list|)
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output short (16 bit) value.  */
end_comment

begin_function
name|void
name|_bfd_vms_output_short
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|int
name|value
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|6
argument_list|,
literal|"_bfd_vms_output_short (%04x)\n"
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|value
operator|&
literal|0xffff
argument_list|,
name|PRIV
argument_list|(
name|output_buf
argument_list|)
operator|+
name|PRIV
argument_list|(
name|output_size
argument_list|)
argument_list|)
expr_stmt|;
name|PRIV
argument_list|(
name|output_size
argument_list|)
operator|+=
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output long (32 bit) value.  */
end_comment

begin_function
name|void
name|_bfd_vms_output_long
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|long
name|value
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|6
argument_list|,
literal|"_bfd_vms_output_long (%08lx)\n"
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
name|PRIV
argument_list|(
name|output_buf
argument_list|)
operator|+
name|PRIV
argument_list|(
name|output_size
argument_list|)
argument_list|)
expr_stmt|;
name|PRIV
argument_list|(
name|output_size
argument_list|)
operator|+=
literal|4
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output quad (64 bit) value.  */
end_comment

begin_function
name|void
name|_bfd_vms_output_quad
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|uquad
name|value
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|6
argument_list|,
literal|"_bfd_vms_output_quad (%016lx)\n"
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|PRIV
argument_list|(
name|output_buf
argument_list|)
operator|+
name|PRIV
argument_list|(
name|output_size
argument_list|)
argument_list|)
expr_stmt|;
name|PRIV
argument_list|(
name|output_size
argument_list|)
operator|+=
literal|8
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output c-string as counted string.  */
end_comment

begin_function
name|void
name|_bfd_vms_output_counted
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|value
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|6
argument_list|,
literal|"_bfd_vms_output_counted (%s)\n"
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|len
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"_bfd_vms_output_counted called with zero bytes"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|len
operator|>
literal|255
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"_bfd_vms_output_counted called with too many bytes"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|_bfd_vms_output_byte
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|len
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|_bfd_vms_output_dump
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|value
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output character area.  */
end_comment

begin_function
name|void
name|_bfd_vms_output_dump
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|6
argument_list|,
literal|"_bfd_vms_output_dump (%d)\n"
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|length
operator|==
literal|0
condition|)
return|return;
name|memcpy
argument_list|(
name|PRIV
argument_list|(
name|output_buf
argument_list|)
operator|+
name|PRIV
argument_list|(
name|output_size
argument_list|)
argument_list|,
name|data
argument_list|,
operator|(
name|size_t
operator|)
name|length
argument_list|)
expr_stmt|;
name|PRIV
argument_list|(
name|output_size
argument_list|)
operator|+=
name|length
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output count bytes of value.  */
end_comment

begin_function
name|void
name|_bfd_vms_output_fill
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|value
parameter_list|,
name|int
name|count
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|6
argument_list|,
literal|"_bfd_vms_output_fill (val %02x times %d)\n"
argument_list|,
name|value
argument_list|,
name|count
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return;
name|memset
argument_list|(
name|PRIV
argument_list|(
name|output_buf
argument_list|)
operator|+
name|PRIV
argument_list|(
name|output_size
argument_list|)
argument_list|,
name|value
argument_list|,
operator|(
name|size_t
operator|)
name|count
argument_list|)
expr_stmt|;
name|PRIV
argument_list|(
name|output_size
argument_list|)
operator|+=
name|count
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This hash routine borrowed from GNU-EMACS, and strengthened slightly.  ERY.  */
end_comment

begin_function
specifier|static
name|int
name|hash_string
parameter_list|(
specifier|const
name|char
modifier|*
name|ptr
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ptr
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|end
init|=
name|p
operator|+
name|strlen
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|int
name|hash
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|end
condition|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|hash
operator|=
operator|(
operator|(
name|hash
operator|<<
literal|3
operator|)
operator|+
operator|(
name|hash
operator|<<
literal|15
operator|)
operator|+
operator|(
name|hash
operator|>>
literal|28
operator|)
operator|+
name|c
operator|)
expr_stmt|;
block|}
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/* Generate a length-hashed VMS symbol name (limited to maxlen chars).  */
end_comment

begin_function
name|char
modifier|*
name|_bfd_vms_length_hash_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|int
name|maxlen
parameter_list|)
block|{
name|long
name|int
name|result
decl_stmt|;
name|int
name|in_len
decl_stmt|;
name|char
modifier|*
name|new_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_name
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|outbuf
index|[
name|EOBJ_S_C_SYMSIZ
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|out
init|=
name|outbuf
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|4
argument_list|,
literal|"_bfd_vms_length_hash_symbol \"%s\"\n"
argument_list|,
name|in
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|maxlen
operator|>
name|EOBJ_S_C_SYMSIZ
condition|)
name|maxlen
operator|=
name|EOBJ_S_C_SYMSIZ
expr_stmt|;
comment|/* Save this for later.  */
name|new_name
operator|=
name|out
expr_stmt|;
comment|/* We may need to truncate the symbol, save the hash for later.  */
name|in_len
operator|=
name|strlen
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|in_len
operator|>
name|maxlen
operator|)
condition|?
name|hash_string
argument_list|(
name|in
argument_list|)
else|:
literal|0
expr_stmt|;
name|old_name
operator|=
name|in
expr_stmt|;
comment|/* Do the length checking.  */
if|if
condition|(
name|in_len
operator|<=
name|maxlen
condition|)
name|i
operator|=
name|in_len
expr_stmt|;
else|else
block|{
if|if
condition|(
name|PRIV
argument_list|(
name|flag_hash_long_names
argument_list|)
condition|)
name|i
operator|=
name|maxlen
operator|-
literal|9
expr_stmt|;
else|else
name|i
operator|=
name|maxlen
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|out
argument_list|,
name|in
argument_list|,
operator|(
name|size_t
operator|)
name|i
argument_list|)
expr_stmt|;
name|in
operator|+=
name|i
expr_stmt|;
name|out
operator|+=
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|in_len
operator|>
name|maxlen
operator|)
operator|&&
name|PRIV
argument_list|(
name|flag_hash_long_names
argument_list|)
condition|)
name|sprintf
argument_list|(
name|out
argument_list|,
literal|"_%08lx"
argument_list|,
name|result
argument_list|)
expr_stmt|;
else|else
operator|*
name|out
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|4
argument_list|,
literal|"--> [%d]\"%s\"\n"
argument_list|,
name|strlen
argument_list|(
name|outbuf
argument_list|)
argument_list|,
name|outbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|in_len
operator|>
name|maxlen
operator|&&
name|PRIV
argument_list|(
name|flag_hash_long_names
argument_list|)
operator|&&
name|PRIV
argument_list|(
name|flag_show_after_trunc
argument_list|)
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"Symbol %s replaced by %s\n"
argument_list|)
argument_list|,
name|old_name
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
return|return
name|outbuf
return|;
block|}
end_function

begin_comment
comment|/* Allocate and initialize a new symbol.  */
end_comment

begin_function
specifier|static
name|asymbol
modifier|*
name|new_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|asymbol
modifier|*
name|symbol
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|7
argument_list|,
literal|"new_symbol %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|symbol
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
operator|==
literal|0
condition|)
return|return
name|symbol
return|;
name|symbol
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|symbol
operator|->
name|section
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|BFD_UND_SECTION_NAME
argument_list|)
expr_stmt|;
return|return
name|symbol
return|;
block|}
end_function

begin_comment
comment|/* Allocate and enter a new private symbol.  */
end_comment

begin_function
name|vms_symbol_entry
modifier|*
name|_bfd_vms_enter_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|vms_symbol_entry
modifier|*
name|entry
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|6
argument_list|,
literal|"_bfd_vms_enter_symbol %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|entry
operator|=
operator|(
name|vms_symbol_entry
operator|*
operator|)
name|bfd_hash_lookup
argument_list|(
name|PRIV
argument_list|(
name|vms_symbol_table
argument_list|)
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|8
argument_list|,
literal|"creating hash entry for %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|entry
operator|=
operator|(
name|vms_symbol_entry
operator|*
operator|)
name|bfd_hash_lookup
argument_list|(
name|PRIV
argument_list|(
name|vms_symbol_table
argument_list|)
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|0
condition|)
block|{
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|symbol
operator|=
name|new_symbol
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
operator|!=
literal|0
condition|)
block|{
name|entry
operator|->
name|symbol
operator|=
name|symbol
expr_stmt|;
name|PRIV
argument_list|(
name|gsd_sym_count
argument_list|)
operator|++
expr_stmt|;
name|abfd
operator|->
name|symcount
operator|++
expr_stmt|;
block|}
else|else
name|entry
operator|=
literal|0
expr_stmt|;
block|}
else|else
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"failed to enter %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|8
argument_list|,
literal|"found hash entry for %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|VMS_DEBUG
name|_bfd_vms_debug
argument_list|(
literal|7
argument_list|,
literal|"-> entry %p, entry->symbol %p\n"
argument_list|,
name|entry
argument_list|,
name|entry
operator|->
name|symbol
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|entry
return|;
block|}
end_function

end_unit

