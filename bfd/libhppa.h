begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* HP PA-RISC SOM object file format:  definitions internal to BFD.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,    2003 Free Software Foundation, Inc.     Contributed by the Center for Software Science at the    University of Utah (pa-gdb-bugs@cs.utah.edu).     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_LIBHPPA_H
end_ifndef

begin_define
define|#
directive|define
name|_LIBHPPA_H
end_define

begin_define
define|#
directive|define
name|BYTES_IN_WORD
value|4
end_define

begin_define
define|#
directive|define
name|PA_PAGESIZE
value|0x1000
end_define

begin_comment
comment|/* The PA instruction set variants.  */
end_comment

begin_enum
enum|enum
name|pa_arch
block|{
name|pa10
init|=
literal|10
block|,
name|pa11
init|=
literal|11
block|,
name|pa20
init|=
literal|20
block|,
name|pa20w
init|=
literal|25
block|}
enum|;
end_enum

begin_comment
comment|/* HP PA-RISC relocation types */
end_comment

begin_enum
enum|enum
name|hppa_reloc_field_selector_type
block|{
name|R_HPPA_FSEL
init|=
literal|0x0
block|,
name|R_HPPA_LSSEL
init|=
literal|0x1
block|,
name|R_HPPA_RSSEL
init|=
literal|0x2
block|,
name|R_HPPA_LSEL
init|=
literal|0x3
block|,
name|R_HPPA_RSEL
init|=
literal|0x4
block|,
name|R_HPPA_LDSEL
init|=
literal|0x5
block|,
name|R_HPPA_RDSEL
init|=
literal|0x6
block|,
name|R_HPPA_LRSEL
init|=
literal|0x7
block|,
name|R_HPPA_RRSEL
init|=
literal|0x8
block|,
name|R_HPPA_NSEL
init|=
literal|0x9
block|,
name|R_HPPA_NLSEL
init|=
literal|0xa
block|,
name|R_HPPA_NLRSEL
init|=
literal|0xb
block|,
name|R_HPPA_PSEL
init|=
literal|0xc
block|,
name|R_HPPA_LPSEL
init|=
literal|0xd
block|,
name|R_HPPA_RPSEL
init|=
literal|0xe
block|,
name|R_HPPA_TSEL
init|=
literal|0xf
block|,
name|R_HPPA_LTSEL
init|=
literal|0x10
block|,
name|R_HPPA_RTSEL
init|=
literal|0x11
block|,
name|R_HPPA_LTPSEL
init|=
literal|0x12
block|,
name|R_HPPA_RTPSEL
init|=
literal|0x13
block|}
enum|;
end_enum

begin_comment
comment|/* /usr/include/reloc.h defines these to constants.  We want to use    them in enums, so #undef them before we start using them.  We might    be able to fix this another way by simply managing not to include    /usr/include/reloc.h, but currently GDB picks up these defines    somewhere.  */
end_comment

begin_undef
undef|#
directive|undef
name|e_fsel
end_undef

begin_undef
undef|#
directive|undef
name|e_lssel
end_undef

begin_undef
undef|#
directive|undef
name|e_rssel
end_undef

begin_undef
undef|#
directive|undef
name|e_lsel
end_undef

begin_undef
undef|#
directive|undef
name|e_rsel
end_undef

begin_undef
undef|#
directive|undef
name|e_ldsel
end_undef

begin_undef
undef|#
directive|undef
name|e_rdsel
end_undef

begin_undef
undef|#
directive|undef
name|e_lrsel
end_undef

begin_undef
undef|#
directive|undef
name|e_rrsel
end_undef

begin_undef
undef|#
directive|undef
name|e_nsel
end_undef

begin_undef
undef|#
directive|undef
name|e_nlsel
end_undef

begin_undef
undef|#
directive|undef
name|e_nlrsel
end_undef

begin_undef
undef|#
directive|undef
name|e_psel
end_undef

begin_undef
undef|#
directive|undef
name|e_lpsel
end_undef

begin_undef
undef|#
directive|undef
name|e_rpsel
end_undef

begin_undef
undef|#
directive|undef
name|e_tsel
end_undef

begin_undef
undef|#
directive|undef
name|e_ltsel
end_undef

begin_undef
undef|#
directive|undef
name|e_rtsel
end_undef

begin_undef
undef|#
directive|undef
name|e_one
end_undef

begin_undef
undef|#
directive|undef
name|e_two
end_undef

begin_undef
undef|#
directive|undef
name|e_pcrel
end_undef

begin_undef
undef|#
directive|undef
name|e_con
end_undef

begin_undef
undef|#
directive|undef
name|e_plabel
end_undef

begin_undef
undef|#
directive|undef
name|e_abs
end_undef

begin_comment
comment|/* for compatibility */
end_comment

begin_enum
enum|enum
name|hppa_reloc_field_selector_type_alt
block|{
name|e_fsel
init|=
name|R_HPPA_FSEL
block|,
name|e_lssel
init|=
name|R_HPPA_LSSEL
block|,
name|e_rssel
init|=
name|R_HPPA_RSSEL
block|,
name|e_lsel
init|=
name|R_HPPA_LSEL
block|,
name|e_rsel
init|=
name|R_HPPA_RSEL
block|,
name|e_ldsel
init|=
name|R_HPPA_LDSEL
block|,
name|e_rdsel
init|=
name|R_HPPA_RDSEL
block|,
name|e_lrsel
init|=
name|R_HPPA_LRSEL
block|,
name|e_rrsel
init|=
name|R_HPPA_RRSEL
block|,
name|e_nsel
init|=
name|R_HPPA_NSEL
block|,
name|e_nlsel
init|=
name|R_HPPA_NLSEL
block|,
name|e_nlrsel
init|=
name|R_HPPA_NLRSEL
block|,
name|e_psel
init|=
name|R_HPPA_PSEL
block|,
name|e_lpsel
init|=
name|R_HPPA_LPSEL
block|,
name|e_rpsel
init|=
name|R_HPPA_RPSEL
block|,
name|e_tsel
init|=
name|R_HPPA_TSEL
block|,
name|e_ltsel
init|=
name|R_HPPA_LTSEL
block|,
name|e_rtsel
init|=
name|R_HPPA_RTSEL
block|,
name|e_ltpsel
init|=
name|R_HPPA_LTPSEL
block|,
name|e_rtpsel
init|=
name|R_HPPA_RTPSEL
block|}
enum|;
end_enum

begin_enum
enum|enum
name|hppa_reloc_expr_type
block|{
name|R_HPPA_E_ONE
init|=
literal|0
block|,
name|R_HPPA_E_TWO
init|=
literal|1
block|,
name|R_HPPA_E_PCREL
init|=
literal|2
block|,
name|R_HPPA_E_CON
init|=
literal|3
block|,
name|R_HPPA_E_PLABEL
init|=
literal|7
block|,
name|R_HPPA_E_ABS
init|=
literal|18
block|}
enum|;
end_enum

begin_comment
comment|/* for compatibility */
end_comment

begin_enum
enum|enum
name|hppa_reloc_expr_type_alt
block|{
name|e_one
init|=
name|R_HPPA_E_ONE
block|,
name|e_two
init|=
name|R_HPPA_E_TWO
block|,
name|e_pcrel
init|=
name|R_HPPA_E_PCREL
block|,
name|e_con
init|=
name|R_HPPA_E_CON
block|,
name|e_plabel
init|=
name|R_HPPA_E_PLABEL
block|,
name|e_abs
init|=
name|R_HPPA_E_ABS
block|}
enum|;
end_enum

begin_comment
comment|/* Relocations for function calls must be accompanied by parameter    relocation bits.  These bits describe exactly where the caller has    placed the function's arguments and where it expects to find a return    value.     Both ELF and SOM encode this information within the addend field    of the call relocation.  (Note this could break very badly if one    was to make a call like bl foo + 0x12345678).     The high order 10 bits contain parameter relocation information,    the low order 22 bits contain the constant offset.  */
end_comment

begin_define
define|#
directive|define
name|HPPA_R_ARG_RELOC
parameter_list|(
name|a
parameter_list|)
define|\
value|(((a)>> 22)& 0x3ff)
end_define

begin_define
define|#
directive|define
name|HPPA_R_CONSTANT
parameter_list|(
name|a
parameter_list|)
define|\
value|((((bfd_signed_vma)(a))<< (BFD_ARCH_SIZE-22))>> (BFD_ARCH_SIZE-22))
end_define

begin_define
define|#
directive|define
name|HPPA_R_ADDEND
parameter_list|(
name|r
parameter_list|,
name|c
parameter_list|)
define|\
value|(((r)<< 22) + ((c)& 0x3fffff))
end_define

begin_comment
comment|/* Some functions to manipulate PA instructions.  */
end_comment

begin_comment
comment|/* Declare the functions with the unused attribute to avoid warnings.  */
end_comment

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|sign_extend
argument_list|(
name|int
argument_list|,
name|int
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|low_sign_extend
argument_list|(
name|int
argument_list|,
name|int
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|sign_unext
argument_list|(
name|int
argument_list|,
name|int
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|low_sign_unext
argument_list|(
name|int
argument_list|,
name|int
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|re_assemble_3
argument_list|(
name|int
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|re_assemble_12
argument_list|(
name|int
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|re_assemble_14
argument_list|(
name|int
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|re_assemble_16
argument_list|(
name|int
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|re_assemble_17
argument_list|(
name|int
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|re_assemble_21
argument_list|(
name|int
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|re_assemble_22
argument_list|(
name|int
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|bfd_signed_vma
name|hppa_field_adjust
argument_list|(
name|bfd_vma
argument_list|,
name|bfd_signed_vma
argument_list|,
expr|enum
name|hppa_reloc_field_selector_type_alt
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|bfd_hppa_insn2fmt
argument_list|(
name|bfd
operator|*
argument_list|,
name|int
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|hppa_rebuild_insn
argument_list|(
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The *sign_extend functions are used to assemble various bitfields    taken from an instruction and return the resulting immediate    value.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|sign_extend
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|signbit
init|=
operator|(
literal|1
operator|<<
operator|(
name|len
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
name|int
name|mask
init|=
operator|(
name|signbit
operator|<<
literal|1
operator|)
operator|-
literal|1
decl_stmt|;
return|return
operator|(
operator|(
name|x
operator|&
name|mask
operator|)
operator|^
name|signbit
operator|)
operator|-
name|signbit
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|low_sign_extend
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
operator|(
name|x
operator|>>
literal|1
operator|)
operator|-
operator|(
operator|(
name|x
operator|&
literal|1
operator|)
operator|<<
operator|(
name|len
operator|-
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The re_assemble_* functions prepare an immediate value for    insertion into an opcode. pa-risc uses all sorts of weird bitfields    in the instruction to hold the value.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|sign_unext
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|len_ones
decl_stmt|;
name|len_ones
operator|=
operator|(
literal|1
operator|<<
name|len
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|x
operator|&
name|len_ones
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|low_sign_unext
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|temp
decl_stmt|;
name|int
name|sign
decl_stmt|;
name|sign
operator|=
operator|(
name|x
operator|>>
operator|(
name|len
operator|-
literal|1
operator|)
operator|)
operator|&
literal|1
expr_stmt|;
name|temp
operator|=
name|sign_unext
argument_list|(
name|x
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|<<
literal|1
operator|)
operator||
name|sign
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|re_assemble_3
parameter_list|(
name|int
name|as3
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|as3
operator|&
literal|4
operator|)
operator|<<
operator|(
literal|13
operator|-
literal|2
operator|)
operator|)
operator||
operator|(
operator|(
name|as3
operator|&
literal|3
operator|)
operator|<<
operator|(
literal|13
operator|+
literal|1
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|re_assemble_12
parameter_list|(
name|int
name|as12
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|as12
operator|&
literal|0x800
operator|)
operator|>>
literal|11
operator|)
operator||
operator|(
operator|(
name|as12
operator|&
literal|0x400
operator|)
operator|>>
operator|(
literal|10
operator|-
literal|2
operator|)
operator|)
operator||
operator|(
operator|(
name|as12
operator|&
literal|0x3ff
operator|)
operator|<<
operator|(
literal|1
operator|+
literal|2
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|re_assemble_14
parameter_list|(
name|int
name|as14
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|as14
operator|&
literal|0x1fff
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|as14
operator|&
literal|0x2000
operator|)
operator|>>
literal|13
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|re_assemble_16
parameter_list|(
name|int
name|as16
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|t
decl_stmt|;
comment|/* Unusual 16-bit encoding, for wide mode only.  */
name|t
operator|=
operator|(
name|as16
operator|<<
literal|1
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|s
operator|=
operator|(
name|as16
operator|&
literal|0x8000
operator|)
expr_stmt|;
return|return
operator|(
name|t
operator|^
name|s
operator|^
operator|(
name|s
operator|>>
literal|1
operator|)
operator|)
operator||
operator|(
name|s
operator|>>
literal|15
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|re_assemble_17
parameter_list|(
name|int
name|as17
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|as17
operator|&
literal|0x10000
operator|)
operator|>>
literal|16
operator|)
operator||
operator|(
operator|(
name|as17
operator|&
literal|0x0f800
operator|)
operator|<<
operator|(
literal|16
operator|-
literal|11
operator|)
operator|)
operator||
operator|(
operator|(
name|as17
operator|&
literal|0x00400
operator|)
operator|>>
operator|(
literal|10
operator|-
literal|2
operator|)
operator|)
operator||
operator|(
operator|(
name|as17
operator|&
literal|0x003ff
operator|)
operator|<<
operator|(
literal|1
operator|+
literal|2
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|re_assemble_21
parameter_list|(
name|int
name|as21
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|as21
operator|&
literal|0x100000
operator|)
operator|>>
literal|20
operator|)
operator||
operator|(
operator|(
name|as21
operator|&
literal|0x0ffe00
operator|)
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
name|as21
operator|&
literal|0x000180
operator|)
operator|<<
literal|7
operator|)
operator||
operator|(
operator|(
name|as21
operator|&
literal|0x00007c
operator|)
operator|<<
literal|14
operator|)
operator||
operator|(
operator|(
name|as21
operator|&
literal|0x000003
operator|)
operator|<<
literal|12
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|re_assemble_22
parameter_list|(
name|int
name|as22
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|as22
operator|&
literal|0x200000
operator|)
operator|>>
literal|21
operator|)
operator||
operator|(
operator|(
name|as22
operator|&
literal|0x1f0000
operator|)
operator|<<
operator|(
literal|21
operator|-
literal|16
operator|)
operator|)
operator||
operator|(
operator|(
name|as22
operator|&
literal|0x00f800
operator|)
operator|<<
operator|(
literal|16
operator|-
literal|11
operator|)
operator|)
operator||
operator|(
operator|(
name|as22
operator|&
literal|0x000400
operator|)
operator|>>
operator|(
literal|10
operator|-
literal|2
operator|)
operator|)
operator||
operator|(
operator|(
name|as22
operator|&
literal|0x0003ff
operator|)
operator|<<
operator|(
literal|1
operator|+
literal|2
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Handle field selectors for PA instructions.    The L and R (and LS, RS etc.) selectors are used in pairs to form a    full 32 bit address.  eg.     LDIL	L'start,%r1		; put left part into r1    LDW	R'start(%r1),%r2	; add r1 and right part to form address     This function returns sign extended values in all cases. */
end_comment

begin_function
specifier|static
specifier|inline
name|bfd_signed_vma
name|hppa_field_adjust
parameter_list|(
name|bfd_vma
name|sym_val
parameter_list|,
name|bfd_signed_vma
name|addend
parameter_list|,
name|enum
name|hppa_reloc_field_selector_type_alt
name|r_field
parameter_list|)
block|{
name|bfd_signed_vma
name|value
decl_stmt|;
name|value
operator|=
name|sym_val
operator|+
name|addend
expr_stmt|;
switch|switch
condition|(
name|r_field
condition|)
block|{
case|case
name|e_fsel
case|:
comment|/* F: No change.  */
break|break;
case|case
name|e_nsel
case|:
comment|/* N: null selector.  I don't really understand what this is all 	 about, but HP's documentation says "this indicates that zero 	 bits are to be used for the displacement on the instruction. 	 This fixup is used to identify three-instruction sequences to 	 access data (for importing shared library data)."  */
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|e_lsel
case|:
case|case
name|e_nlsel
case|:
comment|/* L:  Select top 21 bits.  */
name|value
operator|=
name|value
operator|>>
literal|11
expr_stmt|;
break|break;
case|case
name|e_rsel
case|:
comment|/* R:  Select bottom 11 bits.  */
name|value
operator|=
name|value
operator|&
literal|0x7ff
expr_stmt|;
break|break;
case|case
name|e_lssel
case|:
comment|/* LS:  Round to nearest multiple of 2048 then select top 21 bits.  */
name|value
operator|=
name|value
operator|+
literal|0x400
expr_stmt|;
name|value
operator|=
name|value
operator|>>
literal|11
expr_stmt|;
break|break;
case|case
name|e_rssel
case|:
comment|/* RS:  Select bottom 11 bits for LS. 	 We need to return a value such that 2048 * LS'x + RS'x == x. 	 ie. RS'x = x - ((x + 0x400)& -0x800) 	 this is just a sign extension from bit 21.  */
name|value
operator|=
operator|(
operator|(
name|value
operator|&
literal|0x7ff
operator|)
operator|^
literal|0x400
operator|)
operator|-
literal|0x400
expr_stmt|;
break|break;
case|case
name|e_ldsel
case|:
comment|/* LD:  Round to next multiple of 2048 then select top 21 bits. 	 Yes, if we are already on a multiple of 2048, we go up to the 	 next one.  RD in this case will be -2048.  */
name|value
operator|=
name|value
operator|+
literal|0x800
expr_stmt|;
name|value
operator|=
name|value
operator|>>
literal|11
expr_stmt|;
break|break;
case|case
name|e_rdsel
case|:
comment|/* RD:  Set bits 0-20 to one.  */
name|value
operator|=
name|value
operator||
operator|-
literal|0x800
expr_stmt|;
break|break;
case|case
name|e_lrsel
case|:
case|case
name|e_nlrsel
case|:
comment|/* LR:  L with rounding of the addend to nearest 8k.  */
name|value
operator|=
name|sym_val
operator|+
operator|(
operator|(
name|addend
operator|+
literal|0x1000
operator|)
operator|&
operator|-
literal|0x2000
operator|)
expr_stmt|;
name|value
operator|=
name|value
operator|>>
literal|11
expr_stmt|;
break|break;
case|case
name|e_rrsel
case|:
comment|/* RR:  R with rounding of the addend to nearest 8k. 	 We need to return a value such that 2048 * LR'x + RR'x == x 	 ie. RR'x = s+a - (s + (((a + 0x1000)& -0x2000)& -0x800)) 	 .	  = s+a - ((s& -0x800) + ((a + 0x1000)& -0x2000)) 	 .	  = (s& 0x7ff) + a - ((a + 0x1000)& -0x2000)  */
name|value
operator|=
operator|(
name|sym_val
operator|&
literal|0x7ff
operator|)
operator|+
operator|(
operator|(
operator|(
name|addend
operator|&
literal|0x1fff
operator|)
operator|^
literal|0x1000
operator|)
operator|-
literal|0x1000
operator|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* PA-RISC OPCODES */
end_comment

begin_define
define|#
directive|define
name|get_opcode
parameter_list|(
name|insn
parameter_list|)
value|(((insn)>> 26)& 0x3f)
end_define

begin_enum
enum|enum
name|hppa_opcode_type
block|{
comment|/* None of the opcodes in the first group generate relocs, so we      aren't too concerned about them.  */
name|OP_SYSOP
init|=
literal|0x00
block|,
name|OP_MEMMNG
init|=
literal|0x01
block|,
name|OP_ALU
init|=
literal|0x02
block|,
name|OP_NDXMEM
init|=
literal|0x03
block|,
name|OP_SPOP
init|=
literal|0x04
block|,
name|OP_DIAG
init|=
literal|0x05
block|,
name|OP_FMPYADD
init|=
literal|0x06
block|,
name|OP_UNDEF07
init|=
literal|0x07
block|,
name|OP_COPRW
init|=
literal|0x09
block|,
name|OP_COPRDW
init|=
literal|0x0b
block|,
name|OP_COPR
init|=
literal|0x0c
block|,
name|OP_FLOAT
init|=
literal|0x0e
block|,
name|OP_PRDSPEC
init|=
literal|0x0f
block|,
name|OP_UNDEF15
init|=
literal|0x15
block|,
name|OP_UNDEF1d
init|=
literal|0x1d
block|,
name|OP_FMPYSUB
init|=
literal|0x26
block|,
name|OP_FPFUSED
init|=
literal|0x2e
block|,
name|OP_SHEXDP0
init|=
literal|0x34
block|,
name|OP_SHEXDP1
init|=
literal|0x35
block|,
name|OP_SHEXDP2
init|=
literal|0x36
block|,
name|OP_UNDEF37
init|=
literal|0x37
block|,
name|OP_SHEXDP3
init|=
literal|0x3c
block|,
name|OP_SHEXDP4
init|=
literal|0x3d
block|,
name|OP_MULTMED
init|=
literal|0x3e
block|,
name|OP_UNDEF3f
init|=
literal|0x3f
block|,
name|OP_LDIL
init|=
literal|0x08
block|,
name|OP_ADDIL
init|=
literal|0x0a
block|,
name|OP_LDO
init|=
literal|0x0d
block|,
name|OP_LDB
init|=
literal|0x10
block|,
name|OP_LDH
init|=
literal|0x11
block|,
name|OP_LDW
init|=
literal|0x12
block|,
name|OP_LDWM
init|=
literal|0x13
block|,
name|OP_STB
init|=
literal|0x18
block|,
name|OP_STH
init|=
literal|0x19
block|,
name|OP_STW
init|=
literal|0x1a
block|,
name|OP_STWM
init|=
literal|0x1b
block|,
name|OP_LDD
init|=
literal|0x14
block|,
name|OP_STD
init|=
literal|0x1c
block|,
name|OP_FLDW
init|=
literal|0x16
block|,
name|OP_LDWL
init|=
literal|0x17
block|,
name|OP_FSTW
init|=
literal|0x1e
block|,
name|OP_STWL
init|=
literal|0x1f
block|,
name|OP_COMBT
init|=
literal|0x20
block|,
name|OP_COMIBT
init|=
literal|0x21
block|,
name|OP_COMBF
init|=
literal|0x22
block|,
name|OP_COMIBF
init|=
literal|0x23
block|,
name|OP_CMPBDT
init|=
literal|0x27
block|,
name|OP_ADDBT
init|=
literal|0x28
block|,
name|OP_ADDIBT
init|=
literal|0x29
block|,
name|OP_ADDBF
init|=
literal|0x2a
block|,
name|OP_ADDIBF
init|=
literal|0x2b
block|,
name|OP_CMPBDF
init|=
literal|0x2f
block|,
name|OP_BVB
init|=
literal|0x30
block|,
name|OP_BB
init|=
literal|0x31
block|,
name|OP_MOVB
init|=
literal|0x32
block|,
name|OP_MOVIB
init|=
literal|0x33
block|,
name|OP_CMPIBD
init|=
literal|0x3b
block|,
name|OP_COMICLR
init|=
literal|0x24
block|,
name|OP_SUBI
init|=
literal|0x25
block|,
name|OP_ADDIT
init|=
literal|0x2c
block|,
name|OP_ADDI
init|=
literal|0x2d
block|,
name|OP_BE
init|=
literal|0x38
block|,
name|OP_BLE
init|=
literal|0x39
block|,
name|OP_BL
init|=
literal|0x3a
block|}
enum|;
end_enum

begin_comment
comment|/* Given a machine instruction, return its format.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|bfd_hppa_insn2fmt
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|insn
parameter_list|)
block|{
name|enum
name|hppa_opcode_type
name|op
init|=
name|get_opcode
argument_list|(
name|insn
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_COMICLR
case|:
case|case
name|OP_SUBI
case|:
case|case
name|OP_ADDIT
case|:
case|case
name|OP_ADDI
case|:
return|return
literal|11
return|;
case|case
name|OP_COMBT
case|:
case|case
name|OP_COMIBT
case|:
case|case
name|OP_COMBF
case|:
case|case
name|OP_COMIBF
case|:
case|case
name|OP_CMPBDT
case|:
case|case
name|OP_ADDBT
case|:
case|case
name|OP_ADDIBT
case|:
case|case
name|OP_ADDBF
case|:
case|case
name|OP_ADDIBF
case|:
case|case
name|OP_CMPBDF
case|:
case|case
name|OP_BVB
case|:
case|case
name|OP_BB
case|:
case|case
name|OP_MOVB
case|:
case|case
name|OP_MOVIB
case|:
case|case
name|OP_CMPIBD
case|:
return|return
literal|12
return|;
case|case
name|OP_LDO
case|:
case|case
name|OP_LDB
case|:
case|case
name|OP_LDH
case|:
case|case
name|OP_LDW
case|:
case|case
name|OP_LDWM
case|:
case|case
name|OP_STB
case|:
case|case
name|OP_STH
case|:
case|case
name|OP_STW
case|:
case|case
name|OP_STWM
case|:
if|if
condition|(
name|abfd
operator|->
name|arch_info
operator|->
name|mach
operator|>=
literal|25
condition|)
return|return
literal|16
return|;
comment|/* Wide mode, format 16.  */
return|return
literal|14
return|;
case|case
name|OP_FLDW
case|:
case|case
name|OP_LDWL
case|:
case|case
name|OP_FSTW
case|:
case|case
name|OP_STWL
case|:
comment|/* This is a hack.  Unfortunately, format 11 is already taken 	 and we're using integers rather than an enum, so it's hard 	 to describe the 11a format.  */
if|if
condition|(
name|abfd
operator|->
name|arch_info
operator|->
name|mach
operator|>=
literal|25
condition|)
return|return
operator|-
literal|16
return|;
comment|/* Wide mode, format 16a.  */
return|return
operator|-
literal|11
return|;
case|case
name|OP_LDD
case|:
case|case
name|OP_STD
case|:
if|if
condition|(
name|abfd
operator|->
name|arch_info
operator|->
name|mach
operator|>=
literal|25
condition|)
return|return
operator|-
literal|10
return|;
comment|/* Wide mode, format 10a.  */
return|return
literal|10
return|;
case|case
name|OP_BL
case|:
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
condition|)
return|return
literal|22
return|;
comment|/* fall thru */
case|case
name|OP_BE
case|:
case|case
name|OP_BLE
case|:
return|return
literal|17
return|;
case|case
name|OP_LDIL
case|:
case|case
name|OP_ADDIL
case|:
return|return
literal|21
return|;
default|default:
break|break;
block|}
return|return
literal|32
return|;
block|}
end_function

begin_comment
comment|/* Insert VALUE into INSN using R_FORMAT to determine exactly what    bits to change.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|hppa_rebuild_insn
parameter_list|(
name|int
name|insn
parameter_list|,
name|int
name|value
parameter_list|,
name|int
name|r_format
parameter_list|)
block|{
switch|switch
condition|(
name|r_format
condition|)
block|{
case|case
literal|11
case|:
return|return
operator|(
name|insn
operator|&
operator|~
literal|0x7ff
operator|)
operator||
name|low_sign_unext
argument_list|(
name|value
argument_list|,
literal|11
argument_list|)
return|;
case|case
literal|12
case|:
return|return
operator|(
name|insn
operator|&
operator|~
literal|0x1ffd
operator|)
operator||
name|re_assemble_12
argument_list|(
name|value
argument_list|)
return|;
case|case
literal|10
case|:
return|return
operator|(
name|insn
operator|&
operator|~
literal|0x3ff1
operator|)
operator||
name|re_assemble_14
argument_list|(
name|value
operator|&
operator|-
literal|8
argument_list|)
return|;
case|case
operator|-
literal|11
case|:
return|return
operator|(
name|insn
operator|&
operator|~
literal|0x3ff9
operator|)
operator||
name|re_assemble_14
argument_list|(
name|value
operator|&
operator|-
literal|4
argument_list|)
return|;
case|case
literal|14
case|:
return|return
operator|(
name|insn
operator|&
operator|~
literal|0x3fff
operator|)
operator||
name|re_assemble_14
argument_list|(
name|value
argument_list|)
return|;
case|case
operator|-
literal|10
case|:
return|return
operator|(
name|insn
operator|&
operator|~
literal|0xfff1
operator|)
operator||
name|re_assemble_16
argument_list|(
name|value
operator|&
operator|-
literal|8
argument_list|)
return|;
case|case
operator|-
literal|16
case|:
return|return
operator|(
name|insn
operator|&
operator|~
literal|0xfff9
operator|)
operator||
name|re_assemble_16
argument_list|(
name|value
operator|&
operator|-
literal|4
argument_list|)
return|;
case|case
literal|16
case|:
return|return
operator|(
name|insn
operator|&
operator|~
literal|0xffff
operator|)
operator||
name|re_assemble_16
argument_list|(
name|value
argument_list|)
return|;
case|case
literal|17
case|:
return|return
operator|(
name|insn
operator|&
operator|~
literal|0x1f1ffd
operator|)
operator||
name|re_assemble_17
argument_list|(
name|value
argument_list|)
return|;
case|case
literal|21
case|:
return|return
operator|(
name|insn
operator|&
operator|~
literal|0x1fffff
operator|)
operator||
name|re_assemble_21
argument_list|(
name|value
argument_list|)
return|;
case|case
literal|22
case|:
return|return
operator|(
name|insn
operator|&
operator|~
literal|0x3ff1ffd
operator|)
operator||
name|re_assemble_22
argument_list|(
name|value
argument_list|)
return|;
case|case
literal|32
case|:
return|return
name|value
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _LIBHPPA_H */
end_comment

end_unit

