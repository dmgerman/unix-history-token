begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* vms-gsd.c -- BFD back-end for VAX (openVMS/VAX) and    EVAX (openVMS/Alpha) files.    Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.     go and read the openVMS linker manual (esp. appendix B)    if you don't know what's going on here :-)     Written by Klaus K"ampf (kkaempf@rmi.de)  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"vms.h"
end_include

begin_comment
comment|/*-----------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* typical sections for vax object files  */
end_comment

begin_define
define|#
directive|define
name|VAX_CODE_NAME
value|"$CODE"
end_define

begin_define
define|#
directive|define
name|VAX_DATA_NAME
value|"$DATA"
end_define

begin_define
define|#
directive|define
name|VAX_ADDRESS_DATA_NAME
value|"$ADDRESS_DATA"
end_define

begin_comment
comment|/* typical sections for evax object files  */
end_comment

begin_define
define|#
directive|define
name|EVAX_ABS_NAME
value|"$ABS$"
end_define

begin_define
define|#
directive|define
name|EVAX_CODE_NAME
value|"$CODE$"
end_define

begin_define
define|#
directive|define
name|EVAX_LINK_NAME
value|"$LINK$"
end_define

begin_define
define|#
directive|define
name|EVAX_DATA_NAME
value|"$DATA$"
end_define

begin_define
define|#
directive|define
name|EVAX_BSS_NAME
value|"$BSS$"
end_define

begin_define
define|#
directive|define
name|EVAX_READONLYADDR_NAME
value|"$READONLY_ADDR$"
end_define

begin_define
define|#
directive|define
name|EVAX_READONLY_NAME
value|"$READONLY$"
end_define

begin_define
define|#
directive|define
name|EVAX_LITERAL_NAME
value|"$LITERAL$"
end_define

begin_define
define|#
directive|define
name|EVAX_COMMON_NAME
value|"$COMMON$"
end_define

begin_define
define|#
directive|define
name|EVAX_LOCAL_NAME
value|"$LOCAL$"
end_define

begin_struct
struct|struct
name|sec_flags_struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of section */
name|int
name|vflags_always
decl_stmt|;
name|flagword
name|flags_always
decl_stmt|;
comment|/* flags we set always */
name|int
name|vflags_hassize
decl_stmt|;
name|flagword
name|flags_hassize
decl_stmt|;
comment|/* flags we set if the section has a size> 0 */
block|}
struct|;
end_struct

begin_comment
comment|/* These flags are deccrtl/vaxcrtl (openVMS 6.2 VAX) compatible  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sec_flags_struct
name|vax_section_flags
index|[]
init|=
block|{
block|{
name|VAX_CODE_NAME
block|,
operator|(
name|GPS_S_M_PIC
operator||
name|GPS_S_M_REL
operator||
name|GPS_S_M_SHR
operator||
name|GPS_S_M_EXE
operator||
name|GPS_S_M_RD
operator|)
block|,
operator|(
name|SEC_CODE
operator|)
block|,
operator|(
name|GPS_S_M_PIC
operator||
name|GPS_S_M_REL
operator||
name|GPS_S_M_SHR
operator||
name|GPS_S_M_EXE
operator||
name|GPS_S_M_RD
operator|)
block|,
operator|(
name|SEC_IN_MEMORY
operator||
name|SEC_CODE
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
block|}
block|,
block|{
name|VAX_DATA_NAME
block|,
operator|(
name|GPS_S_M_PIC
operator||
name|GPS_S_M_REL
operator||
name|GPS_S_M_RD
operator||
name|GPS_S_M_WRT
operator|)
block|,
operator|(
name|SEC_DATA
operator|)
block|,
operator|(
name|GPS_S_M_PIC
operator||
name|GPS_S_M_REL
operator||
name|GPS_S_M_RD
operator||
name|GPS_S_M_WRT
operator|)
block|,
operator|(
name|SEC_IN_MEMORY
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
block|}
block|,
block|{
name|VAX_ADDRESS_DATA_NAME
block|,
operator|(
name|GPS_S_M_PIC
operator||
name|GPS_S_M_REL
operator||
name|GPS_S_M_RD
operator|)
block|,
operator|(
name|SEC_DATA
operator||
name|SEC_READONLY
operator|)
block|,
operator|(
name|GPS_S_M_PIC
operator||
name|GPS_S_M_REL
operator||
name|GPS_S_M_RD
operator|)
block|,
operator|(
name|SEC_IN_MEMORY
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_READONLY
operator||
name|SEC_LOAD
operator|)
block|}
block|,
block|{
name|NULL
block|,
operator|(
name|GPS_S_M_PIC
operator||
name|GPS_S_M_OVR
operator||
name|GPS_S_M_REL
operator||
name|GPS_S_M_GBL
operator||
name|GPS_S_M_RD
operator||
name|GPS_S_M_WRT
operator|)
block|,
operator|(
name|SEC_DATA
operator|)
block|,
operator|(
name|GPS_S_M_PIC
operator||
name|GPS_S_M_OVR
operator||
name|GPS_S_M_REL
operator||
name|GPS_S_M_GBL
operator||
name|GPS_S_M_RD
operator||
name|GPS_S_M_WRT
operator|)
block|,
operator|(
name|SEC_IN_MEMORY
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These flags are deccrtl/vaxcrtl (openVMS 6.2 Alpha) compatible  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sec_flags_struct
name|evax_section_flags
index|[]
init|=
block|{
block|{
name|EVAX_ABS_NAME
block|,
operator|(
name|EGPS_S_V_SHR
operator|)
block|,
operator|(
name|SEC_DATA
operator|)
block|,
operator|(
name|EGPS_S_V_SHR
operator|)
block|,
operator|(
name|SEC_IN_MEMORY
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
block|}
block|,
block|{
name|EVAX_CODE_NAME
block|,
operator|(
name|EGPS_S_V_PIC
operator||
name|EGPS_S_V_REL
operator||
name|EGPS_S_V_SHR
operator||
name|EGPS_S_V_EXE
operator|)
block|,
operator|(
name|SEC_CODE
operator|)
block|,
operator|(
name|EGPS_S_V_PIC
operator||
name|EGPS_S_V_REL
operator||
name|EGPS_S_V_SHR
operator||
name|EGPS_S_V_EXE
operator|)
block|,
operator|(
name|SEC_IN_MEMORY
operator||
name|SEC_CODE
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
block|}
block|,
block|{
name|EVAX_LITERAL_NAME
block|,
operator|(
name|EGPS_S_V_PIC
operator||
name|EGPS_S_V_REL
operator||
name|EGPS_S_V_SHR
operator||
name|EGPS_S_V_RD
operator||
name|EGPS_S_V_NOMOD
operator|)
block|,
operator|(
name|SEC_DATA
operator||
name|SEC_READONLY
operator|)
block|,
operator|(
name|EGPS_S_V_PIC
operator||
name|EGPS_S_V_REL
operator||
name|EGPS_S_V_SHR
operator||
name|EGPS_S_V_RD
operator|)
block|,
operator|(
name|SEC_IN_MEMORY
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_READONLY
operator||
name|SEC_LOAD
operator|)
block|}
block|,
block|{
name|EVAX_LINK_NAME
block|,
operator|(
name|EGPS_S_V_REL
operator||
name|EGPS_S_V_RD
operator|)
block|,
operator|(
name|SEC_DATA
operator||
name|SEC_READONLY
operator|)
block|,
operator|(
name|EGPS_S_V_REL
operator||
name|EGPS_S_V_RD
operator|)
block|,
operator|(
name|SEC_IN_MEMORY
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_READONLY
operator||
name|SEC_LOAD
operator|)
block|}
block|,
block|{
name|EVAX_DATA_NAME
block|,
operator|(
name|EGPS_S_V_REL
operator||
name|EGPS_S_V_RD
operator||
name|EGPS_S_V_WRT
operator||
name|EGPS_S_V_NOMOD
operator|)
block|,
operator|(
name|SEC_DATA
operator|)
block|,
operator|(
name|EGPS_S_V_REL
operator||
name|EGPS_S_V_RD
operator||
name|EGPS_S_V_WRT
operator|)
block|,
operator|(
name|SEC_IN_MEMORY
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
block|}
block|,
block|{
name|EVAX_BSS_NAME
block|,
operator|(
name|EGPS_S_V_REL
operator||
name|EGPS_S_V_RD
operator||
name|EGPS_S_V_WRT
operator||
name|EGPS_S_V_NOMOD
operator|)
block|,
operator|(
name|SEC_NO_FLAGS
operator|)
block|,
operator|(
name|EGPS_S_V_REL
operator||
name|EGPS_S_V_RD
operator||
name|EGPS_S_V_WRT
operator||
name|EGPS_S_V_NOMOD
operator|)
block|,
operator|(
name|SEC_IN_MEMORY
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
block|}
block|,
block|{
name|EVAX_READONLYADDR_NAME
block|,
operator|(
name|EGPS_S_V_PIC
operator||
name|EGPS_S_V_REL
operator||
name|EGPS_S_V_RD
operator|)
block|,
operator|(
name|SEC_DATA
operator||
name|SEC_READONLY
operator|)
block|,
operator|(
name|EGPS_S_V_PIC
operator||
name|EGPS_S_V_REL
operator||
name|EGPS_S_V_RD
operator|)
block|,
operator|(
name|SEC_IN_MEMORY
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_READONLY
operator||
name|SEC_LOAD
operator|)
block|}
block|,
block|{
name|EVAX_READONLY_NAME
block|,
operator|(
name|EGPS_S_V_PIC
operator||
name|EGPS_S_V_REL
operator||
name|EGPS_S_V_SHR
operator||
name|EGPS_S_V_RD
operator||
name|EGPS_S_V_NOMOD
operator|)
block|,
operator|(
name|SEC_DATA
operator||
name|SEC_READONLY
operator|)
block|,
operator|(
name|EGPS_S_V_PIC
operator||
name|EGPS_S_V_REL
operator||
name|EGPS_S_V_SHR
operator||
name|EGPS_S_V_RD
operator|)
block|,
operator|(
name|SEC_IN_MEMORY
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_READONLY
operator||
name|SEC_LOAD
operator|)
block|}
block|,
block|{
name|EVAX_LOCAL_NAME
block|,
operator|(
name|EGPS_S_V_REL
operator||
name|EGPS_S_V_RD
operator||
name|EGPS_S_V_WRT
operator|)
block|,
operator|(
name|SEC_DATA
operator|)
block|,
operator|(
name|EGPS_S_V_REL
operator||
name|EGPS_S_V_RD
operator||
name|EGPS_S_V_WRT
operator|)
block|,
operator|(
name|SEC_IN_MEMORY
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
block|}
block|,
block|{
name|NULL
block|,
operator|(
name|EGPS_S_V_REL
operator||
name|EGPS_S_V_RD
operator||
name|EGPS_S_V_WRT
operator|)
block|,
operator|(
name|SEC_DATA
operator|)
block|,
operator|(
name|EGPS_S_V_REL
operator||
name|EGPS_S_V_RD
operator||
name|EGPS_S_V_WRT
operator|)
block|,
operator|(
name|SEC_IN_MEMORY
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flagword
name|vms_secflag_by_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|sec_flags_struct
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flagword
name|vms_esecflag_by_name
name|PARAMS
argument_list|(
operator|(
expr|struct
name|sec_flags_struct
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Retrieve bfd section flags by name and size  */
end_comment

begin_function
specifier|static
name|flagword
name|vms_secflag_by_name
parameter_list|(
name|abfd
parameter_list|,
name|section_flags
parameter_list|,
name|name
parameter_list|,
name|hassize
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|sec_flags_struct
modifier|*
name|section_flags
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|hassize
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|section_flags
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|PRIV
argument_list|(
name|is_vax
argument_list|)
condition|?
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|section_flags
index|[
name|i
index|]
operator|.
name|name
argument_list|)
else|:
name|strcmp
argument_list|(
name|name
argument_list|,
name|section_flags
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|hassize
condition|)
return|return
name|section_flags
index|[
name|i
index|]
operator|.
name|flags_hassize
return|;
else|else
return|return
name|section_flags
index|[
name|i
index|]
operator|.
name|flags_always
return|;
block|}
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|hassize
condition|)
return|return
name|section_flags
index|[
name|i
index|]
operator|.
name|flags_hassize
return|;
return|return
name|section_flags
index|[
name|i
index|]
operator|.
name|flags_always
return|;
block|}
end_function

begin_comment
comment|/* Retrieve vms section flags by name and size  */
end_comment

begin_function
specifier|static
name|flagword
name|vms_esecflag_by_name
parameter_list|(
name|section_flags
parameter_list|,
name|name
parameter_list|,
name|hassize
parameter_list|)
name|struct
name|sec_flags_struct
modifier|*
name|section_flags
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|hassize
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|section_flags
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|section_flags
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|hassize
condition|)
return|return
name|section_flags
index|[
name|i
index|]
operator|.
name|vflags_hassize
return|;
else|else
return|return
name|section_flags
index|[
name|i
index|]
operator|.
name|vflags_always
return|;
block|}
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|hassize
condition|)
return|return
name|section_flags
index|[
name|i
index|]
operator|.
name|vflags_hassize
return|;
return|return
name|section_flags
index|[
name|i
index|]
operator|.
name|vflags_always
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
name|VMS_DEBUG
end_if

begin_comment
comment|/* debug */
end_comment

begin_struct
struct|struct
name|flagdescstruct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|flagword
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Convert flag to printable string  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|flag2str
parameter_list|(
name|flagdesc
parameter_list|,
name|flags
parameter_list|)
name|struct
name|flagdescstruct
modifier|*
name|flagdesc
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
block|{
specifier|static
name|char
name|res
index|[
literal|64
index|]
decl_stmt|;
name|int
name|next
init|=
literal|0
decl_stmt|;
name|res
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|flagdesc
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|flagdesc
operator|->
name|value
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|next
condition|)
name|strcat
argument_list|(
name|res
argument_list|,
literal|","
argument_list|)
expr_stmt|;
else|else
name|next
operator|=
literal|1
expr_stmt|;
name|strcat
argument_list|(
name|res
argument_list|,
name|flagdesc
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|flagdesc
operator|++
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-----------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* input routines */
end_comment

begin_comment
comment|/* Process GSD/EGSD record    return 0 on success, -1 on error  */
end_comment

begin_function
name|int
name|_bfd_vms_slurp_gsd
parameter_list|(
name|abfd
parameter_list|,
name|objtype
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|objtype
decl_stmt|;
block|{
if|#
directive|if
name|VMS_DEBUG
specifier|static
name|struct
name|flagdescstruct
name|gpsflagdesc
index|[]
init|=
block|{
block|{
literal|"PIC"
block|,
literal|0x0001
block|}
block|,
block|{
literal|"LIB"
block|,
literal|0x0002
block|}
block|,
block|{
literal|"OVR"
block|,
literal|0x0004
block|}
block|,
block|{
literal|"REL"
block|,
literal|0x0008
block|}
block|,
block|{
literal|"GBL"
block|,
literal|0x0010
block|}
block|,
block|{
literal|"SHR"
block|,
literal|0x0020
block|}
block|,
block|{
literal|"EXE"
block|,
literal|0x0040
block|}
block|,
block|{
literal|"RD"
block|,
literal|0x0080
block|}
block|,
block|{
literal|"WRT"
block|,
literal|0x0100
block|}
block|,
block|{
literal|"VEC"
block|,
literal|0x0200
block|}
block|,
block|{
literal|"NOMOD"
block|,
literal|0x0400
block|}
block|,
block|{
literal|"COM"
block|,
literal|0x0800
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|struct
name|flagdescstruct
name|gsyflagdesc
index|[]
init|=
block|{
block|{
literal|"WEAK"
block|,
literal|0x0001
block|}
block|,
block|{
literal|"DEF"
block|,
literal|0x0002
block|}
block|,
block|{
literal|"UNI"
block|,
literal|0x0004
block|}
block|,
block|{
literal|"REL"
block|,
literal|0x0008
block|}
block|,
block|{
literal|"COMM"
block|,
literal|0x0010
block|}
block|,
block|{
literal|"VECEP"
block|,
literal|0x0020
block|}
block|,
block|{
literal|"NORM"
block|,
literal|0x0040
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
endif|#
directive|endif
name|int
name|gsd_type
decl_stmt|,
name|gsd_size
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|unsigned
name|char
modifier|*
name|vms_rec
decl_stmt|;
name|flagword
name|new_flags
decl_stmt|,
name|old_flags
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|vms_symbol_entry
modifier|*
name|entry
decl_stmt|;
name|unsigned
name|long
name|base_addr
decl_stmt|;
name|unsigned
name|long
name|align_addr
decl_stmt|;
specifier|static
name|unsigned
name|int
name|psect_idx
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|2
argument_list|,
literal|"GSD/EGSD (%d/%x)\n"
argument_list|,
name|objtype
argument_list|,
name|objtype
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|objtype
condition|)
block|{
case|case
name|EOBJ_S_C_EGSD
case|:
name|PRIV
argument_list|(
name|vms_rec
argument_list|)
operator|+=
literal|8
expr_stmt|;
comment|/* skip type, size, l_temp */
name|PRIV
argument_list|(
name|rec_size
argument_list|)
operator|-=
literal|8
expr_stmt|;
break|break;
case|case
name|OBJ_S_C_GSD
case|:
name|PRIV
argument_list|(
name|vms_rec
argument_list|)
operator|+=
literal|1
expr_stmt|;
name|PRIV
argument_list|(
name|rec_size
argument_list|)
operator|-=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
comment|/* calculate base address for each section  */
name|base_addr
operator|=
literal|0L
expr_stmt|;
name|abfd
operator|->
name|symcount
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|PRIV
argument_list|(
name|rec_size
argument_list|)
operator|>
literal|0
condition|)
block|{
name|vms_rec
operator|=
name|PRIV
argument_list|(
name|vms_rec
argument_list|)
expr_stmt|;
if|if
condition|(
name|objtype
operator|==
name|OBJ_S_C_GSD
condition|)
block|{
name|gsd_type
operator|=
operator|*
name|vms_rec
expr_stmt|;
block|}
else|else
block|{
name|_bfd_vms_get_header_values
argument_list|(
name|abfd
argument_list|,
name|vms_rec
argument_list|,
operator|&
name|gsd_type
argument_list|,
operator|&
name|gsd_size
argument_list|)
expr_stmt|;
name|gsd_type
operator|+=
name|EVAX_OFFSET
expr_stmt|;
block|}
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|3
argument_list|,
literal|"gsd_type %d\n"
argument_list|,
name|gsd_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|gsd_type
condition|)
block|{
case|case
name|GSD_S_C_PSC
case|:
block|{
comment|/* 	       * program section definition 	       */
name|asection
modifier|*
name|old_section
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|4
argument_list|,
literal|"GSD_S_C_PSC\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If this section isn't a bfd section.  */
if|if
condition|(
name|PRIV
argument_list|(
name|is_vax
argument_list|)
operator|&&
operator|(
name|psect_idx
operator|<
operator|(
name|abfd
operator|->
name|section_count
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* check for temporary section from TIR record.  */
if|if
condition|(
name|psect_idx
operator|<
name|PRIV
argument_list|(
name|section_count
argument_list|)
condition|)
name|old_section
operator|=
name|PRIV
argument_list|(
name|sections
argument_list|)
index|[
name|psect_idx
index|]
expr_stmt|;
else|else
name|old_section
operator|=
literal|0
expr_stmt|;
block|}
name|name
operator|=
name|_bfd_vms_save_counted_string
argument_list|(
name|vms_rec
operator|+
literal|8
argument_list|)
expr_stmt|;
name|section
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|section
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"bfd_make_section (%s) failed"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|old_flags
operator|=
name|bfd_getl16
argument_list|(
name|vms_rec
operator|+
literal|2
argument_list|)
expr_stmt|;
name|section
operator|->
name|_raw_size
operator|=
name|bfd_getl32
argument_list|(
name|vms_rec
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* allocation */
name|new_flags
operator|=
name|vms_secflag_by_name
argument_list|(
name|abfd
argument_list|,
name|vax_section_flags
argument_list|,
name|name
argument_list|,
name|section
operator|->
name|_raw_size
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_flags
operator|&
name|EGPS_S_V_REL
condition|)
name|new_flags
operator||=
name|SEC_RELOC
expr_stmt|;
if|if
condition|(
name|old_flags
operator|&
name|GPS_S_M_OVR
condition|)
name|new_flags
operator||=
name|SEC_IS_COMMON
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|new_flags
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"bfd_set_section_flags (%s, %x) failed"
argument_list|)
argument_list|,
name|name
argument_list|,
name|new_flags
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|section
operator|->
name|alignment_power
operator|=
name|vms_rec
index|[
literal|1
index|]
expr_stmt|;
name|align_addr
operator|=
operator|(
literal|1
operator|<<
name|section
operator|->
name|alignment_power
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|base_addr
operator|%
name|align_addr
operator|)
operator|!=
literal|0
condition|)
name|base_addr
operator|+=
operator|(
name|align_addr
operator|-
operator|(
name|base_addr
operator|%
name|align_addr
operator|)
operator|)
expr_stmt|;
name|section
operator|->
name|vma
operator|=
operator|(
name|bfd_vma
operator|)
name|base_addr
expr_stmt|;
name|base_addr
operator|+=
name|section
operator|->
name|_raw_size
expr_stmt|;
comment|/* global section is common symbol  */
if|if
condition|(
name|old_flags
operator|&
name|GPS_S_M_GBL
condition|)
block|{
name|entry
operator|=
name|_bfd_vms_enter_symbol
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
operator|(
name|vms_symbol_entry
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|symbol
operator|=
name|entry
operator|->
name|symbol
expr_stmt|;
name|symbol
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|symbol
operator|->
name|section
operator|=
name|section
expr_stmt|;
name|symbol
operator|->
name|flags
operator|=
operator|(
name|BSF_GLOBAL
operator||
name|BSF_SECTION_SYM
operator||
name|BSF_OLD_COMMON
operator|)
expr_stmt|;
block|}
comment|/* copy saved contents if old_section set  */
if|if
condition|(
name|old_section
operator|!=
literal|0
condition|)
block|{
name|section
operator|->
name|contents
operator|=
name|old_section
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|_raw_size
operator|<
name|old_section
operator|->
name|_raw_size
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Size mismatch section %s=%lx, %s=%lx"
argument_list|)
argument_list|,
name|old_section
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|old_section
operator|->
name|_raw_size
argument_list|,
name|section
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|section
operator|->
name|_raw_size
operator|>
name|old_section
operator|->
name|_raw_size
condition|)
block|{
name|section
operator|->
name|contents
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bfd_realloc
argument_list|(
name|old_section
operator|->
name|contents
argument_list|,
name|section
operator|->
name|_raw_size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|contents
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
else|else
block|{
name|section
operator|->
name|contents
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|section
operator|->
name|_raw_size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|contents
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|section
operator|->
name|_cooked_size
operator|=
name|section
operator|->
name|_raw_size
expr_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|4
argument_list|,
literal|"gsd psc %d (%s, flags %04x=%s) "
argument_list|,
name|section
operator|->
name|index
argument_list|,
name|name
argument_list|,
name|old_flags
argument_list|,
name|flag2str
argument_list|(
name|gpsflagdesc
argument_list|,
name|old_flags
argument_list|)
argument_list|)
expr_stmt|;
name|vms_debug
argument_list|(
literal|4
argument_list|,
literal|"%d bytes at 0x%08lx (mem %p)\n"
argument_list|,
name|section
operator|->
name|_raw_size
argument_list|,
name|section
operator|->
name|vma
argument_list|,
name|section
operator|->
name|contents
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|gsd_size
operator|=
name|vms_rec
index|[
literal|8
index|]
operator|+
literal|9
expr_stmt|;
name|psect_idx
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|GSD_S_C_EPM
case|:
case|case
name|GSD_S_C_EPMW
case|:
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|4
argument_list|,
literal|"gsd epm\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*FALLTHRU*/
case|case
name|GSD_S_C_SYM
case|:
case|case
name|GSD_S_C_SYMW
case|:
block|{
name|int
name|name_offset
init|=
literal|0
decl_stmt|,
name|value_offset
init|=
literal|0
decl_stmt|;
comment|/* 	       * symbol specification (definition or reference) 	       */
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|4
argument_list|,
literal|"GSD_S_C_SYM(W)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|old_flags
operator|=
name|bfd_getl16
argument_list|(
name|vms_rec
operator|+
literal|2
argument_list|)
expr_stmt|;
name|new_flags
operator|=
name|BSF_NO_FLAGS
expr_stmt|;
if|if
condition|(
name|old_flags
operator|&
name|GSY_S_M_WEAK
condition|)
name|new_flags
operator||=
name|BSF_WEAK
expr_stmt|;
switch|switch
condition|(
name|gsd_type
condition|)
block|{
case|case
name|GSD_S_C_EPM
case|:
name|name_offset
operator|=
literal|11
expr_stmt|;
name|value_offset
operator|=
literal|5
expr_stmt|;
name|new_flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
break|break;
case|case
name|GSD_S_C_EPMW
case|:
name|name_offset
operator|=
literal|12
expr_stmt|;
name|value_offset
operator|=
literal|6
expr_stmt|;
name|new_flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
break|break;
case|case
name|GSD_S_C_SYM
case|:
if|if
condition|(
name|old_flags
operator|&
name|GSY_S_M_DEF
condition|)
comment|/* symbol definition */
name|name_offset
operator|=
literal|9
expr_stmt|;
else|else
name|name_offset
operator|=
literal|4
expr_stmt|;
name|value_offset
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|GSD_S_C_SYMW
case|:
if|if
condition|(
name|old_flags
operator|&
name|GSY_S_M_DEF
condition|)
comment|/* symbol definition */
name|name_offset
operator|=
literal|10
expr_stmt|;
else|else
name|name_offset
operator|=
literal|5
expr_stmt|;
name|value_offset
operator|=
literal|6
expr_stmt|;
break|break;
block|}
comment|/* save symbol in vms_symbol_table */
name|entry
operator|=
name|_bfd_vms_enter_symbol
argument_list|(
name|abfd
argument_list|,
name|_bfd_vms_save_counted_string
argument_list|(
name|vms_rec
operator|+
name|name_offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
operator|(
name|vms_symbol_entry
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|symbol
operator|=
name|entry
operator|->
name|symbol
expr_stmt|;
if|if
condition|(
name|old_flags
operator|&
name|GSY_S_M_DEF
condition|)
comment|/* symbol definition */
block|{
name|int
name|psect
decl_stmt|;
name|symbol
operator|->
name|value
operator|=
name|bfd_getl32
argument_list|(
name|vms_rec
operator|+
name|value_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gsd_type
operator|==
name|GSD_S_C_SYMW
operator|)
operator|||
operator|(
name|gsd_type
operator|==
name|GSD_S_C_EPMW
operator|)
condition|)
name|psect
operator|=
name|bfd_getl16
argument_list|(
name|vms_rec
operator|+
name|value_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
else|else
name|psect
operator|=
name|vms_rec
index|[
name|value_offset
operator|-
literal|1
index|]
expr_stmt|;
name|symbol
operator|->
name|section
operator|=
operator|(
name|asection
operator|*
operator|)
name|psect
expr_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|4
argument_list|,
literal|"gsd sym def #%d (%s, %d [%p], %04x=%s)\n"
argument_list|,
name|abfd
operator|->
name|symcount
argument_list|,
name|symbol
operator|->
name|name
argument_list|,
operator|(
name|int
operator|)
name|symbol
operator|->
name|section
argument_list|,
name|symbol
operator|->
name|section
argument_list|,
name|old_flags
argument_list|,
name|flag2str
argument_list|(
name|gsyflagdesc
argument_list|,
name|old_flags
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
comment|/* symbol reference */
block|{
name|symbol
operator|->
name|section
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|BFD_UND_SECTION_NAME
argument_list|)
expr_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|4
argument_list|,
literal|"gsd sym ref #%d (%s, %s [%p], %04x=%s)\n"
argument_list|,
name|abfd
operator|->
name|symcount
argument_list|,
name|symbol
operator|->
name|name
argument_list|,
name|symbol
operator|->
name|section
operator|->
name|name
argument_list|,
name|symbol
operator|->
name|section
argument_list|,
name|old_flags
argument_list|,
name|flag2str
argument_list|(
name|gsyflagdesc
argument_list|,
name|old_flags
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|gsd_size
operator|=
name|vms_rec
index|[
name|name_offset
index|]
operator|+
name|name_offset
operator|+
literal|1
expr_stmt|;
name|symbol
operator|->
name|flags
operator|=
name|new_flags
expr_stmt|;
block|}
break|break;
case|case
name|GSD_S_C_PRO
case|:
case|case
name|GSD_S_C_PROW
case|:
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|4
argument_list|,
literal|"gsd pro\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|GSD_S_C_IDC
case|:
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|4
argument_list|,
literal|"gsd idc\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|GSD_S_C_ENV
case|:
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|4
argument_list|,
literal|"gsd env\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|GSD_S_C_LSY
case|:
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|4
argument_list|,
literal|"gsd lsy\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|GSD_S_C_LEPM
case|:
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|4
argument_list|,
literal|"gsd lepm\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|GSD_S_C_LPRO
case|:
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|4
argument_list|,
literal|"gsd lpro\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|GSD_S_C_SPSC
case|:
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|4
argument_list|,
literal|"gsd spsc\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|GSD_S_C_SYMV
case|:
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|4
argument_list|,
literal|"gsd symv\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|GSD_S_C_EPMV
case|:
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|4
argument_list|,
literal|"gsd epmv\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|GSD_S_C_PROV
case|:
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|4
argument_list|,
literal|"gsd prov\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|EGSD_S_C_PSC
operator|+
name|EVAX_OFFSET
case|:
block|{
comment|/* program section definition  */
name|name
operator|=
name|_bfd_vms_save_counted_string
argument_list|(
name|vms_rec
operator|+
literal|12
argument_list|)
expr_stmt|;
name|section
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|section
condition|)
return|return
operator|-
literal|1
return|;
name|old_flags
operator|=
name|bfd_getl16
argument_list|(
name|vms_rec
operator|+
literal|6
argument_list|)
expr_stmt|;
name|section
operator|->
name|_raw_size
operator|=
name|bfd_getl32
argument_list|(
name|vms_rec
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* allocation */
name|new_flags
operator|=
name|vms_secflag_by_name
argument_list|(
name|abfd
argument_list|,
name|evax_section_flags
argument_list|,
name|name
argument_list|,
name|section
operator|->
name|_raw_size
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_flags
operator|&
name|EGPS_S_V_REL
condition|)
name|new_flags
operator||=
name|SEC_RELOC
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|new_flags
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|section
operator|->
name|alignment_power
operator|=
name|vms_rec
index|[
literal|4
index|]
expr_stmt|;
name|align_addr
operator|=
operator|(
literal|1
operator|<<
name|section
operator|->
name|alignment_power
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|base_addr
operator|%
name|align_addr
operator|)
operator|!=
literal|0
condition|)
name|base_addr
operator|+=
operator|(
name|align_addr
operator|-
operator|(
name|base_addr
operator|%
name|align_addr
operator|)
operator|)
expr_stmt|;
name|section
operator|->
name|vma
operator|=
operator|(
name|bfd_vma
operator|)
name|base_addr
expr_stmt|;
name|base_addr
operator|+=
name|section
operator|->
name|_raw_size
expr_stmt|;
name|section
operator|->
name|contents
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|section
operator|->
name|_raw_size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|section
operator|->
name|_cooked_size
operator|=
name|section
operator|->
name|_raw_size
expr_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|4
argument_list|,
literal|"egsd psc %d (%s, flags %04x=%s) "
argument_list|,
name|section
operator|->
name|index
argument_list|,
name|name
argument_list|,
name|old_flags
argument_list|,
name|flag2str
argument_list|(
name|gpsflagdesc
argument_list|,
name|old_flags
argument_list|)
argument_list|)
expr_stmt|;
name|vms_debug
argument_list|(
literal|4
argument_list|,
literal|"%d bytes at 0x%08lx (mem %p)\n"
argument_list|,
name|section
operator|->
name|_raw_size
argument_list|,
name|section
operator|->
name|vma
argument_list|,
name|section
operator|->
name|contents
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
case|case
name|EGSD_S_C_SYM
operator|+
name|EVAX_OFFSET
case|:
block|{
comment|/* symbol specification (definition or reference)  */
name|symbol
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|old_flags
operator|=
name|bfd_getl16
argument_list|(
name|vms_rec
operator|+
literal|6
argument_list|)
expr_stmt|;
name|new_flags
operator|=
name|BSF_NO_FLAGS
expr_stmt|;
if|if
condition|(
name|old_flags
operator|&
name|EGSY_S_V_WEAK
condition|)
name|new_flags
operator||=
name|BSF_WEAK
expr_stmt|;
if|if
condition|(
name|vms_rec
index|[
literal|6
index|]
operator|&
name|EGSY_S_V_DEF
condition|)
comment|/* symbol definition */
block|{
name|symbol
operator|->
name|name
operator|=
name|_bfd_vms_save_counted_string
argument_list|(
name|vms_rec
operator|+
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_flags
operator|&
name|EGSY_S_V_NORM
condition|)
block|{
comment|/* proc def */
name|new_flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
block|}
name|symbol
operator|->
name|value
operator|=
name|bfd_getl64
argument_list|(
name|vms_rec
operator|+
literal|8
argument_list|)
expr_stmt|;
name|symbol
operator|->
name|section
operator|=
operator|(
name|asection
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|bfd_getl32
argument_list|(
name|vms_rec
operator|+
literal|28
argument_list|)
operator|)
expr_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|4
argument_list|,
literal|"egsd sym def #%d (%s, %d, %04x=%s)\n"
argument_list|,
name|abfd
operator|->
name|symcount
argument_list|,
name|symbol
operator|->
name|name
argument_list|,
operator|(
name|int
operator|)
name|symbol
operator|->
name|section
argument_list|,
name|old_flags
argument_list|,
name|flag2str
argument_list|(
name|gsyflagdesc
argument_list|,
name|old_flags
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
comment|/* symbol reference */
block|{
name|symbol
operator|->
name|name
operator|=
name|_bfd_vms_save_counted_string
argument_list|(
name|vms_rec
operator|+
literal|8
argument_list|)
expr_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|4
argument_list|,
literal|"egsd sym ref #%d (%s, %04x=%s)\n"
argument_list|,
name|abfd
operator|->
name|symcount
argument_list|,
name|symbol
operator|->
name|name
argument_list|,
name|old_flags
argument_list|,
name|flag2str
argument_list|(
name|gsyflagdesc
argument_list|,
name|old_flags
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|symbol
operator|->
name|section
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|BFD_UND_SECTION_NAME
argument_list|)
expr_stmt|;
block|}
name|symbol
operator|->
name|flags
operator|=
name|new_flags
expr_stmt|;
comment|/* save symbol in vms_symbol_table  */
name|entry
operator|=
operator|(
name|vms_symbol_entry
operator|*
operator|)
name|bfd_hash_lookup
argument_list|(
name|PRIV
argument_list|(
name|vms_symbol_table
argument_list|)
argument_list|,
name|symbol
operator|->
name|name
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
operator|(
name|vms_symbol_entry
operator|*
operator|)
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|entry
operator|->
name|symbol
operator|!=
operator|(
name|asymbol
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* FIXME ?, DEC C generates this */
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|4
argument_list|,
literal|"EGSD_S_C_SYM: duplicate \"%s\"\n"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|entry
operator|->
name|symbol
operator|=
name|symbol
expr_stmt|;
name|PRIV
argument_list|(
name|gsd_sym_count
argument_list|)
operator|++
expr_stmt|;
name|abfd
operator|->
name|symcount
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
name|EGSD_S_C_IDC
operator|+
name|EVAX_OFFSET
case|:
break|break;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"unknown gsd/egsd subtype %d"
argument_list|)
argument_list|,
name|gsd_type
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* switch */
name|PRIV
argument_list|(
name|rec_size
argument_list|)
operator|-=
name|gsd_size
expr_stmt|;
name|PRIV
argument_list|(
name|vms_rec
argument_list|)
operator|+=
name|gsd_size
expr_stmt|;
block|}
comment|/* while (recsize> 0) */
if|if
condition|(
name|abfd
operator|->
name|symcount
operator|>
literal|0
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_SYMS
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* output routines */
end_comment

begin_comment
comment|/* Write section and symbol directory of bfd abfd  */
end_comment

begin_function
name|int
name|_bfd_vms_write_gsd
parameter_list|(
name|abfd
parameter_list|,
name|objtype
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|objtype
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|asection
modifier|*
name|section
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|unsigned
name|int
name|symnum
decl_stmt|;
name|int
name|last_index
init|=
operator|-
literal|1
decl_stmt|;
name|char
name|dummy_name
index|[
literal|10
index|]
decl_stmt|;
name|char
modifier|*
name|sname
decl_stmt|;
name|flagword
name|new_flags
decl_stmt|,
name|old_flags
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|2
argument_list|,
literal|"vms_write_gsd (%p, %d)\n"
argument_list|,
name|abfd
argument_list|,
name|objtype
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* output sections  */
name|section
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|3
argument_list|,
literal|"%d sections found\n"
argument_list|,
name|abfd
operator|->
name|section_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* egsd is quadword aligned  */
name|_bfd_vms_output_alignment
argument_list|(
name|abfd
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|_bfd_vms_output_begin
argument_list|(
name|abfd
argument_list|,
name|EOBJ_S_C_EGSD
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|_bfd_vms_output_long
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_bfd_vms_output_push
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* prepare output for subrecords */
while|while
condition|(
name|section
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|3
argument_list|,
literal|"Section #%d %s, %d bytes\n"
argument_list|,
name|section
operator|->
name|index
argument_list|,
name|section
operator|->
name|name
argument_list|,
operator|(
name|int
operator|)
name|section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 13 bytes egsd, max 31 chars name -> should be 44 bytes */
if|if
condition|(
name|_bfd_vms_output_check
argument_list|(
name|abfd
argument_list|,
literal|64
argument_list|)
operator|<
literal|0
condition|)
block|{
name|_bfd_vms_output_pop
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|_bfd_vms_output_end
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|_bfd_vms_output_begin
argument_list|(
name|abfd
argument_list|,
name|EOBJ_S_C_EGSD
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|_bfd_vms_output_long
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_bfd_vms_output_push
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* prepare output for subrecords */
block|}
comment|/* Create dummy sections to keep consecutive indices */
while|while
condition|(
name|section
operator|->
name|index
operator|-
name|last_index
operator|>
literal|1
condition|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|3
argument_list|,
literal|"index %d, last %d\n"
argument_list|,
name|section
operator|->
name|index
argument_list|,
name|last_index
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_bfd_vms_output_begin
argument_list|(
name|abfd
argument_list|,
name|EGSD_S_C_PSC
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|_bfd_vms_output_short
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_bfd_vms_output_short
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_bfd_vms_output_long
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|dummy_name
argument_list|,
literal|".DUMMY%02d"
argument_list|,
name|last_index
argument_list|)
expr_stmt|;
name|_bfd_vms_output_counted
argument_list|(
name|abfd
argument_list|,
name|dummy_name
argument_list|)
expr_stmt|;
name|_bfd_vms_output_flush
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|last_index
operator|++
expr_stmt|;
block|}
comment|/* Don't know if this is necessary for the linker but for now it keeps 	 vms_slurp_gsd happy  */
name|sname
operator|=
operator|(
name|char
operator|*
operator|)
name|section
operator|->
name|name
expr_stmt|;
if|if
condition|(
operator|*
name|sname
operator|==
literal|'.'
condition|)
block|{
name|sname
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|sname
operator|==
literal|'t'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|sname
argument_list|,
literal|"text"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|sname
operator|=
name|PRIV
argument_list|(
name|is_vax
argument_list|)
condition|?
name|VAX_CODE_NAME
else|:
name|EVAX_CODE_NAME
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|sname
operator|==
literal|'d'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|sname
argument_list|,
literal|"data"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|sname
operator|=
name|PRIV
argument_list|(
name|is_vax
argument_list|)
condition|?
name|VAX_DATA_NAME
else|:
name|EVAX_DATA_NAME
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|sname
operator|==
literal|'b'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|sname
argument_list|,
literal|"bss"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|sname
operator|=
name|EVAX_BSS_NAME
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|sname
operator|==
literal|'l'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|sname
argument_list|,
literal|"link"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|sname
operator|=
name|EVAX_LINK_NAME
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|sname
operator|==
literal|'r'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|sname
argument_list|,
literal|"rdata"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|sname
operator|=
name|EVAX_READONLY_NAME
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|sname
operator|==
literal|'l'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|sname
argument_list|,
literal|"literal"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|sname
operator|=
name|EVAX_LITERAL_NAME
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|sname
operator|==
literal|'c'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|sname
argument_list|,
literal|"comm"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|sname
operator|=
name|EVAX_COMMON_NAME
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|sname
operator|==
literal|'l'
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|sname
argument_list|,
literal|"lcomm"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|sname
operator|=
name|EVAX_LOCAL_NAME
expr_stmt|;
block|}
else|else
name|sname
operator|=
name|_bfd_vms_length_hash_symbol
argument_list|(
name|abfd
argument_list|,
name|sname
argument_list|,
name|EOBJ_S_C_SECSIZ
argument_list|)
expr_stmt|;
name|_bfd_vms_output_begin
argument_list|(
name|abfd
argument_list|,
name|EGSD_S_C_PSC
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|_bfd_vms_output_short
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|alignment_power
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|section
argument_list|)
condition|)
block|{
name|new_flags
operator|=
operator|(
name|EGPS_S_V_OVR
operator||
name|EGPS_S_V_REL
operator||
name|EGPS_S_V_GBL
operator||
name|EGPS_S_V_RD
operator||
name|EGPS_S_V_WRT
operator||
name|EGPS_S_V_NOMOD
operator||
name|EGPS_S_V_COM
operator|)
expr_stmt|;
block|}
else|else
block|{
name|new_flags
operator|=
name|vms_esecflag_by_name
argument_list|(
name|evax_section_flags
argument_list|,
name|sname
argument_list|,
name|section
operator|->
name|_raw_size
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
name|_bfd_vms_output_short
argument_list|(
name|abfd
argument_list|,
name|new_flags
argument_list|)
expr_stmt|;
name|_bfd_vms_output_long
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|_bfd_vms_output_counted
argument_list|(
name|abfd
argument_list|,
name|sname
argument_list|)
expr_stmt|;
name|_bfd_vms_output_flush
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|last_index
operator|=
name|section
operator|->
name|index
expr_stmt|;
name|section
operator|=
name|section
operator|->
name|next
expr_stmt|;
block|}
comment|/* output symbols  */
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|3
argument_list|,
literal|"%d symbols found\n"
argument_list|,
name|abfd
operator|->
name|symcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bfd_set_start_address
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|symnum
operator|=
literal|0
init|;
name|symnum
operator|<
name|abfd
operator|->
name|symcount
condition|;
name|symnum
operator|++
control|)
block|{
name|char
modifier|*
name|hash
decl_stmt|;
name|symbol
operator|=
name|abfd
operator|->
name|outsymbols
index|[
name|symnum
index|]
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|symbol
operator|->
name|name
operator|)
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|symbol
operator|->
name|name
argument_list|,
literal|"__main"
argument_list|)
operator|==
literal|0
condition|)
name|bfd_set_start_address
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|symbol
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
name|old_flags
operator|=
name|symbol
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|old_flags
operator|&
name|BSF_FILE
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|old_flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_WEAK
operator|)
operator|)
operator|==
literal|0
operator|)
comment|/* not xdef */
operator|&&
operator|(
operator|!
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|)
condition|)
comment|/* and not xref */
continue|continue;
comment|/* dont output */
comment|/* 13 bytes egsd, max 64 chars name -> should be 77 bytes  */
if|if
condition|(
name|_bfd_vms_output_check
argument_list|(
name|abfd
argument_list|,
literal|80
argument_list|)
operator|<
literal|0
condition|)
block|{
name|_bfd_vms_output_pop
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|_bfd_vms_output_end
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|_bfd_vms_output_begin
argument_list|(
name|abfd
argument_list|,
name|EOBJ_S_C_EGSD
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|_bfd_vms_output_long
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_bfd_vms_output_push
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* prepare output for subrecords */
block|}
name|_bfd_vms_output_begin
argument_list|(
name|abfd
argument_list|,
name|EGSD_S_C_SYM
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|_bfd_vms_output_short
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* data type, alignment */
name|new_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|old_flags
operator|&
name|BSF_WEAK
condition|)
name|new_flags
operator||=
name|EGSY_S_V_WEAK
expr_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
comment|/* .comm  */
name|new_flags
operator||=
operator|(
name|EGSY_S_V_WEAK
operator||
name|EGSY_S_V_COMM
operator|)
expr_stmt|;
if|if
condition|(
name|old_flags
operator|&
name|BSF_FUNCTION
condition|)
block|{
name|new_flags
operator||=
name|EGSY_S_V_NORM
expr_stmt|;
name|new_flags
operator||=
name|EGSY_S_V_REL
expr_stmt|;
block|}
if|if
condition|(
name|old_flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_WEAK
operator|)
condition|)
block|{
name|new_flags
operator||=
name|EGSY_S_V_DEF
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|new_flags
operator||=
name|EGSY_S_V_REL
expr_stmt|;
block|}
name|_bfd_vms_output_short
argument_list|(
name|abfd
argument_list|,
name|new_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_WEAK
operator|)
condition|)
comment|/* symbol definition */
block|{
name|uquad
name|code_address
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|ca_psindx
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|psindx
decl_stmt|;
if|if
condition|(
operator|(
name|old_flags
operator|&
name|BSF_FUNCTION
operator|)
operator|&&
name|symbol
operator|->
name|udata
operator|.
name|p
operator|!=
name|NULL
condition|)
block|{
name|code_address
operator|=
operator|(
operator|(
name|asymbol
operator|*
operator|)
operator|(
name|symbol
operator|->
name|udata
operator|.
name|p
operator|)
operator|)
operator|->
name|value
expr_stmt|;
name|ca_psindx
operator|=
operator|(
operator|(
name|asymbol
operator|*
operator|)
operator|(
name|symbol
operator|->
name|udata
operator|.
name|p
operator|)
operator|)
operator|->
name|section
operator|->
name|index
expr_stmt|;
block|}
name|psindx
operator|=
name|symbol
operator|->
name|section
operator|->
name|index
expr_stmt|;
name|_bfd_vms_output_quad
argument_list|(
name|abfd
argument_list|,
name|symbol
operator|->
name|value
argument_list|)
expr_stmt|;
name|_bfd_vms_output_quad
argument_list|(
name|abfd
argument_list|,
name|code_address
argument_list|)
expr_stmt|;
name|_bfd_vms_output_long
argument_list|(
name|abfd
argument_list|,
name|ca_psindx
argument_list|)
expr_stmt|;
name|_bfd_vms_output_long
argument_list|(
name|abfd
argument_list|,
name|psindx
argument_list|)
expr_stmt|;
block|}
name|hash
operator|=
name|_bfd_vms_length_hash_symbol
argument_list|(
name|abfd
argument_list|,
name|symbol
operator|->
name|name
argument_list|,
name|EOBJ_S_C_SYMSIZ
argument_list|)
expr_stmt|;
name|_bfd_vms_output_counted
argument_list|(
name|abfd
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|_bfd_vms_output_flush
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
name|_bfd_vms_output_alignment
argument_list|(
name|abfd
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|_bfd_vms_output_pop
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|_bfd_vms_output_end
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

