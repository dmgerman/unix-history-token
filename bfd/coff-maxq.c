begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for MAXQ COFF binaries.    Copyright 2004, 2007  Free Software Foundation, Inc.     Contributed by Vineet Sharma (vineets@noida.hcltech.com) Inderpreet S.    (inderpreetb@noida.hcltech.com)     HCL Technologies Ltd.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the Free     Software Foundation; either version 2 of the License, or (at your option)    any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License    for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,     51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"coff/maxq.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAXQ20
end_ifndef

begin_define
define|#
directive|define
name|MAXQ20
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RTYPE2HOWTO
parameter_list|(
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
define|\
value|((cache_ptr)->howto =                                                 \    ((dst)->r_type< 48 							\     ? howto_table + (((dst)->r_type==47) ? 6: ((dst)->r_type))		\     : NULL))
end_define

begin_define
define|#
directive|define
name|COFF_DEFAULT_SECTION_ALIGNMENT_POWER
value|(2)
end_define

begin_comment
comment|/* Code to swap in the reloc offset.  */
end_comment

begin_define
define|#
directive|define
name|SWAP_IN_RELOC_OFFSET
value|H_GET_16
end_define

begin_define
define|#
directive|define
name|SWAP_OUT_RELOC_OFFSET
value|H_PUT_16
end_define

begin_define
define|#
directive|define
name|SHORT_JUMP
value|BFD_RELOC_16_PCREL_S2
end_define

begin_define
define|#
directive|define
name|LONG_JUMP
value|BFD_RELOC_14
end_define

begin_define
define|#
directive|define
name|ABSOLUTE_ADDR_FOR_DATA
value|BFD_RELOC_24
end_define

begin_comment
comment|/* checks the range of short jump -127 to 128 */
end_comment

begin_define
define|#
directive|define
name|IS_SJUMP_RANGE
parameter_list|(
name|x
parameter_list|)
value|((x> -128)&& (x< 129))
end_define

begin_define
define|#
directive|define
name|HIGH_WORD_MASK
value|0xff00
end_define

begin_define
define|#
directive|define
name|LOW_WORD_MASK
value|0x00ff
end_define

begin_function
specifier|static
name|long
name|get_symbol_value
parameter_list|(
name|asymbol
modifier|*
name|symbol
parameter_list|)
block|{
name|long
name|relocation
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
return|return
name|relocation
return|;
block|}
end_function

begin_comment
comment|/* This function performs all the maxq relocations.    FIXME:  The handling of the addend in the 'BFD_*'    relocations types.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|coff_maxq20_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol_in
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|addr
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|x
init|=
literal|0
decl_stmt|;
name|long
name|call_addr
init|=
literal|0
decl_stmt|;
name|short
name|addend
init|=
literal|0
decl_stmt|;
name|long
name|diff
init|=
literal|0
decl_stmt|;
comment|/* If this is an undefined symbol, return error.  */
if|if
condition|(
name|symbol_in
operator|->
name|section
operator|==
operator|&
name|bfd_und_section
operator|&&
operator|(
name|symbol_in
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|==
literal|0
condition|)
return|return
name|bfd_reloc_continue
return|;
if|if
condition|(
name|data
operator|&&
name|reloc_entry
condition|)
block|{
name|addr
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
expr_stmt|;
name|call_addr
operator|=
name|call_addr
operator|-
name|call_addr
expr_stmt|;
name|call_addr
operator|=
name|get_symbol_value
argument_list|(
name|symbol_in
argument_list|)
expr_stmt|;
comment|/* Over here the value val stores the 8 bit/16 bit value. We will put a           check if we are moving a 16 bit immediate value into an 8 bit          register. In that case we will generate a Upper bytes into PFX[0]          and move the lower 8 bits as SRC.  */
switch|switch
condition|(
name|reloc_entry
operator|->
name|howto
operator|->
name|type
condition|)
block|{
comment|/* BFD_RELOC_16_PCREL_S2 47 Handles all the relative jumps and 	     calls Note: Every relative jump or call is in words.  */
case|case
name|SHORT_JUMP
case|:
comment|/* Handle any addend.  */
name|addend
operator|=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|addend
operator|>
name|call_addr
operator|||
name|addend
operator|>
literal|0
condition|)
name|call_addr
operator|=
name|symbol_in
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|addend
expr_stmt|;
elseif|else
if|if
condition|(
name|addend
operator|<
name|call_addr
operator|&&
name|addend
operator|>
literal|0
condition|)
name|call_addr
operator|=
name|call_addr
operator|+
name|addend
expr_stmt|;
elseif|else
if|if
condition|(
name|addend
operator|<
literal|0
condition|)
name|call_addr
operator|=
name|call_addr
operator|+
name|addend
expr_stmt|;
name|diff
operator|=
operator|(
operator|(
name|call_addr
operator|<<
literal|1
operator|)
operator|-
operator|(
name|reloc_entry
operator|->
name|address
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_SJUMP_RANGE
argument_list|(
name|diff
argument_list|)
condition|)
block|{
name|bfd_perror
argument_list|(
name|_
argument_list|(
literal|"Can't Make it a Short Jump"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_outofrange
return|;
block|}
name|x
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|x
operator|=
name|x
operator|&
name|LOW_WORD_MASK
expr_stmt|;
name|x
operator|=
name|x
operator||
operator|(
name|diff
operator|<<
literal|8
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|x
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|ABSOLUTE_ADDR_FOR_DATA
case|:
case|case
name|LONG_JUMP
case|:
comment|/* BFD_RELOC_14 Handles intersegment or long jumps which might be 	     from code to code or code to data segment jumps. Note: When this  	     fucntion is called by gas the section flags somehow do not 	     contain the info about the section type(CODE or DATA). Thus the 	     user needs to evoke the linker after assembling the files 	     because the Code-Code relocs are word aligned but code-data are 	     byte aligned.  */
name|addend
operator|=
operator|(
name|reloc_entry
operator|->
name|addend
operator|-
name|reloc_entry
operator|->
name|addend
operator|)
expr_stmt|;
comment|/* Handle any addend.  */
name|addend
operator|=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
comment|/* For relocation involving multiple file added becomes zero thus 	     this fails - check for zero added. In another case when we try 	     to add a stub to a file the addend shows the offset from the 	     start od this file.  */
name|addend
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_is_com_section
argument_list|(
name|symbol_in
operator|->
name|section
argument_list|)
operator|&&
operator|(
operator|(
name|symbol_in
operator|->
name|flags
operator|&
name|BSF_OLD_COMMON
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|reloc_entry
operator|->
name|addend
operator|>
name|symbol_in
operator|->
name|value
condition|)
name|addend
operator|=
name|reloc_entry
operator|->
name|addend
operator|-
name|symbol_in
operator|->
name|value
expr_stmt|;
if|if
condition|(
operator|(
name|reloc_entry
operator|->
name|addend
operator|<
name|symbol_in
operator|->
name|value
operator|)
operator|&&
operator|(
name|reloc_entry
operator|->
name|addend
operator|!=
literal|0
operator|)
condition|)
name|addend
operator|=
name|reloc_entry
operator|->
name|addend
operator|-
name|symbol_in
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|addend
operator|==
name|symbol_in
operator|->
name|value
condition|)
name|addend
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol_in
operator|->
name|section
argument_list|)
operator|||
operator|(
operator|(
name|symbol_in
operator|->
name|flags
operator|&
name|BSF_OLD_COMMON
operator|)
operator|!=
literal|0
operator|)
condition|)
name|addend
operator|=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|addend
operator|<
literal|0
operator|&&
operator|(
name|call_addr
operator|<
call|(
name|long
call|)
argument_list|(
name|addend
operator|*
operator|(
operator|-
literal|1
operator|)
argument_list|)
operator|)
condition|)
name|addend
operator|=
literal|0
expr_stmt|;
name|call_addr
operator|+=
name|addend
expr_stmt|;
comment|/* FIXME: This check does not work well with the assembler, 	     linker needs to be run always.  */
if|if
condition|(
operator|(
name|symbol_in
operator|->
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
name|SEC_CODE
condition|)
block|{
comment|/* Convert it into words.  */
name|call_addr
operator|=
name|call_addr
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|call_addr
operator|>
literal|0xFFFF
condition|)
comment|/* Intersegment Jump.  */
block|{
name|bfd_perror
argument_list|(
name|_
argument_list|(
literal|"Exceeds Long Jump Range"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_outofrange
return|;
block|}
block|}
else|else
block|{
comment|/* case ABSOLUTE_ADDR_FOR_DATA : Resolves any code-data 		 segemnt relocs. These are NOT word aligned.  */
if|if
condition|(
name|call_addr
operator|>
literal|0xFFFF
condition|)
comment|/* Intersegment Jump.  */
block|{
name|bfd_perror
argument_list|(
name|_
argument_list|(
literal|"Absolute address Exceeds 16 bit Range"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_outofrange
return|;
block|}
block|}
name|x
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xFF00FF00
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator||
operator|(
operator|(
name|call_addr
operator|&
name|HIGH_WORD_MASK
operator|)
operator|>>
literal|8
operator|)
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator||
operator|(
name|call_addr
operator|&
name|LOW_WORD_MASK
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|x
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|BFD_RELOC_8
case|:
name|addend
operator|=
operator|(
name|reloc_entry
operator|->
name|addend
operator|-
name|reloc_entry
operator|->
name|addend
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_is_com_section
argument_list|(
name|symbol_in
operator|->
name|section
argument_list|)
operator|&&
operator|(
operator|(
name|symbol_in
operator|->
name|flags
operator|&
name|BSF_OLD_COMMON
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|reloc_entry
operator|->
name|addend
operator|>
name|symbol_in
operator|->
name|value
condition|)
name|addend
operator|=
name|reloc_entry
operator|->
name|addend
operator|-
name|symbol_in
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|addend
operator|<
name|symbol_in
operator|->
name|value
condition|)
name|addend
operator|=
name|reloc_entry
operator|->
name|addend
operator|-
name|symbol_in
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|addend
operator|==
name|symbol_in
operator|->
name|value
condition|)
name|addend
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol_in
operator|->
name|section
argument_list|)
operator|||
operator|(
operator|(
name|symbol_in
operator|->
name|flags
operator|&
name|BSF_OLD_COMMON
operator|)
operator|!=
literal|0
operator|)
condition|)
name|addend
operator|=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|addend
operator|<
literal|0
operator|&&
operator|(
name|call_addr
operator|<
call|(
name|long
call|)
argument_list|(
name|addend
operator|*
operator|(
operator|-
literal|1
operator|)
argument_list|)
operator|)
condition|)
name|addend
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|call_addr
operator|+
name|addend
operator|>
literal|0xFF
condition|)
block|{
name|bfd_perror
argument_list|(
name|_
argument_list|(
literal|"Absolute address Exceeds 8 bit Range"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_outofrange
return|;
block|}
name|x
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|x
operator|=
name|x
operator|&
literal|0x00
expr_stmt|;
name|x
operator|=
name|x
operator||
operator|(
name|call_addr
operator|+
name|addend
operator|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|x
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|BFD_RELOC_16
case|:
name|addend
operator|=
operator|(
name|reloc_entry
operator|->
name|addend
operator|-
name|reloc_entry
operator|->
name|addend
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_is_com_section
argument_list|(
name|symbol_in
operator|->
name|section
argument_list|)
operator|&&
operator|(
operator|(
name|symbol_in
operator|->
name|flags
operator|&
name|BSF_OLD_COMMON
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|reloc_entry
operator|->
name|addend
operator|>
name|symbol_in
operator|->
name|value
condition|)
name|addend
operator|=
name|reloc_entry
operator|->
name|addend
operator|-
name|symbol_in
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|addend
operator|<
name|symbol_in
operator|->
name|value
condition|)
name|addend
operator|=
name|reloc_entry
operator|->
name|addend
operator|-
name|symbol_in
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|addend
operator|==
name|symbol_in
operator|->
name|value
condition|)
name|addend
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol_in
operator|->
name|section
argument_list|)
operator|||
operator|(
operator|(
name|symbol_in
operator|->
name|flags
operator|&
name|BSF_OLD_COMMON
operator|)
operator|!=
literal|0
operator|)
condition|)
name|addend
operator|=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|addend
operator|<
literal|0
operator|&&
operator|(
name|call_addr
operator|<
call|(
name|long
call|)
argument_list|(
name|addend
operator|*
operator|(
operator|-
literal|1
operator|)
argument_list|)
operator|)
condition|)
name|addend
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|call_addr
operator|+
name|addend
operator|)
operator|>
literal|0xFFFF
condition|)
block|{
name|bfd_perror
argument_list|(
name|_
argument_list|(
literal|"Absolute address Exceeds 16 bit Range"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_outofrange
return|;
block|}
else|else
block|{
name|unsigned
name|short
name|val
init|=
operator|(
name|call_addr
operator|+
name|addend
operator|)
decl_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* LE */
name|x
operator|=
operator|(
name|x
operator|&
literal|0x0000
operator|)
expr_stmt|;
comment|/* Flush garbage value.  */
name|x
operator|=
name|val
expr_stmt|;
if|if
condition|(
operator|(
name|symbol_in
operator|->
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
name|SEC_CODE
condition|)
name|x
operator|=
name|x
operator|>>
literal|1
expr_stmt|;
comment|/* Convert it into words.  */
block|}
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|x
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|BFD_RELOC_32
case|:
name|addend
operator|=
operator|(
name|reloc_entry
operator|->
name|addend
operator|-
name|reloc_entry
operator|->
name|addend
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_is_com_section
argument_list|(
name|symbol_in
operator|->
name|section
argument_list|)
operator|&&
operator|(
operator|(
name|symbol_in
operator|->
name|flags
operator|&
name|BSF_OLD_COMMON
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|reloc_entry
operator|->
name|addend
operator|>
name|symbol_in
operator|->
name|value
condition|)
name|addend
operator|=
name|reloc_entry
operator|->
name|addend
operator|-
name|symbol_in
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|addend
operator|<
name|symbol_in
operator|->
name|value
condition|)
name|addend
operator|=
name|reloc_entry
operator|->
name|addend
operator|-
name|symbol_in
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|addend
operator|==
name|symbol_in
operator|->
name|value
condition|)
name|addend
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol_in
operator|->
name|section
argument_list|)
operator|||
operator|(
operator|(
name|symbol_in
operator|->
name|flags
operator|&
name|BSF_OLD_COMMON
operator|)
operator|!=
literal|0
operator|)
condition|)
name|addend
operator|=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|addend
operator|<
literal|0
operator|&&
operator|(
name|call_addr
operator|<
call|(
name|long
call|)
argument_list|(
name|addend
operator|*
operator|(
operator|-
literal|1
operator|)
argument_list|)
operator|)
condition|)
name|addend
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|call_addr
operator|+
name|addend
operator|)
operator|<
literal|0
condition|)
block|{
name|bfd_perror
argument_list|(
literal|"Absolute address Exceeds 32 bit Range"
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_outofrange
return|;
block|}
name|x
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0x0000
operator|)
expr_stmt|;
comment|/* Flush garbage value.  */
name|x
operator|=
name|call_addr
operator|+
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|symbol_in
operator|->
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
name|SEC_CODE
condition|)
name|x
operator|=
name|x
operator|>>
literal|1
expr_stmt|;
comment|/* Convert it into words.  */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|x
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
default|default:
name|bfd_perror
argument_list|(
name|_
argument_list|(
literal|"Unrecognized Reloc Type"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_notsupported
return|;
block|}
block|}
return|return
name|bfd_reloc_notsupported
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_table
index|[]
init|=
block|{
name|EMPTY_HOWTO
argument_list|(
literal|0
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|1
argument_list|)
block|,
block|{
name|BFD_RELOC_32
block|,
literal|0
block|,
literal|1
block|,
literal|8
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|coff_maxq20_reloc
block|,
literal|"32Bit"
block|,
name|TRUE
block|,
literal|0x000000ff
block|,
literal|0x000000ff
block|,
name|TRUE
block|}
block|,
block|{
name|SHORT_JUMP
block|,
literal|0
block|,
literal|1
block|,
literal|8
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|coff_maxq20_reloc
block|,
literal|"SHORT_JMP"
block|,
name|TRUE
block|,
literal|0x000000ff
block|,
literal|0x000000ff
block|,
name|TRUE
block|}
block|,
block|{
name|ABSOLUTE_ADDR_FOR_DATA
block|,
literal|0
block|,
literal|2
block|,
literal|32
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|coff_maxq20_reloc
block|,
literal|"INTERSEGMENT_RELOC"
block|,
name|TRUE
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
name|FALSE
block|}
block|,
block|{
name|BFD_RELOC_16
block|,
literal|0
block|,
literal|1
block|,
literal|8
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|coff_maxq20_reloc
block|,
literal|"16Bit"
block|,
name|TRUE
block|,
literal|0x000000ff
block|,
literal|0x000000ff
block|,
name|TRUE
block|}
block|,
block|{
name|LONG_JUMP
block|,
literal|0
block|,
literal|2
block|,
literal|32
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|coff_maxq20_reloc
block|,
literal|"LONG_JUMP"
block|,
name|TRUE
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
name|FALSE
block|}
block|,
block|{
name|BFD_RELOC_8
block|,
literal|0
block|,
literal|1
block|,
literal|8
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|coff_maxq20_reloc
block|,
literal|"8bit"
block|,
name|TRUE
block|,
literal|0x000000ff
block|,
literal|0x000000ff
block|,
name|TRUE
block|}
block|,
name|EMPTY_HOWTO
argument_list|(
literal|8
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|9
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|10
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|maxq_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* SHORT JUMP */
case|case
name|BFD_RELOC_16_PCREL_S2
case|:
return|return
name|howto_table
operator|+
literal|3
return|;
comment|/* INTERSEGMENT JUMP */
case|case
name|BFD_RELOC_24
case|:
return|return
name|howto_table
operator|+
literal|4
return|;
comment|/* BYTE RELOC */
case|case
name|BFD_RELOC_8
case|:
return|return
name|howto_table
operator|+
literal|7
return|;
comment|/* WORD RELOC */
case|case
name|BFD_RELOC_16
case|:
return|return
name|howto_table
operator|+
literal|5
return|;
comment|/* LONG RELOC */
case|case
name|BFD_RELOC_32
case|:
return|return
name|howto_table
operator|+
literal|2
return|;
comment|/* LONG JUMP */
case|case
name|BFD_RELOC_14
case|:
return|return
name|howto_table
operator|+
literal|6
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|maxq_reloc_name_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|r_name
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|howto_table
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|howto_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcasecmp
argument_list|(
name|howto_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|howto_table
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_define
define|#
directive|define
name|coff_bfd_reloc_type_lookup
value|maxq_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|coff_bfd_reloc_name_lookup
value|maxq_reloc_name_lookup
end_define

begin_comment
comment|/* Perform any necessary magic to the addend in a reloc entry.  */
end_comment

begin_define
define|#
directive|define
name|CALC_ADDEND
parameter_list|(
name|abfd
parameter_list|,
name|symbol
parameter_list|,
name|ext_reloc
parameter_list|,
name|cache_ptr
parameter_list|)
define|\
value|cache_ptr->addend =  ext_reloc.r_offset;
end_define

begin_include
include|#
directive|include
file|"coffcode.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_UNDERSCORE
end_ifndef

begin_define
define|#
directive|define
name|TARGET_UNDERSCORE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EXTRA_S_FLAGS
end_ifndef

begin_define
define|#
directive|define
name|EXTRA_S_FLAGS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Forward declaration for use initialising alternative_target field.  */
end_comment

begin_expr_stmt
name|CREATE_LITTLE_COFF_TARGET_VEC
argument_list|(
name|maxqcoff_vec
argument_list|,
literal|"coff-maxq"
argument_list|,
literal|0
argument_list|,
name|EXTRA_S_FLAGS
argument_list|,
name|TARGET_UNDERSCORE
argument_list|,
name|NULL
argument_list|,
name|COFF_SWAP_TABLE
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

