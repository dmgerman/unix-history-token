begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD library support routines for the Renesas H8/300 architecture.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 2000, 2001, 2002,    2003, 2004, 2007 Free Software Foundation, Inc.    Hacked by Steve Chamberlain of Cygnus Support.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_function
specifier|static
name|bfd_boolean
name|h8300_scan
parameter_list|(
specifier|const
name|struct
name|bfd_arch_info
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
if|if
condition|(
operator|*
name|string
operator|!=
literal|'h'
operator|&&
operator|*
name|string
operator|!=
literal|'H'
condition|)
return|return
name|FALSE
return|;
name|string
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|!=
literal|'8'
condition|)
return|return
name|FALSE
return|;
name|string
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'/'
condition|)
name|string
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|!=
literal|'3'
condition|)
return|return
name|FALSE
return|;
name|string
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|!=
literal|'0'
condition|)
return|return
name|FALSE
return|;
name|string
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|!=
literal|'0'
condition|)
return|return
name|FALSE
return|;
name|string
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'-'
condition|)
name|string
operator|++
expr_stmt|;
comment|/* In ELF linker scripts, we typically express the architecture/machine      as architecture:machine.       So if we've matched so far and encounter a colon, try to match the      string following the colon.  */
if|if
condition|(
operator|*
name|string
operator|==
literal|':'
condition|)
block|{
name|string
operator|++
expr_stmt|;
return|return
name|h8300_scan
argument_list|(
name|info
argument_list|,
name|string
argument_list|)
return|;
block|}
if|if
condition|(
operator|*
name|string
operator|==
literal|'h'
operator|||
operator|*
name|string
operator|==
literal|'H'
condition|)
block|{
name|string
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'n'
operator|||
operator|*
name|string
operator|==
literal|'N'
condition|)
return|return
operator|(
name|info
operator|->
name|mach
operator|==
name|bfd_mach_h8300hn
operator|)
return|;
return|return
operator|(
name|info
operator|->
name|mach
operator|==
name|bfd_mach_h8300h
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|string
operator|==
literal|'s'
operator|||
operator|*
name|string
operator|==
literal|'S'
condition|)
block|{
name|string
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'n'
operator|||
operator|*
name|string
operator|==
literal|'N'
condition|)
return|return
operator|(
name|info
operator|->
name|mach
operator|==
name|bfd_mach_h8300sn
operator|)
return|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'x'
operator|||
operator|*
name|string
operator|==
literal|'X'
condition|)
block|{
name|string
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'n'
operator|||
operator|*
name|string
operator|==
literal|'N'
condition|)
return|return
operator|(
name|info
operator|->
name|mach
operator|==
name|bfd_mach_h8300sxn
operator|)
return|;
return|return
operator|(
name|info
operator|->
name|mach
operator|==
name|bfd_mach_h8300sx
operator|)
return|;
block|}
return|return
operator|(
name|info
operator|->
name|mach
operator|==
name|bfd_mach_h8300s
operator|)
return|;
block|}
else|else
return|return
name|info
operator|->
name|mach
operator|==
name|bfd_mach_h8300
return|;
block|}
end_function

begin_comment
comment|/* This routine is provided two arch_infos and works out the machine    which would be compatible with both and returns a pointer to its    info structure.  */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_arch_info_type
modifier|*
name|compatible
parameter_list|(
specifier|const
name|bfd_arch_info_type
modifier|*
name|in
parameter_list|,
specifier|const
name|bfd_arch_info_type
modifier|*
name|out
parameter_list|)
block|{
if|if
condition|(
name|in
operator|->
name|arch
operator|!=
name|out
operator|->
name|arch
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|in
operator|->
name|mach
operator|==
name|bfd_mach_h8300sx
operator|&&
name|out
operator|->
name|mach
operator|==
name|bfd_mach_h8300s
condition|)
return|return
name|in
return|;
if|if
condition|(
name|in
operator|->
name|mach
operator|==
name|bfd_mach_h8300s
operator|&&
name|out
operator|->
name|mach
operator|==
name|bfd_mach_h8300sx
condition|)
return|return
name|out
return|;
if|if
condition|(
name|in
operator|->
name|mach
operator|==
name|bfd_mach_h8300sxn
operator|&&
name|out
operator|->
name|mach
operator|==
name|bfd_mach_h8300sn
condition|)
return|return
name|in
return|;
if|if
condition|(
name|in
operator|->
name|mach
operator|==
name|bfd_mach_h8300sn
operator|&&
name|out
operator|->
name|mach
operator|==
name|bfd_mach_h8300sxn
condition|)
return|return
name|out
return|;
comment|/* It's really not a good idea to mix and match modes.  */
if|if
condition|(
name|in
operator|->
name|mach
operator|!=
name|out
operator|->
name|mach
condition|)
return|return
literal|0
return|;
else|else
return|return
name|in
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|bfd_arch_info_type
name|h8300sxn_info_struct
init|=
block|{
literal|32
block|,
comment|/* 32 bits in a word */
literal|16
block|,
comment|/* 16 bits in an address */
literal|8
block|,
comment|/* 8 bits in a byte */
name|bfd_arch_h8300
block|,
name|bfd_mach_h8300sxn
block|,
literal|"h8300sxn"
block|,
comment|/* arch_name  */
literal|"h8300sxn"
block|,
comment|/* printable name */
literal|1
block|,
name|FALSE
block|,
comment|/* the default machine */
name|compatible
block|,
name|h8300_scan
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_arch_info_type
name|h8300sx_info_struct
init|=
block|{
literal|32
block|,
comment|/* 32 bits in a word */
literal|32
block|,
comment|/* 32 bits in an address */
literal|8
block|,
comment|/* 8 bits in a byte */
name|bfd_arch_h8300
block|,
name|bfd_mach_h8300sx
block|,
literal|"h8300sx"
block|,
comment|/* arch_name  */
literal|"h8300sx"
block|,
comment|/* printable name */
literal|1
block|,
name|FALSE
block|,
comment|/* the default machine */
name|compatible
block|,
name|h8300_scan
block|,
operator|&
name|h8300sxn_info_struct
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_arch_info_type
name|h8300sn_info_struct
init|=
block|{
literal|32
block|,
comment|/* 32 bits in a word.  */
literal|16
block|,
comment|/* 16 bits in an address.  */
literal|8
block|,
comment|/* 8 bits in a byte.  */
name|bfd_arch_h8300
block|,
name|bfd_mach_h8300sn
block|,
literal|"h8300sn"
block|,
comment|/* Architecture name.  */
literal|"h8300sn"
block|,
comment|/* Printable name.  */
literal|1
block|,
name|FALSE
block|,
comment|/* The default machine.  */
name|compatible
block|,
name|h8300_scan
block|,
operator|&
name|h8300sx_info_struct
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_arch_info_type
name|h8300hn_info_struct
init|=
block|{
literal|32
block|,
comment|/* 32 bits in a word.  */
literal|16
block|,
comment|/* 16 bits in an address.  */
literal|8
block|,
comment|/* 8 bits in a byte.  */
name|bfd_arch_h8300
block|,
name|bfd_mach_h8300hn
block|,
literal|"h8300hn"
block|,
comment|/* Architecture name.  */
literal|"h8300hn"
block|,
comment|/* Printable name.  */
literal|1
block|,
name|FALSE
block|,
comment|/* The default machine.  */
name|compatible
block|,
name|h8300_scan
block|,
operator|&
name|h8300sn_info_struct
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_arch_info_type
name|h8300s_info_struct
init|=
block|{
literal|32
block|,
comment|/* 32 bits in a word.  */
literal|32
block|,
comment|/* 32 bits in an address.  */
literal|8
block|,
comment|/* 8 bits in a byte.  */
name|bfd_arch_h8300
block|,
name|bfd_mach_h8300s
block|,
literal|"h8300s"
block|,
comment|/* Architecture name.  */
literal|"h8300s"
block|,
comment|/* Printable name.  */
literal|1
block|,
name|FALSE
block|,
comment|/* The default machine.  */
name|compatible
block|,
name|h8300_scan
block|,
operator|&
name|h8300hn_info_struct
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_arch_info_type
name|h8300h_info_struct
init|=
block|{
literal|32
block|,
comment|/* 32 bits in a word.  */
literal|32
block|,
comment|/* 32 bits in an address.  */
literal|8
block|,
comment|/* 8 bits in a byte.  */
name|bfd_arch_h8300
block|,
name|bfd_mach_h8300h
block|,
literal|"h8300h"
block|,
comment|/* Architecture name.  */
literal|"h8300h"
block|,
comment|/* Printable name.  */
literal|1
block|,
name|FALSE
block|,
comment|/* The default machine.  */
name|compatible
block|,
name|h8300_scan
block|,
operator|&
name|h8300s_info_struct
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|bfd_arch_info_type
name|bfd_h8300_arch
init|=
block|{
literal|16
block|,
comment|/* 16 bits in a word.  */
literal|16
block|,
comment|/* 16 bits in an address.  */
literal|8
block|,
comment|/* 8 bits in a byte.  */
name|bfd_arch_h8300
block|,
name|bfd_mach_h8300
block|,
literal|"h8300"
block|,
comment|/* Architecture name.  */
literal|"h8300"
block|,
comment|/* Printable name.  */
literal|1
block|,
name|TRUE
block|,
comment|/* The default machine.  */
name|compatible
block|,
name|h8300_scan
block|,
operator|&
name|h8300h_info_struct
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pad the given address to 32 bits, converting 16-bit and 24-bit    addresses into the values they would have had on a h8s target.  */
end_comment

begin_function
name|bfd_vma
name|bfd_h8300_pad_address
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_vma
name|address
parameter_list|)
block|{
comment|/* Cope with bfd_vma's larger than 32 bits.  */
name|address
operator|&=
literal|0xffffffffu
expr_stmt|;
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_mach_h8300
case|:
case|case
name|bfd_mach_h8300hn
case|:
case|case
name|bfd_mach_h8300sn
case|:
case|case
name|bfd_mach_h8300sxn
case|:
comment|/* Sign extend a 16-bit address.  */
if|if
condition|(
name|address
operator|>=
literal|0x8000
condition|)
return|return
name|address
operator||
literal|0xffff0000u
return|;
return|return
name|address
return|;
case|case
name|bfd_mach_h8300h
case|:
comment|/* Sign extend a 24-bit address.  */
if|if
condition|(
name|address
operator|>=
literal|0x800000
condition|)
return|return
name|address
operator||
literal|0xff000000u
return|;
return|return
name|address
return|;
case|case
name|bfd_mach_h8300s
case|:
case|case
name|bfd_mach_h8300sx
case|:
return|return
name|address
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

end_unit

