begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD backend for MIPS BSD (a.out) binaries.    Copyright 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003    Free Software Foundation, Inc.    Written by Ralph Campbell.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* #define ENTRY_CAN_BE_ZERO */
end_comment

begin_define
define|#
directive|define
name|N_HEADER_IN_TEXT
parameter_list|(
name|x
parameter_list|)
value|1
end_define

begin_define
define|#
directive|define
name|N_SHARED_LIB
parameter_list|(
name|x
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|N_TXTADDR
parameter_list|(
name|x
parameter_list|)
define|\
value|(N_MAGIC(x) != ZMAGIC ? (x).a_entry :
comment|/* object file or NMAGIC */
value|\ 	    TEXT_START_ADDR + EXEC_BYTES_SIZE
comment|/* no padding */
value|\     )
end_define

begin_define
define|#
directive|define
name|N_DATADDR
parameter_list|(
name|x
parameter_list|)
value|(N_TXTADDR(x)+N_TXTSIZE(x))
end_define

begin_define
define|#
directive|define
name|TEXT_START_ADDR
value|4096
end_define

begin_define
define|#
directive|define
name|TARGET_PAGE_SIZE
value|4096
end_define

begin_define
define|#
directive|define
name|SEGMENT_SIZE
value|TARGET_PAGE_SIZE
end_define

begin_define
define|#
directive|define
name|DEFAULT_ARCH
value|bfd_arch_mips
end_define

begin_define
define|#
directive|define
name|MACHTYPE_OK
parameter_list|(
name|mtype
parameter_list|)
value|((mtype) == M_UNKNOWN \ 			    || (mtype) == M_MIPS1 || (mtype) == M_MIPS2)
end_define

begin_define
define|#
directive|define
name|MY_symbol_leading_char
value|'\0'
end_define

begin_comment
comment|/* Do not "beautify" the CONCAT* macro args.  Traditional C will not    remove whitespace added here, and thus will fail to concatenate    the tokens.  */
end_comment

begin_define
define|#
directive|define
name|MY
parameter_list|(
name|OP
parameter_list|)
value|CONCAT2 (mipsbsd_,OP)
end_define

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_define
define|#
directive|define
name|SET_ARCH_MACH
parameter_list|(
name|ABFD
parameter_list|,
name|EXEC
parameter_list|)
define|\
value|MY(set_arch_mach) (ABFD, N_MACHTYPE (EXEC)); \   MY(choose_reloc_size) (ABFD);
end_define

begin_function_decl
specifier|static
name|void
name|MY
parameter_list|(
name|set_arch_mach
parameter_list|)
function_decl|PARAMS
parameter_list|(
function_decl|(
name|bfd
modifier|*
name|abfd
decl_stmt|,
name|unsigned
name|long
name|machtype
decl_stmt|)
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|void
name|MY
parameter_list|(
name|choose_reloc_size
parameter_list|)
function_decl|PARAMS
parameter_list|(
function_decl|(bfd *abfd
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_define
define|#
directive|define
name|MY_write_object_contents
value|MY(write_object_contents)
end_define

begin_function_decl
specifier|static
name|bfd_boolean
name|MY
parameter_list|(
name|write_object_contents
parameter_list|)
function_decl|PARAMS
parameter_list|(
function_decl|(bfd *abfd
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* We can't use MY(x) here because it leads to a recursive call to CONCAT2    when expanded inside JUMP_TABLE.  */
end_comment

begin_define
define|#
directive|define
name|MY_bfd_reloc_type_lookup
value|mipsbsd_reloc_howto_type_lookup
end_define

begin_define
define|#
directive|define
name|MY_canonicalize_reloc
value|mipsbsd_canonicalize_reloc
end_define

begin_define
define|#
directive|define
name|MY_bfd_link_hash_table_create
value|_bfd_generic_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|MY_bfd_link_add_symbols
value|_bfd_generic_link_add_symbols
end_define

begin_define
define|#
directive|define
name|MY_final_link_callback
value|unused
end_define

begin_define
define|#
directive|define
name|MY_bfd_final_link
value|_bfd_generic_final_link
end_define

begin_define
define|#
directive|define
name|MY_backend_data
value|&MY(backend_data)
end_define

begin_define
define|#
directive|define
name|MY_BFD_TARGET
end_define

begin_include
include|#
directive|include
file|"aout-target.h"
end_include

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_fix_jmp_addr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
expr|struct
name|bfd_symbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|reloc_howto_type
modifier|*
name|MY
parameter_list|(
name|reloc_howto_type_lookup
parameter_list|)
function_decl|PARAMS
parameter_list|(
function_decl|(bfd *
operator|,
function_decl|bfd_reloc_code_real_type
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
name|long
name|MY
parameter_list|(
name|canonicalize_reloc
parameter_list|)
function_decl|PARAMS
parameter_list|(
function_decl|(bfd *
operator|,
function_decl|sec_ptr
operator|,
function_decl|arelent **
operator|,
function_decl|asymbol **
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|MY
function|(
name|set_arch_mach
function|)
parameter_list|(
name|abfd
parameter_list|,
name|machtype
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|long
name|machtype
decl_stmt|;
block|{
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
name|unsigned
name|int
name|machine
decl_stmt|;
comment|/* Determine the architecture and machine type of the object file.  */
switch|switch
condition|(
name|machtype
condition|)
block|{
case|case
name|M_MIPS1
case|:
name|arch
operator|=
name|bfd_arch_mips
expr_stmt|;
name|machine
operator|=
name|bfd_mach_mips3000
expr_stmt|;
break|break;
case|case
name|M_MIPS2
case|:
name|arch
operator|=
name|bfd_arch_mips
expr_stmt|;
name|machine
operator|=
name|bfd_mach_mips4000
expr_stmt|;
break|break;
default|default:
name|arch
operator|=
name|bfd_arch_obscure
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine the size of a relocation entry, based on the architecture */
end_comment

begin_function
specifier|static
name|void
name|MY
function|(
name|choose_reloc_size
function|)
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_arch_sparc
case|:
case|case
name|bfd_arch_a29k
case|:
case|case
name|bfd_arch_mips
case|:
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|RELOC_EXT_SIZE
expr_stmt|;
break|break;
default|default:
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|RELOC_STD_SIZE
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Write an object file in BSD a.out format.   Section contents have already been written.  We write the   file header, symbols, and relocation.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|MY
function|(
name|write_object_contents
function|)
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|external_exec
name|exec_bytes
decl_stmt|;
name|struct
name|internal_exec
modifier|*
name|execp
init|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
comment|/* Magic number, maestro, please!  */
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_arch_m68k
case|:
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_mach_m68010
case|:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_68010
argument_list|)
expr_stmt|;
break|break;
default|default:
case|case
name|bfd_mach_m68020
case|:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_68020
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|bfd_arch_sparc
case|:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_SPARC
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_arch_i386
case|:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_386
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_arch_a29k
case|:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_29K
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_arch_mips
case|:
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_mach_mips4000
case|:
case|case
name|bfd_mach_mips6000
case|:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_MIPS2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_MIPS1
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_UNKNOWN
argument_list|)
expr_stmt|;
block|}
name|MY
function_decl|(
name|choose_reloc_size
function_decl|)
parameter_list|(
name|abfd
parameter_list|)
function_decl|;
name|WRITE_HEADERS
argument_list|(
name|abfd
argument_list|,
name|execp
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* MIPS relocation types.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_RELOC_32
value|0
end_define

begin_define
define|#
directive|define
name|MIPS_RELOC_JMP
value|1
end_define

begin_define
define|#
directive|define
name|MIPS_RELOC_WDISP16
value|2
end_define

begin_define
define|#
directive|define
name|MIPS_RELOC_HI16
value|3
end_define

begin_define
define|#
directive|define
name|MIPS_RELOC_HI16_S
value|4
end_define

begin_define
define|#
directive|define
name|MIPS_RELOC_LO16
value|5
end_define

begin_comment
comment|/* This is only called when performing a BFD_RELOC_MIPS_JMP relocation.    The jump destination address is formed from the upper 4 bits of the    "current" program counter concatenated with the jump instruction's    26 bit field and two trailing zeros.    If the destination address is not in the same segment as the "current"    program counter, then we need to signal an error.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mips_fix_jmp_addr
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|struct
name|bfd_symbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|bfd_vma
name|relocation
decl_stmt|,
name|pc
decl_stmt|;
comment|/* If this is a partial relocation, just continue.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
return|return
name|bfd_reloc_continue
return|;
comment|/* If this is an undefined symbol, return error */
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|==
literal|0
condition|)
return|return
name|bfd_reloc_undefined
return|;
comment|/* Work out which section the relocation is targeted at and the      initial relocation command value.  */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|pc
operator|=
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|reloc_entry
operator|->
name|address
operator|+
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|relocation
operator|&
literal|0xF0000000
operator|)
operator|!=
operator|(
name|pc
operator|&
literal|0xF0000000
operator|)
condition|)
return|return
name|bfd_reloc_overflow
return|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_comment
comment|/* This is only called when performing a BFD_RELOC_HI16_S relocation.    We need to see if bit 15 is set in the result. If it is, we add    0x10000 and continue normally. This will compensate for the sign extension    when the low bits are added at run time.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mips_fix_hi16_s
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_reloc_status_type
name|mips_fix_hi16_s
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|bfd_vma
name|relocation
decl_stmt|;
comment|/* If this is a partial relocation, just continue.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
return|return
name|bfd_reloc_continue
return|;
comment|/* If this is an undefined symbol, return error.  */
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|==
literal|0
condition|)
return|return
name|bfd_reloc_undefined
return|;
comment|/* Work out which section the relocation is targeted at and the      initial relocation command value.  */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|relocation
operator|&
literal|0x8000
condition|)
name|reloc_entry
operator|->
name|addend
operator|+=
literal|0x10000
expr_stmt|;
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|mips_howto_table_ext
index|[]
init|=
block|{
block|{
name|MIPS_RELOC_32
block|,
literal|0
block|,
literal|2
block|,
literal|32
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
literal|0
block|,
literal|"32"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0xffffffff
block|,
name|FALSE
block|}
block|,
block|{
name|MIPS_RELOC_JMP
block|,
literal|2
block|,
literal|2
block|,
literal|26
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|mips_fix_jmp_addr
block|,
literal|"MIPS_JMP"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0x03ffffff
block|,
name|FALSE
block|}
block|,
block|{
name|MIPS_RELOC_WDISP16
block|,
literal|2
block|,
literal|2
block|,
literal|16
block|,
name|TRUE
block|,
literal|0
block|,
name|complain_overflow_signed
block|,
literal|0
block|,
literal|"WDISP16"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0x0000ffff
block|,
name|FALSE
block|}
block|,
block|{
name|MIPS_RELOC_HI16
block|,
literal|16
block|,
literal|2
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
literal|0
block|,
literal|"HI16"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0x0000ffff
block|,
name|FALSE
block|}
block|,
block|{
name|MIPS_RELOC_HI16_S
block|,
literal|16
block|,
literal|2
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|mips_fix_hi16_s
block|,
literal|"HI16_S"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0x0000ffff
block|,
name|FALSE
block|}
block|,
block|{
name|MIPS_RELOC_LO16
block|,
literal|0
block|,
literal|2
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
literal|0
block|,
literal|"LO16"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0x0000ffff
block|,
name|FALSE
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|MY
function|(
name|reloc_howto_type_lookup
function|)
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
if|if
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_arch_mips
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BFD_RELOC_CTOR
case|:
case|case
name|BFD_RELOC_32
case|:
return|return
operator|(
operator|&
name|mips_howto_table_ext
index|[
name|MIPS_RELOC_32
index|]
operator|)
return|;
case|case
name|BFD_RELOC_MIPS_JMP
case|:
return|return
operator|(
operator|&
name|mips_howto_table_ext
index|[
name|MIPS_RELOC_JMP
index|]
operator|)
return|;
case|case
name|BFD_RELOC_16_PCREL_S2
case|:
return|return
operator|(
operator|&
name|mips_howto_table_ext
index|[
name|MIPS_RELOC_WDISP16
index|]
operator|)
return|;
case|case
name|BFD_RELOC_HI16
case|:
return|return
operator|(
operator|&
name|mips_howto_table_ext
index|[
name|MIPS_RELOC_HI16
index|]
operator|)
return|;
case|case
name|BFD_RELOC_HI16_S
case|:
return|return
operator|(
operator|&
name|mips_howto_table_ext
index|[
name|MIPS_RELOC_HI16_S
index|]
operator|)
return|;
case|case
name|BFD_RELOC_LO16
case|:
return|return
operator|(
operator|&
name|mips_howto_table_ext
index|[
name|MIPS_RELOC_LO16
index|]
operator|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* This is just like the standard aoutx.h version but we need to do our    own mapping of external reloc type values to howto entries.  */
end_comment

begin_function
name|long
name|MY
function|(
name|canonicalize_reloc
function|)
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|relptr
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relptr
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
name|arelent
modifier|*
name|tblptr
init|=
name|section
operator|->
name|relocation
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
specifier|extern
name|reloc_howto_type
name|NAME
argument_list|(
name|aout
argument_list|,
name|ext_howto_table
argument_list|)
decl|[]
decl_stmt|;
comment|/* If we have already read in the relocation table, return the values.  */
if|if
condition|(
name|section
operator|->
name|flags
operator|&
name|SEC_CONSTRUCTOR
condition|)
block|{
name|arelent_chain
modifier|*
name|chain
init|=
name|section
operator|->
name|constructor_chain
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|section
operator|->
name|reloc_count
condition|;
name|count
operator|++
control|)
block|{
operator|*
name|relptr
operator|++
operator|=
operator|&
name|chain
operator|->
name|relent
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|relptr
operator|=
literal|0
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
return|;
block|}
if|if
condition|(
name|tblptr
operator|&&
name|section
operator|->
name|reloc_count
condition|)
block|{
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|++
operator|<
name|section
operator|->
name|reloc_count
condition|;
control|)
operator|*
name|relptr
operator|++
operator|=
name|tblptr
operator|++
expr_stmt|;
operator|*
name|relptr
operator|=
literal|0
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
return|;
block|}
if|if
condition|(
operator|!
name|NAME
argument_list|(
name|aout
argument_list|,
name|slurp_reloc_table
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|tblptr
operator|=
name|section
operator|->
name|relocation
expr_stmt|;
comment|/* fix up howto entries.  */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|++
operator|<
name|section
operator|->
name|reloc_count
condition|;
control|)
block|{
name|c
operator|=
name|tblptr
operator|->
name|howto
operator|-
name|NAME
argument_list|(
name|aout
argument_list|,
name|ext_howto_table
argument_list|)
expr_stmt|;
name|tblptr
operator|->
name|howto
operator|=
operator|&
name|mips_howto_table_ext
index|[
name|c
index|]
expr_stmt|;
operator|*
name|relptr
operator|++
operator|=
name|tblptr
operator|++
expr_stmt|;
block|}
operator|*
name|relptr
operator|=
literal|0
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
return|;
block|}
end_function

begin_function_decl
specifier|static
specifier|const
name|struct
name|aout_backend_data
name|MY
parameter_list|(
name|backend_data
parameter_list|)
init|=
block|{
literal|0
operator|,
comment|/* zmagic contiguous */
function_decl|1
operator|,
comment|/* text incl header */
function_decl|0
operator|,
comment|/* entry is text address */
function_decl|0
operator|,
comment|/* exec_hdr_flags */
function_decl|TARGET_PAGE_SIZE
operator|,
comment|/* text vma */
function_decl|MY_set_sizes
operator|,
function_decl|0
operator|,
comment|/* text size includes exec header */
function_decl|0
operator|,
comment|/* add_dynamic_symbols */
function_decl|0
operator|,
comment|/* add_one_symbol */
function_decl|0
operator|,
comment|/* link_dynamic_object */
function_decl|0
operator|,
comment|/* write_dynamic_symbol */
function_decl|0
operator|,
comment|/* check_dynamic_reloc */
function_decl|0
end_function_decl

begin_comment
comment|/* finish_dynamic_link */
end_comment

begin_decl_stmt
unit|};
specifier|extern
specifier|const
name|bfd_target
name|aout_mips_big_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|bfd_target
name|aout_mips_little_vec
init|=
block|{
literal|"a.out-mips-little"
block|,
comment|/* name */
name|bfd_target_aout_flavour
block|,
name|BFD_ENDIAN_LITTLE
block|,
comment|/* target byte order (little) */
name|BFD_ENDIAN_LITTLE
block|,
comment|/* target headers byte order (little) */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_CODE
operator||
name|SEC_DATA
operator|)
block|,
name|MY_symbol_leading_char
block|,
literal|' '
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* data */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|MY_object_p
block|,
comment|/* bfd_check_format */
name|bfd_generic_archive_p
block|,
name|MY_core_file_p
block|}
block|,
block|{
name|bfd_false
block|,
name|MY_mkobject
block|,
comment|/* bfd_set_format */
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|MY_write_object_contents
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|MY
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|MY
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|MY
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|MY
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|MY
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|MY
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|MY
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|MY
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
operator|&
name|aout_mips_big_vec
block|,
operator|(
name|PTR
operator|)
name|MY_backend_data
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|bfd_target
name|aout_mips_big_vec
init|=
block|{
literal|"a.out-mips-big"
block|,
comment|/* name */
name|bfd_target_aout_flavour
block|,
name|BFD_ENDIAN_BIG
block|,
comment|/* target byte order (big) */
name|BFD_ENDIAN_BIG
block|,
comment|/* target headers byte order (big) */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_CODE
operator||
name|SEC_DATA
operator|)
block|,
name|MY_symbol_leading_char
block|,
literal|' '
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|MY_object_p
block|,
comment|/* bfd_check_format */
name|bfd_generic_archive_p
block|,
name|MY_core_file_p
block|}
block|,
block|{
name|bfd_false
block|,
name|MY_mkobject
block|,
comment|/* bfd_set_format */
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|MY_write_object_contents
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|MY
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|MY
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|MY
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|MY
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|MY
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|MY
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|MY
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|MY
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
operator|&
name|aout_mips_little_vec
block|,
operator|(
name|PTR
operator|)
name|MY_backend_data
block|}
decl_stmt|;
end_decl_stmt

end_unit

