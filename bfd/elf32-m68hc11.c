begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Motorola 68HC11-specific support for 32-bit ELF    Copyright 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.    Contributed by Stephane Carrez (stcarrez@nerim.fr)    (Heavily copied from the D10V port by Martin Hunt (hunt@cygnus.com))  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf32-m68hc1x.h"
end_include

begin_include
include|#
directive|include
file|"elf/m68hc11.h"
end_include

begin_include
include|#
directive|include
file|"opcode/m68hc11.h"
end_include

begin_comment
comment|/* Relocation functions.  */
end_comment

begin_function_decl
specifier|static
name|reloc_howto_type
modifier|*
name|bfd_elf32_bfd_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd_reloc_code_real_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|m68hc11_info_to_howto_rel
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Trampoline generation.  */
end_comment

begin_function_decl
specifier|static
name|bfd_boolean
name|m68hc11_elf_size_one_stub
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|gen_entry
parameter_list|,
name|void
modifier|*
name|in_arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|m68hc11_elf_build_one_stub
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|gen_entry
parameter_list|,
name|void
modifier|*
name|in_arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|m68hc11_elf_bfd_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Linker relaxation.  */
end_comment

begin_function_decl
specifier|static
name|bfd_boolean
name|m68hc11_elf_relax_section
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|bfd_boolean
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|m68hc11_elf_relax_delete_bytes
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|m68hc11_relax_group
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compare_reloc
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Use REL instead of RELA to save space */
end_comment

begin_define
define|#
directive|define
name|USE_REL
value|1
end_define

begin_comment
comment|/* The Motorola 68HC11 microcontroller only addresses 64Kb but we also    support a memory bank switching mechanism similar to 68HC12.    We must handle 8 and 16-bit relocations.  The 32-bit relocation    are used for debugging sections (DWARF2) to represent a virtual    address.    The 3-bit and 16-bit PC rel relocation is only used by 68HC12.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_m68hc11_howto_table
index|[]
init|=
block|{
comment|/* This reloc does nothing.  */
name|HOWTO
argument_list|(
name|R_M68HC11_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M68HC11_NONE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 8 bit absolute relocation */
name|HOWTO
argument_list|(
name|R_M68HC11_8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M68HC11_8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x00ff
argument_list|,
comment|/* src_mask */
literal|0x00ff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 8 bit absolute relocation (upper address) */
name|HOWTO
argument_list|(
name|R_M68HC11_HI8
argument_list|,
comment|/* type */
literal|8
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M68HC11_HI8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x00ff
argument_list|,
comment|/* src_mask */
literal|0x00ff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 8 bit absolute relocation (upper address) */
name|HOWTO
argument_list|(
name|R_M68HC11_LO8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M68HC11_LO8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x00ff
argument_list|,
comment|/* src_mask */
literal|0x00ff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 8 bit PC-rel relocation */
name|HOWTO
argument_list|(
name|R_M68HC11_PCREL_8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M68HC11_PCREL_8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x00ff
argument_list|,
comment|/* src_mask */
literal|0x00ff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit absolute relocation */
name|HOWTO
argument_list|(
name|R_M68HC11_16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
comment|/*bitfield */
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M68HC11_16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32 bit absolute relocation.  This one is never used for the      code relocation.  It's used by gas for -gstabs generation.  */
name|HOWTO
argument_list|(
name|R_M68HC11_32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M68HC11_32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 3 bit absolute relocation */
name|HOWTO
argument_list|(
name|R_M68HC11_3B
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|3
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M68HC11_4B"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x003
argument_list|,
comment|/* src_mask */
literal|0x003
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit PC-rel relocation */
name|HOWTO
argument_list|(
name|R_M68HC11_PCREL_16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M68HC11_PCREL_16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable hierarchy */
name|HOWTO
argument_list|(
name|R_M68HC11_GNU_VTINHERIT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_M68HC11_GNU_VTINHERIT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable member usage */
name|HOWTO
argument_list|(
name|R_M68HC11_GNU_VTENTRY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_elf_rel_vtable_reloc_fn
argument_list|,
comment|/* special_function */
literal|"R_M68HC11_GNU_VTENTRY"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 24 bit relocation */
name|HOWTO
argument_list|(
name|R_M68HC11_24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|24
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M68HC11_24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffff
argument_list|,
comment|/* src_mask */
literal|0xffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16-bit low relocation */
name|HOWTO
argument_list|(
name|R_M68HC11_LO16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M68HC11_LO16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A page relocation */
name|HOWTO
argument_list|(
name|R_M68HC11_PAGE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M68HC11_PAGE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x00ff
argument_list|,
comment|/* src_mask */
literal|0x00ff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|14
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|15
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|16
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|17
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|18
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|19
argument_list|)
block|,
comment|/* Mark beginning of a jump instruction (any form).  */
name|HOWTO
argument_list|(
name|R_M68HC11_RL_JUMP
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|m68hc11_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_M68HC11_RL_JUMP"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Mark beginning of Gcc relaxation group instruction.  */
name|HOWTO
argument_list|(
name|R_M68HC11_RL_GROUP
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|m68hc11_elf_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_M68HC11_RL_GROUP"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map BFD reloc types to M68HC11 ELF reloc types.  */
end_comment

begin_struct
struct|struct
name|m68hc11_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_val
decl_stmt|;
name|unsigned
name|char
name|elf_reloc_val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|m68hc11_reloc_map
name|m68hc11_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_M68HC11_NONE
block|,}
block|,
block|{
name|BFD_RELOC_8
block|,
name|R_M68HC11_8
block|}
block|,
block|{
name|BFD_RELOC_M68HC11_HI8
block|,
name|R_M68HC11_HI8
block|}
block|,
block|{
name|BFD_RELOC_M68HC11_LO8
block|,
name|R_M68HC11_LO8
block|}
block|,
block|{
name|BFD_RELOC_8_PCREL
block|,
name|R_M68HC11_PCREL_8
block|}
block|,
block|{
name|BFD_RELOC_16_PCREL
block|,
name|R_M68HC11_PCREL_16
block|}
block|,
block|{
name|BFD_RELOC_16
block|,
name|R_M68HC11_16
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_M68HC11_32
block|}
block|,
block|{
name|BFD_RELOC_M68HC11_3B
block|,
name|R_M68HC11_3B
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_INHERIT
block|,
name|R_M68HC11_GNU_VTINHERIT
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_ENTRY
block|,
name|R_M68HC11_GNU_VTENTRY
block|}
block|,
block|{
name|BFD_RELOC_M68HC11_LO16
block|,
name|R_M68HC11_LO16
block|}
block|,
block|{
name|BFD_RELOC_M68HC11_PAGE
block|,
name|R_M68HC11_PAGE
block|}
block|,
block|{
name|BFD_RELOC_M68HC11_24
block|,
name|R_M68HC11_24
block|}
block|,
block|{
name|BFD_RELOC_M68HC11_RL_JUMP
block|,
name|R_M68HC11_RL_JUMP
block|}
block|,
block|{
name|BFD_RELOC_M68HC11_RL_GROUP
block|,
name|R_M68HC11_RL_GROUP
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|bfd_elf32_bfd_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|m68hc11_reloc_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|m68hc11_reloc_map
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|m68hc11_reloc_map
index|[
name|i
index|]
operator|.
name|bfd_reloc_val
operator|==
name|code
condition|)
return|return
operator|&
name|elf_m68hc11_howto_table
index|[
name|m68hc11_reloc_map
index|[
name|i
index|]
operator|.
name|elf_reloc_val
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set the howto pointer for an M68HC11 ELF reloc.  */
end_comment

begin_function
specifier|static
name|void
name|m68hc11_info_to_howto_rel
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|cache_ptr
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|dst
parameter_list|)
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r_type
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_M68HC11_max
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf_m68hc11_howto_table
index|[
name|r_type
index|]
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Far trampoline generation.  */
end_comment

begin_comment
comment|/* Build a 68HC11 trampoline stub.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m68hc11_elf_build_one_stub
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|gen_entry
parameter_list|,
name|void
modifier|*
name|in_arg
parameter_list|)
block|{
name|struct
name|elf32_m68hc11_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|m68hc11_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|asection
modifier|*
name|stub_sec
decl_stmt|;
name|bfd
modifier|*
name|stub_bfd
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_vma
name|sym_value
decl_stmt|,
name|phys_page
decl_stmt|,
name|phys_addr
decl_stmt|;
comment|/* Massage our args to the form they really have.  */
name|stub_entry
operator|=
operator|(
expr|struct
name|elf32_m68hc11_stub_hash_entry
operator|*
operator|)
name|gen_entry
expr_stmt|;
name|info
operator|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|in_arg
expr_stmt|;
name|htab
operator|=
name|m68hc11_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|stub_sec
operator|=
name|stub_entry
operator|->
name|stub_sec
expr_stmt|;
comment|/* Make a note of the offset within the stubs for this entry.  */
name|stub_entry
operator|->
name|stub_offset
operator|=
name|stub_sec
operator|->
name|size
expr_stmt|;
name|stub_sec
operator|->
name|size
operator|+=
literal|10
expr_stmt|;
name|loc
operator|=
name|stub_sec
operator|->
name|contents
operator|+
name|stub_entry
operator|->
name|stub_offset
expr_stmt|;
name|stub_bfd
operator|=
name|stub_sec
operator|->
name|owner
expr_stmt|;
comment|/* Create the trampoline call stub:       pshb      ldab #%page(symbol)      ldy #%addr(symbol)      jmp __trampoline    */
name|sym_value
operator|=
operator|(
name|stub_entry
operator|->
name|target_value
operator|+
name|stub_entry
operator|->
name|target_section
operator|->
name|output_offset
operator|+
name|stub_entry
operator|->
name|target_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|phys_addr
operator|=
name|m68hc11_phys_addr
argument_list|(
operator|&
name|htab
operator|->
name|pinfo
argument_list|,
name|sym_value
argument_list|)
expr_stmt|;
name|phys_page
operator|=
name|m68hc11_phys_page
argument_list|(
operator|&
name|htab
operator|->
name|pinfo
argument_list|,
name|sym_value
argument_list|)
expr_stmt|;
comment|/* pshb; ldab #%page(sym) */
name|bfd_put_8
argument_list|(
name|stub_bfd
argument_list|,
literal|0x37
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|stub_bfd
argument_list|,
literal|0xC6
argument_list|,
name|loc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|stub_bfd
argument_list|,
name|phys_page
argument_list|,
name|loc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|3
expr_stmt|;
comment|/* ldy #%addr(sym)  */
name|bfd_put_8
argument_list|(
name|stub_bfd
argument_list|,
literal|0x18
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|stub_bfd
argument_list|,
literal|0xCE
argument_list|,
name|loc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|stub_bfd
argument_list|,
name|phys_addr
argument_list|,
name|loc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|loc
operator|+=
literal|4
expr_stmt|;
comment|/* jmp __trampoline  */
name|bfd_put_8
argument_list|(
name|stub_bfd
argument_list|,
literal|0x7E
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|stub_bfd
argument_list|,
name|htab
operator|->
name|pinfo
operator|.
name|trampoline_addr
argument_list|,
name|loc
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* As above, but don't actually build the stub.  Just bump offset so    we know stub section sizes.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m68hc11_elf_size_one_stub
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|gen_entry
parameter_list|,
name|void
modifier|*
name|in_arg
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|elf32_m68hc11_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
comment|/* Massage our args to the form they really have.  */
name|stub_entry
operator|=
operator|(
expr|struct
name|elf32_m68hc11_stub_hash_entry
operator|*
operator|)
name|gen_entry
expr_stmt|;
name|stub_entry
operator|->
name|stub_sec
operator|->
name|size
operator|+=
literal|10
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create a 68HC11 ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|m68hc11_elf_bfd_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|m68hc11_elf_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|m68hc11_elf_hash_table_create
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|m68hc11_elf_link_hash_table
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
name|ret
operator|->
name|size_one_stub
operator|=
name|m68hc11_elf_size_one_stub
expr_stmt|;
name|ret
operator|->
name|build_one_stub
operator|=
name|m68hc11_elf_build_one_stub
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* 68HC11 Linker Relaxation.  */
end_comment

begin_struct
struct|struct
name|m68hc11_direct_relax
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|char
name|code
decl_stmt|;
name|unsigned
name|char
name|direct_code
decl_stmt|;
block|}
name|m68hc11_direct_relax_table
index|[]
init|=
block|{
block|{
literal|"adca"
block|,
literal|0xB9
block|,
literal|0x99
block|}
block|,
block|{
literal|"adcb"
block|,
literal|0xF9
block|,
literal|0xD9
block|}
block|,
block|{
literal|"adda"
block|,
literal|0xBB
block|,
literal|0x9B
block|}
block|,
block|{
literal|"addb"
block|,
literal|0xFB
block|,
literal|0xDB
block|}
block|,
block|{
literal|"addd"
block|,
literal|0xF3
block|,
literal|0xD3
block|}
block|,
block|{
literal|"anda"
block|,
literal|0xB4
block|,
literal|0x94
block|}
block|,
block|{
literal|"andb"
block|,
literal|0xF4
block|,
literal|0xD4
block|}
block|,
block|{
literal|"cmpa"
block|,
literal|0xB1
block|,
literal|0x91
block|}
block|,
block|{
literal|"cmpb"
block|,
literal|0xF1
block|,
literal|0xD1
block|}
block|,
block|{
literal|"cpd"
block|,
literal|0xB3
block|,
literal|0x93
block|}
block|,
block|{
literal|"cpxy"
block|,
literal|0xBC
block|,
literal|0x9C
block|}
block|,
comment|/* { "cpy",  0xBC, 0x9C }, */
block|{
literal|"eora"
block|,
literal|0xB8
block|,
literal|0x98
block|}
block|,
block|{
literal|"eorb"
block|,
literal|0xF8
block|,
literal|0xD8
block|}
block|,
block|{
literal|"jsr"
block|,
literal|0xBD
block|,
literal|0x9D
block|}
block|,
block|{
literal|"ldaa"
block|,
literal|0xB6
block|,
literal|0x96
block|}
block|,
block|{
literal|"ldab"
block|,
literal|0xF6
block|,
literal|0xD6
block|}
block|,
block|{
literal|"ldd"
block|,
literal|0xFC
block|,
literal|0xDC
block|}
block|,
block|{
literal|"lds"
block|,
literal|0xBE
block|,
literal|0x9E
block|}
block|,
block|{
literal|"ldxy"
block|,
literal|0xFE
block|,
literal|0xDE
block|}
block|,
comment|/*  { "ldy",  0xFE, 0xDE },*/
block|{
literal|"oraa"
block|,
literal|0xBA
block|,
literal|0x9A
block|}
block|,
block|{
literal|"orab"
block|,
literal|0xFA
block|,
literal|0xDA
block|}
block|,
block|{
literal|"sbca"
block|,
literal|0xB2
block|,
literal|0x92
block|}
block|,
block|{
literal|"sbcb"
block|,
literal|0xF2
block|,
literal|0xD2
block|}
block|,
block|{
literal|"staa"
block|,
literal|0xB7
block|,
literal|0x97
block|}
block|,
block|{
literal|"stab"
block|,
literal|0xF7
block|,
literal|0xD7
block|}
block|,
block|{
literal|"std"
block|,
literal|0xFD
block|,
literal|0xDD
block|}
block|,
block|{
literal|"sts"
block|,
literal|0xBF
block|,
literal|0x9F
block|}
block|,
block|{
literal|"stxy"
block|,
literal|0xFF
block|,
literal|0xDF
block|}
block|,
comment|/*  { "sty",  0xFF, 0xDF },*/
block|{
literal|"suba"
block|,
literal|0xB0
block|,
literal|0x90
block|}
block|,
block|{
literal|"subb"
block|,
literal|0xF0
block|,
literal|0xD0
block|}
block|,
block|{
literal|"subd"
block|,
literal|0xB3
block|,
literal|0x93
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|struct
name|m68hc11_direct_relax
modifier|*
name|find_relaxable_insn
parameter_list|(
name|unsigned
name|char
name|code
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|m68hc11_direct_relax_table
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|m68hc11_direct_relax_table
index|[
name|i
index|]
operator|.
name|code
operator|==
name|code
condition|)
return|return
operator|&
name|m68hc11_direct_relax_table
index|[
name|i
index|]
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|compare_reloc
parameter_list|(
specifier|const
name|void
modifier|*
name|e1
parameter_list|,
specifier|const
name|void
modifier|*
name|e2
parameter_list|)
block|{
specifier|const
name|Elf_Internal_Rela
modifier|*
name|i1
init|=
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
name|e1
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|i2
init|=
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
name|e2
decl_stmt|;
if|if
condition|(
name|i1
operator|->
name|r_offset
operator|==
name|i2
operator|->
name|r_offset
condition|)
return|return
literal|0
return|;
else|else
return|return
name|i1
operator|->
name|r_offset
operator|<
name|i2
operator|->
name|r_offset
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|M6811_OP_LDX_IMMEDIATE
value|(0xCE)
end_define

begin_function
specifier|static
name|void
name|m68hc11_relax_group
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|unsigned
name|value
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|end_group
parameter_list|)
block|{
name|unsigned
name|char
name|code
decl_stmt|;
name|unsigned
name|long
name|start_offset
decl_stmt|;
name|unsigned
name|long
name|ldx_offset
init|=
name|offset
decl_stmt|;
name|unsigned
name|long
name|ldx_size
decl_stmt|;
name|int
name|can_delete_ldx
decl_stmt|;
name|int
name|relax_ldy
init|=
literal|0
decl_stmt|;
comment|/* First instruction of the relax group must be a      LDX #value or LDY #value.  If this is not the case,      ignore the relax group.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|0x18
condition|)
block|{
name|relax_ldy
operator|++
expr_stmt|;
name|offset
operator|++
expr_stmt|;
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
name|ldx_size
operator|=
name|offset
operator|-
name|ldx_offset
operator|+
literal|3
expr_stmt|;
name|offset
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|M6811_OP_LDX_IMMEDIATE
operator|||
name|offset
operator|>=
name|end_group
condition|)
return|return;
comment|/* We can remove the LDX/LDY only when all bset/brclr instructions      of the relax group have been converted to use direct addressing      mode.  */
name|can_delete_ldx
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|offset
operator|<
name|end_group
condition|)
block|{
name|unsigned
name|isize
decl_stmt|;
name|unsigned
name|new_value
decl_stmt|;
name|int
name|bset_use_y
decl_stmt|;
name|bset_use_y
operator|=
literal|0
expr_stmt|;
name|start_offset
operator|=
name|offset
expr_stmt|;
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|0x18
condition|)
block|{
name|bset_use_y
operator|++
expr_stmt|;
name|offset
operator|++
expr_stmt|;
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/* Check the instruction and translate to use direct addressing mode.  */
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* bset */
case|case
literal|0x1C
case|:
name|code
operator|=
literal|0x14
expr_stmt|;
name|isize
operator|=
literal|3
expr_stmt|;
break|break;
comment|/* brclr */
case|case
literal|0x1F
case|:
name|code
operator|=
literal|0x13
expr_stmt|;
name|isize
operator|=
literal|4
expr_stmt|;
break|break;
comment|/* brset */
case|case
literal|0x1E
case|:
name|code
operator|=
literal|0x12
expr_stmt|;
name|isize
operator|=
literal|4
expr_stmt|;
break|break;
comment|/* bclr */
case|case
literal|0x1D
case|:
name|code
operator|=
literal|0x15
expr_stmt|;
name|isize
operator|=
literal|3
expr_stmt|;
break|break;
comment|/* This instruction is not recognized and we are not              at end of the relax group.  Ignore and don't remove              the first LDX (we don't know what it is used for...).  */
default|default:
return|return;
block|}
name|new_value
operator|=
operator|(
name|unsigned
operator|)
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|offset
operator|+
literal|1
argument_list|)
expr_stmt|;
name|new_value
operator|+=
name|value
expr_stmt|;
if|if
condition|(
operator|(
name|new_value
operator|&
literal|0xff00
operator|)
operator|==
literal|0
operator|&&
name|bset_use_y
operator|==
name|relax_ldy
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|,
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|new_value
argument_list|,
name|contents
operator|+
name|offset
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_offset
operator|!=
name|offset
condition|)
block|{
name|m68hc11_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|start_offset
argument_list|,
name|offset
operator|-
name|start_offset
argument_list|)
expr_stmt|;
name|end_group
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
name|can_delete_ldx
operator|=
literal|0
expr_stmt|;
block|}
name|offset
operator|=
name|start_offset
operator|+
name|isize
expr_stmt|;
block|}
if|if
condition|(
name|can_delete_ldx
condition|)
block|{
comment|/* Remove the move instruction (3 or 4 bytes win).  */
name|m68hc11_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|ldx_offset
argument_list|,
name|ldx_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function handles relaxing for the 68HC11.   	and somewhat more difficult to support.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m68hc11_elf_relax_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|bfd_boolean
modifier|*
name|again
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|shndx_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|free_relocs
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|bfd_byte
modifier|*
name|free_contents
init|=
name|NULL
decl_stmt|;
name|Elf32_External_Sym
modifier|*
name|free_extsyms
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|prev_insn_branch
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|prev_insn_group
init|=
name|NULL
decl_stmt|;
name|unsigned
name|insn_group_value
init|=
literal|0
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
comment|/* Assume nothing changes.  */
operator|*
name|again
operator|=
name|FALSE
expr_stmt|;
comment|/* We don't have to do anything for a relocatable link, if      this section does not have relocs, or if this is not a      code section.  */
if|if
condition|(
name|link_info
operator|->
name|relocatable
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|sec
operator|->
name|reloc_count
operator|==
literal|0
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|shndx_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_shndx_hdr
expr_stmt|;
comment|/* Get a copy of the native relocations.  */
name|internal_relocs
operator|=
operator|(
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free_relocs
operator|=
name|internal_relocs
expr_stmt|;
comment|/* Checking for branch relaxation relies on the relocations to      be sorted on 'r_offset'.  This is not guaranteed so we must sort.  */
name|qsort
argument_list|(
name|internal_relocs
argument_list|,
name|sec
operator|->
name|reloc_count
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
argument_list|,
name|compare_reloc
argument_list|)
expr_stmt|;
comment|/* Walk through them looking for relaxing opportunities.  */
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|symval
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|int
name|is_far
init|=
literal|0
decl_stmt|;
comment|/* If this isn't something that can be relaxed, then ignore 	 this reloc.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_M68HC11_16
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_M68HC11_RL_JUMP
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_M68HC11_RL_GROUP
condition|)
block|{
name|prev_insn_branch
operator|=
literal|0
expr_stmt|;
name|prev_insn_group
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* Get the section contents if we haven't done so already.  */
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
block|{
comment|/* Get cached copy if it exists.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
comment|/* Go get them off disk.  */
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|&
name|contents
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* Try to eliminate an unconditional 8 bit pc-relative branch 	 which immediately follows a conditional 8 bit pc-relative 	 branch around the unconditional branch.  	    original:		new: 	    bCC lab1		bCC' lab2 	    bra lab2 	   lab1:	       lab1:  	 This happens when the bCC can't reach lab2 at assembly time, 	 but due to other relaxations it can reach at link time.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_M68HC11_RL_JUMP
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|nrel
decl_stmt|;
name|unsigned
name|char
name|code
decl_stmt|;
name|unsigned
name|char
name|roffset
decl_stmt|;
name|prev_insn_branch
operator|=
literal|0
expr_stmt|;
name|prev_insn_group
operator|=
literal|0
expr_stmt|;
comment|/* Do nothing if this reloc is the last byte in the section.  */
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|+
literal|2
operator|>=
name|sec
operator|->
name|size
condition|)
continue|continue;
comment|/* See if the next instruction is an unconditional pc-relative 	     branch, more often than not this test will fail, so we 	     test it first to speed things up.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0x7e
condition|)
continue|continue;
comment|/* Also make sure the next relocation applies to the next 	     instruction and that it's a pc-relative 8 bit branch.  */
name|nrel
operator|=
name|irel
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nrel
operator|==
name|irelend
operator|||
name|irel
operator|->
name|r_offset
operator|+
literal|3
operator|!=
name|nrel
operator|->
name|r_offset
operator|||
name|ELF32_R_TYPE
argument_list|(
name|nrel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_M68HC11_16
condition|)
continue|continue;
comment|/* Make sure our destination immediately follows the 	     unconditional branch.  */
name|roffset
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|roffset
operator|!=
literal|3
condition|)
continue|continue;
name|prev_insn_branch
operator|=
name|irel
expr_stmt|;
name|prev_insn_group
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* Read this BFD's symbols if we haven't done so already.  */
if|if
condition|(
name|isymbuf
operator|==
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Get the value of the symbol referred to by the reloc.  */
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* A local symbol.  */
name|isym
operator|=
name|isymbuf
operator|+
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|is_far
operator|=
name|isym
operator|->
name|st_other
operator|&
name|STO_M68HC12_FAR
expr_stmt|;
name|sym_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|symval
operator|=
operator|(
name|isym
operator|->
name|st_value
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sym_sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|indx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* An external symbol.  */
name|indx
operator|=
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
block|{
comment|/* This appears to be a reference to an undefined                  symbol.  Just ignore it--it will be caught by the                  regular reloc processing.  */
name|prev_insn_branch
operator|=
literal|0
expr_stmt|;
name|prev_insn_group
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|is_far
operator|=
name|h
operator|->
name|other
operator|&
name|STO_M68HC12_FAR
expr_stmt|;
name|isym
operator|=
literal|0
expr_stmt|;
name|sym_sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|symval
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sym_sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_M68HC11_RL_GROUP
condition|)
block|{
name|prev_insn_branch
operator|=
literal|0
expr_stmt|;
name|prev_insn_group
operator|=
literal|0
expr_stmt|;
comment|/* Do nothing if this reloc is the last byte in the section.  */
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|==
name|sec
operator|->
name|size
condition|)
continue|continue;
name|prev_insn_group
operator|=
name|irel
expr_stmt|;
name|insn_group_value
operator|=
name|isym
operator|->
name|st_value
expr_stmt|;
continue|continue;
block|}
comment|/* When we relax some bytes, the size of our section changes.          This affects the layout of next input sections that go in our          output section.  When the symbol is part of another section that          will go in the same output section as the current one, it's          final address may now be incorrect (too far).  We must let the          linker re-compute all section offsets before processing this          reloc.  Code example:                                  Initial             Final          .sect .text            section size = 6    section size = 4          jmp foo          jmp bar          .sect .text.foo_bar    output_offset = 6   output_offset = 4          foo: rts          bar: rts           If we process the reloc now, the jmp bar is replaced by a          relative branch to the initial bar address (output_offset 6).  */
if|if
condition|(
operator|*
name|again
operator|&&
name|sym_sec
operator|!=
name|sec
operator|&&
name|sym_sec
operator|->
name|output_section
operator|==
name|sec
operator|->
name|output_section
condition|)
block|{
name|prev_insn_group
operator|=
literal|0
expr_stmt|;
name|prev_insn_branch
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|value
operator|=
name|symval
expr_stmt|;
comment|/* Try to turn a far branch to a near branch.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_M68HC11_16
operator|&&
name|prev_insn_branch
condition|)
block|{
name|bfd_vma
name|offset
decl_stmt|;
name|unsigned
name|char
name|code
decl_stmt|;
name|offset
operator|=
name|value
operator|-
operator|(
name|prev_insn_branch
operator|->
name|r_offset
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
literal|2
operator|)
expr_stmt|;
comment|/* If the offset is still out of -128..+127 range,              leave that far branch unchanged.  */
if|if
condition|(
operator|(
name|offset
operator|&
literal|0xff80
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|offset
operator|&
literal|0xff80
operator|)
operator|!=
literal|0xff80
condition|)
block|{
name|prev_insn_branch
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* Shrink the branch.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|prev_insn_branch
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|0x7e
condition|)
block|{
name|code
operator|=
literal|0x20
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|,
name|contents
operator|+
name|prev_insn_branch
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xff
argument_list|,
name|contents
operator|+
name|prev_insn_branch
operator|->
name|r_offset
operator|+
literal|1
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_offset
operator|=
name|prev_insn_branch
operator|->
name|r_offset
operator|+
literal|1
expr_stmt|;
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_M68HC11_PCREL_8
argument_list|)
expr_stmt|;
name|m68hc11_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|code
operator|^=
literal|0x1
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|,
name|contents
operator|+
name|prev_insn_branch
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xff
argument_list|,
name|contents
operator|+
name|prev_insn_branch
operator|->
name|r_offset
operator|+
literal|1
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_offset
operator|=
name|prev_insn_branch
operator|->
name|r_offset
operator|+
literal|1
expr_stmt|;
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_M68HC11_PCREL_8
argument_list|)
expr_stmt|;
name|m68hc11_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
name|prev_insn_branch
operator|=
literal|0
expr_stmt|;
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Try to turn a 16 bit address into a 8 bit page0 address.  */
elseif|else
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_M68HC11_16
operator|&&
operator|(
name|value
operator|&
literal|0xff00
operator|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|char
name|code
decl_stmt|;
name|unsigned
name|short
name|offset
decl_stmt|;
name|struct
name|m68hc11_direct_relax
modifier|*
name|rinfo
decl_stmt|;
name|prev_insn_branch
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|value
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|&
literal|0xff00
operator|)
operator|!=
literal|0
condition|)
block|{
name|prev_insn_group
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|prev_insn_group
condition|)
block|{
name|unsigned
name|long
name|old_sec_size
init|=
name|sec
operator|->
name|size
decl_stmt|;
comment|/* Note that we've changed the relocation contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|free_relocs
operator|=
name|NULL
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|free_contents
operator|=
name|NULL
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|isymbuf
expr_stmt|;
name|free_extsyms
operator|=
name|NULL
expr_stmt|;
name|m68hc11_relax_group
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
name|offset
argument_list|,
name|prev_insn_group
operator|->
name|r_offset
argument_list|,
name|insn_group_value
argument_list|)
expr_stmt|;
name|irel
operator|=
name|prev_insn_group
expr_stmt|;
name|prev_insn_group
operator|=
literal|0
expr_stmt|;
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_M68HC11_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|size
operator|!=
name|old_sec_size
condition|)
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
comment|/* Get the opcode.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rinfo
operator|=
name|find_relaxable_insn
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|rinfo
operator|==
literal|0
condition|)
block|{
name|prev_insn_group
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* Note that we've changed the relocation contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|free_relocs
operator|=
name|NULL
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|free_contents
operator|=
name|NULL
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|isymbuf
expr_stmt|;
name|free_extsyms
operator|=
name|NULL
expr_stmt|;
comment|/* Fix the opcode.  */
comment|/* printf ("A relaxable case : 0x%02x (%s)\n",              code, rinfo->name); */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|rinfo
operator|->
name|direct_code
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Delete one byte of data (upper byte of address).  */
name|m68hc11_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_M68HC11_8
argument_list|)
expr_stmt|;
comment|/* That will change things, so, we should relax again.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
name|R_M68HC11_16
operator|&&
operator|!
name|is_far
condition|)
block|{
name|unsigned
name|char
name|code
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|prev_insn_branch
operator|=
literal|0
expr_stmt|;
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|0x7e
operator|||
name|code
operator|==
literal|0xbd
condition|)
block|{
name|offset
operator|=
name|value
operator|-
operator|(
name|irel
operator|->
name|r_offset
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
literal|1
operator|)
expr_stmt|;
name|offset
operator|+=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* If the offset is still out of -128..+127 range,                  leave that far branch unchanged.  */
if|if
condition|(
operator|(
name|offset
operator|&
literal|0xff80
operator|)
operator|==
literal|0
operator|||
operator|(
name|offset
operator|&
literal|0xff80
operator|)
operator|==
literal|0xff80
condition|)
block|{
comment|/* Note that we've changed the relocation contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|free_relocs
operator|=
name|NULL
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|free_contents
operator|=
name|NULL
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|isymbuf
expr_stmt|;
name|free_extsyms
operator|=
name|NULL
expr_stmt|;
comment|/* Shrink the branch.  */
name|code
operator|=
operator|(
name|code
operator|==
literal|0x7e
operator|)
condition|?
literal|0x20
else|:
literal|0x8d
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xff
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_M68HC11_PCREL_8
argument_list|)
expr_stmt|;
name|m68hc11_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* That will change things, so, we should relax again.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
name|prev_insn_branch
operator|=
literal|0
expr_stmt|;
name|prev_insn_group
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|free_relocs
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|free_relocs
argument_list|)
expr_stmt|;
name|free_relocs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|free_contents
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|free_contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the section contents for elf_link_input_bfd.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
block|}
name|free_contents
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|free_extsyms
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|free_extsyms
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the symbols for elf_link_input_bfd.  */
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
block|}
name|free_extsyms
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|free_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_extsyms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_extsyms
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Delete some bytes from a section while relaxing.  */
end_comment

begin_function
specifier|static
name|void
name|m68hc11_elf_relax_delete_bytes
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|unsigned
name|int
name|sec_shndx
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|bfd_vma
name|toaddr
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
decl_stmt|,
modifier|*
name|isym
decl_stmt|,
modifier|*
name|isymend
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|end_hashes
decl_stmt|;
name|unsigned
name|int
name|symcount
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
name|sec_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
name|toaddr
operator|=
name|sec
operator|->
name|size
expr_stmt|;
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
expr_stmt|;
name|irelend
operator|=
name|irel
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
comment|/* Actually delete the bytes.  */
name|memmove
argument_list|(
name|contents
operator|+
name|addr
argument_list|,
name|contents
operator|+
name|addr
operator|+
name|count
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|toaddr
operator|-
name|addr
operator|-
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|sec
operator|->
name|size
operator|-=
name|count
expr_stmt|;
comment|/* Adjust all the relocs.  */
for|for
control|(
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|unsigned
name|char
name|code
decl_stmt|;
name|unsigned
name|char
name|offset
decl_stmt|;
name|unsigned
name|short
name|raddr
decl_stmt|;
name|unsigned
name|long
name|old_offset
decl_stmt|;
name|int
name|branch_pos
decl_stmt|;
name|old_offset
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
comment|/* See if this reloc was for the bytes we have deleted, in which 	 case we no longer care about it.  Don't delete relocs which 	 represent addresses, though.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_M68HC11_RL_JUMP
operator|&&
name|irel
operator|->
name|r_offset
operator|>=
name|addr
operator|&&
name|irel
operator|->
name|r_offset
operator|<
name|addr
operator|+
name|count
condition|)
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_M68HC11_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
name|R_M68HC11_NONE
condition|)
continue|continue;
comment|/* Get the new reloc address.  */
if|if
condition|(
operator|(
name|irel
operator|->
name|r_offset
operator|>
name|addr
operator|&&
name|irel
operator|->
name|r_offset
operator|<
name|toaddr
operator|)
condition|)
name|irel
operator|->
name|r_offset
operator|-=
name|count
expr_stmt|;
comment|/* If this is a PC relative reloc, see if the range it covers          includes the bytes we have deleted.  */
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|R_M68HC11_RL_JUMP
case|:
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* jsr and jmp instruction are also marked with RL_JUMP                  relocs but no adjustment must be made.  */
case|case
literal|0x7e
case|:
case|case
literal|0x9d
case|:
case|case
literal|0xbd
case|:
continue|continue;
case|case
literal|0x12
case|:
case|case
literal|0x13
case|:
name|branch_pos
operator|=
literal|3
expr_stmt|;
name|raddr
operator|=
literal|4
expr_stmt|;
comment|/* Special case when we translate a brclr N,y into brclr *<addr>                  In this case, the 0x18 page2 prefix is removed.                  The reloc offset is not modified but the instruction                  size is reduced by 1.  */
if|if
condition|(
name|old_offset
operator|==
name|addr
condition|)
name|raddr
operator|++
expr_stmt|;
break|break;
case|case
literal|0x1e
case|:
case|case
literal|0x1f
case|:
name|branch_pos
operator|=
literal|3
expr_stmt|;
name|raddr
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|0x18
case|:
name|branch_pos
operator|=
literal|4
expr_stmt|;
name|raddr
operator|=
literal|5
expr_stmt|;
break|break;
default|default:
name|branch_pos
operator|=
literal|1
expr_stmt|;
name|raddr
operator|=
literal|2
expr_stmt|;
break|break;
block|}
name|offset
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
name|branch_pos
argument_list|)
expr_stmt|;
name|raddr
operator|+=
name|old_offset
expr_stmt|;
name|raddr
operator|+=
operator|(
operator|(
name|unsigned
name|short
operator|)
name|offset
operator||
operator|(
operator|(
name|offset
operator|&
literal|0x80
operator|)
condition|?
literal|0xff00
else|:
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|<
name|addr
operator|&&
name|raddr
operator|>
name|addr
condition|)
block|{
name|offset
operator|-=
name|count
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
name|branch_pos
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|>=
name|addr
operator|&&
name|raddr
operator|<=
name|addr
condition|)
block|{
name|offset
operator|+=
name|count
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
name|branch_pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*printf ("Not adjusted 0x%04x [0x%4x 0x%4x]\n", raddr,                 irel->r_offset, addr);*/
block|}
break|break;
block|}
block|}
comment|/* Adjust the local symbols defined in this section.  */
name|isymend
operator|=
name|isymbuf
operator|+
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
name|isym
operator|=
name|isymbuf
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
control|)
block|{
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|sec_shndx
operator|&&
name|isym
operator|->
name|st_value
operator|>
name|addr
operator|&&
name|isym
operator|->
name|st_value
operator|<=
name|toaddr
condition|)
name|isym
operator|->
name|st_value
operator|-=
name|count
expr_stmt|;
block|}
comment|/* Now adjust the global symbols defined in this section.  */
name|symcount
operator|=
operator|(
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|end_hashes
operator|=
name|sym_hashes
operator|+
name|symcount
expr_stmt|;
for|for
control|(
init|;
name|sym_hashes
operator|<
name|end_hashes
condition|;
name|sym_hashes
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|sym_hash
init|=
operator|*
name|sym_hashes
decl_stmt|;
if|if
condition|(
operator|(
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|sec
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|>
name|addr
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|<=
name|toaddr
condition|)
block|{
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|-=
name|count
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Specific sections:    - The .page0 is a data section that is mapped in [0x0000..0x00FF].      Page0 accesses are faster on the M68HC11. Soft registers used by GCC-m6811      are located in .page0.    - The .vectors is the section that represents the interrupt      vectors.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|bfd_elf_special_section
name|elf32_m68hc11_special_sections
index|[]
init|=
block|{
block|{
literal|".eeprom"
block|,
literal|7
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
literal|".page0"
block|,
literal|6
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
literal|".softregs"
block|,
literal|9
block|,
literal|0
block|,
name|SHT_NOBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
literal|".vectors"
block|,
literal|8
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_m68hc11
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_68HC11
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1000
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_m68hc11_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-m68hc11"
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|0
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|m68hc11_info_to_howto_rel
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_relax_section
value|m68hc11_elf_relax_section
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|elf32_m68hc11_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|elf32_m68hc11_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|elf32_m68hc11_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|elf32_m68hc11_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
value|elf32_m68hc11_add_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_special_sections
value|elf32_m68hc11_special_sections
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
define|\
value|m68hc11_elf_bfd_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_free
define|\
value|m68hc11_elf_bfd_link_hash_table_free
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_merge_private_bfd_data
define|\
value|_bfd_m68hc11_elf_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_set_private_flags
value|_bfd_m68hc11_elf_set_private_flags
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_print_private_bfd_data
define|\
value|_bfd_m68hc11_elf_print_private_bfd_data
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

