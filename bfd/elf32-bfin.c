begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ADI Blackfin BFD support for 32-bit ELF.    Copyright 2005, 2006 Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301,    USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/bfin.h"
end_include

begin_include
include|#
directive|include
file|"elf/dwarf2.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_comment
comment|/* FUNCTION : bfin_pltpc_reloc    ABSTRACT : TODO : figure out how to handle pltpc relocs.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|bfin_pltpc_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
name|symbol
name|ATTRIBUTE_UNUSED
parameter_list|,
name|PTR
name|data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|input_section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_reloc_status_type
name|flag
init|=
name|bfd_reloc_ok
decl_stmt|;
return|return
name|flag
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|bfd_reloc_status_type
name|bfin_pcrel24_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|PTR
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_size_type
name|addr
init|=
name|reloc_entry
operator|->
name|address
decl_stmt|;
name|bfd_vma
name|output_base
init|=
literal|0
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
init|=
name|reloc_entry
operator|->
name|howto
decl_stmt|;
name|asection
modifier|*
name|output_section
decl_stmt|;
name|bfd_boolean
name|relocatable
init|=
operator|(
name|output_bfd
operator|!=
name|NULL
operator|)
decl_stmt|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|input_section
argument_list|)
condition|)
return|return
name|bfd_reloc_outofrange
return|;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|==
literal|0
operator|&&
operator|!
name|relocatable
condition|)
return|return
name|bfd_reloc_undefined
return|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|output_section
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|relocatable
condition|)
name|output_base
operator|=
literal|0
expr_stmt|;
else|else
name|output_base
operator|=
name|output_section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
operator|!
name|relocatable
operator|||
operator|!
name|strcmp
argument_list|(
name|symbol
operator|->
name|name
argument_list|,
name|symbol
operator|->
name|section
operator|->
name|name
argument_list|)
condition|)
name|relocation
operator|+=
name|output_base
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
operator|!
name|relocatable
operator|&&
operator|!
name|strcmp
argument_list|(
name|symbol
operator|->
name|name
argument_list|,
name|symbol
operator|->
name|section
operator|->
name|name
argument_list|)
condition|)
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|relocation
operator|-=
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|-=
name|reloc_entry
operator|->
name|address
expr_stmt|;
if|if
condition|(
name|howto
operator|->
name|complain_on_overflow
operator|!=
name|complain_overflow_dont
condition|)
block|{
name|bfd_reloc_status_type
name|status
decl_stmt|;
name|status
operator|=
name|bfd_check_overflow
argument_list|(
name|howto
operator|->
name|complain_on_overflow
argument_list|,
name|howto
operator|->
name|bitsize
argument_list|,
name|howto
operator|->
name|rightshift
argument_list|,
name|bfd_arch_bits_per_address
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|status
return|;
block|}
comment|/* if rightshift is 1 and the number odd, return error.  */
if|if
condition|(
name|howto
operator|->
name|rightshift
operator|&&
operator|(
name|relocation
operator|&
literal|0x01
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"relocation should be even number\n"
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_overflow
return|;
block|}
name|relocation
operator|>>=
operator|(
name|bfd_vma
operator|)
name|howto
operator|->
name|rightshift
expr_stmt|;
comment|/* Shift everything up to where it's going to be used.  */
name|relocation
operator|<<=
operator|(
name|bfd_vma
operator|)
name|howto
operator|->
name|bitpos
expr_stmt|;
if|if
condition|(
name|relocatable
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
name|reloc_entry
operator|->
name|addend
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
block|}
block|{
name|short
name|x
decl_stmt|;
comment|/* We are getting reloc_entry->address 2 byte off from        the start of instruction. Assuming absolute postion        of the reloc data. But, following code had been written assuming        reloc address is starting at begining of instruction.        To compensate that I have increased the value of        relocation by 1 (effectively 2) and used the addr -2 instead of addr.  */
name|relocation
operator|+=
literal|1
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
operator|-
literal|2
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xff00
operator|)
operator||
operator|(
operator|(
name|relocation
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
operator|+
name|addr
operator|-
literal|2
argument_list|)
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
expr_stmt|;
name|x
operator|=
name|relocation
operator|&
literal|0xFFFF
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
expr_stmt|;
block|}
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|bfin_imm16_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|PTR
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_vma
name|relocation
decl_stmt|,
name|x
decl_stmt|;
name|bfd_size_type
name|reloc_addr
init|=
name|reloc_entry
operator|->
name|address
decl_stmt|;
name|bfd_vma
name|output_base
init|=
literal|0
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
init|=
name|reloc_entry
operator|->
name|howto
decl_stmt|;
name|asection
modifier|*
name|output_section
decl_stmt|;
name|bfd_boolean
name|relocatable
init|=
operator|(
name|output_bfd
operator|!=
name|NULL
operator|)
decl_stmt|;
comment|/* Is the address of the relocation really within the section?  */
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|input_section
argument_list|)
condition|)
return|return
name|bfd_reloc_outofrange
return|;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|==
literal|0
operator|&&
operator|!
name|relocatable
condition|)
return|return
name|bfd_reloc_undefined
return|;
name|output_section
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
expr_stmt|;
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
comment|/* Convert input-section-relative symbol value to absolute.  */
if|if
condition|(
name|relocatable
condition|)
name|output_base
operator|=
literal|0
expr_stmt|;
else|else
name|output_base
operator|=
name|output_section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
operator|!
name|relocatable
operator|||
operator|!
name|strcmp
argument_list|(
name|symbol
operator|->
name|name
argument_list|,
name|symbol
operator|->
name|section
operator|->
name|name
argument_list|)
condition|)
name|relocation
operator|+=
name|output_base
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
comment|/* Add in supplied addend.  */
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|relocatable
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
name|reloc_entry
operator|->
name|addend
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
block|}
else|else
block|{
name|reloc_entry
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|howto
operator|->
name|complain_on_overflow
operator|!=
name|complain_overflow_dont
condition|)
block|{
name|bfd_reloc_status_type
name|flag
decl_stmt|;
name|flag
operator|=
name|bfd_check_overflow
argument_list|(
name|howto
operator|->
name|complain_on_overflow
argument_list|,
name|howto
operator|->
name|bitsize
argument_list|,
name|howto
operator|->
name|rightshift
argument_list|,
name|bfd_arch_bits_per_address
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|flag
return|;
block|}
comment|/* Here the variable relocation holds the final address of the      symbol we are relocating against, plus any addend.  */
name|relocation
operator|>>=
operator|(
name|bfd_vma
operator|)
name|howto
operator|->
name|rightshift
expr_stmt|;
name|x
operator|=
name|relocation
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
operator|+
name|reloc_addr
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|bfin_byte4_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|PTR
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_vma
name|relocation
decl_stmt|,
name|x
decl_stmt|;
name|bfd_size_type
name|addr
init|=
name|reloc_entry
operator|->
name|address
decl_stmt|;
name|bfd_vma
name|output_base
init|=
literal|0
decl_stmt|;
name|asection
modifier|*
name|output_section
decl_stmt|;
name|bfd_boolean
name|relocatable
init|=
operator|(
name|output_bfd
operator|!=
name|NULL
operator|)
decl_stmt|;
comment|/* Is the address of the relocation really within the section?  */
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|input_section
argument_list|)
condition|)
return|return
name|bfd_reloc_outofrange
return|;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|==
literal|0
operator|&&
operator|!
name|relocatable
condition|)
return|return
name|bfd_reloc_undefined
return|;
name|output_section
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
expr_stmt|;
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
comment|/* Convert input-section-relative symbol value to absolute.  */
if|if
condition|(
name|relocatable
condition|)
name|output_base
operator|=
literal|0
expr_stmt|;
else|else
name|output_base
operator|=
name|output_section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
operator|(
name|symbol
operator|->
name|name
operator|&&
name|symbol
operator|->
name|section
operator|->
name|name
operator|&&
operator|!
name|strcmp
argument_list|(
name|symbol
operator|->
name|name
argument_list|,
name|symbol
operator|->
name|section
operator|->
name|name
argument_list|)
operator|)
operator|||
operator|!
name|relocatable
condition|)
block|{
name|relocation
operator|+=
name|output_base
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
block|}
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|relocatable
condition|)
block|{
comment|/* This output will be relocatable ... like ld -r. */
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
name|reloc_entry
operator|->
name|addend
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
block|}
else|else
block|{
name|reloc_entry
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Here the variable relocation holds the final address of the      symbol we are relocating against, plus any addend.  */
name|x
operator|=
name|relocation
operator|&
literal|0xFFFF0000
expr_stmt|;
name|x
operator|>>=
literal|16
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
operator|+
name|addr
operator|+
literal|2
argument_list|)
expr_stmt|;
name|x
operator|=
name|relocation
operator|&
literal|0x0000FFFF
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* bfin_bfd_reloc handles the blackfin arithmetic relocations.    Use this instead of bfd_perform_relocation.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|bfin_bfd_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|PTR
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_size_type
name|addr
init|=
name|reloc_entry
operator|->
name|address
decl_stmt|;
name|bfd_vma
name|output_base
init|=
literal|0
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
init|=
name|reloc_entry
operator|->
name|howto
decl_stmt|;
name|asection
modifier|*
name|output_section
decl_stmt|;
name|bfd_boolean
name|relocatable
init|=
operator|(
name|output_bfd
operator|!=
name|NULL
operator|)
decl_stmt|;
comment|/* Is the address of the relocation really within the section?  */
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|input_section
argument_list|)
condition|)
return|return
name|bfd_reloc_outofrange
return|;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|==
literal|0
operator|&&
operator|!
name|relocatable
condition|)
return|return
name|bfd_reloc_undefined
return|;
comment|/* Get symbol value.  (Common symbols are special.)  */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|output_section
operator|=
name|symbol
operator|->
name|section
operator|->
name|output_section
expr_stmt|;
comment|/* Convert input-section-relative symbol value to absolute.  */
if|if
condition|(
name|relocatable
condition|)
name|output_base
operator|=
literal|0
expr_stmt|;
else|else
name|output_base
operator|=
name|output_section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
operator|!
name|relocatable
operator|||
operator|!
name|strcmp
argument_list|(
name|symbol
operator|->
name|name
argument_list|,
name|symbol
operator|->
name|section
operator|->
name|name
argument_list|)
condition|)
name|relocation
operator|+=
name|output_base
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
operator|!
name|relocatable
operator|&&
operator|!
name|strcmp
argument_list|(
name|symbol
operator|->
name|name
argument_list|,
name|symbol
operator|->
name|section
operator|->
name|name
argument_list|)
condition|)
block|{
comment|/* Add in supplied addend.  */
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
block|}
comment|/* Here the variable relocation holds the final address of the      symbol we are relocating against, plus any addend.  */
if|if
condition|(
name|howto
operator|->
name|pc_relative
operator|==
name|TRUE
condition|)
block|{
name|relocation
operator|-=
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|howto
operator|->
name|pcrel_offset
operator|==
name|TRUE
condition|)
name|relocation
operator|-=
name|reloc_entry
operator|->
name|address
expr_stmt|;
block|}
if|if
condition|(
name|relocatable
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
name|reloc_entry
operator|->
name|addend
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
block|}
if|if
condition|(
name|howto
operator|->
name|complain_on_overflow
operator|!=
name|complain_overflow_dont
condition|)
block|{
name|bfd_reloc_status_type
name|status
decl_stmt|;
name|status
operator|=
name|bfd_check_overflow
argument_list|(
name|howto
operator|->
name|complain_on_overflow
argument_list|,
name|howto
operator|->
name|bitsize
argument_list|,
name|howto
operator|->
name|rightshift
argument_list|,
name|bfd_arch_bits_per_address
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|status
return|;
block|}
comment|/* If rightshift is 1 and the number odd, return error.  */
if|if
condition|(
name|howto
operator|->
name|rightshift
operator|&&
operator|(
name|relocation
operator|&
literal|0x01
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"relocation should be even number\n"
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_overflow
return|;
block|}
name|relocation
operator|>>=
operator|(
name|bfd_vma
operator|)
name|howto
operator|->
name|rightshift
expr_stmt|;
comment|/* Shift everything up to where it's going to be used.  */
name|relocation
operator|<<=
operator|(
name|bfd_vma
operator|)
name|howto
operator|->
name|bitpos
expr_stmt|;
define|#
directive|define
name|DOIT
parameter_list|(
name|x
parameter_list|)
define|\
value|x = ( (x& ~howto->dst_mask) | (relocation& howto->dst_mask))
comment|/* handle 8 and 16 bit relocations here. */
switch|switch
condition|(
name|howto
operator|->
name|size
condition|)
block|{
case|case
literal|0
case|:
block|{
name|char
name|x
init|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
block|{
name|unsigned
name|short
name|x
init|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|x
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
return|return
name|bfd_reloc_other
return|;
block|}
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* HOWTO Table for blackfin.    Blackfin relocations are fairly complicated.    Some of the salient features are    a. Even numbered offsets. A number of (not all) relocations are       even numbered. This means that the rightmost bit is not stored.       Needs to right shift by 1 and check to see if value is not odd    b. A relocation can be an expression. An expression takes on       a variety of relocations arranged in a stack.    As a result, we cannot use the standard generic function as special    function. We will have our own, which is very similar to the standard    generic function except that it understands how to get the value from    the relocation stack. .  */
end_comment

begin_define
define|#
directive|define
name|BFIN_RELOC_MIN
value|0
end_define

begin_define
define|#
directive|define
name|BFIN_RELOC_MAX
value|0x21
end_define

begin_define
define|#
directive|define
name|BFIN_GNUEXT_RELOC_MIN
value|0x40
end_define

begin_define
define|#
directive|define
name|BFIN_GNUEXT_RELOC_MAX
value|0x43
end_define

begin_define
define|#
directive|define
name|BFIN_ARELOC_MIN
value|0xE0
end_define

begin_define
define|#
directive|define
name|BFIN_ARELOC_MAX
value|0xF3
end_define

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|bfin_howto_table
index|[]
init|=
block|{
comment|/* This reloc does nothing. .  */
name|HOWTO
argument_list|(
name|R_unused0
argument_list|,
comment|/* type.  */
literal|0
argument_list|,
comment|/* rightshift.  */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long).  */
literal|32
argument_list|,
comment|/* bitsize.  */
name|FALSE
argument_list|,
comment|/* pc_relative.  */
literal|0
argument_list|,
comment|/* bitpos.  */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow.  */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function.  */
literal|"R_unused0"
argument_list|,
comment|/* name.  */
name|FALSE
argument_list|,
comment|/* partial_inplace.  */
literal|0
argument_list|,
comment|/* src_mask.  */
literal|0
argument_list|,
comment|/* dst_mask.  */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset.  */
name|HOWTO
argument_list|(
name|R_pcrel5m2
argument_list|,
comment|/* type.  */
literal|1
argument_list|,
comment|/* rightshift.  */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long)..  */
literal|4
argument_list|,
comment|/* bitsize.  */
name|TRUE
argument_list|,
comment|/* pc_relative.  */
literal|0
argument_list|,
comment|/* bitpos.  */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow.  */
name|bfin_bfd_reloc
argument_list|,
comment|/* special_function.  */
literal|"R_pcrel5m2"
argument_list|,
comment|/* name.  */
name|FALSE
argument_list|,
comment|/* partial_inplace.  */
literal|0
argument_list|,
comment|/* src_mask.  */
literal|0x0000000F
argument_list|,
comment|/* dst_mask.  */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset.  */
name|HOWTO
argument_list|(
name|R_unused1
argument_list|,
comment|/* type.  */
literal|0
argument_list|,
comment|/* rightshift.  */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long).  */
literal|32
argument_list|,
comment|/* bitsize.  */
name|FALSE
argument_list|,
comment|/* pc_relative.  */
literal|0
argument_list|,
comment|/* bitpos.  */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow.  */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function.  */
literal|"R_unused1"
argument_list|,
comment|/* name.  */
name|FALSE
argument_list|,
comment|/* partial_inplace.  */
literal|0
argument_list|,
comment|/* src_mask.  */
literal|0
argument_list|,
comment|/* dst_mask.  */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset.  */
name|HOWTO
argument_list|(
name|R_pcrel10
argument_list|,
comment|/* type.  */
literal|1
argument_list|,
comment|/* rightshift.  */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long).  */
literal|10
argument_list|,
comment|/* bitsize.  */
name|TRUE
argument_list|,
comment|/* pc_relative.  */
literal|0
argument_list|,
comment|/* bitpos.  */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow.  */
name|bfin_bfd_reloc
argument_list|,
comment|/* special_function.  */
literal|"R_pcrel10"
argument_list|,
comment|/* name.  */
name|FALSE
argument_list|,
comment|/* partial_inplace.  */
literal|0
argument_list|,
comment|/* src_mask.  */
literal|0x000003FF
argument_list|,
comment|/* dst_mask.  */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset.  */
name|HOWTO
argument_list|(
name|R_pcrel12_jump
argument_list|,
comment|/* type.  */
literal|1
argument_list|,
comment|/* rightshift.  */
comment|/* the offset is actually 13 bit 				   aligned on a word boundary so 				   only 12 bits have to be used. 				   Right shift the rightmost bit..  */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long).  */
literal|12
argument_list|,
comment|/* bitsize.  */
name|TRUE
argument_list|,
comment|/* pc_relative.  */
literal|0
argument_list|,
comment|/* bitpos.  */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow.  */
name|bfin_bfd_reloc
argument_list|,
comment|/* special_function.  */
literal|"R_pcrel12_jump"
argument_list|,
comment|/* name.  */
name|FALSE
argument_list|,
comment|/* partial_inplace.  */
literal|0
argument_list|,
comment|/* src_mask.  */
literal|0x0FFF
argument_list|,
comment|/* dst_mask.  */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset.  */
name|HOWTO
argument_list|(
name|R_rimm16
argument_list|,
comment|/* type.  */
literal|0
argument_list|,
comment|/* rightshift.  */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long).  */
literal|16
argument_list|,
comment|/* bitsize.  */
name|FALSE
argument_list|,
comment|/* pc_relative.  */
literal|0
argument_list|,
comment|/* bitpos.  */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow.  */
name|bfin_imm16_reloc
argument_list|,
comment|/* special_function.  */
literal|"R_rimm16"
argument_list|,
comment|/* name.  */
name|FALSE
argument_list|,
comment|/* partial_inplace.  */
literal|0
argument_list|,
comment|/* src_mask.  */
literal|0x0000FFFF
argument_list|,
comment|/* dst_mask.  */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset.  */
name|HOWTO
argument_list|(
name|R_luimm16
argument_list|,
comment|/* type.  */
literal|0
argument_list|,
comment|/* rightshift.  */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long).  */
literal|16
argument_list|,
comment|/* bitsize.  */
name|FALSE
argument_list|,
comment|/* pc_relative.  */
literal|0
argument_list|,
comment|/* bitpos.  */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow.  */
name|bfin_imm16_reloc
argument_list|,
comment|/* special_function.  */
literal|"R_luimm16"
argument_list|,
comment|/* name.  */
name|FALSE
argument_list|,
comment|/* partial_inplace.  */
literal|0
argument_list|,
comment|/* src_mask.  */
literal|0x0000FFFF
argument_list|,
comment|/* dst_mask.  */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset.  */
name|HOWTO
argument_list|(
name|R_huimm16
argument_list|,
comment|/* type.  */
literal|16
argument_list|,
comment|/* rightshift.  */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long).  */
literal|16
argument_list|,
comment|/* bitsize.  */
name|FALSE
argument_list|,
comment|/* pc_relative.  */
literal|0
argument_list|,
comment|/* bitpos.  */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow.  */
name|bfin_imm16_reloc
argument_list|,
comment|/* special_function.  */
literal|"R_huimm16"
argument_list|,
comment|/* name.  */
name|FALSE
argument_list|,
comment|/* partial_inplace.  */
literal|0
argument_list|,
comment|/* src_mask.  */
literal|0x0000FFFF
argument_list|,
comment|/* dst_mask.  */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset.  */
name|HOWTO
argument_list|(
name|R_pcrel12_jump_s
argument_list|,
comment|/* type.  */
literal|1
argument_list|,
comment|/* rightshift.  */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long).  */
literal|12
argument_list|,
comment|/* bitsize.  */
name|TRUE
argument_list|,
comment|/* pc_relative.  */
literal|0
argument_list|,
comment|/* bitpos.  */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow.  */
name|bfin_bfd_reloc
argument_list|,
comment|/* special_function.  */
literal|"R_pcrel12_jump_s"
argument_list|,
comment|/* name.  */
name|FALSE
argument_list|,
comment|/* partial_inplace.  */
literal|0
argument_list|,
comment|/* src_mask.  */
literal|0x00000FFF
argument_list|,
comment|/* dst_mask.  */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset.  */
name|HOWTO
argument_list|(
name|R_pcrel24_jump_x
argument_list|,
comment|/* type.  */
literal|1
argument_list|,
comment|/* rightshift.  */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long).  */
literal|24
argument_list|,
comment|/* bitsize.  */
name|TRUE
argument_list|,
comment|/* pc_relative.  */
literal|0
argument_list|,
comment|/* bitpos.  */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow.  */
name|bfin_pcrel24_reloc
argument_list|,
comment|/* special_function.  */
literal|"R_pcrel24_jump_x"
argument_list|,
comment|/* name.  */
name|FALSE
argument_list|,
comment|/* partial_inplace.  */
literal|0
argument_list|,
comment|/* src_mask.  */
literal|0x00FFFFFF
argument_list|,
comment|/* dst_mask.  */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset.  */
name|HOWTO
argument_list|(
name|R_pcrel24
argument_list|,
comment|/* type.  */
literal|1
argument_list|,
comment|/* rightshift.  */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long).  */
literal|24
argument_list|,
comment|/* bitsize.  */
name|TRUE
argument_list|,
comment|/* pc_relative.  */
literal|0
argument_list|,
comment|/* bitpos.  */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow.  */
name|bfin_pcrel24_reloc
argument_list|,
comment|/* special_function.  */
literal|"R_pcrel24"
argument_list|,
comment|/* name.  */
name|FALSE
argument_list|,
comment|/* partial_inplace.  */
literal|0
argument_list|,
comment|/* src_mask.  */
literal|0x00FFFFFF
argument_list|,
comment|/* dst_mask.  */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset.  */
name|HOWTO
argument_list|(
name|R_unusedb
argument_list|,
comment|/* type.  */
literal|0
argument_list|,
comment|/* rightshift.  */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long).  */
literal|32
argument_list|,
comment|/* bitsize.  */
name|FALSE
argument_list|,
comment|/* pc_relative.  */
literal|0
argument_list|,
comment|/* bitpos.  */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow.  */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function.  */
literal|"R_unusedb"
argument_list|,
comment|/* name.  */
name|FALSE
argument_list|,
comment|/* partial_inplace.  */
literal|0
argument_list|,
comment|/* src_mask.  */
literal|0
argument_list|,
comment|/* dst_mask.  */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset.  */
name|HOWTO
argument_list|(
name|R_unusedc
argument_list|,
comment|/* type.  */
literal|0
argument_list|,
comment|/* rightshift.  */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long).  */
literal|32
argument_list|,
comment|/* bitsize.  */
name|FALSE
argument_list|,
comment|/* pc_relative.  */
literal|0
argument_list|,
comment|/* bitpos.  */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow.  */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function.  */
literal|"R_unusedc"
argument_list|,
comment|/* name.  */
name|FALSE
argument_list|,
comment|/* partial_inplace.  */
literal|0
argument_list|,
comment|/* src_mask.  */
literal|0
argument_list|,
comment|/* dst_mask.  */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset.  */
name|HOWTO
argument_list|(
name|R_pcrel24_jump_l
argument_list|,
comment|/* type.  */
literal|1
argument_list|,
comment|/* rightshift.  */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long).  */
literal|24
argument_list|,
comment|/* bitsize.  */
name|TRUE
argument_list|,
comment|/* pc_relative.  */
literal|0
argument_list|,
comment|/* bitpos.  */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow.  */
name|bfin_pcrel24_reloc
argument_list|,
comment|/* special_function.  */
literal|"R_pcrel24_jump_l"
argument_list|,
comment|/* name.  */
name|FALSE
argument_list|,
comment|/* partial_inplace.  */
literal|0
argument_list|,
comment|/* src_mask.  */
literal|0x00FFFFFF
argument_list|,
comment|/* dst_mask.  */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset.  */
name|HOWTO
argument_list|(
name|R_pcrel24_call_x
argument_list|,
comment|/* type.  */
literal|1
argument_list|,
comment|/* rightshift.  */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long).  */
literal|24
argument_list|,
comment|/* bitsize.  */
name|TRUE
argument_list|,
comment|/* pc_relative.  */
literal|0
argument_list|,
comment|/* bitpos.  */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow.  */
name|bfin_pcrel24_reloc
argument_list|,
comment|/* special_function.  */
literal|"R_pcrel24_call_x"
argument_list|,
comment|/* name.  */
name|FALSE
argument_list|,
comment|/* partial_inplace.  */
literal|0
argument_list|,
comment|/* src_mask.  */
literal|0x00FFFFFF
argument_list|,
comment|/* dst_mask.  */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset.  */
name|HOWTO
argument_list|(
name|R_var_eq_symb
argument_list|,
comment|/* type.  */
literal|0
argument_list|,
comment|/* rightshift.  */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long).  */
literal|32
argument_list|,
comment|/* bitsize.  */
name|FALSE
argument_list|,
comment|/* pc_relative.  */
literal|0
argument_list|,
comment|/* bitpos.  */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow.  */
name|bfin_bfd_reloc
argument_list|,
comment|/* special_function.  */
literal|"R_var_eq_symb"
argument_list|,
comment|/* name.  */
name|FALSE
argument_list|,
comment|/* partial_inplace.  */
literal|0
argument_list|,
comment|/* src_mask.  */
literal|0
argument_list|,
comment|/* dst_mask.  */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset.  */
name|HOWTO
argument_list|(
name|R_byte_data
argument_list|,
comment|/* type.  */
literal|0
argument_list|,
comment|/* rightshift.  */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long).  */
literal|8
argument_list|,
comment|/* bitsize.  */
name|FALSE
argument_list|,
comment|/* pc_relative.  */
literal|0
argument_list|,
comment|/* bitpos.  */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow.  */
name|bfin_bfd_reloc
argument_list|,
comment|/* special_function.  */
literal|"R_byte_data"
argument_list|,
comment|/* name.  */
name|FALSE
argument_list|,
comment|/* partial_inplace.  */
literal|0
argument_list|,
comment|/* src_mask.  */
literal|0xFF
argument_list|,
comment|/* dst_mask.  */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset.  */
name|HOWTO
argument_list|(
name|R_byte2_data
argument_list|,
comment|/* type.  */
literal|0
argument_list|,
comment|/* rightshift.  */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long).  */
literal|16
argument_list|,
comment|/* bitsize.  */
name|FALSE
argument_list|,
comment|/* pc_relative.  */
literal|0
argument_list|,
comment|/* bitpos.  */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow.  */
name|bfin_bfd_reloc
argument_list|,
comment|/* special_function.  */
literal|"R_byte2_data"
argument_list|,
comment|/* name.  */
name|FALSE
argument_list|,
comment|/* partial_inplace.  */
literal|0
argument_list|,
comment|/* src_mask.  */
literal|0xFFFF
argument_list|,
comment|/* dst_mask.  */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset.  */
name|HOWTO
argument_list|(
name|R_byte4_data
argument_list|,
comment|/* type.  */
literal|0
argument_list|,
comment|/* rightshift.  */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long).  */
literal|32
argument_list|,
comment|/* bitsize.  */
name|FALSE
argument_list|,
comment|/* pc_relative.  */
literal|0
argument_list|,
comment|/* bitpos.  */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow.  */
name|bfin_byte4_reloc
argument_list|,
comment|/* special_function.  */
literal|"R_byte4_data"
argument_list|,
comment|/* name.  */
name|FALSE
argument_list|,
comment|/* partial_inplace.  */
literal|0
argument_list|,
comment|/* src_mask.  */
literal|0xFFFFFFFF
argument_list|,
comment|/* dst_mask.  */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset.  */
name|HOWTO
argument_list|(
name|R_pcrel11
argument_list|,
comment|/* type.  */
literal|1
argument_list|,
comment|/* rightshift.  */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long).  */
literal|10
argument_list|,
comment|/* bitsize.  */
name|TRUE
argument_list|,
comment|/* pc_relative.  */
literal|0
argument_list|,
comment|/* bitpos.  */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow.  */
name|bfin_bfd_reloc
argument_list|,
comment|/* special_function.  */
literal|"R_pcrel11"
argument_list|,
comment|/* name.  */
name|FALSE
argument_list|,
comment|/* partial_inplace.  */
literal|0
argument_list|,
comment|/* src_mask.  */
literal|0x000003FF
argument_list|,
comment|/* dst_mask.  */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset.  */
comment|/* A 18-bit signed operand with the GOT offset for the address of      the symbol.  */
name|HOWTO
argument_list|(
name|R_BFIN_GOT17M4
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_BFIN_GOT12"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The upper 16 bits of the GOT offset for the address of the      symbol.  */
name|HOWTO
argument_list|(
name|R_BFIN_GOTHI
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_BFIN_GOTHI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The lower 16 bits of the GOT offset for the address of the      symbol.  */
name|HOWTO
argument_list|(
name|R_BFIN_GOTLO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_BFIN_GOTLO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The 32-bit address of the canonical descriptor of a function.  */
name|HOWTO
argument_list|(
name|R_BFIN_FUNCDESC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_BFIN_FUNCDESC"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 12-bit signed operand with the GOT offset for the address of      canonical descriptor of a function.  */
name|HOWTO
argument_list|(
name|R_BFIN_FUNCDESC_GOT17M4
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_BFIN_FUNCDESC_GOT17M4"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The upper 16 bits of the GOT offset for the address of the      canonical descriptor of a function.  */
name|HOWTO
argument_list|(
name|R_BFIN_FUNCDESC_GOTHI
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_BFIN_FUNCDESC_GOTHI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The lower 16 bits of the GOT offset for the address of the      canonical descriptor of a function.  */
name|HOWTO
argument_list|(
name|R_BFIN_FUNCDESC_GOTLO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_BFIN_FUNCDESC_GOTLO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The 32-bit address of the canonical descriptor of a function.  */
name|HOWTO
argument_list|(
name|R_BFIN_FUNCDESC_VALUE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_BFIN_FUNCDESC_VALUE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 12-bit signed operand with the GOT offset for the address of      canonical descriptor of a function.  */
name|HOWTO
argument_list|(
name|R_BFIN_FUNCDESC_GOTOFF17M4
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_BFIN_FUNCDESC_GOTOFF17M4"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The upper 16 bits of the GOT offset for the address of the      canonical descriptor of a function.  */
name|HOWTO
argument_list|(
name|R_BFIN_FUNCDESC_GOTOFFHI
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_BFIN_FUNCDESC_GOTOFFHI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The lower 16 bits of the GOT offset for the address of the      canonical descriptor of a function.  */
name|HOWTO
argument_list|(
name|R_BFIN_FUNCDESC_GOTOFFLO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_BFIN_FUNCDESC_GOTOFFLO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 12-bit signed operand with the GOT offset for the address of      the symbol.  */
name|HOWTO
argument_list|(
name|R_BFIN_GOTOFF17M4
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_BFIN_GOTOFF17M4"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The upper 16 bits of the GOT offset for the address of the      symbol.  */
name|HOWTO
argument_list|(
name|R_BFIN_GOTOFFHI
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_BFIN_GOTOFFHI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The lower 16 bits of the GOT offset for the address of the      symbol.  */
name|HOWTO
argument_list|(
name|R_BFIN_GOTOFFLO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_BFIN_GOTOFFLO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|bfin_gnuext_howto_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|R_pltpc
argument_list|,
comment|/* type.  */
literal|0
argument_list|,
comment|/* rightshift.  */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long).  */
literal|16
argument_list|,
comment|/* bitsize.  */
name|FALSE
argument_list|,
comment|/* pc_relative.  */
literal|0
argument_list|,
comment|/* bitpos.  */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow.  */
name|bfin_pltpc_reloc
argument_list|,
comment|/* special_function.  */
literal|"R_pltpc"
argument_list|,
comment|/* name.  */
name|FALSE
argument_list|,
comment|/* partial_inplace.  */
literal|0xffff
argument_list|,
comment|/* src_mask.  */
literal|0xffff
argument_list|,
comment|/* dst_mask.  */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset.  */
name|HOWTO
argument_list|(
name|R_got
argument_list|,
comment|/* type.  */
literal|0
argument_list|,
comment|/* rightshift.  */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long).  */
literal|16
argument_list|,
comment|/* bitsize.  */
name|FALSE
argument_list|,
comment|/* pc_relative.  */
literal|0
argument_list|,
comment|/* bitpos.  */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow.  */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function.  */
literal|"R_got"
argument_list|,
comment|/* name.  */
name|FALSE
argument_list|,
comment|/* partial_inplace.  */
literal|0x7fff
argument_list|,
comment|/* src_mask.  */
literal|0x7fff
argument_list|,
comment|/* dst_mask.  */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset.  */
comment|/* GNU extension to record C++ vtable hierarchy.  */
name|HOWTO
argument_list|(
name|R_BFIN_GNU_VTINHERIT
argument_list|,
comment|/* type.  */
literal|0
argument_list|,
comment|/* rightshift.  */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long).  */
literal|0
argument_list|,
comment|/* bitsize.  */
name|FALSE
argument_list|,
comment|/* pc_relative.  */
literal|0
argument_list|,
comment|/* bitpos.  */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow.  */
name|NULL
argument_list|,
comment|/* special_function.  */
literal|"R_BFIN_GNU_VTINHERIT"
argument_list|,
comment|/* name.  */
name|FALSE
argument_list|,
comment|/* partial_inplace.  */
literal|0
argument_list|,
comment|/* src_mask.  */
literal|0
argument_list|,
comment|/* dst_mask.  */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset.  */
comment|/* GNU extension to record C++ vtable member usage.  */
name|HOWTO
argument_list|(
argument|R_BFIN_GNU_VTENTRY
argument_list|,
comment|/* type.  */
literal|0
argument_list|,
comment|/* rightshift.  */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long).  */
literal|0
argument_list|,
comment|/* bitsize.  */
argument|FALSE
argument_list|,
comment|/* pc_relative.  */
literal|0
argument_list|,
comment|/* bitpos.  */
argument|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow.  */
argument|_bfd_elf_rel_vtable_reloc_fn
argument_list|,
comment|/* special_function.  */
literal|"R_BFIN_GNU_VTENTRY"
argument_list|,
comment|/* name.  */
argument|FALSE
argument_list|,
comment|/* partial_inplace.  */
literal|0
argument_list|,
comment|/* src_mask.  */
literal|0
argument_list|,
comment|/* dst_mask.  */
argument|FALSE
argument_list|)
comment|/* pcrel_offset.  */
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|bfin_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_val
decl_stmt|;
name|unsigned
name|int
name|bfin_reloc_val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|bfin_reloc_map
name|bfin_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_unused0
block|}
block|,
block|{
name|BFD_RELOC_BFIN_5_PCREL
block|,
name|R_pcrel5m2
block|}
block|,
block|{
name|BFD_RELOC_NONE
block|,
name|R_unused1
block|}
block|,
block|{
name|BFD_RELOC_BFIN_10_PCREL
block|,
name|R_pcrel10
block|}
block|,
block|{
name|BFD_RELOC_BFIN_12_PCREL_JUMP
block|,
name|R_pcrel12_jump
block|}
block|,
block|{
name|BFD_RELOC_BFIN_16_IMM
block|,
name|R_rimm16
block|}
block|,
block|{
name|BFD_RELOC_BFIN_16_LOW
block|,
name|R_luimm16
block|}
block|,
block|{
name|BFD_RELOC_BFIN_16_HIGH
block|,
name|R_huimm16
block|}
block|,
block|{
name|BFD_RELOC_BFIN_12_PCREL_JUMP_S
block|,
name|R_pcrel12_jump_s
block|}
block|,
block|{
name|BFD_RELOC_24_PCREL
block|,
name|R_pcrel24
block|}
block|,
block|{
name|BFD_RELOC_24_PCREL
block|,
name|R_pcrel24
block|}
block|,
block|{
name|BFD_RELOC_BFIN_24_PCREL_JUMP_L
block|,
name|R_pcrel24_jump_l
block|}
block|,
block|{
name|BFD_RELOC_NONE
block|,
name|R_unusedb
block|}
block|,
block|{
name|BFD_RELOC_NONE
block|,
name|R_unusedc
block|}
block|,
block|{
name|BFD_RELOC_BFIN_24_PCREL_CALL_X
block|,
name|R_pcrel24_call_x
block|}
block|,
block|{
name|BFD_RELOC_8
block|,
name|R_byte_data
block|}
block|,
block|{
name|BFD_RELOC_16
block|,
name|R_byte2_data
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_byte4_data
block|}
block|,
block|{
name|BFD_RELOC_BFIN_11_PCREL
block|,
name|R_pcrel11
block|}
block|,
block|{
name|BFD_RELOC_BFIN_GOT
block|,
name|R_got
block|}
block|,
block|{
name|BFD_RELOC_BFIN_PLTPC
block|,
name|R_pltpc
block|}
block|,
block|{
name|BFD_RELOC_BFIN_GOT17M4
block|,
name|R_BFIN_GOT17M4
block|}
block|,
block|{
name|BFD_RELOC_BFIN_GOTHI
block|,
name|R_BFIN_GOTHI
block|}
block|,
block|{
name|BFD_RELOC_BFIN_GOTLO
block|,
name|R_BFIN_GOTLO
block|}
block|,
block|{
name|BFD_RELOC_BFIN_FUNCDESC
block|,
name|R_BFIN_FUNCDESC
block|}
block|,
block|{
name|BFD_RELOC_BFIN_FUNCDESC_GOT17M4
block|,
name|R_BFIN_FUNCDESC_GOT17M4
block|}
block|,
block|{
name|BFD_RELOC_BFIN_FUNCDESC_GOTHI
block|,
name|R_BFIN_FUNCDESC_GOTHI
block|}
block|,
block|{
name|BFD_RELOC_BFIN_FUNCDESC_GOTLO
block|,
name|R_BFIN_FUNCDESC_GOTLO
block|}
block|,
block|{
name|BFD_RELOC_BFIN_FUNCDESC_VALUE
block|,
name|R_BFIN_FUNCDESC_VALUE
block|}
block|,
block|{
name|BFD_RELOC_BFIN_FUNCDESC_GOTOFF17M4
block|,
name|R_BFIN_FUNCDESC_GOTOFF17M4
block|}
block|,
block|{
name|BFD_RELOC_BFIN_FUNCDESC_GOTOFFHI
block|,
name|R_BFIN_FUNCDESC_GOTOFFHI
block|}
block|,
block|{
name|BFD_RELOC_BFIN_FUNCDESC_GOTOFFLO
block|,
name|R_BFIN_FUNCDESC_GOTOFFLO
block|}
block|,
block|{
name|BFD_RELOC_BFIN_GOTOFF17M4
block|,
name|R_BFIN_GOTOFF17M4
block|}
block|,
block|{
name|BFD_RELOC_BFIN_GOTOFFHI
block|,
name|R_BFIN_GOTOFFHI
block|}
block|,
block|{
name|BFD_RELOC_BFIN_GOTOFFLO
block|,
name|R_BFIN_GOTOFFLO
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_INHERIT
block|,
name|R_BFIN_GNU_VTINHERIT
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_ENTRY
block|,
name|R_BFIN_GNU_VTENTRY
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|bfin_info_to_howto
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|cache_ptr
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|dst
parameter_list|)
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|<=
name|BFIN_RELOC_MAX
condition|)
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|bfin_howto_table
index|[
name|r_type
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|>=
name|BFIN_GNUEXT_RELOC_MIN
operator|&&
name|r_type
operator|<=
name|BFIN_GNUEXT_RELOC_MAX
condition|)
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|bfin_gnuext_howto_table
index|[
name|r_type
operator|-
name|BFIN_GNUEXT_RELOC_MIN
index|]
expr_stmt|;
else|else
name|cache_ptr
operator|->
name|howto
operator|=
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a BFD reloc type, return the howto.  */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|bfin_bfd_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|r_type
init|=
name|BFIN_RELOC_MIN
decl_stmt|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|bfin_reloc_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|bfin_reloc_map
index|[
literal|0
index|]
argument_list|)
init|;
operator|--
name|i
condition|;
control|)
if|if
condition|(
name|bfin_reloc_map
index|[
name|i
index|]
operator|.
name|bfd_reloc_val
operator|==
name|code
condition|)
name|r_type
operator|=
name|bfin_reloc_map
index|[
name|i
index|]
operator|.
name|bfin_reloc_val
expr_stmt|;
if|if
condition|(
name|r_type
operator|<=
name|BFIN_RELOC_MAX
operator|&&
name|r_type
operator|>
name|BFIN_RELOC_MIN
condition|)
return|return
operator|&
name|bfin_howto_table
index|[
name|r_type
index|]
return|;
elseif|else
if|if
condition|(
name|r_type
operator|>=
name|BFIN_GNUEXT_RELOC_MIN
operator|&&
name|r_type
operator|<=
name|BFIN_GNUEXT_RELOC_MAX
condition|)
return|return
operator|&
name|bfin_gnuext_howto_table
index|[
name|r_type
operator|-
name|BFIN_GNUEXT_RELOC_MIN
index|]
return|;
return|return
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Given a bfin relocation type, return the howto.  */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|bfin_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|r_type
parameter_list|)
block|{
if|if
condition|(
name|r_type
operator|<=
name|BFIN_RELOC_MAX
condition|)
return|return
operator|&
name|bfin_howto_table
index|[
name|r_type
index|]
return|;
elseif|else
if|if
condition|(
name|r_type
operator|>=
name|BFIN_GNUEXT_RELOC_MIN
operator|&&
name|r_type
operator|<=
name|BFIN_GNUEXT_RELOC_MAX
condition|)
return|return
operator|&
name|bfin_gnuext_howto_table
index|[
name|r_type
operator|-
name|BFIN_GNUEXT_RELOC_MIN
index|]
return|;
return|return
operator|(
name|reloc_howto_type
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the name is a local label.    bfin local labels begin with L$.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|bfin_is_local_label_name
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|)
block|{
if|if
condition|(
name|label
index|[
literal|0
index|]
operator|==
literal|'L'
operator|&&
name|label
index|[
literal|1
index|]
operator|==
literal|'$'
condition|)
return|return
name|TRUE
return|;
return|return
name|_bfd_elf_is_local_label_name
argument_list|(
name|abfd
argument_list|,
name|label
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
name|bfd_elf32_bfinfdpic_vec
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IS_FDPIC
parameter_list|(
name|bfd
parameter_list|)
value|((bfd)->xvec ==&bfd_elf32_bfinfdpic_vec)
end_define

begin_comment
comment|/* An extension of the elf hash table data structure, containing some    additional Blackfin-specific data.  */
end_comment

begin_struct
struct|struct
name|bfinfdpic_elf_link_hash_table
block|{
name|struct
name|elf_link_hash_table
name|elf
decl_stmt|;
comment|/* A pointer to the .got section.  */
name|asection
modifier|*
name|sgot
decl_stmt|;
comment|/* A pointer to the .rel.got section.  */
name|asection
modifier|*
name|sgotrel
decl_stmt|;
comment|/* A pointer to the .rofixup section.  */
name|asection
modifier|*
name|sgotfixup
decl_stmt|;
comment|/* A pointer to the .plt section.  */
name|asection
modifier|*
name|splt
decl_stmt|;
comment|/* A pointer to the .rel.plt section.  */
name|asection
modifier|*
name|spltrel
decl_stmt|;
comment|/* GOT base offset.  */
name|bfd_vma
name|got0
decl_stmt|;
comment|/* Location of the first non-lazy PLT entry, i.e., the number of      bytes taken by lazy PLT entries.  */
name|bfd_vma
name|plt0
decl_stmt|;
comment|/* A hash table holding information about which symbols were      referenced with which PIC-related relocations.  */
name|struct
name|htab
modifier|*
name|relocs_info
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Get the Blackfin ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|bfinfdpic_hash_table
parameter_list|(
name|info
parameter_list|)
define|\
value|((struct bfinfdpic_elf_link_hash_table *) ((info)->hash))
end_define

begin_define
define|#
directive|define
name|bfinfdpic_got_section
parameter_list|(
name|info
parameter_list|)
define|\
value|(bfinfdpic_hash_table (info)->sgot)
end_define

begin_define
define|#
directive|define
name|bfinfdpic_gotrel_section
parameter_list|(
name|info
parameter_list|)
define|\
value|(bfinfdpic_hash_table (info)->sgotrel)
end_define

begin_define
define|#
directive|define
name|bfinfdpic_gotfixup_section
parameter_list|(
name|info
parameter_list|)
define|\
value|(bfinfdpic_hash_table (info)->sgotfixup)
end_define

begin_define
define|#
directive|define
name|bfinfdpic_plt_section
parameter_list|(
name|info
parameter_list|)
define|\
value|(bfinfdpic_hash_table (info)->splt)
end_define

begin_define
define|#
directive|define
name|bfinfdpic_pltrel_section
parameter_list|(
name|info
parameter_list|)
define|\
value|(bfinfdpic_hash_table (info)->spltrel)
end_define

begin_define
define|#
directive|define
name|bfinfdpic_relocs_info
parameter_list|(
name|info
parameter_list|)
define|\
value|(bfinfdpic_hash_table (info)->relocs_info)
end_define

begin_define
define|#
directive|define
name|bfinfdpic_got_initial_offset
parameter_list|(
name|info
parameter_list|)
define|\
value|(bfinfdpic_hash_table (info)->got0)
end_define

begin_define
define|#
directive|define
name|bfinfdpic_plt_initial_offset
parameter_list|(
name|info
parameter_list|)
define|\
value|(bfinfdpic_hash_table (info)->plt0)
end_define

begin_comment
comment|/* Create a Blackfin ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|bfinfdpic_elf_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|bfinfdpic_elf_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|bfinfdpic_elf_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|elf
argument_list|,
name|abfd
argument_list|,
name|_bfd_elf_link_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_hash_entry
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|&
name|ret
operator|->
name|elf
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Decide whether a reference to a symbol can be resolved locally or    not.  If the symbol is protected, we want the local address, but    its function descriptor must be assigned by the dynamic linker.  */
end_comment

begin_define
define|#
directive|define
name|BFINFDPIC_SYM_LOCAL
parameter_list|(
name|INFO
parameter_list|,
name|H
parameter_list|)
define|\
value|(_bfd_elf_symbol_refs_local_p ((H), (INFO), 1) \    || ! elf_hash_table (INFO)->dynamic_sections_created)
end_define

begin_define
define|#
directive|define
name|BFINFDPIC_FUNCDESC_LOCAL
parameter_list|(
name|INFO
parameter_list|,
name|H
parameter_list|)
define|\
value|((H)->dynindx == -1 || ! elf_hash_table (INFO)->dynamic_sections_created)
end_define

begin_comment
comment|/* This structure collects information on what kind of GOT, PLT or    function descriptors are required by relocations that reference a    certain symbol.  */
end_comment

begin_struct
struct|struct
name|bfinfdpic_relocs_info
block|{
comment|/* The index of the symbol, as stored in the relocation r_info, if      we have a local symbol; -1 otherwise.  */
name|long
name|symndx
decl_stmt|;
union|union
block|{
comment|/* The input bfd in which the symbol is defined, if it's a local        symbol.  */
name|bfd
modifier|*
name|abfd
decl_stmt|;
comment|/* If symndx == -1, the hash table entry corresponding to a global        symbol (even if it turns out to bind locally, in which case it        should ideally be replaced with section's symndx + addend).  */
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|}
name|d
union|;
comment|/* The addend of the relocation that references the symbol.  */
name|bfd_vma
name|addend
decl_stmt|;
comment|/* The fields above are used to identify an entry.  The fields below      contain information on how an entry is used and, later on, which      locations it was assigned.  */
comment|/* The following 2 fields record whether the symbol+addend above was      ever referenced with a GOT relocation.  The 17M4 suffix indicates a      GOT17M4 relocation; hilo is used for GOTLO/GOTHI pairs.  */
name|unsigned
name|got17m4
range|:
literal|1
decl_stmt|;
name|unsigned
name|gothilo
range|:
literal|1
decl_stmt|;
comment|/* Whether a FUNCDESC relocation references symbol+addend.  */
name|unsigned
name|fd
range|:
literal|1
decl_stmt|;
comment|/* Whether a FUNCDESC_GOT relocation references symbol+addend.  */
name|unsigned
name|fdgot17m4
range|:
literal|1
decl_stmt|;
name|unsigned
name|fdgothilo
range|:
literal|1
decl_stmt|;
comment|/* Whether a FUNCDESC_GOTOFF relocation references symbol+addend.  */
name|unsigned
name|fdgoff17m4
range|:
literal|1
decl_stmt|;
name|unsigned
name|fdgoffhilo
range|:
literal|1
decl_stmt|;
comment|/* Whether symbol+addend is referenced with GOTOFF17M4, GOTOFFLO or      GOTOFFHI relocations.  The addend doesn't really matter, since we      envision that this will only be used to check whether the symbol      is mapped to the same segment as the got.  */
name|unsigned
name|gotoff
range|:
literal|1
decl_stmt|;
comment|/* Whether symbol+addend is referenced by a LABEL24 relocation.  */
name|unsigned
name|call
range|:
literal|1
decl_stmt|;
comment|/* Whether symbol+addend is referenced by a 32 or FUNCDESC_VALUE      relocation.  */
name|unsigned
name|sym
range|:
literal|1
decl_stmt|;
comment|/* Whether we need a PLT entry for a symbol.  Should be implied by      something like:      (call&& symndx == -1&& ! BFINFDPIC_SYM_LOCAL (info, d.h))  */
name|unsigned
name|plt
range|:
literal|1
decl_stmt|;
comment|/* Whether a function descriptor should be created in this link unit      for symbol+addend.  Should be implied by something like:      (plt || fdgotoff17m4 || fdgotofflohi       || ((fd || fdgot17m4 || fdgothilo)&& (symndx != -1 || BFINFDPIC_FUNCDESC_LOCAL (info, d.h))))  */
name|unsigned
name|privfd
range|:
literal|1
decl_stmt|;
comment|/* Whether a lazy PLT entry is needed for this symbol+addend.      Should be implied by something like:      (privfd&& symndx == -1&& ! BFINFDPIC_SYM_LOCAL (info, d.h)&& ! (info->flags& DF_BIND_NOW))  */
name|unsigned
name|lazyplt
range|:
literal|1
decl_stmt|;
comment|/* Whether we've already emitted GOT relocations and PLT entries as      needed for this symbol.  */
name|unsigned
name|done
range|:
literal|1
decl_stmt|;
comment|/* The number of R_byte4_data, R_BFIN_FUNCDESC and R_BFIN_FUNCDESC_VALUE      relocations referencing the symbol.  */
name|unsigned
name|relocs32
decl_stmt|,
name|relocsfd
decl_stmt|,
name|relocsfdv
decl_stmt|;
comment|/* The number of .rofixups entries and dynamic relocations allocated      for this symbol, minus any that might have already been used.  */
name|unsigned
name|fixups
decl_stmt|,
name|dynrelocs
decl_stmt|;
comment|/* The offsets of the GOT entries assigned to symbol+addend, to the      function descriptor's address, and to a function descriptor,      respectively.  Should be zero if unassigned.  The offsets are      counted from the value that will be assigned to the PIC register,      not from the beginning of the .got section.  */
name|bfd_signed_vma
name|got_entry
decl_stmt|,
name|fdgot_entry
decl_stmt|,
name|fd_entry
decl_stmt|;
comment|/* The offsets of the PLT entries assigned to symbol+addend,      non-lazy and lazy, respectively.  If unassigned, should be      (bfd_vma)-1.  */
name|bfd_vma
name|plt_entry
decl_stmt|,
name|lzplt_entry
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Compute a hash with the key fields of an bfinfdpic_relocs_info entry.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|bfinfdpic_relocs_info_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|entry_
parameter_list|)
block|{
specifier|const
name|struct
name|bfinfdpic_relocs_info
modifier|*
name|entry
init|=
name|entry_
decl_stmt|;
return|return
operator|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
condition|?
operator|(
name|long
operator|)
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|hash
else|:
name|entry
operator|->
name|symndx
operator|+
operator|(
name|long
operator|)
name|entry
operator|->
name|d
operator|.
name|abfd
operator|->
name|id
operator|*
literal|257
operator|)
operator|+
name|entry
operator|->
name|addend
return|;
block|}
end_function

begin_comment
comment|/* Test whether the key fields of two bfinfdpic_relocs_info entries are    identical.  */
end_comment

begin_function
specifier|static
name|int
name|bfinfdpic_relocs_info_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|entry1
parameter_list|,
specifier|const
name|void
modifier|*
name|entry2
parameter_list|)
block|{
specifier|const
name|struct
name|bfinfdpic_relocs_info
modifier|*
name|e1
init|=
name|entry1
decl_stmt|;
specifier|const
name|struct
name|bfinfdpic_relocs_info
modifier|*
name|e2
init|=
name|entry2
decl_stmt|;
return|return
name|e1
operator|->
name|symndx
operator|==
name|e2
operator|->
name|symndx
operator|&&
name|e1
operator|->
name|addend
operator|==
name|e2
operator|->
name|addend
operator|&&
operator|(
name|e1
operator|->
name|symndx
operator|==
operator|-
literal|1
condition|?
name|e1
operator|->
name|d
operator|.
name|h
operator|==
name|e2
operator|->
name|d
operator|.
name|h
else|:
name|e1
operator|->
name|d
operator|.
name|abfd
operator|==
name|e2
operator|->
name|d
operator|.
name|abfd
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find or create an entry in a hash table HT that matches the key    fields of the given ENTRY.  If it's not found, memory for a new    entry is allocated in ABFD's obstack.  */
end_comment

begin_function
specifier|static
name|struct
name|bfinfdpic_relocs_info
modifier|*
name|bfinfdpic_relocs_info_find
parameter_list|(
name|struct
name|htab
modifier|*
name|ht
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|struct
name|bfinfdpic_relocs_info
modifier|*
name|entry
parameter_list|,
name|enum
name|insert_option
name|insert
parameter_list|)
block|{
name|struct
name|bfinfdpic_relocs_info
modifier|*
modifier|*
name|loc
init|=
operator|(
expr|struct
name|bfinfdpic_relocs_info
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|ht
argument_list|,
name|entry
argument_list|,
name|insert
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|loc
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
name|loc
condition|)
return|return
operator|*
name|loc
return|;
operator|*
name|loc
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|loc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|loc
condition|)
return|return
operator|*
name|loc
return|;
operator|(
operator|*
name|loc
operator|)
operator|->
name|symndx
operator|=
name|entry
operator|->
name|symndx
expr_stmt|;
operator|(
operator|*
name|loc
operator|)
operator|->
name|d
operator|=
name|entry
operator|->
name|d
expr_stmt|;
operator|(
operator|*
name|loc
operator|)
operator|->
name|addend
operator|=
name|entry
operator|->
name|addend
expr_stmt|;
operator|(
operator|*
name|loc
operator|)
operator|->
name|plt_entry
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
operator|(
operator|*
name|loc
operator|)
operator|->
name|lzplt_entry
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
return|return
operator|*
name|loc
return|;
block|}
end_function

begin_comment
comment|/* Obtain the address of the entry in HT associated with H's symbol +    addend, creating a new entry if none existed.  ABFD is only used    for memory allocation purposes.  */
end_comment

begin_function
specifier|inline
specifier|static
name|struct
name|bfinfdpic_relocs_info
modifier|*
name|bfinfdpic_relocs_info_for_global
parameter_list|(
name|struct
name|htab
modifier|*
name|ht
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|bfd_vma
name|addend
parameter_list|,
name|enum
name|insert_option
name|insert
parameter_list|)
block|{
name|struct
name|bfinfdpic_relocs_info
name|entry
decl_stmt|;
name|entry
operator|.
name|symndx
operator|=
operator|-
literal|1
expr_stmt|;
name|entry
operator|.
name|d
operator|.
name|h
operator|=
name|h
expr_stmt|;
name|entry
operator|.
name|addend
operator|=
name|addend
expr_stmt|;
return|return
name|bfinfdpic_relocs_info_find
argument_list|(
name|ht
argument_list|,
name|abfd
argument_list|,
operator|&
name|entry
argument_list|,
name|insert
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Obtain the address of the entry in HT associated with the SYMNDXth    local symbol of the input bfd ABFD, plus the addend, creating a new    entry if none existed.  */
end_comment

begin_function
specifier|inline
specifier|static
name|struct
name|bfinfdpic_relocs_info
modifier|*
name|bfinfdpic_relocs_info_for_local
parameter_list|(
name|struct
name|htab
modifier|*
name|ht
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|long
name|symndx
parameter_list|,
name|bfd_vma
name|addend
parameter_list|,
name|enum
name|insert_option
name|insert
parameter_list|)
block|{
name|struct
name|bfinfdpic_relocs_info
name|entry
decl_stmt|;
name|entry
operator|.
name|symndx
operator|=
name|symndx
expr_stmt|;
name|entry
operator|.
name|d
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|entry
operator|.
name|addend
operator|=
name|addend
expr_stmt|;
return|return
name|bfinfdpic_relocs_info_find
argument_list|(
name|ht
argument_list|,
name|abfd
argument_list|,
operator|&
name|entry
argument_list|,
name|insert
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Merge fields set by check_relocs() of two entries that end up being    mapped to the same (presumably global) symbol.  */
end_comment

begin_function
specifier|inline
specifier|static
name|void
name|bfinfdpic_pic_merge_early_relocs_info
parameter_list|(
name|struct
name|bfinfdpic_relocs_info
modifier|*
name|e2
parameter_list|,
name|struct
name|bfinfdpic_relocs_info
specifier|const
modifier|*
name|e1
parameter_list|)
block|{
name|e2
operator|->
name|got17m4
operator||=
name|e1
operator|->
name|got17m4
expr_stmt|;
name|e2
operator|->
name|gothilo
operator||=
name|e1
operator|->
name|gothilo
expr_stmt|;
name|e2
operator|->
name|fd
operator||=
name|e1
operator|->
name|fd
expr_stmt|;
name|e2
operator|->
name|fdgot17m4
operator||=
name|e1
operator|->
name|fdgot17m4
expr_stmt|;
name|e2
operator|->
name|fdgothilo
operator||=
name|e1
operator|->
name|fdgothilo
expr_stmt|;
name|e2
operator|->
name|fdgoff17m4
operator||=
name|e1
operator|->
name|fdgoff17m4
expr_stmt|;
name|e2
operator|->
name|fdgoffhilo
operator||=
name|e1
operator|->
name|fdgoffhilo
expr_stmt|;
name|e2
operator|->
name|gotoff
operator||=
name|e1
operator|->
name|gotoff
expr_stmt|;
name|e2
operator|->
name|call
operator||=
name|e1
operator|->
name|call
expr_stmt|;
name|e2
operator|->
name|sym
operator||=
name|e1
operator|->
name|sym
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Every block of 65535 lazy PLT entries shares a single call to the    resolver, inserted in the 32768th lazy PLT entry (i.e., entry #    32767, counting from 0).  All other lazy PLT entries branch to it    in a single instruction.  */
end_comment

begin_define
define|#
directive|define
name|LZPLT_RESOLVER_EXTRA
value|10
end_define

begin_define
define|#
directive|define
name|LZPLT_NORMAL_SIZE
value|6
end_define

begin_define
define|#
directive|define
name|LZPLT_ENTRIES
value|1362
end_define

begin_define
define|#
directive|define
name|BFINFDPIC_LZPLT_BLOCK_SIZE
value|((bfd_vma) LZPLT_NORMAL_SIZE * LZPLT_ENTRIES + LZPLT_RESOLVER_EXTRA)
end_define

begin_define
define|#
directive|define
name|BFINFDPIC_LZPLT_RESOLV_LOC
value|(LZPLT_NORMAL_SIZE * LZPLT_ENTRIES / 2)
end_define

begin_comment
comment|/* Add a dynamic relocation to the SRELOC section.  */
end_comment

begin_function
specifier|inline
specifier|static
name|bfd_vma
name|_bfinfdpic_add_dyn_reloc
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|asection
modifier|*
name|sreloc
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|int
name|reloc_type
parameter_list|,
name|long
name|dynindx
parameter_list|,
name|bfd_vma
name|addend
parameter_list|,
name|struct
name|bfinfdpic_relocs_info
modifier|*
name|entry
parameter_list|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_vma
name|reloc_offset
decl_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|offset
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|dynindx
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|addend
expr_stmt|;
name|reloc_offset
operator|=
name|sreloc
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|reloc_offset
operator|<
name|sreloc
operator|->
name|size
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|sreloc
operator|->
name|contents
operator|+
name|reloc_offset
argument_list|)
expr_stmt|;
name|sreloc
operator|->
name|reloc_count
operator|++
expr_stmt|;
comment|/* If the entry's index is zero, this relocation was probably to a      linkonce section that got discarded.  We reserved a dynamic      relocation, but it was for another entry than the one we got at      the time of emitting the relocation.  Unfortunately there's no      simple way for us to catch this situation, since the relocation      is cleared right before calling relocate_section, at which point      we no longer know what the relocation used to point to.  */
if|if
condition|(
name|entry
operator|->
name|symndx
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|entry
operator|->
name|dynrelocs
operator|>
literal|0
argument_list|)
expr_stmt|;
name|entry
operator|->
name|dynrelocs
operator|--
expr_stmt|;
block|}
return|return
name|reloc_offset
return|;
block|}
end_function

begin_comment
comment|/* Add a fixup to the ROFIXUP section.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|_bfinfdpic_add_rofixup
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|asection
modifier|*
name|rofixup
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|struct
name|bfinfdpic_relocs_info
modifier|*
name|entry
parameter_list|)
block|{
name|bfd_vma
name|fixup_offset
decl_stmt|;
if|if
condition|(
name|rofixup
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
condition|)
return|return
operator|-
literal|1
return|;
name|fixup_offset
operator|=
name|rofixup
operator|->
name|reloc_count
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|rofixup
operator|->
name|contents
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|fixup_offset
operator|<
name|rofixup
operator|->
name|size
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|offset
argument_list|,
name|rofixup
operator|->
name|contents
operator|+
name|fixup_offset
argument_list|)
expr_stmt|;
block|}
name|rofixup
operator|->
name|reloc_count
operator|++
expr_stmt|;
if|if
condition|(
name|entry
operator|&&
name|entry
operator|->
name|symndx
condition|)
block|{
comment|/* See discussion about symndx == 0 in _bfinfdpic_add_dyn_reloc 	 above.  */
name|BFD_ASSERT
argument_list|(
name|entry
operator|->
name|fixups
operator|>
literal|0
argument_list|)
expr_stmt|;
name|entry
operator|->
name|fixups
operator|--
expr_stmt|;
block|}
return|return
name|fixup_offset
return|;
block|}
end_function

begin_comment
comment|/* Find the segment number in which OSEC, and output section, is    located.  */
end_comment

begin_function
specifier|static
name|unsigned
name|_bfinfdpic_osec_to_segment
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|asection
modifier|*
name|osec
parameter_list|)
block|{
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|p
decl_stmt|;
comment|/* Find the segment that contains the output_section.  */
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|segment_map
operator|,
name|p
operator|=
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|phdr
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
operator|,
name|p
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|m
operator|->
name|count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|m
operator|->
name|sections
index|[
name|i
index|]
operator|==
name|osec
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
break|break;
block|}
return|return
name|p
operator|-
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|phdr
return|;
block|}
end_function

begin_function
specifier|inline
specifier|static
name|bfd_boolean
name|_bfinfdpic_osec_readonly_p
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|asection
modifier|*
name|osec
parameter_list|)
block|{
name|unsigned
name|seg
init|=
name|_bfinfdpic_osec_to_segment
argument_list|(
name|output_bfd
argument_list|,
name|osec
argument_list|)
decl_stmt|;
return|return
operator|!
operator|(
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|phdr
index|[
name|seg
index|]
operator|.
name|p_flags
operator|&
name|PF_W
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate relocations for GOT entries, function descriptors, and    code for PLT and lazy PLT entries.  */
end_comment

begin_function
specifier|inline
specifier|static
name|bfd_boolean
name|_bfinfdpic_emit_got_relocs_plt_entries
parameter_list|(
name|struct
name|bfinfdpic_relocs_info
modifier|*
name|entry
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|,
name|bfd_vma
name|addend
parameter_list|)
block|{
name|bfd_vma
name|fd_lazy_rel_offset
init|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|dynindx
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|done
condition|)
return|return
name|TRUE
return|;
name|entry
operator|->
name|done
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|got_entry
operator|||
name|entry
operator|->
name|fdgot_entry
operator|||
name|entry
operator|->
name|fd_entry
condition|)
block|{
comment|/* If the symbol is dynamic, consider it for dynamic 	 relocations, otherwise decay to section + offset.  */
if|if
condition|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
name|dynindx
operator|=
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|dynindx
expr_stmt|;
else|else
block|{
if|if
condition|(
name|sec
operator|->
name|output_section
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
operator|&&
operator|!
name|bfd_is_und_section
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
condition|)
name|dynindx
operator|=
name|elf_section_data
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
operator|->
name|dynindx
expr_stmt|;
else|else
name|dynindx
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Generate relocation for GOT entry pointing to the symbol.  */
if|if
condition|(
name|entry
operator|->
name|got_entry
condition|)
block|{
name|int
name|idx
init|=
name|dynindx
decl_stmt|;
name|bfd_vma
name|ad
init|=
name|addend
decl_stmt|;
comment|/* If the symbol is dynamic but binds locally, use 	 section+offset.  */
if|if
condition|(
name|sec
operator|&&
operator|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|BFINFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
condition|)
name|ad
operator|+=
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
else|else
name|ad
operator|+=
name|sym
operator|->
name|st_value
expr_stmt|;
name|ad
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|output_section
operator|&&
name|elf_section_data
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
condition|)
name|idx
operator|=
name|elf_section_data
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
operator|->
name|dynindx
expr_stmt|;
else|else
name|idx
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we're linking an executable at a fixed address, we can 	 omit the dynamic relocation as long as the symbol is local to 	 this module.  */
if|if
condition|(
name|info
operator|->
name|executable
operator|&&
operator|!
name|info
operator|->
name|pie
operator|&&
operator|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|BFINFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|sec
condition|)
name|ad
operator|+=
name|sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
condition|)
name|_bfinfdpic_add_rofixup
argument_list|(
name|output_bfd
argument_list|,
name|bfinfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|bfinfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|got_entry
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
name|_bfinfdpic_add_dyn_reloc
argument_list|(
name|output_bfd
argument_list|,
name|bfinfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|bfinfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|got_entry
argument_list|)
operator|+
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
argument_list|,
name|R_byte4_data
argument_list|,
name|idx
argument_list|,
name|ad
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|ad
argument_list|,
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|+
name|bfinfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|got_entry
argument_list|)
expr_stmt|;
block|}
comment|/* Generate relocation for GOT entry pointing to a canonical      function descriptor.  */
if|if
condition|(
name|entry
operator|->
name|fdgot_entry
condition|)
block|{
name|int
name|reloc
decl_stmt|,
name|idx
decl_stmt|;
name|bfd_vma
name|ad
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|&&
name|BFINFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|)
condition|)
block|{
comment|/* If the symbol is dynamic and there may be dynamic symbol 	     resolution because we are, or are linked with, a shared 	     library, emit a FUNCDESC relocation such that the dynamic 	     linker will allocate the function descriptor.  If the 	     symbol needs a non-local function descriptor but binds 	     locally (e.g., its visibility is protected, emit a 	     dynamic relocation decayed to section+offset.  */
if|if
condition|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|BFINFDPIC_FUNCDESC_LOCAL
argument_list|(
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|&&
name|BFINFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|&&
operator|!
operator|(
name|info
operator|->
name|executable
operator|&&
operator|!
name|info
operator|->
name|pie
operator|)
condition|)
block|{
name|reloc
operator|=
name|R_BFIN_FUNCDESC
expr_stmt|;
name|idx
operator|=
name|elf_section_data
argument_list|(
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
argument_list|)
operator|->
name|dynindx
expr_stmt|;
name|ad
operator|=
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|BFINFDPIC_FUNCDESC_LOCAL
argument_list|(
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
condition|)
block|{
name|reloc
operator|=
name|R_BFIN_FUNCDESC
expr_stmt|;
name|idx
operator|=
name|dynindx
expr_stmt|;
name|ad
operator|=
name|addend
expr_stmt|;
if|if
condition|(
name|ad
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
comment|/* Otherwise, we know we have a private function descriptor, 		 so reference it directly.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
name|BFD_ASSERT
argument_list|(
name|entry
operator|->
name|privfd
argument_list|)
expr_stmt|;
name|reloc
operator|=
name|R_byte4_data
expr_stmt|;
name|idx
operator|=
name|elf_section_data
argument_list|(
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
argument_list|)
operator|->
name|dynindx
expr_stmt|;
name|ad
operator|=
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|bfinfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|fd_entry
expr_stmt|;
block|}
comment|/* If there is room for dynamic symbol resolution, emit the 	     dynamic relocation.  However, if we're linking an 	     executable at a fixed location, we won't have emitted a 	     dynamic symbol entry for the got section, so idx will be 	     zero, which means we can and should compute the address 	     of the private descriptor ourselves.  */
if|if
condition|(
name|info
operator|->
name|executable
operator|&&
operator|!
name|info
operator|->
name|pie
operator|&&
operator|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|BFINFDPIC_FUNCDESC_LOCAL
argument_list|(
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|)
condition|)
block|{
name|ad
operator|+=
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|_bfinfdpic_add_rofixup
argument_list|(
name|output_bfd
argument_list|,
name|bfinfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|bfinfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|fdgot_entry
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
name|_bfinfdpic_add_dyn_reloc
argument_list|(
name|output_bfd
argument_list|,
name|bfinfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|bfinfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|fdgot_entry
argument_list|)
operator|+
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
argument_list|,
name|reloc
argument_list|,
name|idx
argument_list|,
name|ad
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|ad
argument_list|,
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|+
name|bfinfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|fdgot_entry
argument_list|)
expr_stmt|;
block|}
comment|/* Generate relocation to fill in a private function descriptor in      the GOT.  */
if|if
condition|(
name|entry
operator|->
name|fd_entry
condition|)
block|{
name|int
name|idx
init|=
name|dynindx
decl_stmt|;
name|bfd_vma
name|ad
init|=
name|addend
decl_stmt|;
name|bfd_vma
name|ofst
decl_stmt|;
name|long
name|lowword
decl_stmt|,
name|highword
decl_stmt|;
comment|/* If the symbol is dynamic but binds locally, use 	 section+offset.  */
if|if
condition|(
name|sec
operator|&&
operator|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|BFINFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
condition|)
name|ad
operator|+=
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
else|else
name|ad
operator|+=
name|sym
operator|->
name|st_value
expr_stmt|;
name|ad
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|output_section
operator|&&
name|elf_section_data
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
condition|)
name|idx
operator|=
name|elf_section_data
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
operator|->
name|dynindx
expr_stmt|;
else|else
name|idx
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we're linking an executable at a fixed address, we can 	 omit the dynamic relocation as long as the symbol is local to 	 this module.  */
if|if
condition|(
name|info
operator|->
name|executable
operator|&&
operator|!
name|info
operator|->
name|pie
operator|&&
operator|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|BFINFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|sec
condition|)
name|ad
operator|+=
name|sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|ofst
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
condition|)
block|{
name|_bfinfdpic_add_rofixup
argument_list|(
name|output_bfd
argument_list|,
name|bfinfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|bfinfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|fd_entry
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|_bfinfdpic_add_rofixup
argument_list|(
name|output_bfd
argument_list|,
name|bfinfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|bfinfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|fd_entry
operator|+
literal|4
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ofst
operator|=
name|_bfinfdpic_add_dyn_reloc
argument_list|(
name|output_bfd
argument_list|,
name|entry
operator|->
name|lazyplt
condition|?
name|bfinfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
else|:
name|bfinfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|bfinfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|fd_entry
argument_list|)
operator|+
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
argument_list|,
name|R_BFIN_FUNCDESC_VALUE
argument_list|,
name|idx
argument_list|,
name|ad
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
comment|/* If we've omitted the dynamic relocation, just emit the fixed 	 addresses of the symbol and of the local GOT base offset.  */
if|if
condition|(
name|info
operator|->
name|executable
operator|&&
operator|!
name|info
operator|->
name|pie
operator|&&
name|sec
operator|&&
name|sec
operator|->
name|output_section
condition|)
block|{
name|lowword
operator|=
name|ad
expr_stmt|;
name|highword
operator|=
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|bfinfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|lazyplt
condition|)
block|{
if|if
condition|(
name|ad
condition|)
return|return
name|FALSE
return|;
name|fd_lazy_rel_offset
operator|=
name|ofst
expr_stmt|;
comment|/* A function descriptor used for lazy or local resolving is 	     initialized such that its high word contains the output 	     section index in which the PLT entries are located, and 	     the low word contains the address of the lazy PLT entry 	     entry point, that must be within the memory region 	     assigned to that section.  */
name|lowword
operator|=
name|entry
operator|->
name|lzplt_entry
operator|+
literal|4
operator|+
name|bfinfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|bfinfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|highword
operator|=
name|_bfinfdpic_osec_to_segment
argument_list|(
name|output_bfd
argument_list|,
name|bfinfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* A function descriptor for a local function gets the index 	     of the section.  For a non-local function, it's 	     disregarded.  */
name|lowword
operator|=
name|ad
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|dynindx
operator|==
name|idx
condition|)
name|highword
operator|=
literal|0
expr_stmt|;
else|else
name|highword
operator|=
name|_bfinfdpic_osec_to_segment
argument_list|(
name|output_bfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|)
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|lowword
argument_list|,
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|+
name|bfinfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|fd_entry
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|highword
argument_list|,
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|+
name|bfinfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|fd_entry
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Generate code for the PLT entry.  */
if|if
condition|(
name|entry
operator|->
name|plt_entry
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|bfd_byte
modifier|*
name|plt_code
init|=
name|bfinfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|+
name|entry
operator|->
name|plt_entry
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|entry
operator|->
name|fd_entry
argument_list|)
expr_stmt|;
comment|/* Figure out what kind of PLT entry we need, depending on the 	 location of the function descriptor within the GOT.  */
if|if
condition|(
name|entry
operator|->
name|fd_entry
operator|>=
operator|-
operator|(
literal|1
operator|<<
operator|(
literal|18
operator|-
literal|1
operator|)
operator|)
operator|&&
name|entry
operator|->
name|fd_entry
operator|+
literal|4
operator|<
operator|(
literal|1
operator|<<
operator|(
literal|18
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* P1 = [P3 + fd_entry]; P3 = [P3 + fd_entry + 4] */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0xe519
operator||
operator|(
operator|(
name|entry
operator|->
name|fd_entry
operator|<<
literal|14
operator|)
operator|&
literal|0xFFFF0000
operator|)
argument_list|,
name|plt_code
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0xe51b
operator||
operator|(
operator|(
operator|(
name|entry
operator|->
name|fd_entry
operator|+
literal|4
operator|)
operator|<<
literal|14
operator|)
operator|&
literal|0xFFFF0000
operator|)
argument_list|,
name|plt_code
operator|+
literal|4
argument_list|)
expr_stmt|;
name|plt_code
operator|+=
literal|8
expr_stmt|;
block|}
else|else
block|{
comment|/* P1.L = fd_entry; P1.H = fd_entry; 	     P3 = P3 + P1; 	     P1 = [P3]; 	     P3 = [P3 + 4];  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0xe109
operator||
operator|(
name|entry
operator|->
name|fd_entry
operator|<<
literal|16
operator|)
argument_list|,
name|plt_code
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0xe149
operator||
operator|(
name|entry
operator|->
name|fd_entry
operator|&
literal|0xFFFF0000
operator|)
argument_list|,
name|plt_code
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|output_bfd
argument_list|,
literal|0x5ad9
argument_list|,
name|plt_code
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|output_bfd
argument_list|,
literal|0x9159
argument_list|,
name|plt_code
operator|+
literal|10
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|output_bfd
argument_list|,
literal|0xac5b
argument_list|,
name|plt_code
operator|+
literal|12
argument_list|)
expr_stmt|;
name|plt_code
operator|+=
literal|14
expr_stmt|;
block|}
comment|/* JUMP (P1) */
name|bfd_put_16
argument_list|(
name|output_bfd
argument_list|,
literal|0x0051
argument_list|,
name|plt_code
argument_list|)
expr_stmt|;
block|}
comment|/* Generate code for the lazy PLT entry.  */
if|if
condition|(
name|entry
operator|->
name|lzplt_entry
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|bfd_byte
modifier|*
name|lzplt_code
init|=
name|bfinfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|+
name|entry
operator|->
name|lzplt_entry
decl_stmt|;
name|bfd_vma
name|resolverStub_addr
decl_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|fd_lazy_rel_offset
argument_list|,
name|lzplt_code
argument_list|)
expr_stmt|;
name|lzplt_code
operator|+=
literal|4
expr_stmt|;
name|resolverStub_addr
operator|=
name|entry
operator|->
name|lzplt_entry
operator|/
name|BFINFDPIC_LZPLT_BLOCK_SIZE
operator|*
name|BFINFDPIC_LZPLT_BLOCK_SIZE
operator|+
name|BFINFDPIC_LZPLT_RESOLV_LOC
expr_stmt|;
if|if
condition|(
name|resolverStub_addr
operator|>=
name|bfinfdpic_plt_initial_offset
argument_list|(
name|info
argument_list|)
condition|)
name|resolverStub_addr
operator|=
name|bfinfdpic_plt_initial_offset
argument_list|(
name|info
argument_list|)
operator|-
name|LZPLT_NORMAL_SIZE
operator|-
name|LZPLT_RESOLVER_EXTRA
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|lzplt_entry
operator|==
name|resolverStub_addr
condition|)
block|{
comment|/* This is a lazy PLT entry that includes a resolver call. 	     P2 = [P3]; 	     R3 = [P3 + 4]; 	     JUMP (P2);  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0xa05b915a
argument_list|,
name|lzplt_code
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|output_bfd
argument_list|,
literal|0x0052
argument_list|,
name|lzplt_code
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* JUMP.S  resolverStub */
name|bfd_put_16
argument_list|(
name|output_bfd
argument_list|,
literal|0x2000
operator||
operator|(
operator|(
operator|(
name|resolverStub_addr
operator|-
name|entry
operator|->
name|lzplt_entry
operator|)
operator|/
literal|2
operator|)
operator|&
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|12
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|lzplt_code
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase, and    allocate space in the global offset table or procedure linkage    table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|bfin_check_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|NULL
expr_stmt|;
name|srelgot
operator|=
name|NULL
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
comment|/* This relocation describes the C++ object vtable hierarchy.            Reconstruct it for later use during GC.  */
case|case
name|R_BFIN_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries            are actually used.  Record for later use during GC.  */
case|case
name|R_BFIN_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|R_got
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* Fall through.  */
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
block|{
comment|/* Create the .got section.  */
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
block|{
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|srelgot
operator|==
name|NULL
operator|&&
operator|(
name|h
operator|!=
name|NULL
operator|||
name|info
operator|->
name|shared
operator|)
condition|)
block|{
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srelgot
operator|==
name|NULL
condition|)
block|{
name|srelgot
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srelgot
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|srelgot
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|srelgot
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|==
literal|0
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Allocate space in the .got section.  */
name|sgot
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
comment|/* Allocate relocation space.  */
name|srelgot
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
name|h
operator|->
name|got
operator|.
name|refcount
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a global offset table entry for a local symbol.  */
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|size
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|size
operator|*=
sizeof|sizeof
argument_list|(
name|bfd_signed_vma
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
operator|(
operator|(
name|bfd_signed_vma
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_got_refcounts
expr_stmt|;
block|}
if|if
condition|(
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|==
literal|0
condition|)
block|{
name|sgot
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* If we are generating a shared object, we need to 		         output a R_68K_RELATIVE reloc so that the dynamic 		         linker can adjust this GOT entry.  */
name|srelgot
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
block|}
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|++
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|elf_reloc_type_class
name|elf32_bfin_reloc_type_class
parameter_list|(
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rela
parameter_list|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|ELF32_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
condition|)
block|{
default|default:
return|return
name|reloc_class_normal
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Relocate an Blackfin ELF section.     The RELOCATE_SECTION function is called by the new ELF backend linker    to handle the relocations for a section.     The relocs are always passed as Rela structures; if the section    actually uses Rel structures, the r_addend field will always be    zero.     This function is responsible for adjusting the section contents as    necessary, and (if using Rela relocs and generating a relocatable    output file) adjusting the reloc addend as necessary.     This function does not have to worry about setting the reloc    address or the reloc symbol index.     LOCAL_SYMS is a pointer to the swapped in local symbols.     LOCAL_SECTIONS is an array giving the section in the input file    corresponding to the st_shndx field of each local symbol.     The global hash table entry for the global symbols can be found    via elf_sym_hashes (input_bfd).     When generating relocatable output, this function must handle    STB_LOCAL/STT_SECTION symbols specially.  The output symbol is    going to be the section symbol corresponding to the output    section, which means that the addend must be adjusted    accordingly.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|bfinfdpic_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|unsigned
name|isec_segment
decl_stmt|,
name|got_segment
decl_stmt|,
name|plt_segment
decl_stmt|,
name|check_segment
index|[
literal|2
index|]
decl_stmt|;
name|int
name|silence_segment_error
init|=
operator|!
operator|(
name|info
operator|->
name|shared
operator|||
name|info
operator|->
name|pie
operator|)
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
name|isec_segment
operator|=
name|_bfinfdpic_osec_to_segment
argument_list|(
name|output_bfd
argument_list|,
name|input_section
operator|->
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_FDPIC
argument_list|(
name|output_bfd
argument_list|)
operator|&&
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
condition|)
name|got_segment
operator|=
name|_bfinfdpic_osec_to_segment
argument_list|(
name|output_bfd
argument_list|,
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
argument_list|)
expr_stmt|;
else|else
name|got_segment
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|IS_FDPIC
argument_list|(
name|output_bfd
argument_list|)
operator|&&
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
name|plt_segment
operator|=
name|_bfinfdpic_osec_to_segment
argument_list|(
name|output_bfd
argument_list|,
name|bfinfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
argument_list|)
expr_stmt|;
else|else
name|plt_segment
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|int
name|r_type
decl_stmt|;
name|asection
modifier|*
name|osec
decl_stmt|;
name|struct
name|bfinfdpic_relocs_info
modifier|*
name|picrel
decl_stmt|;
name|bfd_vma
name|orig_addend
init|=
name|rel
operator|->
name|r_addend
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_BFIN_GNU_VTINHERIT
operator|||
name|r_type
operator|==
name|R_BFIN_GNU_VTENTRY
condition|)
continue|continue;
comment|/* This is a final link.  */
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|howto
operator|=
name|bfin_reloc_type_lookup
argument_list|(
name|input_bfd
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|howto
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|osec
operator|=
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|name
operator|==
name|NULL
operator|)
condition|?
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
else|:
name|name
expr_stmt|;
block|}
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|!
name|BFINFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|sec
operator|=
name|NULL
expr_stmt|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|unresolved_syms_in_objects
operator|==
name|RM_IGNORE
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
operator|(
name|info
operator|->
name|unresolved_syms_in_objects
operator|==
name|RM_GENERATE_ERROR
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|)
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
name|osec
operator|=
name|sec
expr_stmt|;
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_pcrel24
case|:
case|case
name|R_pcrel24_jump_l
case|:
case|case
name|R_byte4_data
case|:
if|if
condition|(
operator|!
name|IS_FDPIC
argument_list|(
name|output_bfd
argument_list|)
condition|)
goto|goto
name|non_fdpic
goto|;
case|case
name|R_BFIN_GOT17M4
case|:
case|case
name|R_BFIN_GOTHI
case|:
case|case
name|R_BFIN_GOTLO
case|:
case|case
name|R_BFIN_FUNCDESC_GOT17M4
case|:
case|case
name|R_BFIN_FUNCDESC_GOTHI
case|:
case|case
name|R_BFIN_FUNCDESC_GOTLO
case|:
case|case
name|R_BFIN_GOTOFF17M4
case|:
case|case
name|R_BFIN_GOTOFFHI
case|:
case|case
name|R_BFIN_GOTOFFLO
case|:
case|case
name|R_BFIN_FUNCDESC_GOTOFF17M4
case|:
case|case
name|R_BFIN_FUNCDESC_GOTOFFHI
case|:
case|case
name|R_BFIN_FUNCDESC_GOTOFFLO
case|:
case|case
name|R_BFIN_FUNCDESC
case|:
case|case
name|R_BFIN_FUNCDESC_VALUE
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|picrel
operator|=
name|bfinfdpic_relocs_info_for_global
argument_list|(
name|bfinfdpic_relocs_info
argument_list|(
name|info
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|h
argument_list|,
name|orig_addend
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
else|else
comment|/* In order to find the entry we created before, we must 	       use the original addend, not the one that may have been 	       modified by _bfd_elf_rela_local_sym().  */
name|picrel
operator|=
name|bfinfdpic_relocs_info_for_local
argument_list|(
name|bfinfdpic_relocs_info
argument_list|(
name|info
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|r_symndx
argument_list|,
name|orig_addend
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|picrel
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|_bfinfdpic_emit_got_relocs_plt_entries
argument_list|(
name|picrel
argument_list|,
name|output_bfd
argument_list|,
name|info
argument_list|,
name|osec
argument_list|,
name|sym
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: relocation at `%A+0x%x' references symbol `%s' with nonzero addend"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
default|default:
name|non_fdpic
label|:
name|picrel
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|h
operator|&&
operator|!
name|BFINFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"relocation references symbol not defined in the module"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_pcrel24
case|:
case|case
name|R_pcrel24_jump_l
case|:
name|check_segment
index|[
literal|0
index|]
operator|=
name|isec_segment
expr_stmt|;
if|if
condition|(
operator|!
name|IS_FDPIC
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|check_segment
index|[
literal|1
index|]
operator|=
name|isec_segment
expr_stmt|;
elseif|else
if|if
condition|(
name|picrel
operator|->
name|plt
condition|)
block|{
name|relocation
operator|=
name|bfinfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|bfinfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|picrel
operator|->
name|plt_entry
expr_stmt|;
name|check_segment
index|[
literal|1
index|]
operator|=
name|plt_segment
expr_stmt|;
block|}
comment|/* We don't want to warn on calls to undefined weak symbols, 	     as calls to them must be protected by non-NULL tests 	     anyway, and unprotected calls would invoke undefined 	     behavior.  */
elseif|else
if|if
condition|(
name|picrel
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
name|picrel
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|check_segment
index|[
literal|1
index|]
operator|=
name|check_segment
index|[
literal|0
index|]
expr_stmt|;
else|else
name|check_segment
index|[
literal|1
index|]
operator|=
name|sec
condition|?
name|_bfinfdpic_osec_to_segment
argument_list|(
name|output_bfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|)
else|:
operator|(
name|unsigned
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|R_BFIN_GOT17M4
case|:
case|case
name|R_BFIN_GOTHI
case|:
case|case
name|R_BFIN_GOTLO
case|:
name|relocation
operator|=
name|picrel
operator|->
name|got_entry
expr_stmt|;
name|check_segment
index|[
literal|0
index|]
operator|=
name|check_segment
index|[
literal|1
index|]
operator|=
name|got_segment
expr_stmt|;
break|break;
case|case
name|R_BFIN_FUNCDESC_GOT17M4
case|:
case|case
name|R_BFIN_FUNCDESC_GOTHI
case|:
case|case
name|R_BFIN_FUNCDESC_GOTLO
case|:
name|relocation
operator|=
name|picrel
operator|->
name|fdgot_entry
expr_stmt|;
name|check_segment
index|[
literal|0
index|]
operator|=
name|check_segment
index|[
literal|1
index|]
operator|=
name|got_segment
expr_stmt|;
break|break;
case|case
name|R_BFIN_GOTOFFHI
case|:
case|case
name|R_BFIN_GOTOFF17M4
case|:
case|case
name|R_BFIN_GOTOFFLO
case|:
name|relocation
operator|-=
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|bfinfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|check_segment
index|[
literal|0
index|]
operator|=
name|got_segment
expr_stmt|;
name|check_segment
index|[
literal|1
index|]
operator|=
name|sec
condition|?
name|_bfinfdpic_osec_to_segment
argument_list|(
name|output_bfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|)
else|:
operator|(
name|unsigned
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|R_BFIN_FUNCDESC_GOTOFF17M4
case|:
case|case
name|R_BFIN_FUNCDESC_GOTOFFHI
case|:
case|case
name|R_BFIN_FUNCDESC_GOTOFFLO
case|:
name|relocation
operator|=
name|picrel
operator|->
name|fd_entry
expr_stmt|;
name|check_segment
index|[
literal|0
index|]
operator|=
name|check_segment
index|[
literal|1
index|]
operator|=
name|got_segment
expr_stmt|;
break|break;
case|case
name|R_BFIN_FUNCDESC
case|:
block|{
name|int
name|dynindx
decl_stmt|;
name|bfd_vma
name|addend
init|=
name|rel
operator|->
name|r_addend
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|h
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|&&
name|BFINFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|)
condition|)
block|{
comment|/* If the symbol is dynamic and there may be dynamic 		   symbol resolution because we are or are linked with a 		   shared library, emit a FUNCDESC relocation such that 		   the dynamic linker will allocate the function 		   descriptor.  If the symbol needs a non-local function 		   descriptor but binds locally (e.g., its visibility is 		   protected, emit a dynamic relocation decayed to 		   section+offset.  */
if|if
condition|(
name|h
operator|&&
operator|!
name|BFINFDPIC_FUNCDESC_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|&&
name|BFINFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|&&
operator|!
operator|(
name|info
operator|->
name|executable
operator|&&
operator|!
name|info
operator|->
name|pie
operator|)
condition|)
block|{
name|dynindx
operator|=
name|elf_section_data
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
argument_list|)
operator|->
name|dynindx
expr_stmt|;
name|addend
operator|+=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|&&
operator|!
name|BFINFDPIC_FUNCDESC_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
if|if
condition|(
name|addend
condition|)
block|{
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"R_BFIN_FUNCDESC references dynamic symbol with nonzero addend"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|dynindx
operator|=
name|h
operator|->
name|dynindx
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, we know we have a private function 		       descriptor, so reference it directly.  */
name|BFD_ASSERT
argument_list|(
name|picrel
operator|->
name|privfd
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|R_byte4_data
expr_stmt|;
name|dynindx
operator|=
name|elf_section_data
argument_list|(
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
argument_list|)
operator|->
name|dynindx
expr_stmt|;
name|addend
operator|=
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|bfinfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|picrel
operator|->
name|fd_entry
expr_stmt|;
block|}
comment|/* If there is room for dynamic symbol resolution, emit 		   the dynamic relocation.  However, if we're linking an 		   executable at a fixed location, we won't have emitted a 		   dynamic symbol entry for the got section, so idx will 		   be zero, which means we can and should compute the 		   address of the private descriptor ourselves.  */
if|if
condition|(
name|info
operator|->
name|executable
operator|&&
operator|!
name|info
operator|->
name|pie
operator|&&
operator|(
operator|!
name|h
operator|||
name|BFINFDPIC_FUNCDESC_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|)
condition|)
block|{
name|addend
operator|+=
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|output_bfd
argument_list|,
name|input_section
operator|->
name|output_section
argument_list|)
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
operator|)
operator|==
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
condition|)
block|{
if|if
condition|(
name|_bfinfdpic_osec_readonly_p
argument_list|(
name|output_bfd
argument_list|,
name|input_section
operator|->
name|output_section
argument_list|)
condition|)
block|{
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"cannot emit fixups in read-only section"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|_bfinfdpic_add_rofixup
argument_list|(
name|output_bfd
argument_list|,
name|bfinfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
argument_list|,
name|picrel
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|output_bfd
argument_list|,
name|input_section
operator|->
name|output_section
argument_list|)
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
operator|)
operator|==
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
condition|)
block|{
if|if
condition|(
name|_bfinfdpic_osec_readonly_p
argument_list|(
name|output_bfd
argument_list|,
name|input_section
operator|->
name|output_section
argument_list|)
condition|)
block|{
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"cannot emit dynamic relocations in read-only section"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|_bfinfdpic_add_dyn_reloc
argument_list|(
name|output_bfd
argument_list|,
name|bfinfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
argument_list|,
name|r_type
argument_list|,
name|dynindx
argument_list|,
name|addend
argument_list|,
name|picrel
argument_list|)
expr_stmt|;
block|}
else|else
name|addend
operator|+=
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
block|}
comment|/* We want the addend in-place because dynamic 	       relocations are REL.  Setting relocation to it should 	       arrange for it to be installed.  */
name|relocation
operator|=
name|addend
operator|-
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
name|check_segment
index|[
literal|0
index|]
operator|=
name|check_segment
index|[
literal|1
index|]
operator|=
name|got_segment
expr_stmt|;
break|break;
case|case
name|R_byte4_data
case|:
if|if
condition|(
operator|!
name|IS_FDPIC
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|check_segment
index|[
literal|0
index|]
operator|=
name|check_segment
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|R_BFIN_FUNCDESC_VALUE
case|:
block|{
name|int
name|dynindx
decl_stmt|;
name|bfd_vma
name|addend
init|=
name|rel
operator|->
name|r_addend
decl_stmt|;
comment|/* If the symbol is dynamic but binds locally, use 	       section+offset.  */
if|if
condition|(
name|h
operator|&&
operator|!
name|BFINFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
if|if
condition|(
name|addend
operator|&&
name|r_type
operator|==
name|R_BFIN_FUNCDESC_VALUE
condition|)
block|{
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"R_BFIN_FUNCDESC_VALUE references dynamic symbol with nonzero addend"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|dynindx
operator|=
name|h
operator|->
name|dynindx
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|h
condition|)
name|addend
operator|+=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
else|else
name|addend
operator|+=
name|sym
operator|->
name|st_value
expr_stmt|;
if|if
condition|(
name|osec
condition|)
name|addend
operator|+=
name|osec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|osec
operator|&&
name|osec
operator|->
name|output_section
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|osec
operator|->
name|output_section
argument_list|)
operator|&&
operator|!
name|bfd_is_und_section
argument_list|(
name|osec
operator|->
name|output_section
argument_list|)
condition|)
name|dynindx
operator|=
name|elf_section_data
argument_list|(
name|osec
operator|->
name|output_section
argument_list|)
operator|->
name|dynindx
expr_stmt|;
else|else
name|dynindx
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we're linking an executable at a fixed address, we 	       can omit the dynamic relocation as long as the symbol 	       is defined in the current link unit (which is implied 	       by its output section not being NULL).  */
if|if
condition|(
name|info
operator|->
name|executable
operator|&&
operator|!
name|info
operator|->
name|pie
operator|&&
operator|(
operator|!
name|h
operator|||
name|BFINFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|osec
condition|)
name|addend
operator|+=
name|osec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|IS_FDPIC
argument_list|(
name|input_bfd
argument_list|)
operator|&&
operator|(
name|bfd_get_section_flags
argument_list|(
name|output_bfd
argument_list|,
name|input_section
operator|->
name|output_section
argument_list|)
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
operator|)
operator|==
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
condition|)
block|{
if|if
condition|(
name|_bfinfdpic_osec_readonly_p
argument_list|(
name|output_bfd
argument_list|,
name|input_section
operator|->
name|output_section
argument_list|)
condition|)
block|{
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"cannot emit fixups in read-only section"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|h
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
condition|)
block|{
name|_bfinfdpic_add_rofixup
argument_list|(
name|output_bfd
argument_list|,
name|bfinfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
argument_list|,
name|picrel
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_BFIN_FUNCDESC_VALUE
condition|)
name|_bfinfdpic_add_rofixup
argument_list|(
name|output_bfd
argument_list|,
name|bfinfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
literal|4
argument_list|,
name|picrel
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|output_bfd
argument_list|,
name|input_section
operator|->
name|output_section
argument_list|)
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
operator|)
operator|==
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
condition|)
block|{
if|if
condition|(
name|_bfinfdpic_osec_readonly_p
argument_list|(
name|output_bfd
argument_list|,
name|input_section
operator|->
name|output_section
argument_list|)
condition|)
block|{
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"cannot emit dynamic relocations in read-only section"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|_bfinfdpic_add_dyn_reloc
argument_list|(
name|output_bfd
argument_list|,
name|bfinfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
argument_list|,
name|r_type
argument_list|,
name|dynindx
argument_list|,
name|addend
argument_list|,
name|picrel
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osec
condition|)
name|addend
operator|+=
name|osec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
comment|/* We want the addend in-place because dynamic 		   relocations are REL.  Setting relocation to it 		   should arrange for it to be installed.  */
name|relocation
operator|=
name|addend
operator|-
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_BFIN_FUNCDESC_VALUE
condition|)
block|{
comment|/* If we've omitted the dynamic relocation, just emit 		   the fixed addresses of the symbol and of the local 		   GOT base offset.  */
if|if
condition|(
name|info
operator|->
name|executable
operator|&&
operator|!
name|info
operator|->
name|pie
operator|&&
operator|(
operator|!
name|h
operator|||
name|BFINFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|)
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|bfinfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
else|else
comment|/* A function descriptor used for lazy or local 		     resolving is initialized such that its high word 		     contains the output section index in which the 		     PLT entries are located, and the low word 		     contains the offset of the lazy PLT entry entry 		     point into that section.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|h
operator|&&
operator|!
name|BFINFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|?
literal|0
else|:
name|_bfinfdpic_osec_to_segment
argument_list|(
name|output_bfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|)
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
name|check_segment
index|[
literal|0
index|]
operator|=
name|check_segment
index|[
literal|1
index|]
operator|=
name|got_segment
expr_stmt|;
break|break;
default|default:
name|check_segment
index|[
literal|0
index|]
operator|=
name|isec_segment
expr_stmt|;
name|check_segment
index|[
literal|1
index|]
operator|=
name|sec
condition|?
name|_bfinfdpic_osec_to_segment
argument_list|(
name|output_bfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|)
else|:
operator|(
name|unsigned
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|check_segment
index|[
literal|0
index|]
operator|!=
name|check_segment
index|[
literal|1
index|]
operator|&&
name|IS_FDPIC
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
if|#
directive|if
literal|1
comment|/* If you take this out, remove the #error from fdpic-static-6.d 	 in the ld testsuite.  */
comment|/* This helps catch problems in GCC while we can't do more 	     than static linking.  The idea is to test whether the 	     input file basename is crt0.o only once.  */
if|if
condition|(
name|silence_segment_error
operator|==
literal|1
condition|)
name|silence_segment_error
operator|=
operator|(
name|strlen
argument_list|(
name|input_bfd
operator|->
name|filename
argument_list|)
operator|==
literal|6
operator|&&
name|strcmp
argument_list|(
name|input_bfd
operator|->
name|filename
argument_list|,
literal|"crt0.o"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strlen
argument_list|(
name|input_bfd
operator|->
name|filename
argument_list|)
operator|>
literal|6
operator|&&
name|strcmp
argument_list|(
name|input_bfd
operator|->
name|filename
operator|+
name|strlen
argument_list|(
name|input_bfd
operator|->
name|filename
argument_list|)
operator|-
literal|7
argument_list|,
literal|"/crt0.o"
argument_list|)
operator|==
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|silence_segment_error
comment|/* We don't want duplicate errors for undefined 		 symbols.  */
operator|&&
operator|!
operator|(
name|picrel
operator|&&
name|picrel
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
name|picrel
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|)
condition|)
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
operator|(
name|info
operator|->
name|shared
operator|||
name|info
operator|->
name|pie
operator|)
condition|?
name|_
argument_list|(
literal|"relocations between different segments are not supported"
argument_list|)
else|:
name|_
argument_list|(
literal|"warning: relocation references a different segment"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|silence_segment_error
operator|&&
operator|(
name|info
operator|->
name|shared
operator|||
name|info
operator|->
name|pie
operator|)
condition|)
return|return
name|FALSE
return|;
name|elf_elfheader
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_BFIN_PIC
expr_stmt|;
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_BFIN_GOTOFFHI
case|:
comment|/* We need the addend to be applied before we shift the 	     value right.  */
name|relocation
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
comment|/* Fall through.  */
case|case
name|R_BFIN_GOTHI
case|:
case|case
name|R_BFIN_FUNCDESC_GOTHI
case|:
case|case
name|R_BFIN_FUNCDESC_GOTOFFHI
case|:
name|relocation
operator|>>=
literal|16
expr_stmt|;
comment|/* Fall through.  */
case|case
name|R_BFIN_GOTLO
case|:
case|case
name|R_BFIN_FUNCDESC_GOTLO
case|:
case|case
name|R_BFIN_GOTOFFLO
case|:
case|case
name|R_BFIN_FUNCDESC_GOTOFFLO
case|:
name|relocation
operator|&=
literal|0xffff
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_pcrel24
case|:
case|case
name|R_pcrel24_jump_l
case|:
if|if
condition|(
operator|!
name|IS_FDPIC
argument_list|(
name|output_bfd
argument_list|)
operator|||
operator|!
name|picrel
operator|->
name|plt
condition|)
break|break;
comment|/* Fall through.  */
comment|/* When referencing a GOT entry, a function descriptor or a 	     PLT, we don't want the addend to apply to the reference, 	     but rather to the referenced symbol.  The actual entry 	     will have already been created taking the addend into 	     account, so cancel it out here.  */
case|case
name|R_BFIN_GOT17M4
case|:
case|case
name|R_BFIN_GOTHI
case|:
case|case
name|R_BFIN_GOTLO
case|:
case|case
name|R_BFIN_FUNCDESC_GOT17M4
case|:
case|case
name|R_BFIN_FUNCDESC_GOTHI
case|:
case|case
name|R_BFIN_FUNCDESC_GOTLO
case|:
case|case
name|R_BFIN_FUNCDESC_GOTOFF17M4
case|:
case|case
name|R_BFIN_FUNCDESC_GOTOFFHI
case|:
case|case
name|R_BFIN_FUNCDESC_GOTOFFLO
case|:
comment|/* Note that we only want GOTOFFHI, not GOTOFFLO or GOTOFF17M4 	     here, since we do want to apply the addend to the others. 	     Note that we've applied the addend to GOTOFFHI before we 	     shifted it right.  */
case|case
name|R_BFIN_GOTOFFHI
case|:
name|relocation
operator|-=
name|rel
operator|->
name|r_addend
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_pcrel24
operator|||
name|r_type
operator|==
name|R_pcrel24_jump_l
condition|)
block|{
name|bfd_vma
name|x
decl_stmt|;
name|bfd_vma
name|address
init|=
name|rel
operator|->
name|r_offset
decl_stmt|;
name|relocation
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
comment|/* Perform usual pc-relative correction.  */
name|relocation
operator|-=
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|-=
name|address
expr_stmt|;
comment|/* We are getting reloc_entry->address 2 byte off from 	     the start of instruction. Assuming absolute postion 	     of the reloc data. But, following code had been written assuming 	     reloc address is starting at begining of instruction. 	     To compensate that I have increased the value of 	     relocation by 1 (effectively 2) and used the addr -2 instead of addr.  */
name|relocation
operator|+=
literal|2
expr_stmt|;
name|address
operator|-=
literal|2
expr_stmt|;
name|relocation
operator|>>=
literal|1
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|address
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xff00
operator|)
operator||
operator|(
operator|(
name|relocation
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
operator|+
name|address
argument_list|)
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|address
operator|+
literal|2
argument_list|)
expr_stmt|;
name|x
operator|=
name|relocation
operator|&
literal|0xFFFF
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
operator|+
name|address
operator|+
literal|2
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
block|}
else|else
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_overflow
case|:
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
argument_list|(
name|info
argument_list|,
operator|(
name|h
condition|?
operator|&
name|h
operator|->
name|root
else|:
name|NULL
operator|)
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_undefined
case|:
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: out of range error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_notsupported
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unsupported relocation error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_dangerous
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: dangerous relocation"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unknown error"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|msg
condition|)
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|bfin_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|NULL
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|relocation
init|=
literal|0
decl_stmt|;
name|bfd_boolean
name|unresolved_reloc
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|<
literal|0
operator|||
name|r_type
operator|>=
literal|243
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_BFIN_GNU_VTENTRY
operator|||
name|r_type
operator|==
name|R_BFIN_GNU_VTINHERIT
condition|)
continue|continue;
name|howto
operator|=
name|bfin_reloc_type_lookup
argument_list|(
name|input_bfd
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|howto
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_boolean
name|warned
decl_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
block|}
name|address
operator|=
name|rel
operator|->
name|r_offset
expr_stmt|;
comment|/* Then, process normally.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_BFIN_GNU_VTINHERIT
case|:
case|case
name|R_BFIN_GNU_VTENTRY
case|:
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_got
case|:
comment|/* Relocation is to the address of the entry for this symbol 	     in the global offset table.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|do_default
goto|;
comment|/* Fall through.  */
comment|/* Relocation is the offset of the entry for this symbol in 	     the global offset table.  */
block|{
name|bfd_vma
name|off
decl_stmt|;
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
block|{
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|bfd_boolean
name|dyn
decl_stmt|;
name|off
operator|=
name|h
operator|->
name|got
operator|.
name|offset
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|off
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dyn
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
expr_stmt|;
if|if
condition|(
operator|!
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
operator|->
name|shared
argument_list|,
name|h
argument_list|)
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
name|h
operator|->
name|forced_local
operator|)
operator|&&
name|h
operator|->
name|def_regular
operator|)
condition|)
block|{
comment|/* This is actually a static link, or it is a 		       -Bsymbolic link and the symbol is defined 		       locally, or the symbol was forced to be local 		       because of a version file..  We must initialize 		       this entry in the global offset table.  Since 		       the offset must always be a multiple of 4, we 		       use the least significant bit to record whether 		       we have initialized it already.  		       When doing a dynamic link, we create a .rela.got 		       relocation entry to initialize the value.  This 		       is done in the finish_dynamic_symbol routine.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|offset
operator||=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|local_got_offsets
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|off
operator|=
name|local_got_offsets
index|[
name|r_symndx
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|off
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* The offset must always be a multiple of 4.  We use 		   the least significant bit to record whether we have 		   already generated the necessary reloc.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_pcrel24
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
expr_stmt|;
name|loc
operator|=
name|s
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|s
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
name|local_got_offsets
index|[
name|r_symndx
index|]
operator||=
literal|1
expr_stmt|;
block|}
block|}
name|relocation
operator|=
name|sgot
operator|->
name|output_offset
operator|+
name|off
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
comment|/* bfin : preg = [preg + 17bitdiv4offset] relocation is div by 4.  */
name|relocation
operator|/=
literal|4
expr_stmt|;
block|}
goto|goto
name|do_default
goto|;
case|case
name|R_pcrel24
case|:
case|case
name|R_pcrel24_jump_l
case|:
block|{
name|bfd_vma
name|x
decl_stmt|;
name|relocation
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
comment|/* Perform usual pc-relative correction.  */
name|relocation
operator|-=
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|-=
name|address
expr_stmt|;
comment|/* We are getting reloc_entry->address 2 byte off from 	       the start of instruction. Assuming absolute postion 	       of the reloc data. But, following code had been written assuming 	       reloc address is starting at begining of instruction. 	       To compensate that I have increased the value of 	       relocation by 1 (effectively 2) and used the addr -2 instead of addr.  */
name|relocation
operator|+=
literal|2
expr_stmt|;
name|address
operator|-=
literal|2
expr_stmt|;
name|relocation
operator|>>=
literal|1
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|address
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xff00
operator|)
operator||
operator|(
operator|(
name|relocation
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
operator|+
name|address
argument_list|)
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|address
operator|+
literal|2
argument_list|)
expr_stmt|;
name|x
operator|=
name|relocation
operator|&
literal|0xFFFF
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
operator|+
name|address
operator|+
literal|2
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
block|}
break|break;
default|default:
name|do_default
label|:
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|address
argument_list|,
name|relocation
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Dynamic relocs are not propagated for SEC_DEBUGGING sections          because such sections are not SEC_ALLOC and thus ld.so will          not process them.  */
if|if
condition|(
name|unresolved_reloc
operator|&&
operator|!
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|->
name|def_dynamic
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): unresolvable relocation against symbol `%s'"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
name|bfd_reloc_overflow
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
argument_list|(
name|info
argument_list|,
operator|(
name|h
condition|?
operator|&
name|h
operator|->
name|root
else|:
name|NULL
operator|)
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): reloc against `%s': error %d"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|name
argument_list|,
operator|(
name|int
operator|)
name|r
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|bfin_gc_mark_hook
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_BFIN_GNU_VTINHERIT
case|:
case|case
name|R_BFIN_GNU_VTENTRY
case|:
break|break;
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
default|default:
break|break;
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
block|}
block|}
block|}
else|else
return|return
name|bfd_section_from_elf_index
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Update the got entry reference counts for the section being removed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|bfinfdpic_gc_sweep_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Update the got entry reference counts for the section being removed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|bfin_gc_sweep_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_got
case|:
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
operator|--
name|h
operator|->
name|got
operator|.
name|refcount
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|==
literal|0
condition|)
block|{
comment|/* We don't need the .got entry any more.  */
name|sgot
operator|->
name|size
operator|-=
literal|4
expr_stmt|;
name|srelgot
operator|->
name|size
operator|-=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|local_got_refcounts
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|>
literal|0
condition|)
block|{
operator|--
name|local_got_refcounts
index|[
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|==
literal|0
condition|)
block|{
comment|/* We don't need the .got entry any more.  */
name|sgot
operator|->
name|size
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|srelgot
operator|->
name|size
operator|-=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* We need dynamic symbols for every section, since segments can    relocate independently.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|_bfinfdpic_link_omit_section_dynsym
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|p
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
switch|switch
condition|(
name|elf_section_data
argument_list|(
name|p
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
condition|)
block|{
case|case
name|SHT_PROGBITS
case|:
case|case
name|SHT_NOBITS
case|:
comment|/* If sh_type is yet undecided, assume it could be 	 SHT_PROGBITS/SHT_NOBITS.  */
case|case
name|SHT_NULL
case|:
return|return
name|FALSE
return|;
comment|/* There shouldn't be section relative relocations 	 against any other section.  */
default|default:
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Create  a .got section, as well as its additional info field.  This    is almost entirely copied from    elflink.c:_bfd_elf_create_got_section().  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|_bfin_create_got_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|flagword
name|flags
decl_stmt|,
name|pltflags
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|int
name|ptralign
decl_stmt|;
name|int
name|offset
decl_stmt|;
comment|/* This function may be called more than once.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|!=
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* Machine specific: although pointers are 32-bits wide, we want the      GOT to be aligned to a 64-bit boundary, such that function      descriptors in it can be accessed with 64-bit loads and      stores.  */
name|ptralign
operator|=
literal|3
expr_stmt|;
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|pltflags
operator|=
name|flags
expr_stmt|;
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|ptralign
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bed
operator|->
name|want_got_plt
condition|)
block|{
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".got.plt"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|ptralign
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|bed
operator|->
name|want_got_sym
condition|)
block|{
comment|/* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the .got 	 (or .got.plt) section.  We don't do this in the linker script 	 because we don't want to define the symbol if we are not creating 	 a global offset table.  */
name|h
operator|=
name|_bfd_elf_define_linkage_sym
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|s
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
expr_stmt|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hgot
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Machine-specific: we want the symbol for executables as 	 well.  */
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* The first bit of the global offset table is the header.  */
name|s
operator|->
name|size
operator|+=
name|bed
operator|->
name|got_header_size
expr_stmt|;
comment|/* This is the machine-specific part.  Create and initialize section      data for the got.  */
if|if
condition|(
name|IS_FDPIC
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|=
name|s
expr_stmt|;
name|bfinfdpic_relocs_info
argument_list|(
name|info
argument_list|)
operator|=
name|htab_try_create
argument_list|(
literal|1
argument_list|,
name|bfinfdpic_relocs_info_hash
argument_list|,
name|bfinfdpic_relocs_info_eq
argument_list|,
operator|(
name|htab_del
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfinfdpic_relocs_info
argument_list|(
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".rel.got"
argument_list|,
operator|(
name|flags
operator||
name|SEC_READONLY
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|bfinfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
operator|=
name|s
expr_stmt|;
comment|/* Machine-specific.  */
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".rofixup"
argument_list|,
operator|(
name|flags
operator||
name|SEC_READONLY
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|bfinfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
operator|=
name|s
expr_stmt|;
name|offset
operator|=
operator|-
literal|2048
expr_stmt|;
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
literal|2048
expr_stmt|;
name|flags
operator|=
name|BSF_GLOBAL
operator||
name|BSF_WEAK
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Make sure the got and plt sections exist, and that our pointers in    the link hash table point to them.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_bfinfdpic_create_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
comment|/* This is mostly copied from      elflink.c:_bfd_elf_create_dynamic_sections().  */
name|flagword
name|flags
decl_stmt|,
name|pltflags
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
comment|/* We need to create .plt, .rel[a].plt, .got, .got.plt, .dynbss, and      .rel[a].bss sections.  */
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|pltflags
operator|=
name|flags
expr_stmt|;
name|pltflags
operator||=
name|SEC_CODE
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|plt_not_loaded
condition|)
name|pltflags
operator|&=
operator|~
operator|(
name|SEC_CODE
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator|)
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|plt_readonly
condition|)
name|pltflags
operator||=
name|SEC_READONLY
expr_stmt|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|pltflags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|bed
operator|->
name|plt_alignment
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Blackfin-specific: remember it.  */
name|bfinfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|want_plt_sym
condition|)
block|{
comment|/* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the 	 .plt section.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"_PROCEDURE_LINKAGE_TABLE_"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|executable
operator|&&
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Blackfin-specific: we want rel relocations for the plt.  */
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".rel.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|bed
operator|->
name|s
operator|->
name|log_file_align
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Blackfin-specific: remember it.  */
name|bfinfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|=
name|s
expr_stmt|;
comment|/* Blackfin-specific: we want to create the GOT in the Blackfin way.  */
if|if
condition|(
operator|!
name|_bfin_create_got_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Blackfin-specific: make sure we created everything we wanted.  */
name|BFD_ASSERT
argument_list|(
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|&&
name|bfinfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
comment|/*&& bfinfdpic_gotfixup_section (info) */
operator|&&
name|bfinfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|&&
name|bfinfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|want_dynbss
condition|)
block|{
comment|/* The .dynbss section is a place to put symbols which are defined 	 by dynamic objects, are referenced by regular objects, and are 	 not functions.  We must allocate space for them in the process 	 image and use a R_*_COPY reloc to tell the dynamic linker to 	 initialize them at run time.  The linker script puts the .dynbss 	 section into the .bss section of the final image.  */
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|SEC_ALLOC
operator||
name|SEC_LINKER_CREATED
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* The .rel[a].bss section holds copy relocs.  This section is not      normally needed.  We need to create it here, though, so that the      linker will map it to an output section.  We can't just create it      only if we need it, because we will not know whether we need it      until we have seen all the input files, and the first time the      main linker code calls BFD after examining all the input files      (size_dynamic_sections) the input sections have already been      mapped to the output sections.  If the section turns out not to      be needed, we can discard it later.  We will never need this      section when generating a shared object, since they do not use      copy relocs.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
operator|(
name|bed
operator|->
name|default_use_rela_p
condition|?
literal|".rela.bss"
else|:
literal|".rel.bss"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|bed
operator|->
name|s
operator|->
name|log_file_align
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The name of the dynamic interpreter.  This is put in the .interp    section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/lib/ld.so.1"
end_define

begin_define
define|#
directive|define
name|DEFAULT_STACK_SIZE
value|0x20000
end_define

begin_comment
comment|/* This structure is used to collect the number of entries present in    each addressable range of the got.  */
end_comment

begin_struct
struct|struct
name|_bfinfdpic_dynamic_got_info
block|{
comment|/* Several bits of information about the current link.  */
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
comment|/* Total size needed for GOT entries within the 18- or 32-bit      ranges.  */
name|bfd_vma
name|got17m4
decl_stmt|,
name|gothilo
decl_stmt|;
comment|/* Total size needed for function descriptor entries within the 18-      or 32-bit ranges.  */
name|bfd_vma
name|fd17m4
decl_stmt|,
name|fdhilo
decl_stmt|;
comment|/* Total size needed function descriptor entries referenced in PLT      entries, that would be profitable to place in offsets close to      the PIC register.  */
name|bfd_vma
name|fdplt
decl_stmt|;
comment|/* Total size needed by lazy PLT entries.  */
name|bfd_vma
name|lzplt
decl_stmt|;
comment|/* Number of relocations carried over from input object files.  */
name|unsigned
name|long
name|relocs
decl_stmt|;
comment|/* Number of fixups introduced by relocations in input object files.  */
name|unsigned
name|long
name|fixups
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Compute the total GOT size required by each symbol in each range.    Symbols may require up to 4 words in the GOT: an entry pointing to    the symbol, an entry pointing to its function descriptor, and a    private function descriptors taking two words.  */
end_comment

begin_function
specifier|static
name|int
name|_bfinfdpic_count_got_plt_entries
parameter_list|(
name|void
modifier|*
modifier|*
name|entryp
parameter_list|,
name|void
modifier|*
name|dinfo_
parameter_list|)
block|{
name|struct
name|bfinfdpic_relocs_info
modifier|*
name|entry
init|=
operator|*
name|entryp
decl_stmt|;
name|struct
name|_bfinfdpic_dynamic_got_info
modifier|*
name|dinfo
init|=
name|dinfo_
decl_stmt|;
name|unsigned
name|relocs
init|=
literal|0
decl_stmt|,
name|fixups
init|=
literal|0
decl_stmt|;
comment|/* Allocate space for a GOT entry pointing to the symbol.  */
if|if
condition|(
name|entry
operator|->
name|got17m4
condition|)
name|dinfo
operator|->
name|got17m4
operator|+=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|gothilo
condition|)
name|dinfo
operator|->
name|gothilo
operator|+=
literal|4
expr_stmt|;
else|else
name|entry
operator|->
name|relocs32
operator|--
expr_stmt|;
name|entry
operator|->
name|relocs32
operator|++
expr_stmt|;
comment|/* Allocate space for a GOT entry pointing to the function      descriptor.  */
if|if
condition|(
name|entry
operator|->
name|fdgot17m4
condition|)
name|dinfo
operator|->
name|got17m4
operator|+=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|fdgothilo
condition|)
name|dinfo
operator|->
name|gothilo
operator|+=
literal|4
expr_stmt|;
else|else
name|entry
operator|->
name|relocsfd
operator|--
expr_stmt|;
name|entry
operator|->
name|relocsfd
operator|++
expr_stmt|;
comment|/* Decide whether we need a PLT entry, a function descriptor in the      GOT, and a lazy PLT entry for this symbol.  */
name|entry
operator|->
name|plt
operator|=
name|entry
operator|->
name|call
operator|&&
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|BFINFDPIC_SYM_LOCAL
argument_list|(
name|dinfo
operator|->
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|&&
name|elf_hash_table
argument_list|(
name|dinfo
operator|->
name|info
argument_list|)
operator|->
name|dynamic_sections_created
expr_stmt|;
name|entry
operator|->
name|privfd
operator|=
name|entry
operator|->
name|plt
operator|||
name|entry
operator|->
name|fdgoff17m4
operator|||
name|entry
operator|->
name|fdgoffhilo
operator|||
operator|(
operator|(
name|entry
operator|->
name|fd
operator|||
name|entry
operator|->
name|fdgot17m4
operator|||
name|entry
operator|->
name|fdgothilo
operator|)
operator|&&
operator|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|BFINFDPIC_FUNCDESC_LOCAL
argument_list|(
name|dinfo
operator|->
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|)
operator|)
expr_stmt|;
name|entry
operator|->
name|lazyplt
operator|=
name|entry
operator|->
name|privfd
operator|&&
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|BFINFDPIC_SYM_LOCAL
argument_list|(
name|dinfo
operator|->
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|&&
operator|!
operator|(
name|dinfo
operator|->
name|info
operator|->
name|flags
operator|&
name|DF_BIND_NOW
operator|)
operator|&&
name|elf_hash_table
argument_list|(
name|dinfo
operator|->
name|info
argument_list|)
operator|->
name|dynamic_sections_created
expr_stmt|;
comment|/* Allocate space for a function descriptor.  */
if|if
condition|(
name|entry
operator|->
name|fdgoff17m4
condition|)
name|dinfo
operator|->
name|fd17m4
operator|+=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|privfd
operator|&&
name|entry
operator|->
name|plt
condition|)
name|dinfo
operator|->
name|fdplt
operator|+=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|privfd
condition|)
name|dinfo
operator|->
name|fdhilo
operator|+=
literal|8
expr_stmt|;
else|else
name|entry
operator|->
name|relocsfdv
operator|--
expr_stmt|;
name|entry
operator|->
name|relocsfdv
operator|++
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|lazyplt
condition|)
name|dinfo
operator|->
name|lzplt
operator|+=
name|LZPLT_NORMAL_SIZE
expr_stmt|;
if|if
condition|(
operator|!
name|dinfo
operator|->
name|info
operator|->
name|executable
operator|||
name|dinfo
operator|->
name|info
operator|->
name|pie
condition|)
name|relocs
operator|=
name|entry
operator|->
name|relocs32
operator|+
name|entry
operator|->
name|relocsfd
operator|+
name|entry
operator|->
name|relocsfdv
expr_stmt|;
else|else
block|{
if|if
condition|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|BFINFDPIC_SYM_LOCAL
argument_list|(
name|dinfo
operator|->
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
condition|)
name|fixups
operator|+=
name|entry
operator|->
name|relocs32
operator|+
literal|2
operator|*
name|entry
operator|->
name|relocsfdv
expr_stmt|;
block|}
else|else
name|relocs
operator|+=
name|entry
operator|->
name|relocs32
operator|+
name|entry
operator|->
name|relocsfdv
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|BFINFDPIC_FUNCDESC_LOCAL
argument_list|(
name|dinfo
operator|->
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
condition|)
name|fixups
operator|+=
name|entry
operator|->
name|relocsfd
expr_stmt|;
block|}
else|else
name|relocs
operator|+=
name|entry
operator|->
name|relocsfd
expr_stmt|;
block|}
name|entry
operator|->
name|dynrelocs
operator|+=
name|relocs
expr_stmt|;
name|entry
operator|->
name|fixups
operator|+=
name|fixups
expr_stmt|;
name|dinfo
operator|->
name|relocs
operator|+=
name|relocs
expr_stmt|;
name|dinfo
operator|->
name|fixups
operator|+=
name|fixups
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This structure is used to assign offsets to got entries, function    descriptors, plt entries and lazy plt entries.  */
end_comment

begin_struct
struct|struct
name|_bfinfdpic_dynamic_got_plt_info
block|{
comment|/* Summary information collected with _bfinfdpic_count_got_plt_entries.  */
name|struct
name|_bfinfdpic_dynamic_got_info
name|g
decl_stmt|;
comment|/* For each addressable range, we record a MAX (positive) and MIN      (negative) value.  CUR is used to assign got entries, and it's      incremented from an initial positive value to MAX, then from MIN      to FDCUR (unless FDCUR wraps around first).  FDCUR is used to      assign function descriptors, and it's decreased from an initial      non-positive value to MIN, then from MAX down to CUR (unless CUR      wraps around first).  All of MIN, MAX, CUR and FDCUR always point      to even words.  ODD, if non-zero, indicates an odd word to be      used for the next got entry, otherwise CUR is used and      incremented by a pair of words, wrapping around when it reaches      MAX.  FDCUR is decremented (and wrapped) before the next function      descriptor is chosen.  FDPLT indicates the number of remaining      slots that can be used for function descriptors used only by PLT      entries.  */
struct|struct
name|_bfinfdpic_dynamic_got_alloc_data
block|{
name|bfd_signed_vma
name|max
decl_stmt|,
name|cur
decl_stmt|,
name|odd
decl_stmt|,
name|fdcur
decl_stmt|,
name|min
decl_stmt|;
name|bfd_vma
name|fdplt
decl_stmt|;
block|}
name|got17m4
struct|,
name|gothilo
struct|;
block|}
struct|;
end_struct

begin_comment
comment|/* Determine the positive and negative ranges to be used by each    offset range in the GOT.  FDCUR and CUR, that must be aligned to a    double-word boundary, are the minimum (negative) and maximum    (positive) GOT offsets already used by previous ranges, except for    an ODD entry that may have been left behind.  GOT and FD indicate    the size of GOT entries and function descriptors that must be    placed within the range from -WRAP to WRAP.  If there's room left,    up to FDPLT bytes should be reserved for additional function    descriptors.  */
end_comment

begin_function
specifier|inline
specifier|static
name|bfd_signed_vma
name|_bfinfdpic_compute_got_alloc_data
parameter_list|(
name|struct
name|_bfinfdpic_dynamic_got_alloc_data
modifier|*
name|gad
parameter_list|,
name|bfd_signed_vma
name|fdcur
parameter_list|,
name|bfd_signed_vma
name|odd
parameter_list|,
name|bfd_signed_vma
name|cur
parameter_list|,
name|bfd_vma
name|got
parameter_list|,
name|bfd_vma
name|fd
parameter_list|,
name|bfd_vma
name|fdplt
parameter_list|,
name|bfd_vma
name|wrap
parameter_list|)
block|{
name|bfd_signed_vma
name|wrapmin
init|=
operator|-
name|wrap
decl_stmt|;
comment|/* Start at the given initial points.  */
name|gad
operator|->
name|fdcur
operator|=
name|fdcur
expr_stmt|;
name|gad
operator|->
name|cur
operator|=
name|cur
expr_stmt|;
comment|/* If we had an incoming odd word and we have any got entries that      are going to use it, consume it, otherwise leave gad->odd at      zero.  We might force gad->odd to zero and return the incoming      odd such that it is used by the next range, but then GOT entries      might appear to be out of order and we wouldn't be able to      shorten the GOT by one word if it turns out to end with an      unpaired GOT entry.  */
if|if
condition|(
name|odd
operator|&&
name|got
condition|)
block|{
name|gad
operator|->
name|odd
operator|=
name|odd
expr_stmt|;
name|got
operator|-=
literal|4
expr_stmt|;
name|odd
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|gad
operator|->
name|odd
operator|=
literal|0
expr_stmt|;
comment|/* If we're left with an unpaired GOT entry, compute its location      such that we can return it.  Otherwise, if got doesn't require an      odd number of words here, either odd was already zero in the      block above, or it was set to zero because got was non-zero, or      got was already zero.  In the latter case, we want the value of      odd to carry over to the return statement, so we don't want to      reset odd unless the condition below is true.  */
if|if
condition|(
name|got
operator|&
literal|4
condition|)
block|{
name|odd
operator|=
name|cur
operator|+
name|got
expr_stmt|;
name|got
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* Compute the tentative boundaries of this range.  */
name|gad
operator|->
name|max
operator|=
name|cur
operator|+
name|got
expr_stmt|;
name|gad
operator|->
name|min
operator|=
name|fdcur
operator|-
name|fd
expr_stmt|;
name|gad
operator|->
name|fdplt
operator|=
literal|0
expr_stmt|;
comment|/* If function descriptors took too much space, wrap some of them      around.  */
if|if
condition|(
name|gad
operator|->
name|min
operator|<
name|wrapmin
condition|)
block|{
name|gad
operator|->
name|max
operator|+=
name|wrapmin
operator|-
name|gad
operator|->
name|min
expr_stmt|;
name|gad
operator|->
name|min
operator|=
name|wrapmin
expr_stmt|;
block|}
comment|/* If there is space left and we have function descriptors      referenced in PLT entries that could take advantage of shorter      offsets, place them here.  */
elseif|else
if|if
condition|(
name|fdplt
operator|&&
name|gad
operator|->
name|min
operator|>
name|wrapmin
condition|)
block|{
name|bfd_vma
name|fds
decl_stmt|;
if|if
condition|(
call|(
name|bfd_vma
call|)
argument_list|(
name|gad
operator|->
name|min
operator|-
name|wrapmin
argument_list|)
operator|<
name|fdplt
condition|)
name|fds
operator|=
name|gad
operator|->
name|min
operator|-
name|wrapmin
expr_stmt|;
else|else
name|fds
operator|=
name|fdplt
expr_stmt|;
name|fdplt
operator|-=
name|fds
expr_stmt|;
name|gad
operator|->
name|min
operator|-=
name|fds
expr_stmt|;
name|gad
operator|->
name|fdplt
operator|+=
name|fds
expr_stmt|;
block|}
comment|/* If GOT entries took too much space, wrap some of them around.      This may well cause gad->min to become lower than wrapmin.  This      will cause a relocation overflow later on, so we don't have to      report it here . */
if|if
condition|(
operator|(
name|bfd_vma
operator|)
name|gad
operator|->
name|max
operator|>
name|wrap
condition|)
block|{
name|gad
operator|->
name|min
operator|-=
name|gad
operator|->
name|max
operator|-
name|wrap
expr_stmt|;
name|gad
operator|->
name|max
operator|=
name|wrap
expr_stmt|;
block|}
comment|/* If there is more space left, try to place some more function      descriptors for PLT entries.  */
elseif|else
if|if
condition|(
name|fdplt
operator|&&
operator|(
name|bfd_vma
operator|)
name|gad
operator|->
name|max
operator|<
name|wrap
condition|)
block|{
name|bfd_vma
name|fds
decl_stmt|;
if|if
condition|(
call|(
name|bfd_vma
call|)
argument_list|(
name|wrap
operator|-
name|gad
operator|->
name|max
argument_list|)
operator|<
name|fdplt
condition|)
name|fds
operator|=
name|wrap
operator|-
name|gad
operator|->
name|max
expr_stmt|;
else|else
name|fds
operator|=
name|fdplt
expr_stmt|;
name|fdplt
operator|-=
name|fds
expr_stmt|;
name|gad
operator|->
name|max
operator|+=
name|fds
expr_stmt|;
name|gad
operator|->
name|fdplt
operator|+=
name|fds
expr_stmt|;
block|}
comment|/* If odd was initially computed as an offset past the wrap point,      wrap it around.  */
if|if
condition|(
name|odd
operator|>
name|gad
operator|->
name|max
condition|)
name|odd
operator|=
name|gad
operator|->
name|min
operator|+
name|odd
operator|-
name|gad
operator|->
name|max
expr_stmt|;
comment|/* _bfinfdpic_get_got_entry() below will always wrap gad->cur if needed      before returning, so do it here too.  This guarantees that,      should cur and fdcur meet at the wrap point, they'll both be      equal to min.  */
if|if
condition|(
name|gad
operator|->
name|cur
operator|==
name|gad
operator|->
name|max
condition|)
name|gad
operator|->
name|cur
operator|=
name|gad
operator|->
name|min
expr_stmt|;
return|return
name|odd
return|;
block|}
end_function

begin_comment
comment|/* Compute the location of the next GOT entry, given the allocation    data for a range.  */
end_comment

begin_function
specifier|inline
specifier|static
name|bfd_signed_vma
name|_bfinfdpic_get_got_entry
parameter_list|(
name|struct
name|_bfinfdpic_dynamic_got_alloc_data
modifier|*
name|gad
parameter_list|)
block|{
name|bfd_signed_vma
name|ret
decl_stmt|;
if|if
condition|(
name|gad
operator|->
name|odd
condition|)
block|{
comment|/* If there was an odd word left behind, use it.  */
name|ret
operator|=
name|gad
operator|->
name|odd
expr_stmt|;
name|gad
operator|->
name|odd
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, use the word pointed to by cur, reserve the next 	 as an odd word, and skip to the next pair of words, possibly 	 wrapping around.  */
name|ret
operator|=
name|gad
operator|->
name|cur
expr_stmt|;
name|gad
operator|->
name|odd
operator|=
name|gad
operator|->
name|cur
operator|+
literal|4
expr_stmt|;
name|gad
operator|->
name|cur
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|gad
operator|->
name|cur
operator|==
name|gad
operator|->
name|max
condition|)
name|gad
operator|->
name|cur
operator|=
name|gad
operator|->
name|min
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Compute the location of the next function descriptor entry in the    GOT, given the allocation data for a range.  */
end_comment

begin_function
specifier|inline
specifier|static
name|bfd_signed_vma
name|_bfinfdpic_get_fd_entry
parameter_list|(
name|struct
name|_bfinfdpic_dynamic_got_alloc_data
modifier|*
name|gad
parameter_list|)
block|{
comment|/* If we're at the bottom, wrap around, and only then allocate the      next pair of words.  */
if|if
condition|(
name|gad
operator|->
name|fdcur
operator|==
name|gad
operator|->
name|min
condition|)
name|gad
operator|->
name|fdcur
operator|=
name|gad
operator|->
name|max
expr_stmt|;
return|return
name|gad
operator|->
name|fdcur
operator|-=
literal|8
return|;
block|}
end_function

begin_comment
comment|/* Assign GOT offsets for every GOT entry and function descriptor.    Doing everything in a single pass is tricky.  */
end_comment

begin_function
specifier|static
name|int
name|_bfinfdpic_assign_got_entries
parameter_list|(
name|void
modifier|*
modifier|*
name|entryp
parameter_list|,
name|void
modifier|*
name|info_
parameter_list|)
block|{
name|struct
name|bfinfdpic_relocs_info
modifier|*
name|entry
init|=
operator|*
name|entryp
decl_stmt|;
name|struct
name|_bfinfdpic_dynamic_got_plt_info
modifier|*
name|dinfo
init|=
name|info_
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|got17m4
condition|)
name|entry
operator|->
name|got_entry
operator|=
name|_bfinfdpic_get_got_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|got17m4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|gothilo
condition|)
name|entry
operator|->
name|got_entry
operator|=
name|_bfinfdpic_get_got_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|gothilo
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|fdgot17m4
condition|)
name|entry
operator|->
name|fdgot_entry
operator|=
name|_bfinfdpic_get_got_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|got17m4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|fdgothilo
condition|)
name|entry
operator|->
name|fdgot_entry
operator|=
name|_bfinfdpic_get_got_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|gothilo
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|fdgoff17m4
condition|)
name|entry
operator|->
name|fd_entry
operator|=
name|_bfinfdpic_get_fd_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|got17m4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|plt
operator|&&
name|dinfo
operator|->
name|got17m4
operator|.
name|fdplt
condition|)
block|{
name|dinfo
operator|->
name|got17m4
operator|.
name|fdplt
operator|-=
literal|8
expr_stmt|;
name|entry
operator|->
name|fd_entry
operator|=
name|_bfinfdpic_get_fd_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|got17m4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|plt
condition|)
block|{
name|dinfo
operator|->
name|gothilo
operator|.
name|fdplt
operator|-=
literal|8
expr_stmt|;
name|entry
operator|->
name|fd_entry
operator|=
name|_bfinfdpic_get_fd_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|gothilo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|privfd
condition|)
name|entry
operator|->
name|fd_entry
operator|=
name|_bfinfdpic_get_fd_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|gothilo
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Assign GOT offsets to private function descriptors used by PLT    entries (or referenced by 32-bit offsets), as well as PLT entries    and lazy PLT entries.  */
end_comment

begin_function
specifier|static
name|int
name|_bfinfdpic_assign_plt_entries
parameter_list|(
name|void
modifier|*
modifier|*
name|entryp
parameter_list|,
name|void
modifier|*
name|info_
parameter_list|)
block|{
name|struct
name|bfinfdpic_relocs_info
modifier|*
name|entry
init|=
operator|*
name|entryp
decl_stmt|;
name|struct
name|_bfinfdpic_dynamic_got_plt_info
modifier|*
name|dinfo
init|=
name|info_
decl_stmt|;
comment|/* If this symbol requires a local function descriptor, allocate      one.  */
if|if
condition|(
name|entry
operator|->
name|privfd
operator|&&
name|entry
operator|->
name|fd_entry
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dinfo
operator|->
name|got17m4
operator|.
name|fdplt
condition|)
block|{
name|entry
operator|->
name|fd_entry
operator|=
name|_bfinfdpic_get_fd_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|got17m4
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|got17m4
operator|.
name|fdplt
operator|-=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|dinfo
operator|->
name|gothilo
operator|.
name|fdplt
argument_list|)
expr_stmt|;
name|entry
operator|->
name|fd_entry
operator|=
name|_bfinfdpic_get_fd_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|gothilo
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|gothilo
operator|.
name|fdplt
operator|-=
literal|8
expr_stmt|;
block|}
block|}
if|if
condition|(
name|entry
operator|->
name|plt
condition|)
block|{
name|int
name|size
decl_stmt|;
comment|/* We use the section's raw size to mark the location of the 	 next PLT entry.  */
name|entry
operator|->
name|plt_entry
operator|=
name|bfinfdpic_plt_section
argument_list|(
name|dinfo
operator|->
name|g
operator|.
name|info
argument_list|)
operator|->
name|size
expr_stmt|;
comment|/* Figure out the length of this PLT entry based on the 	 addressing mode we need to reach the function descriptor.  */
name|BFD_ASSERT
argument_list|(
name|entry
operator|->
name|fd_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|fd_entry
operator|>=
operator|-
operator|(
literal|1
operator|<<
operator|(
literal|18
operator|-
literal|1
operator|)
operator|)
operator|&&
name|entry
operator|->
name|fd_entry
operator|+
literal|4
operator|<
operator|(
literal|1
operator|<<
operator|(
literal|18
operator|-
literal|1
operator|)
operator|)
condition|)
name|size
operator|=
literal|10
expr_stmt|;
else|else
name|size
operator|=
literal|16
expr_stmt|;
name|bfinfdpic_plt_section
argument_list|(
name|dinfo
operator|->
name|g
operator|.
name|info
argument_list|)
operator|->
name|size
operator|+=
name|size
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|lazyplt
condition|)
block|{
name|entry
operator|->
name|lzplt_entry
operator|=
name|dinfo
operator|->
name|g
operator|.
name|lzplt
expr_stmt|;
name|dinfo
operator|->
name|g
operator|.
name|lzplt
operator|+=
name|LZPLT_NORMAL_SIZE
expr_stmt|;
comment|/* If this entry is the one that gets the resolver stub, account 	 for the additional instruction.  */
if|if
condition|(
name|entry
operator|->
name|lzplt_entry
operator|%
name|BFINFDPIC_LZPLT_BLOCK_SIZE
operator|==
name|BFINFDPIC_LZPLT_RESOLV_LOC
condition|)
name|dinfo
operator|->
name|g
operator|.
name|lzplt
operator|+=
name|LZPLT_RESOLVER_EXTRA
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Follow indirect and warning hash entries so that each got entry    points to the final symbol definition.  P must point to a pointer    to the hash table we're traversing.  Since this traversal may    modify the hash table, we set this pointer to NULL to indicate    we've made a potentially-destructive change to the hash table, so    the traversal must be restarted.  */
end_comment

begin_function
specifier|static
name|int
name|_bfinfdpic_resolve_final_relocs_info
parameter_list|(
name|void
modifier|*
modifier|*
name|entryp
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|bfinfdpic_relocs_info
modifier|*
name|entry
init|=
operator|*
name|entryp
decl_stmt|;
name|htab_t
modifier|*
name|htab
init|=
name|p
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|entry
operator|->
name|d
operator|.
name|h
decl_stmt|;
name|struct
name|bfinfdpic_relocs_info
modifier|*
name|oentry
decl_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|d
operator|.
name|h
operator|==
name|h
condition|)
return|return
literal|1
return|;
name|oentry
operator|=
name|bfinfdpic_relocs_info_for_global
argument_list|(
operator|*
name|htab
argument_list|,
literal|0
argument_list|,
name|h
argument_list|,
name|entry
operator|->
name|addend
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|oentry
condition|)
block|{
comment|/* Merge the two entries.  */
name|bfinfdpic_pic_merge_early_relocs_info
argument_list|(
name|oentry
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|htab_clear_slot
argument_list|(
operator|*
name|htab
argument_list|,
name|entryp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|entry
operator|->
name|d
operator|.
name|h
operator|=
name|h
expr_stmt|;
comment|/* If we can't find this entry with the new bfd hash, re-insert 	 it, and get the traversal restarted.  */
if|if
condition|(
operator|!
name|htab_find
argument_list|(
operator|*
name|htab
argument_list|,
name|entry
argument_list|)
condition|)
block|{
name|htab_clear_slot
argument_list|(
operator|*
name|htab
argument_list|,
name|entryp
argument_list|)
expr_stmt|;
name|entryp
operator|=
name|htab_find_slot
argument_list|(
operator|*
name|htab
argument_list|,
name|entry
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|entryp
condition|)
operator|*
name|entryp
operator|=
name|entry
expr_stmt|;
comment|/* Abort the traversal, since the whole table may have 	     moved, and leave it up to the parent to restart the 	     process.  */
operator|*
operator|(
name|htab_t
operator|*
operator|)
name|p
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_bfinfdpic_size_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|_bfinfdpic_dynamic_got_plt_info
name|gpinfo
decl_stmt|;
name|bfd_signed_vma
name|odd
decl_stmt|;
name|bfd_vma
name|limit
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
block|}
name|memset
argument_list|(
operator|&
name|gpinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gpinfo
argument_list|)
argument_list|)
expr_stmt|;
name|gpinfo
operator|.
name|g
operator|.
name|info
operator|=
name|info
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|htab_t
name|relocs
init|=
name|bfinfdpic_relocs_info
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|htab_traverse
argument_list|(
name|relocs
argument_list|,
name|_bfinfdpic_resolve_final_relocs_info
argument_list|,
operator|&
name|relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocs
operator|==
name|bfinfdpic_relocs_info
argument_list|(
name|info
argument_list|)
condition|)
break|break;
block|}
name|htab_traverse
argument_list|(
name|bfinfdpic_relocs_info
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfinfdpic_count_got_plt_entries
argument_list|,
operator|&
name|gpinfo
operator|.
name|g
argument_list|)
expr_stmt|;
name|odd
operator|=
literal|12
expr_stmt|;
comment|/* Compute the total size taken by entries in the 18-bit range,      to tell how many PLT function descriptors we can bring into it      without causing it to overflow.  */
name|limit
operator|=
name|odd
operator|+
name|gpinfo
operator|.
name|g
operator|.
name|got17m4
operator|+
name|gpinfo
operator|.
name|g
operator|.
name|fd17m4
expr_stmt|;
if|if
condition|(
name|limit
operator|<
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|18
condition|)
name|limit
operator|=
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|18
operator|)
operator|-
name|limit
expr_stmt|;
else|else
name|limit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gpinfo
operator|.
name|g
operator|.
name|fdplt
operator|<
name|limit
condition|)
name|limit
operator|=
name|gpinfo
operator|.
name|g
operator|.
name|fdplt
expr_stmt|;
comment|/* Determine the ranges of GOT offsets that we can use for each      range of addressing modes.  */
name|odd
operator|=
name|_bfinfdpic_compute_got_alloc_data
argument_list|(
operator|&
name|gpinfo
operator|.
name|got17m4
argument_list|,
literal|0
argument_list|,
name|odd
argument_list|,
literal|16
argument_list|,
name|gpinfo
operator|.
name|g
operator|.
name|got17m4
argument_list|,
name|gpinfo
operator|.
name|g
operator|.
name|fd17m4
argument_list|,
name|limit
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
operator|(
literal|18
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|odd
operator|=
name|_bfinfdpic_compute_got_alloc_data
argument_list|(
operator|&
name|gpinfo
operator|.
name|gothilo
argument_list|,
name|gpinfo
operator|.
name|got17m4
operator|.
name|min
argument_list|,
name|odd
argument_list|,
name|gpinfo
operator|.
name|got17m4
operator|.
name|max
argument_list|,
name|gpinfo
operator|.
name|g
operator|.
name|gothilo
argument_list|,
name|gpinfo
operator|.
name|g
operator|.
name|fdhilo
argument_list|,
name|gpinfo
operator|.
name|g
operator|.
name|fdplt
operator|-
name|gpinfo
operator|.
name|got17m4
operator|.
name|fdplt
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
operator|(
literal|32
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Now assign (most) GOT offsets.  */
name|htab_traverse
argument_list|(
name|bfinfdpic_relocs_info
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfinfdpic_assign_got_entries
argument_list|,
operator|&
name|gpinfo
argument_list|)
expr_stmt|;
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|=
name|gpinfo
operator|.
name|gothilo
operator|.
name|max
operator|-
name|gpinfo
operator|.
name|gothilo
operator|.
name|min
comment|/* If an odd word is the last word of the GOT, we don't need this        word to be part of the GOT.  */
operator|-
operator|(
name|odd
operator|+
literal|4
operator|==
name|gpinfo
operator|.
name|gothilo
operator|.
name|max
condition|?
literal|4
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|==
literal|0
condition|)
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
elseif|else
if|if
condition|(
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|==
literal|12
operator|&&
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
comment|/* Subtract the number of lzplt entries, since those will generate        relocations in the pltrel section.  */
name|bfinfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|=
operator|(
name|gpinfo
operator|.
name|g
operator|.
name|relocs
operator|-
name|gpinfo
operator|.
name|g
operator|.
name|lzplt
operator|/
name|LZPLT_NORMAL_SIZE
operator|)
operator|*
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|s
operator|->
name|sizeof_rel
expr_stmt|;
else|else
name|BFD_ASSERT
argument_list|(
name|gpinfo
operator|.
name|g
operator|.
name|relocs
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfinfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|==
literal|0
condition|)
name|bfinfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
else|else
block|{
name|bfinfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|bfinfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfinfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
name|bfinfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|=
operator|(
name|gpinfo
operator|.
name|g
operator|.
name|fixups
operator|+
literal|1
operator|)
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|bfinfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|==
literal|0
condition|)
name|bfinfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
else|else
block|{
name|bfinfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|bfinfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfinfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|bfinfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|=
name|gpinfo
operator|.
name|g
operator|.
name|lzplt
operator|/
name|LZPLT_NORMAL_SIZE
operator|*
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|s
operator|->
name|sizeof_rel
expr_stmt|;
if|if
condition|(
name|bfinfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|==
literal|0
condition|)
name|bfinfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
else|else
block|{
name|bfinfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|bfinfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfinfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Add 4 bytes for every block of at most 65535 lazy PLT entries,      such that there's room for the additional instruction needed to      call the resolver.  Since _bfinfdpic_assign_got_entries didn't      account for them, our block size is 4 bytes smaller than the real      block size.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|bfinfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|=
name|gpinfo
operator|.
name|g
operator|.
name|lzplt
operator|+
operator|(
operator|(
name|gpinfo
operator|.
name|g
operator|.
name|lzplt
operator|+
operator|(
name|BFINFDPIC_LZPLT_BLOCK_SIZE
operator|-
literal|4
operator|)
operator|-
name|LZPLT_NORMAL_SIZE
operator|)
operator|/
operator|(
name|BFINFDPIC_LZPLT_BLOCK_SIZE
operator|-
literal|4
operator|)
operator|*
name|LZPLT_RESOLVER_EXTRA
operator|)
expr_stmt|;
block|}
comment|/* Reset it, such that _bfinfdpic_assign_plt_entries() can use it to      actually assign lazy PLT entries addresses.  */
name|gpinfo
operator|.
name|g
operator|.
name|lzplt
operator|=
literal|0
expr_stmt|;
comment|/* Save information that we're going to need to generate GOT and PLT      entries.  */
name|bfinfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|=
operator|-
name|gpinfo
operator|.
name|gothilo
operator|.
name|min
expr_stmt|;
if|if
condition|(
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|want_got_sym
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+=
name|bfinfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
name|bfinfdpic_plt_initial_offset
argument_list|(
name|info
argument_list|)
operator|=
name|bfinfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
expr_stmt|;
name|htab_traverse
argument_list|(
name|bfinfdpic_relocs_info
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfinfdpic_assign_plt_entries
argument_list|,
operator|&
name|gpinfo
argument_list|)
expr_stmt|;
comment|/* Allocate the PLT section contents only after      _bfinfdpic_assign_plt_entries has a chance to add the size of the      non-lazy PLT entries.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
if|if
condition|(
name|bfinfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|==
literal|0
condition|)
name|bfinfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
else|else
block|{
name|bfinfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|bfinfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfinfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
if|if
condition|(
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
condition|)
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfinfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
condition|)
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PLTREL
argument_list|,
name|DT_REL
argument_list|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfinfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
condition|)
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_REL
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RELENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf32_bfinfdpic_always_size_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* Force a PT_GNU_STACK segment to be created.  */
if|if
condition|(
operator|!
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|stack_flags
condition|)
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|stack_flags
operator|=
name|PF_R
operator||
name|PF_W
operator||
name|PF_X
expr_stmt|;
comment|/* Define __stacksize if it's not defined yet.  */
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
literal|"__stacksize"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|type
operator|!=
name|STT_OBJECT
operator|||
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|output_bfd
argument_list|,
literal|"__stacksize"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|bfd_abs_section_ptr
argument_list|,
name|DEFAULT_STACK_SIZE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
block|}
comment|/* Create a stack section, and set its alignment.  */
name|sec
operator|=
name|bfd_make_section
argument_list|(
name|output_bfd
argument_list|,
literal|".stack"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|output_bfd
argument_list|,
name|sec
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf32_bfinfdpic_modify_segment_map
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|;
comment|/* objcopy and strip preserve what's already there using      elf32_bfinfdpic_copy_private_bfd_data ().  */
if|if
condition|(
operator|!
name|info
condition|)
return|return
name|TRUE
return|;
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|p_type
operator|==
name|PT_GNU_STACK
condition|)
break|break;
if|if
condition|(
name|m
condition|)
block|{
name|asection
modifier|*
name|sec
init|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".stack"
argument_list|)
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
if|if
condition|(
name|sec
condition|)
block|{
comment|/* Obtain the pointer to the __stacksize symbol.  */
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
literal|"__stacksize"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
argument_list|)
expr_stmt|;
comment|/* Set the section size from the symbol value.  We 	     intentionally ignore the symbol section.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
condition|)
name|sec
operator|->
name|size
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
else|else
name|sec
operator|->
name|size
operator|=
name|DEFAULT_STACK_SIZE
expr_stmt|;
comment|/* Add the stack section to the PT_GNU_STACK segment, 	     such that its size and alignment requirements make it 	     to the segment.  */
name|m
operator|->
name|sections
index|[
name|m
operator|->
name|count
index|]
operator|=
name|sec
expr_stmt|;
name|m
operator|->
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf32_bfinfdpic_finish_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|bfinfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|==
operator|(
name|bfinfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfinfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|hgot
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hgot
decl_stmt|;
name|bfd_vma
name|got_value
init|=
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
decl_stmt|;
name|_bfinfdpic_add_rofixup
argument_list|(
name|output_bfd
argument_list|,
name|bfinfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|got_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfinfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|!=
operator|(
name|bfinfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
operator|->
name|reloc_count
operator|*
literal|4
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"LINKER BUG: .rofixup section size mismatch"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|bfinfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|==
operator|(
name|bfinfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|Elf32_External_Dyn
modifier|*
name|dyncon
decl_stmt|;
name|Elf32_External_Dyn
modifier|*
name|dynconend
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|bfd_elf32_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
default|default:
break|break;
case|case
name|DT_PLTGOT
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|bfinfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|bfinfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_JMPREL
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|bfinfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|bfinfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|bfinfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_bfinfdpic_adjust_dynamic_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* Make sure we know what is going on here.  */
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
operator|||
operator|(
name|h
operator|->
name|def_dynamic
operator|&&
name|h
operator|->
name|ref_regular
operator|&&
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Perform any actions needed for dynamic symbols.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_bfinfdpic_finish_dynamic_symbol
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Decide whether to attempt to turn absptr or lsda encodings in    shared libraries into pcrel within the given input section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|bfinfdpic_elf_use_relative_eh_frame
parameter_list|(
name|bfd
modifier|*
name|input_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|eh_frame_section
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* We can't use PC-relative encodings in FDPIC binaries, in general.  */
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Adjust the contents of an eh_frame_hdr section before they're output.  */
end_comment

begin_function
specifier|static
name|bfd_byte
name|bfinfdpic_elf_encode_eh_address
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|osec
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|asection
modifier|*
name|loc_sec
parameter_list|,
name|bfd_vma
name|loc_offset
parameter_list|,
name|bfd_vma
modifier|*
name|encoded
parameter_list|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hgot
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h
operator|||
operator|(
name|_bfinfdpic_osec_to_segment
argument_list|(
name|abfd
argument_list|,
name|osec
argument_list|)
operator|==
name|_bfinfdpic_osec_to_segment
argument_list|(
name|abfd
argument_list|,
name|loc_sec
operator|->
name|output_section
argument_list|)
operator|)
condition|)
return|return
name|_bfd_elf_encode_eh_address
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|osec
argument_list|,
name|offset
argument_list|,
name|loc_sec
argument_list|,
name|loc_offset
argument_list|,
name|encoded
argument_list|)
return|;
name|BFD_ASSERT
argument_list|(
name|_bfinfdpic_osec_to_segment
argument_list|(
name|abfd
argument_list|,
name|osec
argument_list|)
operator|==
operator|(
name|_bfinfdpic_osec_to_segment
argument_list|(
name|abfd
argument_list|,
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
argument_list|)
operator|)
argument_list|)
expr_stmt|;
operator|*
name|encoded
operator|=
name|osec
operator|->
name|vma
operator|+
name|offset
operator|-
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
return|return
name|DW_EH_PE_datarel
operator||
name|DW_EH_PE_sdata4
return|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase.     Besides handling virtual table relocs for gc, we have to deal with    all sorts of PIC-related relocations.  We describe below the    general plan on how to handle such relocations, even though we only    collect information at this point, storing them in hash tables for    perusal of later passes.     32 relocations are propagated to the linker output when creating    position-independent output.  LO16 and HI16 relocations are not    supposed to be encountered in this case.     LABEL16 should always be resolvable by the linker, since it's only    used by branches.     LABEL24, on the other hand, is used by calls.  If it turns out that    the target of a call is a dynamic symbol, a PLT entry must be    created for it, which triggers the creation of a private function    descriptor and, unless lazy binding is disabled, a lazy PLT entry.     GPREL relocations require the referenced symbol to be in the same    segment as _gp, but this can only be checked later.     All GOT, GOTOFF and FUNCDESC relocations require a .got section to    exist.  LABEL24 might as well, since it may require a PLT entry,    that will require a got.     Non-FUNCDESC GOT relocations require a GOT entry to be created    regardless of whether the symbol is dynamic.  However, since a    global symbol that turns out to not be exported may have the same    address of a non-dynamic symbol, we don't assign GOT entries at    this point, such that we can share them in this case.  A relocation    for the GOT entry always has to be created, be it to offset a    private symbol by the section load address, be it to get the symbol    resolved dynamically.     FUNCDESC GOT relocations require a GOT entry to be created, and    handled as if a FUNCDESC relocation was applied to the GOT entry in    an object file.     FUNCDESC relocations referencing a symbol that turns out to NOT be    dynamic cause a private function descriptor to be created.  The    FUNCDESC relocation then decays to a 32 relocation that points at    the private descriptor.  If the symbol is dynamic, the FUNCDESC    relocation is propagated to the linker output, such that the    dynamic linker creates the canonical descriptor, pointing to the    dynamically-resolved definition of the function.     Non-FUNCDESC GOTOFF relocations must always refer to non-dynamic    symbols that are assigned to the same segment as the GOT, but we    can only check this later, after we know the complete set of    symbols defined and/or exported.     FUNCDESC GOTOFF relocations require a function descriptor to be    created and, unless lazy binding is disabled or the symbol is not    dynamic, a lazy PLT entry.  Since we can't tell at this point    whether a symbol is going to be dynamic, we have to decide later    whether to create a lazy PLT entry or bind the descriptor directly    to the private function.     FUNCDESC_VALUE relocations are not supposed to be present in object    files, but they may very well be simply propagated to the linker    output, since they have no side effect.      A function descriptor always requires a FUNCDESC_VALUE relocation.    Whether it's in .plt.rel or not depends on whether lazy binding is    enabled and on whether the referenced symbol is dynamic.     The existence of a lazy PLT requires the resolverStub lazy PLT    entry to be present.      As for assignment of GOT, PLT and lazy PLT entries, and private    descriptors, we might do them all sequentially, but we can do    better than that.  For example, we can place GOT entries and    private function descriptors referenced using 12-bit operands    closer to the PIC register value, such that these relocations don't    overflow.  Those that are only referenced with LO16 relocations    could come next, but we may as well place PLT-required function    descriptors in the 12-bit range to make them shorter.  Symbols    referenced with LO16/HI16 may come next, but we may place    additional function descriptors in the 16-bit range if we can    reliably tell that we've already placed entries that are ever    referenced with only LO16.  PLT entries are therefore generated as    small as possible, while not introducing relocation overflows in    GOT or FUNCDESC_GOTOFF relocations.  Lazy PLT entries could be    generated before or after PLT entries, but not intermingled with    them, such that we can have more lazy PLT entries in range for a    branch to the resolverStub.  The resolverStub should be emitted at    the most distant location from the first lazy PLT entry such that    it's still in range for a branch, or closer, if there isn't a need    for so many lazy PLT entries.  Additional lazy PLT entries may be    emitted after the resolverStub, as long as branches are still in    range.  If the branch goes out of range, longer lazy PLT entries    are emitted.     We could further optimize PLT and lazy PLT entries by giving them    priority in assignment to closer-to-gr17 locations depending on the    number of occurrences of references to them (assuming a function    that's called more often is more important for performance, so its    PLT entry should be faster), or taking hints from the compiler.    Given infinite time and money... :-)  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|bfinfdpic_check_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|,
modifier|*
modifier|*
name|sym_hashes_end
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|bfinfdpic_relocs_info
modifier|*
name|picrel
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_hashes_end
operator|=
name|sym_hashes
operator|+
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|sym_hashes_end
operator|-=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_BFIN_GOT17M4
case|:
case|case
name|R_BFIN_GOTHI
case|:
case|case
name|R_BFIN_GOTLO
case|:
case|case
name|R_BFIN_FUNCDESC_GOT17M4
case|:
case|case
name|R_BFIN_FUNCDESC_GOTHI
case|:
case|case
name|R_BFIN_FUNCDESC_GOTLO
case|:
case|case
name|R_BFIN_GOTOFF17M4
case|:
case|case
name|R_BFIN_GOTOFFHI
case|:
case|case
name|R_BFIN_GOTOFFLO
case|:
case|case
name|R_BFIN_FUNCDESC_GOTOFF17M4
case|:
case|case
name|R_BFIN_FUNCDESC_GOTOFFHI
case|:
case|case
name|R_BFIN_FUNCDESC_GOTOFFLO
case|:
case|case
name|R_BFIN_FUNCDESC
case|:
case|case
name|R_BFIN_FUNCDESC_VALUE
case|:
if|if
condition|(
operator|!
name|IS_FDPIC
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|bad_reloc
goto|;
comment|/* Fall through.  */
case|case
name|R_pcrel24
case|:
case|case
name|R_pcrel24_jump_l
case|:
case|case
name|R_byte4_data
case|:
if|if
condition|(
name|IS_FDPIC
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|!
name|dynobj
condition|)
block|{
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|_bfin_create_got_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|IS_FDPIC
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|picrel
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
switch|switch
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
condition|)
block|{
case|case
name|STV_INTERNAL
case|:
case|case
name|STV_HIDDEN
case|:
break|break;
default|default:
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
block|}
name|picrel
operator|=
name|bfinfdpic_relocs_info_for_global
argument_list|(
name|bfinfdpic_relocs_info
argument_list|(
name|info
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
block|}
else|else
name|picrel
operator|=
name|bfinfdpic_relocs_info_for_local
argument_list|(
name|bfinfdpic_relocs_info
argument_list|(
name|info
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|r_symndx
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|picrel
condition|)
return|return
name|FALSE
return|;
break|break;
default|default:
name|picrel
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_pcrel24
case|:
case|case
name|R_pcrel24_jump_l
case|:
if|if
condition|(
name|IS_FDPIC
argument_list|(
name|abfd
argument_list|)
condition|)
name|picrel
operator|->
name|call
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_BFIN_FUNCDESC_VALUE
case|:
name|picrel
operator|->
name|relocsfdv
operator|++
expr_stmt|;
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_ALLOC
condition|)
name|picrel
operator|->
name|relocs32
operator|--
expr_stmt|;
comment|/* Fall through.  */
case|case
name|R_byte4_data
case|:
if|if
condition|(
operator|!
name|IS_FDPIC
argument_list|(
name|abfd
argument_list|)
condition|)
break|break;
name|picrel
operator|->
name|sym
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_ALLOC
condition|)
name|picrel
operator|->
name|relocs32
operator|++
expr_stmt|;
break|break;
case|case
name|R_BFIN_GOT17M4
case|:
name|picrel
operator|->
name|got17m4
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_BFIN_GOTHI
case|:
case|case
name|R_BFIN_GOTLO
case|:
name|picrel
operator|->
name|gothilo
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_BFIN_FUNCDESC_GOT17M4
case|:
name|picrel
operator|->
name|fdgot17m4
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_BFIN_FUNCDESC_GOTHI
case|:
case|case
name|R_BFIN_FUNCDESC_GOTLO
case|:
name|picrel
operator|->
name|fdgothilo
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_BFIN_GOTOFF17M4
case|:
case|case
name|R_BFIN_GOTOFFHI
case|:
case|case
name|R_BFIN_GOTOFFLO
case|:
name|picrel
operator|->
name|gotoff
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_BFIN_FUNCDESC_GOTOFF17M4
case|:
name|picrel
operator|->
name|fdgoff17m4
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_BFIN_FUNCDESC_GOTOFFHI
case|:
case|case
name|R_BFIN_FUNCDESC_GOTOFFLO
case|:
name|picrel
operator|->
name|fdgoffhilo
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_BFIN_FUNCDESC
case|:
name|picrel
operator|->
name|fd
operator|=
literal|1
expr_stmt|;
name|picrel
operator|->
name|relocsfd
operator|++
expr_stmt|;
break|break;
comment|/* This relocation describes the C++ object vtable hierarchy.            Reconstruct it for later use during GC.  */
case|case
name|R_BFIN_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually            used.  Record for later use during GC.  */
case|case
name|R_BFIN_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|R_huimm16
case|:
case|case
name|R_luimm16
case|:
case|case
name|R_pcrel12_jump_s
case|:
case|case
name|R_pcrel10
case|:
break|break;
default|default:
name|bad_reloc
label|:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: unsupported relocation type %i"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the right machine number for a Blackfin ELF file.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_bfin_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_bfin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_BFIN_FDPIC
operator|)
operator|!=
literal|0
operator|)
operator|==
operator|(
name|IS_FDPIC
argument_list|(
name|abfd
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf32_bfin_set_private_flags
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|flagword
name|flags
parameter_list|)
block|{
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Copy backend specific data from one object module to another.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|bfin_elf_copy_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|||
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|==
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf32_bfinfdpic_copy_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|bfin_elf_copy_private_bfd_data
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|||
operator|!
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|phdr
operator|||
operator|!
name|elf_tdata
argument_list|(
name|obfd
argument_list|)
operator|||
operator|!
name|elf_tdata
argument_list|(
name|obfd
argument_list|)
operator|->
name|phdr
condition|)
return|return
name|TRUE
return|;
comment|/* Copy the stack size.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_phnum
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|phdr
index|[
name|i
index|]
operator|.
name|p_type
operator|==
name|PT_GNU_STACK
condition|)
block|{
name|Elf_Internal_Phdr
modifier|*
name|iphdr
init|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|phdr
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_phnum
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|elf_tdata
argument_list|(
name|obfd
argument_list|)
operator|->
name|phdr
index|[
name|i
index|]
operator|.
name|p_type
operator|==
name|PT_GNU_STACK
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|elf_tdata
argument_list|(
name|obfd
argument_list|)
operator|->
name|phdr
index|[
name|i
index|]
argument_list|,
name|iphdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|iphdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Rewrite the phdrs, since we're only called after they 		 were first written.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|obfd
argument_list|,
operator|(
name|bfd_signed_vma
operator|)
name|get_elf_backend_data
argument_list|(
name|obfd
argument_list|)
operator|->
name|s
operator|->
name|sizeof_ehdr
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|get_elf_backend_data
argument_list|(
name|obfd
argument_list|)
operator|->
name|s
operator|->
name|write_out_phdrs
argument_list|(
name|obfd
argument_list|,
name|elf_tdata
argument_list|(
name|obfd
argument_list|)
operator|->
name|phdr
argument_list|,
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_phnum
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
break|break;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Display the flags field.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_bfin_print_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|PTR
name|ptr
parameter_list|)
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|ptr
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|abfd
operator|!=
name|NULL
operator|&&
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Print normal ELF private data.  */
name|_bfd_elf_print_private_bfd_data
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|flags
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
comment|/* xgettext:c-format */
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"private flags = %lx:"
argument_list|)
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_BFIN_PIC
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -fpic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_BFIN_FDPIC
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -mfdpic"
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_bfin_merge_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|flagword
name|old_flags
decl_stmt|,
name|old_partial
decl_stmt|;
name|flagword
name|new_flags
decl_stmt|,
name|new_partial
decl_stmt|;
name|bfd_boolean
name|error
init|=
name|FALSE
decl_stmt|;
name|new_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|old_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
name|new_flags
operator|&
name|EF_BFIN_FDPIC
condition|)
name|new_flags
operator|&=
operator|~
name|EF_BFIN_PIC
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"old_flags = 0x%.8lx, new_flags = 0x%.8lx, init = %s, filename = %s"
argument_list|,
name|old_flags
argument_list|,
name|new_flags
argument_list|,
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
comment|/* First call, no flags set.  */
block|{
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
name|old_flags
operator|=
name|new_flags
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new_flags
operator|==
name|old_flags
condition|)
comment|/* Compatible flags are ok.  */
empty_stmt|;
else|else
comment|/* Possibly incompatible flags.  */
block|{
comment|/* We don't have to do anything if the pic flags are the same, or the new          module(s) were compiled with -mlibrary-pic.  */
name|new_partial
operator|=
operator|(
name|new_flags
operator|&
name|EF_BFIN_PIC_FLAGS
operator|)
expr_stmt|;
name|old_partial
operator|=
operator|(
name|old_flags
operator|&
name|EF_BFIN_PIC_FLAGS
operator|)
expr_stmt|;
if|if
condition|(
name|new_partial
operator|==
name|old_partial
condition|)
empty_stmt|;
comment|/* If we have mixtures of -fpic and -fPIC, or in both bits.  */
elseif|else
if|if
condition|(
name|new_partial
operator|!=
literal|0
operator|&&
name|old_partial
operator|!=
literal|0
condition|)
name|old_flags
operator||=
name|new_partial
expr_stmt|;
comment|/* One module was compiled for pic and the other was not, see if we have          had any relocations that are not pic-safe.  */
else|else
name|old_flags
operator||=
name|new_partial
expr_stmt|;
block|}
comment|/* Update the old flags now with changes made above.  */
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|old_flags
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|new_flags
operator|&
name|EF_BFIN_FDPIC
operator|)
operator|==
literal|0
operator|)
operator|!=
operator|(
operator|!
name|IS_FDPIC
argument_list|(
name|ibfd
argument_list|)
operator|)
condition|)
block|{
name|error
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|IS_FDPIC
argument_list|(
name|obfd
argument_list|)
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: cannot link non-fdpic object file into fdpic executable"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: cannot link fdpic object file into non-fdpic executable"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
operator|!
name|error
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* bfin ELF linker hash entry.  */
end_comment

begin_struct
struct|struct
name|bfin_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|root
decl_stmt|;
comment|/* Number of PC relative relocs copied for this symbol.  */
name|struct
name|bfin_pcrel_relocs_copied
modifier|*
name|pcrel_relocs_copied
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* bfin ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|bfin_link_hash_table
block|{
name|struct
name|elf_link_hash_table
name|root
decl_stmt|;
comment|/* Small local sym to section mapping cache.  */
name|struct
name|sym_sec_cache
name|sym_sec
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|bfin_hash_entry
parameter_list|(
name|ent
parameter_list|)
value|((struct bfin_link_hash_entry *) (ent))
end_define

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|bfin_link_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|struct
name|bfd_hash_entry
modifier|*
name|ret
init|=
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bfin_link_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|ret
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
name|_bfd_elf_link_hash_newfunc
argument_list|(
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
name|bfin_hash_entry
argument_list|(
name|ret
argument_list|)
operator|->
name|pcrel_relocs_copied
operator|=
name|NULL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Create an bfin ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|bfin_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|bfin_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|bfin_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|bfin_link_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_hash_entry
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|->
name|sym_sec
operator|.
name|abfd
operator|=
name|NULL
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* The size in bytes of an entry in the procedure linkage table.  */
end_comment

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|bfin_finish_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|Elf32_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|bfd_elf32_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|bfin_finish_dynamic_symbol
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srela
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
comment|/* This symbol has an entry in the global offset table.          Set it up.  */
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|srela
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
operator|&&
name|srela
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* If this is a -Bsymbolic link, and the symbol is defined          locally, we just want to emit a RELATIVE reloc.  Likewise if          the symbol was forced to be local because of a version file.          The entry in the global offset table will already have been          initialized in the relocate_section function.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
name|h
operator|->
name|forced_local
operator|)
operator|&&
name|h
operator|->
name|def_regular
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** check this relocation %s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_pcrel24
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
name|bfd_get_signed_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|sgot
operator|->
name|contents
operator|+
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
operator|)
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_got
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
name|loc
operator|=
name|srela
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|srela
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|needs_copy
condition|)
block|{
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
name|h
operator|==
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hgot
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|bfin_adjust_dynamic_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|power_of_two
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* Make sure we know what is going on here.  */
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|needs_plt
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
operator|||
operator|(
name|h
operator|->
name|def_dynamic
operator|&&
name|h
operator|->
name|ref_regular
operator|&&
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If this is a function, put it in the procedure linkage table.  We      will fill in the contents of the procedure linkage table later,      when we know the address of the .got section.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|||
name|h
operator|->
name|needs_plt
condition|)
block|{
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
comment|/* If we are creating a shared library, we must presume that the      only references to the symbol are via the global offset table.      For such cases we need not do anything here; the relocations will      be handled correctly by relocate_section.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
return|return
name|TRUE
return|;
comment|/* We must allocate the symbol in our .dynbss section, which will      become part of the .bss section of the executable.  There will be      an entry for this symbol in the .dynsym section.  The dynamic      object will contain position independent code, so all references      from the dynamic object to this symbol will go through the global      offset table.  The dynamic linker will use the .dynsym entry to      determine the address it must put in the global offset table, so      both the dynamic object and the regular object will refer to the      same memory location for the variable.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* We must generate a R_68K_COPY reloc to tell the dynamic linker to      copy the initial value out of the dynamic object and into the      runtime process image.  We need to remember the offset into the      .rela.bss section we are going to use.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|srel
decl_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.bss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|srel
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|h
operator|->
name|needs_copy
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We need to figure out the alignment required for this symbol.  I      have no idea how ELF linkers handle this.  */
name|power_of_two
operator|=
name|bfd_log2
argument_list|(
name|h
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
literal|3
condition|)
name|power_of_two
operator|=
literal|3
expr_stmt|;
comment|/* Apply the required alignment.  */
name|s
operator|->
name|size
operator|=
name|BFD_ALIGN
argument_list|(
name|s
operator|->
name|size
argument_list|,
call|(
name|bfd_size_type
call|)
argument_list|(
literal|1
operator|<<
name|power_of_two
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
name|bfd_get_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
name|power_of_two
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Define the symbol as being at this point in the section.  */
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|size
expr_stmt|;
comment|/* Increment the section size to make room for the symbol.  */
name|s
operator|->
name|size
operator|+=
name|h
operator|->
name|size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The bfin linker needs to keep track of the number of relocs that it    decides to copy in check_relocs for each symbol.  This is so that it    can discard PC relative relocs if it doesn't need them when linking    with -Bsymbolic.  We store the information in a field extending the    regular ELF linker hash table.  */
end_comment

begin_comment
comment|/* This structure keeps track of the number of PC relative relocs we have    copied for a given symbol.  */
end_comment

begin_struct
struct|struct
name|bfin_pcrel_relocs_copied
block|{
comment|/* Next section.  */
name|struct
name|bfin_pcrel_relocs_copied
modifier|*
name|next
decl_stmt|;
comment|/* A section in dynobj.  */
name|asection
modifier|*
name|section
decl_stmt|;
comment|/* Number of relocs copied in this section.  */
name|bfd_size_type
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This function is called via elf_link_hash_traverse if we are    creating a shared object.  In the -Bsymbolic case it discards the    space allocated to copy PC relative relocs against symbols which    are defined in regular objects.  For the normal shared case, it    discards space for pc-relative relocs that have become local due to    symbol visibility changes.  We allocated space for them in the    check_relocs routine, but we won't fill them in in the    relocate_section routine.     We also check whether any of the remaining relocations apply    against a readonly section, and set the DF_TEXTREL flag in this    case.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|bfin_discard_copies
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|PTR
name|inf
parameter_list|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
decl_stmt|;
name|struct
name|bfin_pcrel_relocs_copied
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
operator|!
name|h
operator|->
name|def_regular
operator|||
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|&&
operator|!
name|h
operator|->
name|forced_local
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Look for relocations against read-only sections.  */
for|for
control|(
name|s
operator|=
name|bfin_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|pcrel_relocs_copied
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|section
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
block|{
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
for|for
control|(
name|s
operator|=
name|bfin_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|pcrel_relocs_copied
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
name|s
operator|->
name|section
operator|->
name|size
operator|-=
name|s
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|bfin_size_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_boolean
name|relocs
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We may have created entries in the .rela.got section.          However, if we are not creating the dynamic sections, we will          not actually use these entries.  Reset the size of .rela.got,          which will cause it to get stripped from the output file          below.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|s
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this is a -Bsymbolic shared link, then we need to discard all      PC relative relocs against symbols defined in a regular object.      For the normal shared case we discard the PC relative relocs      against symbols that have become local due to visibility changes.      We allocated space for them in the check_relocs routine, but we      will not fill them in in the relocate_section routine.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|bfin_discard_copies
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
comment|/* The check_relocs and adjust_dynamic_symbol entry points have      determined the sizes of the various dynamic sections.  Allocate      memory for them.  */
name|relocs
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_boolean
name|strip
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* It's OK to base decisions on the section name, because none          of the dynobj section names depend upon the input files.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|strip
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
block|{
comment|/* If we don't need this section, strip it from the 	         output file.  This is mostly to handle .rela.bss and 	         .rela.plt.  We must create both sections in 	         create_dynamic_sections, because they must be created 	         before the linker maps input sections to output 	         sections.  The linker does that before 	         adjust_dynamic_symbol is called, and it is that 	         function which decides whether anything needs to go 	         into these sections.  */
name|strip
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|relocs
operator|=
name|TRUE
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need 	         to copy relocs into the output file.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".got"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|strip
condition|)
block|{
name|s
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
continue|continue;
block|}
comment|/* Allocate memory for the section contents.  */
comment|/* FIXME: This should be a call to bfd_alloc not bfd_zalloc.          Unused entries should be reclaimed before the section's contents          are written out, but at the moment this does not happen.  Thus in          order to prevent writing out garbage, we initialise the section's          contents to zero.  */
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|s
operator|->
name|size
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the          values later, in bfin_finish_dynamic_sections, but we          must add the entries now so that we get the correct size for          the .dynamic section.  The DT_DEBUG entry is filled in by the          dynamic linker and used by the debugger.  */
define|#
directive|define
name|add_dynamic_entry
parameter_list|(
name|TAG
parameter_list|,
name|VAL
parameter_list|)
define|\
value|_bfd_elf_add_dynamic_entry (info, TAG, VAL)
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|relocs
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELA
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELAENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
undef|#
directive|undef
name|add_dynamic_entry
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a .data section and a .emreloc in-memory section, store    relocation information into the .emreloc section which can be    used at runtime to relocate the section.  This is called by the    linker when the --embedded-relocs switch is used.  This is called    after the add_symbols entry point has been called for all the    objects, and before the final_link entry point is called.  */
end_comment

begin_decl_stmt
name|bfd_boolean
name|bfd_bfin_elf32_create_embedded_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
name|asection
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|bfd_boolean
name|bfd_bfin_elf32_create_embedded_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|datasec
parameter_list|,
name|asection
modifier|*
name|relsec
parameter_list|,
name|char
modifier|*
modifier|*
name|errmsg
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|BFD_ASSERT
argument_list|(
operator|!
name|info
operator|->
name|relocatable
argument_list|)
expr_stmt|;
operator|*
name|errmsg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|datasec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
comment|/* Get a copy of the native relocations.  */
name|internal_relocs
operator|=
operator|(
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|datasec
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|amt
operator|=
operator|(
name|bfd_size_type
operator|)
name|datasec
operator|->
name|reloc_count
operator|*
literal|12
expr_stmt|;
name|relsec
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsec
operator|->
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|p
operator|=
name|relsec
operator|->
name|contents
expr_stmt|;
name|irelend
operator|=
name|internal_relocs
operator|+
name|datasec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
operator|,
name|p
operator|+=
literal|12
control|)
block|{
name|asection
modifier|*
name|targetsec
decl_stmt|;
comment|/* We are going to write a four byte longword into the runtime        reloc section.  The longword will be the address in the data        section which must be relocated.  It is followed by the name        of the target section NUL-padded or truncated to 8        characters.  */
comment|/* We can only relocate absolute longword relocs at run time.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_byte4_data
condition|)
block|{
operator|*
name|errmsg
operator|=
name|_
argument_list|(
literal|"unsupported reloc type"
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* Get the target section referred to by the reloc.  */
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* A local symbol.  */
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
comment|/* Read this BFD's local symbols if we haven't done so already.  */
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
name|isym
operator|=
name|isymbuf
operator|+
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|targetsec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|indx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* An external symbol.  */
name|indx
operator|=
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
name|targetsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
else|else
name|targetsec
operator|=
name|NULL
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
name|datasec
operator|->
name|output_offset
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
operator|+
literal|4
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetsec
operator|!=
name|NULL
condition|)
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|+
literal|4
argument_list|,
name|targetsec
operator|->
name|output_section
operator|->
name|name
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|datasec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|datasec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_bfin_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-bfin"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_bfin
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_BLACKFIN
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1000
end_define

begin_define
define|#
directive|define
name|elf_symbol_leading_char
value|'_'
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|bfin_bfd_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|bfin_info_to_howto
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|elf32_bfin_object_p
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_is_local_label_name
define|\
value|bfin_is_local_label_name
end_define

begin_define
define|#
directive|define
name|bfin_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct bfin_link_hash_table *) (p)->hash)
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
define|\
value|_bfd_elf_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
define|\
value|bfin_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_final_link
value|bfd_elf_gc_common_final_link
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|bfin_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
define|\
value|bfin_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
define|\
value|bfin_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|bfin_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
define|\
value|bfin_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
define|\
value|bfin_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|bfin_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|bfin_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_merge_private_bfd_data
define|\
value|elf32_bfin_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_set_private_flags
define|\
value|elf32_bfin_set_private_flags
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_print_private_bfd_data
define|\
value|elf32_bfin_print_private_bfd_data
end_define

begin_define
define|#
directive|define
name|elf_backend_reloc_type_class
value|elf32_bfin_reloc_type_class
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_can_refcount
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_want_got_plt
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_readonly
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|12
end_define

begin_define
define|#
directive|define
name|elf_backend_rela_normal
value|1
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_bfinfdpic_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-bfinfdpic"
end_define

begin_undef
undef|#
directive|undef
name|elf32_bed
end_undef

begin_define
define|#
directive|define
name|elf32_bed
value|elf32_bfinfdpic_bed
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_gc_sweep_hook
end_undef

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|bfinfdpic_gc_sweep_hook
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_got_header_size
end_undef

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|0
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_relocate_section
end_undef

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|bfinfdpic_relocate_section
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_check_relocs
end_undef

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|bfinfdpic_check_relocs
end_define

begin_undef
undef|#
directive|undef
name|bfd_elf32_bfd_link_hash_table_create
end_undef

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
define|\
value|bfinfdpic_elf_link_hash_table_create
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_always_size_sections
end_undef

begin_define
define|#
directive|define
name|elf_backend_always_size_sections
define|\
value|elf32_bfinfdpic_always_size_sections
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_modify_segment_map
end_undef

begin_define
define|#
directive|define
name|elf_backend_modify_segment_map
define|\
value|elf32_bfinfdpic_modify_segment_map
end_define

begin_undef
undef|#
directive|undef
name|bfd_elf32_bfd_copy_private_bfd_data
end_undef

begin_define
define|#
directive|define
name|bfd_elf32_bfd_copy_private_bfd_data
define|\
value|elf32_bfinfdpic_copy_private_bfd_data
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_create_dynamic_sections
end_undef

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
define|\
value|elf32_bfinfdpic_create_dynamic_sections
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_adjust_dynamic_symbol
end_undef

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
define|\
value|elf32_bfinfdpic_adjust_dynamic_symbol
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_size_dynamic_sections
end_undef

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
define|\
value|elf32_bfinfdpic_size_dynamic_sections
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_finish_dynamic_symbol
end_undef

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
define|\
value|elf32_bfinfdpic_finish_dynamic_symbol
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_finish_dynamic_sections
end_undef

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
define|\
value|elf32_bfinfdpic_finish_dynamic_sections
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_can_make_relative_eh_frame
end_undef

begin_define
define|#
directive|define
name|elf_backend_can_make_relative_eh_frame
define|\
value|bfinfdpic_elf_use_relative_eh_frame
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_can_make_lsda_relative_eh_frame
end_undef

begin_define
define|#
directive|define
name|elf_backend_can_make_lsda_relative_eh_frame
define|\
value|bfinfdpic_elf_use_relative_eh_frame
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_encode_eh_address
end_undef

begin_define
define|#
directive|define
name|elf_backend_encode_eh_address
define|\
value|bfinfdpic_elf_encode_eh_address
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_may_use_rel_p
end_undef

begin_define
define|#
directive|define
name|elf_backend_may_use_rel_p
value|1
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_may_use_rela_p
end_undef

begin_define
define|#
directive|define
name|elf_backend_may_use_rela_p
value|1
end_define

begin_comment
comment|/* We use REL for dynamic relocations only.  */
end_comment

begin_undef
undef|#
directive|undef
name|elf_backend_default_use_rela_p
end_undef

begin_define
define|#
directive|define
name|elf_backend_default_use_rela_p
value|1
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_omit_section_dynsym
end_undef

begin_define
define|#
directive|define
name|elf_backend_omit_section_dynsym
value|_bfinfdpic_link_omit_section_dynsym
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

