begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for HPPA BSD core files.    Copyright 1993, 1994, 1995, 1998, 1999, 2001, 2002, 2003, 2004, 2005,    2006, 2007 Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.     Written by the Center for Software Science at the University of Utah    and by Cygnus Support.     The core file structure for the Utah 4.3BSD and OSF1 ports on the    PA is a mix between traditional cores and hpux cores -- just    different enough that supporting this format would tend to add    gross hacks to trad-core.c or hpux-core.c.  So instead we keep any    gross hacks isolated to this file.  */
end_comment

begin_comment
comment|/* This file can only be compiled on systems which use HPPA-BSD style    core files.     I would not expect this to be of use to any other host/target, but    you never know.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HOST_HPPABSD
argument_list|)
end_if

begin_include
include|#
directive|include
file|"machine/vmparam.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_comment
comment|/* After a.out.h  */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|make_bfd_asection
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|flagword
operator|,
name|bfd_size_type
operator|,
name|file_ptr
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_target
modifier|*
name|hppabsd_core_core_file_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|hppabsd_core_core_file_failing_command
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hppabsd_core_core_file_failing_signal
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|hppabsd_core_core_file_matches_executable_p
value|generic_core_file_matches_executable_p
end_define

begin_decl_stmt
specifier|static
name|void
name|swap_abort
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are stored in the bfd's tdata.  */
end_comment

begin_struct
struct|struct
name|hppabsd_core_struct
block|{
name|int
name|sig
decl_stmt|;
name|char
name|cmd
index|[
name|MAXCOMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|asection
modifier|*
name|data_section
decl_stmt|;
name|asection
modifier|*
name|stack_section
decl_stmt|;
name|asection
modifier|*
name|reg_section
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|core_hdr
parameter_list|(
name|bfd
parameter_list|)
value|((bfd)->tdata.hppabsd_core_data)
end_define

begin_define
define|#
directive|define
name|core_signal
parameter_list|(
name|bfd
parameter_list|)
value|(core_hdr(bfd)->sig)
end_define

begin_define
define|#
directive|define
name|core_command
parameter_list|(
name|bfd
parameter_list|)
value|(core_hdr(bfd)->cmd)
end_define

begin_define
define|#
directive|define
name|core_datasec
parameter_list|(
name|bfd
parameter_list|)
value|(core_hdr(bfd)->data_section)
end_define

begin_define
define|#
directive|define
name|core_stacksec
parameter_list|(
name|bfd
parameter_list|)
value|(core_hdr(bfd)->stack_section)
end_define

begin_define
define|#
directive|define
name|core_regsec
parameter_list|(
name|bfd
parameter_list|)
value|(core_hdr(bfd)->reg_section)
end_define

begin_function
specifier|static
name|asection
modifier|*
name|make_bfd_asection
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|,
name|flags
parameter_list|,
name|size
parameter_list|,
name|offset
parameter_list|,
name|alignment_power
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|unsigned
name|int
name|alignment_power
decl_stmt|;
block|{
name|asection
modifier|*
name|asect
decl_stmt|;
name|asect
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|asect
condition|)
return|return
name|NULL
return|;
name|asect
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|asect
operator|->
name|filepos
operator|=
name|offset
expr_stmt|;
name|asect
operator|->
name|alignment_power
operator|=
name|alignment_power
expr_stmt|;
return|return
name|asect
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|hppabsd_core_core_file_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|struct
name|user
name|u
decl_stmt|;
name|struct
name|hppabsd_core_struct
modifier|*
name|coredata
decl_stmt|;
name|int
name|clicksz
decl_stmt|;
comment|/* Try to read in the u-area.  We will need information from this      to know how to grok the rest of the core structures.  */
name|val
operator|=
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|u
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
name|u
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
sizeof|sizeof
name|u
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Get the page size out of the u structure.  This will be different      for PA 1.0 machines and PA 1.1 machines.   Yuk!  */
name|clicksz
operator|=
name|u
operator|.
name|u_pcb
operator|.
name|pcb_pgsz
expr_stmt|;
comment|/* clicksz must be a power of two>= 2k.  */
if|if
condition|(
name|clicksz
operator|<
literal|0x800
operator|||
name|clicksz
operator|!=
operator|(
name|clicksz
operator|&
operator|-
name|clicksz
operator|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Sanity checks.  Make sure the size of the core file matches the      the size computed from information within the core itself.  */
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
if|if
condition|(
name|bfd_stat
argument_list|(
name|abfd
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|NBPG
operator|*
operator|(
name|UPAGES
operator|+
name|u
operator|.
name|u_dsize
operator|+
name|u
operator|.
name|u_ssize
operator|)
operator|>
name|statbuf
operator|.
name|st_size
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|clicksz
operator|*
operator|(
name|UPAGES
operator|+
name|u
operator|.
name|u_dsize
operator|+
name|u
operator|.
name|u_ssize
operator|)
operator|<
name|statbuf
operator|.
name|st_size
condition|)
block|{
comment|/* The file is too big.  Maybe it's not a core file 	   or we otherwise have bad values for u_dsize and u_ssize).  */
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* OK, we believe you.  You're a core file (sure, sure).  */
name|coredata
operator|=
operator|(
expr|struct
name|hppabsd_core_struct
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|hppabsd_core_struct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|coredata
condition|)
return|return
name|NULL
return|;
comment|/* Make the core data and available via the tdata part of the BFD.  */
name|abfd
operator|->
name|tdata
operator|.
name|hppabsd_core_data
operator|=
name|coredata
expr_stmt|;
comment|/* Create the sections.  */
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|=
name|make_bfd_asection
argument_list|(
name|abfd
argument_list|,
literal|".stack"
argument_list|,
name|SEC_ALLOC
operator|+
name|SEC_HAS_CONTENTS
argument_list|,
name|clicksz
operator|*
name|u
operator|.
name|u_ssize
argument_list|,
name|NBPG
operator|*
operator|(
name|USIZE
operator|+
name|KSTAKSIZE
operator|)
operator|+
name|clicksz
operator|*
name|u
operator|.
name|u_dsize
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|core_stacksec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|USRSTACK
expr_stmt|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|=
name|make_bfd_asection
argument_list|(
name|abfd
argument_list|,
literal|".data"
argument_list|,
name|SEC_ALLOC
operator|+
name|SEC_LOAD
operator|+
name|SEC_HAS_CONTENTS
argument_list|,
name|clicksz
operator|*
name|u
operator|.
name|u_dsize
argument_list|,
name|NBPG
operator|*
operator|(
name|USIZE
operator|+
name|KSTAKSIZE
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|core_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
name|UDATASEG
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|=
name|make_bfd_asection
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|,
name|SEC_HAS_CONTENTS
argument_list|,
name|KSTAKSIZE
operator|*
name|NBPG
argument_list|,
name|NBPG
operator|*
name|USIZE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|core_command
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|u
operator|.
name|u_comm
argument_list|,
name|MAXCOMLEN
operator|+
literal|1
argument_list|)
expr_stmt|;
name|core_signal
argument_list|(
name|abfd
argument_list|)
operator|=
name|u
operator|.
name|u_code
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
name|fail
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|abfd
operator|->
name|tdata
operator|.
name|any
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|=
name|NULL
expr_stmt|;
name|bfd_section_list_clear
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|hppabsd_core_core_file_failing_command
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|core_command
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hppabsd_core_core_file_failing_signal
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|core_signal
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If somebody calls any byte-swapping routines, shoot them.  */
end_comment

begin_function
specifier|static
name|void
name|swap_abort
parameter_list|()
block|{
comment|/* This way doesn't require any declaration for ANSI to fuck up.  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|NO_GET
value|((bfd_vma (*) (const void *)) swap_abort)
end_define

begin_define
define|#
directive|define
name|NO_PUT
value|((void (*) (bfd_vma, void *)) swap_abort)
end_define

begin_define
define|#
directive|define
name|NO_GETS
value|((bfd_signed_vma (*) (const void *)) swap_abort)
end_define

begin_define
define|#
directive|define
name|NO_GET64
value|((bfd_uint64_t (*) (const void *)) swap_abort)
end_define

begin_define
define|#
directive|define
name|NO_PUT64
value|((void (*) (bfd_uint64_t, void *)) swap_abort)
end_define

begin_define
define|#
directive|define
name|NO_GETS64
value|((bfd_int64_t (*) (const void *)) swap_abort)
end_define

begin_decl_stmt
specifier|const
name|bfd_target
name|hppabsd_core_vec
init|=
block|{
literal|"hppabsd-core"
block|,
name|bfd_target_unknown_flavour
block|,
name|BFD_ENDIAN_BIG
block|,
comment|/* target byte order */
name|BFD_ENDIAN_BIG
block|,
comment|/* target headers byte order */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|0
block|,
comment|/* symbol prefix */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
name|NO_GET64
block|,
name|NO_GETS64
block|,
name|NO_PUT64
block|,
comment|/* 64 bit data */
name|NO_GET
block|,
name|NO_GETS
block|,
name|NO_PUT
block|,
comment|/* 32 bit data */
name|NO_GET
block|,
name|NO_GETS
block|,
name|NO_PUT
block|,
comment|/* 16 bit data */
name|NO_GET64
block|,
name|NO_GETS64
block|,
name|NO_PUT64
block|,
comment|/* 64 bit hdrs */
name|NO_GET
block|,
name|NO_GETS
block|,
name|NO_PUT
block|,
comment|/* 32 bit hdrs */
name|NO_GET
block|,
name|NO_GETS
block|,
name|NO_PUT
block|,
comment|/* 16 bit hdrs */
block|{
comment|/* bfd_check_format */
name|_bfd_dummy_target
block|,
comment|/* unknown format */
name|_bfd_dummy_target
block|,
comment|/* object file */
name|_bfd_dummy_target
block|,
comment|/* archive */
name|hppabsd_core_core_file_p
comment|/* a core file */
block|}
block|,
block|{
comment|/* bfd_set_format */
name|bfd_false
block|,
name|bfd_false
block|,
name|bfd_false
block|,
name|bfd_false
block|}
block|,
block|{
comment|/* bfd_write_contents */
name|bfd_false
block|,
name|bfd_false
block|,
name|bfd_false
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|hppabsd_core
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_noarchive
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|_bfd_nosymbols
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|_bfd_norelocs
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|_bfd_nolink
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|NULL
block|,
operator|(
name|PTR
operator|)
literal|0
comment|/* backend_data */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

