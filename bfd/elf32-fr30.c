begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* FR30-specific support for 32-bit ELF.    Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005    Free Software Foundation, Inc.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/fr30.h"
end_include

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|fr30_elf_i20_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|fr30_elf_i32_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|fr30_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|bfd_reloc_code_real_type
name|code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fr30_info_to_howto_rela
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|fr30_elf_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|fr30_final_link_relocate
name|PARAMS
argument_list|(
operator|(
name|reloc_howto_type
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|fr30_elf_gc_sweep_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|fr30_elf_gc_mark_hook
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|fr30_elf_check_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|fr30_elf_howto_table
index|[]
init|=
block|{
comment|/* This reloc does nothing.  */
name|HOWTO
argument_list|(
name|R_FR30_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FR30_NONE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An 8 bit absolute relocation.  */
name|HOWTO
argument_list|(
name|R_FR30_8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|4
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FR30_8"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0x0000
argument_list|,
comment|/* src_mask */
literal|0x0ff0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 20 bit absolute relocation.  */
name|HOWTO
argument_list|(
name|R_FR30_20
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|20
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|fr30_elf_i20_reloc
argument_list|,
comment|/* special_function */
literal|"R_FR30_20"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0x00000000
argument_list|,
comment|/* src_mask */
literal|0x00f0ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32 bit absolute relocation.  */
name|HOWTO
argument_list|(
name|R_FR30_32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FR30_32"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0x00000000
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32 bit into 48 bits absolute relocation.  */
name|HOWTO
argument_list|(
name|R_FR30_48
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|fr30_elf_i32_reloc
argument_list|,
comment|/* special_function */
literal|"R_FR30_48"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0x00000000
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 6 bit absolute relocation.  */
name|HOWTO
argument_list|(
name|R_FR30_6_IN_4
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|6
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|4
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FR30_6_IN_4"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0x0000
argument_list|,
comment|/* src_mask */
literal|0x00f0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An 8 bit absolute relocation.  */
name|HOWTO
argument_list|(
name|R_FR30_8_IN_8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|4
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FR30_8_IN_8"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0x0000
argument_list|,
comment|/* src_mask */
literal|0x0ff0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 9 bit absolute relocation.  */
name|HOWTO
argument_list|(
name|R_FR30_9_IN_8
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|9
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|4
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FR30_9_IN_8"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0x0000
argument_list|,
comment|/* src_mask */
literal|0x0ff0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 10 bit absolute relocation.  */
name|HOWTO
argument_list|(
name|R_FR30_10_IN_8
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|10
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|4
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FR30_10_IN_8"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0x0000
argument_list|,
comment|/* src_mask */
literal|0x0ff0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A PC relative 9 bit relocation, right shifted by 1.  */
name|HOWTO
argument_list|(
name|R_FR30_9_PCREL
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|9
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FR30_9_PCREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000
argument_list|,
comment|/* src_mask */
literal|0x00ff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A PC relative 12 bit relocation, right shifted by 1.  */
name|HOWTO
argument_list|(
name|R_FR30_12_PCREL
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FR30_12_PCREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000
argument_list|,
comment|/* src_mask */
literal|0x07ff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable hierarchy */
name|HOWTO
argument_list|(
name|R_FR30_GNU_VTINHERIT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_FR30_GNU_VTINHERIT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable member usage */
name|HOWTO
argument_list|(
name|R_FR30_GNU_VTENTRY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_elf_rel_vtable_reloc_fn
argument_list|,
comment|/* special_function */
literal|"R_FR30_GNU_VTENTRY"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Utility to actually perform an R_FR30_20 reloc.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|fr30_elf_i20_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|unsigned
name|long
name|x
decl_stmt|;
comment|/* This part is from bfd_elf_generic_reloc.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|reloc_entry
operator|->
name|howto
operator|->
name|partial_inplace
operator|||
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
operator|)
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
comment|/* FIXME: See bfd_perform_relocation.  Is this right?  */
return|return
name|bfd_reloc_ok
return|;
name|relocation
operator|=
name|symbol
operator|->
name|value
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
operator|+
name|reloc_entry
operator|->
name|addend
expr_stmt|;
if|if
condition|(
name|relocation
operator|>
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|20
operator|)
operator|-
literal|1
operator|)
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|x
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xff0f0000
operator|)
operator||
operator|(
name|relocation
operator|&
literal|0x0000ffff
operator|)
operator||
operator|(
operator|(
name|relocation
operator|&
literal|0x000f0000
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|x
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Utility to actually perform a R_FR30_48 reloc.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|fr30_elf_i32_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|bfd_vma
name|relocation
decl_stmt|;
comment|/* This part is from bfd_elf_generic_reloc.  */
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|reloc_entry
operator|->
name|howto
operator|->
name|partial_inplace
operator|||
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
operator|)
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
comment|/* FIXME: See bfd_perform_relocation.  Is this right?  */
return|return
name|bfd_reloc_ok
return|;
name|relocation
operator|=
name|symbol
operator|->
name|value
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
operator|+
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|relocation
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Map BFD reloc types to FR30 ELF reloc types.  */
end_comment

begin_struct
struct|struct
name|fr30_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_val
decl_stmt|;
name|unsigned
name|int
name|fr30_reloc_val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|fr30_reloc_map
name|fr30_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_FR30_NONE
block|}
block|,
block|{
name|BFD_RELOC_8
block|,
name|R_FR30_8
block|}
block|,
block|{
name|BFD_RELOC_FR30_20
block|,
name|R_FR30_20
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_FR30_32
block|}
block|,
block|{
name|BFD_RELOC_FR30_48
block|,
name|R_FR30_48
block|}
block|,
block|{
name|BFD_RELOC_FR30_6_IN_4
block|,
name|R_FR30_6_IN_4
block|}
block|,
block|{
name|BFD_RELOC_FR30_8_IN_8
block|,
name|R_FR30_8_IN_8
block|}
block|,
block|{
name|BFD_RELOC_FR30_9_IN_8
block|,
name|R_FR30_9_IN_8
block|}
block|,
block|{
name|BFD_RELOC_FR30_10_IN_8
block|,
name|R_FR30_10_IN_8
block|}
block|,
block|{
name|BFD_RELOC_FR30_9_PCREL
block|,
name|R_FR30_9_PCREL
block|}
block|,
block|{
name|BFD_RELOC_FR30_12_PCREL
block|,
name|R_FR30_12_PCREL
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_INHERIT
block|,
name|R_FR30_GNU_VTINHERIT
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_ENTRY
block|,
name|R_FR30_GNU_VTENTRY
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|fr30_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|fr30_reloc_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|fr30_reloc_map
index|[
literal|0
index|]
argument_list|)
init|;
operator|--
name|i
condition|;
control|)
if|if
condition|(
name|fr30_reloc_map
index|[
name|i
index|]
operator|.
name|bfd_reloc_val
operator|==
name|code
condition|)
return|return
operator|&
name|fr30_elf_howto_table
index|[
name|fr30_reloc_map
index|[
name|i
index|]
operator|.
name|fr30_reloc_val
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set the howto pointer for an FR30 ELF reloc.  */
end_comment

begin_function
specifier|static
name|void
name|fr30_info_to_howto_rela
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r_type
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_FR30_max
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|fr30_elf_howto_table
index|[
name|r_type
index|]
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform a single relocation.  By default we use the standard BFD    routines, but a few relocs, we have to do them ourselves.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|fr30_final_link_relocate
parameter_list|(
name|howto
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|rel
parameter_list|,
name|relocation
parameter_list|)
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
block|{
name|bfd_reloc_status_type
name|r
init|=
name|bfd_reloc_ok
decl_stmt|;
name|bfd_vma
name|x
decl_stmt|;
name|bfd_signed_vma
name|srel
decl_stmt|;
switch|switch
condition|(
name|howto
operator|->
name|type
condition|)
block|{
case|case
name|R_FR30_20
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|relocation
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|relocation
operator|>
operator|(
operator|(
literal|1
operator|<<
literal|20
operator|)
operator|-
literal|1
operator|)
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|x
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xff0f0000
operator|)
operator||
operator|(
name|relocation
operator|&
literal|0x0000ffff
operator|)
operator||
operator|(
operator|(
name|relocation
operator|&
literal|0x000f0000
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_FR30_48
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
operator|+
literal|2
expr_stmt|;
name|relocation
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|relocation
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_FR30_9_PCREL
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
operator|+
literal|1
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
expr_stmt|;
name|srel
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|-=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|-=
literal|2
expr_stmt|;
comment|/* Branch instructions add 2 to the PC...  */
name|srel
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|srel
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
if|if
condition|(
name|srel
operator|>
operator|(
operator|(
literal|1
operator|<<
literal|8
operator|)
operator|-
literal|1
operator|)
operator|||
operator|(
name|srel
operator|<
operator|-
operator|(
literal|1
operator|<<
literal|8
operator|)
operator|)
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|bfd_put_8
argument_list|(
name|input_bfd
argument_list|,
name|srel
operator|>>
literal|1
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_FR30_12_PCREL
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
expr_stmt|;
name|srel
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|-=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|-=
literal|2
expr_stmt|;
comment|/* Branch instructions add 2 to the PC...  */
name|srel
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|srel
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
if|if
condition|(
name|srel
operator|>
operator|(
operator|(
literal|1
operator|<<
literal|11
operator|)
operator|-
literal|1
operator|)
operator|||
operator|(
name|srel
operator|<
operator|-
operator|(
literal|1
operator|<<
literal|11
operator|)
operator|)
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf800
operator|)
operator||
operator|(
operator|(
name|srel
operator|>>
literal|1
operator|)
operator|&
literal|0x7ff
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
default|default:
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Relocate an FR30 ELF section.     The RELOCATE_SECTION function is called by the new ELF backend linker    to handle the relocations for a section.     The relocs are always passed as Rela structures; if the section    actually uses Rel structures, the r_addend field will always be    zero.     This function is responsible for adjusting the section contents as    necessary, and (if using Rela relocs and generating a relocatable    output file) adjusting the reloc addend as necessary.     This function does not have to worry about setting the reloc    address or the reloc symbol index.     LOCAL_SYMS is a pointer to the swapped in local symbols.     LOCAL_SECTIONS is an array giving the section in the input file    corresponding to the st_shndx field of each local symbol.     The global hash table entry for the global symbols can be found    via elf_sym_hashes (input_bfd).     When generating relocatable output, this function must handle    STB_LOCAL/STT_SECTION symbols specially.  The output symbol is    going to be the section symbol corresponding to the output    section, which means that the addend must be adjusted    accordingly.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|fr30_elf_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_FR30_GNU_VTINHERIT
operator|||
name|r_type
operator|==
name|R_FR30_GNU_VTENTRY
condition|)
continue|continue;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|howto
operator|=
name|fr30_elf_howto_table
operator|+
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|name
operator|==
name|NULL
operator|)
condition|?
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
else|:
name|name
expr_stmt|;
block|}
else|else
block|{
name|bfd_boolean
name|unresolved_reloc
decl_stmt|,
name|warned
decl_stmt|;
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
block|}
name|r
operator|=
name|fr30_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_overflow
case|:
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
argument_list|(
name|info
argument_list|,
operator|(
name|h
condition|?
operator|&
name|h
operator|->
name|root
else|:
name|NULL
operator|)
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_undefined
case|:
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: out of range error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_notsupported
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unsupported relocation error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_dangerous
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: dangerous relocation"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unknown error"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|msg
condition|)
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the section that should be marked against GC for a given    relocation.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|fr30_elf_gc_mark_hook
parameter_list|(
name|sec
parameter_list|,
name|info
parameter_list|,
name|rel
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_FR30_GNU_VTINHERIT
case|:
case|case
name|R_FR30_GNU_VTENTRY
case|:
break|break;
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
default|default:
break|break;
block|}
block|}
block|}
else|else
return|return
name|bfd_section_from_elf_index
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Update the got entry reference counts for the section being removed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|fr30_elf_gc_sweep_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase.    Since we don't do .gots or .plts, we just need to consider the    virtual table relocs for gc.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|fr30_elf_check_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|,
modifier|*
modifier|*
name|sym_hashes_end
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_hashes_end
operator|=
name|sym_hashes
operator|+
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|sym_hashes_end
operator|-=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
comment|/* This relocation describes the C++ object vtable hierarchy.            Reconstruct it for later use during GC.  */
case|case
name|R_FR30_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually            used.  Record for later use during GC.  */
case|case
name|R_FR30_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_fr30
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_FR30
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT1
value|EM_CYGNUS_FR30
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1000
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_fr30_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-fr30"
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|NULL
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|fr30_info_to_howto_rela
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|fr30_elf_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|fr30_elf_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|fr30_elf_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|fr30_elf_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_rela_normal
value|1
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|fr30_reloc_type_lookup
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

