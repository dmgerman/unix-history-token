begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* bfd back-end for HP PA-RISC SOM objects.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.     Contributed by the Center for Software Science at the    University of Utah.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA    02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"alloca-conf.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HOST_HPPAHPUX
argument_list|)
operator|||
name|defined
argument_list|(
name|HOST_HPPABSD
argument_list|)
operator|||
name|defined
argument_list|(
name|HOST_HPPAOSF
argument_list|)
operator|||
name|defined
argument_list|(
name|HOST_HPPAMPEIX
argument_list|)
end_if

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"som.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|hppa_som_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|som_mkobject
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|som_is_space
parameter_list|(
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|som_is_subspace
parameter_list|(
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compare_subspaces
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|som_compute_checksum
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|som_build_and_write_symbol_table
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|som_slurp_symbol_table
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Magic not defined in standard HP-UX header files until 8.0.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CPU_PA_RISC1_0
end_ifndef

begin_define
define|#
directive|define
name|CPU_PA_RISC1_0
value|0x20B
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CPU_PA_RISC1_0 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CPU_PA_RISC1_1
end_ifndef

begin_define
define|#
directive|define
name|CPU_PA_RISC1_1
value|0x210
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CPU_PA_RISC1_1 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CPU_PA_RISC2_0
end_ifndef

begin_define
define|#
directive|define
name|CPU_PA_RISC2_0
value|0x214
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CPU_PA_RISC2_0 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_PA_RISC1_0_ID
end_ifndef

begin_define
define|#
directive|define
name|_PA_RISC1_0_ID
value|CPU_PA_RISC1_0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _PA_RISC1_0_ID */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_PA_RISC1_1_ID
end_ifndef

begin_define
define|#
directive|define
name|_PA_RISC1_1_ID
value|CPU_PA_RISC1_1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _PA_RISC1_1_ID */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_PA_RISC2_0_ID
end_ifndef

begin_define
define|#
directive|define
name|_PA_RISC2_0_ID
value|CPU_PA_RISC2_0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _PA_RISC2_0_ID */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_PA_RISC_MAXID
end_ifndef

begin_define
define|#
directive|define
name|_PA_RISC_MAXID
value|0x2FF
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _PA_RISC_MAXID */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_PA_RISC_ID
end_ifndef

begin_define
define|#
directive|define
name|_PA_RISC_ID
parameter_list|(
name|__m_num
parameter_list|)
define|\
value|(((__m_num) == _PA_RISC1_0_ID) ||	\      ((__m_num)>= _PA_RISC1_1_ID&& (__m_num)<= _PA_RISC_MAXID))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _PA_RISC_ID */
end_comment

begin_comment
comment|/* HIUX in it's infinite stupidity changed the names for several "well    known" constants.  Work around such braindamage.  Try the HPUX version    first, then the HIUX version, and finally provide a default.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HPUX_AUX_ID
end_ifdef

begin_define
define|#
directive|define
name|EXEC_AUX_ID
value|HPUX_AUX_ID
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EXEC_AUX_ID
argument_list|)
operator|&&
name|defined
argument_list|(
name|HIUX_AUX_ID
argument_list|)
end_if

begin_define
define|#
directive|define
name|EXEC_AUX_ID
value|HIUX_AUX_ID
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EXEC_AUX_ID
end_ifndef

begin_define
define|#
directive|define
name|EXEC_AUX_ID
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Size (in chars) of the temporary buffers used during fixup and string    table writes.   */
end_comment

begin_define
define|#
directive|define
name|SOM_TMP_BUFSIZE
value|8192
end_define

begin_comment
comment|/* Size of the hash table in archives.  */
end_comment

begin_define
define|#
directive|define
name|SOM_LST_HASH_SIZE
value|31
end_define

begin_comment
comment|/* Max number of SOMs to be found in an archive.  */
end_comment

begin_define
define|#
directive|define
name|SOM_LST_MODULE_LIMIT
value|1024
end_define

begin_comment
comment|/* Generic alignment macro.  */
end_comment

begin_define
define|#
directive|define
name|SOM_ALIGN
parameter_list|(
name|val
parameter_list|,
name|alignment
parameter_list|)
define|\
value|(((val) + (alignment) - 1)&~ ((unsigned long) (alignment) - 1))
end_define

begin_comment
comment|/* SOM allows any one of the four previous relocations to be reused    with a "R_PREV_FIXUP" relocation entry.  Since R_PREV_FIXUP    relocations are always a single byte, using a R_PREV_FIXUP instead    of some multi-byte relocation makes object files smaller.     Note one side effect of using a R_PREV_FIXUP is the relocation that    is being repeated moves to the front of the queue.  */
end_comment

begin_struct
struct|struct
name|reloc_queue
block|{
name|unsigned
name|char
modifier|*
name|reloc
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|}
name|reloc_queue
index|[
literal|4
index|]
struct|;
end_struct

begin_comment
comment|/* This fully describes the symbol types which may be attached to    an EXPORT or IMPORT directive.  Only SOM uses this formation    (ELF has no need for it).  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|SYMBOL_TYPE_UNKNOWN
block|,
name|SYMBOL_TYPE_ABSOLUTE
block|,
name|SYMBOL_TYPE_CODE
block|,
name|SYMBOL_TYPE_DATA
block|,
name|SYMBOL_TYPE_ENTRY
block|,
name|SYMBOL_TYPE_MILLICODE
block|,
name|SYMBOL_TYPE_PLABEL
block|,
name|SYMBOL_TYPE_PRI_PROG
block|,
name|SYMBOL_TYPE_SEC_PROG
block|, }
name|pa_symbol_type
typedef|;
end_typedef

begin_struct
struct|struct
name|section_to_type
block|{
name|char
modifier|*
name|section
decl_stmt|;
name|char
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Assorted symbol information that needs to be derived from the BFD symbol    and/or the BFD backend private symbol data.  */
end_comment

begin_struct
struct|struct
name|som_misc_symbol_info
block|{
name|unsigned
name|int
name|symbol_type
decl_stmt|;
name|unsigned
name|int
name|symbol_scope
decl_stmt|;
name|unsigned
name|int
name|arg_reloc
decl_stmt|;
name|unsigned
name|int
name|symbol_info
decl_stmt|;
name|unsigned
name|int
name|symbol_value
decl_stmt|;
name|unsigned
name|int
name|priv_level
decl_stmt|;
name|unsigned
name|int
name|secondary_def
decl_stmt|;
name|unsigned
name|int
name|is_comdat
decl_stmt|;
name|unsigned
name|int
name|is_common
decl_stmt|;
name|unsigned
name|int
name|dup_common
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Map SOM section names to POSIX/BSD single-character symbol types.     This table includes all the standard subspaces as defined in the    current "PRO ABI for PA-RISC Systems", $UNWIND$ which for    some reason was left out, and sections specific to embedded stabs.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|section_to_type
name|stt
index|[]
init|=
block|{
block|{
literal|"$TEXT$"
block|,
literal|'t'
block|}
block|,
block|{
literal|"$SHLIB_INFO$"
block|,
literal|'t'
block|}
block|,
block|{
literal|"$MILLICODE$"
block|,
literal|'t'
block|}
block|,
block|{
literal|"$LIT$"
block|,
literal|'t'
block|}
block|,
block|{
literal|"$CODE$"
block|,
literal|'t'
block|}
block|,
block|{
literal|"$UNWIND_START$"
block|,
literal|'t'
block|}
block|,
block|{
literal|"$UNWIND$"
block|,
literal|'t'
block|}
block|,
block|{
literal|"$PRIVATE$"
block|,
literal|'d'
block|}
block|,
block|{
literal|"$PLT$"
block|,
literal|'d'
block|}
block|,
block|{
literal|"$SHLIB_DATA$"
block|,
literal|'d'
block|}
block|,
block|{
literal|"$DATA$"
block|,
literal|'d'
block|}
block|,
block|{
literal|"$SHORTDATA$"
block|,
literal|'g'
block|}
block|,
block|{
literal|"$DLT$"
block|,
literal|'d'
block|}
block|,
block|{
literal|"$GLOBAL$"
block|,
literal|'g'
block|}
block|,
block|{
literal|"$SHORTBSS$"
block|,
literal|'s'
block|}
block|,
block|{
literal|"$BSS$"
block|,
literal|'b'
block|}
block|,
block|{
literal|"$GDB_STRINGS$"
block|,
literal|'N'
block|}
block|,
block|{
literal|"$GDB_SYMBOLS$"
block|,
literal|'N'
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* About the relocation formatting table...     There are 256 entries in the table, one for each possible    relocation opcode available in SOM.  We index the table by    the relocation opcode.  The names and operations are those    defined by a.out_800 (4).     Right now this table is only used to count and perform minimal    processing on relocation streams so that they can be internalized    into BFD and symbolically printed by utilities.  To make actual use    of them would be much more difficult, BFD's concept of relocations    is far too simple to handle SOM relocations.  The basic assumption    that a relocation can be completely processed independent of other    relocations before an object file is written is invalid for SOM.     The SOM relocations are meant to be processed as a stream, they    specify copying of data from the input section to the output section    while possibly modifying the data in some manner.  They also can    specify that a variable number of zeros or uninitialized data be    inserted on in the output segment at the current offset.  Some    relocations specify that some previous relocation be re-applied at    the current location in the input/output sections.  And finally a number    of relocations have effects on other sections (R_ENTRY, R_EXIT,    R_UNWIND_AUX and a variety of others).  There isn't even enough room    in the BFD relocation data structure to store enough information to    perform all the relocations.     Each entry in the table has three fields.     The first entry is an index into this "class" of relocations.  This    index can then be used as a variable within the relocation itself.     The second field is a format string which actually controls processing    of the relocation.  It uses a simple postfix machine to do calculations    based on variables/constants found in the string and the relocation    stream.     The third field specifys whether or not this relocation may use    a constant (V) from the previous R_DATA_OVERRIDE rather than a constant    stored in the instruction.     Variables:     L = input space byte count    D = index into class of relocations    M = output space byte count    N = statement number (unused?)    O = stack operation    R = parameter relocation bits    S = symbol index    T = first 32 bits of stack unwind information    U = second 32 bits of stack unwind information    V = a literal constant (usually used in the next relocation)    P = a previous relocation     Lower case letters (starting with 'b') refer to following    bytes in the relocation stream.  'b' is the next 1 byte,    c is the next 2 bytes, d is the next 3 bytes, etc...    This is the variable part of the relocation entries that    makes our life a living hell.     numerical constants are also used in the format string.  Note    the constants are represented in decimal.     '+', "*" and "=" represents the obvious postfix operators.    '<' represents a left shift.     Stack Operations:     Parameter Relocation Bits:     Unwind Entries:     Previous Relocations:  The index field represents which in the queue    of 4 previous fixups should be re-applied.     Literal Constants:  These are generally used to represent addend    parts of relocations when these constants are not stored in the    fields of the instructions themselves.  For example the instruction    addil foo-$global$-0x1234 would use an override for "0x1234" rather    than storing it into the addil itself.  */
end_comment

begin_struct
struct|struct
name|fixup_format
block|{
name|int
name|D
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|fixup_format
name|som_fixup_formats
index|[
literal|256
index|]
init|=
block|{
comment|/* R_NO_RELOCATION.  */
block|{
literal|0
block|,
literal|"LD1+4*="
block|}
block|,
comment|/* 0x00 */
block|{
literal|1
block|,
literal|"LD1+4*="
block|}
block|,
comment|/* 0x01 */
block|{
literal|2
block|,
literal|"LD1+4*="
block|}
block|,
comment|/* 0x02 */
block|{
literal|3
block|,
literal|"LD1+4*="
block|}
block|,
comment|/* 0x03 */
block|{
literal|4
block|,
literal|"LD1+4*="
block|}
block|,
comment|/* 0x04 */
block|{
literal|5
block|,
literal|"LD1+4*="
block|}
block|,
comment|/* 0x05 */
block|{
literal|6
block|,
literal|"LD1+4*="
block|}
block|,
comment|/* 0x06 */
block|{
literal|7
block|,
literal|"LD1+4*="
block|}
block|,
comment|/* 0x07 */
block|{
literal|8
block|,
literal|"LD1+4*="
block|}
block|,
comment|/* 0x08 */
block|{
literal|9
block|,
literal|"LD1+4*="
block|}
block|,
comment|/* 0x09 */
block|{
literal|10
block|,
literal|"LD1+4*="
block|}
block|,
comment|/* 0x0a */
block|{
literal|11
block|,
literal|"LD1+4*="
block|}
block|,
comment|/* 0x0b */
block|{
literal|12
block|,
literal|"LD1+4*="
block|}
block|,
comment|/* 0x0c */
block|{
literal|13
block|,
literal|"LD1+4*="
block|}
block|,
comment|/* 0x0d */
block|{
literal|14
block|,
literal|"LD1+4*="
block|}
block|,
comment|/* 0x0e */
block|{
literal|15
block|,
literal|"LD1+4*="
block|}
block|,
comment|/* 0x0f */
block|{
literal|16
block|,
literal|"LD1+4*="
block|}
block|,
comment|/* 0x10 */
block|{
literal|17
block|,
literal|"LD1+4*="
block|}
block|,
comment|/* 0x11 */
block|{
literal|18
block|,
literal|"LD1+4*="
block|}
block|,
comment|/* 0x12 */
block|{
literal|19
block|,
literal|"LD1+4*="
block|}
block|,
comment|/* 0x13 */
block|{
literal|20
block|,
literal|"LD1+4*="
block|}
block|,
comment|/* 0x14 */
block|{
literal|21
block|,
literal|"LD1+4*="
block|}
block|,
comment|/* 0x15 */
block|{
literal|22
block|,
literal|"LD1+4*="
block|}
block|,
comment|/* 0x16 */
block|{
literal|23
block|,
literal|"LD1+4*="
block|}
block|,
comment|/* 0x17 */
block|{
literal|0
block|,
literal|"LD8<b+1+4*="
block|}
block|,
comment|/* 0x18 */
block|{
literal|1
block|,
literal|"LD8<b+1+4*="
block|}
block|,
comment|/* 0x19 */
block|{
literal|2
block|,
literal|"LD8<b+1+4*="
block|}
block|,
comment|/* 0x1a */
block|{
literal|3
block|,
literal|"LD8<b+1+4*="
block|}
block|,
comment|/* 0x1b */
block|{
literal|0
block|,
literal|"LD16<c+1+4*="
block|}
block|,
comment|/* 0x1c */
block|{
literal|1
block|,
literal|"LD16<c+1+4*="
block|}
block|,
comment|/* 0x1d */
block|{
literal|2
block|,
literal|"LD16<c+1+4*="
block|}
block|,
comment|/* 0x1e */
block|{
literal|0
block|,
literal|"Ld1+="
block|}
block|,
comment|/* 0x1f */
comment|/* R_ZEROES.  */
block|{
literal|0
block|,
literal|"Lb1+4*="
block|}
block|,
comment|/* 0x20 */
block|{
literal|1
block|,
literal|"Ld1+="
block|}
block|,
comment|/* 0x21 */
comment|/* R_UNINIT.  */
block|{
literal|0
block|,
literal|"Lb1+4*="
block|}
block|,
comment|/* 0x22 */
block|{
literal|1
block|,
literal|"Ld1+="
block|}
block|,
comment|/* 0x23 */
comment|/* R_RELOCATION.  */
block|{
literal|0
block|,
literal|"L4="
block|}
block|,
comment|/* 0x24 */
comment|/* R_DATA_ONE_SYMBOL.  */
block|{
literal|0
block|,
literal|"L4=Sb="
block|}
block|,
comment|/* 0x25 */
block|{
literal|1
block|,
literal|"L4=Sd="
block|}
block|,
comment|/* 0x26 */
comment|/* R_DATA_PLEBEL.  */
block|{
literal|0
block|,
literal|"L4=Sb="
block|}
block|,
comment|/* 0x27 */
block|{
literal|1
block|,
literal|"L4=Sd="
block|}
block|,
comment|/* 0x28 */
comment|/* R_SPACE_REF.  */
block|{
literal|0
block|,
literal|"L4="
block|}
block|,
comment|/* 0x29 */
comment|/* R_REPEATED_INIT.  */
block|{
literal|0
block|,
literal|"L4=Mb1+4*="
block|}
block|,
comment|/* 0x2a */
block|{
literal|1
block|,
literal|"Lb4*=Mb1+L*="
block|}
block|,
comment|/* 0x2b */
block|{
literal|2
block|,
literal|"Lb4*=Md1+4*="
block|}
block|,
comment|/* 0x2c */
block|{
literal|3
block|,
literal|"Ld1+=Me1+="
block|}
block|,
comment|/* 0x2d */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0x2e */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0x2f */
comment|/* R_PCREL_CALL.  */
block|{
literal|0
block|,
literal|"L4=RD=Sb="
block|}
block|,
comment|/* 0x30 */
block|{
literal|1
block|,
literal|"L4=RD=Sb="
block|}
block|,
comment|/* 0x31 */
block|{
literal|2
block|,
literal|"L4=RD=Sb="
block|}
block|,
comment|/* 0x32 */
block|{
literal|3
block|,
literal|"L4=RD=Sb="
block|}
block|,
comment|/* 0x33 */
block|{
literal|4
block|,
literal|"L4=RD=Sb="
block|}
block|,
comment|/* 0x34 */
block|{
literal|5
block|,
literal|"L4=RD=Sb="
block|}
block|,
comment|/* 0x35 */
block|{
literal|6
block|,
literal|"L4=RD=Sb="
block|}
block|,
comment|/* 0x36 */
block|{
literal|7
block|,
literal|"L4=RD=Sb="
block|}
block|,
comment|/* 0x37 */
block|{
literal|8
block|,
literal|"L4=RD=Sb="
block|}
block|,
comment|/* 0x38 */
block|{
literal|9
block|,
literal|"L4=RD=Sb="
block|}
block|,
comment|/* 0x39 */
block|{
literal|0
block|,
literal|"L4=RD8<b+=Sb="
block|}
block|,
comment|/* 0x3a */
block|{
literal|1
block|,
literal|"L4=RD8<b+=Sb="
block|}
block|,
comment|/* 0x3b */
block|{
literal|0
block|,
literal|"L4=RD8<b+=Sd="
block|}
block|,
comment|/* 0x3c */
block|{
literal|1
block|,
literal|"L4=RD8<b+=Sd="
block|}
block|,
comment|/* 0x3d */
comment|/* R_SHORT_PCREL_MODE.  */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0x3e */
comment|/* R_LONG_PCREL_MODE.  */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0x3f */
comment|/* R_ABS_CALL.  */
block|{
literal|0
block|,
literal|"L4=RD=Sb="
block|}
block|,
comment|/* 0x40 */
block|{
literal|1
block|,
literal|"L4=RD=Sb="
block|}
block|,
comment|/* 0x41 */
block|{
literal|2
block|,
literal|"L4=RD=Sb="
block|}
block|,
comment|/* 0x42 */
block|{
literal|3
block|,
literal|"L4=RD=Sb="
block|}
block|,
comment|/* 0x43 */
block|{
literal|4
block|,
literal|"L4=RD=Sb="
block|}
block|,
comment|/* 0x44 */
block|{
literal|5
block|,
literal|"L4=RD=Sb="
block|}
block|,
comment|/* 0x45 */
block|{
literal|6
block|,
literal|"L4=RD=Sb="
block|}
block|,
comment|/* 0x46 */
block|{
literal|7
block|,
literal|"L4=RD=Sb="
block|}
block|,
comment|/* 0x47 */
block|{
literal|8
block|,
literal|"L4=RD=Sb="
block|}
block|,
comment|/* 0x48 */
block|{
literal|9
block|,
literal|"L4=RD=Sb="
block|}
block|,
comment|/* 0x49 */
block|{
literal|0
block|,
literal|"L4=RD8<b+=Sb="
block|}
block|,
comment|/* 0x4a */
block|{
literal|1
block|,
literal|"L4=RD8<b+=Sb="
block|}
block|,
comment|/* 0x4b */
block|{
literal|0
block|,
literal|"L4=RD8<b+=Sd="
block|}
block|,
comment|/* 0x4c */
block|{
literal|1
block|,
literal|"L4=RD8<b+=Sd="
block|}
block|,
comment|/* 0x4d */
comment|/* R_RESERVED.  */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0x4e */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0x4f */
comment|/* R_DP_RELATIVE.  */
block|{
literal|0
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x50 */
block|{
literal|1
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x51 */
block|{
literal|2
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x52 */
block|{
literal|3
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x53 */
block|{
literal|4
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x54 */
block|{
literal|5
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x55 */
block|{
literal|6
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x56 */
block|{
literal|7
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x57 */
block|{
literal|8
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x58 */
block|{
literal|9
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x59 */
block|{
literal|10
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x5a */
block|{
literal|11
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x5b */
block|{
literal|12
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x5c */
block|{
literal|13
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x5d */
block|{
literal|14
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x5e */
block|{
literal|15
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x5f */
block|{
literal|16
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x60 */
block|{
literal|17
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x61 */
block|{
literal|18
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x62 */
block|{
literal|19
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x63 */
block|{
literal|20
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x64 */
block|{
literal|21
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x65 */
block|{
literal|22
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x66 */
block|{
literal|23
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x67 */
block|{
literal|24
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x68 */
block|{
literal|25
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x69 */
block|{
literal|26
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x6a */
block|{
literal|27
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x6b */
block|{
literal|28
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x6c */
block|{
literal|29
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x6d */
block|{
literal|30
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x6e */
block|{
literal|31
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x6f */
block|{
literal|32
block|,
literal|"L4=Sb="
block|}
block|,
comment|/* 0x70 */
block|{
literal|33
block|,
literal|"L4=Sd="
block|}
block|,
comment|/* 0x71 */
comment|/* R_RESERVED.  */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0x72 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0x73 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0x74 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0x75 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0x76 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0x77 */
comment|/* R_DLT_REL.  */
block|{
literal|0
block|,
literal|"L4=Sb="
block|}
block|,
comment|/* 0x78 */
block|{
literal|1
block|,
literal|"L4=Sd="
block|}
block|,
comment|/* 0x79 */
comment|/* R_RESERVED.  */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0x7a */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0x7b */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0x7c */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0x7d */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0x7e */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0x7f */
comment|/* R_CODE_ONE_SYMBOL.  */
block|{
literal|0
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x80 */
block|{
literal|1
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x81 */
block|{
literal|2
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x82 */
block|{
literal|3
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x83 */
block|{
literal|4
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x84 */
block|{
literal|5
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x85 */
block|{
literal|6
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x86 */
block|{
literal|7
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x87 */
block|{
literal|8
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x88 */
block|{
literal|9
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x89 */
block|{
literal|10
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x8q */
block|{
literal|11
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x8b */
block|{
literal|12
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x8c */
block|{
literal|13
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x8d */
block|{
literal|14
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x8e */
block|{
literal|15
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x8f */
block|{
literal|16
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x90 */
block|{
literal|17
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x91 */
block|{
literal|18
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x92 */
block|{
literal|19
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x93 */
block|{
literal|20
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x94 */
block|{
literal|21
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x95 */
block|{
literal|22
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x96 */
block|{
literal|23
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x97 */
block|{
literal|24
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x98 */
block|{
literal|25
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x99 */
block|{
literal|26
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x9a */
block|{
literal|27
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x9b */
block|{
literal|28
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x9c */
block|{
literal|29
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x9d */
block|{
literal|30
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x9e */
block|{
literal|31
block|,
literal|"L4=SD="
block|}
block|,
comment|/* 0x9f */
block|{
literal|32
block|,
literal|"L4=Sb="
block|}
block|,
comment|/* 0xa0 */
block|{
literal|33
block|,
literal|"L4=Sd="
block|}
block|,
comment|/* 0xa1 */
comment|/* R_RESERVED.  */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xa2 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xa3 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xa4 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xa5 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xa6 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xa7 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xa8 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xa9 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xaa */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xab */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xac */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xad */
comment|/* R_MILLI_REL.  */
block|{
literal|0
block|,
literal|"L4=Sb="
block|}
block|,
comment|/* 0xae */
block|{
literal|1
block|,
literal|"L4=Sd="
block|}
block|,
comment|/* 0xaf */
comment|/* R_CODE_PLABEL.  */
block|{
literal|0
block|,
literal|"L4=Sb="
block|}
block|,
comment|/* 0xb0 */
block|{
literal|1
block|,
literal|"L4=Sd="
block|}
block|,
comment|/* 0xb1 */
comment|/* R_BREAKPOINT.  */
block|{
literal|0
block|,
literal|"L4="
block|}
block|,
comment|/* 0xb2 */
comment|/* R_ENTRY.  */
block|{
literal|0
block|,
literal|"Te=Ue="
block|}
block|,
comment|/* 0xb3 */
block|{
literal|1
block|,
literal|"Uf="
block|}
block|,
comment|/* 0xb4 */
comment|/* R_ALT_ENTRY.  */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xb5 */
comment|/* R_EXIT.  */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xb6 */
comment|/* R_BEGIN_TRY.  */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xb7 */
comment|/* R_END_TRY.  */
block|{
literal|0
block|,
literal|"R0="
block|}
block|,
comment|/* 0xb8 */
block|{
literal|1
block|,
literal|"Rb4*="
block|}
block|,
comment|/* 0xb9 */
block|{
literal|2
block|,
literal|"Rd4*="
block|}
block|,
comment|/* 0xba */
comment|/* R_BEGIN_BRTAB.  */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xbb */
comment|/* R_END_BRTAB.  */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xbc */
comment|/* R_STATEMENT.  */
block|{
literal|0
block|,
literal|"Nb="
block|}
block|,
comment|/* 0xbd */
block|{
literal|1
block|,
literal|"Nc="
block|}
block|,
comment|/* 0xbe */
block|{
literal|2
block|,
literal|"Nd="
block|}
block|,
comment|/* 0xbf */
comment|/* R_DATA_EXPR.  */
block|{
literal|0
block|,
literal|"L4="
block|}
block|,
comment|/* 0xc0 */
comment|/* R_CODE_EXPR.  */
block|{
literal|0
block|,
literal|"L4="
block|}
block|,
comment|/* 0xc1 */
comment|/* R_FSEL.  */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xc2 */
comment|/* R_LSEL.  */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xc3 */
comment|/* R_RSEL.  */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xc4 */
comment|/* R_N_MODE.  */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xc5 */
comment|/* R_S_MODE.  */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xc6 */
comment|/* R_D_MODE.  */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xc7 */
comment|/* R_R_MODE.  */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xc8 */
comment|/* R_DATA_OVERRIDE.  */
block|{
literal|0
block|,
literal|"V0="
block|}
block|,
comment|/* 0xc9 */
block|{
literal|1
block|,
literal|"Vb="
block|}
block|,
comment|/* 0xca */
block|{
literal|2
block|,
literal|"Vc="
block|}
block|,
comment|/* 0xcb */
block|{
literal|3
block|,
literal|"Vd="
block|}
block|,
comment|/* 0xcc */
block|{
literal|4
block|,
literal|"Ve="
block|}
block|,
comment|/* 0xcd */
comment|/* R_TRANSLATED.  */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xce */
comment|/* R_AUX_UNWIND.  */
block|{
literal|0
block|,
literal|"Sd=Ve=Ee="
block|}
block|,
comment|/* 0xcf */
comment|/* R_COMP1.  */
block|{
literal|0
block|,
literal|"Ob="
block|}
block|,
comment|/* 0xd0 */
comment|/* R_COMP2.  */
block|{
literal|0
block|,
literal|"Ob=Sd="
block|}
block|,
comment|/* 0xd1 */
comment|/* R_COMP3.  */
block|{
literal|0
block|,
literal|"Ob=Ve="
block|}
block|,
comment|/* 0xd2 */
comment|/* R_PREV_FIXUP.  */
block|{
literal|0
block|,
literal|"P"
block|}
block|,
comment|/* 0xd3 */
block|{
literal|1
block|,
literal|"P"
block|}
block|,
comment|/* 0xd4 */
block|{
literal|2
block|,
literal|"P"
block|}
block|,
comment|/* 0xd5 */
block|{
literal|3
block|,
literal|"P"
block|}
block|,
comment|/* 0xd6 */
comment|/* R_SEC_STMT.  */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xd7 */
comment|/* R_N0SEL.  */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xd8 */
comment|/* R_N1SEL.  */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xd9 */
comment|/* R_LINETAB.  */
block|{
literal|0
block|,
literal|"Eb=Sd=Ve="
block|}
block|,
comment|/* 0xda */
comment|/* R_LINETAB_ESC.  */
block|{
literal|0
block|,
literal|"Eb=Mb="
block|}
block|,
comment|/* 0xdb */
comment|/* R_LTP_OVERRIDE.  */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xdc */
comment|/* R_COMMENT.  */
block|{
literal|0
block|,
literal|"Ob=Vf="
block|}
block|,
comment|/* 0xdd */
comment|/* R_RESERVED.  */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xde */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xdf */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xe0 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xe1 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xe2 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xe3 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xe4 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xe5 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xe6 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xe7 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xe8 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xe9 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xea */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xeb */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xec */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xed */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xee */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xef */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xf0 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xf1 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xf2 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xf3 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xf4 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xf5 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xf6 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xf7 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xf8 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xf9 */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xfa */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xfb */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xfc */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xfd */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xfe */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* 0xff */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|comp1_opcodes
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x40
block|,
literal|0x41
block|,
literal|0x42
block|,
literal|0x43
block|,
literal|0x44
block|,
literal|0x45
block|,
literal|0x46
block|,
literal|0x47
block|,
literal|0x48
block|,
literal|0x49
block|,
literal|0x4a
block|,
literal|0x4b
block|,
literal|0x60
block|,
literal|0x80
block|,
literal|0xa0
block|,
literal|0xc0
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|comp2_opcodes
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x80
block|,
literal|0x82
block|,
literal|0xc0
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|comp3_opcodes
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x02
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These apparently are not in older versions of hpux reloc.h (hpux7).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|R_DLT_REL
end_ifndef

begin_define
define|#
directive|define
name|R_DLT_REL
value|0x78
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|R_AUX_UNWIND
end_ifndef

begin_define
define|#
directive|define
name|R_AUX_UNWIND
value|0xcf
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|R_SEC_STMT
end_ifndef

begin_define
define|#
directive|define
name|R_SEC_STMT
value|0xd7
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* And these first appeared in hpux10.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|R_SHORT_PCREL_MODE
end_ifndef

begin_define
define|#
directive|define
name|NO_PCREL_MODES
end_define

begin_define
define|#
directive|define
name|R_SHORT_PCREL_MODE
value|0x3e
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|R_LONG_PCREL_MODE
end_ifndef

begin_define
define|#
directive|define
name|R_LONG_PCREL_MODE
value|0x3f
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|R_N0SEL
end_ifndef

begin_define
define|#
directive|define
name|R_N0SEL
value|0xd8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|R_N1SEL
end_ifndef

begin_define
define|#
directive|define
name|R_N1SEL
value|0xd9
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|R_LINETAB
end_ifndef

begin_define
define|#
directive|define
name|R_LINETAB
value|0xda
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|R_LINETAB_ESC
end_ifndef

begin_define
define|#
directive|define
name|R_LINETAB_ESC
value|0xdb
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|R_LTP_OVERRIDE
end_ifndef

begin_define
define|#
directive|define
name|R_LTP_OVERRIDE
value|0xdc
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|R_COMMENT
end_ifndef

begin_define
define|#
directive|define
name|R_COMMENT
value|0xdd
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SOM_HOWTO
parameter_list|(
name|TYPE
parameter_list|,
name|NAME
parameter_list|)
define|\
value|HOWTO(TYPE, 0, 0, 32, FALSE, 0, 0, hppa_som_reloc, NAME, FALSE, 0, 0, FALSE)
end_define

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|som_hppa_howto_table
index|[]
init|=
block|{
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_NO_RELOCATION
argument_list|,
literal|"R_NO_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_ZEROES
argument_list|,
literal|"R_ZEROES"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_ZEROES
argument_list|,
literal|"R_ZEROES"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_UNINIT
argument_list|,
literal|"R_UNINIT"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_UNINIT
argument_list|,
literal|"R_UNINIT"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RELOCATION
argument_list|,
literal|"R_RELOCATION"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DATA_ONE_SYMBOL
argument_list|,
literal|"R_DATA_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DATA_ONE_SYMBOL
argument_list|,
literal|"R_DATA_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DATA_PLABEL
argument_list|,
literal|"R_DATA_PLABEL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DATA_PLABEL
argument_list|,
literal|"R_DATA_PLABEL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_SPACE_REF
argument_list|,
literal|"R_SPACE_REF"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_REPEATED_INIT
argument_list|,
literal|"REPEATED_INIT"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_REPEATED_INIT
argument_list|,
literal|"REPEATED_INIT"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_REPEATED_INIT
argument_list|,
literal|"REPEATED_INIT"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_REPEATED_INIT
argument_list|,
literal|"REPEATED_INIT"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_PCREL_CALL
argument_list|,
literal|"R_PCREL_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_PCREL_CALL
argument_list|,
literal|"R_PCREL_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_PCREL_CALL
argument_list|,
literal|"R_PCREL_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_PCREL_CALL
argument_list|,
literal|"R_PCREL_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_PCREL_CALL
argument_list|,
literal|"R_PCREL_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_PCREL_CALL
argument_list|,
literal|"R_PCREL_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_PCREL_CALL
argument_list|,
literal|"R_PCREL_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_PCREL_CALL
argument_list|,
literal|"R_PCREL_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_PCREL_CALL
argument_list|,
literal|"R_PCREL_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_PCREL_CALL
argument_list|,
literal|"R_PCREL_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_PCREL_CALL
argument_list|,
literal|"R_PCREL_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_PCREL_CALL
argument_list|,
literal|"R_PCREL_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_PCREL_CALL
argument_list|,
literal|"R_PCREL_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_PCREL_CALL
argument_list|,
literal|"R_PCREL_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_SHORT_PCREL_MODE
argument_list|,
literal|"R_SHORT_PCREL_MODE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_LONG_PCREL_MODE
argument_list|,
literal|"R_LONG_PCREL_MODE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_ABS_CALL
argument_list|,
literal|"R_ABS_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_ABS_CALL
argument_list|,
literal|"R_ABS_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_ABS_CALL
argument_list|,
literal|"R_ABS_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_ABS_CALL
argument_list|,
literal|"R_ABS_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_ABS_CALL
argument_list|,
literal|"R_ABS_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_ABS_CALL
argument_list|,
literal|"R_ABS_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_ABS_CALL
argument_list|,
literal|"R_ABS_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_ABS_CALL
argument_list|,
literal|"R_ABS_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_ABS_CALL
argument_list|,
literal|"R_ABS_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_ABS_CALL
argument_list|,
literal|"R_ABS_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_ABS_CALL
argument_list|,
literal|"R_ABS_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_ABS_CALL
argument_list|,
literal|"R_ABS_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_ABS_CALL
argument_list|,
literal|"R_ABS_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_ABS_CALL
argument_list|,
literal|"R_ABS_CALL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DP_RELATIVE
argument_list|,
literal|"R_DP_RELATIVE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DLT_REL
argument_list|,
literal|"R_DLT_REL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DLT_REL
argument_list|,
literal|"R_DLT_REL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_ONE_SYMBOL
argument_list|,
literal|"R_CODE_ONE_SYMBOL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_MILLI_REL
argument_list|,
literal|"R_MILLI_REL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_MILLI_REL
argument_list|,
literal|"R_MILLI_REL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_PLABEL
argument_list|,
literal|"R_CODE_PLABEL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_PLABEL
argument_list|,
literal|"R_CODE_PLABEL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_BREAKPOINT
argument_list|,
literal|"R_BREAKPOINT"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_ENTRY
argument_list|,
literal|"R_ENTRY"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_ENTRY
argument_list|,
literal|"R_ENTRY"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_ALT_ENTRY
argument_list|,
literal|"R_ALT_ENTRY"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_EXIT
argument_list|,
literal|"R_EXIT"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_BEGIN_TRY
argument_list|,
literal|"R_BEGIN_TRY"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_END_TRY
argument_list|,
literal|"R_END_TRY"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_END_TRY
argument_list|,
literal|"R_END_TRY"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_END_TRY
argument_list|,
literal|"R_END_TRY"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_BEGIN_BRTAB
argument_list|,
literal|"R_BEGIN_BRTAB"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_END_BRTAB
argument_list|,
literal|"R_END_BRTAB"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_STATEMENT
argument_list|,
literal|"R_STATEMENT"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_STATEMENT
argument_list|,
literal|"R_STATEMENT"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_STATEMENT
argument_list|,
literal|"R_STATEMENT"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DATA_EXPR
argument_list|,
literal|"R_DATA_EXPR"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_CODE_EXPR
argument_list|,
literal|"R_CODE_EXPR"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_FSEL
argument_list|,
literal|"R_FSEL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_LSEL
argument_list|,
literal|"R_LSEL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RSEL
argument_list|,
literal|"R_RSEL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_N_MODE
argument_list|,
literal|"R_N_MODE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_S_MODE
argument_list|,
literal|"R_S_MODE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_D_MODE
argument_list|,
literal|"R_D_MODE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_R_MODE
argument_list|,
literal|"R_R_MODE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DATA_OVERRIDE
argument_list|,
literal|"R_DATA_OVERRIDE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DATA_OVERRIDE
argument_list|,
literal|"R_DATA_OVERRIDE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DATA_OVERRIDE
argument_list|,
literal|"R_DATA_OVERRIDE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DATA_OVERRIDE
argument_list|,
literal|"R_DATA_OVERRIDE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_DATA_OVERRIDE
argument_list|,
literal|"R_DATA_OVERRIDE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_TRANSLATED
argument_list|,
literal|"R_TRANSLATED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_AUX_UNWIND
argument_list|,
literal|"R_AUX_UNWIND"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_COMP1
argument_list|,
literal|"R_COMP1"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_COMP2
argument_list|,
literal|"R_COMP2"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_COMP3
argument_list|,
literal|"R_COMP3"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_PREV_FIXUP
argument_list|,
literal|"R_PREV_FIXUP"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_PREV_FIXUP
argument_list|,
literal|"R_PREV_FIXUP"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_PREV_FIXUP
argument_list|,
literal|"R_PREV_FIXUP"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_PREV_FIXUP
argument_list|,
literal|"R_PREV_FIXUP"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_SEC_STMT
argument_list|,
literal|"R_SEC_STMT"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_N0SEL
argument_list|,
literal|"R_N0SEL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_N1SEL
argument_list|,
literal|"R_N1SEL"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_LINETAB
argument_list|,
literal|"R_LINETAB"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_LINETAB_ESC
argument_list|,
literal|"R_LINETAB_ESC"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_LTP_OVERRIDE
argument_list|,
literal|"R_LTP_OVERRIDE"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_COMMENT
argument_list|,
literal|"R_COMMENT"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
name|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|,
name|SOM_HOWTO
argument_list|(
argument|R_RESERVED
argument_list|,
literal|"R_RESERVED"
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the SOM relocation queue.  By definition the queue holds    the last four multibyte fixups.  */
end_comment

begin_function
specifier|static
name|void
name|som_initialize_reloc_queue
parameter_list|(
name|struct
name|reloc_queue
modifier|*
name|queue
parameter_list|)
block|{
name|queue
index|[
literal|0
index|]
operator|.
name|reloc
operator|=
name|NULL
expr_stmt|;
name|queue
index|[
literal|0
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|queue
index|[
literal|1
index|]
operator|.
name|reloc
operator|=
name|NULL
expr_stmt|;
name|queue
index|[
literal|1
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|queue
index|[
literal|2
index|]
operator|.
name|reloc
operator|=
name|NULL
expr_stmt|;
name|queue
index|[
literal|2
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|queue
index|[
literal|3
index|]
operator|.
name|reloc
operator|=
name|NULL
expr_stmt|;
name|queue
index|[
literal|3
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert a new relocation into the relocation queue.  */
end_comment

begin_function
specifier|static
name|void
name|som_reloc_queue_insert
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|struct
name|reloc_queue
modifier|*
name|queue
parameter_list|)
block|{
name|queue
index|[
literal|3
index|]
operator|.
name|reloc
operator|=
name|queue
index|[
literal|2
index|]
operator|.
name|reloc
expr_stmt|;
name|queue
index|[
literal|3
index|]
operator|.
name|size
operator|=
name|queue
index|[
literal|2
index|]
operator|.
name|size
expr_stmt|;
name|queue
index|[
literal|2
index|]
operator|.
name|reloc
operator|=
name|queue
index|[
literal|1
index|]
operator|.
name|reloc
expr_stmt|;
name|queue
index|[
literal|2
index|]
operator|.
name|size
operator|=
name|queue
index|[
literal|1
index|]
operator|.
name|size
expr_stmt|;
name|queue
index|[
literal|1
index|]
operator|.
name|reloc
operator|=
name|queue
index|[
literal|0
index|]
operator|.
name|reloc
expr_stmt|;
name|queue
index|[
literal|1
index|]
operator|.
name|size
operator|=
name|queue
index|[
literal|0
index|]
operator|.
name|size
expr_stmt|;
name|queue
index|[
literal|0
index|]
operator|.
name|reloc
operator|=
name|p
expr_stmt|;
name|queue
index|[
literal|0
index|]
operator|.
name|size
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When an entry in the relocation queue is reused, the entry moves    to the front of the queue.  */
end_comment

begin_function
specifier|static
name|void
name|som_reloc_queue_fix
parameter_list|(
name|struct
name|reloc_queue
modifier|*
name|queue
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|index
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|index
operator|==
literal|1
condition|)
block|{
name|unsigned
name|char
modifier|*
name|tmp1
init|=
name|queue
index|[
literal|0
index|]
operator|.
name|reloc
decl_stmt|;
name|unsigned
name|int
name|tmp2
init|=
name|queue
index|[
literal|0
index|]
operator|.
name|size
decl_stmt|;
name|queue
index|[
literal|0
index|]
operator|.
name|reloc
operator|=
name|queue
index|[
literal|1
index|]
operator|.
name|reloc
expr_stmt|;
name|queue
index|[
literal|0
index|]
operator|.
name|size
operator|=
name|queue
index|[
literal|1
index|]
operator|.
name|size
expr_stmt|;
name|queue
index|[
literal|1
index|]
operator|.
name|reloc
operator|=
name|tmp1
expr_stmt|;
name|queue
index|[
literal|1
index|]
operator|.
name|size
operator|=
name|tmp2
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|index
operator|==
literal|2
condition|)
block|{
name|unsigned
name|char
modifier|*
name|tmp1
init|=
name|queue
index|[
literal|0
index|]
operator|.
name|reloc
decl_stmt|;
name|unsigned
name|int
name|tmp2
init|=
name|queue
index|[
literal|0
index|]
operator|.
name|size
decl_stmt|;
name|queue
index|[
literal|0
index|]
operator|.
name|reloc
operator|=
name|queue
index|[
literal|2
index|]
operator|.
name|reloc
expr_stmt|;
name|queue
index|[
literal|0
index|]
operator|.
name|size
operator|=
name|queue
index|[
literal|2
index|]
operator|.
name|size
expr_stmt|;
name|queue
index|[
literal|2
index|]
operator|.
name|reloc
operator|=
name|queue
index|[
literal|1
index|]
operator|.
name|reloc
expr_stmt|;
name|queue
index|[
literal|2
index|]
operator|.
name|size
operator|=
name|queue
index|[
literal|1
index|]
operator|.
name|size
expr_stmt|;
name|queue
index|[
literal|1
index|]
operator|.
name|reloc
operator|=
name|tmp1
expr_stmt|;
name|queue
index|[
literal|1
index|]
operator|.
name|size
operator|=
name|tmp2
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|index
operator|==
literal|3
condition|)
block|{
name|unsigned
name|char
modifier|*
name|tmp1
init|=
name|queue
index|[
literal|0
index|]
operator|.
name|reloc
decl_stmt|;
name|unsigned
name|int
name|tmp2
init|=
name|queue
index|[
literal|0
index|]
operator|.
name|size
decl_stmt|;
name|queue
index|[
literal|0
index|]
operator|.
name|reloc
operator|=
name|queue
index|[
literal|3
index|]
operator|.
name|reloc
expr_stmt|;
name|queue
index|[
literal|0
index|]
operator|.
name|size
operator|=
name|queue
index|[
literal|3
index|]
operator|.
name|size
expr_stmt|;
name|queue
index|[
literal|3
index|]
operator|.
name|reloc
operator|=
name|queue
index|[
literal|2
index|]
operator|.
name|reloc
expr_stmt|;
name|queue
index|[
literal|3
index|]
operator|.
name|size
operator|=
name|queue
index|[
literal|2
index|]
operator|.
name|size
expr_stmt|;
name|queue
index|[
literal|2
index|]
operator|.
name|reloc
operator|=
name|queue
index|[
literal|1
index|]
operator|.
name|reloc
expr_stmt|;
name|queue
index|[
literal|2
index|]
operator|.
name|size
operator|=
name|queue
index|[
literal|1
index|]
operator|.
name|size
expr_stmt|;
name|queue
index|[
literal|1
index|]
operator|.
name|reloc
operator|=
name|tmp1
expr_stmt|;
name|queue
index|[
literal|1
index|]
operator|.
name|size
operator|=
name|tmp2
expr_stmt|;
return|return;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Search for a particular relocation in the relocation queue.  */
end_comment

begin_function
specifier|static
name|int
name|som_reloc_queue_find
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|struct
name|reloc_queue
modifier|*
name|queue
parameter_list|)
block|{
if|if
condition|(
name|queue
index|[
literal|0
index|]
operator|.
name|reloc
operator|&&
operator|!
name|memcmp
argument_list|(
name|p
argument_list|,
name|queue
index|[
literal|0
index|]
operator|.
name|reloc
argument_list|,
name|size
argument_list|)
operator|&&
name|size
operator|==
name|queue
index|[
literal|0
index|]
operator|.
name|size
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|queue
index|[
literal|1
index|]
operator|.
name|reloc
operator|&&
operator|!
name|memcmp
argument_list|(
name|p
argument_list|,
name|queue
index|[
literal|1
index|]
operator|.
name|reloc
argument_list|,
name|size
argument_list|)
operator|&&
name|size
operator|==
name|queue
index|[
literal|1
index|]
operator|.
name|size
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|queue
index|[
literal|2
index|]
operator|.
name|reloc
operator|&&
operator|!
name|memcmp
argument_list|(
name|p
argument_list|,
name|queue
index|[
literal|2
index|]
operator|.
name|reloc
argument_list|,
name|size
argument_list|)
operator|&&
name|size
operator|==
name|queue
index|[
literal|2
index|]
operator|.
name|size
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|queue
index|[
literal|3
index|]
operator|.
name|reloc
operator|&&
operator|!
name|memcmp
argument_list|(
name|p
argument_list|,
name|queue
index|[
literal|3
index|]
operator|.
name|reloc
argument_list|,
name|size
argument_list|)
operator|&&
name|size
operator|==
name|queue
index|[
literal|3
index|]
operator|.
name|size
condition|)
return|return
literal|3
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|try_prev_fixup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
modifier|*
name|subspace_reloc_sizep
parameter_list|,
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|struct
name|reloc_queue
modifier|*
name|queue
parameter_list|)
block|{
name|int
name|queue_index
init|=
name|som_reloc_queue_find
argument_list|(
name|p
argument_list|,
name|size
argument_list|,
name|queue
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue_index
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Found this in a previous fixup.  Undo the fixup we 	 just built and use R_PREV_FIXUP instead.  We saved 	 a total of size - 1 bytes in the fixup stream.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|R_PREV_FIXUP
operator|+
name|queue_index
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
operator|*
name|subspace_reloc_sizep
operator|+=
literal|1
expr_stmt|;
name|som_reloc_queue_fix
argument_list|(
name|queue
argument_list|,
name|queue_index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|som_reloc_queue_insert
argument_list|(
name|p
argument_list|,
name|size
argument_list|,
name|queue
argument_list|)
expr_stmt|;
operator|*
name|subspace_reloc_sizep
operator|+=
name|size
expr_stmt|;
name|p
operator|+=
name|size
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Emit the proper R_NO_RELOCATION fixups to map the next SKIP    bytes without any relocation.  Update the size of the subspace    relocation stream via SUBSPACE_RELOC_SIZE_P; also return the    current pointer into the relocation stream.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|som_reloc_skip
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|int
name|skip
parameter_list|,
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|unsigned
name|int
modifier|*
name|subspace_reloc_sizep
parameter_list|,
name|struct
name|reloc_queue
modifier|*
name|queue
parameter_list|)
block|{
comment|/* Use a 4 byte R_NO_RELOCATION entry with a maximal value      then R_PREV_FIXUPs to get the difference down to a      reasonable size.  */
if|if
condition|(
name|skip
operator|>=
literal|0x1000000
condition|)
block|{
name|skip
operator|-=
literal|0x1000000
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|R_NO_RELOCATION
operator|+
literal|31
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xff
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0xffff
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
name|subspace_reloc_sizep
argument_list|,
name|p
argument_list|,
literal|4
argument_list|,
name|queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|skip
operator|>=
literal|0x1000000
condition|)
block|{
name|skip
operator|-=
literal|0x1000000
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|R_PREV_FIXUP
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
operator|*
name|subspace_reloc_sizep
operator|+=
literal|1
expr_stmt|;
comment|/* No need to adjust queue here since we are repeating the 	     most recent fixup.  */
block|}
block|}
comment|/* The difference must be less than 0x1000000.  Use one      more R_NO_RELOCATION entry to get to the right difference.  */
if|if
condition|(
operator|(
name|skip
operator|&
literal|3
operator|)
operator|==
literal|0
operator|&&
name|skip
operator|<=
literal|0xc0000
operator|&&
name|skip
operator|>
literal|0
condition|)
block|{
comment|/* Difference can be handled in a simple single-byte 	 R_NO_RELOCATION entry.  */
if|if
condition|(
name|skip
operator|<=
literal|0x60
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|R_NO_RELOCATION
operator|+
operator|(
name|skip
operator|>>
literal|2
operator|)
operator|-
literal|1
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
name|subspace_reloc_sizep
operator|+=
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
comment|/* Handle it with a two byte R_NO_RELOCATION entry.  */
elseif|else
if|if
condition|(
name|skip
operator|<=
literal|0x1000
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|R_NO_RELOCATION
operator|+
literal|24
operator|+
operator|(
operator|(
operator|(
name|skip
operator|>>
literal|2
operator|)
operator|-
literal|1
operator|)
operator|>>
literal|8
operator|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|skip
operator|>>
literal|2
operator|)
operator|-
literal|1
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
name|subspace_reloc_sizep
argument_list|,
name|p
argument_list|,
literal|2
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
comment|/* Handle it with a three byte R_NO_RELOCATION entry.  */
else|else
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|R_NO_RELOCATION
operator|+
literal|28
operator|+
operator|(
operator|(
operator|(
name|skip
operator|>>
literal|2
operator|)
operator|-
literal|1
operator|)
operator|>>
literal|16
operator|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
call|(
name|bfd_vma
call|)
argument_list|(
name|skip
operator|>>
literal|2
argument_list|)
operator|-
literal|1
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
name|subspace_reloc_sizep
argument_list|,
name|p
argument_list|,
literal|3
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Ugh.  Punt and use a 4 byte entry.  */
elseif|else
if|if
condition|(
name|skip
operator|>
literal|0
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|R_NO_RELOCATION
operator|+
literal|31
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|skip
operator|-
literal|1
operator|)
operator|>>
literal|16
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|skip
operator|-
literal|1
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
name|subspace_reloc_sizep
argument_list|,
name|p
argument_list|,
literal|4
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Emit the proper R_DATA_OVERRIDE fixups to handle a nonzero addend    from a BFD relocation.  Update the size of the subspace relocation    stream via SUBSPACE_RELOC_SIZE_P; also return the current pointer    into the relocation stream.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|som_reloc_addend
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_vma
name|addend
parameter_list|,
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|unsigned
name|int
modifier|*
name|subspace_reloc_sizep
parameter_list|,
name|struct
name|reloc_queue
modifier|*
name|queue
parameter_list|)
block|{
if|if
condition|(
name|addend
operator|+
literal|0x80
operator|<
literal|0x100
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|R_DATA_OVERRIDE
operator|+
literal|1
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|addend
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
name|subspace_reloc_sizep
argument_list|,
name|p
argument_list|,
literal|2
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|addend
operator|+
literal|0x8000
operator|<
literal|0x10000
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|R_DATA_OVERRIDE
operator|+
literal|2
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|addend
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
name|subspace_reloc_sizep
argument_list|,
name|p
argument_list|,
literal|3
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|addend
operator|+
literal|0x800000
operator|<
literal|0x1000000
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|R_DATA_OVERRIDE
operator|+
literal|3
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|addend
operator|>>
literal|16
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|addend
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
name|subspace_reloc_sizep
argument_list|,
name|p
argument_list|,
literal|4
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|R_DATA_OVERRIDE
operator|+
literal|4
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|addend
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
name|subspace_reloc_sizep
argument_list|,
name|p
argument_list|,
literal|5
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Handle a single function call relocation.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|som_reloc_call
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|unsigned
name|int
modifier|*
name|subspace_reloc_sizep
parameter_list|,
name|arelent
modifier|*
name|bfd_reloc
parameter_list|,
name|int
name|sym_num
parameter_list|,
name|struct
name|reloc_queue
modifier|*
name|queue
parameter_list|)
block|{
name|int
name|arg_bits
init|=
name|HPPA_R_ARG_RELOC
argument_list|(
name|bfd_reloc
operator|->
name|addend
argument_list|)
decl_stmt|;
name|int
name|rtn_bits
init|=
name|arg_bits
operator|&
literal|0x3
decl_stmt|;
name|int
name|type
decl_stmt|,
name|done
init|=
literal|0
decl_stmt|;
comment|/* You'll never believe all this is necessary to handle relocations      for function calls.  Having to compute and pack the argument      relocation bits is the real nightmare.       If you're interested in how this works, just forget it.  You really      do not want to know about this braindamage.  */
comment|/* First see if this can be done with a "simple" relocation.  Simple      relocations have a symbol number< 0x100 and have simple encodings      of argument relocations.  */
if|if
condition|(
name|sym_num
operator|<
literal|0x100
condition|)
block|{
switch|switch
condition|(
name|arg_bits
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|type
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
operator|<<
literal|8
case|:
case|case
literal|1
operator|<<
literal|8
operator||
literal|1
case|:
name|type
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
operator|<<
literal|8
operator||
literal|1
operator|<<
literal|6
case|:
case|case
literal|1
operator|<<
literal|8
operator||
literal|1
operator|<<
literal|6
operator||
literal|1
case|:
name|type
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|1
operator|<<
literal|8
operator||
literal|1
operator|<<
literal|6
operator||
literal|1
operator|<<
literal|4
case|:
case|case
literal|1
operator|<<
literal|8
operator||
literal|1
operator|<<
literal|6
operator||
literal|1
operator|<<
literal|4
operator||
literal|1
case|:
name|type
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|1
operator|<<
literal|8
operator||
literal|1
operator|<<
literal|6
operator||
literal|1
operator|<<
literal|4
operator||
literal|1
operator|<<
literal|2
case|:
case|case
literal|1
operator|<<
literal|8
operator||
literal|1
operator|<<
literal|6
operator||
literal|1
operator|<<
literal|4
operator||
literal|1
operator|<<
literal|2
operator||
literal|1
case|:
name|type
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
comment|/* Not one of the easy encodings.  This will have to be 	     handled by the more complex code below.  */
name|type
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|type
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Account for the return value too.  */
if|if
condition|(
name|rtn_bits
condition|)
name|type
operator|+=
literal|5
expr_stmt|;
comment|/* Emit a 2 byte relocation.  Then see if it can be handled 	     with a relocation which is already in the relocation queue.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
operator|+
name|type
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|sym_num
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
name|subspace_reloc_sizep
argument_list|,
name|p
argument_list|,
literal|2
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If this could not be handled with a simple relocation, then do a hard      one.  Hard relocations occur if the symbol number was too high or if      the encoding of argument relocation bits is too complex.  */
if|if
condition|(
operator|!
name|done
condition|)
block|{
comment|/* Don't ask about these magic sequences.  I took them straight 	 from gas-1.36 which took them from the a.out man page.  */
name|type
operator|=
name|rtn_bits
expr_stmt|;
if|if
condition|(
operator|(
name|arg_bits
operator|>>
literal|6
operator|&
literal|0xf
operator|)
operator|==
literal|0xe
condition|)
name|type
operator|+=
literal|9
operator|*
literal|40
expr_stmt|;
else|else
name|type
operator|+=
operator|(
literal|3
operator|*
operator|(
name|arg_bits
operator|>>
literal|8
operator|&
literal|3
operator|)
operator|+
operator|(
name|arg_bits
operator|>>
literal|6
operator|&
literal|3
operator|)
operator|)
operator|*
literal|40
expr_stmt|;
if|if
condition|(
operator|(
name|arg_bits
operator|>>
literal|2
operator|&
literal|0xf
operator|)
operator|==
literal|0xe
condition|)
name|type
operator|+=
literal|9
operator|*
literal|4
expr_stmt|;
else|else
name|type
operator|+=
operator|(
literal|3
operator|*
operator|(
name|arg_bits
operator|>>
literal|4
operator|&
literal|3
operator|)
operator|+
operator|(
name|arg_bits
operator|>>
literal|2
operator|&
literal|3
operator|)
operator|)
operator|*
literal|4
expr_stmt|;
comment|/* Output the first two bytes of the relocation.  These describe 	 the length of the relocation and encoding style.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
operator|+
literal|10
operator|+
literal|2
operator|*
operator|(
name|sym_num
operator|>=
literal|0x100
operator|)
operator|+
operator|(
name|type
operator|>=
literal|0x100
operator|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|type
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Now output the symbol index and see if this bizarre relocation 	 just happened to be in the relocation queue.  */
if|if
condition|(
name|sym_num
operator|<
literal|0x100
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|sym_num
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
name|subspace_reloc_sizep
argument_list|,
name|p
argument_list|,
literal|3
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|sym_num
operator|>>
literal|16
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|sym_num
argument_list|,
name|p
operator|+
literal|3
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
name|subspace_reloc_sizep
argument_list|,
name|p
argument_list|,
literal|5
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Return the logarithm of X, base 2, considering X unsigned,    if X is a power of 2.  Otherwise, returns -1.  */
end_comment

begin_function
specifier|static
name|int
name|exact_log2
parameter_list|(
name|unsigned
name|int
name|x
parameter_list|)
block|{
name|int
name|log
init|=
literal|0
decl_stmt|;
comment|/* Test for 0 or a power of 2.  */
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|x
operator|!=
operator|(
name|x
operator|&
operator|-
name|x
operator|)
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
operator|(
name|x
operator|>>=
literal|1
operator|)
operator|!=
literal|0
condition|)
name|log
operator|++
expr_stmt|;
return|return
name|log
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|hppa_som_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol_in
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|output_bfd
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Given a generic HPPA relocation type, the instruction format,    and a field selector, return one or more appropriate SOM relocations.  */
end_comment

begin_function
name|int
modifier|*
modifier|*
name|hppa_som_gen_reloc_type
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|base_type
parameter_list|,
name|int
name|format
parameter_list|,
name|enum
name|hppa_reloc_field_selector_type_alt
name|field
parameter_list|,
name|int
name|sym_diff
parameter_list|,
name|asymbol
modifier|*
name|sym
parameter_list|)
block|{
name|int
modifier|*
name|final_type
decl_stmt|,
modifier|*
modifier|*
name|final_types
decl_stmt|;
name|final_types
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
operator|*
literal|6
argument_list|)
expr_stmt|;
name|final_type
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|final_types
operator|||
operator|!
name|final_type
condition|)
return|return
name|NULL
return|;
comment|/* The field selector may require additional relocations to be      generated.  It's impossible to know at this moment if additional      relocations will be needed, so we make them.  The code to actually      write the relocation/fixup stream is responsible for removing      any redundant relocations.  */
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|e_fsel
case|:
case|case
name|e_psel
case|:
case|case
name|e_lpsel
case|:
case|case
name|e_rpsel
case|:
name|final_types
index|[
literal|0
index|]
operator|=
name|final_type
expr_stmt|;
name|final_types
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|final_types
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|final_type
operator|=
name|base_type
expr_stmt|;
break|break;
case|case
name|e_tsel
case|:
case|case
name|e_ltsel
case|:
case|case
name|e_rtsel
case|:
name|final_types
index|[
literal|0
index|]
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|final_types
index|[
literal|0
index|]
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|field
operator|==
name|e_tsel
condition|)
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_FSEL
expr_stmt|;
elseif|else
if|if
condition|(
name|field
operator|==
name|e_ltsel
condition|)
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_LSEL
expr_stmt|;
else|else
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_RSEL
expr_stmt|;
name|final_types
index|[
literal|1
index|]
operator|=
name|final_type
expr_stmt|;
name|final_types
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|final_type
operator|=
name|base_type
expr_stmt|;
break|break;
case|case
name|e_lssel
case|:
case|case
name|e_rssel
case|:
name|final_types
index|[
literal|0
index|]
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|final_types
index|[
literal|0
index|]
condition|)
return|return
name|NULL
return|;
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_S_MODE
expr_stmt|;
name|final_types
index|[
literal|1
index|]
operator|=
name|final_type
expr_stmt|;
name|final_types
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|final_type
operator|=
name|base_type
expr_stmt|;
break|break;
case|case
name|e_lsel
case|:
case|case
name|e_rsel
case|:
name|final_types
index|[
literal|0
index|]
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|final_types
index|[
literal|0
index|]
condition|)
return|return
name|NULL
return|;
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_N_MODE
expr_stmt|;
name|final_types
index|[
literal|1
index|]
operator|=
name|final_type
expr_stmt|;
name|final_types
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|final_type
operator|=
name|base_type
expr_stmt|;
break|break;
case|case
name|e_ldsel
case|:
case|case
name|e_rdsel
case|:
name|final_types
index|[
literal|0
index|]
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|final_types
index|[
literal|0
index|]
condition|)
return|return
name|NULL
return|;
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_D_MODE
expr_stmt|;
name|final_types
index|[
literal|1
index|]
operator|=
name|final_type
expr_stmt|;
name|final_types
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|final_type
operator|=
name|base_type
expr_stmt|;
break|break;
case|case
name|e_lrsel
case|:
case|case
name|e_rrsel
case|:
name|final_types
index|[
literal|0
index|]
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|final_types
index|[
literal|0
index|]
condition|)
return|return
name|NULL
return|;
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_R_MODE
expr_stmt|;
name|final_types
index|[
literal|1
index|]
operator|=
name|final_type
expr_stmt|;
name|final_types
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|final_type
operator|=
name|base_type
expr_stmt|;
break|break;
case|case
name|e_nsel
case|:
name|final_types
index|[
literal|0
index|]
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|final_types
index|[
literal|0
index|]
condition|)
return|return
name|NULL
return|;
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_N1SEL
expr_stmt|;
name|final_types
index|[
literal|1
index|]
operator|=
name|final_type
expr_stmt|;
name|final_types
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|final_type
operator|=
name|base_type
expr_stmt|;
break|break;
case|case
name|e_nlsel
case|:
case|case
name|e_nlrsel
case|:
name|final_types
index|[
literal|0
index|]
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|final_types
index|[
literal|0
index|]
condition|)
return|return
name|NULL
return|;
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_N0SEL
expr_stmt|;
name|final_types
index|[
literal|1
index|]
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|final_types
index|[
literal|1
index|]
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|field
operator|==
name|e_nlsel
condition|)
operator|*
name|final_types
index|[
literal|1
index|]
operator|=
name|R_N_MODE
expr_stmt|;
else|else
operator|*
name|final_types
index|[
literal|1
index|]
operator|=
name|R_R_MODE
expr_stmt|;
name|final_types
index|[
literal|2
index|]
operator|=
name|final_type
expr_stmt|;
name|final_types
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|final_type
operator|=
name|base_type
expr_stmt|;
break|break;
comment|/* FIXME: These two field selectors are not currently supported.  */
case|case
name|e_ltpsel
case|:
case|case
name|e_rtpsel
case|:
name|abort
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|R_HPPA
case|:
comment|/* The difference of two symbols needs *very* special handling.  */
if|if
condition|(
name|sym_diff
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
name|final_types
index|[
literal|0
index|]
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|final_types
index|[
literal|1
index|]
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|final_types
index|[
literal|2
index|]
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|final_types
index|[
literal|3
index|]
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|final_types
index|[
literal|0
index|]
operator|||
operator|!
name|final_types
index|[
literal|1
index|]
operator|||
operator|!
name|final_types
index|[
literal|2
index|]
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|field
operator|==
name|e_fsel
condition|)
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_FSEL
expr_stmt|;
elseif|else
if|if
condition|(
name|field
operator|==
name|e_rsel
condition|)
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_RSEL
expr_stmt|;
elseif|else
if|if
condition|(
name|field
operator|==
name|e_lsel
condition|)
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_LSEL
expr_stmt|;
operator|*
name|final_types
index|[
literal|1
index|]
operator|=
name|R_COMP2
expr_stmt|;
operator|*
name|final_types
index|[
literal|2
index|]
operator|=
name|R_COMP2
expr_stmt|;
operator|*
name|final_types
index|[
literal|3
index|]
operator|=
name|R_COMP1
expr_stmt|;
name|final_types
index|[
literal|4
index|]
operator|=
name|final_type
expr_stmt|;
if|if
condition|(
name|format
operator|==
literal|32
condition|)
operator|*
name|final_types
index|[
literal|4
index|]
operator|=
name|R_DATA_EXPR
expr_stmt|;
else|else
operator|*
name|final_types
index|[
literal|4
index|]
operator|=
name|R_CODE_EXPR
expr_stmt|;
name|final_types
index|[
literal|5
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* PLABELs get their own relocation type.  */
elseif|else
if|if
condition|(
name|field
operator|==
name|e_psel
operator|||
name|field
operator|==
name|e_lpsel
operator|||
name|field
operator|==
name|e_rpsel
condition|)
block|{
comment|/* A PLABEL relocation that has a size of 32 bits must 	     be a R_DATA_PLABEL.  All others are R_CODE_PLABELs.  */
if|if
condition|(
name|format
operator|==
literal|32
condition|)
operator|*
name|final_type
operator|=
name|R_DATA_PLABEL
expr_stmt|;
else|else
operator|*
name|final_type
operator|=
name|R_CODE_PLABEL
expr_stmt|;
block|}
comment|/* PIC stuff.  */
elseif|else
if|if
condition|(
name|field
operator|==
name|e_tsel
operator|||
name|field
operator|==
name|e_ltsel
operator|||
name|field
operator|==
name|e_rtsel
condition|)
operator|*
name|final_type
operator|=
name|R_DLT_REL
expr_stmt|;
comment|/* A relocation in the data space is always a full 32bits.  */
elseif|else
if|if
condition|(
name|format
operator|==
literal|32
condition|)
block|{
operator|*
name|final_type
operator|=
name|R_DATA_ONE_SYMBOL
expr_stmt|;
comment|/* If there's no SOM symbol type associated with this BFD 	     symbol, then set the symbol type to ST_DATA.  	     Only do this if the type is going to default later when 	     we write the object file.  	     This is done so that the linker never encounters an 	     R_DATA_ONE_SYMBOL reloc involving an ST_CODE symbol.  	     This allows the compiler to generate exception handling 	     tables.  	     Note that one day we may need to also emit BEGIN_BRTAB and 	     END_BRTAB to prevent the linker from optimizing away insns 	     in exception handling regions.  */
if|if
condition|(
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_UNKNOWN
operator|&&
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_FUNCTION
operator|)
operator|==
literal|0
operator|&&
operator|!
name|bfd_is_com_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
condition|)
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|=
name|SYMBOL_TYPE_DATA
expr_stmt|;
block|}
break|break;
case|case
name|R_HPPA_GOTOFF
case|:
comment|/* More PLABEL special cases.  */
if|if
condition|(
name|field
operator|==
name|e_psel
operator|||
name|field
operator|==
name|e_lpsel
operator|||
name|field
operator|==
name|e_rpsel
condition|)
operator|*
name|final_type
operator|=
name|R_DATA_PLABEL
expr_stmt|;
break|break;
case|case
name|R_HPPA_COMPLEX
case|:
comment|/* The difference of two symbols needs *very* special handling.  */
if|if
condition|(
name|sym_diff
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
name|final_types
index|[
literal|0
index|]
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|final_types
index|[
literal|1
index|]
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|final_types
index|[
literal|2
index|]
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|final_types
index|[
literal|3
index|]
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|final_types
index|[
literal|0
index|]
operator|||
operator|!
name|final_types
index|[
literal|1
index|]
operator|||
operator|!
name|final_types
index|[
literal|2
index|]
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|field
operator|==
name|e_fsel
condition|)
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_FSEL
expr_stmt|;
elseif|else
if|if
condition|(
name|field
operator|==
name|e_rsel
condition|)
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_RSEL
expr_stmt|;
elseif|else
if|if
condition|(
name|field
operator|==
name|e_lsel
condition|)
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_LSEL
expr_stmt|;
operator|*
name|final_types
index|[
literal|1
index|]
operator|=
name|R_COMP2
expr_stmt|;
operator|*
name|final_types
index|[
literal|2
index|]
operator|=
name|R_COMP2
expr_stmt|;
operator|*
name|final_types
index|[
literal|3
index|]
operator|=
name|R_COMP1
expr_stmt|;
name|final_types
index|[
literal|4
index|]
operator|=
name|final_type
expr_stmt|;
if|if
condition|(
name|format
operator|==
literal|32
condition|)
operator|*
name|final_types
index|[
literal|4
index|]
operator|=
name|R_DATA_EXPR
expr_stmt|;
else|else
operator|*
name|final_types
index|[
literal|4
index|]
operator|=
name|R_CODE_EXPR
expr_stmt|;
name|final_types
index|[
literal|5
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
else|else
break|break;
case|case
name|R_HPPA_NONE
case|:
case|case
name|R_HPPA_ABS_CALL
case|:
comment|/* Right now we can default all these.  */
break|break;
case|case
name|R_HPPA_PCREL_CALL
case|:
block|{
ifndef|#
directive|ifndef
name|NO_PCREL_MODES
comment|/* If we have short and long pcrel modes, then generate the proper 	   mode selector, then the pcrel relocation.  Redundant selectors 	   will be eliminated as the relocs are sized and emitted.  */
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
name|final_types
index|[
literal|0
index|]
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|final_types
index|[
literal|0
index|]
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|format
operator|==
literal|17
condition|)
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_SHORT_PCREL_MODE
expr_stmt|;
else|else
operator|*
name|final_types
index|[
literal|0
index|]
operator|=
name|R_LONG_PCREL_MODE
expr_stmt|;
name|final_types
index|[
literal|1
index|]
operator|=
name|final_type
expr_stmt|;
name|final_types
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|final_type
operator|=
name|base_type
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
return|return
name|final_types
return|;
block|}
end_function

begin_comment
comment|/* Return the address of the correct entry in the PA SOM relocation    howto table.  */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|som_bfd_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|code
operator|<
operator|(
name|int
operator|)
name|R_NO_RELOCATION
operator|+
literal|255
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|(
name|int
operator|)
name|som_hppa_howto_table
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|type
operator|==
operator|(
name|int
operator|)
name|code
argument_list|)
expr_stmt|;
return|return
operator|&
name|som_hppa_howto_table
index|[
operator|(
name|int
operator|)
name|code
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|som_bfd_reloc_name_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|r_name
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|som_hppa_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|som_hppa_howto_table
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|som_hppa_howto_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcasecmp
argument_list|(
name|som_hppa_howto_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|som_hppa_howto_table
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Perform some initialization for an object.  Save results of this    initialization in the BFD.  */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|som_object_setup
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|header
modifier|*
name|file_hdrp
parameter_list|,
name|struct
name|som_exec_auxhdr
modifier|*
name|aux_hdrp
parameter_list|,
name|unsigned
name|long
name|current_offset
parameter_list|)
block|{
name|asection
modifier|*
name|section
decl_stmt|;
comment|/* som_mkobject will set bfd_error if som_mkobject fails.  */
if|if
condition|(
operator|!
name|som_mkobject
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Set BFD flags based on what information is available in the SOM.  */
name|abfd
operator|->
name|flags
operator|=
name|BFD_NO_FLAGS
expr_stmt|;
if|if
condition|(
name|file_hdrp
operator|->
name|symbol_total
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
expr_stmt|;
switch|switch
condition|(
name|file_hdrp
operator|->
name|a_magic
condition|)
block|{
case|case
name|DEMAND_MAGIC
case|:
name|abfd
operator|->
name|flags
operator||=
operator|(
name|D_PAGED
operator||
name|WP_TEXT
operator||
name|EXEC_P
operator|)
expr_stmt|;
break|break;
case|case
name|SHARE_MAGIC
case|:
name|abfd
operator|->
name|flags
operator||=
operator|(
name|WP_TEXT
operator||
name|EXEC_P
operator|)
expr_stmt|;
break|break;
case|case
name|EXEC_MAGIC
case|:
name|abfd
operator|->
name|flags
operator||=
operator|(
name|EXEC_P
operator|)
expr_stmt|;
break|break;
case|case
name|RELOC_MAGIC
case|:
name|abfd
operator|->
name|flags
operator||=
name|HAS_RELOC
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|SHL_MAGIC
case|case
name|SHL_MAGIC
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DL_MAGIC
case|case
name|DL_MAGIC
case|:
endif|#
directive|endif
name|abfd
operator|->
name|flags
operator||=
name|DYNAMIC
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Save the auxiliary header.  */
name|obj_som_exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|=
name|aux_hdrp
expr_stmt|;
comment|/* Allocate space to hold the saved exec header information.  */
name|obj_som_exec_data
argument_list|(
name|abfd
argument_list|)
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|som_exec_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj_som_exec_data
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* The braindamaged OSF1 linker switched exec_flags and exec_entry!       We used to identify OSF1 binaries based on NEW_VERSION_ID, but      apparently the latest HPUX linker is using NEW_VERSION_ID now.       It's about time, OSF has used the new id since at least 1992;      HPUX didn't start till nearly 1995!.       The new approach examines the entry field for an executable.  If      it is not 4-byte aligned then it's not a proper code address and      we guess it's really the executable flags.  For a main program,      we also consider zero to be indicative of a buggy linker, since      that is not a valid entry point.  The entry point for a shared      library, however, can be zero so we do not consider that to be      indicative of a buggy linker.  */
if|if
condition|(
name|aux_hdrp
condition|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|section
operator|=
name|abfd
operator|->
name|sections
init|;
name|section
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
name|bfd_vma
name|entry
decl_stmt|;
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|entry
operator|=
name|aux_hdrp
operator|->
name|exec_entry
operator|+
name|aux_hdrp
operator|->
name|exec_tmem
expr_stmt|;
if|if
condition|(
name|entry
operator|>=
name|section
operator|->
name|vma
operator|&&
name|entry
operator|<
name|section
operator|->
name|vma
operator|+
name|section
operator|->
name|size
condition|)
name|found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|aux_hdrp
operator|->
name|exec_entry
operator|==
literal|0
operator|&&
operator|!
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|)
operator|||
operator|(
name|aux_hdrp
operator|->
name|exec_entry
operator|&
literal|0x3
operator|)
operator|!=
literal|0
operator|||
operator|!
name|found
condition|)
block|{
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
operator|=
name|aux_hdrp
operator|->
name|exec_flags
expr_stmt|;
name|obj_som_exec_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|exec_flags
operator|=
name|aux_hdrp
operator|->
name|exec_entry
expr_stmt|;
block|}
else|else
block|{
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
operator|=
name|aux_hdrp
operator|->
name|exec_entry
operator|+
name|current_offset
expr_stmt|;
name|obj_som_exec_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|exec_flags
operator|=
name|aux_hdrp
operator|->
name|exec_flags
expr_stmt|;
block|}
block|}
name|obj_som_exec_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|version_id
operator|=
name|file_hdrp
operator|->
name|version_id
expr_stmt|;
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_hppa
argument_list|,
name|pa10
argument_list|)
expr_stmt|;
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|file_hdrp
operator|->
name|symbol_total
expr_stmt|;
comment|/* Initialize the saved symbol table and string table to NULL.      Save important offsets and sizes from the SOM header into      the BFD.  */
name|obj_som_stringtab
argument_list|(
name|abfd
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|obj_som_symtab
argument_list|(
name|abfd
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|obj_som_sorted_syms
argument_list|(
name|abfd
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|obj_som_stringtab_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|file_hdrp
operator|->
name|symbol_strings_size
expr_stmt|;
name|obj_som_sym_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
name|file_hdrp
operator|->
name|symbol_location
operator|+
name|current_offset
expr_stmt|;
name|obj_som_str_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|file_hdrp
operator|->
name|symbol_strings_location
operator|+
name|current_offset
operator|)
expr_stmt|;
name|obj_som_reloc_filepos
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
name|file_hdrp
operator|->
name|fixup_request_location
operator|+
name|current_offset
operator|)
expr_stmt|;
name|obj_som_exec_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|system_id
operator|=
name|file_hdrp
operator|->
name|system_id
expr_stmt|;
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_comment
comment|/* Convert all of the space and subspace info into BFD sections.  Each space    contains a number of subspaces, which in turn describe the mapping between    regions of the exec file, and the address space that the program runs in.    BFD sections which correspond to spaces will overlap the sections for the    associated subspaces.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|setup_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|header
modifier|*
name|file_hdr
parameter_list|,
name|unsigned
name|long
name|current_offset
parameter_list|)
block|{
name|char
modifier|*
name|space_strings
decl_stmt|;
name|unsigned
name|int
name|space_index
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|int
name|total_subspaces
init|=
literal|0
decl_stmt|;
name|asection
modifier|*
modifier|*
name|subspace_sections
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* First, read in space names.  */
name|amt
operator|=
name|file_hdr
operator|->
name|space_strings_size
expr_stmt|;
name|space_strings
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|space_strings
operator|&&
name|amt
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|current_offset
operator|+
name|file_hdr
operator|->
name|space_strings_location
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_bread
argument_list|(
name|space_strings
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
comment|/* Loop over all of the space dictionaries, building up sections.  */
for|for
control|(
name|space_index
operator|=
literal|0
init|;
name|space_index
operator|<
name|file_hdr
operator|->
name|space_total
condition|;
name|space_index
operator|++
control|)
block|{
name|struct
name|space_dictionary_record
name|space
decl_stmt|;
name|struct
name|som_subspace_dictionary_record
name|subspace
decl_stmt|,
name|save_subspace
decl_stmt|;
name|unsigned
name|int
name|subspace_index
decl_stmt|;
name|asection
modifier|*
name|space_asect
decl_stmt|;
name|bfd_size_type
name|space_size
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|newname
decl_stmt|;
comment|/* Read the space dictionary element.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|current_offset
operator|+
name|file_hdr
operator|->
name|space_location
operator|+
name|space_index
operator|*
sizeof|sizeof
name|space
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|amt
operator|=
sizeof|sizeof
name|space
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|&
name|space
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
comment|/* Setup the space name string.  */
name|space
operator|.
name|name
operator|.
name|n_name
operator|=
name|space
operator|.
name|name
operator|.
name|n_strx
operator|+
name|space_strings
expr_stmt|;
comment|/* Make a section out of it.  */
name|amt
operator|=
name|strlen
argument_list|(
name|space
operator|.
name|name
operator|.
name|n_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|newname
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newname
condition|)
goto|goto
name|error_return
goto|;
name|strcpy
argument_list|(
name|newname
argument_list|,
name|space
operator|.
name|name
operator|.
name|n_name
argument_list|)
expr_stmt|;
name|space_asect
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|newname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|space_asect
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|space
operator|.
name|is_loadable
operator|==
literal|0
condition|)
name|space_asect
operator|->
name|flags
operator||=
name|SEC_DEBUGGING
expr_stmt|;
comment|/* Set up all the attributes for the space.  */
if|if
condition|(
operator|!
name|bfd_som_set_section_attributes
argument_list|(
name|space_asect
argument_list|,
name|space
operator|.
name|is_defined
argument_list|,
name|space
operator|.
name|is_private
argument_list|,
name|space
operator|.
name|sort_key
argument_list|,
name|space
operator|.
name|space_number
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* If the space has no subspaces, then we're done.  */
if|if
condition|(
name|space
operator|.
name|subspace_quantity
operator|==
literal|0
condition|)
continue|continue;
comment|/* Now, read in the first subspace for this space.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|current_offset
operator|+
name|file_hdr
operator|->
name|subspace_location
operator|+
name|space
operator|.
name|subspace_index
operator|*
sizeof|sizeof
name|subspace
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|amt
operator|=
sizeof|sizeof
name|subspace
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|&
name|subspace
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
comment|/* Seek back to the start of the subspaces for loop below.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|current_offset
operator|+
name|file_hdr
operator|->
name|subspace_location
operator|+
name|space
operator|.
name|subspace_index
operator|*
sizeof|sizeof
name|subspace
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* Setup the start address and file loc from the first subspace 	 record.  */
name|space_asect
operator|->
name|vma
operator|=
name|subspace
operator|.
name|subspace_start
expr_stmt|;
name|space_asect
operator|->
name|filepos
operator|=
name|subspace
operator|.
name|file_loc_init_value
operator|+
name|current_offset
expr_stmt|;
name|space_asect
operator|->
name|alignment_power
operator|=
name|exact_log2
argument_list|(
name|subspace
operator|.
name|alignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|space_asect
operator|->
name|alignment_power
operator|==
operator|(
name|unsigned
operator|)
operator|-
literal|1
condition|)
goto|goto
name|error_return
goto|;
comment|/* Initialize save_subspace so we can reliably determine if this 	 loop placed any useful values into it.  */
name|memset
argument_list|(
operator|&
name|save_subspace
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|save_subspace
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Loop over the rest of the subspaces, building up more sections.  */
for|for
control|(
name|subspace_index
operator|=
literal|0
init|;
name|subspace_index
operator|<
name|space
operator|.
name|subspace_quantity
condition|;
name|subspace_index
operator|++
control|)
block|{
name|asection
modifier|*
name|subspace_asect
decl_stmt|;
comment|/* Read in the next subspace.  */
name|amt
operator|=
sizeof|sizeof
name|subspace
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|&
name|subspace
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
comment|/* Setup the subspace name string.  */
name|subspace
operator|.
name|name
operator|.
name|n_name
operator|=
name|subspace
operator|.
name|name
operator|.
name|n_strx
operator|+
name|space_strings
expr_stmt|;
name|amt
operator|=
name|strlen
argument_list|(
name|subspace
operator|.
name|name
operator|.
name|n_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|newname
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newname
condition|)
goto|goto
name|error_return
goto|;
name|strcpy
argument_list|(
name|newname
argument_list|,
name|subspace
operator|.
name|name
operator|.
name|n_name
argument_list|)
expr_stmt|;
comment|/* Make a section out of this subspace.  */
name|subspace_asect
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|newname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subspace_asect
condition|)
goto|goto
name|error_return
goto|;
comment|/* Store private information about the section.  */
if|if
condition|(
operator|!
name|bfd_som_set_subsection_attributes
argument_list|(
name|subspace_asect
argument_list|,
name|space_asect
argument_list|,
name|subspace
operator|.
name|access_control_bits
argument_list|,
name|subspace
operator|.
name|sort_key
argument_list|,
name|subspace
operator|.
name|quadrant
argument_list|,
name|subspace
operator|.
name|is_comdat
argument_list|,
name|subspace
operator|.
name|is_common
argument_list|,
name|subspace
operator|.
name|dup_common
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Keep an easy mapping between subspaces and sections. 	     Note we do not necessarily read the subspaces in the 	     same order in which they appear in the object file.  	     So to make the target index come out correctly, we 	     store the location of the subspace header in target 	     index, then sort using the location of the subspace 	     header as the key.  Then we can assign correct 	     subspace indices.  */
name|total_subspaces
operator|++
expr_stmt|;
name|subspace_asect
operator|->
name|target_index
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|subspace
argument_list|)
expr_stmt|;
comment|/* Set SEC_READONLY and SEC_CODE/SEC_DATA as specified 	     by the access_control_bits in the subspace header.  */
switch|switch
condition|(
name|subspace
operator|.
name|access_control_bits
operator|>>
literal|4
condition|)
block|{
comment|/* Readonly data.  */
case|case
literal|0x0
case|:
name|subspace_asect
operator|->
name|flags
operator||=
name|SEC_DATA
operator||
name|SEC_READONLY
expr_stmt|;
break|break;
comment|/* Normal data.  */
case|case
literal|0x1
case|:
name|subspace_asect
operator|->
name|flags
operator||=
name|SEC_DATA
expr_stmt|;
break|break;
comment|/* Readonly code and the gateways. 	       Gateways have other attributes which do not map 	       into anything BFD knows about.  */
case|case
literal|0x2
case|:
case|case
literal|0x4
case|:
case|case
literal|0x5
case|:
case|case
literal|0x6
case|:
case|case
literal|0x7
case|:
name|subspace_asect
operator|->
name|flags
operator||=
name|SEC_CODE
operator||
name|SEC_READONLY
expr_stmt|;
break|break;
comment|/* dynamic (writable) code.  */
case|case
literal|0x3
case|:
name|subspace_asect
operator|->
name|flags
operator||=
name|SEC_CODE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|subspace
operator|.
name|is_comdat
operator|||
name|subspace
operator|.
name|is_common
operator|||
name|subspace
operator|.
name|dup_common
condition|)
name|subspace_asect
operator|->
name|flags
operator||=
name|SEC_LINK_ONCE
expr_stmt|;
if|if
condition|(
name|subspace
operator|.
name|subspace_length
operator|>
literal|0
condition|)
name|subspace_asect
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
if|if
condition|(
name|subspace
operator|.
name|is_loadable
condition|)
name|subspace_asect
operator|->
name|flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
else|else
name|subspace_asect
operator|->
name|flags
operator||=
name|SEC_DEBUGGING
expr_stmt|;
if|if
condition|(
name|subspace
operator|.
name|code_only
condition|)
name|subspace_asect
operator|->
name|flags
operator||=
name|SEC_CODE
expr_stmt|;
comment|/* Both file_loc_init_value and initialization_length will 	     be zero for a BSS like subspace.  */
if|if
condition|(
name|subspace
operator|.
name|file_loc_init_value
operator|==
literal|0
operator|&&
name|subspace
operator|.
name|initialization_length
operator|==
literal|0
condition|)
name|subspace_asect
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SEC_DATA
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator|)
expr_stmt|;
comment|/* This subspace has relocations. 	     The fixup_request_quantity is a byte count for the number of 	     entries in the relocation stream; it is not the actual number 	     of relocations in the subspace.  */
if|if
condition|(
name|subspace
operator|.
name|fixup_request_quantity
operator|!=
literal|0
condition|)
block|{
name|subspace_asect
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
name|subspace_asect
operator|->
name|rel_filepos
operator|=
name|subspace
operator|.
name|fixup_request_index
expr_stmt|;
name|som_section_data
argument_list|(
name|subspace_asect
argument_list|)
operator|->
name|reloc_size
operator|=
name|subspace
operator|.
name|fixup_request_quantity
expr_stmt|;
comment|/* We can not determine this yet.  When we read in the 		 relocation table the correct value will be filled in.  */
name|subspace_asect
operator|->
name|reloc_count
operator|=
operator|(
name|unsigned
operator|)
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Update save_subspace if appropriate.  */
if|if
condition|(
name|subspace
operator|.
name|file_loc_init_value
operator|>
name|save_subspace
operator|.
name|file_loc_init_value
condition|)
name|save_subspace
operator|=
name|subspace
expr_stmt|;
name|subspace_asect
operator|->
name|vma
operator|=
name|subspace
operator|.
name|subspace_start
expr_stmt|;
name|subspace_asect
operator|->
name|size
operator|=
name|subspace
operator|.
name|subspace_length
expr_stmt|;
name|subspace_asect
operator|->
name|filepos
operator|=
operator|(
name|subspace
operator|.
name|file_loc_init_value
operator|+
name|current_offset
operator|)
expr_stmt|;
name|subspace_asect
operator|->
name|alignment_power
operator|=
name|exact_log2
argument_list|(
name|subspace
operator|.
name|alignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|subspace_asect
operator|->
name|alignment_power
operator|==
operator|(
name|unsigned
operator|)
operator|-
literal|1
condition|)
goto|goto
name|error_return
goto|;
comment|/* Keep track of the accumulated sizes of the sections.  */
name|space_size
operator|+=
name|subspace
operator|.
name|subspace_length
expr_stmt|;
block|}
comment|/* This can happen for a .o which defines symbols in otherwise 	 empty subspaces.  */
if|if
condition|(
operator|!
name|save_subspace
operator|.
name|file_loc_init_value
condition|)
name|space_asect
operator|->
name|size
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|file_hdr
operator|->
name|a_magic
operator|!=
name|RELOC_MAGIC
condition|)
block|{
comment|/* Setup the size for the space section based upon the info 		 in the last subspace of the space.  */
name|space_asect
operator|->
name|size
operator|=
operator|(
name|save_subspace
operator|.
name|subspace_start
operator|-
name|space_asect
operator|->
name|vma
operator|+
name|save_subspace
operator|.
name|subspace_length
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The subspace_start field is not initialised in relocatable 	         only objects, so it cannot be used for length calculations. 		 Instead we use the space_size value which we have been 		 accumulating.  This isn't an accurate estimate since it 		 ignores alignment and ordering issues.  */
name|space_asect
operator|->
name|size
operator|=
name|space_size
expr_stmt|;
block|}
block|}
block|}
comment|/* Now that we've read in all the subspace records, we need to assign      a target index to each subspace.  */
name|amt
operator|=
name|total_subspaces
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|subspace_sections
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|subspace_sections
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|section
operator|=
name|abfd
operator|->
name|sections
init|;
name|section
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|som_is_subspace
argument_list|(
name|section
argument_list|)
condition|)
continue|continue;
name|subspace_sections
index|[
name|i
index|]
operator|=
name|section
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|qsort
argument_list|(
name|subspace_sections
argument_list|,
name|total_subspaces
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|,
name|compare_subspaces
argument_list|)
expr_stmt|;
comment|/* subspace_sections is now sorted in the order in which the subspaces      appear in the object file.  Assign an index to each one now.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total_subspaces
condition|;
name|i
operator|++
control|)
name|subspace_sections
index|[
name|i
index|]
operator|->
name|target_index
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|space_strings
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|space_strings
argument_list|)
expr_stmt|;
if|if
condition|(
name|subspace_sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|subspace_sections
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|space_strings
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|space_strings
argument_list|)
expr_stmt|;
if|if
condition|(
name|subspace_sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|subspace_sections
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Read in a SOM object and make it into a BFD.  */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|som_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|header
name|file_hdr
decl_stmt|;
name|struct
name|som_exec_auxhdr
modifier|*
name|aux_hdr_ptr
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|current_offset
init|=
literal|0
decl_stmt|;
name|struct
name|lst_header
name|lst_header
decl_stmt|;
name|struct
name|som_entry
name|som_entry
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
define|#
directive|define
name|ENTRY_SIZE
value|sizeof (struct som_entry)
name|amt
operator|=
name|FILE_HDR_SIZE
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|file_hdr
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|_PA_RISC_ID
argument_list|(
name|file_hdr
operator|.
name|system_id
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
switch|switch
condition|(
name|file_hdr
operator|.
name|a_magic
condition|)
block|{
case|case
name|RELOC_MAGIC
case|:
case|case
name|EXEC_MAGIC
case|:
case|case
name|SHARE_MAGIC
case|:
case|case
name|DEMAND_MAGIC
case|:
ifdef|#
directive|ifdef
name|DL_MAGIC
case|case
name|DL_MAGIC
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SHL_MAGIC
case|case
name|SHL_MAGIC
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SHARED_MAGIC_CNX
case|case
name|SHARED_MAGIC_CNX
case|:
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|EXECLIBMAGIC
case|case
name|EXECLIBMAGIC
case|:
comment|/* Read the lst header and determine where the SOM directory begins.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|amt
operator|=
name|SLSTHDR
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|lst_header
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Position to and read the first directory entry.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|lst_header
operator|.
name|dir_loc
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|amt
operator|=
name|ENTRY_SIZE
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|som_entry
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Now position to the first SOM.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|som_entry
operator|.
name|location
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|current_offset
operator|=
name|som_entry
operator|.
name|location
expr_stmt|;
comment|/* And finally, re-read the som header.  */
name|amt
operator|=
name|FILE_HDR_SIZE
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|file_hdr
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|file_hdr
operator|.
name|version_id
operator|!=
name|VERSION_ID
operator|&&
name|file_hdr
operator|.
name|version_id
operator|!=
name|NEW_VERSION_ID
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* If the aux_header_size field in the file header is zero, then this      object is an incomplete executable (a .o file).  Do not try to read      a non-existant auxiliary header.  */
if|if
condition|(
name|file_hdr
operator|.
name|aux_header_size
operator|!=
literal|0
condition|)
block|{
name|aux_hdr_ptr
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|aux_hdr_ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux_hdr_ptr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|amt
operator|=
name|AUX_HDR_SIZE
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
name|aux_hdr_ptr
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
operator|!
name|setup_sections
argument_list|(
name|abfd
argument_list|,
operator|&
name|file_hdr
argument_list|,
name|current_offset
argument_list|)
condition|)
block|{
comment|/* setup_sections does not bubble up a bfd error code.  */
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* This appears to be a valid SOM object.  Do some initialization.  */
return|return
name|som_object_setup
argument_list|(
name|abfd
argument_list|,
operator|&
name|file_hdr
argument_list|,
name|aux_hdr_ptr
argument_list|,
name|current_offset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a SOM object.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|som_mkobject
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
comment|/* Allocate memory to hold backend information.  */
name|abfd
operator|->
name|tdata
operator|.
name|som_data
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|som_data_struct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|som_data
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Initialize some information in the file header.  This routine makes    not attempt at doing the right thing for a full executable; it    is only meant to handle relocatable objects.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|som_prep_headers
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|header
modifier|*
name|file_hdr
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|header
argument_list|)
decl_stmt|;
comment|/* Make and attach a file header to the BFD.  */
name|file_hdr
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_hdr
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|=
name|file_hdr
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
condition|)
block|{
comment|/* Make and attach an exec header to the BFD.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|som_exec_auxhdr
argument_list|)
expr_stmt|;
name|obj_som_exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj_som_exec_hdr
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
condition|)
name|file_hdr
operator|->
name|a_magic
operator|=
name|DEMAND_MAGIC
expr_stmt|;
elseif|else
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|WP_TEXT
condition|)
name|file_hdr
operator|->
name|a_magic
operator|=
name|SHARE_MAGIC
expr_stmt|;
ifdef|#
directive|ifdef
name|SHL_MAGIC
elseif|else
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
condition|)
name|file_hdr
operator|->
name|a_magic
operator|=
name|SHL_MAGIC
expr_stmt|;
endif|#
directive|endif
else|else
name|file_hdr
operator|->
name|a_magic
operator|=
name|EXEC_MAGIC
expr_stmt|;
block|}
else|else
name|file_hdr
operator|->
name|a_magic
operator|=
name|RELOC_MAGIC
expr_stmt|;
comment|/* These fields are optional, and embedding timestamps is not always      a wise thing to do, it makes comparing objects during a multi-stage      bootstrap difficult.  */
name|file_hdr
operator|->
name|file_time
operator|.
name|secs
operator|=
literal|0
expr_stmt|;
name|file_hdr
operator|->
name|file_time
operator|.
name|nanosecs
operator|=
literal|0
expr_stmt|;
name|file_hdr
operator|->
name|entry_space
operator|=
literal|0
expr_stmt|;
name|file_hdr
operator|->
name|entry_subspace
operator|=
literal|0
expr_stmt|;
name|file_hdr
operator|->
name|entry_offset
operator|=
literal|0
expr_stmt|;
name|file_hdr
operator|->
name|presumed_dp
operator|=
literal|0
expr_stmt|;
comment|/* Now iterate over the sections translating information from      BFD sections to SOM spaces/subspaces.  */
for|for
control|(
name|section
operator|=
name|abfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
comment|/* Ignore anything which has not been marked as a space or 	 subspace.  */
if|if
condition|(
operator|!
name|som_is_space
argument_list|(
name|section
argument_list|)
operator|&&
operator|!
name|som_is_subspace
argument_list|(
name|section
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|som_is_space
argument_list|(
name|section
argument_list|)
condition|)
block|{
comment|/* Allocate space for the space dictionary.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|space_dictionary_record
argument_list|)
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Set space attributes.  Note most attributes of SOM spaces 	     are set based on the subspaces it contains.  */
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|loader_fix_index
operator|=
operator|-
literal|1
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|init_pointer_index
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Set more attributes that were stuffed away in private data.  */
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|sort_key
operator|=
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|sort_key
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|is_defined
operator|=
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|is_defined
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|is_private
operator|=
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|is_private
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|space_number
operator|=
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|space_number
expr_stmt|;
block|}
else|else
block|{
comment|/* Allocate space for the subspace dictionary.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|som_subspace_dictionary_record
argument_list|)
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Set subspace attributes.  Basic stuff is done here, additional 	     attributes are filled in later as more information becomes 	     available.  */
if|if
condition|(
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
condition|)
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|is_loadable
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|code_only
operator|=
literal|1
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|subspace_start
operator|=
name|section
operator|->
name|vma
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|subspace_length
operator|=
name|section
operator|->
name|size
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|initialization_length
operator|=
name|section
operator|->
name|size
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|alignment
operator|=
literal|1
operator|<<
name|section
operator|->
name|alignment_power
expr_stmt|;
comment|/* Set more attributes that were stuffed away in private data.  */
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|sort_key
operator|=
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|sort_key
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|access_control_bits
operator|=
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|access_control_bits
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|quadrant
operator|=
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|quadrant
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|is_comdat
operator|=
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|is_comdat
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|is_common
operator|=
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|is_common
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|dup_common
operator|=
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|dup_common
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the given section is a SOM space, FALSE otherwise.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|som_is_space
parameter_list|(
name|asection
modifier|*
name|section
parameter_list|)
block|{
comment|/* If no copy data is available, then it's neither a space nor a      subspace.  */
if|if
condition|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* If the containing space isn't the same as the given section,      then this isn't a space.  */
if|if
condition|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|container
operator|!=
name|section
operator|&&
operator|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|container
operator|->
name|output_section
operator|!=
name|section
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* OK.  Must be a space.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the given section is a SOM subspace, FALSE otherwise.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|som_is_subspace
parameter_list|(
name|asection
modifier|*
name|section
parameter_list|)
block|{
comment|/* If no copy data is available, then it's neither a space nor a      subspace.  */
if|if
condition|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* If the containing space is the same as the given section,      then this isn't a subspace.  */
if|if
condition|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|container
operator|==
name|section
operator|||
operator|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|container
operator|->
name|output_section
operator|==
name|section
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* OK.  Must be a subspace.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the given space contains the given subspace.  It    is safe to assume space really is a space, and subspace really    is a subspace.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|som_is_container
parameter_list|(
name|asection
modifier|*
name|space
parameter_list|,
name|asection
modifier|*
name|subspace
parameter_list|)
block|{
return|return
operator|(
name|som_section_data
argument_list|(
name|subspace
argument_list|)
operator|->
name|copy_data
operator|->
name|container
operator|==
name|space
operator|)
operator|||
operator|(
name|som_section_data
argument_list|(
name|subspace
argument_list|)
operator|->
name|copy_data
operator|->
name|container
operator|->
name|output_section
operator|==
name|space
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Count and return the number of spaces attached to the given BFD.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|som_count_spaces
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
for|for
control|(
name|section
operator|=
name|abfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
name|count
operator|+=
name|som_is_space
argument_list|(
name|section
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Count the number of subspaces attached to the given BFD.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|som_count_subspaces
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
for|for
control|(
name|section
operator|=
name|abfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
name|count
operator|+=
name|som_is_subspace
argument_list|(
name|section
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Return -1, 0, 1 indicating the relative ordering of sym1 and sym2.     We desire symbols to be ordered starting with the symbol with the    highest relocation count down to the symbol with the lowest relocation    count.  Doing so compacts the relocation stream.  */
end_comment

begin_function
specifier|static
name|int
name|compare_syms
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|asymbol
modifier|*
modifier|*
name|sym1
init|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sym2
init|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
name|unsigned
name|int
name|count1
decl_stmt|,
name|count2
decl_stmt|;
comment|/* Get relocation count for each symbol.  Note that the count      is stored in the udata pointer for section symbols!  */
if|if
condition|(
operator|(
operator|*
name|sym1
operator|)
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
condition|)
name|count1
operator|=
operator|(
operator|*
name|sym1
operator|)
operator|->
name|udata
operator|.
name|i
expr_stmt|;
else|else
name|count1
operator|=
name|som_symbol_data
argument_list|(
operator|*
name|sym1
argument_list|)
operator|->
name|reloc_count
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|sym2
operator|)
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
condition|)
name|count2
operator|=
operator|(
operator|*
name|sym2
operator|)
operator|->
name|udata
operator|.
name|i
expr_stmt|;
else|else
name|count2
operator|=
name|som_symbol_data
argument_list|(
operator|*
name|sym2
argument_list|)
operator|->
name|reloc_count
expr_stmt|;
comment|/* Return the appropriate value.  */
if|if
condition|(
name|count1
operator|<
name|count2
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|count1
operator|>
name|count2
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return -1, 0, 1 indicating the relative ordering of subspace1    and subspace.  */
end_comment

begin_function
specifier|static
name|int
name|compare_subspaces
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|asection
modifier|*
modifier|*
name|subspace1
init|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
name|asection
modifier|*
modifier|*
name|subspace2
init|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|subspace1
operator|)
operator|->
name|target_index
operator|<
operator|(
operator|*
name|subspace2
operator|)
operator|->
name|target_index
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|subspace2
operator|)
operator|->
name|target_index
operator|<
operator|(
operator|*
name|subspace1
operator|)
operator|->
name|target_index
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Perform various work in preparation for emitting the fixup stream.  */
end_comment

begin_function
specifier|static
name|void
name|som_prep_for_fixups
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|syms
parameter_list|,
name|unsigned
name|long
name|num_syms
parameter_list|)
block|{
name|unsigned
name|long
name|i
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sorted_syms
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* Most SOM relocations involving a symbol have a length which is      dependent on the index of the symbol.  So symbols which are      used often in relocations should have a small index.  */
comment|/* First initialize the counters for each symbol.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_syms
condition|;
name|i
operator|++
control|)
block|{
comment|/* Handle a section symbol; these have no pointers back to the 	 SOM symbol info.  So we just use the udata field to hold the 	 relocation count.  */
if|if
condition|(
name|som_symbol_data
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
operator|==
name|NULL
operator|||
name|syms
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
condition|)
block|{
name|syms
index|[
name|i
index|]
operator|->
name|flags
operator||=
name|BSF_SECTION_SYM
expr_stmt|;
name|syms
index|[
name|i
index|]
operator|->
name|udata
operator|.
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|som_symbol_data
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now that the counters are initialized, make a weighted count      of how often a given symbol is used in a relocation.  */
for|for
control|(
name|section
operator|=
name|abfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
name|int
name|j
decl_stmt|;
comment|/* Does this section have any relocations?  */
if|if
condition|(
operator|(
name|int
operator|)
name|section
operator|->
name|reloc_count
operator|<=
literal|0
condition|)
continue|continue;
comment|/* Walk through each relocation for this section.  */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
operator|(
name|int
operator|)
name|section
operator|->
name|reloc_count
condition|;
name|j
operator|++
control|)
block|{
name|arelent
modifier|*
name|reloc
init|=
name|section
operator|->
name|orelocation
index|[
name|j
index|]
decl_stmt|;
name|int
name|scale
decl_stmt|;
comment|/* A relocation against a symbol in the *ABS* section really 	     does not have a symbol.  Likewise if the symbol isn't associated 	     with any section.  */
if|if
condition|(
name|reloc
operator|->
name|sym_ptr_ptr
operator|==
name|NULL
operator|||
name|bfd_is_abs_section
argument_list|(
operator|(
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|section
argument_list|)
condition|)
continue|continue;
comment|/* Scaling to encourage symbols involved in R_DP_RELATIVE 	     and R_CODE_ONE_SYMBOL relocations to come first.  These 	     two relocations have single byte versions if the symbol 	     index is very small.  */
if|if
condition|(
name|reloc
operator|->
name|howto
operator|->
name|type
operator|==
name|R_DP_RELATIVE
operator|||
name|reloc
operator|->
name|howto
operator|->
name|type
operator|==
name|R_CODE_ONE_SYMBOL
condition|)
name|scale
operator|=
literal|2
expr_stmt|;
else|else
name|scale
operator|=
literal|1
expr_stmt|;
comment|/* Handle section symbols by storing the count in the udata 	     field.  It will not be used and the count is very important 	     for these symbols.  */
if|if
condition|(
operator|(
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
condition|)
block|{
operator|(
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|udata
operator|.
name|i
operator|=
operator|(
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|udata
operator|.
name|i
operator|+
name|scale
expr_stmt|;
continue|continue;
block|}
comment|/* A normal symbol.  Increment the count.  */
name|som_symbol_data
argument_list|(
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
argument_list|)
operator|->
name|reloc_count
operator|+=
name|scale
expr_stmt|;
block|}
block|}
comment|/* Sort a copy of the symbol table, rather than the canonical      output symbol table.  */
name|amt
operator|=
name|num_syms
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
expr_stmt|;
name|sorted_syms
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sorted_syms
argument_list|,
name|syms
argument_list|,
name|num_syms
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|sorted_syms
argument_list|,
name|num_syms
argument_list|,
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|,
name|compare_syms
argument_list|)
expr_stmt|;
name|obj_som_sorted_syms
argument_list|(
name|abfd
argument_list|)
operator|=
name|sorted_syms
expr_stmt|;
comment|/* Compute the symbol indexes, they will be needed by the relocation      code.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_syms
condition|;
name|i
operator|++
control|)
block|{
comment|/* A section symbol.  Again, there is no pointer to backend symbol 	 information, so we reuse the udata field again.  */
if|if
condition|(
name|sorted_syms
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
condition|)
name|sorted_syms
index|[
name|i
index|]
operator|->
name|udata
operator|.
name|i
operator|=
name|i
expr_stmt|;
else|else
name|som_symbol_data
argument_list|(
name|sorted_syms
index|[
name|i
index|]
argument_list|)
operator|->
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|som_write_fixups
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|long
name|current_offset
parameter_list|,
name|unsigned
name|int
modifier|*
name|total_reloc_sizep
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Chunk of memory that we can use as buffer space, then throw      away.  */
name|unsigned
name|char
name|tmp_space
index|[
name|SOM_TMP_BUFSIZE
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|total_reloc_size
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|subspace_reloc_size
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|num_spaces
init|=
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|space_total
decl_stmt|;
name|asection
modifier|*
name|section
init|=
name|abfd
operator|->
name|sections
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|memset
argument_list|(
name|tmp_space
argument_list|,
literal|0
argument_list|,
name|SOM_TMP_BUFSIZE
argument_list|)
expr_stmt|;
name|p
operator|=
name|tmp_space
expr_stmt|;
comment|/* All the fixups for a particular subspace are emitted in a single      stream.  All the subspaces for a particular space are emitted      as a single stream.       So, to get all the locations correct one must iterate through all the      spaces, for each space iterate through its subspaces and output a      fixups stream.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_spaces
condition|;
name|i
operator|++
control|)
block|{
name|asection
modifier|*
name|subsection
decl_stmt|;
comment|/* Find a space.  */
while|while
condition|(
operator|!
name|som_is_space
argument_list|(
name|section
argument_list|)
condition|)
name|section
operator|=
name|section
operator|->
name|next
expr_stmt|;
comment|/* Now iterate through each of its subspaces.  */
for|for
control|(
name|subsection
operator|=
name|abfd
operator|->
name|sections
init|;
name|subsection
operator|!=
name|NULL
condition|;
name|subsection
operator|=
name|subsection
operator|->
name|next
control|)
block|{
name|int
name|reloc_offset
decl_stmt|;
name|unsigned
name|int
name|current_rounding_mode
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_PCREL_MODES
name|unsigned
name|int
name|current_call_mode
decl_stmt|;
endif|#
directive|endif
comment|/* Find a subspace of this space.  */
if|if
condition|(
operator|!
name|som_is_subspace
argument_list|(
name|subsection
argument_list|)
operator|||
operator|!
name|som_is_container
argument_list|(
name|section
argument_list|,
name|subsection
argument_list|)
condition|)
continue|continue;
comment|/* If this subspace does not have real data, then we are 	     finished with it.  */
if|if
condition|(
operator|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
condition|)
block|{
name|som_section_data
argument_list|(
name|subsection
argument_list|)
operator|->
name|subspace_dict
operator|->
name|fixup_request_index
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* This subspace has some relocations.  Put the relocation stream 	     index into the subspace record.  */
name|som_section_data
argument_list|(
name|subsection
argument_list|)
operator|->
name|subspace_dict
operator|->
name|fixup_request_index
operator|=
name|total_reloc_size
expr_stmt|;
comment|/* To make life easier start over with a clean slate for 	     each subspace.  Seek to the start of the relocation stream 	     for this subspace in preparation for writing out its fixup 	     stream.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|current_offset
operator|+
name|total_reloc_size
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* Buffer space has already been allocated.  Just perform some 	     initialization here.  */
name|p
operator|=
name|tmp_space
expr_stmt|;
name|subspace_reloc_size
operator|=
literal|0
expr_stmt|;
name|reloc_offset
operator|=
literal|0
expr_stmt|;
name|som_initialize_reloc_queue
argument_list|(
name|reloc_queue
argument_list|)
expr_stmt|;
name|current_rounding_mode
operator|=
name|R_N_MODE
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_PCREL_MODES
name|current_call_mode
operator|=
name|R_SHORT_PCREL_MODE
expr_stmt|;
endif|#
directive|endif
comment|/* Translate each BFD relocation into one or more SOM 	     relocations.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|subsection
operator|->
name|reloc_count
condition|;
name|j
operator|++
control|)
block|{
name|arelent
modifier|*
name|bfd_reloc
init|=
name|subsection
operator|->
name|orelocation
index|[
name|j
index|]
decl_stmt|;
name|unsigned
name|int
name|skip
decl_stmt|;
name|int
name|sym_num
decl_stmt|;
comment|/* Get the symbol number.  Remember it's stored in a 		 special place for section symbols.  */
if|if
condition|(
operator|(
operator|*
name|bfd_reloc
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
condition|)
name|sym_num
operator|=
operator|(
operator|*
name|bfd_reloc
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|udata
operator|.
name|i
expr_stmt|;
else|else
name|sym_num
operator|=
name|som_symbol_data
argument_list|(
operator|*
name|bfd_reloc
operator|->
name|sym_ptr_ptr
argument_list|)
operator|->
name|index
expr_stmt|;
comment|/* If there is not enough room for the next couple relocations, 		 then dump the current buffer contents now.  Also reinitialize 		 the relocation queue.  		 No single BFD relocation could ever translate into more 		 than 100 bytes of SOM relocations (20bytes is probably the 		 upper limit, but leave lots of space for growth).  */
if|if
condition|(
name|p
operator|-
name|tmp_space
operator|+
literal|100
operator|>
name|SOM_TMP_BUFSIZE
condition|)
block|{
name|amt
operator|=
name|p
operator|-
name|tmp_space
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|tmp_space
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
name|p
operator|=
name|tmp_space
expr_stmt|;
name|som_initialize_reloc_queue
argument_list|(
name|reloc_queue
argument_list|)
expr_stmt|;
block|}
comment|/* Emit R_NO_RELOCATION fixups to map any bytes which were 		 skipped.  */
name|skip
operator|=
name|bfd_reloc
operator|->
name|address
operator|-
name|reloc_offset
expr_stmt|;
name|p
operator|=
name|som_reloc_skip
argument_list|(
name|abfd
argument_list|,
name|skip
argument_list|,
name|p
argument_list|,
operator|&
name|subspace_reloc_size
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
comment|/* Update reloc_offset for the next iteration.  		 Many relocations do not consume input bytes.  They 		 are markers, or set state necessary to perform some 		 later relocation.  */
switch|switch
condition|(
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
condition|)
block|{
case|case
name|R_ENTRY
case|:
case|case
name|R_ALT_ENTRY
case|:
case|case
name|R_EXIT
case|:
case|case
name|R_N_MODE
case|:
case|case
name|R_S_MODE
case|:
case|case
name|R_D_MODE
case|:
case|case
name|R_R_MODE
case|:
case|case
name|R_FSEL
case|:
case|case
name|R_LSEL
case|:
case|case
name|R_RSEL
case|:
case|case
name|R_COMP1
case|:
case|case
name|R_COMP2
case|:
case|case
name|R_BEGIN_BRTAB
case|:
case|case
name|R_END_BRTAB
case|:
case|case
name|R_BEGIN_TRY
case|:
case|case
name|R_END_TRY
case|:
case|case
name|R_N0SEL
case|:
case|case
name|R_N1SEL
case|:
ifndef|#
directive|ifndef
name|NO_PCREL_MODES
case|case
name|R_SHORT_PCREL_MODE
case|:
case|case
name|R_LONG_PCREL_MODE
case|:
endif|#
directive|endif
name|reloc_offset
operator|=
name|bfd_reloc
operator|->
name|address
expr_stmt|;
break|break;
default|default:
name|reloc_offset
operator|=
name|bfd_reloc
operator|->
name|address
operator|+
literal|4
expr_stmt|;
break|break;
block|}
comment|/* Now the actual relocation we care about.  */
switch|switch
condition|(
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
condition|)
block|{
case|case
name|R_PCREL_CALL
case|:
case|case
name|R_ABS_CALL
case|:
name|p
operator|=
name|som_reloc_call
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
operator|&
name|subspace_reloc_size
argument_list|,
name|bfd_reloc
argument_list|,
name|sym_num
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_CODE_ONE_SYMBOL
case|:
case|case
name|R_DP_RELATIVE
case|:
comment|/* Account for any addend.  */
if|if
condition|(
name|bfd_reloc
operator|->
name|addend
condition|)
name|p
operator|=
name|som_reloc_addend
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|addend
argument_list|,
name|p
argument_list|,
operator|&
name|subspace_reloc_size
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_num
operator|<
literal|0x20
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
operator|+
name|sym_num
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|subspace_reloc_size
operator|+=
literal|1
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym_num
operator|<
literal|0x100
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
operator|+
literal|32
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|sym_num
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
operator|&
name|subspace_reloc_size
argument_list|,
name|p
argument_list|,
literal|2
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym_num
operator|<
literal|0x10000000
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
operator|+
literal|33
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|sym_num
operator|>>
literal|16
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|sym_num
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
operator|&
name|subspace_reloc_size
argument_list|,
name|p
argument_list|,
literal|4
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|R_DATA_ONE_SYMBOL
case|:
case|case
name|R_DATA_PLABEL
case|:
case|case
name|R_CODE_PLABEL
case|:
case|case
name|R_DLT_REL
case|:
comment|/* Account for any addend using R_DATA_OVERRIDE.  */
if|if
condition|(
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
operator|!=
name|R_DATA_ONE_SYMBOL
operator|&&
name|bfd_reloc
operator|->
name|addend
condition|)
name|p
operator|=
name|som_reloc_addend
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|addend
argument_list|,
name|p
argument_list|,
operator|&
name|subspace_reloc_size
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_num
operator|<
literal|0x100
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|sym_num
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
operator|&
name|subspace_reloc_size
argument_list|,
name|p
argument_list|,
literal|2
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym_num
operator|<
literal|0x10000000
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
operator|+
literal|1
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|sym_num
operator|>>
literal|16
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|sym_num
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
operator|&
name|subspace_reloc_size
argument_list|,
name|p
argument_list|,
literal|4
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|R_ENTRY
case|:
block|{
name|unsigned
name|int
name|tmp
decl_stmt|;
name|arelent
modifier|*
name|tmp_reloc
init|=
name|NULL
decl_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|R_ENTRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* R_ENTRY relocations have 64 bits of associated 		       data.  Unfortunately the addend field of a bfd 		       relocation is only 32 bits.  So, we split up 		       the 64bit unwind information and store part in 		       the R_ENTRY relocation, and the rest in the R_EXIT 		       relocation.  */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|addend
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Find the next R_EXIT relocation.  */
for|for
control|(
name|tmp
operator|=
name|j
init|;
name|tmp
operator|<
name|subsection
operator|->
name|reloc_count
condition|;
name|tmp
operator|++
control|)
block|{
name|tmp_reloc
operator|=
name|subsection
operator|->
name|orelocation
index|[
name|tmp
index|]
expr_stmt|;
if|if
condition|(
name|tmp_reloc
operator|->
name|howto
operator|->
name|type
operator|==
name|R_EXIT
condition|)
break|break;
block|}
if|if
condition|(
name|tmp
operator|==
name|subsection
operator|->
name|reloc_count
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|tmp_reloc
operator|->
name|addend
argument_list|,
name|p
operator|+
literal|5
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
operator|&
name|subspace_reloc_size
argument_list|,
name|p
argument_list|,
literal|9
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|R_N_MODE
case|:
case|case
name|R_S_MODE
case|:
case|case
name|R_D_MODE
case|:
case|case
name|R_R_MODE
case|:
comment|/* If this relocation requests the current rounding 		     mode, then it is redundant.  */
if|if
condition|(
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
operator|!=
name|current_rounding_mode
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|subspace_reloc_size
operator|+=
literal|1
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
name|current_rounding_mode
operator|=
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
expr_stmt|;
block|}
break|break;
ifndef|#
directive|ifndef
name|NO_PCREL_MODES
case|case
name|R_LONG_PCREL_MODE
case|:
case|case
name|R_SHORT_PCREL_MODE
case|:
if|if
condition|(
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
operator|!=
name|current_call_mode
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|subspace_reloc_size
operator|+=
literal|1
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
name|current_call_mode
operator|=
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|R_EXIT
case|:
case|case
name|R_ALT_ENTRY
case|:
case|case
name|R_FSEL
case|:
case|case
name|R_LSEL
case|:
case|case
name|R_RSEL
case|:
case|case
name|R_BEGIN_BRTAB
case|:
case|case
name|R_END_BRTAB
case|:
case|case
name|R_BEGIN_TRY
case|:
case|case
name|R_N0SEL
case|:
case|case
name|R_N1SEL
case|:
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|subspace_reloc_size
operator|+=
literal|1
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|R_END_TRY
case|:
comment|/* The end of an exception handling region.  The reloc's 		     addend contains the offset of the exception handling 		     code.  */
if|if
condition|(
name|bfd_reloc
operator|->
name|addend
operator|==
literal|0
condition|)
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
argument_list|,
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_reloc
operator|->
name|addend
operator|<
literal|1024
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
operator|+
literal|1
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|addend
operator|/
literal|4
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
operator|&
name|subspace_reloc_size
argument_list|,
name|p
argument_list|,
literal|2
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
operator|+
literal|2
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_reloc
operator|->
name|addend
operator|/
literal|4
operator|)
operator|>>
literal|16
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|addend
operator|/
literal|4
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
operator|&
name|subspace_reloc_size
argument_list|,
name|p
argument_list|,
literal|4
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_COMP1
case|:
comment|/* The only time we generate R_COMP1, R_COMP2 and 		     R_CODE_EXPR relocs is for the difference of two 		     symbols.  Hence we can cheat here.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x44
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
operator|&
name|subspace_reloc_size
argument_list|,
name|p
argument_list|,
literal|2
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_COMP2
case|:
comment|/* The only time we generate R_COMP1, R_COMP2 and 		     R_CODE_EXPR relocs is for the difference of two 		     symbols.  Hence we can cheat here.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x80
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|sym_num
operator|>>
literal|16
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|sym_num
argument_list|,
name|p
operator|+
literal|3
argument_list|)
expr_stmt|;
name|p
operator|=
name|try_prev_fixup
argument_list|(
name|abfd
argument_list|,
operator|&
name|subspace_reloc_size
argument_list|,
name|p
argument_list|,
literal|5
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_CODE_EXPR
case|:
case|case
name|R_DATA_EXPR
case|:
comment|/* The only time we generate R_COMP1, R_COMP2 and 		     R_CODE_EXPR relocs is for the difference of two 		     symbols.  Hence we can cheat here.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_reloc
operator|->
name|howto
operator|->
name|type
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|subspace_reloc_size
operator|+=
literal|1
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
break|break;
comment|/* Put a "R_RESERVED" relocation in the stream if 		   we hit something we do not understand.  The linker 		   will complain loudly if this ever happens.  */
default|default:
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xff
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|subspace_reloc_size
operator|+=
literal|1
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Last BFD relocation for a subspace has been processed. 	     Map the rest of the subspace with R_NO_RELOCATION fixups.  */
name|p
operator|=
name|som_reloc_skip
argument_list|(
name|abfd
argument_list|,
name|subsection
operator|->
name|size
operator|-
name|reloc_offset
argument_list|,
name|p
argument_list|,
operator|&
name|subspace_reloc_size
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
comment|/* Scribble out the relocations.  */
name|amt
operator|=
name|p
operator|-
name|tmp_space
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|tmp_space
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
name|p
operator|=
name|tmp_space
expr_stmt|;
name|total_reloc_size
operator|+=
name|subspace_reloc_size
expr_stmt|;
name|som_section_data
argument_list|(
name|subsection
argument_list|)
operator|->
name|subspace_dict
operator|->
name|fixup_request_quantity
operator|=
name|subspace_reloc_size
expr_stmt|;
block|}
name|section
operator|=
name|section
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|total_reloc_sizep
operator|=
name|total_reloc_size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Write out the space/subspace string table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|som_write_space_strings
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|long
name|current_offset
parameter_list|,
name|unsigned
name|int
modifier|*
name|string_sizep
parameter_list|)
block|{
comment|/* Chunk of memory that we can use as buffer space, then throw      away.  */
name|size_t
name|tmp_space_size
init|=
name|SOM_TMP_BUFSIZE
decl_stmt|;
name|char
modifier|*
name|tmp_space
init|=
name|alloca
argument_list|(
name|tmp_space_size
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|tmp_space
decl_stmt|;
name|unsigned
name|int
name|strings_size
init|=
literal|0
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* Seek to the start of the space strings in preparation for writing      them out.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|current_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* Walk through all the spaces and subspaces (order is not important)      building up and writing string table entries for their names.  */
for|for
control|(
name|section
operator|=
name|abfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
name|size_t
name|length
decl_stmt|;
comment|/* Only work with space/subspaces; avoid any other sections 	 which might have been made (.text for example).  */
if|if
condition|(
operator|!
name|som_is_space
argument_list|(
name|section
argument_list|)
operator|&&
operator|!
name|som_is_subspace
argument_list|(
name|section
argument_list|)
condition|)
continue|continue;
comment|/* Get the length of the space/subspace name.  */
name|length
operator|=
name|strlen
argument_list|(
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* If there is not enough room for the next entry, then dump the 	 current buffer contents now and maybe allocate a larger 	 buffer.  Each entry will take 4 bytes to hold the string 	 length + the string itself + null terminator.  */
if|if
condition|(
name|p
operator|-
name|tmp_space
operator|+
literal|5
operator|+
name|length
operator|>
name|tmp_space_size
condition|)
block|{
comment|/* Flush buffer before refilling or reallocating.  */
name|amt
operator|=
name|p
operator|-
name|tmp_space
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|tmp_space
index|[
literal|0
index|]
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
comment|/* Reallocate if now empty buffer still too small.  */
if|if
condition|(
literal|5
operator|+
name|length
operator|>
name|tmp_space_size
condition|)
block|{
comment|/* Ensure a minimum growth factor to avoid O(n**2) space 		 consumption for n strings.  The optimal minimum 		 factor seems to be 2, as no other value can guarantee 		 wasting less than 50% space.  (Note that we cannot 		 deallocate space allocated by `alloca' without 		 returning from this function.)  The same technique is 		 used a few more times below when a buffer is 		 reallocated.  */
name|tmp_space_size
operator|=
name|MAX
argument_list|(
literal|2
operator|*
name|tmp_space_size
argument_list|,
literal|5
operator|+
name|length
argument_list|)
expr_stmt|;
name|tmp_space
operator|=
name|alloca
argument_list|(
name|tmp_space_size
argument_list|)
expr_stmt|;
block|}
comment|/* Reset to beginning of the (possibly new) buffer space.  */
name|p
operator|=
name|tmp_space
expr_stmt|;
block|}
comment|/* First element in a string table entry is the length of the 	 string.  Alignment issues are already handled.  */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|length
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|strings_size
operator|+=
literal|4
expr_stmt|;
comment|/* Record the index in the space/subspace records.  */
if|if
condition|(
name|som_is_space
argument_list|(
name|section
argument_list|)
condition|)
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|name
operator|.
name|n_strx
operator|=
name|strings_size
expr_stmt|;
else|else
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|name
operator|.
name|n_strx
operator|=
name|strings_size
expr_stmt|;
comment|/* Next comes the string itself + a null terminator.  */
name|strcpy
argument_list|(
name|p
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
name|p
operator|+=
name|length
operator|+
literal|1
expr_stmt|;
name|strings_size
operator|+=
name|length
operator|+
literal|1
expr_stmt|;
comment|/* Always align up to the next word boundary.  */
while|while
condition|(
name|strings_size
operator|%
literal|4
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|strings_size
operator|++
expr_stmt|;
block|}
block|}
comment|/* Done with the space/subspace strings.  Write out any information      contained in a partial block.  */
name|amt
operator|=
name|p
operator|-
name|tmp_space
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|tmp_space
index|[
literal|0
index|]
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
operator|*
name|string_sizep
operator|=
name|strings_size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Write out the symbol string table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|som_write_symbol_strings
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|long
name|current_offset
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|syms
parameter_list|,
name|unsigned
name|int
name|num_syms
parameter_list|,
name|unsigned
name|int
modifier|*
name|string_sizep
parameter_list|,
name|COMPUNIT
modifier|*
name|compilation_unit
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Chunk of memory that we can use as buffer space, then throw      away.  */
name|size_t
name|tmp_space_size
init|=
name|SOM_TMP_BUFSIZE
decl_stmt|;
name|char
modifier|*
name|tmp_space
init|=
name|alloca
argument_list|(
name|tmp_space_size
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|tmp_space
decl_stmt|;
name|unsigned
name|int
name|strings_size
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|comp
index|[
literal|4
index|]
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* This gets a bit gruesome because of the compilation unit.  The      strings within the compilation unit are part of the symbol      strings, but don't have symbol_dictionary entries.  So, manually      write them and update the compilation unit header.  On input, the      compilation unit header contains local copies of the strings.      Move them aside.  */
if|if
condition|(
name|compilation_unit
condition|)
block|{
name|comp
index|[
literal|0
index|]
operator|=
name|compilation_unit
operator|->
name|name
operator|.
name|n_name
expr_stmt|;
name|comp
index|[
literal|1
index|]
operator|=
name|compilation_unit
operator|->
name|language_name
operator|.
name|n_name
expr_stmt|;
name|comp
index|[
literal|2
index|]
operator|=
name|compilation_unit
operator|->
name|product_id
operator|.
name|n_name
expr_stmt|;
name|comp
index|[
literal|3
index|]
operator|=
name|compilation_unit
operator|->
name|version_id
operator|.
name|n_name
expr_stmt|;
block|}
comment|/* Seek to the start of the space strings in preparation for writing      them out.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|current_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|compilation_unit
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|length
init|=
name|strlen
argument_list|(
name|comp
index|[
name|i
index|]
argument_list|)
decl_stmt|;
comment|/* If there is not enough room for the next entry, then dump 	     the current buffer contents now and maybe allocate a 	     larger buffer.  */
if|if
condition|(
name|p
operator|-
name|tmp_space
operator|+
literal|5
operator|+
name|length
operator|>
name|tmp_space_size
condition|)
block|{
comment|/* Flush buffer before refilling or reallocating.  */
name|amt
operator|=
name|p
operator|-
name|tmp_space
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|tmp_space
index|[
literal|0
index|]
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
comment|/* Reallocate if now empty buffer still too small.  */
if|if
condition|(
literal|5
operator|+
name|length
operator|>
name|tmp_space_size
condition|)
block|{
comment|/* See alloca above for discussion of new size.  */
name|tmp_space_size
operator|=
name|MAX
argument_list|(
literal|2
operator|*
name|tmp_space_size
argument_list|,
literal|5
operator|+
name|length
argument_list|)
expr_stmt|;
name|tmp_space
operator|=
name|alloca
argument_list|(
name|tmp_space_size
argument_list|)
expr_stmt|;
block|}
comment|/* Reset to beginning of the (possibly new) buffer 		 space.  */
name|p
operator|=
name|tmp_space
expr_stmt|;
block|}
comment|/* First element in a string table entry is the length of 	     the string.  This must always be 4 byte aligned.  This is 	     also an appropriate time to fill in the string index 	     field in the symbol table entry.  */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|length
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|strings_size
operator|+=
literal|4
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
comment|/* Next comes the string itself + a null terminator.  */
name|strcpy
argument_list|(
name|p
argument_list|,
name|comp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
name|obj_som_compilation_unit
argument_list|(
name|abfd
argument_list|)
operator|->
name|name
operator|.
name|n_strx
operator|=
name|strings_size
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|obj_som_compilation_unit
argument_list|(
name|abfd
argument_list|)
operator|->
name|language_name
operator|.
name|n_strx
operator|=
name|strings_size
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|obj_som_compilation_unit
argument_list|(
name|abfd
argument_list|)
operator|->
name|product_id
operator|.
name|n_strx
operator|=
name|strings_size
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|obj_som_compilation_unit
argument_list|(
name|abfd
argument_list|)
operator|->
name|version_id
operator|.
name|n_strx
operator|=
name|strings_size
expr_stmt|;
break|break;
block|}
name|p
operator|+=
name|length
operator|+
literal|1
expr_stmt|;
name|strings_size
operator|+=
name|length
operator|+
literal|1
expr_stmt|;
comment|/* Always align up to the next word boundary.  */
while|while
condition|(
name|strings_size
operator|%
literal|4
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|strings_size
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_syms
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|length
init|=
name|strlen
argument_list|(
name|syms
index|[
name|i
index|]
operator|->
name|name
argument_list|)
decl_stmt|;
comment|/* If there is not enough room for the next entry, then dump the 	 current buffer contents now and maybe allocate a larger buffer.  */
if|if
condition|(
name|p
operator|-
name|tmp_space
operator|+
literal|5
operator|+
name|length
operator|>
name|tmp_space_size
condition|)
block|{
comment|/* Flush buffer before refilling or reallocating.  */
name|amt
operator|=
name|p
operator|-
name|tmp_space
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|tmp_space
index|[
literal|0
index|]
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
comment|/* Reallocate if now empty buffer still too small.  */
if|if
condition|(
literal|5
operator|+
name|length
operator|>
name|tmp_space_size
condition|)
block|{
comment|/* See alloca above for discussion of new size.  */
name|tmp_space_size
operator|=
name|MAX
argument_list|(
literal|2
operator|*
name|tmp_space_size
argument_list|,
literal|5
operator|+
name|length
argument_list|)
expr_stmt|;
name|tmp_space
operator|=
name|alloca
argument_list|(
name|tmp_space_size
argument_list|)
expr_stmt|;
block|}
comment|/* Reset to beginning of the (possibly new) buffer space.  */
name|p
operator|=
name|tmp_space
expr_stmt|;
block|}
comment|/* First element in a string table entry is the length of the 	 string.  This must always be 4 byte aligned.  This is also 	 an appropriate time to fill in the string index field in the 	 symbol table entry.  */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|length
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|strings_size
operator|+=
literal|4
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
comment|/* Next comes the string itself + a null terminator.  */
name|strcpy
argument_list|(
name|p
argument_list|,
name|syms
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|som_symbol_data
argument_list|(
name|syms
index|[
name|i
index|]
argument_list|)
operator|->
name|stringtab_offset
operator|=
name|strings_size
expr_stmt|;
name|p
operator|+=
name|length
operator|+
literal|1
expr_stmt|;
name|strings_size
operator|+=
name|length
operator|+
literal|1
expr_stmt|;
comment|/* Always align up to the next word boundary.  */
while|while
condition|(
name|strings_size
operator|%
literal|4
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|strings_size
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
comment|/* Scribble out any partial block.  */
name|amt
operator|=
name|p
operator|-
name|tmp_space
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|tmp_space
index|[
literal|0
index|]
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
operator|*
name|string_sizep
operator|=
name|strings_size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Compute variable information to be placed in the SOM headers,    space/subspace dictionaries, relocation streams, etc.  Begin    writing parts of the object file.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|som_begin_writing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|unsigned
name|long
name|current_offset
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|strings_size
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|num_spaces
decl_stmt|,
name|num_subspaces
decl_stmt|,
name|i
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|unsigned
name|int
name|total_subspaces
init|=
literal|0
decl_stmt|;
name|struct
name|som_exec_auxhdr
modifier|*
name|exec_header
init|=
name|NULL
decl_stmt|;
comment|/* The file header will always be first in an object file,      everything else can be in random locations.  To keep things      "simple" BFD will lay out the object file in the manner suggested      by the PRO ABI for PA-RISC Systems.  */
comment|/* Before any output can really begin offsets for all the major      portions of the object file must be computed.  So, starting      with the initial file header compute (and sometimes write)      each portion of the object file.  */
comment|/* Make room for the file header, it's contents are not complete      yet, so it can not be written at this time.  */
name|current_offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|header
argument_list|)
expr_stmt|;
comment|/* Any auxiliary headers will follow the file header.  Right now      we support only the copyright and version headers.  */
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|aux_header_location
operator|=
name|current_offset
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|aux_header_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
condition|)
block|{
comment|/* Parts of the exec header will be filled in later, so 	 delay writing the header itself.  Fill in the defaults, 	 and write it later.  */
name|current_offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|som_exec_auxhdr
argument_list|)
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|aux_header_size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|som_exec_auxhdr
argument_list|)
expr_stmt|;
name|exec_header
operator|=
name|obj_som_exec_hdr
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|exec_header
operator|->
name|som_auxhdr
operator|.
name|type
operator|=
name|EXEC_AUX_ID
expr_stmt|;
name|exec_header
operator|->
name|som_auxhdr
operator|.
name|length
operator|=
literal|40
expr_stmt|;
block|}
if|if
condition|(
name|obj_som_version_hdr
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|bfd_size_type
name|len
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|current_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* Write the aux_id structure and the string length.  */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aux_id
argument_list|)
operator|+
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|aux_header_size
operator|+=
name|len
expr_stmt|;
name|current_offset
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|obj_som_version_hdr
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|len
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
condition|)
return|return
name|FALSE
return|;
comment|/* Write the version string.  */
name|len
operator|=
name|obj_som_version_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|header_id
operator|.
name|length
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|aux_header_size
operator|+=
name|len
expr_stmt|;
name|current_offset
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|obj_som_version_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|user_string
argument_list|,
name|len
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|obj_som_copyright_hdr
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|bfd_size_type
name|len
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|current_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* Write the aux_id structure and the string length.  */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aux_id
argument_list|)
operator|+
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|aux_header_size
operator|+=
name|len
expr_stmt|;
name|current_offset
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|obj_som_copyright_hdr
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|len
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
condition|)
return|return
name|FALSE
return|;
comment|/* Write the copyright string.  */
name|len
operator|=
name|obj_som_copyright_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|header_id
operator|.
name|length
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|aux_header_size
operator|+=
name|len
expr_stmt|;
name|current_offset
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|obj_som_copyright_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|copyright
argument_list|,
name|len
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Next comes the initialization pointers; we have no initialization      pointers, so current offset does not change.  */
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|init_array_location
operator|=
name|current_offset
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|init_array_total
operator|=
literal|0
expr_stmt|;
comment|/* Next are the space records.  These are fixed length records.       Count the number of spaces to determine how much room is needed      in the object file for the space records.       The names of the spaces are stored in a separate string table,      and the index for each space into the string table is computed      below.  Therefore, it is not possible to write the space headers      at this time.  */
name|num_spaces
operator|=
name|som_count_spaces
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|space_location
operator|=
name|current_offset
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|space_total
operator|=
name|num_spaces
expr_stmt|;
name|current_offset
operator|+=
name|num_spaces
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|space_dictionary_record
argument_list|)
expr_stmt|;
comment|/* Next are the subspace records.  These are fixed length records.       Count the number of subspaes to determine how much room is needed      in the object file for the subspace records.       A variety if fields in the subspace record are still unknown at      this time (index into string table, fixup stream location/size, etc).  */
name|num_subspaces
operator|=
name|som_count_subspaces
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|subspace_location
operator|=
name|current_offset
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|subspace_total
operator|=
name|num_subspaces
expr_stmt|;
name|current_offset
operator|+=
name|num_subspaces
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|som_subspace_dictionary_record
argument_list|)
expr_stmt|;
comment|/* Next is the string table for the space/subspace names.  We will      build and write the string table on the fly.  At the same time      we will fill in the space/subspace name index fields.  */
comment|/* The string table needs to be aligned on a word boundary.  */
if|if
condition|(
name|current_offset
operator|%
literal|4
condition|)
name|current_offset
operator|+=
operator|(
literal|4
operator|-
operator|(
name|current_offset
operator|%
literal|4
operator|)
operator|)
expr_stmt|;
comment|/* Mark the offset of the space/subspace string table in the      file header.  */
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|space_strings_location
operator|=
name|current_offset
expr_stmt|;
comment|/* Scribble out the space strings.  */
if|if
condition|(
operator|!
name|som_write_space_strings
argument_list|(
name|abfd
argument_list|,
name|current_offset
argument_list|,
operator|&
name|strings_size
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Record total string table size in the header and update the      current offset.  */
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|space_strings_size
operator|=
name|strings_size
expr_stmt|;
name|current_offset
operator|+=
name|strings_size
expr_stmt|;
comment|/* Next is the compilation unit.  */
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|compiler_location
operator|=
name|current_offset
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|compiler_total
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|obj_som_compilation_unit
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|compiler_total
operator|=
literal|1
expr_stmt|;
name|current_offset
operator|+=
name|COMPUNITSZ
expr_stmt|;
block|}
comment|/* Now compute the file positions for the loadable subspaces, taking      care to make sure everything stays properly aligned.  */
name|section
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_spaces
condition|;
name|i
operator|++
control|)
block|{
name|asection
modifier|*
name|subsection
decl_stmt|;
name|int
name|first_subspace
decl_stmt|;
name|unsigned
name|int
name|subspace_offset
init|=
literal|0
decl_stmt|;
comment|/* Find a space.  */
while|while
condition|(
operator|!
name|som_is_space
argument_list|(
name|section
argument_list|)
condition|)
name|section
operator|=
name|section
operator|->
name|next
expr_stmt|;
name|first_subspace
operator|=
literal|1
expr_stmt|;
comment|/* Now look for all its subspaces.  */
for|for
control|(
name|subsection
operator|=
name|abfd
operator|->
name|sections
init|;
name|subsection
operator|!=
name|NULL
condition|;
name|subsection
operator|=
name|subsection
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|som_is_subspace
argument_list|(
name|subsection
argument_list|)
operator|||
operator|!
name|som_is_container
argument_list|(
name|section
argument_list|,
name|subsection
argument_list|)
operator|||
operator|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* If this is the first subspace in the space, and we are 	     building an executable, then take care to make sure all 	     the alignments are correct and update the exec header.  */
if|if
condition|(
name|first_subspace
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
condition|)
block|{
comment|/* Demand paged executables have each space aligned to a 		 page boundary.  Sharable executables (write-protected 		 text) have just the private (aka data& bss) space aligned 		 to a page boundary.  Ugh.  Not true for HPUX.  		 The HPUX kernel requires the text to always be page aligned 		 within the file regardless of the executable's type.  */
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|D_PAGED
operator||
name|DYNAMIC
operator|)
operator|||
operator|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|||
operator|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|WP_TEXT
operator|)
operator|&&
operator|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_DATA
operator|)
operator|)
condition|)
name|current_offset
operator|=
name|SOM_ALIGN
argument_list|(
name|current_offset
argument_list|,
name|PA_PAGESIZE
argument_list|)
expr_stmt|;
comment|/* Update the exec header.  */
if|if
condition|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_CODE
operator|&&
name|exec_header
operator|->
name|exec_tfile
operator|==
literal|0
condition|)
block|{
name|exec_header
operator|->
name|exec_tmem
operator|=
name|section
operator|->
name|vma
expr_stmt|;
name|exec_header
operator|->
name|exec_tfile
operator|=
name|current_offset
expr_stmt|;
block|}
if|if
condition|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_DATA
operator|&&
name|exec_header
operator|->
name|exec_dfile
operator|==
literal|0
condition|)
block|{
name|exec_header
operator|->
name|exec_dmem
operator|=
name|section
operator|->
name|vma
expr_stmt|;
name|exec_header
operator|->
name|exec_dfile
operator|=
name|current_offset
expr_stmt|;
block|}
comment|/* Keep track of exactly where we are within a particular 		 space.  This is necessary as the braindamaged HPUX 		 loader will create holes between subspaces *and* 		 subspace alignments are *NOT* preserved.  What a crock.  */
name|subspace_offset
operator|=
name|subsection
operator|->
name|vma
expr_stmt|;
comment|/* Only do this for the first subspace within each space.  */
name|first_subspace
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
condition|)
block|{
comment|/* The braindamaged HPUX loader may have created a hole 		 between two subspaces.  It is *not* sufficient to use 		 the alignment specifications within the subspaces to 		 account for these holes -- I've run into at least one 		 case where the loader left one code subspace unaligned 		 in a final executable.  		 To combat this we keep a current offset within each space, 		 and use the subspace vma fields to detect and preserve 		 holes.  What a crock!  		 ps.  This is not necessary for unloadable space/subspaces.  */
name|current_offset
operator|+=
name|subsection
operator|->
name|vma
operator|-
name|subspace_offset
expr_stmt|;
if|if
condition|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
name|exec_header
operator|->
name|exec_tsize
operator|+=
name|subsection
operator|->
name|vma
operator|-
name|subspace_offset
expr_stmt|;
else|else
name|exec_header
operator|->
name|exec_dsize
operator|+=
name|subsection
operator|->
name|vma
operator|-
name|subspace_offset
expr_stmt|;
name|subspace_offset
operator|+=
name|subsection
operator|->
name|vma
operator|-
name|subspace_offset
expr_stmt|;
block|}
name|subsection
operator|->
name|target_index
operator|=
name|total_subspaces
operator|++
expr_stmt|;
comment|/* This is real data to be loaded from the file.  */
if|if
condition|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
block|{
comment|/* Update the size of the code& data.  */
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|&&
name|subsection
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
name|exec_header
operator|->
name|exec_tsize
operator|+=
name|subsection
operator|->
name|size
expr_stmt|;
elseif|else
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|&&
name|subsection
operator|->
name|flags
operator|&
name|SEC_DATA
condition|)
name|exec_header
operator|->
name|exec_dsize
operator|+=
name|subsection
operator|->
name|size
expr_stmt|;
name|som_section_data
argument_list|(
name|subsection
argument_list|)
operator|->
name|subspace_dict
operator|->
name|file_loc_init_value
operator|=
name|current_offset
expr_stmt|;
name|subsection
operator|->
name|filepos
operator|=
name|current_offset
expr_stmt|;
name|current_offset
operator|+=
name|subsection
operator|->
name|size
expr_stmt|;
name|subspace_offset
operator|+=
name|subsection
operator|->
name|size
expr_stmt|;
block|}
comment|/* Looks like uninitialized data.  */
else|else
block|{
comment|/* Update the size of the bss section.  */
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
condition|)
name|exec_header
operator|->
name|exec_bsize
operator|+=
name|subsection
operator|->
name|size
expr_stmt|;
name|som_section_data
argument_list|(
name|subsection
argument_list|)
operator|->
name|subspace_dict
operator|->
name|file_loc_init_value
operator|=
literal|0
expr_stmt|;
name|som_section_data
argument_list|(
name|subsection
argument_list|)
operator|->
name|subspace_dict
operator|->
name|initialization_length
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Goto the next section.  */
name|section
operator|=
name|section
operator|->
name|next
expr_stmt|;
block|}
comment|/* Finally compute the file positions for unloadable subspaces.      If building an executable, start the unloadable stuff on its      own page.  */
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
condition|)
name|current_offset
operator|=
name|SOM_ALIGN
argument_list|(
name|current_offset
argument_list|,
name|PA_PAGESIZE
argument_list|)
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|unloadable_sp_location
operator|=
name|current_offset
expr_stmt|;
name|section
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_spaces
condition|;
name|i
operator|++
control|)
block|{
name|asection
modifier|*
name|subsection
decl_stmt|;
comment|/* Find a space.  */
while|while
condition|(
operator|!
name|som_is_space
argument_list|(
name|section
argument_list|)
condition|)
name|section
operator|=
name|section
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
condition|)
name|current_offset
operator|=
name|SOM_ALIGN
argument_list|(
name|current_offset
argument_list|,
name|PA_PAGESIZE
argument_list|)
expr_stmt|;
comment|/* Now look for all its subspaces.  */
for|for
control|(
name|subsection
operator|=
name|abfd
operator|->
name|sections
init|;
name|subsection
operator|!=
name|NULL
condition|;
name|subsection
operator|=
name|subsection
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|som_is_subspace
argument_list|(
name|subsection
argument_list|)
operator|||
operator|!
name|som_is_container
argument_list|(
name|section
argument_list|,
name|subsection
argument_list|)
operator|||
operator|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|subsection
operator|->
name|target_index
operator|=
name|total_subspaces
operator|++
expr_stmt|;
comment|/* This is real data to be loaded from the file.  */
if|if
condition|(
operator|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
block|{
name|som_section_data
argument_list|(
name|subsection
argument_list|)
operator|->
name|subspace_dict
operator|->
name|file_loc_init_value
operator|=
name|current_offset
expr_stmt|;
name|subsection
operator|->
name|filepos
operator|=
name|current_offset
expr_stmt|;
name|current_offset
operator|+=
name|subsection
operator|->
name|size
expr_stmt|;
block|}
comment|/* Looks like uninitialized data.  */
else|else
block|{
name|som_section_data
argument_list|(
name|subsection
argument_list|)
operator|->
name|subspace_dict
operator|->
name|file_loc_init_value
operator|=
literal|0
expr_stmt|;
name|som_section_data
argument_list|(
name|subsection
argument_list|)
operator|->
name|subspace_dict
operator|->
name|initialization_length
operator|=
name|subsection
operator|->
name|size
expr_stmt|;
block|}
block|}
comment|/* Goto the next section.  */
name|section
operator|=
name|section
operator|->
name|next
expr_stmt|;
block|}
comment|/* If building an executable, then make sure to seek to and write      one byte at the end of the file to make sure any necessary      zeros are filled in.  Ugh.  */
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
condition|)
name|current_offset
operator|=
name|SOM_ALIGN
argument_list|(
name|current_offset
argument_list|,
name|PA_PAGESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|current_offset
operator|-
literal|1
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
literal|""
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|FALSE
return|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|unloadable_sp_size
operator|=
name|current_offset
operator|-
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|unloadable_sp_location
expr_stmt|;
comment|/* Loader fixups are not supported in any way shape or form.  */
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|loader_fixup_location
operator|=
literal|0
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|loader_fixup_total
operator|=
literal|0
expr_stmt|;
comment|/* Done.  Store the total size of the SOM so far.  */
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|som_length
operator|=
name|current_offset
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finally, scribble out the various headers to the disk.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|som_finish_writing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|int
name|num_spaces
init|=
name|som_count_spaces
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|syms
init|=
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|num_syms
decl_stmt|;
name|int
name|subspace_index
init|=
literal|0
decl_stmt|;
name|file_ptr
name|location
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|unsigned
name|long
name|current_offset
decl_stmt|;
name|unsigned
name|int
name|strings_size
decl_stmt|,
name|total_reloc_size
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* We must set up the version identifier here as objcopy/strip copy      private BFD data too late for us to handle this in som_begin_writing.  */
if|if
condition|(
name|obj_som_exec_data
argument_list|(
name|abfd
argument_list|)
operator|&&
name|obj_som_exec_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|version_id
condition|)
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|version_id
operator|=
name|obj_som_exec_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|version_id
expr_stmt|;
else|else
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|version_id
operator|=
name|NEW_VERSION_ID
expr_stmt|;
comment|/* Next is the symbol table.  These are fixed length records.       Count the number of symbols to determine how much room is needed      in the object file for the symbol table.       The names of the symbols are stored in a separate string table,      and the index for each symbol name into the string table is computed      below.  Therefore, it is not possible to write the symbol table      at this time.       These used to be output before the subspace contents, but they      were moved here to work around a stupid bug in the hpux linker      (fixed in hpux10).  */
name|current_offset
operator|=
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|som_length
expr_stmt|;
comment|/* Make sure we're on a word boundary.  */
if|if
condition|(
name|current_offset
operator|%
literal|4
condition|)
name|current_offset
operator|+=
operator|(
literal|4
operator|-
operator|(
name|current_offset
operator|%
literal|4
operator|)
operator|)
expr_stmt|;
name|num_syms
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbol_location
operator|=
name|current_offset
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbol_total
operator|=
name|num_syms
expr_stmt|;
name|current_offset
operator|+=
name|num_syms
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_dictionary_record
argument_list|)
expr_stmt|;
comment|/* Next are the symbol strings.      Align them to a word boundary.  */
if|if
condition|(
name|current_offset
operator|%
literal|4
condition|)
name|current_offset
operator|+=
operator|(
literal|4
operator|-
operator|(
name|current_offset
operator|%
literal|4
operator|)
operator|)
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbol_strings_location
operator|=
name|current_offset
expr_stmt|;
comment|/* Scribble out the symbol strings.  */
if|if
condition|(
operator|!
name|som_write_symbol_strings
argument_list|(
name|abfd
argument_list|,
name|current_offset
argument_list|,
name|syms
argument_list|,
name|num_syms
argument_list|,
operator|&
name|strings_size
argument_list|,
name|obj_som_compilation_unit
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Record total string table size in header and update the      current offset.  */
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbol_strings_size
operator|=
name|strings_size
expr_stmt|;
name|current_offset
operator|+=
name|strings_size
expr_stmt|;
comment|/* Do prep work before handling fixups.  */
name|som_prep_for_fixups
argument_list|(
name|abfd
argument_list|,
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* At the end of the file is the fixup stream which starts on a      word boundary.  */
if|if
condition|(
name|current_offset
operator|%
literal|4
condition|)
name|current_offset
operator|+=
operator|(
literal|4
operator|-
operator|(
name|current_offset
operator|%
literal|4
operator|)
operator|)
expr_stmt|;
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|fixup_request_location
operator|=
name|current_offset
expr_stmt|;
comment|/* Write the fixups and update fields in subspace headers which      relate to the fixup stream.  */
if|if
condition|(
operator|!
name|som_write_fixups
argument_list|(
name|abfd
argument_list|,
name|current_offset
argument_list|,
operator|&
name|total_reloc_size
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Record the total size of the fixup stream in the file header.  */
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|fixup_request_total
operator|=
name|total_reloc_size
expr_stmt|;
comment|/* Done.  Store the total size of the SOM.  */
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|som_length
operator|=
name|current_offset
operator|+
name|total_reloc_size
expr_stmt|;
comment|/* Now that the symbol table information is complete, build and      write the symbol table.  */
if|if
condition|(
operator|!
name|som_build_and_write_symbol_table
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Subspaces are written first so that we can set up information      about them in their containing spaces as the subspace is written.  */
comment|/* Seek to the start of the subspace dictionary records.  */
name|location
operator|=
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|subspace_location
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|location
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|section
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
comment|/* Now for each loadable space write out records for its subspaces.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_spaces
condition|;
name|i
operator|++
control|)
block|{
name|asection
modifier|*
name|subsection
decl_stmt|;
comment|/* Find a space.  */
while|while
condition|(
operator|!
name|som_is_space
argument_list|(
name|section
argument_list|)
condition|)
name|section
operator|=
name|section
operator|->
name|next
expr_stmt|;
comment|/* Now look for all its subspaces.  */
for|for
control|(
name|subsection
operator|=
name|abfd
operator|->
name|sections
init|;
name|subsection
operator|!=
name|NULL
condition|;
name|subsection
operator|=
name|subsection
operator|->
name|next
control|)
block|{
comment|/* Skip any section which does not correspond to a space 	     or subspace.  Or does not have SEC_ALLOC set (and therefore 	     has no real bits on the disk).  */
if|if
condition|(
operator|!
name|som_is_subspace
argument_list|(
name|subsection
argument_list|)
operator|||
operator|!
name|som_is_container
argument_list|(
name|section
argument_list|,
name|subsection
argument_list|)
operator|||
operator|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* If this is the first subspace for this space, then save 	     the index of the subspace in its containing space.  Also 	     set "is_loadable" in the containing space.  */
if|if
condition|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|subspace_quantity
operator|==
literal|0
condition|)
block|{
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|is_loadable
operator|=
literal|1
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|subspace_index
operator|=
name|subspace_index
expr_stmt|;
block|}
comment|/* Increment the number of subspaces seen and the number of 	     subspaces contained within the current space.  */
name|subspace_index
operator|++
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|subspace_quantity
operator|++
expr_stmt|;
comment|/* Mark the index of the current space within the subspace's 	     dictionary record.  */
name|som_section_data
argument_list|(
name|subsection
argument_list|)
operator|->
name|subspace_dict
operator|->
name|space_index
operator|=
name|i
expr_stmt|;
comment|/* Dump the current subspace header.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|som_subspace_dictionary_record
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|som_section_data
argument_list|(
name|subsection
argument_list|)
operator|->
name|subspace_dict
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Goto the next section.  */
name|section
operator|=
name|section
operator|->
name|next
expr_stmt|;
block|}
comment|/* Now repeat the process for unloadable subspaces.  */
name|section
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
comment|/* Now for each space write out records for its subspaces.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_spaces
condition|;
name|i
operator|++
control|)
block|{
name|asection
modifier|*
name|subsection
decl_stmt|;
comment|/* Find a space.  */
while|while
condition|(
operator|!
name|som_is_space
argument_list|(
name|section
argument_list|)
condition|)
name|section
operator|=
name|section
operator|->
name|next
expr_stmt|;
comment|/* Now look for all its subspaces.  */
for|for
control|(
name|subsection
operator|=
name|abfd
operator|->
name|sections
init|;
name|subsection
operator|!=
name|NULL
condition|;
name|subsection
operator|=
name|subsection
operator|->
name|next
control|)
block|{
comment|/* Skip any section which does not correspond to a space or 	     subspace, or which SEC_ALLOC set (and therefore handled 	     in the loadable spaces/subspaces code above).  */
if|if
condition|(
operator|!
name|som_is_subspace
argument_list|(
name|subsection
argument_list|)
operator|||
operator|!
name|som_is_container
argument_list|(
name|section
argument_list|,
name|subsection
argument_list|)
operator|||
operator|(
name|subsection
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* If this is the first subspace for this space, then save 	     the index of the subspace in its containing space.  Clear 	     "is_loadable".  */
if|if
condition|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|subspace_quantity
operator|==
literal|0
condition|)
block|{
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|is_loadable
operator|=
literal|0
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|subspace_index
operator|=
name|subspace_index
expr_stmt|;
block|}
comment|/* Increment the number of subspaces seen and the number of 	     subspaces contained within the current space.  */
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
operator|->
name|subspace_quantity
operator|++
expr_stmt|;
name|subspace_index
operator|++
expr_stmt|;
comment|/* Mark the index of the current space within the subspace's 	     dictionary record.  */
name|som_section_data
argument_list|(
name|subsection
argument_list|)
operator|->
name|subspace_dict
operator|->
name|space_index
operator|=
name|i
expr_stmt|;
comment|/* Dump this subspace header.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|som_subspace_dictionary_record
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|som_section_data
argument_list|(
name|subsection
argument_list|)
operator|->
name|subspace_dict
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Goto the next section.  */
name|section
operator|=
name|section
operator|->
name|next
expr_stmt|;
block|}
comment|/* All the subspace dictionary records are written, and all the      fields are set up in the space dictionary records.       Seek to the right location and start writing the space      dictionary records.  */
name|location
operator|=
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|space_location
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|location
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|section
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_spaces
condition|;
name|i
operator|++
control|)
block|{
comment|/* Find a space.  */
while|while
condition|(
operator|!
name|som_is_space
argument_list|(
name|section
argument_list|)
condition|)
name|section
operator|=
name|section
operator|->
name|next
expr_stmt|;
comment|/* Dump its header.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|space_dictionary_record
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|space_dict
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
comment|/* Goto the next section.  */
name|section
operator|=
name|section
operator|->
name|next
expr_stmt|;
block|}
comment|/* Write the compilation unit record if there is one.  */
if|if
condition|(
name|obj_som_compilation_unit
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|location
operator|=
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|compiler_location
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|location
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|amt
operator|=
name|COMPUNITSZ
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|obj_som_compilation_unit
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Setting of the system_id has to happen very late now that copying of      BFD private data happens *after* section contents are set.  */
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
condition|)
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|system_id
operator|=
name|obj_som_exec_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|system_id
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
operator|==
name|pa20
condition|)
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|system_id
operator|=
name|CPU_PA_RISC2_0
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
operator|==
name|pa11
condition|)
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|system_id
operator|=
name|CPU_PA_RISC1_1
expr_stmt|;
else|else
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|system_id
operator|=
name|CPU_PA_RISC1_0
expr_stmt|;
comment|/* Compute the checksum for the file header just before writing      the header to disk.  */
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|checksum
operator|=
name|som_compute_checksum
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Only thing left to do is write out the file header.  It is always      at location zero.  Seek there and write it.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
comment|/* Now write the exec header.  */
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
condition|)
block|{
name|long
name|tmp
decl_stmt|,
name|som_length
decl_stmt|;
name|struct
name|som_exec_auxhdr
modifier|*
name|exec_header
decl_stmt|;
name|exec_header
operator|=
name|obj_som_exec_hdr
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|exec_header
operator|->
name|exec_entry
operator|=
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|exec_header
operator|->
name|exec_flags
operator|=
name|obj_som_exec_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|exec_flags
expr_stmt|;
comment|/* Oh joys.  Ram some of the BSS data into the DATA section 	 to be compatible with how the hp linker makes objects 	 (saves memory space).  */
name|tmp
operator|=
name|exec_header
operator|->
name|exec_dsize
expr_stmt|;
name|tmp
operator|=
name|SOM_ALIGN
argument_list|(
name|tmp
argument_list|,
name|PA_PAGESIZE
argument_list|)
expr_stmt|;
name|exec_header
operator|->
name|exec_bsize
operator|-=
operator|(
name|tmp
operator|-
name|exec_header
operator|->
name|exec_dsize
operator|)
expr_stmt|;
if|if
condition|(
name|exec_header
operator|->
name|exec_bsize
operator|<
literal|0
condition|)
name|exec_header
operator|->
name|exec_bsize
operator|=
literal|0
expr_stmt|;
name|exec_header
operator|->
name|exec_dsize
operator|=
name|tmp
expr_stmt|;
comment|/* Now perform some sanity checks.  The idea is to catch bogons now and 	 inform the user, instead of silently generating a bogus file.  */
name|som_length
operator|=
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|som_length
expr_stmt|;
if|if
condition|(
name|exec_header
operator|->
name|exec_tfile
operator|+
name|exec_header
operator|->
name|exec_tsize
operator|>
name|som_length
operator|||
name|exec_header
operator|->
name|exec_dfile
operator|+
name|exec_header
operator|->
name|exec_dsize
operator|>
name|som_length
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|aux_header_location
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|amt
operator|=
name|AUX_HDR_SIZE
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|exec_header
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Compute and return the checksum for a SOM file header.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|som_compute_checksum
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|unsigned
name|long
name|checksum
decl_stmt|,
name|count
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|long
modifier|*
name|buffer
init|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
name|count
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|header
argument_list|)
operator|/
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|checksum
operator|^=
operator|*
operator|(
name|buffer
operator|+
name|i
operator|)
expr_stmt|;
return|return
name|checksum
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|som_bfd_derive_misc_symbol_info
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
name|sym
parameter_list|,
name|struct
name|som_misc_symbol_info
modifier|*
name|info
parameter_list|)
block|{
comment|/* Initialize.  */
name|memset
argument_list|(
name|info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|som_misc_symbol_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The HP SOM linker requires detailed type information about      all symbols (including undefined symbols!).  Unfortunately,      the type specified in an import/export statement does not      always match what the linker wants.  Severe braindamage.  */
comment|/* Section symbols will not have a SOM symbol type assigned to      them yet.  Assign all section symbols type ST_DATA.  */
if|if
condition|(
name|sym
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
condition|)
name|info
operator|->
name|symbol_type
operator|=
name|ST_DATA
expr_stmt|;
else|else
block|{
comment|/* For BFD style common, the linker will choke unless we set the 	 type and scope to ST_STORAGE and SS_UNSAT, respectively.  */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
condition|)
block|{
name|info
operator|->
name|symbol_type
operator|=
name|ST_STORAGE
expr_stmt|;
name|info
operator|->
name|symbol_scope
operator|=
name|SS_UNSAT
expr_stmt|;
block|}
comment|/* It is possible to have a symbol without an associated 	 type.  This happens if the user imported the symbol 	 without a type and the symbol was never defined 	 locally.  If BSF_FUNCTION is set for this symbol, then 	 assign it type ST_CODE (the HP linker requires undefined 	 external functions to have type ST_CODE rather than ST_ENTRY).  */
elseif|else
if|if
condition|(
operator|(
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_UNKNOWN
operator|||
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_CODE
operator|)
operator|&&
name|bfd_is_und_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
operator|&&
name|sym
operator|->
name|flags
operator|&
name|BSF_FUNCTION
condition|)
name|info
operator|->
name|symbol_type
operator|=
name|ST_CODE
expr_stmt|;
comment|/* Handle function symbols which were defined in this file. 	 They should have type ST_ENTRY.  Also retrieve the argument 	 relocation bits from the SOM backend information.  */
elseif|else
if|if
condition|(
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_ENTRY
operator|||
operator|(
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_CODE
operator|&&
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_FUNCTION
operator|)
operator|)
operator|||
operator|(
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_UNKNOWN
operator|&&
operator|(
name|sym
operator|->
name|flags
operator|&
name|BSF_FUNCTION
operator|)
operator|)
condition|)
block|{
name|info
operator|->
name|symbol_type
operator|=
name|ST_ENTRY
expr_stmt|;
name|info
operator|->
name|arg_reloc
operator|=
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|tc_data
operator|.
name|ap
operator|.
name|hppa_arg_reloc
expr_stmt|;
name|info
operator|->
name|priv_level
operator|=
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|tc_data
operator|.
name|ap
operator|.
name|hppa_priv_level
expr_stmt|;
block|}
comment|/* For unknown symbols set the symbol's type based on the symbol's 	 section (ST_DATA for DATA sections, ST_CODE for CODE sections).  */
elseif|else
if|if
condition|(
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_UNKNOWN
condition|)
block|{
if|if
condition|(
name|sym
operator|->
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
name|info
operator|->
name|symbol_type
operator|=
name|ST_CODE
expr_stmt|;
else|else
name|info
operator|->
name|symbol_type
operator|=
name|ST_DATA
expr_stmt|;
block|}
comment|/* From now on it's a very simple mapping.  */
elseif|else
if|if
condition|(
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_ABSOLUTE
condition|)
name|info
operator|->
name|symbol_type
operator|=
name|ST_ABSOLUTE
expr_stmt|;
elseif|else
if|if
condition|(
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_CODE
condition|)
name|info
operator|->
name|symbol_type
operator|=
name|ST_CODE
expr_stmt|;
elseif|else
if|if
condition|(
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_DATA
condition|)
name|info
operator|->
name|symbol_type
operator|=
name|ST_DATA
expr_stmt|;
elseif|else
if|if
condition|(
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_MILLICODE
condition|)
name|info
operator|->
name|symbol_type
operator|=
name|ST_MILLICODE
expr_stmt|;
elseif|else
if|if
condition|(
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_PLABEL
condition|)
name|info
operator|->
name|symbol_type
operator|=
name|ST_PLABEL
expr_stmt|;
elseif|else
if|if
condition|(
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_PRI_PROG
condition|)
name|info
operator|->
name|symbol_type
operator|=
name|ST_PRI_PROG
expr_stmt|;
elseif|else
if|if
condition|(
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_SEC_PROG
condition|)
name|info
operator|->
name|symbol_type
operator|=
name|ST_SEC_PROG
expr_stmt|;
block|}
comment|/* Now handle the symbol's scope.  Exported data which is not      in the common section has scope SS_UNIVERSAL.  Note scope      of common symbols was handled earlier!  */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
condition|)
name|info
operator|->
name|symbol_scope
operator|=
name|SS_UNSAT
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|->
name|flags
operator|&
operator|(
name|BSF_EXPORT
operator||
name|BSF_WEAK
operator|)
condition|)
name|info
operator|->
name|symbol_scope
operator|=
name|SS_UNIVERSAL
expr_stmt|;
comment|/* Anything else which is not in the common section has scope      SS_LOCAL.  */
else|else
name|info
operator|->
name|symbol_scope
operator|=
name|SS_LOCAL
expr_stmt|;
comment|/* Now set the symbol_info field.  It has no real meaning      for undefined or common symbols, but the HP linker will      choke if it's not set to some "reasonable" value.  We      use zero as a reasonable value.  */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
operator|||
name|bfd_is_und_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
operator|||
name|bfd_is_abs_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
condition|)
name|info
operator|->
name|symbol_info
operator|=
literal|0
expr_stmt|;
comment|/* For all other symbols, the symbol_info field contains the      subspace index of the space this symbol is contained in.  */
else|else
name|info
operator|->
name|symbol_info
operator|=
name|sym
operator|->
name|section
operator|->
name|target_index
expr_stmt|;
comment|/* Set the symbol's value.  */
name|info
operator|->
name|symbol_value
operator|=
name|sym
operator|->
name|value
operator|+
name|sym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
comment|/* The secondary_def field is for "weak" symbols.  */
if|if
condition|(
name|sym
operator|->
name|flags
operator|&
name|BSF_WEAK
condition|)
name|info
operator|->
name|secondary_def
operator|=
name|TRUE
expr_stmt|;
else|else
name|info
operator|->
name|secondary_def
operator|=
name|FALSE
expr_stmt|;
comment|/* The is_comdat, is_common and dup_common fields provide various      flavors of common.       For data symbols, setting IS_COMMON provides Fortran style common      (duplicate definitions and overlapped initialization).  Setting both      IS_COMMON and DUP_COMMON provides Cobol style common (duplicate      definitions as long as they are all the same length).  In a shared      link data symbols retain their IS_COMMON and DUP_COMMON flags.      An IS_COMDAT data symbol is similar to a IS_COMMON | DUP_COMMON      symbol except in that it loses its IS_COMDAT flag in a shared link.       For code symbols, IS_COMDAT and DUP_COMMON have effect.  Universal      DUP_COMMON code symbols are not exported from shared libraries.      IS_COMDAT symbols are exported but they lose their IS_COMDAT flag.       We take a simplified approach to setting the is_comdat, is_common      and dup_common flags in symbols based on the flag settings of their      subspace.  This avoids having to add directives like `.comdat' but      the linker behavior is probably undefined if there is more than one      universal symbol (comdat key sysmbol) in a subspace.       The behavior of these flags is not well documentmented, so there      may be bugs and some surprising interactions with other flags.  */
if|if
condition|(
name|som_section_data
argument_list|(
name|sym
operator|->
name|section
argument_list|)
operator|&&
name|som_section_data
argument_list|(
name|sym
operator|->
name|section
argument_list|)
operator|->
name|subspace_dict
operator|&&
name|info
operator|->
name|symbol_scope
operator|==
name|SS_UNIVERSAL
operator|&&
operator|(
name|info
operator|->
name|symbol_type
operator|==
name|ST_ENTRY
operator|||
name|info
operator|->
name|symbol_type
operator|==
name|ST_CODE
operator|||
name|info
operator|->
name|symbol_type
operator|==
name|ST_DATA
operator|)
condition|)
block|{
name|info
operator|->
name|is_comdat
operator|=
name|som_section_data
argument_list|(
name|sym
operator|->
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|is_comdat
expr_stmt|;
name|info
operator|->
name|is_common
operator|=
name|som_section_data
argument_list|(
name|sym
operator|->
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|is_common
expr_stmt|;
name|info
operator|->
name|dup_common
operator|=
name|som_section_data
argument_list|(
name|sym
operator|->
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|dup_common
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build and write, in one big chunk, the entire symbol table for    this BFD.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|som_build_and_write_symbol_table
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|unsigned
name|int
name|num_syms
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|file_ptr
name|symtab_location
init|=
name|obj_som_file_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|symbol_location
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|bfd_syms
init|=
name|obj_som_sorted_syms
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|symbol_dictionary_record
modifier|*
name|som_symtab
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_size_type
name|symtab_size
decl_stmt|;
comment|/* Compute total symbol table size and allocate a chunk of memory      to hold the symbol table as we build it.  */
name|symtab_size
operator|=
name|num_syms
expr_stmt|;
name|symtab_size
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_dictionary_record
argument_list|)
expr_stmt|;
name|som_symtab
operator|=
name|bfd_zmalloc
argument_list|(
name|symtab_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|som_symtab
operator|==
name|NULL
operator|&&
name|symtab_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* Walk over each symbol.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_syms
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|som_misc_symbol_info
name|info
decl_stmt|;
comment|/* This is really an index into the symbol strings table. 	 By the time we get here, the index has already been 	 computed and stored into the name field in the BFD symbol.  */
name|som_symtab
index|[
name|i
index|]
operator|.
name|name
operator|.
name|n_strx
operator|=
name|som_symbol_data
argument_list|(
name|bfd_syms
index|[
name|i
index|]
argument_list|)
operator|->
name|stringtab_offset
expr_stmt|;
comment|/* Derive SOM information from the BFD symbol.  */
name|som_bfd_derive_misc_symbol_info
argument_list|(
name|abfd
argument_list|,
name|bfd_syms
index|[
name|i
index|]
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
comment|/* Now use it.  */
name|som_symtab
index|[
name|i
index|]
operator|.
name|symbol_type
operator|=
name|info
operator|.
name|symbol_type
expr_stmt|;
name|som_symtab
index|[
name|i
index|]
operator|.
name|symbol_scope
operator|=
name|info
operator|.
name|symbol_scope
expr_stmt|;
name|som_symtab
index|[
name|i
index|]
operator|.
name|arg_reloc
operator|=
name|info
operator|.
name|arg_reloc
expr_stmt|;
name|som_symtab
index|[
name|i
index|]
operator|.
name|symbol_info
operator|=
name|info
operator|.
name|symbol_info
expr_stmt|;
name|som_symtab
index|[
name|i
index|]
operator|.
name|xleast
operator|=
literal|3
expr_stmt|;
name|som_symtab
index|[
name|i
index|]
operator|.
name|symbol_value
operator|=
name|info
operator|.
name|symbol_value
operator||
name|info
operator|.
name|priv_level
expr_stmt|;
name|som_symtab
index|[
name|i
index|]
operator|.
name|secondary_def
operator|=
name|info
operator|.
name|secondary_def
expr_stmt|;
name|som_symtab
index|[
name|i
index|]
operator|.
name|is_comdat
operator|=
name|info
operator|.
name|is_comdat
expr_stmt|;
name|som_symtab
index|[
name|i
index|]
operator|.
name|is_common
operator|=
name|info
operator|.
name|is_common
expr_stmt|;
name|som_symtab
index|[
name|i
index|]
operator|.
name|dup_common
operator|=
name|info
operator|.
name|dup_common
expr_stmt|;
block|}
comment|/* Everything is ready, seek to the right location and      scribble out the symbol table.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|symtab_location
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|som_symtab
argument_list|,
name|symtab_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|symtab_size
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|som_symtab
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|som_symtab
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|som_symtab
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|som_symtab
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Write an object in SOM format.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|som_write_object_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
operator|!
name|abfd
operator|->
name|output_has_begun
condition|)
block|{
comment|/* Set up fixed parts of the file, space, and subspace headers. 	 Notify the world that output has begun.  */
name|som_prep_headers
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|output_has_begun
operator|=
name|TRUE
expr_stmt|;
comment|/* Start writing the object file.  This include all the string 	 tables, fixup streams, and other portions of the object file.  */
name|som_begin_writing
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
return|return
name|som_finish_writing
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read and save the string table associated with the given BFD.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|som_slurp_string_table
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|char
modifier|*
name|stringtab
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* Use the saved version if its available.  */
if|if
condition|(
name|obj_som_stringtab
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* I don't think this can currently happen, and I'm not sure it should      really be an error, but it's better than getting unpredictable results      from the host's malloc when passed a size of zero.  */
if|if
condition|(
name|obj_som_stringtab_size
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_symbols
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Allocate and read in the string table.  */
name|amt
operator|=
name|obj_som_stringtab_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|stringtab
operator|=
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|stringtab
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_som_str_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_bread
argument_list|(
name|stringtab
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
comment|/* Save our results and return success.  */
name|obj_som_stringtab
argument_list|(
name|abfd
argument_list|)
operator|=
name|stringtab
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return the amount of data (in bytes) required to hold the symbol    table for this object.  */
end_comment

begin_function
specifier|static
name|long
name|som_get_symtab_upper_bound
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
operator|!
name|som_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert from a SOM subspace index to a BFD section.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|bfd_section_from_som_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|symbol_dictionary_record
modifier|*
name|symbol
parameter_list|)
block|{
name|asection
modifier|*
name|section
decl_stmt|;
comment|/* The meaning of the symbol_info field changes for functions      within executables.  So only use the quick symbol_info mapping for      incomplete objects and non-function symbols in executables.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
operator|==
literal|0
operator|||
operator|(
name|symbol
operator|->
name|symbol_type
operator|!=
name|ST_ENTRY
operator|&&
name|symbol
operator|->
name|symbol_type
operator|!=
name|ST_PRI_PROG
operator|&&
name|symbol
operator|->
name|symbol_type
operator|!=
name|ST_SEC_PROG
operator|&&
name|symbol
operator|->
name|symbol_type
operator|!=
name|ST_MILLICODE
operator|)
condition|)
block|{
name|int
name|index
init|=
name|symbol
operator|->
name|symbol_info
decl_stmt|;
for|for
control|(
name|section
operator|=
name|abfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
if|if
condition|(
name|section
operator|->
name|target_index
operator|==
name|index
operator|&&
name|som_is_subspace
argument_list|(
name|section
argument_list|)
condition|)
return|return
name|section
return|;
block|}
else|else
block|{
name|unsigned
name|int
name|value
init|=
name|symbol
operator|->
name|symbol_value
decl_stmt|;
comment|/* For executables we will have to use the symbol's address and 	 find out what section would contain that address.   Yuk.  */
for|for
control|(
name|section
operator|=
name|abfd
operator|->
name|sections
init|;
name|section
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
if|if
condition|(
name|value
operator|>=
name|section
operator|->
name|vma
operator|&&
name|value
operator|<=
name|section
operator|->
name|vma
operator|+
name|section
operator|->
name|size
operator|&&
name|som_is_subspace
argument_list|(
name|section
argument_list|)
condition|)
return|return
name|section
return|;
block|}
comment|/* Could be a symbol from an external library (such as an OMOS      shared library).  Don't abort.  */
return|return
name|bfd_abs_section_ptr
return|;
block|}
end_function

begin_comment
comment|/* Read and save the symbol table associated with the given BFD.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|som_slurp_symbol_table
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|int
name|symbol_count
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|int
name|symsize
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|symbol_dictionary_record
argument_list|)
decl_stmt|;
name|char
modifier|*
name|stringtab
decl_stmt|;
name|struct
name|symbol_dictionary_record
modifier|*
name|buf
init|=
name|NULL
decl_stmt|,
modifier|*
name|bufp
decl_stmt|,
modifier|*
name|endbufp
decl_stmt|;
name|som_symbol_type
modifier|*
name|sym
decl_stmt|,
modifier|*
name|symbase
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* Return saved value if it exists.  */
if|if
condition|(
name|obj_som_symtab
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
condition|)
goto|goto
name|successful_return
goto|;
comment|/* Special case.  This is *not* an error.  */
if|if
condition|(
name|symbol_count
operator|==
literal|0
condition|)
goto|goto
name|successful_return
goto|;
if|if
condition|(
operator|!
name|som_slurp_string_table
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|stringtab
operator|=
name|obj_som_stringtab
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|amt
operator|=
name|symbol_count
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|som_symbol_type
argument_list|)
expr_stmt|;
name|symbase
operator|=
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbase
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* Read in the external SOM representation.  */
name|amt
operator|=
name|symbol_count
expr_stmt|;
name|amt
operator|*=
name|symsize
expr_stmt|;
name|buf
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
operator|&&
name|amt
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_som_sym_filepos
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_bread
argument_list|(
name|buf
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
comment|/* Iterate over all the symbols and internalize them.  */
name|endbufp
operator|=
name|buf
operator|+
name|symbol_count
expr_stmt|;
for|for
control|(
name|bufp
operator|=
name|buf
operator|,
name|sym
operator|=
name|symbase
init|;
name|bufp
operator|<
name|endbufp
condition|;
operator|++
name|bufp
control|)
block|{
comment|/* I don't think we care about these.  */
if|if
condition|(
name|bufp
operator|->
name|symbol_type
operator|==
name|ST_SYM_EXT
operator|||
name|bufp
operator|->
name|symbol_type
operator|==
name|ST_ARG_EXT
condition|)
continue|continue;
comment|/* Set some private data we care about.  */
if|if
condition|(
name|bufp
operator|->
name|symbol_type
operator|==
name|ST_NULL
condition|)
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|=
name|SYMBOL_TYPE_UNKNOWN
expr_stmt|;
elseif|else
if|if
condition|(
name|bufp
operator|->
name|symbol_type
operator|==
name|ST_ABSOLUTE
condition|)
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|=
name|SYMBOL_TYPE_ABSOLUTE
expr_stmt|;
elseif|else
if|if
condition|(
name|bufp
operator|->
name|symbol_type
operator|==
name|ST_DATA
condition|)
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|=
name|SYMBOL_TYPE_DATA
expr_stmt|;
elseif|else
if|if
condition|(
name|bufp
operator|->
name|symbol_type
operator|==
name|ST_CODE
condition|)
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|=
name|SYMBOL_TYPE_CODE
expr_stmt|;
elseif|else
if|if
condition|(
name|bufp
operator|->
name|symbol_type
operator|==
name|ST_PRI_PROG
condition|)
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|=
name|SYMBOL_TYPE_PRI_PROG
expr_stmt|;
elseif|else
if|if
condition|(
name|bufp
operator|->
name|symbol_type
operator|==
name|ST_SEC_PROG
condition|)
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|=
name|SYMBOL_TYPE_SEC_PROG
expr_stmt|;
elseif|else
if|if
condition|(
name|bufp
operator|->
name|symbol_type
operator|==
name|ST_ENTRY
condition|)
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|=
name|SYMBOL_TYPE_ENTRY
expr_stmt|;
elseif|else
if|if
condition|(
name|bufp
operator|->
name|symbol_type
operator|==
name|ST_MILLICODE
condition|)
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|=
name|SYMBOL_TYPE_MILLICODE
expr_stmt|;
elseif|else
if|if
condition|(
name|bufp
operator|->
name|symbol_type
operator|==
name|ST_PLABEL
condition|)
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|=
name|SYMBOL_TYPE_PLABEL
expr_stmt|;
else|else
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|som_type
operator|=
name|SYMBOL_TYPE_UNKNOWN
expr_stmt|;
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|tc_data
operator|.
name|ap
operator|.
name|hppa_arg_reloc
operator|=
name|bufp
operator|->
name|arg_reloc
expr_stmt|;
comment|/* Some reasonable defaults.  */
name|sym
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|name
operator|=
name|bufp
operator|->
name|name
operator|.
name|n_strx
operator|+
name|stringtab
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|value
operator|=
name|bufp
operator|->
name|symbol_value
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|bufp
operator|->
name|symbol_type
condition|)
block|{
case|case
name|ST_ENTRY
case|:
case|case
name|ST_MILLICODE
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|tc_data
operator|.
name|ap
operator|.
name|hppa_priv_level
operator|=
name|sym
operator|->
name|symbol
operator|.
name|value
operator|&
literal|0x3
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|value
operator|&=
operator|~
literal|0x3
expr_stmt|;
break|break;
case|case
name|ST_STUB
case|:
case|case
name|ST_CODE
case|:
case|case
name|ST_PRI_PROG
case|:
case|case
name|ST_SEC_PROG
case|:
name|som_symbol_data
argument_list|(
name|sym
argument_list|)
operator|->
name|tc_data
operator|.
name|ap
operator|.
name|hppa_priv_level
operator|=
name|sym
operator|->
name|symbol
operator|.
name|value
operator|&
literal|0x3
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|value
operator|&=
operator|~
literal|0x3
expr_stmt|;
comment|/* If the symbol's scope is SS_UNSAT, then these are 	     undefined function symbols.  */
if|if
condition|(
name|bufp
operator|->
name|symbol_scope
operator|==
name|SS_UNSAT
condition|)
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
default|default:
break|break;
block|}
comment|/* Handle scoping and section information.  */
switch|switch
condition|(
name|bufp
operator|->
name|symbol_scope
condition|)
block|{
comment|/* symbol_info field is undefined for SS_EXTERNAL and SS_UNSAT symbols, 	   so the section associated with this symbol can't be known.  */
case|case
name|SS_EXTERNAL
case|:
if|if
condition|(
name|bufp
operator|->
name|symbol_type
operator|!=
name|ST_STORAGE
condition|)
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
else|else
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_com_section_ptr
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
operator|(
name|BSF_EXPORT
operator||
name|BSF_GLOBAL
operator|)
expr_stmt|;
break|break;
case|case
name|SS_UNSAT
case|:
if|if
condition|(
name|bufp
operator|->
name|symbol_type
operator|!=
name|ST_STORAGE
condition|)
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
else|else
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_com_section_ptr
expr_stmt|;
break|break;
case|case
name|SS_UNIVERSAL
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
operator|(
name|BSF_EXPORT
operator||
name|BSF_GLOBAL
operator|)
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_section_from_som_symbol
argument_list|(
name|abfd
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|value
operator|-=
name|sym
operator|->
name|symbol
operator|.
name|section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|SS_LOCAL
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_LOCAL
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_section_from_som_symbol
argument_list|(
name|abfd
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|value
operator|-=
name|sym
operator|->
name|symbol
operator|.
name|section
operator|->
name|vma
expr_stmt|;
break|break;
block|}
comment|/* Check for a weak symbol.  */
if|if
condition|(
name|bufp
operator|->
name|secondary_def
condition|)
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_WEAK
expr_stmt|;
comment|/* Mark section symbols and symbols used by the debugger. 	 Note $START$ is a magic code symbol, NOT a section symbol.  */
if|if
condition|(
name|sym
operator|->
name|symbol
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|sym
operator|->
name|symbol
operator|.
name|name
index|[
name|strlen
argument_list|(
name|sym
operator|->
name|symbol
operator|.
name|name
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'$'
operator|&&
operator|!
name|strcmp
argument_list|(
name|sym
operator|->
name|symbol
operator|.
name|name
argument_list|,
name|sym
operator|->
name|symbol
operator|.
name|section
operator|->
name|name
argument_list|)
condition|)
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_SECTION_SYM
expr_stmt|;
elseif|else
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|sym
operator|->
name|symbol
operator|.
name|name
argument_list|,
literal|"L$0\002"
argument_list|)
condition|)
block|{
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_SECTION_SYM
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|name
operator|=
name|sym
operator|->
name|symbol
operator|.
name|section
operator|->
name|name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|sym
operator|->
name|symbol
operator|.
name|name
argument_list|,
literal|"L$0\001"
argument_list|)
condition|)
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_DEBUGGING
expr_stmt|;
comment|/* Note increment at bottom of loop, since we skip some symbols 	 we can not include it as part of the for statement.  */
name|sym
operator|++
expr_stmt|;
block|}
comment|/* We modify the symbol count to record the number of BFD symbols we      created.  */
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|sym
operator|-
name|symbase
expr_stmt|;
comment|/* Save our results and return success.  */
name|obj_som_symtab
argument_list|(
name|abfd
argument_list|)
operator|=
name|symbase
expr_stmt|;
name|successful_return
label|:
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
name|error_return
label|:
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Canonicalize a SOM symbol table.  Return the number of entries    in the symbol table.  */
end_comment

begin_function
specifier|static
name|long
name|som_canonicalize_symtab
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|location
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|som_symbol_type
modifier|*
name|symbase
decl_stmt|;
if|if
condition|(
operator|!
name|som_slurp_symbol_table
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|i
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|symbase
operator|=
name|obj_som_symtab
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|location
operator|++
operator|,
name|symbase
operator|++
control|)
operator|*
name|location
operator|=
operator|&
name|symbase
operator|->
name|symbol
expr_stmt|;
comment|/* Final null pointer.  */
operator|*
name|location
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Make a SOM symbol.  There is nothing special to do here.  */
end_comment

begin_function
specifier|static
name|asymbol
modifier|*
name|som_make_empty_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|som_symbol_type
argument_list|)
decl_stmt|;
name|som_symbol_type
modifier|*
name|new
init|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|new
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
operator|&
name|new
operator|->
name|symbol
return|;
block|}
end_function

begin_comment
comment|/* Print symbol information.  */
end_comment

begin_function
specifier|static
name|void
name|som_print_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|void
modifier|*
name|afile
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|bfd_print_symbol_type
name|how
parameter_list|)
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|afile
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_more
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"som "
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
name|symbol
operator|->
name|value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %lx"
argument_list|,
operator|(
name|long
operator|)
name|symbol
operator|->
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_all
case|:
block|{
specifier|const
name|char
modifier|*
name|section_name
decl_stmt|;
name|section_name
operator|=
name|symbol
operator|->
name|section
condition|?
name|symbol
operator|->
name|section
operator|->
name|name
else|:
literal|"(*none*)"
expr_stmt|;
name|bfd_print_symbol_vandf
argument_list|(
name|abfd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s\t%s"
argument_list|,
name|section_name
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|som_bfd_is_local_label_name
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|name
index|[
literal|0
index|]
operator|==
literal|'L'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'$'
return|;
block|}
end_function

begin_comment
comment|/* Count or process variable-length SOM fixup records.     To avoid code duplication we use this code both to compute the number    of relocations requested by a stream, and to internalize the stream.     When computing the number of relocations requested by a stream the    variables rptr, section, and symbols have no meaning.     Return the number of relocations requested by the fixup stream.  When    not just counting     This needs at least two or three more passes to get it cleaned up.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|som_set_reloc_info
parameter_list|(
name|unsigned
name|char
modifier|*
name|fixup
parameter_list|,
name|unsigned
name|int
name|end
parameter_list|,
name|arelent
modifier|*
name|internal_relocs
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|,
name|bfd_boolean
name|just_count
parameter_list|)
block|{
name|unsigned
name|int
name|op
decl_stmt|,
name|varname
decl_stmt|,
name|deallocate_contents
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end_fixups
init|=
operator|&
name|fixup
index|[
name|end
index|]
decl_stmt|;
specifier|const
name|struct
name|fixup_format
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|save_fixup
decl_stmt|;
name|int
name|variables
index|[
literal|26
index|]
decl_stmt|,
name|stack
index|[
literal|20
index|]
decl_stmt|,
name|c
decl_stmt|,
name|v
decl_stmt|,
name|count
decl_stmt|,
name|prev_fixup
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
name|saved_unwind_bits
decl_stmt|;
specifier|const
name|int
modifier|*
name|subop
decl_stmt|;
name|arelent
modifier|*
name|rptr
init|=
name|internal_relocs
decl_stmt|;
name|unsigned
name|int
name|offset
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|var
parameter_list|(
name|c
parameter_list|)
value|variables[(c) - 'A']
define|#
directive|define
name|push
parameter_list|(
name|v
parameter_list|)
value|(*sp++ = (v))
define|#
directive|define
name|pop
parameter_list|()
value|(*--sp)
define|#
directive|define
name|emptystack
parameter_list|()
value|(sp == stack)
name|som_initialize_reloc_queue
argument_list|(
name|reloc_queue
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|variables
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|variables
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|stack
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stack
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|prev_fixup
operator|=
literal|0
expr_stmt|;
name|saved_unwind_bits
operator|=
literal|0
expr_stmt|;
name|sp
operator|=
name|stack
expr_stmt|;
while|while
condition|(
name|fixup
operator|<
name|end_fixups
condition|)
block|{
comment|/* Save pointer to the start of this fixup.  We'll use 	 it later to determine if it is necessary to put this fixup 	 on the queue.  */
name|save_fixup
operator|=
name|fixup
expr_stmt|;
comment|/* Get the fixup code and its associated format.  */
name|op
operator|=
operator|*
name|fixup
operator|++
expr_stmt|;
name|fp
operator|=
operator|&
name|som_fixup_formats
index|[
name|op
index|]
expr_stmt|;
comment|/* Handle a request for a previous fixup.  */
if|if
condition|(
operator|*
name|fp
operator|->
name|format
operator|==
literal|'P'
condition|)
block|{
comment|/* Get pointer to the beginning of the prev fixup, move 	     the repeated fixup to the head of the queue.  */
name|fixup
operator|=
name|reloc_queue
index|[
name|fp
operator|->
name|D
index|]
operator|.
name|reloc
expr_stmt|;
name|som_reloc_queue_fix
argument_list|(
name|reloc_queue
argument_list|,
name|fp
operator|->
name|D
argument_list|)
expr_stmt|;
name|prev_fixup
operator|=
literal|1
expr_stmt|;
comment|/* Get the fixup code and its associated format.  */
name|op
operator|=
operator|*
name|fixup
operator|++
expr_stmt|;
name|fp
operator|=
operator|&
name|som_fixup_formats
index|[
name|op
index|]
expr_stmt|;
block|}
comment|/* If this fixup will be passed to BFD, set some reasonable defaults.  */
if|if
condition|(
operator|!
name|just_count
operator|&&
name|som_hppa_howto_table
index|[
name|op
index|]
operator|.
name|type
operator|!=
name|R_NO_RELOCATION
operator|&&
name|som_hppa_howto_table
index|[
name|op
index|]
operator|.
name|type
operator|!=
name|R_DATA_OVERRIDE
condition|)
block|{
name|rptr
operator|->
name|address
operator|=
name|offset
expr_stmt|;
name|rptr
operator|->
name|howto
operator|=
operator|&
name|som_hppa_howto_table
index|[
name|op
index|]
expr_stmt|;
name|rptr
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
name|rptr
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
block|}
comment|/* Set default input length to 0.  Get the opcode class index 	 into D.  */
name|var
argument_list|(
literal|'L'
argument_list|)
operator|=
literal|0
expr_stmt|;
name|var
argument_list|(
literal|'D'
argument_list|)
operator|=
name|fp
operator|->
name|D
expr_stmt|;
name|var
argument_list|(
literal|'U'
argument_list|)
operator|=
name|saved_unwind_bits
expr_stmt|;
comment|/* Get the opcode format.  */
name|cp
operator|=
name|fp
operator|->
name|format
expr_stmt|;
comment|/* Process the format string.  Parsing happens in two phases, 	 parse RHS, then assign to LHS.  Repeat until no more 	 characters in the format string.  */
while|while
condition|(
operator|*
name|cp
condition|)
block|{
comment|/* The variable this pass is going to compute a value for.  */
name|varname
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
comment|/* Start processing RHS.  Continue until a NULL or '=' is found.  */
do|do
block|{
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
comment|/* If this is a variable, push it on the stack.  */
if|if
condition|(
name|ISUPPER
argument_list|(
name|c
argument_list|)
condition|)
name|push
argument_list|(
name|var
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is a lower case letter, then it represents 		 additional data from the fixup stream to be pushed onto 		 the stack.  */
elseif|else
if|if
condition|(
name|ISLOWER
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|int
name|bits
init|=
operator|(
name|c
operator|-
literal|'a'
operator|)
operator|*
literal|8
decl_stmt|;
for|for
control|(
name|v
operator|=
literal|0
init|;
name|c
operator|>
literal|'a'
condition|;
operator|--
name|c
control|)
name|v
operator|=
operator|(
name|v
operator|<<
literal|8
operator|)
operator||
operator|*
name|fixup
operator|++
expr_stmt|;
if|if
condition|(
name|varname
operator|==
literal|'V'
condition|)
name|v
operator|=
name|sign_extend
argument_list|(
name|v
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
comment|/* A decimal constant.  Push it on the stack.  */
elseif|else
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|v
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|v
operator|=
operator|(
name|v
operator|*
literal|10
operator|)
operator|+
operator|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
name|push
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* An operator.  Pop two two values from the stack and 		   use them as operands to the given operation.  Push 		   the result of the operation back on the stack.  */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'+'
case|:
name|v
operator|=
name|pop
argument_list|()
expr_stmt|;
name|v
operator|+=
name|pop
argument_list|()
expr_stmt|;
name|push
argument_list|(
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|v
operator|=
name|pop
argument_list|()
expr_stmt|;
name|v
operator|*=
name|pop
argument_list|()
expr_stmt|;
name|push
argument_list|(
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|v
operator|=
name|pop
argument_list|()
expr_stmt|;
name|v
operator|=
name|pop
argument_list|()
operator|<<
name|v
expr_stmt|;
name|push
argument_list|(
name|v
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|'='
condition|)
do|;
comment|/* Move over the equal operator.  */
name|cp
operator|++
expr_stmt|;
comment|/* Pop the RHS off the stack.  */
name|c
operator|=
name|pop
argument_list|()
expr_stmt|;
comment|/* Perform the assignment.  */
name|var
argument_list|(
name|varname
argument_list|)
operator|=
name|c
expr_stmt|;
comment|/* Handle side effects. and special 'O' stack cases.  */
switch|switch
condition|(
name|varname
condition|)
block|{
comment|/* Consume some bytes from the input space.  */
case|case
literal|'L'
case|:
name|offset
operator|+=
name|c
expr_stmt|;
break|break;
comment|/* A symbol to use in the relocation.  Make a note 	       of this if we are not just counting.  */
case|case
literal|'S'
case|:
if|if
condition|(
operator|!
name|just_count
condition|)
name|rptr
operator|->
name|sym_ptr_ptr
operator|=
operator|&
name|symbols
index|[
name|c
index|]
expr_stmt|;
break|break;
comment|/* Argument relocation bits for a function call.  */
case|case
literal|'R'
case|:
if|if
condition|(
operator|!
name|just_count
condition|)
block|{
name|unsigned
name|int
name|tmp
init|=
name|var
argument_list|(
literal|'R'
argument_list|)
decl_stmt|;
name|rptr
operator|->
name|addend
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|som_hppa_howto_table
index|[
name|op
index|]
operator|.
name|type
operator|==
name|R_PCREL_CALL
operator|&&
name|R_PCREL_CALL
operator|+
literal|10
operator|>
name|op
operator|)
operator|||
operator|(
name|som_hppa_howto_table
index|[
name|op
index|]
operator|.
name|type
operator|==
name|R_ABS_CALL
operator|&&
name|R_ABS_CALL
operator|+
literal|10
operator|>
name|op
operator|)
condition|)
block|{
comment|/* Simple encoding.  */
if|if
condition|(
name|tmp
operator|>
literal|4
condition|)
block|{
name|tmp
operator|-=
literal|5
expr_stmt|;
name|rptr
operator|->
name|addend
operator||=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|==
literal|4
condition|)
name|rptr
operator|->
name|addend
operator||=
literal|1
operator|<<
literal|8
operator||
literal|1
operator|<<
literal|6
operator||
literal|1
operator|<<
literal|4
operator||
literal|1
operator|<<
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|==
literal|3
condition|)
name|rptr
operator|->
name|addend
operator||=
literal|1
operator|<<
literal|8
operator||
literal|1
operator|<<
literal|6
operator||
literal|1
operator|<<
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|==
literal|2
condition|)
name|rptr
operator|->
name|addend
operator||=
literal|1
operator|<<
literal|8
operator||
literal|1
operator|<<
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|==
literal|1
condition|)
name|rptr
operator|->
name|addend
operator||=
literal|1
operator|<<
literal|8
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
comment|/* First part is easy -- low order two bits are 			 directly copied, then shifted away.  */
name|rptr
operator|->
name|addend
operator|=
name|tmp
operator|&
literal|0x3
expr_stmt|;
name|tmp
operator|>>=
literal|2
expr_stmt|;
comment|/* Diving the result by 10 gives us the second 			 part.  If it is 9, then the first two words 			 are a double precision paramater, else it is 			 3 * the first arg bits + the 2nd arg bits.  */
name|tmp1
operator|=
name|tmp
operator|/
literal|10
expr_stmt|;
name|tmp
operator|-=
name|tmp1
operator|*
literal|10
expr_stmt|;
if|if
condition|(
name|tmp1
operator|==
literal|9
condition|)
name|rptr
operator|->
name|addend
operator|+=
operator|(
literal|0xe
operator|<<
literal|6
operator|)
expr_stmt|;
else|else
block|{
comment|/* Get the two pieces.  */
name|tmp2
operator|=
name|tmp1
operator|/
literal|3
expr_stmt|;
name|tmp1
operator|-=
name|tmp2
operator|*
literal|3
expr_stmt|;
comment|/* Put them in the addend.  */
name|rptr
operator|->
name|addend
operator|+=
operator|(
name|tmp2
operator|<<
literal|8
operator|)
operator|+
operator|(
name|tmp1
operator|<<
literal|6
operator|)
expr_stmt|;
block|}
comment|/* What's left is the third part.  It's unpacked 			 just like the second.  */
if|if
condition|(
name|tmp
operator|==
literal|9
condition|)
name|rptr
operator|->
name|addend
operator|+=
operator|(
literal|0xe
operator|<<
literal|2
operator|)
expr_stmt|;
else|else
block|{
name|tmp2
operator|=
name|tmp
operator|/
literal|3
expr_stmt|;
name|tmp
operator|-=
name|tmp2
operator|*
literal|3
expr_stmt|;
name|rptr
operator|->
name|addend
operator|+=
operator|(
name|tmp2
operator|<<
literal|4
operator|)
operator|+
operator|(
name|tmp
operator|<<
literal|2
operator|)
expr_stmt|;
block|}
block|}
name|rptr
operator|->
name|addend
operator|=
name|HPPA_R_ADDEND
argument_list|(
name|rptr
operator|->
name|addend
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Handle the linker expression stack.  */
case|case
literal|'O'
case|:
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|R_COMP1
case|:
name|subop
operator|=
name|comp1_opcodes
expr_stmt|;
break|break;
case|case
name|R_COMP2
case|:
name|subop
operator|=
name|comp2_opcodes
expr_stmt|;
break|break;
case|case
name|R_COMP3
case|:
name|subop
operator|=
name|comp3_opcodes
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|subop
operator|<=
operator|(
name|unsigned
name|char
operator|)
name|c
condition|)
operator|++
name|subop
expr_stmt|;
operator|--
name|subop
expr_stmt|;
break|break;
comment|/* The lower 32unwind bits must be persistent.  */
case|case
literal|'U'
case|:
name|saved_unwind_bits
operator|=
name|var
argument_list|(
literal|'U'
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* If we used a previous fixup, clean up after it.  */
if|if
condition|(
name|prev_fixup
condition|)
block|{
name|fixup
operator|=
name|save_fixup
operator|+
literal|1
expr_stmt|;
name|prev_fixup
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Queue it.  */
elseif|else
if|if
condition|(
name|fixup
operator|>
name|save_fixup
operator|+
literal|1
condition|)
name|som_reloc_queue_insert
argument_list|(
name|save_fixup
argument_list|,
name|fixup
operator|-
name|save_fixup
argument_list|,
name|reloc_queue
argument_list|)
expr_stmt|;
comment|/* We do not pass R_DATA_OVERRIDE or R_NO_RELOCATION 	 fixups to BFD.  */
if|if
condition|(
name|som_hppa_howto_table
index|[
name|op
index|]
operator|.
name|type
operator|!=
name|R_DATA_OVERRIDE
operator|&&
name|som_hppa_howto_table
index|[
name|op
index|]
operator|.
name|type
operator|!=
name|R_NO_RELOCATION
condition|)
block|{
comment|/* Done with a single reloction. Loop back to the top.  */
if|if
condition|(
operator|!
name|just_count
condition|)
block|{
if|if
condition|(
name|som_hppa_howto_table
index|[
name|op
index|]
operator|.
name|type
operator|==
name|R_ENTRY
condition|)
name|rptr
operator|->
name|addend
operator|=
name|var
argument_list|(
literal|'T'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|som_hppa_howto_table
index|[
name|op
index|]
operator|.
name|type
operator|==
name|R_EXIT
condition|)
name|rptr
operator|->
name|addend
operator|=
name|var
argument_list|(
literal|'U'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|som_hppa_howto_table
index|[
name|op
index|]
operator|.
name|type
operator|==
name|R_PCREL_CALL
operator|||
name|som_hppa_howto_table
index|[
name|op
index|]
operator|.
name|type
operator|==
name|R_ABS_CALL
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|som_hppa_howto_table
index|[
name|op
index|]
operator|.
name|type
operator|==
name|R_DATA_ONE_SYMBOL
condition|)
block|{
comment|/* Try what was specified in R_DATA_OVERRIDE first 		     (if anything).  Then the hard way using the 		     section contents.  */
name|rptr
operator|->
name|addend
operator|=
name|var
argument_list|(
literal|'V'
argument_list|)
expr_stmt|;
if|if
condition|(
name|rptr
operator|->
name|addend
operator|==
literal|0
operator|&&
operator|!
name|section
operator|->
name|contents
condition|)
block|{
comment|/* Got to read the damn contents first.  We don't 			 bother saving the contents (yet).  Add it one 			 day if the need arises.  */
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|section
operator|->
name|owner
argument_list|,
name|section
argument_list|,
operator|&
name|contents
argument_list|)
condition|)
block|{
if|if
condition|(
name|contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
operator|(
name|unsigned
operator|)
operator|-
literal|1
return|;
block|}
name|section
operator|->
name|contents
operator|=
name|contents
expr_stmt|;
name|deallocate_contents
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rptr
operator|->
name|addend
operator|==
literal|0
condition|)
name|rptr
operator|->
name|addend
operator|=
name|bfd_get_32
argument_list|(
name|section
operator|->
name|owner
argument_list|,
operator|(
name|section
operator|->
name|contents
operator|+
name|offset
operator|-
name|var
argument_list|(
literal|'L'
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|rptr
operator|->
name|addend
operator|=
name|var
argument_list|(
literal|'V'
argument_list|)
expr_stmt|;
name|rptr
operator|++
expr_stmt|;
block|}
name|count
operator|++
expr_stmt|;
comment|/* Now that we've handled a "full" relocation, reset 	     some state.  */
name|memset
argument_list|(
name|variables
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|variables
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|stack
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stack
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|deallocate_contents
condition|)
name|free
argument_list|(
name|section
operator|->
name|contents
argument_list|)
expr_stmt|;
return|return
name|count
return|;
undef|#
directive|undef
name|var
undef|#
directive|undef
name|push
undef|#
directive|undef
name|pop
undef|#
directive|undef
name|emptystack
block|}
end_function

begin_comment
comment|/* Read in the relocs (aka fixups in SOM terms) for a section.     som_get_reloc_upper_bound calls this routine with JUST_COUNT    set to TRUE to indicate it only needs a count of the number    of actual relocations.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|som_slurp_reloc_table
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|,
name|bfd_boolean
name|just_count
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|external_relocs
decl_stmt|;
name|unsigned
name|int
name|fixup_stream_size
decl_stmt|;
name|arelent
modifier|*
name|internal_relocs
decl_stmt|;
name|unsigned
name|int
name|num_relocs
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|fixup_stream_size
operator|=
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|reloc_size
expr_stmt|;
comment|/* If there were no relocations, then there is nothing to do.  */
if|if
condition|(
name|section
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* If reloc_count is -1, then the relocation stream has not been      parsed.  We must do so now to know how many relocations exist.  */
if|if
condition|(
name|section
operator|->
name|reloc_count
operator|==
operator|(
name|unsigned
operator|)
operator|-
literal|1
condition|)
block|{
name|amt
operator|=
name|fixup_stream_size
expr_stmt|;
name|external_relocs
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|external_relocs
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Read in the external forms.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|obj_som_reloc_filepos
argument_list|(
name|abfd
argument_list|)
operator|+
name|section
operator|->
name|rel_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_bread
argument_list|(
name|external_relocs
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
comment|/* Let callers know how many relocations found. 	 also save the relocation stream as we will 	 need it again.  */
name|section
operator|->
name|reloc_count
operator|=
name|som_set_reloc_info
argument_list|(
name|external_relocs
argument_list|,
name|fixup_stream_size
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|reloc_stream
operator|=
name|external_relocs
expr_stmt|;
block|}
comment|/* If the caller only wanted a count, then return now.  */
if|if
condition|(
name|just_count
condition|)
return|return
name|TRUE
return|;
name|num_relocs
operator|=
name|section
operator|->
name|reloc_count
expr_stmt|;
name|external_relocs
operator|=
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|reloc_stream
expr_stmt|;
comment|/* Return saved information about the relocations if it is available.  */
if|if
condition|(
name|section
operator|->
name|relocation
operator|!=
name|NULL
condition|)
return|return
name|TRUE
return|;
name|amt
operator|=
name|num_relocs
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
expr_stmt|;
name|internal_relocs
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|amt
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Process and internalize the relocations.  */
name|som_set_reloc_info
argument_list|(
name|external_relocs
argument_list|,
name|fixup_stream_size
argument_list|,
name|internal_relocs
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* We're done with the external relocations.  Free them.  */
name|free
argument_list|(
name|external_relocs
argument_list|)
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|reloc_stream
operator|=
name|NULL
expr_stmt|;
comment|/* Save our results and return success.  */
name|section
operator|->
name|relocation
operator|=
name|internal_relocs
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return the number of bytes required to store the relocation    information associated with the given section.  */
end_comment

begin_function
specifier|static
name|long
name|som_get_reloc_upper_bound
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|sec_ptr
name|asect
parameter_list|)
block|{
comment|/* If section has relocations, then read in the relocation stream      and parse it to determine how many relocations exist.  */
if|if
condition|(
name|asect
operator|->
name|flags
operator|&
name|SEC_RELOC
condition|)
block|{
if|if
condition|(
operator|!
name|som_slurp_reloc_table
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|asect
operator|->
name|reloc_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
return|;
block|}
comment|/* There are no relocations.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Convert relocations from SOM (external) form into BFD internal    form.  Return the number of relocations.  */
end_comment

begin_function
specifier|static
name|long
name|som_canonicalize_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|sec_ptr
name|section
parameter_list|,
name|arelent
modifier|*
modifier|*
name|relptr
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|)
block|{
name|arelent
modifier|*
name|tblptr
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
operator|!
name|som_slurp_reloc_table
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|count
operator|=
name|section
operator|->
name|reloc_count
expr_stmt|;
name|tblptr
operator|=
name|section
operator|->
name|relocation
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
operator|*
name|relptr
operator|++
operator|=
name|tblptr
operator|++
expr_stmt|;
operator|*
name|relptr
operator|=
name|NULL
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
name|som_vec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A hook to set up object file dependent section information.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|som_new_section_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|newsect
parameter_list|)
block|{
if|if
condition|(
operator|!
name|newsect
operator|->
name|used_by_bfd
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|som_section_data_struct
argument_list|)
decl_stmt|;
name|newsect
operator|->
name|used_by_bfd
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newsect
operator|->
name|used_by_bfd
condition|)
return|return
name|FALSE
return|;
block|}
name|newsect
operator|->
name|alignment_power
operator|=
literal|3
expr_stmt|;
comment|/* We allow more than three sections internally.  */
return|return
name|_bfd_generic_new_section_hook
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Copy any private info we understand from the input symbol    to the output symbol.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|som_bfd_copy_private_symbol_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|asymbol
modifier|*
name|isymbol
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|,
name|asymbol
modifier|*
name|osymbol
parameter_list|)
block|{
name|struct
name|som_symbol
modifier|*
name|input_symbol
init|=
operator|(
expr|struct
name|som_symbol
operator|*
operator|)
name|isymbol
decl_stmt|;
name|struct
name|som_symbol
modifier|*
name|output_symbol
init|=
operator|(
expr|struct
name|som_symbol
operator|*
operator|)
name|osymbol
decl_stmt|;
comment|/* One day we may try to grok other private data.  */
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_som_flavour
operator|||
name|obfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_som_flavour
condition|)
return|return
name|FALSE
return|;
comment|/* The only private information we need to copy is the argument relocation      bits.  */
name|output_symbol
operator|->
name|tc_data
operator|.
name|ap
operator|.
name|hppa_arg_reloc
operator|=
name|input_symbol
operator|->
name|tc_data
operator|.
name|ap
operator|.
name|hppa_arg_reloc
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Copy any private info we understand from the input section    to the output section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|som_bfd_copy_private_section_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|asection
modifier|*
name|isection
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|,
name|asection
modifier|*
name|osection
parameter_list|)
block|{
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* One day we may try to grok other private data.  */
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_som_flavour
operator|||
name|obfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_som_flavour
operator|||
operator|(
operator|!
name|som_is_space
argument_list|(
name|isection
argument_list|)
operator|&&
operator|!
name|som_is_subspace
argument_list|(
name|isection
argument_list|)
operator|)
condition|)
return|return
name|TRUE
return|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|som_copyable_section_data_struct
argument_list|)
expr_stmt|;
name|som_section_data
argument_list|(
name|osection
argument_list|)
operator|->
name|copy_data
operator|=
name|bfd_zalloc
argument_list|(
name|obfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|som_section_data
argument_list|(
name|osection
argument_list|)
operator|->
name|copy_data
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
name|som_section_data
argument_list|(
name|osection
argument_list|)
operator|->
name|copy_data
argument_list|,
name|som_section_data
argument_list|(
name|isection
argument_list|)
operator|->
name|copy_data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|som_copyable_section_data_struct
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Reparent if necessary.  */
if|if
condition|(
name|som_section_data
argument_list|(
name|osection
argument_list|)
operator|->
name|copy_data
operator|->
name|container
condition|)
name|som_section_data
argument_list|(
name|osection
argument_list|)
operator|->
name|copy_data
operator|->
name|container
operator|=
name|som_section_data
argument_list|(
name|osection
argument_list|)
operator|->
name|copy_data
operator|->
name|container
operator|->
name|output_section
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Copy any private info we understand from the input bfd    to the output bfd.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|som_bfd_copy_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
comment|/* One day we may try to grok other private data.  */
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_som_flavour
operator|||
name|obfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_som_flavour
condition|)
return|return
name|TRUE
return|;
comment|/* Allocate some memory to hold the data we need.  */
name|obj_som_exec_data
argument_list|(
name|obfd
argument_list|)
operator|=
name|bfd_zalloc
argument_list|(
name|obfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|som_exec_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj_som_exec_data
argument_list|(
name|obfd
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Now copy the data.  */
name|memcpy
argument_list|(
name|obj_som_exec_data
argument_list|(
name|obfd
argument_list|)
argument_list|,
name|obj_som_exec_data
argument_list|(
name|ibfd
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|som_exec_data
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Display the SOM header.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|som_bfd_print_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|void
modifier|*
name|farg
parameter_list|)
block|{
name|struct
name|som_exec_auxhdr
modifier|*
name|exec_header
decl_stmt|;
name|struct
name|aux_id
modifier|*
name|auxhdr
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|f
operator|=
operator|(
name|FILE
operator|*
operator|)
name|farg
expr_stmt|;
name|exec_header
operator|=
name|obj_som_exec_hdr
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_header
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\nExec Auxiliary Header\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"  flags              "
argument_list|)
expr_stmt|;
name|auxhdr
operator|=
operator|&
name|exec_header
operator|->
name|som_auxhdr
expr_stmt|;
if|if
condition|(
name|auxhdr
operator|->
name|mandatory
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"mandatory "
argument_list|)
expr_stmt|;
if|if
condition|(
name|auxhdr
operator|->
name|copy
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"copy "
argument_list|)
expr_stmt|;
if|if
condition|(
name|auxhdr
operator|->
name|append
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"append "
argument_list|)
expr_stmt|;
if|if
condition|(
name|auxhdr
operator|->
name|ignore
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"ignore "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"  type               %#x\n"
argument_list|,
name|auxhdr
operator|->
name|type
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"  length             %#x\n"
argument_list|,
name|auxhdr
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* Note that, depending on the HP-UX version, the following fields can be          either ints, or longs.  */
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"  text size          %#lx\n"
argument_list|,
operator|(
name|long
operator|)
name|exec_header
operator|->
name|exec_tsize
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"  text memory offset %#lx\n"
argument_list|,
operator|(
name|long
operator|)
name|exec_header
operator|->
name|exec_tmem
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"  text file offset   %#lx\n"
argument_list|,
operator|(
name|long
operator|)
name|exec_header
operator|->
name|exec_tfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"  data size          %#lx\n"
argument_list|,
operator|(
name|long
operator|)
name|exec_header
operator|->
name|exec_dsize
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"  data memory offset %#lx\n"
argument_list|,
operator|(
name|long
operator|)
name|exec_header
operator|->
name|exec_dmem
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"  data file offset   %#lx\n"
argument_list|,
operator|(
name|long
operator|)
name|exec_header
operator|->
name|exec_dfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"  bss size           %#lx\n"
argument_list|,
operator|(
name|long
operator|)
name|exec_header
operator|->
name|exec_bsize
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"  entry point        %#lx\n"
argument_list|,
operator|(
name|long
operator|)
name|exec_header
operator|->
name|exec_entry
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"  loader flags       %#lx\n"
argument_list|,
operator|(
name|long
operator|)
name|exec_header
operator|->
name|exec_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"  bss initializer    %#lx\n"
argument_list|,
operator|(
name|long
operator|)
name|exec_header
operator|->
name|exec_bfill
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set backend info for sections which can not be described    in the BFD data structures.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_som_set_section_attributes
parameter_list|(
name|asection
modifier|*
name|section
parameter_list|,
name|int
name|defined
parameter_list|,
name|int
name|private
parameter_list|,
name|unsigned
name|int
name|sort_key
parameter_list|,
name|int
name|spnum
parameter_list|)
block|{
comment|/* Allocate memory to hold the magic information.  */
if|if
condition|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|som_copyable_section_data_struct
argument_list|)
decl_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|=
name|bfd_zalloc
argument_list|(
name|section
operator|->
name|owner
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|sort_key
operator|=
name|sort_key
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|is_defined
operator|=
name|defined
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|is_private
operator|=
name|private
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|container
operator|=
name|section
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|space_number
operator|=
name|spnum
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set backend info for subsections which can not be described    in the BFD data structures.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_som_set_subsection_attributes
parameter_list|(
name|asection
modifier|*
name|section
parameter_list|,
name|asection
modifier|*
name|container
parameter_list|,
name|int
name|access
parameter_list|,
name|unsigned
name|int
name|sort_key
parameter_list|,
name|int
name|quadrant
parameter_list|,
name|int
name|comdat
parameter_list|,
name|int
name|common
parameter_list|,
name|int
name|dup_common
parameter_list|)
block|{
comment|/* Allocate memory to hold the magic information.  */
if|if
condition|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|som_copyable_section_data_struct
argument_list|)
decl_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|=
name|bfd_zalloc
argument_list|(
name|section
operator|->
name|owner
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|sort_key
operator|=
name|sort_key
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|access_control_bits
operator|=
name|access
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|quadrant
operator|=
name|quadrant
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|container
operator|=
name|container
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|is_comdat
operator|=
name|comdat
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|is_common
operator|=
name|common
expr_stmt|;
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|copy_data
operator|->
name|dup_common
operator|=
name|dup_common
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the full SOM symbol type.  SOM needs far more symbol information    than any other object file format I'm aware of.  It is mandatory    to be able to know if a symbol is an entry point, millicode, data,    code, absolute, storage request, or procedure label.  If you get    the symbol type wrong your program will not link.  */
end_comment

begin_function
name|void
name|bfd_som_set_symbol_type
parameter_list|(
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|unsigned
name|int
name|type
parameter_list|)
block|{
name|som_symbol_data
argument_list|(
name|symbol
argument_list|)
operator|->
name|som_type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attach an auxiliary header to the BFD backend so that it may be    written into the object file.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_som_attach_aux_hdr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|int
name|type
parameter_list|,
name|char
modifier|*
name|string
parameter_list|)
block|{
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|VERSION_AUX_ID
condition|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|pad
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|len
operator|%
literal|4
condition|)
name|pad
operator|=
operator|(
literal|4
operator|-
operator|(
name|len
operator|%
literal|4
operator|)
operator|)
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aux_id
argument_list|)
operator|+
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
operator|+
name|len
operator|+
name|pad
expr_stmt|;
name|obj_som_version_hdr
argument_list|(
name|abfd
argument_list|)
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj_som_version_hdr
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|obj_som_version_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|header_id
operator|.
name|type
operator|=
name|VERSION_AUX_ID
expr_stmt|;
name|obj_som_version_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|header_id
operator|.
name|length
operator|=
name|len
operator|+
name|pad
expr_stmt|;
name|obj_som_version_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|header_id
operator|.
name|length
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|obj_som_version_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|string_length
operator|=
name|len
expr_stmt|;
name|strncpy
argument_list|(
name|obj_som_version_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|user_string
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|COPYRIGHT_AUX_ID
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|pad
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|len
operator|%
literal|4
condition|)
name|pad
operator|=
operator|(
literal|4
operator|-
operator|(
name|len
operator|%
literal|4
operator|)
operator|)
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|aux_id
argument_list|)
operator|+
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
operator|+
name|len
operator|+
name|pad
expr_stmt|;
name|obj_som_copyright_hdr
argument_list|(
name|abfd
argument_list|)
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|obj_som_copyright_hdr
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|obj_som_copyright_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|header_id
operator|.
name|type
operator|=
name|COPYRIGHT_AUX_ID
expr_stmt|;
name|obj_som_copyright_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|header_id
operator|.
name|length
operator|=
name|len
operator|+
name|pad
expr_stmt|;
name|obj_som_copyright_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|header_id
operator|.
name|length
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|obj_som_copyright_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|string_length
operator|=
name|len
expr_stmt|;
name|strcpy
argument_list|(
name|obj_som_copyright_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|copyright
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Attach a compilation unit header to the BFD backend so that it may be    written into the object file.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_som_attach_compilation_unit
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|language_name
parameter_list|,
specifier|const
name|char
modifier|*
name|product_id
parameter_list|,
specifier|const
name|char
modifier|*
name|version_id
parameter_list|)
block|{
name|COMPUNIT
modifier|*
name|n
init|=
operator|(
name|COMPUNIT
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|COMPUNITSZ
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
define|#
directive|define
name|STRDUP
parameter_list|(
name|f
parameter_list|)
define|\
value|if (f != NULL) \     { \       n->f.n_name = bfd_alloc (abfd, (bfd_size_type) strlen (f) + 1); \       if (n->f.n_name == NULL) \ 	return FALSE; \       strcpy (n->f.n_name, f); \     }
name|STRDUP
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|STRDUP
argument_list|(
name|language_name
argument_list|)
expr_stmt|;
name|STRDUP
argument_list|(
name|product_id
argument_list|)
expr_stmt|;
name|STRDUP
argument_list|(
name|version_id
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|STRDUP
name|obj_som_compilation_unit
argument_list|(
name|abfd
argument_list|)
operator|=
name|n
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|som_get_section_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|sec_ptr
name|section
parameter_list|,
name|void
modifier|*
name|location
parameter_list|,
name|file_ptr
name|offset
parameter_list|,
name|bfd_size_type
name|count
parameter_list|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
operator|||
operator|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|offset
operator|+
name|count
argument_list|)
operator|>
name|section
operator|->
name|size
operator|||
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|section
operator|->
name|filepos
operator|+
name|offset
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|!=
name|count
condition|)
return|return
name|FALSE
return|;
comment|/* On error.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|som_set_section_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|sec_ptr
name|section
parameter_list|,
specifier|const
name|void
modifier|*
name|location
parameter_list|,
name|file_ptr
name|offset
parameter_list|,
name|bfd_size_type
name|count
parameter_list|)
block|{
if|if
condition|(
operator|!
name|abfd
operator|->
name|output_has_begun
condition|)
block|{
comment|/* Set up fixed parts of the file, space, and subspace headers. 	 Notify the world that output has begun.  */
name|som_prep_headers
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|output_has_begun
operator|=
name|TRUE
expr_stmt|;
comment|/* Start writing the object file.  This include all the string 	 tables, fixup streams, and other portions of the object file.  */
name|som_begin_writing
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
comment|/* Only write subspaces which have "real" contents (eg. the contents      are not generated at run time by the OS).  */
if|if
condition|(
operator|!
name|som_is_subspace
argument_list|(
name|section
argument_list|)
operator|||
operator|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
name|TRUE
return|;
comment|/* Seek to the proper offset within the object file and write the      data.  */
name|offset
operator|+=
name|som_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|subspace_dict
operator|->
name|file_loc_init_value
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|location
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|!=
name|count
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|som_set_arch_mach
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|enum
name|bfd_architecture
name|arch
parameter_list|,
name|unsigned
name|long
name|machine
parameter_list|)
block|{
comment|/* Allow any architecture to be supported by the SOM backend.  */
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|som_find_nearest_line
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_vma
name|offset
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
modifier|*
name|line_ptr
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|som_sizeof_headers
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"som_sizeof_headers unimplemented"
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the single-character symbol type corresponding to    SOM section S, or '?' for an unknown SOM section.  */
end_comment

begin_function
specifier|static
name|char
name|som_section_type
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|struct
name|section_to_type
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
operator|&
name|stt
index|[
literal|0
index|]
init|;
name|t
operator|->
name|section
condition|;
name|t
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
name|t
operator|->
name|section
argument_list|)
condition|)
return|return
name|t
operator|->
name|type
return|;
return|return
literal|'?'
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|som_decode_symclass
parameter_list|(
name|asymbol
modifier|*
name|symbol
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
return|return
literal|'C'
return|;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
block|{
if|if
condition|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_WEAK
condition|)
block|{
comment|/* If weak, determine if it's specifically an object 	     or non-object weak.  */
if|if
condition|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_OBJECT
condition|)
return|return
literal|'v'
return|;
else|else
return|return
literal|'w'
return|;
block|}
else|else
return|return
literal|'U'
return|;
block|}
if|if
condition|(
name|bfd_is_ind_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
return|return
literal|'I'
return|;
if|if
condition|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_WEAK
condition|)
block|{
comment|/* If weak, determine if it's specifically an object 	 or non-object weak.  */
if|if
condition|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_OBJECT
condition|)
return|return
literal|'V'
return|;
else|else
return|return
literal|'W'
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|symbol
operator|->
name|flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_LOCAL
operator|)
operator|)
condition|)
return|return
literal|'?'
return|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|||
operator|(
name|som_symbol_data
argument_list|(
name|symbol
argument_list|)
operator|!=
name|NULL
operator|&&
name|som_symbol_data
argument_list|(
name|symbol
argument_list|)
operator|->
name|som_type
operator|==
name|SYMBOL_TYPE_ABSOLUTE
operator|)
condition|)
name|c
operator|=
literal|'a'
expr_stmt|;
elseif|else
if|if
condition|(
name|symbol
operator|->
name|section
condition|)
name|c
operator|=
name|som_section_type
argument_list|(
name|symbol
operator|->
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
return|return
literal|'?'
return|;
if|if
condition|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_GLOBAL
condition|)
name|c
operator|=
name|TOUPPER
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Return information about SOM symbol SYMBOL in RET.  */
end_comment

begin_function
specifier|static
name|void
name|som_get_symbol_info
parameter_list|(
name|bfd
modifier|*
name|ignore_abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|symbol_info
modifier|*
name|ret
parameter_list|)
block|{
name|ret
operator|->
name|type
operator|=
name|som_decode_symclass
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|->
name|type
operator|!=
literal|'U'
condition|)
name|ret
operator|->
name|value
operator|=
name|symbol
operator|->
name|value
operator|+
name|symbol
operator|->
name|section
operator|->
name|vma
expr_stmt|;
else|else
name|ret
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|name
operator|=
name|symbol
operator|->
name|name
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Count the number of symbols in the archive symbol table.  Necessary    so that we can allocate space for all the carsyms at once.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|som_bfd_count_ar_symbols
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|lst_header
modifier|*
name|lst_header
parameter_list|,
name|symindex
modifier|*
name|count
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
modifier|*
name|hash_table
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|file_ptr
name|lst_filepos
init|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|lst_header
argument_list|)
decl_stmt|;
name|amt
operator|=
name|lst_header
operator|->
name|hash_size
expr_stmt|;
name|amt
operator|*=
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
expr_stmt|;
name|hash_table
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_table
operator|==
name|NULL
operator|&&
name|lst_header
operator|->
name|hash_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* Don't forget to initialize the counter!  */
operator|*
name|count
operator|=
literal|0
expr_stmt|;
comment|/* Read in the hash table.  The has table is an array of 32bit file offsets      which point to the hash chains.  */
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
name|hash_table
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
comment|/* Walk each chain counting the number of symbols found on that particular      chain.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lst_header
operator|->
name|hash_size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|lst_symbol_record
name|lst_symbol
decl_stmt|;
comment|/* An empty chain has zero as it's file offset.  */
if|if
condition|(
name|hash_table
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
comment|/* Seek to the first symbol in this hash chain.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|lst_filepos
operator|+
name|hash_table
index|[
name|i
index|]
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* Read in this symbol and update the counter.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|lst_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|lst_symbol
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
operator|(
operator|*
name|count
operator|)
operator|++
expr_stmt|;
comment|/* Now iterate through the rest of the symbols on this chain.  */
while|while
condition|(
name|lst_symbol
operator|.
name|next_entry
condition|)
block|{
comment|/* Seek to the next symbol.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|lst_filepos
operator|+
name|lst_symbol
operator|.
name|next_entry
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* Read the symbol in and update the counter.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|lst_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|lst_symbol
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
operator|(
operator|*
name|count
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hash_table
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|hash_table
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|hash_table
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|hash_table
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Fill in the canonical archive symbols (SYMS) from the archive described    by ABFD and LST_HEADER.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|som_bfd_fill_in_ar_symbols
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|lst_header
modifier|*
name|lst_header
parameter_list|,
name|carsym
modifier|*
modifier|*
name|syms
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|carsym
modifier|*
name|set
init|=
name|syms
index|[
literal|0
index|]
decl_stmt|;
name|unsigned
name|int
modifier|*
name|hash_table
init|=
name|NULL
decl_stmt|;
name|struct
name|som_entry
modifier|*
name|som_dict
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|file_ptr
name|lst_filepos
init|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|lst_header
argument_list|)
decl_stmt|;
name|amt
operator|=
name|lst_header
operator|->
name|hash_size
expr_stmt|;
name|amt
operator|*=
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
expr_stmt|;
name|hash_table
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_table
operator|==
name|NULL
operator|&&
name|lst_header
operator|->
name|hash_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* Read in the hash table.  The has table is an array of 32bit file offsets      which point to the hash chains.  */
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
name|hash_table
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
comment|/* Seek to and read in the SOM dictionary.  We will need this to fill      in the carsym's filepos field.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|lst_filepos
operator|+
name|lst_header
operator|->
name|dir_loc
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|amt
operator|=
name|lst_header
operator|->
name|module_count
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|som_entry
argument_list|)
expr_stmt|;
name|som_dict
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|som_dict
operator|==
name|NULL
operator|&&
name|lst_header
operator|->
name|module_count
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
name|som_dict
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
comment|/* Walk each chain filling in the carsyms as we go along.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lst_header
operator|->
name|hash_size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|lst_symbol_record
name|lst_symbol
decl_stmt|;
comment|/* An empty chain has zero as it's file offset.  */
if|if
condition|(
name|hash_table
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
comment|/* Seek to and read the first symbol on the chain.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|lst_filepos
operator|+
name|hash_table
index|[
name|i
index|]
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|lst_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|lst_symbol
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
comment|/* Get the name of the symbol, first get the length which is stored 	 as a 32bit integer just before the symbol.  	 One might ask why we don't just read in the entire string table 	 and index into it.  Well, according to the SOM ABI the string 	 index can point *anywhere* in the archive to save space, so just 	 using the string table would not be safe.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|lst_filepos
operator|+
name|lst_header
operator|->
name|string_loc
operator|+
name|lst_symbol
operator|.
name|name
operator|.
name|n_strx
operator|-
literal|4
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|&
name|len
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
goto|goto
name|error_return
goto|;
comment|/* Allocate space for the name and null terminate it too.  */
name|set
operator|->
name|name
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
operator|->
name|name
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_bread
argument_list|(
name|set
operator|->
name|name
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|len
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
condition|)
goto|goto
name|error_return
goto|;
name|set
operator|->
name|name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Fill in the file offset.  Note that the "location" field points 	 to the SOM itself, not the ar_hdr in front of it.  */
name|set
operator|->
name|file_offset
operator|=
name|som_dict
index|[
name|lst_symbol
operator|.
name|som_index
index|]
operator|.
name|location
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
expr_stmt|;
comment|/* Go to the next symbol.  */
name|set
operator|++
expr_stmt|;
comment|/* Iterate through the rest of the chain.  */
while|while
condition|(
name|lst_symbol
operator|.
name|next_entry
condition|)
block|{
comment|/* Seek to the next symbol and read it in.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|lst_filepos
operator|+
name|lst_symbol
operator|.
name|next_entry
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|lst_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|lst_symbol
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
comment|/* Seek to the name length& string and read them in.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|lst_filepos
operator|+
name|lst_header
operator|->
name|string_loc
operator|+
name|lst_symbol
operator|.
name|name
operator|.
name|n_strx
operator|-
literal|4
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|&
name|len
argument_list|,
operator|(
name|bfd_size_type
operator|)
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
goto|goto
name|error_return
goto|;
comment|/* Allocate space for the name and null terminate it too.  */
name|set
operator|->
name|name
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
operator|->
name|name
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_bread
argument_list|(
name|set
operator|->
name|name
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|len
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
condition|)
goto|goto
name|error_return
goto|;
name|set
operator|->
name|name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Fill in the file offset.  Note that the "location" field points 	     to the SOM itself, not the ar_hdr in front of it.  */
name|set
operator|->
name|file_offset
operator|=
name|som_dict
index|[
name|lst_symbol
operator|.
name|som_index
index|]
operator|.
name|location
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
expr_stmt|;
comment|/* Go on to the next symbol.  */
name|set
operator|++
expr_stmt|;
block|}
block|}
comment|/* If we haven't died by now, then we successfully read the entire      archive symbol table.  */
if|if
condition|(
name|hash_table
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|hash_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|som_dict
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|som_dict
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|hash_table
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|hash_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|som_dict
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|som_dict
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Read in the LST from the archive.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|som_slurp_armap
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|lst_header
name|lst_header
decl_stmt|;
name|struct
name|ar_hdr
name|ar_header
decl_stmt|;
name|unsigned
name|int
name|parsed_size
decl_stmt|;
name|struct
name|artdata
modifier|*
name|ardata
init|=
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|char
name|nextname
index|[
literal|17
index|]
decl_stmt|;
name|bfd_size_type
name|amt
init|=
literal|16
decl_stmt|;
name|int
name|i
init|=
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
name|nextname
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
decl_stmt|;
comment|/* Special cases.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|i
operator|!=
literal|16
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
operator|-
literal|16
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* For archives without .o files there is no symbol table.  */
if|if
condition|(
operator|!
name|CONST_STRNEQ
argument_list|(
name|nextname
argument_list|,
literal|"/               "
argument_list|)
condition|)
block|{
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|FALSE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Read in and sanity check the archive header.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|ar_header
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|ar_header
operator|.
name|ar_fmag
argument_list|,
name|ARFMAG
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_malformed_archive
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* How big is the archive symbol table entry?  */
name|errno
operator|=
literal|0
expr_stmt|;
name|parsed_size
operator|=
name|strtol
argument_list|(
name|ar_header
operator|.
name|ar_size
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_malformed_archive
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Save off the file offset of the first real user data.  */
name|ardata
operator|->
name|first_file_filepos
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
operator|+
name|parsed_size
expr_stmt|;
comment|/* Read in the library symbol table.  We'll make heavy use of this      in just a minute.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lst_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|lst_header
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
comment|/* Sanity check.  */
if|if
condition|(
name|lst_header
operator|.
name|a_magic
operator|!=
name|LIBMAGIC
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_malformed_archive
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Count the number of symbols in the library symbol table.  */
if|if
condition|(
operator|!
name|som_bfd_count_ar_symbols
argument_list|(
name|abfd
argument_list|,
operator|&
name|lst_header
argument_list|,
operator|&
name|ardata
operator|->
name|symdef_count
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Get back to the start of the library symbol table.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|ardata
operator|->
name|first_file_filepos
operator|-
name|parsed_size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|lst_header
argument_list|)
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* Initialize the cache and allocate space for the library symbols.  */
name|ardata
operator|->
name|cache
operator|=
literal|0
expr_stmt|;
name|amt
operator|=
name|ardata
operator|->
name|symdef_count
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|carsym
argument_list|)
expr_stmt|;
name|ardata
operator|->
name|symdefs
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ardata
operator|->
name|symdefs
condition|)
return|return
name|FALSE
return|;
comment|/* Now fill in the canonical archive symbols.  */
if|if
condition|(
operator|!
name|som_bfd_fill_in_ar_symbols
argument_list|(
name|abfd
argument_list|,
operator|&
name|lst_header
argument_list|,
operator|&
name|ardata
operator|->
name|symdefs
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Seek back to the "first" file in the archive.  Note the "first"      file may be the extended name table.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|ardata
operator|->
name|first_file_filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* Notify the generic archive code that we have a symbol map.  */
name|bfd_has_map
argument_list|(
name|abfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Begin preparing to write a SOM library symbol table.     As part of the prep work we need to determine the number of symbols    and the size of the associated string section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|som_bfd_prep_for_ar_write
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|int
modifier|*
name|num_syms
parameter_list|,
name|unsigned
name|int
modifier|*
name|stringsize
parameter_list|)
block|{
name|bfd
modifier|*
name|curr_bfd
init|=
name|abfd
operator|->
name|archive_head
decl_stmt|;
comment|/* Some initialization.  */
operator|*
name|num_syms
operator|=
literal|0
expr_stmt|;
operator|*
name|stringsize
operator|=
literal|0
expr_stmt|;
comment|/* Iterate over each BFD within this archive.  */
while|while
condition|(
name|curr_bfd
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|curr_count
decl_stmt|,
name|i
decl_stmt|;
name|som_symbol_type
modifier|*
name|sym
decl_stmt|;
comment|/* Don't bother for non-SOM objects.  */
if|if
condition|(
name|curr_bfd
operator|->
name|format
operator|!=
name|bfd_object
operator|||
name|curr_bfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_som_flavour
condition|)
block|{
name|curr_bfd
operator|=
name|curr_bfd
operator|->
name|archive_next
expr_stmt|;
continue|continue;
block|}
comment|/* Make sure the symbol table has been read, then snag a pointer 	 to it.  It's a little slimey to grab the symbols via obj_som_symtab, 	 but doing so avoids allocating lots of extra memory.  */
if|if
condition|(
operator|!
name|som_slurp_symbol_table
argument_list|(
name|curr_bfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|sym
operator|=
name|obj_som_symtab
argument_list|(
name|curr_bfd
argument_list|)
expr_stmt|;
name|curr_count
operator|=
name|bfd_get_symcount
argument_list|(
name|curr_bfd
argument_list|)
expr_stmt|;
comment|/* Examine each symbol to determine if it belongs in the 	 library symbol table.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|curr_count
condition|;
name|i
operator|++
operator|,
name|sym
operator|++
control|)
block|{
name|struct
name|som_misc_symbol_info
name|info
decl_stmt|;
comment|/* Derive SOM information from the BFD symbol.  */
name|som_bfd_derive_misc_symbol_info
argument_list|(
name|curr_bfd
argument_list|,
operator|&
name|sym
operator|->
name|symbol
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
comment|/* Should we include this symbol?  */
if|if
condition|(
name|info
operator|.
name|symbol_type
operator|==
name|ST_NULL
operator|||
name|info
operator|.
name|symbol_type
operator|==
name|ST_SYM_EXT
operator|||
name|info
operator|.
name|symbol_type
operator|==
name|ST_ARG_EXT
condition|)
continue|continue;
comment|/* Only global symbols and unsatisfied commons.  */
if|if
condition|(
name|info
operator|.
name|symbol_scope
operator|!=
name|SS_UNIVERSAL
operator|&&
name|info
operator|.
name|symbol_type
operator|!=
name|ST_STORAGE
condition|)
continue|continue;
comment|/* Do no include undefined symbols.  */
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|sym
operator|->
name|symbol
operator|.
name|section
argument_list|)
condition|)
continue|continue;
comment|/* Bump the various counters, being careful to honor 	     alignment considerations in the string table.  */
operator|(
operator|*
name|num_syms
operator|)
operator|++
expr_stmt|;
operator|*
name|stringsize
operator|=
operator|*
name|stringsize
operator|+
name|strlen
argument_list|(
name|sym
operator|->
name|symbol
operator|.
name|name
argument_list|)
operator|+
literal|5
expr_stmt|;
while|while
condition|(
operator|*
name|stringsize
operator|%
literal|4
condition|)
operator|(
operator|*
name|stringsize
operator|)
operator|++
expr_stmt|;
block|}
name|curr_bfd
operator|=
name|curr_bfd
operator|->
name|archive_next
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Hash a symbol name based on the hashing algorithm presented in the    SOM ABI.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|som_bfd_ar_symbol_hash
parameter_list|(
name|asymbol
modifier|*
name|symbol
parameter_list|)
block|{
name|unsigned
name|int
name|len
init|=
name|strlen
argument_list|(
name|symbol
operator|->
name|name
argument_list|)
decl_stmt|;
comment|/* Names with length 1 are special.  */
if|if
condition|(
name|len
operator|==
literal|1
condition|)
return|return
literal|0x1000100
operator||
operator|(
name|symbol
operator|->
name|name
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
name|symbol
operator|->
name|name
index|[
literal|0
index|]
return|;
return|return
operator|(
operator|(
name|len
operator|&
literal|0x7f
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
name|symbol
operator|->
name|name
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|symbol
operator|->
name|name
index|[
name|len
operator|-
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|symbol
operator|->
name|name
index|[
name|len
operator|-
literal|1
index|]
return|;
block|}
end_function

begin_comment
comment|/* Do the bulk of the work required to write the SOM library    symbol table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|som_bfd_ar_write_symbol_stuff
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|int
name|nsyms
parameter_list|,
name|unsigned
name|int
name|string_size
parameter_list|,
name|struct
name|lst_header
name|lst
parameter_list|,
name|unsigned
name|elength
parameter_list|)
block|{
name|file_ptr
name|lst_filepos
decl_stmt|;
name|char
modifier|*
name|strings
init|=
name|NULL
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|lst_symbol_record
modifier|*
name|lst_syms
init|=
name|NULL
decl_stmt|,
modifier|*
name|curr_lst_sym
decl_stmt|;
name|bfd
modifier|*
name|curr_bfd
decl_stmt|;
name|unsigned
name|int
modifier|*
name|hash_table
init|=
name|NULL
decl_stmt|;
name|struct
name|som_entry
modifier|*
name|som_dict
init|=
name|NULL
decl_stmt|;
name|struct
name|lst_symbol_record
modifier|*
modifier|*
name|last_hash_entry
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|curr_som_offset
decl_stmt|,
name|som_index
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|amt
operator|=
name|lst
operator|.
name|hash_size
expr_stmt|;
name|amt
operator|*=
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
expr_stmt|;
name|hash_table
operator|=
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_table
operator|==
name|NULL
operator|&&
name|lst
operator|.
name|hash_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|amt
operator|=
name|lst
operator|.
name|module_count
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|som_entry
argument_list|)
expr_stmt|;
name|som_dict
operator|=
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|som_dict
operator|==
name|NULL
operator|&&
name|lst
operator|.
name|module_count
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|amt
operator|=
name|lst
operator|.
name|hash_size
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|lst_symbol_record
operator|*
argument_list|)
expr_stmt|;
name|last_hash_entry
operator|=
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_hash_entry
operator|==
name|NULL
operator|&&
name|lst
operator|.
name|hash_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
comment|/* Lots of fields are file positions relative to the start      of the lst record.  So save its location.  */
name|lst_filepos
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|lst_header
argument_list|)
expr_stmt|;
comment|/* Symbols have som_index fields, so we have to keep track of the      index of each SOM in the archive.       The SOM dictionary has (among other things) the absolute file      position for the SOM which a particular dictionary entry      describes.  We have to compute that information as we iterate      through the SOMs/symbols.  */
name|som_index
operator|=
literal|0
expr_stmt|;
comment|/* We add in the size of the archive header twice as the location      in the SOM dictionary is the actual offset of the SOM, not the      archive header before the SOM.  */
name|curr_som_offset
operator|=
literal|8
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
operator|+
name|lst
operator|.
name|file_end
expr_stmt|;
comment|/* Make room for the archive header and the contents of the      extended string table.  Note that elength includes the size      of the archive header for the extended name table!  */
if|if
condition|(
name|elength
condition|)
name|curr_som_offset
operator|+=
name|elength
expr_stmt|;
comment|/* Make sure we're properly aligned.  */
name|curr_som_offset
operator|=
operator|(
name|curr_som_offset
operator|+
literal|0x1
operator|)
operator|&
operator|~
literal|0x1
expr_stmt|;
comment|/* FIXME should be done with buffers just like everything else...  */
name|amt
operator|=
name|nsyms
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|lst_symbol_record
argument_list|)
expr_stmt|;
name|lst_syms
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|lst_syms
operator|==
name|NULL
operator|&&
name|nsyms
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|strings
operator|=
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|string_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|strings
operator|==
name|NULL
operator|&&
name|string_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|p
operator|=
name|strings
expr_stmt|;
name|curr_lst_sym
operator|=
name|lst_syms
expr_stmt|;
name|curr_bfd
operator|=
name|abfd
operator|->
name|archive_head
expr_stmt|;
while|while
condition|(
name|curr_bfd
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|curr_count
decl_stmt|,
name|i
decl_stmt|;
name|som_symbol_type
modifier|*
name|sym
decl_stmt|;
comment|/* Don't bother for non-SOM objects.  */
if|if
condition|(
name|curr_bfd
operator|->
name|format
operator|!=
name|bfd_object
operator|||
name|curr_bfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_som_flavour
condition|)
block|{
name|curr_bfd
operator|=
name|curr_bfd
operator|->
name|archive_next
expr_stmt|;
continue|continue;
block|}
comment|/* Make sure the symbol table has been read, then snag a pointer 	 to it.  It's a little slimey to grab the symbols via obj_som_symtab, 	 but doing so avoids allocating lots of extra memory.  */
if|if
condition|(
operator|!
name|som_slurp_symbol_table
argument_list|(
name|curr_bfd
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|sym
operator|=
name|obj_som_symtab
argument_list|(
name|curr_bfd
argument_list|)
expr_stmt|;
name|curr_count
operator|=
name|bfd_get_symcount
argument_list|(
name|curr_bfd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|curr_count
condition|;
name|i
operator|++
operator|,
name|sym
operator|++
control|)
block|{
name|struct
name|som_misc_symbol_info
name|info
decl_stmt|;
comment|/* Derive SOM information from the BFD symbol.  */
name|som_bfd_derive_misc_symbol_info
argument_list|(
name|curr_bfd
argument_list|,
operator|&
name|sym
operator|->
name|symbol
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
comment|/* Should we include this symbol?  */
if|if
condition|(
name|info
operator|.
name|symbol_type
operator|==
name|ST_NULL
operator|||
name|info
operator|.
name|symbol_type
operator|==
name|ST_SYM_EXT
operator|||
name|info
operator|.
name|symbol_type
operator|==
name|ST_ARG_EXT
condition|)
continue|continue;
comment|/* Only global symbols and unsatisfied commons.  */
if|if
condition|(
name|info
operator|.
name|symbol_scope
operator|!=
name|SS_UNIVERSAL
operator|&&
name|info
operator|.
name|symbol_type
operator|!=
name|ST_STORAGE
condition|)
continue|continue;
comment|/* Do no include undefined symbols.  */
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|sym
operator|->
name|symbol
operator|.
name|section
argument_list|)
condition|)
continue|continue;
comment|/* If this is the first symbol from this SOM, then update 	     the SOM dictionary too.  */
if|if
condition|(
name|som_dict
index|[
name|som_index
index|]
operator|.
name|location
operator|==
literal|0
condition|)
block|{
name|som_dict
index|[
name|som_index
index|]
operator|.
name|location
operator|=
name|curr_som_offset
expr_stmt|;
name|som_dict
index|[
name|som_index
index|]
operator|.
name|length
operator|=
name|arelt_size
argument_list|(
name|curr_bfd
argument_list|)
expr_stmt|;
block|}
comment|/* Fill in the lst symbol record.  */
name|curr_lst_sym
operator|->
name|hidden
operator|=
literal|0
expr_stmt|;
name|curr_lst_sym
operator|->
name|secondary_def
operator|=
name|info
operator|.
name|secondary_def
expr_stmt|;
name|curr_lst_sym
operator|->
name|symbol_type
operator|=
name|info
operator|.
name|symbol_type
expr_stmt|;
name|curr_lst_sym
operator|->
name|symbol_scope
operator|=
name|info
operator|.
name|symbol_scope
expr_stmt|;
name|curr_lst_sym
operator|->
name|check_level
operator|=
literal|0
expr_stmt|;
name|curr_lst_sym
operator|->
name|must_qualify
operator|=
literal|0
expr_stmt|;
name|curr_lst_sym
operator|->
name|initially_frozen
operator|=
literal|0
expr_stmt|;
name|curr_lst_sym
operator|->
name|memory_resident
operator|=
literal|0
expr_stmt|;
name|curr_lst_sym
operator|->
name|is_common
operator|=
name|bfd_is_com_section
argument_list|(
name|sym
operator|->
name|symbol
operator|.
name|section
argument_list|)
expr_stmt|;
name|curr_lst_sym
operator|->
name|dup_common
operator|=
name|info
operator|.
name|dup_common
expr_stmt|;
name|curr_lst_sym
operator|->
name|xleast
operator|=
literal|3
expr_stmt|;
name|curr_lst_sym
operator|->
name|arg_reloc
operator|=
name|info
operator|.
name|arg_reloc
expr_stmt|;
name|curr_lst_sym
operator|->
name|name
operator|.
name|n_strx
operator|=
name|p
operator|-
name|strings
operator|+
literal|4
expr_stmt|;
name|curr_lst_sym
operator|->
name|qualifier_name
operator|.
name|n_strx
operator|=
literal|0
expr_stmt|;
name|curr_lst_sym
operator|->
name|symbol_info
operator|=
name|info
operator|.
name|symbol_info
expr_stmt|;
name|curr_lst_sym
operator|->
name|symbol_value
operator|=
name|info
operator|.
name|symbol_value
operator||
name|info
operator|.
name|priv_level
expr_stmt|;
name|curr_lst_sym
operator|->
name|symbol_descriptor
operator|=
literal|0
expr_stmt|;
name|curr_lst_sym
operator|->
name|reserved
operator|=
literal|0
expr_stmt|;
name|curr_lst_sym
operator|->
name|som_index
operator|=
name|som_index
expr_stmt|;
name|curr_lst_sym
operator|->
name|symbol_key
operator|=
name|som_bfd_ar_symbol_hash
argument_list|(
operator|&
name|sym
operator|->
name|symbol
argument_list|)
expr_stmt|;
name|curr_lst_sym
operator|->
name|next_entry
operator|=
literal|0
expr_stmt|;
comment|/* Insert into the hash table.  */
if|if
condition|(
name|hash_table
index|[
name|curr_lst_sym
operator|->
name|symbol_key
operator|%
name|lst
operator|.
name|hash_size
index|]
condition|)
block|{
name|struct
name|lst_symbol_record
modifier|*
name|tmp
decl_stmt|;
comment|/* There is already something at the head of this hash chain, 		 so tack this symbol onto the end of the chain.  */
name|tmp
operator|=
name|last_hash_entry
index|[
name|curr_lst_sym
operator|->
name|symbol_key
operator|%
name|lst
operator|.
name|hash_size
index|]
expr_stmt|;
name|tmp
operator|->
name|next_entry
operator|=
operator|(
name|curr_lst_sym
operator|-
name|lst_syms
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lst_symbol_record
argument_list|)
operator|+
name|lst
operator|.
name|hash_size
operator|*
literal|4
operator|+
name|lst
operator|.
name|module_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|som_entry
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|lst_header
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* First entry in this hash chain.  */
name|hash_table
index|[
name|curr_lst_sym
operator|->
name|symbol_key
operator|%
name|lst
operator|.
name|hash_size
index|]
operator|=
operator|(
name|curr_lst_sym
operator|-
name|lst_syms
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lst_symbol_record
argument_list|)
operator|+
name|lst
operator|.
name|hash_size
operator|*
literal|4
operator|+
name|lst
operator|.
name|module_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|som_entry
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|lst_header
argument_list|)
expr_stmt|;
comment|/* Keep track of the last symbol we added to this chain so we can 	     easily update its next_entry pointer.  */
name|last_hash_entry
index|[
name|curr_lst_sym
operator|->
name|symbol_key
operator|%
name|lst
operator|.
name|hash_size
index|]
operator|=
name|curr_lst_sym
expr_stmt|;
comment|/* Update the string table.  */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|strlen
argument_list|(
name|sym
operator|->
name|symbol
operator|.
name|name
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|sym
operator|->
name|symbol
operator|.
name|name
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|sym
operator|->
name|symbol
operator|.
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|int
operator|)
name|p
operator|%
literal|4
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
comment|/* Head to the next symbol.  */
name|curr_lst_sym
operator|++
expr_stmt|;
block|}
comment|/* Keep track of where each SOM will finally reside; then look 	 at the next BFD.  */
name|curr_som_offset
operator|+=
name|arelt_size
argument_list|(
name|curr_bfd
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
expr_stmt|;
comment|/* A particular object in the archive may have an odd length; the 	 linker requires objects begin on an even boundary.  So round 	 up the current offset as necessary.  */
name|curr_som_offset
operator|=
operator|(
name|curr_som_offset
operator|+
literal|0x1
operator|)
operator|&
operator|~
operator|(
name|unsigned
operator|)
literal|1
expr_stmt|;
name|curr_bfd
operator|=
name|curr_bfd
operator|->
name|archive_next
expr_stmt|;
name|som_index
operator|++
expr_stmt|;
block|}
comment|/* Now scribble out the hash table.  */
name|amt
operator|=
name|lst
operator|.
name|hash_size
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|hash_table
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
comment|/* Then the SOM dictionary.  */
name|amt
operator|=
name|lst
operator|.
name|module_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|som_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|som_dict
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
comment|/* The library symbols.  */
name|amt
operator|=
name|nsyms
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lst_symbol_record
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|lst_syms
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
comment|/* And finally the strings.  */
name|amt
operator|=
name|string_size
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|strings
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|hash_table
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|hash_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|som_dict
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|som_dict
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_hash_entry
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_hash_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|lst_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|lst_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|strings
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|strings
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|hash_table
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|hash_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|som_dict
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|som_dict
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_hash_entry
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_hash_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|lst_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|lst_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|strings
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|strings
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Write out the LST for the archive.     You'll never believe this is really how armaps are handled in SOM...  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|som_write_armap
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|unsigned
name|int
name|elength
parameter_list|,
name|struct
name|orl
modifier|*
name|map
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|orl_count
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|stridx
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd
modifier|*
name|curr_bfd
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|lst_size
decl_stmt|,
name|nsyms
decl_stmt|,
name|stringsize
decl_stmt|;
name|struct
name|ar_hdr
name|hdr
decl_stmt|;
name|struct
name|lst_header
name|lst
decl_stmt|;
name|int
modifier|*
name|p
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* We'll use this for the archive's date and mode later.  */
if|if
condition|(
name|stat
argument_list|(
name|abfd
operator|->
name|filename
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Fudge factor.  */
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|armap_timestamp
operator|=
name|statbuf
operator|.
name|st_mtime
operator|+
literal|60
expr_stmt|;
comment|/* Account for the lst header first.  */
name|lst_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lst_header
argument_list|)
expr_stmt|;
comment|/* Start building the LST header.  */
comment|/* FIXME:  Do we need to examine each element to determine the      largest id number?  */
name|lst
operator|.
name|system_id
operator|=
name|CPU_PA_RISC1_0
expr_stmt|;
name|lst
operator|.
name|a_magic
operator|=
name|LIBMAGIC
expr_stmt|;
name|lst
operator|.
name|version_id
operator|=
name|VERSION_ID
expr_stmt|;
name|lst
operator|.
name|file_time
operator|.
name|secs
operator|=
literal|0
expr_stmt|;
name|lst
operator|.
name|file_time
operator|.
name|nanosecs
operator|=
literal|0
expr_stmt|;
name|lst
operator|.
name|hash_loc
operator|=
name|lst_size
expr_stmt|;
name|lst
operator|.
name|hash_size
operator|=
name|SOM_LST_HASH_SIZE
expr_stmt|;
comment|/* Hash table is a SOM_LST_HASH_SIZE 32bit offsets.  */
name|lst_size
operator|+=
literal|4
operator|*
name|SOM_LST_HASH_SIZE
expr_stmt|;
comment|/* We need to count the number of SOMs in this archive.  */
name|curr_bfd
operator|=
name|abfd
operator|->
name|archive_head
expr_stmt|;
name|lst
operator|.
name|module_count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|curr_bfd
operator|!=
name|NULL
condition|)
block|{
comment|/* Only true SOM objects count.  */
if|if
condition|(
name|curr_bfd
operator|->
name|format
operator|==
name|bfd_object
operator|&&
name|curr_bfd
operator|->
name|xvec
operator|->
name|flavour
operator|==
name|bfd_target_som_flavour
condition|)
name|lst
operator|.
name|module_count
operator|++
expr_stmt|;
name|curr_bfd
operator|=
name|curr_bfd
operator|->
name|archive_next
expr_stmt|;
block|}
name|lst
operator|.
name|module_limit
operator|=
name|lst
operator|.
name|module_count
expr_stmt|;
name|lst
operator|.
name|dir_loc
operator|=
name|lst_size
expr_stmt|;
name|lst_size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|som_entry
argument_list|)
operator|*
name|lst
operator|.
name|module_count
expr_stmt|;
comment|/* We don't support import/export tables, auxiliary headers,      or free lists yet.  Make the linker work a little harder      to make our life easier.  */
name|lst
operator|.
name|export_loc
operator|=
literal|0
expr_stmt|;
name|lst
operator|.
name|export_count
operator|=
literal|0
expr_stmt|;
name|lst
operator|.
name|import_loc
operator|=
literal|0
expr_stmt|;
name|lst
operator|.
name|aux_loc
operator|=
literal|0
expr_stmt|;
name|lst
operator|.
name|aux_size
operator|=
literal|0
expr_stmt|;
comment|/* Count how many symbols we will have on the hash chains and the      size of the associated string table.  */
if|if
condition|(
operator|!
name|som_bfd_prep_for_ar_write
argument_list|(
name|abfd
argument_list|,
operator|&
name|nsyms
argument_list|,
operator|&
name|stringsize
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|lst_size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|lst_symbol_record
argument_list|)
operator|*
name|nsyms
expr_stmt|;
comment|/* For the string table.  One day we might actually use this info      to avoid small seeks/reads when reading archives.  */
name|lst
operator|.
name|string_loc
operator|=
name|lst_size
expr_stmt|;
name|lst
operator|.
name|string_size
operator|=
name|stringsize
expr_stmt|;
name|lst_size
operator|+=
name|stringsize
expr_stmt|;
comment|/* SOM ABI says this must be zero.  */
name|lst
operator|.
name|free_list
operator|=
literal|0
expr_stmt|;
name|lst
operator|.
name|file_end
operator|=
name|lst_size
expr_stmt|;
comment|/* Compute the checksum.  Must happen after the entire lst header      has filled in.  */
name|p
operator|=
operator|(
name|int
operator|*
operator|)
operator|&
name|lst
expr_stmt|;
name|lst
operator|.
name|checksum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|lst_header
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|lst
operator|.
name|checksum
operator|^=
operator|*
name|p
operator|++
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_name
argument_list|,
literal|"/               "
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_date
argument_list|,
literal|"%ld"
argument_list|,
name|bfd_ardata
argument_list|(
name|abfd
argument_list|)
operator|->
name|armap_timestamp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_uid
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_gid
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_mode
argument_list|,
literal|"%-8o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|statbuf
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hdr
operator|.
name|ar_size
argument_list|,
literal|"%-10d"
argument_list|,
operator|(
name|int
operator|)
name|lst_size
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|ar_fmag
index|[
literal|0
index|]
operator|=
literal|'`'
expr_stmt|;
name|hdr
operator|.
name|ar_fmag
index|[
literal|1
index|]
operator|=
literal|'\012'
expr_stmt|;
comment|/* Turn any nulls into spaces.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|hdr
operator|)
operator|)
index|[
name|i
index|]
operator|)
operator|=
literal|' '
expr_stmt|;
comment|/* Scribble out the ar header.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ar_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|hdr
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
comment|/* Now scribble out the lst header.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lst_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|lst
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
comment|/* Build and write the armap.  */
if|if
condition|(
operator|!
name|som_bfd_ar_write_symbol_stuff
argument_list|(
name|abfd
argument_list|,
name|nsyms
argument_list|,
name|stringsize
argument_list|,
name|lst
argument_list|,
name|elength
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Done.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Free all information we have cached for this BFD.  We can always    read it again later if we need it.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|som_bfd_free_cached_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|asection
modifier|*
name|o
decl_stmt|;
if|if
condition|(
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_object
condition|)
return|return
name|TRUE
return|;
define|#
directive|define
name|FREE
parameter_list|(
name|x
parameter_list|)
value|if (x != NULL) { free (x); x = NULL; }
comment|/* Free the native string and symbol tables.  */
name|FREE
argument_list|(
name|obj_som_symtab
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|obj_som_stringtab
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
comment|/* Free the native relocations.  */
name|o
operator|->
name|reloc_count
operator|=
operator|(
name|unsigned
operator|)
operator|-
literal|1
expr_stmt|;
name|FREE
argument_list|(
name|som_section_data
argument_list|(
name|o
argument_list|)
operator|->
name|reloc_stream
argument_list|)
expr_stmt|;
comment|/* Free the generic relocations.  */
name|FREE
argument_list|(
name|o
operator|->
name|relocation
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|FREE
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* End of miscellaneous support functions.  */
end_comment

begin_comment
comment|/* Linker support functions.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|som_bfd_link_split_section
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
return|return
name|som_is_subspace
argument_list|(
name|sec
argument_list|)
operator|&&
name|sec
operator|->
name|size
operator|>
literal|240000
return|;
block|}
end_function

begin_define
define|#
directive|define
name|som_close_and_cleanup
value|som_bfd_free_cached_info
end_define

begin_define
define|#
directive|define
name|som_read_ar_hdr
value|_bfd_generic_read_ar_hdr
end_define

begin_define
define|#
directive|define
name|som_openr_next_archived_file
value|bfd_generic_openr_next_archived_file
end_define

begin_define
define|#
directive|define
name|som_get_elt_at_index
value|_bfd_generic_get_elt_at_index
end_define

begin_define
define|#
directive|define
name|som_generic_stat_arch_elt
value|bfd_generic_stat_arch_elt
end_define

begin_define
define|#
directive|define
name|som_truncate_arname
value|bfd_bsd_truncate_arname
end_define

begin_define
define|#
directive|define
name|som_slurp_extended_name_table
value|_bfd_slurp_extended_name_table
end_define

begin_define
define|#
directive|define
name|som_construct_extended_name_table
value|_bfd_archive_coff_construct_extended_name_table
end_define

begin_define
define|#
directive|define
name|som_update_armap_timestamp
value|bfd_true
end_define

begin_define
define|#
directive|define
name|som_bfd_is_target_special_symbol
value|((bfd_boolean (*) (bfd *, asymbol *)) bfd_false)
end_define

begin_define
define|#
directive|define
name|som_get_lineno
value|_bfd_nosymbols_get_lineno
end_define

begin_define
define|#
directive|define
name|som_bfd_make_debug_symbol
value|_bfd_nosymbols_bfd_make_debug_symbol
end_define

begin_define
define|#
directive|define
name|som_read_minisymbols
value|_bfd_generic_read_minisymbols
end_define

begin_define
define|#
directive|define
name|som_minisymbol_to_symbol
value|_bfd_generic_minisymbol_to_symbol
end_define

begin_define
define|#
directive|define
name|som_get_section_contents_in_window
value|_bfd_generic_get_section_contents_in_window
end_define

begin_define
define|#
directive|define
name|som_bfd_get_relocated_section_contents
value|bfd_generic_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|som_bfd_relax_section
value|bfd_generic_relax_section
end_define

begin_define
define|#
directive|define
name|som_bfd_link_hash_table_create
value|_bfd_generic_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|som_bfd_link_hash_table_free
value|_bfd_generic_link_hash_table_free
end_define

begin_define
define|#
directive|define
name|som_bfd_link_add_symbols
value|_bfd_generic_link_add_symbols
end_define

begin_define
define|#
directive|define
name|som_bfd_link_just_syms
value|_bfd_generic_link_just_syms
end_define

begin_define
define|#
directive|define
name|som_bfd_final_link
value|_bfd_generic_final_link
end_define

begin_define
define|#
directive|define
name|som_bfd_gc_sections
value|bfd_generic_gc_sections
end_define

begin_define
define|#
directive|define
name|som_bfd_merge_sections
value|bfd_generic_merge_sections
end_define

begin_define
define|#
directive|define
name|som_bfd_is_group_section
value|bfd_generic_is_group_section
end_define

begin_define
define|#
directive|define
name|som_bfd_discard_group
value|bfd_generic_discard_group
end_define

begin_define
define|#
directive|define
name|som_section_already_linked
value|_bfd_generic_section_already_linked
end_define

begin_define
define|#
directive|define
name|som_bfd_merge_private_bfd_data
value|_bfd_generic_bfd_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|som_bfd_copy_private_header_data
value|_bfd_generic_bfd_copy_private_header_data
end_define

begin_define
define|#
directive|define
name|som_bfd_set_private_flags
value|_bfd_generic_bfd_set_private_flags
end_define

begin_define
define|#
directive|define
name|som_find_inliner_info
value|_bfd_nosymbols_find_inliner_info
end_define

begin_decl_stmt
specifier|const
name|bfd_target
name|som_vec
init|=
block|{
literal|"som"
block|,
comment|/* Name.  */
name|bfd_target_som_flavour
block|,
name|BFD_ENDIAN_BIG
block|,
comment|/* Target byte order.  */
name|BFD_ENDIAN_BIG
block|,
comment|/* Target headers byte order.  */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* Object flags.  */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator||
name|DYNAMIC
operator|)
block|,
operator|(
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_ROM
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_LINK_ONCE
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* Section flags.  */
comment|/* Leading_symbol_char: is the first char of a user symbol      predictable, and if so what is it.  */
literal|0
block|,
literal|'/'
block|,
comment|/* AR_pad_char.  */
literal|14
block|,
comment|/* AR_max_namelen.  */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* Data.  */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* Headers.  */
block|{
name|_bfd_dummy_target
block|,
name|som_object_p
block|,
comment|/* bfd_check_format.  */
name|bfd_generic_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|som_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|som_write_object_contents
block|,
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|,   }
block|,
undef|#
directive|undef
name|som
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|som
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|som
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|som
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|som
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|som
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|som
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|som
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HOST_HPPAHPUX || HOST_HPPABSD || HOST_HPPAOSF */
end_comment

end_unit

