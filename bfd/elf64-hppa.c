begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for HPPA 64-bit ELF    Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"alloca-conf.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/hppa.h"
end_include

begin_include
include|#
directive|include
file|"libhppa.h"
end_include

begin_include
include|#
directive|include
file|"elf64-hppa.h"
end_include

begin_define
define|#
directive|define
name|ARCH_SIZE
value|64
end_define

begin_define
define|#
directive|define
name|PLT_ENTRY_SIZE
value|0x10
end_define

begin_define
define|#
directive|define
name|DLT_ENTRY_SIZE
value|0x8
end_define

begin_define
define|#
directive|define
name|OPD_ENTRY_SIZE
value|0x20
end_define

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/usr/lib/pa20_64/dld.sl"
end_define

begin_comment
comment|/* The stub is supposed to load the target address and target's DP    value out of the PLT, then do an external branch to the target    address.     LDD PLTOFF(%r27),%r1    BVE (%r1)    LDD PLTOFF+8(%r27),%r27     Note that we must use the LDD with a 14 bit displacement, not the one    with a 5 bit displacement.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|plt_stub
index|[]
init|=
block|{
literal|0x53
block|,
literal|0x61
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xe8
block|,
literal|0x20
block|,
literal|0xd0
block|,
literal|0x00
block|,
literal|0x53
block|,
literal|0x7b
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|elf64_hppa_dyn_hash_entry
block|{
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
comment|/* Offsets for this symbol in various linker sections.  */
name|bfd_vma
name|dlt_offset
decl_stmt|;
name|bfd_vma
name|plt_offset
decl_stmt|;
name|bfd_vma
name|opd_offset
decl_stmt|;
name|bfd_vma
name|stub_offset
decl_stmt|;
comment|/* The symbol table entry, if any, that this was derived from.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* The index of the (possibly local) symbol in the input bfd and its      associated BFD.  Needed so that we can have relocs against local      symbols in shared libraries.  */
name|long
name|sym_indx
decl_stmt|;
name|bfd
modifier|*
name|owner
decl_stmt|;
comment|/* Dynamic symbols may need to have two different values.  One for      the dynamic symbol table, one for the normal symbol table.       In such cases we store the symbol's real value and section      index here so we can restore the real value before we write      the normal symbol table.  */
name|bfd_vma
name|st_value
decl_stmt|;
name|int
name|st_shndx
decl_stmt|;
comment|/* Used to count non-got, non-plt relocations for delayed sizing      of relocation sections.  */
struct|struct
name|elf64_hppa_dyn_reloc_entry
block|{
comment|/* Next relocation in the chain.  */
name|struct
name|elf64_hppa_dyn_reloc_entry
modifier|*
name|next
decl_stmt|;
comment|/* The type of the relocation.  */
name|int
name|type
decl_stmt|;
comment|/* The input section of the relocation.  */
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* The index of the section symbol for the input section of        the relocation.  Only needed when building shared libraries.  */
name|int
name|sec_symndx
decl_stmt|;
comment|/* The offset within the input section of the relocation.  */
name|bfd_vma
name|offset
decl_stmt|;
comment|/* The addend for the relocation.  */
name|bfd_vma
name|addend
decl_stmt|;
block|}
modifier|*
name|reloc_entries
struct|;
comment|/* Nonzero if this symbol needs an entry in one of the linker      sections.  */
name|unsigned
name|want_dlt
decl_stmt|;
name|unsigned
name|want_plt
decl_stmt|;
name|unsigned
name|want_opd
decl_stmt|;
name|unsigned
name|want_stub
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|elf64_hppa_dyn_hash_table
block|{
name|struct
name|bfd_hash_table
name|root
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|elf64_hppa_link_hash_table
block|{
name|struct
name|elf_link_hash_table
name|root
decl_stmt|;
comment|/* Shortcuts to get to the various linker defined sections.  */
name|asection
modifier|*
name|dlt_sec
decl_stmt|;
name|asection
modifier|*
name|dlt_rel_sec
decl_stmt|;
name|asection
modifier|*
name|plt_sec
decl_stmt|;
name|asection
modifier|*
name|plt_rel_sec
decl_stmt|;
name|asection
modifier|*
name|opd_sec
decl_stmt|;
name|asection
modifier|*
name|opd_rel_sec
decl_stmt|;
name|asection
modifier|*
name|other_rel_sec
decl_stmt|;
comment|/* Offset of __gp within .plt section.  When the PLT gets large we want      to slide __gp into the PLT section so that we can continue to use      single DP relative instructions to load values out of the PLT.  */
name|bfd_vma
name|gp_offset
decl_stmt|;
comment|/* Note this is not strictly correct.  We should create a stub section for      each input section with calls.  The stub section should be placed before      the section with the call.  */
name|asection
modifier|*
name|stub_sec
decl_stmt|;
name|bfd_vma
name|text_segment_base
decl_stmt|;
name|bfd_vma
name|data_segment_base
decl_stmt|;
name|struct
name|elf64_hppa_dyn_hash_table
name|dyn_hash_table
decl_stmt|;
comment|/* We build tables to map from an input section back to its      symbol index.  This is the BFD for which we currently have      a map.  */
name|bfd
modifier|*
name|section_syms_bfd
decl_stmt|;
comment|/* Array of symbol numbers for each input section attached to the      current BFD.  */
name|int
modifier|*
name|section_syms
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|elf64_hppa_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct elf64_hppa_link_hash_table *) ((p)->hash))
end_define

begin_typedef
typedef|typedef
name|struct
name|bfd_hash_entry
modifier|*
argument_list|(
operator|*
name|new_hash_entry_func
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|elf64_hppa_new_dyn_hash_entry
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
name|entry
operator|,
expr|struct
name|bfd_hash_table
operator|*
name|table
operator|,
specifier|const
name|char
operator|*
name|string
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elf64_hppa_hash_table_create
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|elf64_hppa_dyn_hash_entry
modifier|*
name|elf64_hppa_dyn_hash_lookup
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf64_hppa_dyn_hash_table
operator|*
name|table
operator|,
specifier|const
name|char
operator|*
name|string
operator|,
name|bfd_boolean
name|create
operator|,
name|bfd_boolean
name|copy
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf64_hppa_dyn_hash_traverse
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf64_hppa_dyn_hash_table
operator|*
name|table
operator|,
name|bfd_boolean
argument_list|(
operator|*
name|func
argument_list|)
argument_list|(
expr|struct
name|elf64_hppa_dyn_hash_entry
operator|*
argument_list|,
name|PTR
argument_list|)
operator|,
name|PTR
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_dyn_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|size_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This must follow the definitions of the various derived linker    hash tables and shared functions.  */
end_comment

begin_include
include|#
directive|include
file|"elf-hppa.h"
end_include

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_hppa_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf64_hppa_post_process_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_hppa_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_hppa_adjust_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_hppa_mark_milli_and_exported_functions
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_hppa_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_hppa_link_output_symbol_hook
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_hppa_finish_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elf64_hppa_additional_program_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_hppa_modify_segment_map
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|elf_reloc_type_class
name|elf64_hppa_reloc_type_class
name|PARAMS
argument_list|(
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_hppa_finish_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_hppa_check_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_hppa_dynamic_symbol_p
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_hppa_mark_exported_functions
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_hppa_finalize_opd
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf64_hppa_dyn_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_hppa_finalize_dlt
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf64_hppa_dyn_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|allocate_global_data_dlt
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf64_hppa_dyn_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|allocate_global_data_plt
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf64_hppa_dyn_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|allocate_global_data_stub
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf64_hppa_dyn_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|allocate_global_data_opd
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf64_hppa_dyn_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|get_reloc_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|elf64_hppa_link_hash_table
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|count_dyn_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|elf64_hppa_dyn_hash_entry
operator|*
operator|,
name|int
operator|,
name|asection
operator|*
operator|,
name|int
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|allocate_dynrel_entries
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf64_hppa_dyn_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf64_hppa_finalize_dynreloc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf64_hppa_dyn_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|get_opd
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf64_hppa_link_hash_table
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|get_plt
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf64_hppa_link_hash_table
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|get_dlt
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf64_hppa_link_hash_table
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|get_stub
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf64_hppa_link_hash_table
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elf64_hppa_elf_get_symbol_type
name|PARAMS
argument_list|(
operator|(
name|Elf_Internal_Sym
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_boolean
name|elf64_hppa_dyn_hash_table_init
parameter_list|(
name|struct
name|elf64_hppa_dyn_hash_table
modifier|*
name|ht
parameter_list|,
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|new_hash_entry_func
name|new
parameter_list|,
name|unsigned
name|int
name|entsize
parameter_list|)
block|{
name|memset
argument_list|(
name|ht
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ht
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bfd_hash_table_init
argument_list|(
operator|&
name|ht
operator|->
name|root
argument_list|,
name|new
argument_list|,
name|entsize
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|elf64_hppa_new_dyn_hash_entry
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|elf64_hppa_dyn_hash_entry
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|elf64_hppa_dyn_hash_entry
operator|*
operator|)
name|entry
expr_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
literal|0
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elf64_hppa_dyn_hash_entry
operator|*
operator|)
name|bfd_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
comment|/* Initialize our local data.  All zeros.  */
name|memset
argument_list|(
operator|&
name|ret
operator|->
name|dlt_offset
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|elf64_hppa_dyn_hash_entry
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|elf64_hppa_dyn_hash_entry
argument_list|,
name|dlt_offset
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|root
return|;
block|}
end_function

begin_comment
comment|/* Create the derived linker hash table.  The PA64 ELF port uses this    derived hash table to keep information specific to the PA ElF    linker (without using static variables).  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elf64_hppa_hash_table_create
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|elf64_hppa_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|ret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|_bfd_elf_link_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_hash_entry
argument_list|)
argument_list|)
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|elf64_hppa_dyn_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|dyn_hash_table
argument_list|,
name|abfd
argument_list|,
name|elf64_hppa_new_dyn_hash_entry
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf64_hppa_dyn_hash_entry
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Look up an entry in a PA64 ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|elf64_hppa_dyn_hash_entry
modifier|*
name|elf64_hppa_dyn_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|)
name|struct
name|elf64_hppa_dyn_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|bfd_boolean
name|create
decl_stmt|,
name|copy
decl_stmt|;
block|{
return|return
operator|(
operator|(
expr|struct
name|elf64_hppa_dyn_hash_entry
operator|*
operator|)
name|bfd_hash_lookup
argument_list|(
operator|&
name|table
operator|->
name|root
argument_list|,
name|string
argument_list|,
name|create
argument_list|,
name|copy
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Traverse a PA64 ELF linker hash table.  */
end_comment

begin_function_decl
specifier|static
name|void
name|elf64_hppa_dyn_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
name|struct
name|elf64_hppa_dyn_hash_table
modifier|*
name|table
decl_stmt|;
function_decl|bfd_boolean
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf64_hppa_dyn_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PTR
name|info
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|bfd_hash_traverse
argument_list|(
operator|&
name|table
operator|->
name|root
argument_list|,
operator|(
name|bfd_boolean
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
operator|)
name|func
argument_list|,
name|info
argument_list|)
operator|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if ABFD represents a PA2.0 ELF64 file.     Additionally we set the default architecture and machine.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_hppa_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_target
argument_list|(
name|abfd
argument_list|)
argument_list|,
literal|"elf64-hppa-linux"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* GCC on hppa-linux produces binaries with OSABI=Linux, 	 but the kernel produces corefiles with OSABI=SysV.  */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|!=
name|ELFOSABI_LINUX
operator|&&
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|!=
name|ELFOSABI_NONE
condition|)
comment|/* aka SYSV */
return|return
name|FALSE
return|;
block|}
else|else
block|{
comment|/* HPUX produces binaries with OSABI=HPUX, 	 but the kernel produces corefiles with OSABI=SysV.  */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|!=
name|ELFOSABI_HPUX
operator|&&
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|!=
name|ELFOSABI_NONE
condition|)
comment|/* aka SYSV */
return|return
name|FALSE
return|;
block|}
name|flags
operator|=
name|i_ehdrp
operator|->
name|e_flags
expr_stmt|;
switch|switch
condition|(
name|flags
operator|&
operator|(
name|EF_PARISC_ARCH
operator||
name|EF_PARISC_WIDE
operator|)
condition|)
block|{
case|case
name|EFA_PARISC_1_0
case|:
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_hppa
argument_list|,
literal|10
argument_list|)
return|;
case|case
name|EFA_PARISC_1_1
case|:
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_hppa
argument_list|,
literal|11
argument_list|)
return|;
case|case
name|EFA_PARISC_2_0
case|:
if|if
condition|(
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|ELFCLASS64
condition|)
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_hppa
argument_list|,
literal|25
argument_list|)
return|;
else|else
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_hppa
argument_list|,
literal|20
argument_list|)
return|;
case|case
name|EFA_PARISC_2_0
operator||
name|EF_PARISC_WIDE
case|:
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_hppa
argument_list|,
literal|25
argument_list|)
return|;
block|}
comment|/* Don't be fussy.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Given section type (hdr->sh_type), return a boolean indicating    whether or not the section is an elf64-hppa specific section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_hppa_section_from_shdr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|hdr
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|shindex
parameter_list|)
block|{
name|asection
modifier|*
name|newsect
decl_stmt|;
switch|switch
condition|(
name|hdr
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_PARISC_EXT
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".PARISC.archext"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|SHT_PARISC_UNWIND
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".PARISC.unwind"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|SHT_PARISC_DOC
case|:
case|case
name|SHT_PARISC_ANNOT
case|:
default|default:
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|,
name|shindex
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|newsect
operator|=
name|hdr
operator|->
name|bfd_section
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Construct a string for use in the elf64_hppa_dyn_hash_table.  The    name describes what was once potentially anonymous memory.  We    allocate memory as necessary, possibly reusing PBUF/PLEN.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_dyn_name
parameter_list|(
name|abfd
parameter_list|,
name|h
parameter_list|,
name|rel
parameter_list|,
name|pbuf
parameter_list|,
name|plen
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|char
modifier|*
modifier|*
name|pbuf
decl_stmt|;
name|size_t
modifier|*
name|plen
decl_stmt|;
block|{
name|asection
modifier|*
name|sec
init|=
name|abfd
operator|->
name|sections
decl_stmt|;
name|size_t
name|nlen
decl_stmt|,
name|tlen
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|h
operator|&&
name|rel
operator|->
name|r_addend
operator|==
literal|0
condition|)
return|return
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
return|;
if|if
condition|(
name|h
condition|)
name|nlen
operator|=
name|strlen
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
else|else
name|nlen
operator|=
literal|8
operator|+
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|*
literal|2
operator|-
literal|8
expr_stmt|;
name|tlen
operator|=
name|nlen
operator|+
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|rel
operator|->
name|r_addend
argument_list|)
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
name|len
operator|=
operator|*
name|plen
expr_stmt|;
name|buf
operator|=
operator|*
name|pbuf
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|tlen
condition|)
block|{
if|if
condition|(
name|buf
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|*
name|pbuf
operator|=
name|buf
operator|=
name|malloc
argument_list|(
name|tlen
argument_list|)
expr_stmt|;
operator|*
name|plen
operator|=
name|len
operator|=
name|tlen
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|h
condition|)
block|{
name|memcpy
argument_list|(
name|buf
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|buf
index|[
name|nlen
operator|++
index|]
operator|=
literal|'+'
expr_stmt|;
name|sprintf_vma
argument_list|(
name|buf
operator|+
name|nlen
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nlen
operator|=
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%x:%lx"
argument_list|,
name|sec
operator|->
name|id
operator|&
literal|0xffffffff
argument_list|,
operator|(
name|long
operator|)
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rel
operator|->
name|r_addend
condition|)
block|{
name|buf
index|[
name|nlen
operator|++
index|]
operator|=
literal|'+'
expr_stmt|;
name|sprintf_vma
argument_list|(
name|buf
operator|+
name|nlen
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* SEC is a section containing relocs for an input BFD when linking; return    a suitable section for holding relocs in the output BFD for a link.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|get_reloc_section
parameter_list|(
name|abfd
parameter_list|,
name|hppa_info
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|elf64_hppa_link_hash_table
modifier|*
name|hppa_info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|srel_name
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|srel_name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|srel_name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|BFD_ASSERT
argument_list|(
operator|(
name|strncmp
argument_list|(
name|srel_name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|srel_name
operator|+
literal|5
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|srel_name
argument_list|,
literal|".rel"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|srel_name
operator|+
literal|4
argument_list|)
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|hppa_info
operator|->
name|root
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
operator|!
name|dynobj
condition|)
name|hppa_info
operator|->
name|root
operator|.
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|srel_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|srel
operator|==
name|NULL
condition|)
block|{
name|srel
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
name|srel_name
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|srel
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|srel
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|hppa_info
operator|->
name|other_rel_sec
operator|=
name|srel
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Add a new entry to the list of dynamic relocations against DYN_H.     We use this to keep a record of all the FPTR relocations against a    particular symbol so that we can create FPTR relocations in the    output file.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|count_dyn_reloc
parameter_list|(
name|abfd
parameter_list|,
name|dyn_h
parameter_list|,
name|type
parameter_list|,
name|sec
parameter_list|,
name|sec_symndx
parameter_list|,
name|offset
parameter_list|,
name|addend
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|elf64_hppa_dyn_hash_entry
modifier|*
name|dyn_h
decl_stmt|;
name|int
name|type
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|int
name|sec_symndx
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
block|{
name|struct
name|elf64_hppa_dyn_reloc_entry
modifier|*
name|rent
decl_stmt|;
name|rent
operator|=
operator|(
expr|struct
name|elf64_hppa_dyn_reloc_entry
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
operator|*
name|rent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rent
condition|)
return|return
name|FALSE
return|;
name|rent
operator|->
name|next
operator|=
name|dyn_h
operator|->
name|reloc_entries
expr_stmt|;
name|rent
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|rent
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
name|rent
operator|->
name|sec_symndx
operator|=
name|sec_symndx
expr_stmt|;
name|rent
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|rent
operator|->
name|addend
operator|=
name|addend
expr_stmt|;
name|dyn_h
operator|->
name|reloc_entries
operator|=
name|rent
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Scan the RELOCS and record the type of dynamic entries that each    referenced symbol needs.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_hppa_check_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|struct
name|elf64_hppa_link_hash_table
modifier|*
name|hppa_info
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|asection
modifier|*
name|dlt
decl_stmt|,
modifier|*
name|plt
decl_stmt|,
modifier|*
name|stubs
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|buf_len
decl_stmt|;
name|int
name|sec_symndx
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
comment|/* If this is the first dynamic object found in the link, create      the special sections required for dynamic linking.  */
if|if
condition|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_link_create_dynamic_sections
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|hppa_info
operator|=
name|elf64_hppa_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
comment|/* If necessary, build a new table holding section symbols indices      for this BFD.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
name|hppa_info
operator|->
name|section_syms_bfd
operator|!=
name|abfd
condition|)
block|{
name|unsigned
name|long
name|i
decl_stmt|;
name|unsigned
name|int
name|highest_shndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|,
modifier|*
name|isymend
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* We're done with the old cache of section index to section symbol 	 index information.  Free it.  	 ?!? Note we leak the last section_syms array.  Presumably we 	 could free it in one of the later routines in this file.  */
if|if
condition|(
name|hppa_info
operator|->
name|section_syms
condition|)
name|free
argument_list|(
name|hppa_info
operator|->
name|section_syms
argument_list|)
expr_stmt|;
comment|/* Read this BFD's local symbols.  */
if|if
condition|(
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|local_syms
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|local_syms
operator|==
name|NULL
condition|)
name|local_syms
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_syms
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Record the highest section index referenced by the local symbols.  */
name|highest_shndx
operator|=
literal|0
expr_stmt|;
name|isymend
operator|=
name|local_syms
operator|+
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
name|isym
operator|=
name|local_syms
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
control|)
block|{
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|>
name|highest_shndx
condition|)
name|highest_shndx
operator|=
name|isym
operator|->
name|st_shndx
expr_stmt|;
block|}
comment|/* Allocate an array to hold the section index to section symbol index 	 mapping.  Bump by one since we start counting at zero.  */
name|highest_shndx
operator|++
expr_stmt|;
name|amt
operator|=
name|highest_shndx
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|hppa_info
operator|->
name|section_syms
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
comment|/* Now walk the local symbols again.  If we find a section symbol, 	 record the index of the symbol into the section_syms array.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|isym
operator|=
name|local_syms
init|;
name|isym
operator|<
name|isymend
condition|;
name|i
operator|++
operator|,
name|isym
operator|++
control|)
block|{
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
name|hppa_info
operator|->
name|section_syms
index|[
name|isym
operator|->
name|st_shndx
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|/* We are finished with the local symbols.  */
if|if
condition|(
name|local_syms
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|local_syms
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the symbols for elf_link_input_bfd.  */
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
expr_stmt|;
block|}
block|}
comment|/* Record which BFD we built the section_syms mapping for.  */
name|hppa_info
operator|->
name|section_syms_bfd
operator|=
name|abfd
expr_stmt|;
block|}
comment|/* Record the symbol index for this input section.  We may need it for      relocations when building shared libraries.  When not building shared      libraries this value is never really used, but assign it to zero to      prevent out of bounds memory accesses in other routines.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|sec_symndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
comment|/* If we did not find a section symbol for this section, then 	 something went terribly wrong above.  */
if|if
condition|(
name|sec_symndx
operator|==
operator|-
literal|1
condition|)
return|return
name|FALSE
return|;
name|sec_symndx
operator|=
name|hppa_info
operator|->
name|section_syms
index|[
name|sec_symndx
index|]
expr_stmt|;
block|}
else|else
name|sec_symndx
operator|=
literal|0
expr_stmt|;
name|dlt
operator|=
name|plt
operator|=
name|stubs
operator|=
name|NULL
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
name|buf_len
operator|=
literal|0
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
operator|++
name|rel
control|)
block|{
enum|enum
block|{
name|NEED_DLT
init|=
literal|1
block|,
name|NEED_PLT
init|=
literal|2
block|,
name|NEED_STUB
init|=
literal|4
block|,
name|NEED_OPD
init|=
literal|8
block|,
name|NEED_DYNREL
init|=
literal|16
block|, 	}
enum|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|r_symndx
init|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|struct
name|elf64_hppa_dyn_hash_entry
modifier|*
name|dyn_h
decl_stmt|;
name|int
name|need_entry
decl_stmt|;
specifier|const
name|char
modifier|*
name|addr_name
decl_stmt|;
name|bfd_boolean
name|maybe_dynamic
decl_stmt|;
name|int
name|dynrel_type
init|=
name|R_PARISC_NONE
decl_stmt|;
specifier|static
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* We're dealing with a global symbol -- find its hash entry 	     and mark it as being referenced.  */
name|long
name|indx
init|=
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
decl_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|h
operator|->
name|ref_regular
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We can only get preliminary data on whether a symbol is 	 locally or externally defined, as not all of the input files 	 have yet been processed.  Do something with what we know, as 	 this may help reduce memory usage and processing time later.  */
name|maybe_dynamic
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|h
operator|&&
operator|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
name|info
operator|->
name|unresolved_syms_in_shared_libs
operator|==
name|RM_IGNORE
operator|)
operator|)
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
name|maybe_dynamic
operator|=
name|TRUE
expr_stmt|;
name|howto
operator|=
name|elf_hppa_howto_table
operator|+
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|need_entry
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|howto
operator|->
name|type
condition|)
block|{
comment|/* These are simple indirect references to symbols through the 	   DLT.  We need to create a DLT entry for any symbols which 	   appears in a DLTIND relocation.  */
case|case
name|R_PARISC_DLTIND21L
case|:
case|case
name|R_PARISC_DLTIND14R
case|:
case|case
name|R_PARISC_DLTIND14F
case|:
case|case
name|R_PARISC_DLTIND14WR
case|:
case|case
name|R_PARISC_DLTIND14DR
case|:
name|need_entry
operator|=
name|NEED_DLT
expr_stmt|;
break|break;
comment|/* ?!?  These need a DLT entry.  But I have no idea what to do with 	   the "link time TP value.  */
case|case
name|R_PARISC_LTOFF_TP21L
case|:
case|case
name|R_PARISC_LTOFF_TP14R
case|:
case|case
name|R_PARISC_LTOFF_TP14F
case|:
case|case
name|R_PARISC_LTOFF_TP64
case|:
case|case
name|R_PARISC_LTOFF_TP14WR
case|:
case|case
name|R_PARISC_LTOFF_TP14DR
case|:
case|case
name|R_PARISC_LTOFF_TP16F
case|:
case|case
name|R_PARISC_LTOFF_TP16WF
case|:
case|case
name|R_PARISC_LTOFF_TP16DF
case|:
name|need_entry
operator|=
name|NEED_DLT
expr_stmt|;
break|break;
comment|/* These are function calls.  Depending on their precise target we 	   may need to make a stub for them.  The stub uses the PLT, so we 	   need to create PLT entries for these symbols too.  */
case|case
name|R_PARISC_PCREL12F
case|:
case|case
name|R_PARISC_PCREL17F
case|:
case|case
name|R_PARISC_PCREL22F
case|:
case|case
name|R_PARISC_PCREL32
case|:
case|case
name|R_PARISC_PCREL64
case|:
case|case
name|R_PARISC_PCREL21L
case|:
case|case
name|R_PARISC_PCREL17R
case|:
case|case
name|R_PARISC_PCREL17C
case|:
case|case
name|R_PARISC_PCREL14R
case|:
case|case
name|R_PARISC_PCREL14F
case|:
case|case
name|R_PARISC_PCREL22C
case|:
case|case
name|R_PARISC_PCREL14WR
case|:
case|case
name|R_PARISC_PCREL14DR
case|:
case|case
name|R_PARISC_PCREL16F
case|:
case|case
name|R_PARISC_PCREL16WF
case|:
case|case
name|R_PARISC_PCREL16DF
case|:
name|need_entry
operator|=
operator|(
name|NEED_PLT
operator||
name|NEED_STUB
operator|)
expr_stmt|;
break|break;
case|case
name|R_PARISC_PLTOFF21L
case|:
case|case
name|R_PARISC_PLTOFF14R
case|:
case|case
name|R_PARISC_PLTOFF14F
case|:
case|case
name|R_PARISC_PLTOFF14WR
case|:
case|case
name|R_PARISC_PLTOFF14DR
case|:
case|case
name|R_PARISC_PLTOFF16F
case|:
case|case
name|R_PARISC_PLTOFF16WF
case|:
case|case
name|R_PARISC_PLTOFF16DF
case|:
name|need_entry
operator|=
operator|(
name|NEED_PLT
operator|)
expr_stmt|;
break|break;
case|case
name|R_PARISC_DIR64
case|:
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|maybe_dynamic
condition|)
name|need_entry
operator|=
operator|(
name|NEED_DYNREL
operator|)
expr_stmt|;
name|dynrel_type
operator|=
name|R_PARISC_DIR64
expr_stmt|;
break|break;
comment|/* This is an indirect reference through the DLT to get the address 	   of a OPD descriptor.  Thus we need to make a DLT entry that points 	   to an OPD entry.  */
case|case
name|R_PARISC_LTOFF_FPTR21L
case|:
case|case
name|R_PARISC_LTOFF_FPTR14R
case|:
case|case
name|R_PARISC_LTOFF_FPTR14WR
case|:
case|case
name|R_PARISC_LTOFF_FPTR14DR
case|:
case|case
name|R_PARISC_LTOFF_FPTR32
case|:
case|case
name|R_PARISC_LTOFF_FPTR64
case|:
case|case
name|R_PARISC_LTOFF_FPTR16F
case|:
case|case
name|R_PARISC_LTOFF_FPTR16WF
case|:
case|case
name|R_PARISC_LTOFF_FPTR16DF
case|:
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|maybe_dynamic
condition|)
name|need_entry
operator|=
operator|(
name|NEED_DLT
operator||
name|NEED_OPD
operator|)
expr_stmt|;
else|else
name|need_entry
operator|=
operator|(
name|NEED_DLT
operator||
name|NEED_OPD
operator|)
expr_stmt|;
name|dynrel_type
operator|=
name|R_PARISC_FPTR64
expr_stmt|;
break|break;
comment|/* This is a simple OPD entry.  */
case|case
name|R_PARISC_FPTR64
case|:
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|maybe_dynamic
condition|)
name|need_entry
operator|=
operator|(
name|NEED_OPD
operator||
name|NEED_DYNREL
operator|)
expr_stmt|;
else|else
name|need_entry
operator|=
operator|(
name|NEED_OPD
operator|)
expr_stmt|;
name|dynrel_type
operator|=
name|R_PARISC_FPTR64
expr_stmt|;
break|break;
comment|/* Add more cases as needed.  */
block|}
if|if
condition|(
operator|!
name|need_entry
condition|)
continue|continue;
comment|/* Collect a canonical name for this address.  */
name|addr_name
operator|=
name|get_dyn_name
argument_list|(
name|abfd
argument_list|,
name|h
argument_list|,
name|rel
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|buf_len
argument_list|)
expr_stmt|;
comment|/* Collect the canonical entry data for this address.  */
name|dyn_h
operator|=
name|elf64_hppa_dyn_hash_lookup
argument_list|(
operator|&
name|hppa_info
operator|->
name|dyn_hash_table
argument_list|,
name|addr_name
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dyn_h
argument_list|)
expr_stmt|;
comment|/* Stash away enough information to be able to find this symbol 	 regardless of whether or not it is local or global.  */
name|dyn_h
operator|->
name|h
operator|=
name|h
expr_stmt|;
name|dyn_h
operator|->
name|owner
operator|=
name|abfd
expr_stmt|;
name|dyn_h
operator|->
name|sym_indx
operator|=
name|r_symndx
expr_stmt|;
comment|/* ?!? We may need to do some error checking in here.  */
comment|/* Create what's needed.  */
if|if
condition|(
name|need_entry
operator|&
name|NEED_DLT
condition|)
block|{
if|if
condition|(
operator|!
name|hppa_info
operator|->
name|dlt_sec
operator|&&
operator|!
name|get_dlt
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|hppa_info
argument_list|)
condition|)
goto|goto
name|err_out
goto|;
name|dyn_h
operator|->
name|want_dlt
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|need_entry
operator|&
name|NEED_PLT
condition|)
block|{
if|if
condition|(
operator|!
name|hppa_info
operator|->
name|plt_sec
operator|&&
operator|!
name|get_plt
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|hppa_info
argument_list|)
condition|)
goto|goto
name|err_out
goto|;
name|dyn_h
operator|->
name|want_plt
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|need_entry
operator|&
name|NEED_STUB
condition|)
block|{
if|if
condition|(
operator|!
name|hppa_info
operator|->
name|stub_sec
operator|&&
operator|!
name|get_stub
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|hppa_info
argument_list|)
condition|)
goto|goto
name|err_out
goto|;
name|dyn_h
operator|->
name|want_stub
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|need_entry
operator|&
name|NEED_OPD
condition|)
block|{
if|if
condition|(
operator|!
name|hppa_info
operator|->
name|opd_sec
operator|&&
operator|!
name|get_opd
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|hppa_info
argument_list|)
condition|)
goto|goto
name|err_out
goto|;
name|dyn_h
operator|->
name|want_opd
operator|=
literal|1
expr_stmt|;
comment|/* FPTRs are not allocated by the dynamic linker for PA64, though 	     it is possible that will change in the future.  */
comment|/* This could be a local function that had its address taken, in 	     which case H will be NULL.  */
if|if
condition|(
name|h
condition|)
name|h
operator|->
name|needs_plt
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Add a new dynamic relocation to the chain of dynamic 	 relocations for this symbol.  */
if|if
condition|(
operator|(
name|need_entry
operator|&
name|NEED_DYNREL
operator|)
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|hppa_info
operator|->
name|other_rel_sec
operator|&&
operator|!
name|get_reloc_section
argument_list|(
name|abfd
argument_list|,
name|hppa_info
argument_list|,
name|sec
argument_list|)
condition|)
goto|goto
name|err_out
goto|;
if|if
condition|(
operator|!
name|count_dyn_reloc
argument_list|(
name|abfd
argument_list|,
name|dyn_h
argument_list|,
name|dynrel_type
argument_list|,
name|sec
argument_list|,
name|sec_symndx
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
goto|goto
name|err_out
goto|;
comment|/* If we are building a shared library and we just recorded 	     a dynamic R_PARISC_FPTR64 relocation, then make sure the 	     section symbol for this section ends up in the dynamic 	     symbol table.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
name|dynrel_type
operator|==
name|R_PARISC_FPTR64
operator|&&
operator|!
operator|(
name|bfd_elf_link_record_local_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|sec_symndx
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|buf
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|err_out
label|:
if|if
condition|(
name|buf
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_struct
struct|struct
name|elf64_hppa_allocate_data
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd_size_type
name|ofs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Should we do dynamic things to this symbol?  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_hppa_dynamic_symbol_p
parameter_list|(
name|h
parameter_list|,
name|info
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
comment|/* ??? What, if anything, needs to happen wrt STV_PROTECTED symbols      and relocations that retrieve a function descriptor?  Assume the      worst for now.  */
if|if
condition|(
name|_bfd_elf_dynamic_symbol_p
argument_list|(
name|h
argument_list|,
name|info
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* ??? Why is this here and not elsewhere is_local_label_name.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
index|[
literal|1
index|]
operator|==
literal|'$'
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
else|else
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Mark all functions exported by this file so that we can later allocate    entries in .opd for them.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_hppa_mark_exported_functions
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|elf64_hppa_link_hash_table
modifier|*
name|hppa_info
decl_stmt|;
name|hppa_info
operator|=
name|elf64_hppa_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|type
operator|==
name|STT_FUNC
condition|)
block|{
name|struct
name|elf64_hppa_dyn_hash_entry
modifier|*
name|dyn_h
decl_stmt|;
comment|/* Add this symbol to the PA64 linker hash table.  */
name|dyn_h
operator|=
name|elf64_hppa_dyn_hash_lookup
argument_list|(
operator|&
name|hppa_info
operator|->
name|dyn_hash_table
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dyn_h
argument_list|)
expr_stmt|;
name|dyn_h
operator|->
name|h
operator|=
name|h
expr_stmt|;
if|if
condition|(
operator|!
name|hppa_info
operator|->
name|opd_sec
operator|&&
operator|!
name|get_opd
argument_list|(
name|hppa_info
operator|->
name|root
operator|.
name|dynobj
argument_list|,
name|info
argument_list|,
name|hppa_info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|dyn_h
operator|->
name|want_opd
operator|=
literal|1
expr_stmt|;
comment|/* Put a flag here for output_symbol_hook.  */
name|dyn_h
operator|->
name|st_shndx
operator|=
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|needs_plt
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Allocate space for a DLT entry.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|allocate_global_data_dlt
parameter_list|(
name|dyn_h
parameter_list|,
name|data
parameter_list|)
name|struct
name|elf64_hppa_dyn_hash_entry
modifier|*
name|dyn_h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elf64_hppa_allocate_data
modifier|*
name|x
init|=
operator|(
expr|struct
name|elf64_hppa_allocate_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|dyn_h
operator|->
name|want_dlt
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|dyn_h
operator|->
name|h
decl_stmt|;
if|if
condition|(
name|x
operator|->
name|info
operator|->
name|shared
condition|)
block|{
comment|/* Possibly add the symbol to the local dynamic symbol 	     table since we might need to create a dynamic relocation 	     against it.  */
if|if
condition|(
operator|!
name|h
operator|||
operator|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
name|h
operator|->
name|type
operator|!=
name|STT_PARISC_MILLI
operator|)
condition|)
block|{
name|bfd
modifier|*
name|owner
decl_stmt|;
name|owner
operator|=
operator|(
name|h
condition|?
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
else|:
name|dyn_h
operator|->
name|owner
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bfd_elf_link_record_local_dynamic_symbol
argument_list|(
name|x
operator|->
name|info
argument_list|,
name|owner
argument_list|,
name|dyn_h
operator|->
name|sym_indx
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
name|dyn_h
operator|->
name|dlt_offset
operator|=
name|x
operator|->
name|ofs
expr_stmt|;
name|x
operator|->
name|ofs
operator|+=
name|DLT_ENTRY_SIZE
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Allocate space for a DLT.PLT entry.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|allocate_global_data_plt
parameter_list|(
name|dyn_h
parameter_list|,
name|data
parameter_list|)
name|struct
name|elf64_hppa_dyn_hash_entry
modifier|*
name|dyn_h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elf64_hppa_allocate_data
modifier|*
name|x
init|=
operator|(
expr|struct
name|elf64_hppa_allocate_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|dyn_h
operator|->
name|want_plt
operator|&&
name|elf64_hppa_dynamic_symbol_p
argument_list|(
name|dyn_h
operator|->
name|h
argument_list|,
name|x
operator|->
name|info
argument_list|)
operator|&&
operator|!
operator|(
operator|(
name|dyn_h
operator|->
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|dyn_h
operator|->
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|dyn_h
operator|->
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|!=
name|NULL
operator|)
condition|)
block|{
name|dyn_h
operator|->
name|plt_offset
operator|=
name|x
operator|->
name|ofs
expr_stmt|;
name|x
operator|->
name|ofs
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
if|if
condition|(
name|dyn_h
operator|->
name|plt_offset
operator|<
literal|0x2000
condition|)
name|elf64_hppa_hash_table
argument_list|(
name|x
operator|->
name|info
argument_list|)
operator|->
name|gp_offset
operator|=
name|dyn_h
operator|->
name|plt_offset
expr_stmt|;
block|}
else|else
name|dyn_h
operator|->
name|want_plt
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Allocate space for a STUB entry.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|allocate_global_data_stub
parameter_list|(
name|dyn_h
parameter_list|,
name|data
parameter_list|)
name|struct
name|elf64_hppa_dyn_hash_entry
modifier|*
name|dyn_h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elf64_hppa_allocate_data
modifier|*
name|x
init|=
operator|(
expr|struct
name|elf64_hppa_allocate_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|dyn_h
operator|->
name|want_stub
operator|&&
name|elf64_hppa_dynamic_symbol_p
argument_list|(
name|dyn_h
operator|->
name|h
argument_list|,
name|x
operator|->
name|info
argument_list|)
operator|&&
operator|!
operator|(
operator|(
name|dyn_h
operator|->
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|dyn_h
operator|->
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|dyn_h
operator|->
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|!=
name|NULL
operator|)
condition|)
block|{
name|dyn_h
operator|->
name|stub_offset
operator|=
name|x
operator|->
name|ofs
expr_stmt|;
name|x
operator|->
name|ofs
operator|+=
sizeof|sizeof
argument_list|(
name|plt_stub
argument_list|)
expr_stmt|;
block|}
else|else
name|dyn_h
operator|->
name|want_stub
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Allocate space for a FPTR entry.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|allocate_global_data_opd
parameter_list|(
name|dyn_h
parameter_list|,
name|data
parameter_list|)
name|struct
name|elf64_hppa_dyn_hash_entry
modifier|*
name|dyn_h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elf64_hppa_allocate_data
modifier|*
name|x
init|=
operator|(
expr|struct
name|elf64_hppa_allocate_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|dyn_h
operator|->
name|want_opd
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|dyn_h
operator|->
name|h
decl_stmt|;
if|if
condition|(
name|h
condition|)
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* We never need an opd entry for a symbol which is not 	 defined by this output file.  */
if|if
condition|(
name|h
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|==
name|NULL
operator|)
condition|)
name|dyn_h
operator|->
name|want_opd
operator|=
literal|0
expr_stmt|;
comment|/* If we are creating a shared library, took the address of a local 	 function or might export this function from this object file, then 	 we have to create an opd descriptor.  */
elseif|else
if|if
condition|(
name|x
operator|->
name|info
operator|->
name|shared
operator|||
name|h
operator|==
name|NULL
operator|||
operator|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
name|h
operator|->
name|type
operator|!=
name|STT_PARISC_MILLI
operator|)
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
comment|/* If we are creating a shared library, then we will have to 	     create a runtime relocation for the symbol to properly 	     initialize the .opd entry.  Make sure the symbol gets 	     added to the dynamic symbol table.  */
if|if
condition|(
name|x
operator|->
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
operator|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|bfd
modifier|*
name|owner
decl_stmt|;
name|owner
operator|=
operator|(
name|h
condition|?
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
else|:
name|dyn_h
operator|->
name|owner
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_elf_link_record_local_dynamic_symbol
argument_list|(
name|x
operator|->
name|info
argument_list|,
name|owner
argument_list|,
name|dyn_h
operator|->
name|sym_indx
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* This may not be necessary or desirable anymore now that 	     we have some support for dealing with section symbols 	     in dynamic relocs.  But name munging does make the result 	     much easier to debug.  ie, the EPLT reloc will reference 	     a symbol like .foobar, instead of .text + offset.  */
if|if
condition|(
name|x
operator|->
name|info
operator|->
name|shared
operator|&&
name|h
condition|)
block|{
name|char
modifier|*
name|new_name
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|nh
decl_stmt|;
name|new_name
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|new_name
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|strcpy
argument_list|(
name|new_name
operator|+
literal|1
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|nh
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|x
operator|->
name|info
argument_list|)
argument_list|,
name|new_name
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|nh
operator|->
name|root
operator|.
name|type
operator|=
name|h
operator|->
name|root
operator|.
name|type
expr_stmt|;
name|nh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|nh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|x
operator|->
name|info
argument_list|,
name|nh
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|dyn_h
operator|->
name|opd_offset
operator|=
name|x
operator|->
name|ofs
expr_stmt|;
name|x
operator|->
name|ofs
operator|+=
name|OPD_ENTRY_SIZE
expr_stmt|;
block|}
comment|/* Otherwise we do not need an opd entry.  */
else|else
name|dyn_h
operator|->
name|want_opd
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* HP requires the EI_OSABI field to be filled in.  The assignment to    EI_ABIVERSION may not be strictly necessary.  */
end_comment

begin_function
specifier|static
name|void
name|elf64_hppa_post_process_headers
parameter_list|(
name|abfd
parameter_list|,
name|link_info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_target
argument_list|(
name|abfd
argument_list|)
argument_list|,
literal|"elf64-hppa-linux"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|=
name|ELFOSABI_LINUX
expr_stmt|;
block|}
else|else
block|{
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|=
name|ELFOSABI_HPUX
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_ABIVERSION
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create function descriptor section (.opd).  This section is called .opd    because it contains "official procedure descriptors".  The "official"    refers to the fact that these descriptors are used when taking the address    of a procedure, thus ensuring a unique address for each procedure.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|get_opd
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|hppa_info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|elf64_hppa_link_hash_table
modifier|*
name|hppa_info
decl_stmt|;
block|{
name|asection
modifier|*
name|opd
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|opd
operator|=
name|hppa_info
operator|->
name|opd_sec
expr_stmt|;
if|if
condition|(
operator|!
name|opd
condition|)
block|{
name|dynobj
operator|=
name|hppa_info
operator|->
name|root
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
operator|!
name|dynobj
condition|)
name|hppa_info
operator|->
name|root
operator|.
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
name|opd
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
literal|".opd"
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opd
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|opd
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|hppa_info
operator|->
name|opd_sec
operator|=
name|opd
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create the PLT section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|get_plt
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|hppa_info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|elf64_hppa_link_hash_table
modifier|*
name|hppa_info
decl_stmt|;
block|{
name|asection
modifier|*
name|plt
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|plt
operator|=
name|hppa_info
operator|->
name|plt_sec
expr_stmt|;
if|if
condition|(
operator|!
name|plt
condition|)
block|{
name|dynobj
operator|=
name|hppa_info
operator|->
name|root
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
operator|!
name|dynobj
condition|)
name|hppa_info
operator|->
name|root
operator|.
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
name|plt
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|plt
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|plt
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|hppa_info
operator|->
name|plt_sec
operator|=
name|plt
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create the DLT section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|get_dlt
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|hppa_info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|elf64_hppa_link_hash_table
modifier|*
name|hppa_info
decl_stmt|;
block|{
name|asection
modifier|*
name|dlt
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|dlt
operator|=
name|hppa_info
operator|->
name|dlt_sec
expr_stmt|;
if|if
condition|(
operator|!
name|dlt
condition|)
block|{
name|dynobj
operator|=
name|hppa_info
operator|->
name|root
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
operator|!
name|dynobj
condition|)
name|hppa_info
operator|->
name|root
operator|.
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
name|dlt
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
literal|".dlt"
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dlt
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|dlt
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|hppa_info
operator|->
name|dlt_sec
operator|=
name|dlt
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create the stubs section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|get_stub
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|hppa_info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|elf64_hppa_link_hash_table
modifier|*
name|hppa_info
decl_stmt|;
block|{
name|asection
modifier|*
name|stub
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|stub
operator|=
name|hppa_info
operator|->
name|stub_sec
expr_stmt|;
if|if
condition|(
operator|!
name|stub
condition|)
block|{
name|dynobj
operator|=
name|hppa_info
operator|->
name|root
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
operator|!
name|dynobj
condition|)
name|hppa_info
operator|->
name|root
operator|.
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
name|stub
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
literal|".stub"
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_READONLY
operator||
name|SEC_LINKER_CREATED
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stub
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|stub
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|hppa_info
operator|->
name|stub_sec
operator|=
name|stub
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create sections necessary for dynamic linking.  This is only a rough    cut and will likely change as we learn more about the somewhat    unusual dynamic linking scheme HP uses.     .stub: 	Contains code to implement cross-space calls.  The first time one 	of the stubs is used it will call into the dynamic linker, later 	calls will go straight to the target.  	The only stub we support right now looks like  	ldd OFFSET(%dp),%r1 	bve %r0(%r1) 	ldd OFFSET+8(%dp),%dp  	Other stubs may be needed in the future.  We may want the remove 	the break/nop instruction.  It is only used right now to keep the 	offset of a .plt entry and a .stub entry in sync.     .dlt: 	This is what most people call the .got.  HP used a different name. 	Losers.     .rela.dlt: 	Relocations for the DLT.     .plt: 	Function pointers as address,gp pairs.     .rela.plt: 	Should contain dynamic IPLT (and EPLT?) relocations.     .opd: 	FPTRS     .rela.opd: 	EPLT relocations for symbols exported from shared libraries.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_hppa_create_dynamic_sections
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|get_stub
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|elf64_hppa_hash_table
argument_list|(
name|info
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|get_dlt
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|elf64_hppa_hash_table
argument_list|(
name|info
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|get_plt
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|elf64_hppa_hash_table
argument_list|(
name|info
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|get_opd
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|elf64_hppa_hash_table
argument_list|(
name|info
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".rela.dlt"
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_READONLY
operator||
name|SEC_LINKER_CREATED
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|elf64_hppa_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dlt_rel_sec
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".rela.plt"
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_READONLY
operator||
name|SEC_LINKER_CREATED
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|elf64_hppa_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|plt_rel_sec
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".rela.data"
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_READONLY
operator||
name|SEC_LINKER_CREATED
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|elf64_hppa_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|other_rel_sec
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".rela.opd"
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_READONLY
operator||
name|SEC_LINKER_CREATED
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|elf64_hppa_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|opd_rel_sec
operator|=
name|s
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Allocate dynamic relocations for those symbols that turned out    to be dynamic.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|allocate_dynrel_entries
parameter_list|(
name|dyn_h
parameter_list|,
name|data
parameter_list|)
name|struct
name|elf64_hppa_dyn_hash_entry
modifier|*
name|dyn_h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|elf64_hppa_allocate_data
modifier|*
name|x
init|=
operator|(
expr|struct
name|elf64_hppa_allocate_data
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|elf64_hppa_link_hash_table
modifier|*
name|hppa_info
decl_stmt|;
name|struct
name|elf64_hppa_dyn_reloc_entry
modifier|*
name|rent
decl_stmt|;
name|bfd_boolean
name|dynamic_symbol
decl_stmt|,
name|shared
decl_stmt|;
name|hppa_info
operator|=
name|elf64_hppa_hash_table
argument_list|(
name|x
operator|->
name|info
argument_list|)
expr_stmt|;
name|dynamic_symbol
operator|=
name|elf64_hppa_dynamic_symbol_p
argument_list|(
name|dyn_h
operator|->
name|h
argument_list|,
name|x
operator|->
name|info
argument_list|)
expr_stmt|;
name|shared
operator|=
name|x
operator|->
name|info
operator|->
name|shared
expr_stmt|;
comment|/* We may need to allocate relocations for a non-dynamic symbol      when creating a shared library.  */
if|if
condition|(
operator|!
name|dynamic_symbol
operator|&&
operator|!
name|shared
condition|)
return|return
name|TRUE
return|;
comment|/* Take care of the normal data relocations.  */
for|for
control|(
name|rent
operator|=
name|dyn_h
operator|->
name|reloc_entries
init|;
name|rent
condition|;
name|rent
operator|=
name|rent
operator|->
name|next
control|)
block|{
comment|/* Allocate one iff we are building a shared library, the relocation 	 isn't a R_PARISC_FPTR64, or we don't want an opd entry.  */
if|if
condition|(
operator|!
name|shared
operator|&&
name|rent
operator|->
name|type
operator|==
name|R_PARISC_FPTR64
operator|&&
name|dyn_h
operator|->
name|want_opd
condition|)
continue|continue;
name|hppa_info
operator|->
name|other_rel_sec
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
comment|/* Make sure this symbol gets into the dynamic symbol table if it is 	 not already recorded.  ?!? This should not be in the loop since 	 the symbol need only be added once.  */
if|if
condition|(
name|dyn_h
operator|->
name|h
operator|==
literal|0
operator|||
operator|(
name|dyn_h
operator|->
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
name|dyn_h
operator|->
name|h
operator|->
name|type
operator|!=
name|STT_PARISC_MILLI
operator|)
condition|)
if|if
condition|(
operator|!
name|bfd_elf_link_record_local_dynamic_symbol
argument_list|(
name|x
operator|->
name|info
argument_list|,
name|rent
operator|->
name|sec
operator|->
name|owner
argument_list|,
name|dyn_h
operator|->
name|sym_indx
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Take care of the GOT and PLT relocations.  */
if|if
condition|(
operator|(
name|dynamic_symbol
operator|||
name|shared
operator|)
operator|&&
name|dyn_h
operator|->
name|want_dlt
condition|)
name|hppa_info
operator|->
name|dlt_rel_sec
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
comment|/* If we are building a shared library, then every symbol that has an      opd entry will need an EPLT relocation to relocate the symbol's address      and __gp value based on the runtime load address.  */
if|if
condition|(
name|shared
operator|&&
name|dyn_h
operator|->
name|want_opd
condition|)
name|hppa_info
operator|->
name|opd_rel_sec
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyn_h
operator|->
name|want_plt
operator|&&
name|dynamic_symbol
condition|)
block|{
name|bfd_size_type
name|t
init|=
literal|0
decl_stmt|;
comment|/* Dynamic symbols get one IPLT relocation.  Local symbols in 	 shared libraries get two REL relocations.  Local symbols in 	 main applications get nothing.  */
if|if
condition|(
name|dynamic_symbol
condition|)
name|t
operator|=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|shared
condition|)
name|t
operator|=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|hppa_info
operator|->
name|plt_rel_sec
operator|->
name|size
operator|+=
name|t
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_hppa_adjust_dynamic_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
comment|/* ??? Undefined symbols with PLT entries should be re-defined      to be the PLT entry.  */
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* If this is a reference to a symbol defined by a dynamic object which      is not a function, we might allocate the symbol in our .dynbss section      and allocate a COPY dynamic relocation.       But PA64 code is canonically PIC, so as a rule we can avoid this sort      of hackery.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This function is called via elf_link_hash_traverse to mark millicode    symbols with a dynindx of -1 and to remove the string table reference    from the dynamic symbol table.  If the symbol is not a millicode symbol,    elf64_hppa_mark_exported_functions is called.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_hppa_mark_milli_and_exported_functions
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|elf
init|=
name|h
decl_stmt|;
if|if
condition|(
name|elf
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|elf
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|elf
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|elf
operator|->
name|type
operator|==
name|STT_PARISC_MILLI
condition|)
block|{
if|if
condition|(
name|elf
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
block|{
name|elf
operator|->
name|dynindx
operator|=
operator|-
literal|1
expr_stmt|;
name|_bfd_elf_strtab_delref
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|elf
operator|->
name|dynstr_index
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
return|return
name|elf64_hppa_mark_exported_functions
argument_list|(
name|h
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set the final sizes of the dynamic sections and allocate memory for    the contents of our special sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_hppa_size_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_boolean
name|plt
decl_stmt|;
name|bfd_boolean
name|relocs
decl_stmt|;
name|bfd_boolean
name|reltext
decl_stmt|;
name|struct
name|elf64_hppa_allocate_data
name|data
decl_stmt|;
name|struct
name|elf64_hppa_link_hash_table
modifier|*
name|hppa_info
decl_stmt|;
name|hppa_info
operator|=
name|elf64_hppa_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Mark each function this program exports so that we will allocate      space in the .opd section for each function's FPTR.  If we are      creating dynamic sections, change the dynamic index of millicode      symbols to -1 and remove them from the string table for .dynstr.       We have to traverse the main linker hash table since we have to      find functions which may not have been mentioned in any relocs.  */
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
operator|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|?
name|elf64_hppa_mark_milli_and_exported_functions
else|:
name|elf64_hppa_mark_exported_functions
operator|)
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We may have created entries in the .rela.got section. 	 However, if we are not creating the dynamic sections, we will 	 not actually use these entries.  Reset the size of .rela.dlt, 	 which will cause it to get stripped from the output file 	 below.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.dlt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|s
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Allocate the GOT entries.  */
name|data
operator|.
name|info
operator|=
name|info
expr_stmt|;
if|if
condition|(
name|elf64_hppa_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dlt_sec
condition|)
block|{
name|data
operator|.
name|ofs
operator|=
literal|0x0
expr_stmt|;
name|elf64_hppa_dyn_hash_traverse
argument_list|(
operator|&
name|hppa_info
operator|->
name|dyn_hash_table
argument_list|,
name|allocate_global_data_dlt
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|hppa_info
operator|->
name|dlt_sec
operator|->
name|size
operator|=
name|data
operator|.
name|ofs
expr_stmt|;
name|data
operator|.
name|ofs
operator|=
literal|0x0
expr_stmt|;
name|elf64_hppa_dyn_hash_traverse
argument_list|(
operator|&
name|hppa_info
operator|->
name|dyn_hash_table
argument_list|,
name|allocate_global_data_plt
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|hppa_info
operator|->
name|plt_sec
operator|->
name|size
operator|=
name|data
operator|.
name|ofs
expr_stmt|;
name|data
operator|.
name|ofs
operator|=
literal|0x0
expr_stmt|;
name|elf64_hppa_dyn_hash_traverse
argument_list|(
operator|&
name|hppa_info
operator|->
name|dyn_hash_table
argument_list|,
name|allocate_global_data_stub
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|hppa_info
operator|->
name|stub_sec
operator|->
name|size
operator|=
name|data
operator|.
name|ofs
expr_stmt|;
block|}
comment|/* Allocate space for entries in the .opd section.  */
if|if
condition|(
name|elf64_hppa_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|opd_sec
condition|)
block|{
name|data
operator|.
name|ofs
operator|=
literal|0
expr_stmt|;
name|elf64_hppa_dyn_hash_traverse
argument_list|(
operator|&
name|hppa_info
operator|->
name|dyn_hash_table
argument_list|,
name|allocate_global_data_opd
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|hppa_info
operator|->
name|opd_sec
operator|->
name|size
operator|=
name|data
operator|.
name|ofs
expr_stmt|;
block|}
comment|/* Now allocate space for dynamic relocations, if necessary.  */
if|if
condition|(
name|hppa_info
operator|->
name|root
operator|.
name|dynamic_sections_created
condition|)
name|elf64_hppa_dyn_hash_traverse
argument_list|(
operator|&
name|hppa_info
operator|->
name|dyn_hash_table
argument_list|,
name|allocate_dynrel_entries
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
comment|/* The sizes of all the sections are set.  Allocate memory for them.  */
name|plt
operator|=
name|FALSE
expr_stmt|;
name|relocs
operator|=
name|FALSE
expr_stmt|;
name|reltext
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* It's OK to base decisions on the section name, because none 	 of the dynobj section names depend upon the input files.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".plt"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Remember whether there is a PLT.  */
name|plt
operator|=
name|s
operator|->
name|size
operator|!=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".opd"
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".dlt"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".stub"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".got"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Strip this section if we don't need it; see the comment below.  */
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|target
decl_stmt|;
comment|/* Remember whether there are any reloc sections other 		 than .rela.plt.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rela.plt"
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|outname
decl_stmt|;
name|relocs
operator|=
name|TRUE
expr_stmt|;
comment|/* If this relocation section applies to a read only 		     section, then we probably need a DT_TEXTREL 		     entry.  The entries in the .rela.plt section 		     really apply to the .got section, which we 		     created ourselves and so know is not readonly.  */
name|outname
operator|=
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|output_section
argument_list|)
expr_stmt|;
name|target
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|outname
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|NULL
operator|&&
operator|(
name|target
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|target
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|reltext
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* We use the reloc_count field as a counter if we need 		 to copy relocs into the output file.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
block|{
comment|/* If we don't need this section, strip it from the 	     output file.  This is mostly to handle .rela.bss and 	     .rela.plt.  We must create both sections in 	     create_dynamic_sections, because they must be created 	     before the linker maps input sections to output 	     sections.  The linker does that before 	     adjust_dynamic_symbol is called, and it is that 	     function which decides whether anything needs to go 	     into these sections.  */
name|s
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Allocate memory for the section contents if it has not 	 been allocated already.  We use bfd_zalloc here in case 	 unused entries are not reclaimed before the section's 	 contents are written out.  This should not happen, but this 	 way if it does, we get a R_PARISC_NONE reloc instead of 	 garbage.  */
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
block|{
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Always create a DT_PLTGOT.  It actually has nothing to do with 	 the PLT, it is how we communicate the __gp value of a load 	 module to the dynamic linker.  */
define|#
directive|define
name|add_dynamic_entry
parameter_list|(
name|TAG
parameter_list|,
name|VAL
parameter_list|)
define|\
value|_bfd_elf_add_dynamic_entry (info, TAG, VAL)
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_HP_DLD_FLAGS
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in elf64_hppa_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_HP_DLD_HOOK
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_HP_LOAD_MAP
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Force DT_FLAGS to always be set. 	 Required by HPUX 11.00 patch PHSS_26559.  */
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_FLAGS
argument_list|,
operator|(
name|info
operator|)
operator|->
name|flags
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|plt
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTREL
argument_list|,
name|DT_RELA
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|relocs
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELA
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELAENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|reltext
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|add_dynamic_entry
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Called after we have output the symbol into the dynamic symbol    table, but before we output the symbol into the normal symbol    table.     For some symbols we had to change their address when outputting    the dynamic symbol table.  We undo that change here so that    the symbols have their expected value in the normal symbol    table.  Ick.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_hppa_link_output_symbol_hook
parameter_list|(
name|info
parameter_list|,
name|name
parameter_list|,
name|sym
parameter_list|,
name|input_sec
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|input_sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
name|struct
name|elf64_hppa_link_hash_table
modifier|*
name|hppa_info
decl_stmt|;
name|struct
name|elf64_hppa_dyn_hash_entry
modifier|*
name|dyn_h
decl_stmt|;
comment|/* We may be called with the file symbol or section symbols.      They never need munging, so it is safe to ignore them.  */
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|TRUE
return|;
comment|/* Get the PA dyn_symbol (if any) associated with NAME.  */
name|hppa_info
operator|=
name|elf64_hppa_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dyn_h
operator|=
name|elf64_hppa_dyn_hash_lookup
argument_list|(
operator|&
name|hppa_info
operator|->
name|dyn_hash_table
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dyn_h
operator|||
name|dyn_h
operator|->
name|h
operator|!=
name|h
condition|)
return|return
name|TRUE
return|;
comment|/* Function symbols for which we created .opd entries *may* have been      munged by finish_dynamic_symbol and have to be un-munged here.       Note that finish_dynamic_symbol sometimes turns dynamic symbols      into non-dynamic ones, so we initialize st_shndx to -1 in      mark_exported_functions and check to see if it was overwritten      here instead of just checking dyn_h->h->dynindx.  */
if|if
condition|(
name|dyn_h
operator|->
name|want_opd
operator|&&
name|dyn_h
operator|->
name|st_shndx
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Restore the saved value and section index.  */
name|sym
operator|->
name|st_value
operator|=
name|dyn_h
operator|->
name|st_value
expr_stmt|;
name|sym
operator|->
name|st_shndx
operator|=
name|dyn_h
operator|->
name|st_shndx
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_hppa_finish_dynamic_symbol
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
name|asection
modifier|*
name|stub
decl_stmt|,
modifier|*
name|splt
decl_stmt|,
modifier|*
name|sdlt
decl_stmt|,
modifier|*
name|sopd
decl_stmt|,
modifier|*
name|spltrel
decl_stmt|,
modifier|*
name|sdltrel
decl_stmt|;
name|struct
name|elf64_hppa_link_hash_table
modifier|*
name|hppa_info
decl_stmt|;
name|struct
name|elf64_hppa_dyn_hash_entry
modifier|*
name|dyn_h
decl_stmt|;
name|hppa_info
operator|=
name|elf64_hppa_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dyn_h
operator|=
name|elf64_hppa_dyn_hash_lookup
argument_list|(
operator|&
name|hppa_info
operator|->
name|dyn_hash_table
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|stub
operator|=
name|hppa_info
operator|->
name|stub_sec
expr_stmt|;
name|splt
operator|=
name|hppa_info
operator|->
name|plt_sec
expr_stmt|;
name|sdlt
operator|=
name|hppa_info
operator|->
name|dlt_sec
expr_stmt|;
name|sopd
operator|=
name|hppa_info
operator|->
name|opd_sec
expr_stmt|;
name|spltrel
operator|=
name|hppa_info
operator|->
name|plt_rel_sec
expr_stmt|;
name|sdltrel
operator|=
name|hppa_info
operator|->
name|dlt_rel_sec
expr_stmt|;
comment|/* Incredible.  It is actually necessary to NOT use the symbol's real      value when building the dynamic symbol table for a shared library.      At least for symbols that refer to functions.       We will store a new value and section index into the symbol long      enough to output it into the dynamic symbol table, then we restore      the original values (in elf64_hppa_link_output_symbol_hook).  */
if|if
condition|(
name|dyn_h
operator|&&
name|dyn_h
operator|->
name|want_opd
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|sopd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Save away the original value and section index so that we 	 can restore them later.  */
name|dyn_h
operator|->
name|st_value
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
name|dyn_h
operator|->
name|st_shndx
operator|=
name|sym
operator|->
name|st_shndx
expr_stmt|;
comment|/* For the dynamic symbol table entry, we want the value to be 	 address of this symbol's entry within the .opd section.  */
name|sym
operator|->
name|st_value
operator|=
operator|(
name|dyn_h
operator|->
name|opd_offset
operator|+
name|sopd
operator|->
name|output_offset
operator|+
name|sopd
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|sym
operator|->
name|st_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|output_bfd
argument_list|,
name|sopd
operator|->
name|output_section
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize a .plt entry if requested.  */
if|if
condition|(
name|dyn_h
operator|&&
name|dyn_h
operator|->
name|want_plt
operator|&&
name|elf64_hppa_dynamic_symbol_p
argument_list|(
name|dyn_h
operator|->
name|h
argument_list|,
name|info
argument_list|)
condition|)
block|{
name|bfd_vma
name|value
decl_stmt|;
name|Elf_Internal_Rela
name|rel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|spltrel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* We do not actually care about the value in the PLT entry 	 if we are creating a shared library and the symbol is 	 still undefined, we create a dynamic relocation to fill 	 in the correct value.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
name|value
operator|=
literal|0
expr_stmt|;
else|else
name|value
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Fill in the entry in the procedure linkage table.  	 The format of a plt entry is<funcaddr><__gp>.  	 plt_offset is the offset within the PLT section at which to 	 install the PLT entry.  	 We are modifying the in-memory PLT contents here, so we do not add 	 in the output_offset of the PLT section.  */
name|bfd_put_64
argument_list|(
name|splt
operator|->
name|owner
argument_list|,
name|value
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|dyn_h
operator|->
name|plt_offset
argument_list|)
expr_stmt|;
name|value
operator|=
name|_bfd_get_gp_value
argument_list|(
name|splt
operator|->
name|output_section
operator|->
name|owner
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|splt
operator|->
name|owner
argument_list|,
name|value
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|dyn_h
operator|->
name|plt_offset
operator|+
literal|0x8
argument_list|)
expr_stmt|;
comment|/* Create a dynamic IPLT relocation for this entry.  	 We are creating a relocation in the output file's PLT section, 	 which is included within the DLT secton.  So we do need to include 	 the PLT's output_offset in the computation of the relocation's 	 address.  */
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|dyn_h
operator|->
name|plt_offset
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_PARISC_IPLT
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
name|spltrel
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|spltrel
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|splt
operator|->
name|output_section
operator|->
name|owner
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize an external call stub entry if requested.  */
if|if
condition|(
name|dyn_h
operator|&&
name|dyn_h
operator|->
name|want_stub
operator|&&
name|elf64_hppa_dynamic_symbol_p
argument_list|(
name|dyn_h
operator|->
name|h
argument_list|,
name|info
argument_list|)
condition|)
block|{
name|bfd_vma
name|value
decl_stmt|;
name|int
name|insn
decl_stmt|;
name|unsigned
name|int
name|max_offset
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|stub
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Install the generic stub template.  	 We are modifying the contents of the stub section, so we do not 	 need to include the stub section's output_offset here.  */
name|memcpy
argument_list|(
name|stub
operator|->
name|contents
operator|+
name|dyn_h
operator|->
name|stub_offset
argument_list|,
name|plt_stub
argument_list|,
sizeof|sizeof
argument_list|(
name|plt_stub
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fix up the first ldd instruction.  	 We are modifying the contents of the STUB section in memory, 	 so we do not need to include its output offset in this computation.  	 Note the plt_offset value is the value of the PLT entry relative to 	 the start of the PLT section.  These instructions will reference 	 data relative to the value of __gp, which may not necessarily have 	 the same address as the start of the PLT section.  	 gp_offset contains the offset of __gp within the PLT section.  */
name|value
operator|=
name|dyn_h
operator|->
name|plt_offset
operator|-
name|hppa_info
operator|->
name|gp_offset
expr_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|stub
operator|->
name|owner
argument_list|,
name|stub
operator|->
name|contents
operator|+
name|dyn_h
operator|->
name|stub_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|->
name|arch_info
operator|->
name|mach
operator|>=
literal|25
condition|)
block|{
comment|/* Wide mode allows 16 bit offsets.  */
name|max_offset
operator|=
literal|32768
expr_stmt|;
name|insn
operator|&=
operator|~
literal|0xfff1
expr_stmt|;
name|insn
operator||=
name|re_assemble_16
argument_list|(
operator|(
name|int
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|max_offset
operator|=
literal|8192
expr_stmt|;
name|insn
operator|&=
operator|~
literal|0x3ff1
expr_stmt|;
name|insn
operator||=
name|re_assemble_14
argument_list|(
operator|(
name|int
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|value
operator|&
literal|7
operator|)
operator|||
name|value
operator|+
name|max_offset
operator|>=
literal|2
operator|*
name|max_offset
operator|-
literal|8
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"stub entry for %s cannot load .plt, dp offset = %ld"
argument_list|)
argument_list|,
name|dyn_h
operator|->
name|root
operator|.
name|string
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|bfd_put_32
argument_list|(
name|stub
operator|->
name|owner
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|stub
operator|->
name|contents
operator|+
name|dyn_h
operator|->
name|stub_offset
argument_list|)
expr_stmt|;
comment|/* Fix up the second ldd instruction.  */
name|value
operator|+=
literal|8
expr_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|stub
operator|->
name|owner
argument_list|,
name|stub
operator|->
name|contents
operator|+
name|dyn_h
operator|->
name|stub_offset
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|->
name|arch_info
operator|->
name|mach
operator|>=
literal|25
condition|)
block|{
name|insn
operator|&=
operator|~
literal|0xfff1
expr_stmt|;
name|insn
operator||=
name|re_assemble_16
argument_list|(
operator|(
name|int
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|insn
operator|&=
operator|~
literal|0x3ff1
expr_stmt|;
name|insn
operator||=
name|re_assemble_14
argument_list|(
operator|(
name|int
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|stub
operator|->
name|owner
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|stub
operator|->
name|contents
operator|+
name|dyn_h
operator|->
name|stub_offset
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The .opd section contains FPTRs for each function this file    exports.  Initialize the FPTR entries.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_hppa_finalize_opd
parameter_list|(
name|dyn_h
parameter_list|,
name|data
parameter_list|)
name|struct
name|elf64_hppa_dyn_hash_entry
modifier|*
name|dyn_h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|elf64_hppa_link_hash_table
modifier|*
name|hppa_info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|dyn_h
condition|?
name|dyn_h
operator|->
name|h
else|:
name|NULL
decl_stmt|;
name|asection
modifier|*
name|sopd
decl_stmt|;
name|asection
modifier|*
name|sopdrel
decl_stmt|;
name|hppa_info
operator|=
name|elf64_hppa_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|sopd
operator|=
name|hppa_info
operator|->
name|opd_sec
expr_stmt|;
name|sopdrel
operator|=
name|hppa_info
operator|->
name|opd_rel_sec
expr_stmt|;
if|if
condition|(
name|h
operator|&&
name|dyn_h
operator|->
name|want_opd
condition|)
block|{
name|bfd_vma
name|value
decl_stmt|;
comment|/* The first two words of an .opd entry are zero.  	 We are modifying the contents of the OPD section in memory, so we 	 do not need to include its output offset in this computation.  */
name|memset
argument_list|(
name|sopd
operator|->
name|contents
operator|+
name|dyn_h
operator|->
name|opd_offset
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
comment|/* The next word is the address of the function.  */
name|bfd_put_64
argument_list|(
name|sopd
operator|->
name|owner
argument_list|,
name|value
argument_list|,
name|sopd
operator|->
name|contents
operator|+
name|dyn_h
operator|->
name|opd_offset
operator|+
literal|16
argument_list|)
expr_stmt|;
comment|/* The last word is our local __gp value.  */
name|value
operator|=
name|_bfd_get_gp_value
argument_list|(
name|sopd
operator|->
name|output_section
operator|->
name|owner
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|sopd
operator|->
name|owner
argument_list|,
name|value
argument_list|,
name|sopd
operator|->
name|contents
operator|+
name|dyn_h
operator|->
name|opd_offset
operator|+
literal|24
argument_list|)
expr_stmt|;
block|}
comment|/* If we are generating a shared library, we must generate EPLT relocations      for each entry in the .opd, even for static functions (they may have      had their address taken).  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
name|dyn_h
operator|&&
name|dyn_h
operator|->
name|want_opd
condition|)
block|{
name|Elf_Internal_Rela
name|rel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|int
name|dynindx
decl_stmt|;
comment|/* We may need to do a relocation against a local symbol, in 	 which case we have to look up it's dynamic symbol index off 	 the local symbol hash table.  */
if|if
condition|(
name|h
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
name|dynindx
operator|=
name|h
operator|->
name|dynindx
expr_stmt|;
else|else
name|dynindx
operator|=
name|_bfd_elf_link_lookup_local_dynindx
argument_list|(
name|info
argument_list|,
name|dyn_h
operator|->
name|owner
argument_list|,
name|dyn_h
operator|->
name|sym_indx
argument_list|)
expr_stmt|;
comment|/* The offset of this relocation is the absolute address of the 	 .opd entry for this symbol.  */
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|dyn_h
operator|->
name|opd_offset
operator|+
name|sopd
operator|->
name|output_offset
operator|+
name|sopd
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* If H is non-null, then we have an external symbol.  	 It is imperative that we use a different dynamic symbol for the 	 EPLT relocation if the symbol has global scope.  	 In the dynamic symbol table, the function symbol will have a value 	 which is address of the function's .opd entry.  	 Thus, we can not use that dynamic symbol for the EPLT relocation 	 (if we did, the data in the .opd would reference itself rather 	 than the actual address of the function).  Instead we have to use 	 a new dynamic symbol which has the same value as the original global 	 function symbol.  	 We prefix the original symbol with a "." and use the new symbol in 	 the EPLT relocation.  This new symbol has already been recorded in 	 the symbol table, we just have to look it up and use it.  	 We do not have such problems with static functions because we do 	 not make their addresses in the dynamic symbol table point to 	 the .opd entry.  Ultimately this should be safe since a static 	 function can not be directly referenced outside of its shared 	 library.  	 We do have to play similar games for FPTR relocations in shared 	 libraries, including those for static symbols.  See the FPTR 	 handling in elf64_hppa_finalize_dynreloc.  */
if|if
condition|(
name|h
condition|)
block|{
name|char
modifier|*
name|new_name
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|nh
decl_stmt|;
name|new_name
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|new_name
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|strcpy
argument_list|(
name|new_name
operator|+
literal|1
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|nh
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|new_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* All we really want from the new symbol is its dynamic 	     symbol index.  */
name|dynindx
operator|=
name|nh
operator|->
name|dynindx
expr_stmt|;
block|}
name|rel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|dynindx
argument_list|,
name|R_PARISC_EPLT
argument_list|)
expr_stmt|;
name|loc
operator|=
name|sopdrel
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|sopdrel
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|sopd
operator|->
name|output_section
operator|->
name|owner
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The .dlt section contains addresses for items referenced through the    dlt.  Note that we can have a DLTIND relocation for a local symbol, thus    we can not depend on finish_dynamic_symbol to initialize the .dlt.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_hppa_finalize_dlt
parameter_list|(
name|dyn_h
parameter_list|,
name|data
parameter_list|)
name|struct
name|elf64_hppa_dyn_hash_entry
modifier|*
name|dyn_h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|elf64_hppa_link_hash_table
modifier|*
name|hppa_info
decl_stmt|;
name|asection
modifier|*
name|sdlt
decl_stmt|,
modifier|*
name|sdltrel
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|dyn_h
condition|?
name|dyn_h
operator|->
name|h
else|:
name|NULL
decl_stmt|;
name|hppa_info
operator|=
name|elf64_hppa_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|sdlt
operator|=
name|hppa_info
operator|->
name|dlt_sec
expr_stmt|;
name|sdltrel
operator|=
name|hppa_info
operator|->
name|dlt_rel_sec
expr_stmt|;
comment|/* H/DYN_H may refer to a local variable and we know it's      address, so there is no need to create a relocation.  Just install      the proper value into the DLT, note this shortcut can not be      skipped when building a shared library.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
name|h
operator|&&
name|dyn_h
operator|->
name|want_dlt
condition|)
block|{
name|bfd_vma
name|value
decl_stmt|;
comment|/* If we had an LTOFF_FPTR style relocation we want the DLT entry 	 to point to the FPTR entry in the .opd section.  	 We include the OPD's output offset in this computation as 	 we are referring to an absolute address in the resulting 	 object file.  */
if|if
condition|(
name|dyn_h
operator|->
name|want_opd
condition|)
block|{
name|value
operator|=
operator|(
name|dyn_h
operator|->
name|opd_offset
operator|+
name|hppa_info
operator|->
name|opd_sec
operator|->
name|output_offset
operator|+
name|hppa_info
operator|->
name|opd_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
condition|)
block|{
name|value
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
condition|)
name|value
operator|+=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
else|else
name|value
operator|+=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|vma
expr_stmt|;
block|}
else|else
comment|/* We have an undefined function reference.  */
name|value
operator|=
literal|0
expr_stmt|;
comment|/* We do not need to include the output offset of the DLT section 	 here because we are modifying the in-memory contents.  */
name|bfd_put_64
argument_list|(
name|sdlt
operator|->
name|owner
argument_list|,
name|value
argument_list|,
name|sdlt
operator|->
name|contents
operator|+
name|dyn_h
operator|->
name|dlt_offset
argument_list|)
expr_stmt|;
block|}
comment|/* Create a relocation for the DLT entry associated with this symbol.      When building a shared library the symbol does not have to be dynamic.  */
if|if
condition|(
name|dyn_h
operator|->
name|want_dlt
operator|&&
operator|(
name|elf64_hppa_dynamic_symbol_p
argument_list|(
name|dyn_h
operator|->
name|h
argument_list|,
name|info
argument_list|)
operator|||
name|info
operator|->
name|shared
operator|)
condition|)
block|{
name|Elf_Internal_Rela
name|rel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|int
name|dynindx
decl_stmt|;
comment|/* We may need to do a relocation against a local symbol, in 	 which case we have to look up it's dynamic symbol index off 	 the local symbol hash table.  */
if|if
condition|(
name|h
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
name|dynindx
operator|=
name|h
operator|->
name|dynindx
expr_stmt|;
else|else
name|dynindx
operator|=
name|_bfd_elf_link_lookup_local_dynindx
argument_list|(
name|info
argument_list|,
name|dyn_h
operator|->
name|owner
argument_list|,
name|dyn_h
operator|->
name|sym_indx
argument_list|)
expr_stmt|;
comment|/* Create a dynamic relocation for this entry.  Do include the output 	 offset of the DLT entry since we need an absolute address in the 	 resulting object file.  */
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|dyn_h
operator|->
name|dlt_offset
operator|+
name|sdlt
operator|->
name|output_offset
operator|+
name|sdlt
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|&&
name|h
operator|->
name|type
operator|==
name|STT_FUNC
condition|)
name|rel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|dynindx
argument_list|,
name|R_PARISC_FPTR64
argument_list|)
expr_stmt|;
else|else
name|rel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|dynindx
argument_list|,
name|R_PARISC_DIR64
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
name|sdltrel
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|sdltrel
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|sdlt
operator|->
name|output_section
operator|->
name|owner
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finalize the dynamic relocations.  Specifically the FPTR relocations    for dynamic functions used to initialize static data.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_hppa_finalize_dynreloc
parameter_list|(
name|dyn_h
parameter_list|,
name|data
parameter_list|)
name|struct
name|elf64_hppa_dyn_hash_entry
modifier|*
name|dyn_h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|elf64_hppa_link_hash_table
modifier|*
name|hppa_info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|int
name|dynamic_symbol
decl_stmt|;
name|dynamic_symbol
operator|=
name|elf64_hppa_dynamic_symbol_p
argument_list|(
name|dyn_h
operator|->
name|h
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dynamic_symbol
operator|&&
operator|!
name|info
operator|->
name|shared
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|dyn_h
operator|->
name|reloc_entries
condition|)
block|{
name|struct
name|elf64_hppa_dyn_reloc_entry
modifier|*
name|rent
decl_stmt|;
name|int
name|dynindx
decl_stmt|;
name|hppa_info
operator|=
name|elf64_hppa_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|h
operator|=
name|dyn_h
operator|->
name|h
expr_stmt|;
comment|/* We may need to do a relocation against a local symbol, in 	 which case we have to look up it's dynamic symbol index off 	 the local symbol hash table.  */
if|if
condition|(
name|h
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
name|dynindx
operator|=
name|h
operator|->
name|dynindx
expr_stmt|;
else|else
name|dynindx
operator|=
name|_bfd_elf_link_lookup_local_dynindx
argument_list|(
name|info
argument_list|,
name|dyn_h
operator|->
name|owner
argument_list|,
name|dyn_h
operator|->
name|sym_indx
argument_list|)
expr_stmt|;
for|for
control|(
name|rent
operator|=
name|dyn_h
operator|->
name|reloc_entries
init|;
name|rent
condition|;
name|rent
operator|=
name|rent
operator|->
name|next
control|)
block|{
name|Elf_Internal_Rela
name|rel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
comment|/* Allocate one iff we are building a shared library, the relocation 	     isn't a R_PARISC_FPTR64, or we don't want an opd entry.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
name|rent
operator|->
name|type
operator|==
name|R_PARISC_FPTR64
operator|&&
name|dyn_h
operator|->
name|want_opd
condition|)
continue|continue;
comment|/* Create a dynamic relocation for this entry.  	     We need the output offset for the reloc's section because 	     we are creating an absolute address in the resulting object 	     file.  */
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|rent
operator|->
name|offset
operator|+
name|rent
operator|->
name|sec
operator|->
name|output_offset
operator|+
name|rent
operator|->
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* An FPTR64 relocation implies that we took the address of 	     a function and that the function has an entry in the .opd 	     section.  We want the FPTR64 relocation to reference the 	     entry in .opd.  	     We could munge the symbol value in the dynamic symbol table 	     (in fact we already do for functions with global scope) to point 	     to the .opd entry.  Then we could use that dynamic symbol in 	     this relocation.  	     Or we could do something sensible, not munge the symbol's 	     address and instead just use a different symbol to reference 	     the .opd entry.  At least that seems sensible until you 	     realize there's no local dynamic symbols we can use for that 	     purpose.  Thus the hair in the check_relocs routine.  	     We use a section symbol recorded by check_relocs as the 	     base symbol for the relocation.  The addend is the difference 	     between the section symbol and the address of the .opd entry.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
name|rent
operator|->
name|type
operator|==
name|R_PARISC_FPTR64
operator|&&
name|dyn_h
operator|->
name|want_opd
condition|)
block|{
name|bfd_vma
name|value
decl_stmt|,
name|value2
decl_stmt|;
comment|/* First compute the address of the opd entry for this symbol.  */
name|value
operator|=
operator|(
name|dyn_h
operator|->
name|opd_offset
operator|+
name|hppa_info
operator|->
name|opd_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|hppa_info
operator|->
name|opd_sec
operator|->
name|output_offset
operator|)
expr_stmt|;
comment|/* Compute the value of the start of the section with 		 the relocation.  */
name|value2
operator|=
operator|(
name|rent
operator|->
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|rent
operator|->
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
comment|/* Compute the difference between the start of the section 		 with the relocation and the opd entry.  */
name|value
operator|-=
name|value2
expr_stmt|;
comment|/* The result becomes the addend of the relocation.  */
name|rel
operator|.
name|r_addend
operator|=
name|value
expr_stmt|;
comment|/* The section symbol becomes the symbol for the dynamic 		 relocation.  */
name|dynindx
operator|=
name|_bfd_elf_link_lookup_local_dynindx
argument_list|(
name|info
argument_list|,
name|rent
operator|->
name|sec
operator|->
name|owner
argument_list|,
name|rent
operator|->
name|sec_symndx
argument_list|)
expr_stmt|;
block|}
else|else
name|rel
operator|.
name|r_addend
operator|=
name|rent
operator|->
name|addend
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|dynindx
argument_list|,
name|rent
operator|->
name|type
argument_list|)
expr_stmt|;
name|loc
operator|=
name|hppa_info
operator|->
name|other_rel_sec
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
operator|(
name|hppa_info
operator|->
name|other_rel_sec
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
operator|)
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|hppa_info
operator|->
name|other_rel_sec
operator|->
name|output_section
operator|->
name|owner
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Used to decide how to sort relocs in an optimal manner for the    dynamic linker, before writing them out.  */
end_comment

begin_function
specifier|static
name|enum
name|elf_reloc_type_class
name|elf64_hppa_reloc_type_class
parameter_list|(
name|rela
parameter_list|)
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rela
decl_stmt|;
block|{
if|if
condition|(
name|ELF64_R_SYM
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
operator|==
literal|0
condition|)
return|return
name|reloc_class_relative
return|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|ELF64_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_PARISC_IPLT
case|:
return|return
name|reloc_class_plt
return|;
case|case
name|R_PARISC_COPY
case|:
return|return
name|reloc_class_copy
return|;
default|default:
return|return
name|reloc_class_normal
return|;
block|}
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_hppa_finish_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|struct
name|elf64_hppa_link_hash_table
modifier|*
name|hppa_info
decl_stmt|;
name|hppa_info
operator|=
name|elf64_hppa_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Finalize the contents of the .opd section.  */
name|elf64_hppa_dyn_hash_traverse
argument_list|(
operator|&
name|hppa_info
operator|->
name|dyn_hash_table
argument_list|,
name|elf64_hppa_finalize_opd
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|elf64_hppa_dyn_hash_traverse
argument_list|(
operator|&
name|hppa_info
operator|->
name|dyn_hash_table
argument_list|,
name|elf64_hppa_finalize_dynreloc
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* Finalize the contents of the .dlt section.  */
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* Finalize the contents of the .dlt section.  */
name|elf64_hppa_dyn_hash_traverse
argument_list|(
operator|&
name|hppa_info
operator|->
name|dyn_hash_table
argument_list|,
name|elf64_hppa_finalize_dlt
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|Elf64_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf64_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf64_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_elf64_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
default|default:
break|break;
case|case
name|DT_HP_LOAD_MAP
case|:
comment|/* Compute the absolute address of 16byte scratchpad area 		 for the dynamic linker.  		 By convention the linker script will allocate the scratchpad 		 area at the start of the .data section.  So all we have to 		 to is find the start of the .data section.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".data"
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|bfd_elf64_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_PLTGOT
case|:
comment|/* HP's use PLTGOT to set the GOT register.  */
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|bfd_elf64_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_JMPREL
case|:
name|s
operator|=
name|hppa_info
operator|->
name|plt_rel_sec
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
expr_stmt|;
name|bfd_elf64_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|s
operator|=
name|hppa_info
operator|->
name|plt_rel_sec
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|size
expr_stmt|;
name|bfd_elf64_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_RELA
case|:
name|s
operator|=
name|hppa_info
operator|->
name|other_rel_sec
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|||
operator|!
name|s
operator|->
name|size
condition|)
name|s
operator|=
name|hppa_info
operator|->
name|dlt_rel_sec
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|||
operator|!
name|s
operator|->
name|size
condition|)
name|s
operator|=
name|hppa_info
operator|->
name|opd_rel_sec
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
expr_stmt|;
name|bfd_elf64_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_RELASZ
case|:
name|s
operator|=
name|hppa_info
operator|->
name|other_rel_sec
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|size
expr_stmt|;
name|s
operator|=
name|hppa_info
operator|->
name|dlt_rel_sec
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|+=
name|s
operator|->
name|size
expr_stmt|;
name|s
operator|=
name|hppa_info
operator|->
name|opd_rel_sec
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|+=
name|s
operator|->
name|size
expr_stmt|;
comment|/* There is some question about whether or not the size of 		 the PLT relocs should be included here.  HP's tools do 		 it, so we'll emulate them.  */
name|s
operator|=
name|hppa_info
operator|->
name|plt_rel_sec
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|+=
name|s
operator|->
name|size
expr_stmt|;
name|bfd_elf64_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Support for core dump NOTE sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_hppa_grok_prstatus
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
name|size_t
name|size
decl_stmt|;
switch|switch
condition|(
name|note
operator|->
name|descsz
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
literal|760
case|:
comment|/* Linux/hppa */
comment|/* pr_cursig */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* pr_pid */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_pid
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|32
argument_list|)
expr_stmt|;
comment|/* pr_reg */
name|offset
operator|=
literal|112
expr_stmt|;
name|size
operator|=
literal|640
expr_stmt|;
break|break;
block|}
comment|/* Make a ".reg/999" section.  */
return|return
name|_bfd_elfcore_make_pseudosection
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|,
name|size
argument_list|,
name|note
operator|->
name|descpos
operator|+
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf64_hppa_grok_psinfo
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
name|char
modifier|*
name|command
decl_stmt|;
name|int
name|n
decl_stmt|;
switch|switch
condition|(
name|note
operator|->
name|descsz
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
literal|136
case|:
comment|/* Linux/hppa elf_prpsinfo.  */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_program
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|40
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|56
argument_list|,
literal|80
argument_list|)
expr_stmt|;
block|}
comment|/* Note that for some reason, a spurious space is tacked      onto the end of the args in some (at least one anyway)      implementations, so strip it off if it exists.  */
name|command
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|n
operator|&&
name|command
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|command
index|[
name|n
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return the number of additional phdrs we will need.     The generic ELF code only creates PT_PHDRs for executables.  The HP    dynamic linker requires PT_PHDRs for dynamic libraries too.     This routine indicates that the backend needs one additional program    header for that case.     Note we do not have access to the link info structure here, so we have    to guess whether or not we are building a shared library based on the    existence of a .interp section.  */
end_comment

begin_function
specifier|static
name|int
name|elf64_hppa_additional_program_headers
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* If we are creating a shared library, then we have to create a      PT_PHDR segment.  HP's dynamic linker chokes without it.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Allocate and initialize any program headers required by this    specific backend.     The generic ELF code only creates PT_PHDRs for executables.  The HP    dynamic linker requires PT_PHDRs for dynamic libraries too.     This allocates the PT_PHDR and initializes it in a manner suitable    for the HP linker.     Note we do not have access to the link info structure here, so we have    to guess whether or not we are building a shared library based on the    existence of a .interp section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_hppa_modify_segment_map
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|p_type
operator|==
name|PT_PHDR
condition|)
break|break;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
operator|(
operator|(
expr|struct
name|elf_segment_map
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
expr|*
name|m
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|m
operator|->
name|p_type
operator|=
name|PT_PHDR
expr_stmt|;
name|m
operator|->
name|p_flags
operator|=
name|PF_R
operator||
name|PF_X
expr_stmt|;
name|m
operator|->
name|p_flags_valid
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|p_paddr_valid
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|includes_phdrs
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|next
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
operator|=
name|m
expr_stmt|;
block|}
block|}
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|p_type
operator|==
name|PT_LOAD
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* The code "hint" is not really a hint.  It is a requirement 	       for certain versions of the HP dynamic linker.  Worse yet, 	       it must be set even if the shared library does not have 	       any code in its "text" segment (thus the check for .hash 	       to catch this situation).  */
if|if
condition|(
name|m
operator|->
name|sections
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|SEC_CODE
operator|||
operator|(
name|strcmp
argument_list|(
name|m
operator|->
name|sections
index|[
name|i
index|]
operator|->
name|name
argument_list|,
literal|".hash"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|m
operator|->
name|p_flags
operator||=
operator|(
name|PF_X
operator||
name|PF_HP_CODE
operator|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Called when writing out an object file to decide the type of a    symbol.  */
end_comment

begin_function
specifier|static
name|int
name|elf64_hppa_elf_get_symbol_type
parameter_list|(
name|elf_sym
parameter_list|,
name|type
parameter_list|)
name|Elf_Internal_Sym
modifier|*
name|elf_sym
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|elf_sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_PARISC_MILLI
condition|)
return|return
name|STT_PARISC_MILLI
return|;
else|else
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Support HP specific sections for core files.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf64_hppa_section_from_phdr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Phdr
modifier|*
name|hdr
parameter_list|,
name|int
name|index
parameter_list|,
specifier|const
name|char
modifier|*
name|typename
parameter_list|)
block|{
if|if
condition|(
name|hdr
operator|->
name|p_type
operator|==
name|PT_HP_CORE_KERNEL
condition|)
block|{
name|asection
modifier|*
name|sect
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_make_section_from_phdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|index
argument_list|,
name|typename
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|sect
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
literal|".kernel"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sect
operator|->
name|size
operator|=
name|hdr
operator|->
name|p_filesz
expr_stmt|;
name|sect
operator|->
name|filepos
operator|=
name|hdr
operator|->
name|p_offset
expr_stmt|;
name|sect
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|hdr
operator|->
name|p_type
operator|==
name|PT_HP_CORE_PROC
condition|)
block|{
name|int
name|sig
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|p_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|&
name|sig
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|FALSE
return|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|=
name|sig
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_make_section_from_phdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|index
argument_list|,
name|typename
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* GDB uses the ".reg" section to read register contents.  */
return|return
name|_bfd_elfcore_make_pseudosection
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|,
name|hdr
operator|->
name|p_filesz
argument_list|,
name|hdr
operator|->
name|p_offset
argument_list|)
return|;
block|}
if|if
condition|(
name|hdr
operator|->
name|p_type
operator|==
name|PT_HP_CORE_LOADABLE
operator|||
name|hdr
operator|->
name|p_type
operator|==
name|PT_HP_CORE_STACK
operator|||
name|hdr
operator|->
name|p_type
operator|==
name|PT_HP_CORE_MMF
condition|)
name|hdr
operator|->
name|p_type
operator|=
name|PT_LOAD
expr_stmt|;
return|return
name|_bfd_elf_make_section_from_phdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|index
argument_list|,
name|typename
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|bfd_elf_special_section
name|elf64_hppa_special_sections
index|[]
init|=
block|{
block|{
literal|".fini"
block|,
literal|5
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
literal|".init"
block|,
literal|5
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
literal|".plt"
block|,
literal|4
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
operator|+
name|SHF_PARISC_SHORT
block|}
block|,
block|{
literal|".dlt"
block|,
literal|4
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
operator|+
name|SHF_PARISC_SHORT
block|}
block|,
block|{
literal|".sdata"
block|,
literal|6
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
operator|+
name|SHF_PARISC_SHORT
block|}
block|,
block|{
literal|".sbss"
block|,
literal|5
block|,
literal|0
block|,
name|SHT_NOBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
operator|+
name|SHF_PARISC_SHORT
block|}
block|,
block|{
literal|".tbss"
block|,
literal|5
block|,
literal|0
block|,
name|SHT_NOBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
operator|+
name|SHF_HP_TLS
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The hash bucket size is the standard one, namely 4.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|elf_size_info
name|hppa64_elf_size_info
init|=
block|{
sizeof|sizeof
argument_list|(
name|Elf64_External_Ehdr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Phdr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Shdr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Rel
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Sym
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Dyn
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|Elf_External_Note
argument_list|)
block|,
literal|4
block|,
literal|1
block|,
literal|64
block|,
literal|3
block|,
name|ELFCLASS64
block|,
name|EV_CURRENT
block|,
name|bfd_elf64_write_out_phdrs
block|,
name|bfd_elf64_write_shdrs_and_ehdr
block|,
name|bfd_elf64_write_relocs
block|,
name|bfd_elf64_swap_symbol_in
block|,
name|bfd_elf64_swap_symbol_out
block|,
name|bfd_elf64_slurp_reloc_table
block|,
name|bfd_elf64_slurp_symbol_table
block|,
name|bfd_elf64_swap_dyn_in
block|,
name|bfd_elf64_swap_dyn_out
block|,
name|bfd_elf64_swap_reloc_in
block|,
name|bfd_elf64_swap_reloc_out
block|,
name|bfd_elf64_swap_reloca_in
block|,
name|bfd_elf64_swap_reloca_out
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf64_hppa_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf64-hppa"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_hppa
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_PARISC
end_define

begin_comment
comment|/* This is not strictly correct.  The maximum page size for PA2.0 is    64M.  But everything still uses 4k.  */
end_comment

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1000
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_reloc_type_lookup
value|elf_hppa_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_is_local_label_name
value|elf_hppa_is_local_label_name
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|elf_hppa_info_to_howto
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|elf_hppa_info_to_howto_rel
end_define

begin_define
define|#
directive|define
name|elf_backend_section_from_shdr
value|elf64_hppa_section_from_shdr
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|elf64_hppa_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
define|\
value|elf_hppa_final_write_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_fake_sections
value|elf_hppa_fake_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
value|elf_hppa_add_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|elf_hppa_relocate_section
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_final_link
value|elf_hppa_final_link
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
define|\
value|elf64_hppa_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_post_process_headers
value|elf64_hppa_post_process_headers
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
define|\
value|elf64_hppa_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
define|\
value|elf64_hppa_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
define|\
value|elf64_hppa_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
define|\
value|elf64_hppa_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_prstatus
value|elf64_hppa_grok_prstatus
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_psinfo
value|elf64_hppa_grok_psinfo
end_define

begin_comment
comment|/* Stuff for the BFD linker: */
end_comment

begin_define
define|#
directive|define
name|bfd_elf64_bfd_link_hash_table_create
define|\
value|elf64_hppa_hash_table_create
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
define|\
value|elf64_hppa_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_size_info
define|\
value|hppa64_elf_size_info
end_define

begin_define
define|#
directive|define
name|elf_backend_additional_program_headers
define|\
value|elf64_hppa_additional_program_headers
end_define

begin_define
define|#
directive|define
name|elf_backend_modify_segment_map
define|\
value|elf64_hppa_modify_segment_map
end_define

begin_define
define|#
directive|define
name|elf_backend_link_output_symbol_hook
define|\
value|elf64_hppa_link_output_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_want_got_plt
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_readonly
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_type_change_ok
value|TRUE
end_define

begin_define
define|#
directive|define
name|elf_backend_get_symbol_type
value|elf64_hppa_elf_get_symbol_type
end_define

begin_define
define|#
directive|define
name|elf_backend_reloc_type_class
value|elf64_hppa_reloc_type_class
end_define

begin_define
define|#
directive|define
name|elf_backend_rela_normal
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_special_sections
value|elf64_hppa_special_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_action_discarded
value|elf_hppa_action_discarded
end_define

begin_define
define|#
directive|define
name|elf_backend_section_from_phdr
value|elf64_hppa_section_from_phdr
end_define

begin_include
include|#
directive|include
file|"elf64-target.h"
end_include

begin_undef
undef|#
directive|undef
name|TARGET_BIG_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf64_hppa_linux_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BIG_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf64-hppa-linux"
end_define

begin_define
define|#
directive|define
name|INCLUDED_TARGET_FILE
value|1
end_define

begin_include
include|#
directive|include
file|"elf64-target.h"
end_include

end_unit

