begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Configurable Xtensa ISA support.    Copyright 2003, 2004, 2005, 2007 Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"xtensa-isa.h"
end_include

begin_include
include|#
directive|include
file|"xtensa-isa-internal.h"
end_include

begin_decl_stmt
name|xtensa_isa_status
name|xtisa_errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|xtisa_error_msg
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|xtensa_isa_status
name|xtensa_isa_errno
argument_list|(
name|xtensa_isa
name|isa
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|)
block|{
return|return
name|xtisa_errno
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|xtensa_isa_error_msg
argument_list|(
name|xtensa_isa
name|isa
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|)
block|{
return|return
name|xtisa_error_msg
return|;
block|}
end_decl_stmt

begin_define
define|#
directive|define
name|CHECK_ALLOC
parameter_list|(
name|MEM
parameter_list|,
name|ERRVAL
parameter_list|)
define|\
value|do { \     if ((MEM) == 0) \       { \ 	xtisa_errno = xtensa_isa_out_of_memory; \ 	strcpy (xtisa_error_msg, "out of memory"); \ 	return (ERRVAL); \       } \   } while (0)
end_define

begin_define
define|#
directive|define
name|CHECK_ALLOC_FOR_INIT
parameter_list|(
name|MEM
parameter_list|,
name|ERRVAL
parameter_list|,
name|ERRNO_P
parameter_list|,
name|ERROR_MSG_P
parameter_list|)
define|\
value|do { \     if ((MEM) == 0) \       { \ 	xtisa_errno = xtensa_isa_out_of_memory; \ 	strcpy (xtisa_error_msg, "out of memory"); \ 	if (ERRNO_P) *(ERRNO_P) = xtisa_errno; \ 	if (ERROR_MSG_P) *(ERROR_MSG_P) = xtisa_error_msg; \ 	return (ERRVAL); \       } \   } while (0)
end_define

begin_escape
end_escape

begin_comment
comment|/* Instruction buffers.  */
end_comment

begin_function
name|int
name|xtensa_insnbuf_size
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
return|return
name|intisa
operator|->
name|insnbuf_size
return|;
block|}
end_function

begin_function
name|xtensa_insnbuf
name|xtensa_insnbuf_alloc
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
block|{
name|xtensa_insnbuf
name|result
init|=
operator|(
name|xtensa_insnbuf
operator|)
name|malloc
argument_list|(
name|xtensa_insnbuf_size
argument_list|(
name|isa
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|xtensa_insnbuf_word
argument_list|)
argument_list|)
decl_stmt|;
name|CHECK_ALLOC
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_decl_stmt
name|void
name|xtensa_insnbuf_free
argument_list|(
name|xtensa_isa
name|isa
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|,
name|xtensa_insnbuf
name|buf
argument_list|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Given<byte_index>, the index of a byte in a xtensa_insnbuf, our    internal representation of a xtensa instruction word, return the index of    its word and the bit index of its low order byte in the xtensa_insnbuf.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|byte_to_word_index
parameter_list|(
name|int
name|byte_index
parameter_list|)
block|{
return|return
name|byte_index
operator|/
sizeof|sizeof
argument_list|(
name|xtensa_insnbuf_word
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|byte_to_bit_index
parameter_list|(
name|int
name|byte_index
parameter_list|)
block|{
return|return
operator|(
name|byte_index
operator|&
literal|0x3
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_comment
comment|/* Copy an instruction in the 32-bit words pointed at by "insn" to    characters pointed at by "cp".  This is more complicated than you    might think because we want 16-bit instructions in bytes 2& 3 for    big-endian configurations.  This function allows us to specify    which byte in "insn" to start with and which way to increment,    allowing trivial implementation for both big- and little-endian    configurations....and it seems to make pretty good code for    both.  */
end_comment

begin_function
name|int
name|xtensa_insnbuf_to_chars
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
specifier|const
name|xtensa_insnbuf
name|insn
parameter_list|,
name|unsigned
name|char
modifier|*
name|cp
parameter_list|,
name|int
name|num_chars
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|int
name|insn_size
init|=
name|xtensa_isa_maxlength
argument_list|(
name|isa
argument_list|)
decl_stmt|;
name|int
name|fence_post
decl_stmt|,
name|start
decl_stmt|,
name|increment
decl_stmt|,
name|i
decl_stmt|,
name|byte_count
decl_stmt|;
name|xtensa_format
name|fmt
decl_stmt|;
if|if
condition|(
name|num_chars
operator|==
literal|0
condition|)
name|num_chars
operator|=
name|insn_size
expr_stmt|;
if|if
condition|(
name|intisa
operator|->
name|is_big_endian
condition|)
block|{
name|start
operator|=
name|insn_size
operator|-
literal|1
expr_stmt|;
name|increment
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
literal|0
expr_stmt|;
name|increment
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Find the instruction format.  Do nothing if the buffer does not contain      a valid instruction since we need to know how many bytes to copy.  */
name|fmt
operator|=
name|xtensa_format_decode
argument_list|(
name|isa
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
name|byte_count
operator|=
name|xtensa_format_length
argument_list|(
name|isa
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte_count
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
if|if
condition|(
name|byte_count
operator|>
name|num_chars
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_buffer_overflow
expr_stmt|;
name|strcpy
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"output buffer too small for instruction"
argument_list|)
expr_stmt|;
return|return
name|XTENSA_UNDEFINED
return|;
block|}
name|fence_post
operator|=
name|start
operator|+
operator|(
name|byte_count
operator|*
name|increment
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|!=
name|fence_post
condition|;
name|i
operator|+=
name|increment
operator|,
operator|++
name|cp
control|)
block|{
name|int
name|word_inx
init|=
name|byte_to_word_index
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|bit_inx
init|=
name|byte_to_bit_index
argument_list|(
name|i
argument_list|)
decl_stmt|;
operator|*
name|cp
operator|=
operator|(
name|insn
index|[
name|word_inx
index|]
operator|>>
name|bit_inx
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
return|return
name|byte_count
return|;
block|}
end_function

begin_comment
comment|/* Inward conversion from byte stream to xtensa_insnbuf.  See    xtensa_insnbuf_to_chars for a discussion of why this is complicated    by endianness.  */
end_comment

begin_function
name|void
name|xtensa_insnbuf_from_chars
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_insnbuf
name|insn
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|cp
parameter_list|,
name|int
name|num_chars
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|int
name|max_size
decl_stmt|,
name|insn_size
decl_stmt|,
name|fence_post
decl_stmt|,
name|start
decl_stmt|,
name|increment
decl_stmt|,
name|i
decl_stmt|;
name|max_size
operator|=
name|xtensa_isa_maxlength
argument_list|(
name|isa
argument_list|)
expr_stmt|;
comment|/* Decode the instruction length so we know how many bytes to read.  */
name|insn_size
operator|=
call|(
name|intisa
operator|->
name|length_decode_fn
call|)
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_size
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
comment|/* This should never happen when the byte stream contains a 	 valid instruction.  Just read the maximum number of bytes....  */
name|insn_size
operator|=
name|max_size
expr_stmt|;
block|}
if|if
condition|(
name|num_chars
operator|==
literal|0
operator|||
name|num_chars
operator|>
name|insn_size
condition|)
name|num_chars
operator|=
name|insn_size
expr_stmt|;
if|if
condition|(
name|intisa
operator|->
name|is_big_endian
condition|)
block|{
name|start
operator|=
name|max_size
operator|-
literal|1
expr_stmt|;
name|increment
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
literal|0
expr_stmt|;
name|increment
operator|=
literal|1
expr_stmt|;
block|}
name|fence_post
operator|=
name|start
operator|+
operator|(
name|num_chars
operator|*
name|increment
operator|)
expr_stmt|;
name|memset
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
name|xtensa_insnbuf_size
argument_list|(
name|isa
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|xtensa_insnbuf_word
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|!=
name|fence_post
condition|;
name|i
operator|+=
name|increment
operator|,
operator|++
name|cp
control|)
block|{
name|int
name|word_inx
init|=
name|byte_to_word_index
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|bit_inx
init|=
name|byte_to_bit_index
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|insn
index|[
name|word_inx
index|]
operator||=
operator|(
operator|*
name|cp
operator|&
literal|0xff
operator|)
operator|<<
name|bit_inx
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ISA information.  */
end_comment

begin_decl_stmt
specifier|extern
name|xtensa_isa_internal
name|xtensa_modules
decl_stmt|;
end_decl_stmt

begin_function
name|xtensa_isa
name|xtensa_isa_init
parameter_list|(
name|xtensa_isa_status
modifier|*
name|errno_p
parameter_list|,
name|char
modifier|*
modifier|*
name|error_msg_p
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|isa
init|=
operator|&
name|xtensa_modules
decl_stmt|;
name|int
name|n
decl_stmt|,
name|is_user
decl_stmt|;
comment|/* Set up the opcode name lookup table.  */
name|isa
operator|->
name|opname_lookup_table
operator|=
name|bfd_malloc
argument_list|(
name|isa
operator|->
name|num_opcodes
operator|*
sizeof|sizeof
argument_list|(
name|xtensa_lookup_entry
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK_ALLOC_FOR_INIT
argument_list|(
name|isa
operator|->
name|opname_lookup_table
argument_list|,
name|NULL
argument_list|,
name|errno_p
argument_list|,
name|error_msg_p
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|isa
operator|->
name|num_opcodes
condition|;
name|n
operator|++
control|)
block|{
name|isa
operator|->
name|opname_lookup_table
index|[
name|n
index|]
operator|.
name|key
operator|=
name|isa
operator|->
name|opcodes
index|[
name|n
index|]
operator|.
name|name
expr_stmt|;
name|isa
operator|->
name|opname_lookup_table
index|[
name|n
index|]
operator|.
name|u
operator|.
name|opcode
operator|=
name|n
expr_stmt|;
block|}
name|qsort
argument_list|(
name|isa
operator|->
name|opname_lookup_table
argument_list|,
name|isa
operator|->
name|num_opcodes
argument_list|,
sizeof|sizeof
argument_list|(
name|xtensa_lookup_entry
argument_list|)
argument_list|,
name|xtensa_isa_name_compare
argument_list|)
expr_stmt|;
comment|/* Set up the state name lookup table.  */
name|isa
operator|->
name|state_lookup_table
operator|=
name|bfd_malloc
argument_list|(
name|isa
operator|->
name|num_states
operator|*
sizeof|sizeof
argument_list|(
name|xtensa_lookup_entry
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK_ALLOC_FOR_INIT
argument_list|(
name|isa
operator|->
name|state_lookup_table
argument_list|,
name|NULL
argument_list|,
name|errno_p
argument_list|,
name|error_msg_p
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|isa
operator|->
name|num_states
condition|;
name|n
operator|++
control|)
block|{
name|isa
operator|->
name|state_lookup_table
index|[
name|n
index|]
operator|.
name|key
operator|=
name|isa
operator|->
name|states
index|[
name|n
index|]
operator|.
name|name
expr_stmt|;
name|isa
operator|->
name|state_lookup_table
index|[
name|n
index|]
operator|.
name|u
operator|.
name|state
operator|=
name|n
expr_stmt|;
block|}
name|qsort
argument_list|(
name|isa
operator|->
name|state_lookup_table
argument_list|,
name|isa
operator|->
name|num_states
argument_list|,
sizeof|sizeof
argument_list|(
name|xtensa_lookup_entry
argument_list|)
argument_list|,
name|xtensa_isa_name_compare
argument_list|)
expr_stmt|;
comment|/* Set up the sysreg name lookup table.  */
name|isa
operator|->
name|sysreg_lookup_table
operator|=
name|bfd_malloc
argument_list|(
name|isa
operator|->
name|num_sysregs
operator|*
sizeof|sizeof
argument_list|(
name|xtensa_lookup_entry
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK_ALLOC_FOR_INIT
argument_list|(
name|isa
operator|->
name|sysreg_lookup_table
argument_list|,
name|NULL
argument_list|,
name|errno_p
argument_list|,
name|error_msg_p
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|isa
operator|->
name|num_sysregs
condition|;
name|n
operator|++
control|)
block|{
name|isa
operator|->
name|sysreg_lookup_table
index|[
name|n
index|]
operator|.
name|key
operator|=
name|isa
operator|->
name|sysregs
index|[
name|n
index|]
operator|.
name|name
expr_stmt|;
name|isa
operator|->
name|sysreg_lookup_table
index|[
name|n
index|]
operator|.
name|u
operator|.
name|sysreg
operator|=
name|n
expr_stmt|;
block|}
name|qsort
argument_list|(
name|isa
operator|->
name|sysreg_lookup_table
argument_list|,
name|isa
operator|->
name|num_sysregs
argument_list|,
sizeof|sizeof
argument_list|(
name|xtensa_lookup_entry
argument_list|)
argument_list|,
name|xtensa_isa_name_compare
argument_list|)
expr_stmt|;
comment|/* Set up the user& system sysreg number tables.  */
for|for
control|(
name|is_user
operator|=
literal|0
init|;
name|is_user
operator|<
literal|2
condition|;
name|is_user
operator|++
control|)
block|{
name|isa
operator|->
name|sysreg_table
index|[
name|is_user
index|]
operator|=
name|bfd_malloc
argument_list|(
operator|(
name|isa
operator|->
name|max_sysreg_num
index|[
name|is_user
index|]
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|xtensa_sysreg
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK_ALLOC_FOR_INIT
argument_list|(
name|isa
operator|->
name|sysreg_table
index|[
name|is_user
index|]
argument_list|,
name|NULL
argument_list|,
name|errno_p
argument_list|,
name|error_msg_p
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<=
name|isa
operator|->
name|max_sysreg_num
index|[
name|is_user
index|]
condition|;
name|n
operator|++
control|)
name|isa
operator|->
name|sysreg_table
index|[
name|is_user
index|]
index|[
name|n
index|]
operator|=
name|XTENSA_UNDEFINED
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|isa
operator|->
name|num_sysregs
condition|;
name|n
operator|++
control|)
block|{
name|xtensa_sysreg_internal
modifier|*
name|sreg
init|=
operator|&
name|isa
operator|->
name|sysregs
index|[
name|n
index|]
decl_stmt|;
name|is_user
operator|=
name|sreg
operator|->
name|is_user
expr_stmt|;
name|isa
operator|->
name|sysreg_table
index|[
name|is_user
index|]
index|[
name|sreg
operator|->
name|number
index|]
operator|=
name|n
expr_stmt|;
block|}
comment|/* Set up the interface lookup table.  */
name|isa
operator|->
name|interface_lookup_table
operator|=
name|bfd_malloc
argument_list|(
name|isa
operator|->
name|num_interfaces
operator|*
sizeof|sizeof
argument_list|(
name|xtensa_lookup_entry
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK_ALLOC_FOR_INIT
argument_list|(
name|isa
operator|->
name|interface_lookup_table
argument_list|,
name|NULL
argument_list|,
name|errno_p
argument_list|,
name|error_msg_p
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|isa
operator|->
name|num_interfaces
condition|;
name|n
operator|++
control|)
block|{
name|isa
operator|->
name|interface_lookup_table
index|[
name|n
index|]
operator|.
name|key
operator|=
name|isa
operator|->
name|interfaces
index|[
name|n
index|]
operator|.
name|name
expr_stmt|;
name|isa
operator|->
name|interface_lookup_table
index|[
name|n
index|]
operator|.
name|u
operator|.
name|intf
operator|=
name|n
expr_stmt|;
block|}
name|qsort
argument_list|(
name|isa
operator|->
name|interface_lookup_table
argument_list|,
name|isa
operator|->
name|num_interfaces
argument_list|,
sizeof|sizeof
argument_list|(
name|xtensa_lookup_entry
argument_list|)
argument_list|,
name|xtensa_isa_name_compare
argument_list|)
expr_stmt|;
comment|/* Set up the funcUnit lookup table.  */
name|isa
operator|->
name|funcUnit_lookup_table
operator|=
name|bfd_malloc
argument_list|(
name|isa
operator|->
name|num_funcUnits
operator|*
sizeof|sizeof
argument_list|(
name|xtensa_lookup_entry
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK_ALLOC_FOR_INIT
argument_list|(
name|isa
operator|->
name|funcUnit_lookup_table
argument_list|,
name|NULL
argument_list|,
name|errno_p
argument_list|,
name|error_msg_p
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|isa
operator|->
name|num_funcUnits
condition|;
name|n
operator|++
control|)
block|{
name|isa
operator|->
name|funcUnit_lookup_table
index|[
name|n
index|]
operator|.
name|key
operator|=
name|isa
operator|->
name|funcUnits
index|[
name|n
index|]
operator|.
name|name
expr_stmt|;
name|isa
operator|->
name|funcUnit_lookup_table
index|[
name|n
index|]
operator|.
name|u
operator|.
name|fun
operator|=
name|n
expr_stmt|;
block|}
name|qsort
argument_list|(
name|isa
operator|->
name|funcUnit_lookup_table
argument_list|,
name|isa
operator|->
name|num_funcUnits
argument_list|,
sizeof|sizeof
argument_list|(
name|xtensa_lookup_entry
argument_list|)
argument_list|,
name|xtensa_isa_name_compare
argument_list|)
expr_stmt|;
name|isa
operator|->
name|insnbuf_size
operator|=
operator|(
operator|(
name|isa
operator|->
name|insn_size
operator|+
sizeof|sizeof
argument_list|(
name|xtensa_insnbuf_word
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|xtensa_insnbuf_word
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|xtensa_isa
operator|)
name|isa
return|;
block|}
end_function

begin_function
name|void
name|xtensa_isa_free
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* With this version of the code, the xtensa_isa structure is not      dynamically allocated, so this function is not essential.  Free      the memory allocated by xtensa_isa_init and restore the xtensa_isa      structure to its initial state.  */
if|if
condition|(
name|intisa
operator|->
name|opname_lookup_table
condition|)
block|{
name|free
argument_list|(
name|intisa
operator|->
name|opname_lookup_table
argument_list|)
expr_stmt|;
name|intisa
operator|->
name|opname_lookup_table
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|intisa
operator|->
name|state_lookup_table
condition|)
block|{
name|free
argument_list|(
name|intisa
operator|->
name|state_lookup_table
argument_list|)
expr_stmt|;
name|intisa
operator|->
name|state_lookup_table
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|intisa
operator|->
name|sysreg_lookup_table
condition|)
block|{
name|free
argument_list|(
name|intisa
operator|->
name|sysreg_lookup_table
argument_list|)
expr_stmt|;
name|intisa
operator|->
name|sysreg_lookup_table
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|2
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|intisa
operator|->
name|sysreg_table
index|[
name|n
index|]
condition|)
block|{
name|free
argument_list|(
name|intisa
operator|->
name|sysreg_table
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|intisa
operator|->
name|sysreg_table
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|intisa
operator|->
name|interface_lookup_table
condition|)
block|{
name|free
argument_list|(
name|intisa
operator|->
name|interface_lookup_table
argument_list|)
expr_stmt|;
name|intisa
operator|->
name|interface_lookup_table
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|intisa
operator|->
name|funcUnit_lookup_table
condition|)
block|{
name|free
argument_list|(
name|intisa
operator|->
name|funcUnit_lookup_table
argument_list|)
expr_stmt|;
name|intisa
operator|->
name|funcUnit_lookup_table
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|xtensa_isa_name_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|v1
parameter_list|,
specifier|const
name|void
modifier|*
name|v2
parameter_list|)
block|{
name|xtensa_lookup_entry
modifier|*
name|e1
init|=
operator|(
name|xtensa_lookup_entry
operator|*
operator|)
name|v1
decl_stmt|;
name|xtensa_lookup_entry
modifier|*
name|e2
init|=
operator|(
name|xtensa_lookup_entry
operator|*
operator|)
name|v2
decl_stmt|;
return|return
name|strcasecmp
argument_list|(
name|e1
operator|->
name|key
argument_list|,
name|e2
operator|->
name|key
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|xtensa_isa_maxlength
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
return|return
name|intisa
operator|->
name|insn_size
return|;
block|}
end_function

begin_function
name|int
name|xtensa_isa_length_from_chars
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|cp
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
return|return
call|(
name|intisa
operator|->
name|length_decode_fn
call|)
argument_list|(
name|cp
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|xtensa_isa_num_pipe_stages
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
block|{
name|xtensa_opcode
name|opcode
decl_stmt|;
name|xtensa_funcUnit_use
modifier|*
name|use
decl_stmt|;
name|int
name|num_opcodes
decl_stmt|,
name|num_uses
decl_stmt|;
name|int
name|i
decl_stmt|,
name|stage
decl_stmt|,
name|max_stage
init|=
name|XTENSA_UNDEFINED
decl_stmt|;
name|num_opcodes
operator|=
name|xtensa_isa_num_opcodes
argument_list|(
name|isa
argument_list|)
expr_stmt|;
for|for
control|(
name|opcode
operator|=
literal|0
init|;
name|opcode
operator|<
name|num_opcodes
condition|;
name|opcode
operator|++
control|)
block|{
name|num_uses
operator|=
name|xtensa_opcode_num_funcUnit_uses
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_uses
condition|;
name|i
operator|++
control|)
block|{
name|use
operator|=
name|xtensa_opcode_funcUnit_use
argument_list|(
name|isa
argument_list|,
name|opcode
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|stage
operator|=
name|use
operator|->
name|stage
expr_stmt|;
if|if
condition|(
name|stage
operator|>
name|max_stage
condition|)
name|max_stage
operator|=
name|stage
expr_stmt|;
block|}
block|}
return|return
name|max_stage
operator|+
literal|1
return|;
block|}
end_function

begin_function
name|int
name|xtensa_isa_num_formats
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
return|return
name|intisa
operator|->
name|num_formats
return|;
block|}
end_function

begin_function
name|int
name|xtensa_isa_num_opcodes
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
return|return
name|intisa
operator|->
name|num_opcodes
return|;
block|}
end_function

begin_function
name|int
name|xtensa_isa_num_regfiles
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
return|return
name|intisa
operator|->
name|num_regfiles
return|;
block|}
end_function

begin_function
name|int
name|xtensa_isa_num_states
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
return|return
name|intisa
operator|->
name|num_states
return|;
block|}
end_function

begin_function
name|int
name|xtensa_isa_num_sysregs
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
return|return
name|intisa
operator|->
name|num_sysregs
return|;
block|}
end_function

begin_function
name|int
name|xtensa_isa_num_interfaces
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
return|return
name|intisa
operator|->
name|num_interfaces
return|;
block|}
end_function

begin_function
name|int
name|xtensa_isa_num_funcUnits
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
return|return
name|intisa
operator|->
name|num_funcUnits
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Instruction formats.  */
end_comment

begin_define
define|#
directive|define
name|CHECK_FORMAT
parameter_list|(
name|INTISA
parameter_list|,
name|FMT
parameter_list|,
name|ERRVAL
parameter_list|)
define|\
value|do { \     if ((FMT)< 0 || (FMT)>= (INTISA)->num_formats) \       { \ 	xtisa_errno = xtensa_isa_bad_format; \ 	strcpy (xtisa_error_msg, "invalid format specifier"); \ 	return (ERRVAL); \       } \   } while (0)
end_define

begin_define
define|#
directive|define
name|CHECK_SLOT
parameter_list|(
name|INTISA
parameter_list|,
name|FMT
parameter_list|,
name|SLOT
parameter_list|,
name|ERRVAL
parameter_list|)
define|\
value|do { \     if ((SLOT)< 0 || (SLOT)>= (INTISA)->formats[FMT].num_slots) \       { \ 	xtisa_errno = xtensa_isa_bad_slot; \ 	strcpy (xtisa_error_msg, "invalid slot specifier"); \ 	return (ERRVAL); \       } \   } while (0)
end_define

begin_function
specifier|const
name|char
modifier|*
name|xtensa_format_name
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_FORMAT
argument_list|(
name|intisa
argument_list|,
name|fmt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|intisa
operator|->
name|formats
index|[
name|fmt
index|]
operator|.
name|name
return|;
block|}
end_function

begin_function
name|xtensa_format
name|xtensa_format_lookup
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
specifier|const
name|char
modifier|*
name|fmtname
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|int
name|fmt
decl_stmt|;
if|if
condition|(
operator|!
name|fmtname
operator|||
operator|!
operator|*
name|fmtname
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_bad_format
expr_stmt|;
name|strcpy
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"invalid format name"
argument_list|)
expr_stmt|;
return|return
name|XTENSA_UNDEFINED
return|;
block|}
for|for
control|(
name|fmt
operator|=
literal|0
init|;
name|fmt
operator|<
name|intisa
operator|->
name|num_formats
condition|;
name|fmt
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|fmtname
argument_list|,
name|intisa
operator|->
name|formats
index|[
name|fmt
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|fmt
return|;
block|}
name|xtisa_errno
operator|=
name|xtensa_isa_bad_format
expr_stmt|;
name|sprintf
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"format \"%s\" not recognized"
argument_list|,
name|fmtname
argument_list|)
expr_stmt|;
return|return
name|XTENSA_UNDEFINED
return|;
block|}
end_function

begin_function
name|xtensa_format
name|xtensa_format_decode
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
specifier|const
name|xtensa_insnbuf
name|insn
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|xtensa_format
name|fmt
decl_stmt|;
name|fmt
operator|=
call|(
name|intisa
operator|->
name|format_decode_fn
call|)
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|!=
name|XTENSA_UNDEFINED
condition|)
return|return
name|fmt
return|;
name|xtisa_errno
operator|=
name|xtensa_isa_bad_format
expr_stmt|;
name|strcpy
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"cannot decode instruction format"
argument_list|)
expr_stmt|;
return|return
name|XTENSA_UNDEFINED
return|;
block|}
end_function

begin_function
name|int
name|xtensa_format_encode
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|,
name|xtensa_insnbuf
name|insn
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_FORMAT
argument_list|(
name|intisa
argument_list|,
name|fmt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|intisa
operator|->
name|formats
index|[
name|fmt
index|]
operator|.
name|encode_fn
operator|)
operator|(
name|insn
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|xtensa_format_length
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_FORMAT
argument_list|(
name|intisa
argument_list|,
name|fmt
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
return|return
name|intisa
operator|->
name|formats
index|[
name|fmt
index|]
operator|.
name|length
return|;
block|}
end_function

begin_function
name|int
name|xtensa_format_num_slots
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_FORMAT
argument_list|(
name|intisa
argument_list|,
name|fmt
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
return|return
name|intisa
operator|->
name|formats
index|[
name|fmt
index|]
operator|.
name|num_slots
return|;
block|}
end_function

begin_function
name|xtensa_opcode
name|xtensa_format_slot_nop_opcode
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|,
name|int
name|slot
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|int
name|slot_id
decl_stmt|;
name|CHECK_FORMAT
argument_list|(
name|intisa
argument_list|,
name|fmt
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
name|CHECK_SLOT
argument_list|(
name|intisa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
name|slot_id
operator|=
name|intisa
operator|->
name|formats
index|[
name|fmt
index|]
operator|.
name|slot_id
index|[
name|slot
index|]
expr_stmt|;
return|return
name|xtensa_opcode_lookup
argument_list|(
name|isa
argument_list|,
name|intisa
operator|->
name|slots
index|[
name|slot_id
index|]
operator|.
name|nop_name
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|xtensa_format_get_slot
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|,
name|int
name|slot
parameter_list|,
specifier|const
name|xtensa_insnbuf
name|insn
parameter_list|,
name|xtensa_insnbuf
name|slotbuf
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|int
name|slot_id
decl_stmt|;
name|CHECK_FORMAT
argument_list|(
name|intisa
argument_list|,
name|fmt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|CHECK_SLOT
argument_list|(
name|intisa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|slot_id
operator|=
name|intisa
operator|->
name|formats
index|[
name|fmt
index|]
operator|.
name|slot_id
index|[
name|slot
index|]
expr_stmt|;
operator|(
operator|*
name|intisa
operator|->
name|slots
index|[
name|slot_id
index|]
operator|.
name|get_fn
operator|)
operator|(
name|insn
operator|,
name|slotbuf
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|xtensa_format_set_slot
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|,
name|int
name|slot
parameter_list|,
name|xtensa_insnbuf
name|insn
parameter_list|,
specifier|const
name|xtensa_insnbuf
name|slotbuf
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|int
name|slot_id
decl_stmt|;
name|CHECK_FORMAT
argument_list|(
name|intisa
argument_list|,
name|fmt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|CHECK_SLOT
argument_list|(
name|intisa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|slot_id
operator|=
name|intisa
operator|->
name|formats
index|[
name|fmt
index|]
operator|.
name|slot_id
index|[
name|slot
index|]
expr_stmt|;
operator|(
operator|*
name|intisa
operator|->
name|slots
index|[
name|slot_id
index|]
operator|.
name|set_fn
operator|)
operator|(
name|insn
operator|,
name|slotbuf
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Opcode information.  */
end_comment

begin_define
define|#
directive|define
name|CHECK_OPCODE
parameter_list|(
name|INTISA
parameter_list|,
name|OPC
parameter_list|,
name|ERRVAL
parameter_list|)
define|\
value|do { \     if ((OPC)< 0 || (OPC)>= (INTISA)->num_opcodes) \       { \ 	xtisa_errno = xtensa_isa_bad_opcode; \ 	strcpy (xtisa_error_msg, "invalid opcode specifier"); \ 	return (ERRVAL); \       } \   } while (0)
end_define

begin_function
name|xtensa_opcode
name|xtensa_opcode_lookup
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
specifier|const
name|char
modifier|*
name|opname
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|xtensa_lookup_entry
name|entry
decl_stmt|,
modifier|*
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|opname
operator|||
operator|!
operator|*
name|opname
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_bad_opcode
expr_stmt|;
name|strcpy
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"invalid opcode name"
argument_list|)
expr_stmt|;
return|return
name|XTENSA_UNDEFINED
return|;
block|}
if|if
condition|(
name|intisa
operator|->
name|num_opcodes
operator|!=
literal|0
condition|)
block|{
name|entry
operator|.
name|key
operator|=
name|opname
expr_stmt|;
name|result
operator|=
name|bsearch
argument_list|(
operator|&
name|entry
argument_list|,
name|intisa
operator|->
name|opname_lookup_table
argument_list|,
name|intisa
operator|->
name|num_opcodes
argument_list|,
sizeof|sizeof
argument_list|(
name|xtensa_lookup_entry
argument_list|)
argument_list|,
name|xtensa_isa_name_compare
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_bad_opcode
expr_stmt|;
name|sprintf
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"opcode \"%s\" not recognized"
argument_list|,
name|opname
argument_list|)
expr_stmt|;
return|return
name|XTENSA_UNDEFINED
return|;
block|}
return|return
name|result
operator|->
name|u
operator|.
name|opcode
return|;
block|}
end_function

begin_function
name|xtensa_opcode
name|xtensa_opcode_decode
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|,
name|int
name|slot
parameter_list|,
specifier|const
name|xtensa_insnbuf
name|slotbuf
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|int
name|slot_id
decl_stmt|;
name|xtensa_opcode
name|opc
decl_stmt|;
name|CHECK_FORMAT
argument_list|(
name|intisa
argument_list|,
name|fmt
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
name|CHECK_SLOT
argument_list|(
name|intisa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
name|slot_id
operator|=
name|intisa
operator|->
name|formats
index|[
name|fmt
index|]
operator|.
name|slot_id
index|[
name|slot
index|]
expr_stmt|;
name|opc
operator|=
operator|(
name|intisa
operator|->
name|slots
index|[
name|slot_id
index|]
operator|.
name|opcode_decode_fn
operator|)
operator|(
name|slotbuf
operator|)
expr_stmt|;
if|if
condition|(
name|opc
operator|!=
name|XTENSA_UNDEFINED
condition|)
return|return
name|opc
return|;
name|xtisa_errno
operator|=
name|xtensa_isa_bad_opcode
expr_stmt|;
name|strcpy
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"cannot decode opcode"
argument_list|)
expr_stmt|;
return|return
name|XTENSA_UNDEFINED
return|;
block|}
end_function

begin_function
name|int
name|xtensa_opcode_encode
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|,
name|int
name|slot
parameter_list|,
name|xtensa_insnbuf
name|slotbuf
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|int
name|slot_id
decl_stmt|;
name|xtensa_opcode_encode_fn
name|encode_fn
decl_stmt|;
name|CHECK_FORMAT
argument_list|(
name|intisa
argument_list|,
name|fmt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|CHECK_SLOT
argument_list|(
name|intisa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|CHECK_OPCODE
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|slot_id
operator|=
name|intisa
operator|->
name|formats
index|[
name|fmt
index|]
operator|.
name|slot_id
index|[
name|slot
index|]
expr_stmt|;
name|encode_fn
operator|=
name|intisa
operator|->
name|opcodes
index|[
name|opc
index|]
operator|.
name|encode_fns
index|[
name|slot_id
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|encode_fn
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_wrong_slot
expr_stmt|;
name|sprintf
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"opcode \"%s\" is not allowed in slot %d of format \"%s\""
argument_list|,
name|intisa
operator|->
name|opcodes
index|[
name|opc
index|]
operator|.
name|name
argument_list|,
name|slot
argument_list|,
name|intisa
operator|->
name|formats
index|[
name|fmt
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
call|(
modifier|*
name|encode_fn
call|)
argument_list|(
name|slotbuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|xtensa_opcode_name
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_OPCODE
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|intisa
operator|->
name|opcodes
index|[
name|opc
index|]
operator|.
name|name
return|;
block|}
end_function

begin_function
name|int
name|xtensa_opcode_is_branch
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_OPCODE
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intisa
operator|->
name|opcodes
index|[
name|opc
index|]
operator|.
name|flags
operator|&
name|XTENSA_OPCODE_IS_BRANCH
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|xtensa_opcode_is_jump
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_OPCODE
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intisa
operator|->
name|opcodes
index|[
name|opc
index|]
operator|.
name|flags
operator|&
name|XTENSA_OPCODE_IS_JUMP
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|xtensa_opcode_is_loop
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_OPCODE
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intisa
operator|->
name|opcodes
index|[
name|opc
index|]
operator|.
name|flags
operator|&
name|XTENSA_OPCODE_IS_LOOP
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|xtensa_opcode_is_call
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_OPCODE
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intisa
operator|->
name|opcodes
index|[
name|opc
index|]
operator|.
name|flags
operator|&
name|XTENSA_OPCODE_IS_CALL
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|xtensa_opcode_num_operands
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|int
name|iclass_id
decl_stmt|;
name|CHECK_OPCODE
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
name|iclass_id
operator|=
name|intisa
operator|->
name|opcodes
index|[
name|opc
index|]
operator|.
name|iclass_id
expr_stmt|;
return|return
name|intisa
operator|->
name|iclasses
index|[
name|iclass_id
index|]
operator|.
name|num_operands
return|;
block|}
end_function

begin_function
name|int
name|xtensa_opcode_num_stateOperands
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|int
name|iclass_id
decl_stmt|;
name|CHECK_OPCODE
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
name|iclass_id
operator|=
name|intisa
operator|->
name|opcodes
index|[
name|opc
index|]
operator|.
name|iclass_id
expr_stmt|;
return|return
name|intisa
operator|->
name|iclasses
index|[
name|iclass_id
index|]
operator|.
name|num_stateOperands
return|;
block|}
end_function

begin_function
name|int
name|xtensa_opcode_num_interfaceOperands
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|int
name|iclass_id
decl_stmt|;
name|CHECK_OPCODE
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
name|iclass_id
operator|=
name|intisa
operator|->
name|opcodes
index|[
name|opc
index|]
operator|.
name|iclass_id
expr_stmt|;
return|return
name|intisa
operator|->
name|iclasses
index|[
name|iclass_id
index|]
operator|.
name|num_interfaceOperands
return|;
block|}
end_function

begin_function
name|int
name|xtensa_opcode_num_funcUnit_uses
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_OPCODE
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
return|return
name|intisa
operator|->
name|opcodes
index|[
name|opc
index|]
operator|.
name|num_funcUnit_uses
return|;
block|}
end_function

begin_function
name|xtensa_funcUnit_use
modifier|*
name|xtensa_opcode_funcUnit_use
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|u
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_OPCODE
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|<
literal|0
operator|||
name|u
operator|>=
name|intisa
operator|->
name|opcodes
index|[
name|opc
index|]
operator|.
name|num_funcUnit_uses
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_bad_funcUnit
expr_stmt|;
name|sprintf
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"invalid functional unit use number (%d); "
literal|"opcode \"%s\" has %d"
argument_list|,
name|u
argument_list|,
name|intisa
operator|->
name|opcodes
index|[
name|opc
index|]
operator|.
name|name
argument_list|,
name|intisa
operator|->
name|opcodes
index|[
name|opc
index|]
operator|.
name|num_funcUnit_uses
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|&
name|intisa
operator|->
name|opcodes
index|[
name|opc
index|]
operator|.
name|funcUnit_uses
index|[
name|u
index|]
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Operand information.  */
end_comment

begin_define
define|#
directive|define
name|CHECK_OPERAND
parameter_list|(
name|INTISA
parameter_list|,
name|OPC
parameter_list|,
name|ICLASS
parameter_list|,
name|OPND
parameter_list|,
name|ERRVAL
parameter_list|)
define|\
value|do { \     if ((OPND)< 0 || (OPND)>= (ICLASS)->num_operands) \       { \ 	xtisa_errno = xtensa_isa_bad_operand; \ 	sprintf (xtisa_error_msg, "invalid operand number (%d); " \ 		 "opcode \"%s\" has %d operands", (OPND), \ 		 (INTISA)->opcodes[(OPC)].name, (ICLASS)->num_operands); \ 	return (ERRVAL); \       } \   } while (0)
end_define

begin_function
specifier|static
name|xtensa_operand_internal
modifier|*
name|get_operand
parameter_list|(
name|xtensa_isa_internal
modifier|*
name|intisa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|)
block|{
name|xtensa_iclass_internal
modifier|*
name|iclass
decl_stmt|;
name|int
name|iclass_id
decl_stmt|,
name|operand_id
decl_stmt|;
name|CHECK_OPCODE
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|iclass_id
operator|=
name|intisa
operator|->
name|opcodes
index|[
name|opc
index|]
operator|.
name|iclass_id
expr_stmt|;
name|iclass
operator|=
operator|&
name|intisa
operator|->
name|iclasses
index|[
name|iclass_id
index|]
expr_stmt|;
name|CHECK_OPERAND
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|iclass
argument_list|,
name|opnd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|operand_id
operator|=
name|iclass
operator|->
name|operands
index|[
name|opnd
index|]
operator|.
name|u
operator|.
name|operand_id
expr_stmt|;
return|return
operator|&
name|intisa
operator|->
name|operands
index|[
name|operand_id
index|]
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|xtensa_operand_name
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|xtensa_operand_internal
modifier|*
name|intop
decl_stmt|;
name|intop
operator|=
name|get_operand
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intop
condition|)
return|return
name|NULL
return|;
return|return
name|intop
operator|->
name|name
return|;
block|}
end_function

begin_function
name|int
name|xtensa_operand_is_visible
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|xtensa_iclass_internal
modifier|*
name|iclass
decl_stmt|;
name|int
name|iclass_id
decl_stmt|,
name|operand_id
decl_stmt|;
name|xtensa_operand_internal
modifier|*
name|intop
decl_stmt|;
name|CHECK_OPCODE
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
name|iclass_id
operator|=
name|intisa
operator|->
name|opcodes
index|[
name|opc
index|]
operator|.
name|iclass_id
expr_stmt|;
name|iclass
operator|=
operator|&
name|intisa
operator|->
name|iclasses
index|[
name|iclass_id
index|]
expr_stmt|;
name|CHECK_OPERAND
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|iclass
argument_list|,
name|opnd
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
comment|/* Special case for "sout" operands.  */
if|if
condition|(
name|iclass
operator|->
name|operands
index|[
name|opnd
index|]
operator|.
name|inout
operator|==
literal|'s'
condition|)
return|return
literal|0
return|;
name|operand_id
operator|=
name|iclass
operator|->
name|operands
index|[
name|opnd
index|]
operator|.
name|u
operator|.
name|operand_id
expr_stmt|;
name|intop
operator|=
operator|&
name|intisa
operator|->
name|operands
index|[
name|operand_id
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|intop
operator|->
name|flags
operator|&
name|XTENSA_OPERAND_IS_INVISIBLE
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
name|xtensa_operand_inout
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|xtensa_iclass_internal
modifier|*
name|iclass
decl_stmt|;
name|int
name|iclass_id
decl_stmt|;
name|char
name|inout
decl_stmt|;
name|CHECK_OPCODE
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iclass_id
operator|=
name|intisa
operator|->
name|opcodes
index|[
name|opc
index|]
operator|.
name|iclass_id
expr_stmt|;
name|iclass
operator|=
operator|&
name|intisa
operator|->
name|iclasses
index|[
name|iclass_id
index|]
expr_stmt|;
name|CHECK_OPERAND
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|iclass
argument_list|,
name|opnd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inout
operator|=
name|iclass
operator|->
name|operands
index|[
name|opnd
index|]
operator|.
name|inout
expr_stmt|;
comment|/* Special case for "sout" operands.  */
if|if
condition|(
name|inout
operator|==
literal|'s'
condition|)
return|return
literal|'o'
return|;
return|return
name|inout
return|;
block|}
end_function

begin_function
name|int
name|xtensa_operand_get_field
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|,
name|int
name|slot
parameter_list|,
specifier|const
name|xtensa_insnbuf
name|slotbuf
parameter_list|,
name|uint32
modifier|*
name|valp
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|xtensa_operand_internal
modifier|*
name|intop
decl_stmt|;
name|int
name|slot_id
decl_stmt|;
name|xtensa_get_field_fn
name|get_fn
decl_stmt|;
name|intop
operator|=
name|get_operand
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intop
condition|)
return|return
operator|-
literal|1
return|;
name|CHECK_FORMAT
argument_list|(
name|intisa
argument_list|,
name|fmt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|CHECK_SLOT
argument_list|(
name|intisa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|slot_id
operator|=
name|intisa
operator|->
name|formats
index|[
name|fmt
index|]
operator|.
name|slot_id
index|[
name|slot
index|]
expr_stmt|;
if|if
condition|(
name|intop
operator|->
name|field_id
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_no_field
expr_stmt|;
name|strcpy
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"implicit operand has no field"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|get_fn
operator|=
name|intisa
operator|->
name|slots
index|[
name|slot_id
index|]
operator|.
name|get_field_fns
index|[
name|intop
operator|->
name|field_id
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|get_fn
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_wrong_slot
expr_stmt|;
name|sprintf
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"operand \"%s\" does not exist in slot %d of format \"%s\""
argument_list|,
name|intop
operator|->
name|name
argument_list|,
name|slot
argument_list|,
name|intisa
operator|->
name|formats
index|[
name|fmt
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|valp
operator|=
call|(
modifier|*
name|get_fn
call|)
argument_list|(
name|slotbuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|xtensa_operand_set_field
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|,
name|xtensa_format
name|fmt
parameter_list|,
name|int
name|slot
parameter_list|,
name|xtensa_insnbuf
name|slotbuf
parameter_list|,
name|uint32
name|val
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|xtensa_operand_internal
modifier|*
name|intop
decl_stmt|;
name|int
name|slot_id
decl_stmt|;
name|xtensa_set_field_fn
name|set_fn
decl_stmt|;
name|intop
operator|=
name|get_operand
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intop
condition|)
return|return
operator|-
literal|1
return|;
name|CHECK_FORMAT
argument_list|(
name|intisa
argument_list|,
name|fmt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|CHECK_SLOT
argument_list|(
name|intisa
argument_list|,
name|fmt
argument_list|,
name|slot
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|slot_id
operator|=
name|intisa
operator|->
name|formats
index|[
name|fmt
index|]
operator|.
name|slot_id
index|[
name|slot
index|]
expr_stmt|;
if|if
condition|(
name|intop
operator|->
name|field_id
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_no_field
expr_stmt|;
name|strcpy
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"implicit operand has no field"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|set_fn
operator|=
name|intisa
operator|->
name|slots
index|[
name|slot_id
index|]
operator|.
name|set_field_fns
index|[
name|intop
operator|->
name|field_id
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|set_fn
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_wrong_slot
expr_stmt|;
name|sprintf
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"operand \"%s\" does not exist in slot %d of format \"%s\""
argument_list|,
name|intop
operator|->
name|name
argument_list|,
name|slot
argument_list|,
name|intisa
operator|->
name|formats
index|[
name|fmt
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
call|(
modifier|*
name|set_fn
call|)
argument_list|(
name|slotbuf
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|xtensa_operand_encode
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|,
name|uint32
modifier|*
name|valp
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|xtensa_operand_internal
modifier|*
name|intop
decl_stmt|;
name|uint32
name|test_val
decl_stmt|,
name|orig_val
decl_stmt|;
name|intop
operator|=
name|get_operand
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intop
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|intop
operator|->
name|encode
condition|)
block|{
comment|/* This is a default operand for a field.  How can we tell if the 	 value fits in the field?  Write the value into the field, 	 read it back, and then make sure we get the same value.  */
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
specifier|static
name|xtensa_insnbuf
name|tmpbuf
init|=
literal|0
decl_stmt|;
name|int
name|slot_id
decl_stmt|;
if|if
condition|(
operator|!
name|tmpbuf
condition|)
block|{
name|tmpbuf
operator|=
name|xtensa_insnbuf_alloc
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|CHECK_ALLOC
argument_list|(
name|tmpbuf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* A default operand is always associated with a field, 	 but check just to be sure....  */
if|if
condition|(
name|intop
operator|->
name|field_id
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_internal_error
expr_stmt|;
name|strcpy
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"operand has no field"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Find some slot that includes the field.  */
for|for
control|(
name|slot_id
operator|=
literal|0
init|;
name|slot_id
operator|<
name|intisa
operator|->
name|num_slots
condition|;
name|slot_id
operator|++
control|)
block|{
name|xtensa_get_field_fn
name|get_fn
init|=
name|intisa
operator|->
name|slots
index|[
name|slot_id
index|]
operator|.
name|get_field_fns
index|[
name|intop
operator|->
name|field_id
index|]
decl_stmt|;
name|xtensa_set_field_fn
name|set_fn
init|=
name|intisa
operator|->
name|slots
index|[
name|slot_id
index|]
operator|.
name|set_field_fns
index|[
name|intop
operator|->
name|field_id
index|]
decl_stmt|;
if|if
condition|(
name|get_fn
operator|&&
name|set_fn
condition|)
block|{
call|(
modifier|*
name|set_fn
call|)
argument_list|(
name|tmpbuf
argument_list|,
operator|*
name|valp
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
modifier|*
name|get_fn
call|)
argument_list|(
name|tmpbuf
argument_list|)
operator|!=
operator|*
name|valp
operator|)
return|;
block|}
block|}
comment|/* Couldn't find any slot containing the field....  */
name|xtisa_errno
operator|=
name|xtensa_isa_no_field
expr_stmt|;
name|strcpy
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"field does not exist in any slot"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Encode the value.  In some cases, the encoding function may detect      errors, but most of the time the only way to determine if the value      was successfully encoded is to decode it and check if it matches      the original value.  */
name|orig_val
operator|=
operator|*
name|valp
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|intop
operator|->
name|encode
call|)
argument_list|(
name|valp
argument_list|)
operator|||
operator|(
name|test_val
operator|=
operator|*
name|valp
operator|,
call|(
modifier|*
name|intop
operator|->
name|decode
call|)
argument_list|(
operator|&
name|test_val
argument_list|)
operator|)
operator|||
name|test_val
operator|!=
name|orig_val
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_bad_value
expr_stmt|;
name|sprintf
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"cannot encode operand value 0x%08x"
argument_list|,
operator|*
name|valp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|xtensa_operand_decode
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|,
name|uint32
modifier|*
name|valp
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|xtensa_operand_internal
modifier|*
name|intop
decl_stmt|;
name|intop
operator|=
name|get_operand
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intop
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Use identity function for "default" operands.  */
if|if
condition|(
operator|!
name|intop
operator|->
name|decode
condition|)
return|return
literal|0
return|;
if|if
condition|(
call|(
modifier|*
name|intop
operator|->
name|decode
call|)
argument_list|(
name|valp
argument_list|)
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_bad_value
expr_stmt|;
name|sprintf
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"cannot decode operand value 0x%08x"
argument_list|,
operator|*
name|valp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|xtensa_operand_is_register
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|xtensa_operand_internal
modifier|*
name|intop
decl_stmt|;
name|intop
operator|=
name|get_operand
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intop
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
if|if
condition|(
operator|(
name|intop
operator|->
name|flags
operator|&
name|XTENSA_OPERAND_IS_REGISTER
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|xtensa_regfile
name|xtensa_operand_regfile
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|xtensa_operand_internal
modifier|*
name|intop
decl_stmt|;
name|intop
operator|=
name|get_operand
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intop
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
return|return
name|intop
operator|->
name|regfile
return|;
block|}
end_function

begin_function
name|int
name|xtensa_operand_num_regs
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|xtensa_operand_internal
modifier|*
name|intop
decl_stmt|;
name|intop
operator|=
name|get_operand
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intop
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
return|return
name|intop
operator|->
name|num_regs
return|;
block|}
end_function

begin_function
name|int
name|xtensa_operand_is_known_reg
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|xtensa_operand_internal
modifier|*
name|intop
decl_stmt|;
name|intop
operator|=
name|get_operand
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intop
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
if|if
condition|(
operator|(
name|intop
operator|->
name|flags
operator|&
name|XTENSA_OPERAND_IS_UNKNOWN
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|xtensa_operand_is_PCrelative
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|xtensa_operand_internal
modifier|*
name|intop
decl_stmt|;
name|intop
operator|=
name|get_operand
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intop
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
if|if
condition|(
operator|(
name|intop
operator|->
name|flags
operator|&
name|XTENSA_OPERAND_IS_PCRELATIVE
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|xtensa_operand_do_reloc
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|,
name|uint32
modifier|*
name|valp
parameter_list|,
name|uint32
name|pc
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|xtensa_operand_internal
modifier|*
name|intop
decl_stmt|;
name|intop
operator|=
name|get_operand
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intop
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|intop
operator|->
name|flags
operator|&
name|XTENSA_OPERAND_IS_PCRELATIVE
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|intop
operator|->
name|do_reloc
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_internal_error
expr_stmt|;
name|strcpy
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"operand missing do_reloc function"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
call|(
modifier|*
name|intop
operator|->
name|do_reloc
call|)
argument_list|(
name|valp
argument_list|,
name|pc
argument_list|)
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_bad_value
expr_stmt|;
name|sprintf
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"do_reloc failed for value 0x%08x at PC 0x%08x"
argument_list|,
operator|*
name|valp
argument_list|,
name|pc
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|xtensa_operand_undo_reloc
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|,
name|uint32
modifier|*
name|valp
parameter_list|,
name|uint32
name|pc
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|xtensa_operand_internal
modifier|*
name|intop
decl_stmt|;
name|intop
operator|=
name|get_operand
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|opnd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|intop
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|intop
operator|->
name|flags
operator|&
name|XTENSA_OPERAND_IS_PCRELATIVE
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|intop
operator|->
name|undo_reloc
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_internal_error
expr_stmt|;
name|strcpy
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"operand missing undo_reloc function"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
call|(
modifier|*
name|intop
operator|->
name|undo_reloc
call|)
argument_list|(
name|valp
argument_list|,
name|pc
argument_list|)
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_bad_value
expr_stmt|;
name|sprintf
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"undo_reloc failed for value 0x%08x at PC 0x%08x"
argument_list|,
operator|*
name|valp
argument_list|,
name|pc
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* State Operands.  */
end_comment

begin_define
define|#
directive|define
name|CHECK_STATE_OPERAND
parameter_list|(
name|INTISA
parameter_list|,
name|OPC
parameter_list|,
name|ICLASS
parameter_list|,
name|STOP
parameter_list|,
name|ERRVAL
parameter_list|)
define|\
value|do { \     if ((STOP)< 0 || (STOP)>= (ICLASS)->num_stateOperands) \       { \ 	xtisa_errno = xtensa_isa_bad_operand; \ 	sprintf (xtisa_error_msg, "invalid state operand number (%d); " \ 		 "opcode \"%s\" has %d state operands", (STOP), \ 		 (INTISA)->opcodes[(OPC)].name, (ICLASS)->num_stateOperands); \ 	return (ERRVAL); \       } \   } while (0)
end_define

begin_function
name|xtensa_state
name|xtensa_stateOperand_state
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|stOp
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|xtensa_iclass_internal
modifier|*
name|iclass
decl_stmt|;
name|int
name|iclass_id
decl_stmt|;
name|CHECK_OPCODE
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
name|iclass_id
operator|=
name|intisa
operator|->
name|opcodes
index|[
name|opc
index|]
operator|.
name|iclass_id
expr_stmt|;
name|iclass
operator|=
operator|&
name|intisa
operator|->
name|iclasses
index|[
name|iclass_id
index|]
expr_stmt|;
name|CHECK_STATE_OPERAND
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|iclass
argument_list|,
name|stOp
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
return|return
name|iclass
operator|->
name|stateOperands
index|[
name|stOp
index|]
operator|.
name|u
operator|.
name|state
return|;
block|}
end_function

begin_function
name|char
name|xtensa_stateOperand_inout
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|stOp
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|xtensa_iclass_internal
modifier|*
name|iclass
decl_stmt|;
name|int
name|iclass_id
decl_stmt|;
name|CHECK_OPCODE
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iclass_id
operator|=
name|intisa
operator|->
name|opcodes
index|[
name|opc
index|]
operator|.
name|iclass_id
expr_stmt|;
name|iclass
operator|=
operator|&
name|intisa
operator|->
name|iclasses
index|[
name|iclass_id
index|]
expr_stmt|;
name|CHECK_STATE_OPERAND
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|iclass
argument_list|,
name|stOp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|iclass
operator|->
name|stateOperands
index|[
name|stOp
index|]
operator|.
name|inout
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Interface Operands.  */
end_comment

begin_define
define|#
directive|define
name|CHECK_INTERFACE_OPERAND
parameter_list|(
name|INTISA
parameter_list|,
name|OPC
parameter_list|,
name|ICLASS
parameter_list|,
name|IFOP
parameter_list|,
name|ERRVAL
parameter_list|)
define|\
value|do { \     if ((IFOP)< 0 || (IFOP)>= (ICLASS)->num_interfaceOperands) \       { \ 	xtisa_errno = xtensa_isa_bad_operand; \ 	sprintf (xtisa_error_msg, "invalid interface operand number (%d); " \ 		 "opcode \"%s\" has %d interface operands", (IFOP), \ 		 (INTISA)->opcodes[(OPC)].name, \ 		 (ICLASS)->num_interfaceOperands); \ 	return (ERRVAL); \       } \   } while (0)
end_define

begin_function
name|xtensa_interface
name|xtensa_interfaceOperand_interface
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|ifOp
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|xtensa_iclass_internal
modifier|*
name|iclass
decl_stmt|;
name|int
name|iclass_id
decl_stmt|;
name|CHECK_OPCODE
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
name|iclass_id
operator|=
name|intisa
operator|->
name|opcodes
index|[
name|opc
index|]
operator|.
name|iclass_id
expr_stmt|;
name|iclass
operator|=
operator|&
name|intisa
operator|->
name|iclasses
index|[
name|iclass_id
index|]
expr_stmt|;
name|CHECK_INTERFACE_OPERAND
argument_list|(
name|intisa
argument_list|,
name|opc
argument_list|,
name|iclass
argument_list|,
name|ifOp
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
return|return
name|iclass
operator|->
name|interfaceOperands
index|[
name|ifOp
index|]
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Register Files.  */
end_comment

begin_define
define|#
directive|define
name|CHECK_REGFILE
parameter_list|(
name|INTISA
parameter_list|,
name|RF
parameter_list|,
name|ERRVAL
parameter_list|)
define|\
value|do { \     if ((RF)< 0 || (RF)>= (INTISA)->num_regfiles) \       { \ 	xtisa_errno = xtensa_isa_bad_regfile; \ 	strcpy (xtisa_error_msg, "invalid regfile specifier"); \ 	return (ERRVAL); \       } \   } while (0)
end_define

begin_function
name|xtensa_regfile
name|xtensa_regfile_lookup
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|||
operator|!
operator|*
name|name
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_bad_regfile
expr_stmt|;
name|strcpy
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"invalid regfile name"
argument_list|)
expr_stmt|;
return|return
name|XTENSA_UNDEFINED
return|;
block|}
comment|/* The expected number of regfiles is small; use a linear search.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|intisa
operator|->
name|num_regfiles
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|intisa
operator|->
name|regfiles
index|[
name|n
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|n
return|;
block|}
name|xtisa_errno
operator|=
name|xtensa_isa_bad_regfile
expr_stmt|;
name|sprintf
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"regfile \"%s\" not recognized"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|XTENSA_UNDEFINED
return|;
block|}
end_function

begin_function
name|xtensa_regfile
name|xtensa_regfile_lookup_shortname
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
specifier|const
name|char
modifier|*
name|shortname
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|shortname
operator|||
operator|!
operator|*
name|shortname
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_bad_regfile
expr_stmt|;
name|strcpy
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"invalid regfile shortname"
argument_list|)
expr_stmt|;
return|return
name|XTENSA_UNDEFINED
return|;
block|}
comment|/* The expected number of regfiles is small; use a linear search.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|intisa
operator|->
name|num_regfiles
condition|;
name|n
operator|++
control|)
block|{
comment|/* Ignore regfile views since they always have the same shortnames 	 as their parents.  */
if|if
condition|(
name|intisa
operator|->
name|regfiles
index|[
name|n
index|]
operator|.
name|parent
operator|!=
name|n
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|intisa
operator|->
name|regfiles
index|[
name|n
index|]
operator|.
name|shortname
argument_list|,
name|shortname
argument_list|)
condition|)
return|return
name|n
return|;
block|}
name|xtisa_errno
operator|=
name|xtensa_isa_bad_regfile
expr_stmt|;
name|sprintf
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"regfile shortname \"%s\" not recognized"
argument_list|,
name|shortname
argument_list|)
expr_stmt|;
return|return
name|XTENSA_UNDEFINED
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|xtensa_regfile_name
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_regfile
name|rf
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_REGFILE
argument_list|(
name|intisa
argument_list|,
name|rf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|intisa
operator|->
name|regfiles
index|[
name|rf
index|]
operator|.
name|name
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|xtensa_regfile_shortname
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_regfile
name|rf
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_REGFILE
argument_list|(
name|intisa
argument_list|,
name|rf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|intisa
operator|->
name|regfiles
index|[
name|rf
index|]
operator|.
name|shortname
return|;
block|}
end_function

begin_function
name|xtensa_regfile
name|xtensa_regfile_view_parent
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_regfile
name|rf
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_REGFILE
argument_list|(
name|intisa
argument_list|,
name|rf
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
return|return
name|intisa
operator|->
name|regfiles
index|[
name|rf
index|]
operator|.
name|parent
return|;
block|}
end_function

begin_function
name|int
name|xtensa_regfile_num_bits
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_regfile
name|rf
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_REGFILE
argument_list|(
name|intisa
argument_list|,
name|rf
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
return|return
name|intisa
operator|->
name|regfiles
index|[
name|rf
index|]
operator|.
name|num_bits
return|;
block|}
end_function

begin_function
name|int
name|xtensa_regfile_num_entries
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_regfile
name|rf
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_REGFILE
argument_list|(
name|intisa
argument_list|,
name|rf
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
return|return
name|intisa
operator|->
name|regfiles
index|[
name|rf
index|]
operator|.
name|num_entries
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Processor States.  */
end_comment

begin_define
define|#
directive|define
name|CHECK_STATE
parameter_list|(
name|INTISA
parameter_list|,
name|ST
parameter_list|,
name|ERRVAL
parameter_list|)
define|\
value|do { \     if ((ST)< 0 || (ST)>= (INTISA)->num_states) \       { \ 	xtisa_errno = xtensa_isa_bad_state; \ 	strcpy (xtisa_error_msg, "invalid state specifier"); \ 	return (ERRVAL); \       } \   } while (0)
end_define

begin_function
name|xtensa_state
name|xtensa_state_lookup
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|xtensa_lookup_entry
name|entry
decl_stmt|,
modifier|*
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|||
operator|!
operator|*
name|name
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_bad_state
expr_stmt|;
name|strcpy
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"invalid state name"
argument_list|)
expr_stmt|;
return|return
name|XTENSA_UNDEFINED
return|;
block|}
if|if
condition|(
name|intisa
operator|->
name|num_states
operator|!=
literal|0
condition|)
block|{
name|entry
operator|.
name|key
operator|=
name|name
expr_stmt|;
name|result
operator|=
name|bsearch
argument_list|(
operator|&
name|entry
argument_list|,
name|intisa
operator|->
name|state_lookup_table
argument_list|,
name|intisa
operator|->
name|num_states
argument_list|,
sizeof|sizeof
argument_list|(
name|xtensa_lookup_entry
argument_list|)
argument_list|,
name|xtensa_isa_name_compare
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_bad_state
expr_stmt|;
name|sprintf
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"state \"%s\" not recognized"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|XTENSA_UNDEFINED
return|;
block|}
return|return
name|result
operator|->
name|u
operator|.
name|state
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|xtensa_state_name
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_state
name|st
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_STATE
argument_list|(
name|intisa
argument_list|,
name|st
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|intisa
operator|->
name|states
index|[
name|st
index|]
operator|.
name|name
return|;
block|}
end_function

begin_function
name|int
name|xtensa_state_num_bits
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_state
name|st
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_STATE
argument_list|(
name|intisa
argument_list|,
name|st
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
return|return
name|intisa
operator|->
name|states
index|[
name|st
index|]
operator|.
name|num_bits
return|;
block|}
end_function

begin_function
name|int
name|xtensa_state_is_exported
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_state
name|st
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_STATE
argument_list|(
name|intisa
argument_list|,
name|st
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intisa
operator|->
name|states
index|[
name|st
index|]
operator|.
name|flags
operator|&
name|XTENSA_STATE_IS_EXPORTED
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Sysregs.  */
end_comment

begin_define
define|#
directive|define
name|CHECK_SYSREG
parameter_list|(
name|INTISA
parameter_list|,
name|SYSREG
parameter_list|,
name|ERRVAL
parameter_list|)
define|\
value|do { \     if ((SYSREG)< 0 || (SYSREG)>= (INTISA)->num_sysregs) \       { \ 	xtisa_errno = xtensa_isa_bad_sysreg; \ 	strcpy (xtisa_error_msg, "invalid sysreg specifier"); \ 	return (ERRVAL); \       } \   } while (0)
end_define

begin_function
name|xtensa_sysreg
name|xtensa_sysreg_lookup
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|int
name|num
parameter_list|,
name|int
name|is_user
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
if|if
condition|(
name|is_user
operator|!=
literal|0
condition|)
name|is_user
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|num
operator|<
literal|0
operator|||
name|num
operator|>
name|intisa
operator|->
name|max_sysreg_num
index|[
name|is_user
index|]
operator|||
name|intisa
operator|->
name|sysreg_table
index|[
name|is_user
index|]
index|[
name|num
index|]
operator|==
name|XTENSA_UNDEFINED
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_bad_sysreg
expr_stmt|;
name|strcpy
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"sysreg not recognized"
argument_list|)
expr_stmt|;
return|return
name|XTENSA_UNDEFINED
return|;
block|}
return|return
name|intisa
operator|->
name|sysreg_table
index|[
name|is_user
index|]
index|[
name|num
index|]
return|;
block|}
end_function

begin_function
name|xtensa_sysreg
name|xtensa_sysreg_lookup_name
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|xtensa_lookup_entry
name|entry
decl_stmt|,
modifier|*
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|||
operator|!
operator|*
name|name
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_bad_sysreg
expr_stmt|;
name|strcpy
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"invalid sysreg name"
argument_list|)
expr_stmt|;
return|return
name|XTENSA_UNDEFINED
return|;
block|}
if|if
condition|(
name|intisa
operator|->
name|num_sysregs
operator|!=
literal|0
condition|)
block|{
name|entry
operator|.
name|key
operator|=
name|name
expr_stmt|;
name|result
operator|=
name|bsearch
argument_list|(
operator|&
name|entry
argument_list|,
name|intisa
operator|->
name|sysreg_lookup_table
argument_list|,
name|intisa
operator|->
name|num_sysregs
argument_list|,
sizeof|sizeof
argument_list|(
name|xtensa_lookup_entry
argument_list|)
argument_list|,
name|xtensa_isa_name_compare
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_bad_sysreg
expr_stmt|;
name|sprintf
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"sysreg \"%s\" not recognized"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|XTENSA_UNDEFINED
return|;
block|}
return|return
name|result
operator|->
name|u
operator|.
name|sysreg
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|xtensa_sysreg_name
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_sysreg
name|sysreg
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_SYSREG
argument_list|(
name|intisa
argument_list|,
name|sysreg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|intisa
operator|->
name|sysregs
index|[
name|sysreg
index|]
operator|.
name|name
return|;
block|}
end_function

begin_function
name|int
name|xtensa_sysreg_number
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_sysreg
name|sysreg
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_SYSREG
argument_list|(
name|intisa
argument_list|,
name|sysreg
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
return|return
name|intisa
operator|->
name|sysregs
index|[
name|sysreg
index|]
operator|.
name|number
return|;
block|}
end_function

begin_function
name|int
name|xtensa_sysreg_is_user
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_sysreg
name|sysreg
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_SYSREG
argument_list|(
name|intisa
argument_list|,
name|sysreg
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
if|if
condition|(
name|intisa
operator|->
name|sysregs
index|[
name|sysreg
index|]
operator|.
name|is_user
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Interfaces.  */
end_comment

begin_define
define|#
directive|define
name|CHECK_INTERFACE
parameter_list|(
name|INTISA
parameter_list|,
name|INTF
parameter_list|,
name|ERRVAL
parameter_list|)
define|\
value|do { \     if ((INTF)< 0 || (INTF)>= (INTISA)->num_interfaces) \       { \ 	xtisa_errno = xtensa_isa_bad_interface; \ 	strcpy (xtisa_error_msg, "invalid interface specifier"); \ 	return (ERRVAL); \       } \   } while (0)
end_define

begin_function
name|xtensa_interface
name|xtensa_interface_lookup
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
specifier|const
name|char
modifier|*
name|ifname
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|xtensa_lookup_entry
name|entry
decl_stmt|,
modifier|*
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|ifname
operator|||
operator|!
operator|*
name|ifname
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_bad_interface
expr_stmt|;
name|strcpy
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"invalid interface name"
argument_list|)
expr_stmt|;
return|return
name|XTENSA_UNDEFINED
return|;
block|}
if|if
condition|(
name|intisa
operator|->
name|num_interfaces
operator|!=
literal|0
condition|)
block|{
name|entry
operator|.
name|key
operator|=
name|ifname
expr_stmt|;
name|result
operator|=
name|bsearch
argument_list|(
operator|&
name|entry
argument_list|,
name|intisa
operator|->
name|interface_lookup_table
argument_list|,
name|intisa
operator|->
name|num_interfaces
argument_list|,
sizeof|sizeof
argument_list|(
name|xtensa_lookup_entry
argument_list|)
argument_list|,
name|xtensa_isa_name_compare
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_bad_interface
expr_stmt|;
name|sprintf
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"interface \"%s\" not recognized"
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
return|return
name|XTENSA_UNDEFINED
return|;
block|}
return|return
name|result
operator|->
name|u
operator|.
name|intf
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|xtensa_interface_name
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_interface
name|intf
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_INTERFACE
argument_list|(
name|intisa
argument_list|,
name|intf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|intisa
operator|->
name|interfaces
index|[
name|intf
index|]
operator|.
name|name
return|;
block|}
end_function

begin_function
name|int
name|xtensa_interface_num_bits
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_interface
name|intf
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_INTERFACE
argument_list|(
name|intisa
argument_list|,
name|intf
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
return|return
name|intisa
operator|->
name|interfaces
index|[
name|intf
index|]
operator|.
name|num_bits
return|;
block|}
end_function

begin_function
name|char
name|xtensa_interface_inout
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_interface
name|intf
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_INTERFACE
argument_list|(
name|intisa
argument_list|,
name|intf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|intisa
operator|->
name|interfaces
index|[
name|intf
index|]
operator|.
name|inout
return|;
block|}
end_function

begin_function
name|int
name|xtensa_interface_has_side_effect
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_interface
name|intf
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_INTERFACE
argument_list|(
name|intisa
argument_list|,
name|intf
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intisa
operator|->
name|interfaces
index|[
name|intf
index|]
operator|.
name|flags
operator|&
name|XTENSA_INTERFACE_HAS_SIDE_EFFECT
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|xtensa_interface_class_id
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_interface
name|intf
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_INTERFACE
argument_list|(
name|intisa
argument_list|,
name|intf
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
return|return
name|intisa
operator|->
name|interfaces
index|[
name|intf
index|]
operator|.
name|class_id
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functional Units.  */
end_comment

begin_define
define|#
directive|define
name|CHECK_FUNCUNIT
parameter_list|(
name|INTISA
parameter_list|,
name|FUN
parameter_list|,
name|ERRVAL
parameter_list|)
define|\
value|do { \     if ((FUN)< 0 || (FUN)>= (INTISA)->num_funcUnits) \       { \ 	xtisa_errno = xtensa_isa_bad_funcUnit; \ 	strcpy (xtisa_error_msg, "invalid functional unit specifier"); \ 	return (ERRVAL); \       } \   } while (0)
end_define

begin_function
name|xtensa_funcUnit
name|xtensa_funcUnit_lookup
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|xtensa_lookup_entry
name|entry
decl_stmt|,
modifier|*
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|fname
operator|||
operator|!
operator|*
name|fname
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_bad_funcUnit
expr_stmt|;
name|strcpy
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"invalid functional unit name"
argument_list|)
expr_stmt|;
return|return
name|XTENSA_UNDEFINED
return|;
block|}
if|if
condition|(
name|intisa
operator|->
name|num_funcUnits
operator|!=
literal|0
condition|)
block|{
name|entry
operator|.
name|key
operator|=
name|fname
expr_stmt|;
name|result
operator|=
name|bsearch
argument_list|(
operator|&
name|entry
argument_list|,
name|intisa
operator|->
name|funcUnit_lookup_table
argument_list|,
name|intisa
operator|->
name|num_funcUnits
argument_list|,
sizeof|sizeof
argument_list|(
name|xtensa_lookup_entry
argument_list|)
argument_list|,
name|xtensa_isa_name_compare
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|xtisa_errno
operator|=
name|xtensa_isa_bad_funcUnit
expr_stmt|;
name|sprintf
argument_list|(
name|xtisa_error_msg
argument_list|,
literal|"functional unit \"%s\" not recognized"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
name|XTENSA_UNDEFINED
return|;
block|}
return|return
name|result
operator|->
name|u
operator|.
name|fun
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|xtensa_funcUnit_name
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_funcUnit
name|fun
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_FUNCUNIT
argument_list|(
name|intisa
argument_list|,
name|fun
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|intisa
operator|->
name|funcUnits
index|[
name|fun
index|]
operator|.
name|name
return|;
block|}
end_function

begin_function
name|int
name|xtensa_funcUnit_num_copies
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_funcUnit
name|fun
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|CHECK_FUNCUNIT
argument_list|(
name|intisa
argument_list|,
name|fun
argument_list|,
name|XTENSA_UNDEFINED
argument_list|)
expr_stmt|;
return|return
name|intisa
operator|->
name|funcUnits
index|[
name|fun
index|]
operator|.
name|num_copies
return|;
block|}
end_function

end_unit

