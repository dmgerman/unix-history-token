begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Configurable Xtensa ISA support.    Copyright 2003 Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"xtensa-isa.h"
end_include

begin_include
include|#
directive|include
file|"xtensa-isa-internal.h"
end_include

begin_decl_stmt
name|xtensa_isa
name|xtensa_default_isa
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|opname_lookup_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|v1
parameter_list|,
specifier|const
name|void
modifier|*
name|v2
parameter_list|)
block|{
name|opname_lookup_entry
modifier|*
name|e1
init|=
operator|(
name|opname_lookup_entry
operator|*
operator|)
name|v1
decl_stmt|;
name|opname_lookup_entry
modifier|*
name|e2
init|=
operator|(
name|opname_lookup_entry
operator|*
operator|)
name|v2
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|e1
operator|->
name|key
argument_list|,
name|e2
operator|->
name|key
argument_list|)
return|;
block|}
end_function

begin_function
name|xtensa_isa
name|xtensa_isa_init
parameter_list|(
name|void
parameter_list|)
block|{
name|xtensa_isa
name|isa
decl_stmt|;
name|int
name|mod
decl_stmt|;
name|isa
operator|=
name|xtensa_load_isa
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|isa
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Failed to initialize Xtensa base ISA module\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|mod
operator|=
literal|1
init|;
name|xtensa_isa_modules
index|[
name|mod
index|]
operator|.
name|get_num_opcodes_fn
condition|;
name|mod
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|xtensa_extend_isa
argument_list|(
name|isa
argument_list|,
name|mod
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Failed to initialize Xtensa TIE ISA module\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|isa
return|;
block|}
end_function

begin_comment
comment|/* ISA information.  */
end_comment

begin_function
specifier|static
name|int
name|xtensa_check_isa_config
parameter_list|(
name|xtensa_isa_internal
modifier|*
name|isa
parameter_list|,
name|struct
name|config_struct
modifier|*
name|config_table
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|config_table
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: Empty configuration table in ISA DLL\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* For the first module, save a pointer to the table and record the      specified endianness and availability of the density option.  */
if|if
condition|(
name|isa
operator|->
name|num_modules
operator|==
literal|0
condition|)
block|{
name|int
name|found_memory_order
init|=
literal|0
decl_stmt|;
name|isa
operator|->
name|config
operator|=
name|config_table
expr_stmt|;
name|isa
operator|->
name|has_density
operator|=
literal|1
expr_stmt|;
comment|/* Default to have density option.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|config_table
index|[
name|i
index|]
operator|.
name|param_name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|config_table
index|[
name|i
index|]
operator|.
name|param_name
argument_list|,
literal|"IsaMemoryOrder"
argument_list|)
condition|)
block|{
name|isa
operator|->
name|is_big_endian
operator|=
operator|(
name|strcmp
argument_list|(
name|config_table
index|[
name|i
index|]
operator|.
name|param_value
argument_list|,
literal|"BigEndian"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|found_memory_order
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|config_table
index|[
name|i
index|]
operator|.
name|param_name
argument_list|,
literal|"IsaUseDensityInstruction"
argument_list|)
condition|)
block|{
name|isa
operator|->
name|has_density
operator|=
name|atoi
argument_list|(
name|config_table
index|[
name|i
index|]
operator|.
name|param_value
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found_memory_order
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: \"IsaMemoryOrder\" missing from "
literal|"configuration table in ISA DLL\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
comment|/* For subsequent modules, check that the parameters match.  Note: This      code is sufficient to handle the current model where there are never      more than 2 modules; we might at some point want to handle cases where      module N> 0 specifies some parameters not included in the base table,      and we would then add those to isa->config so that subsequent modules      would check against them. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|config_table
index|[
name|i
index|]
operator|.
name|param_name
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|isa
operator|->
name|config
index|[
name|j
index|]
operator|.
name|param_name
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|config_table
index|[
name|i
index|]
operator|.
name|param_name
argument_list|,
name|isa
operator|->
name|config
index|[
name|j
index|]
operator|.
name|param_name
argument_list|)
condition|)
block|{
name|int
name|mismatch
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|config_table
index|[
name|i
index|]
operator|.
name|param_name
argument_list|,
literal|"IsaCoprocessorCount"
argument_list|)
condition|)
block|{
comment|/* Only require the coprocessor count to be<= the base.  */
name|int
name|tiecnt
init|=
name|atoi
argument_list|(
name|config_table
index|[
name|i
index|]
operator|.
name|param_value
argument_list|)
decl_stmt|;
name|int
name|basecnt
init|=
name|atoi
argument_list|(
name|isa
operator|->
name|config
index|[
name|j
index|]
operator|.
name|param_value
argument_list|)
decl_stmt|;
name|mismatch
operator|=
operator|(
name|tiecnt
operator|>
name|basecnt
operator|)
expr_stmt|;
block|}
else|else
name|mismatch
operator|=
name|strcmp
argument_list|(
name|config_table
index|[
name|i
index|]
operator|.
name|param_value
argument_list|,
name|isa
operator|->
name|config
index|[
name|j
index|]
operator|.
name|param_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|mismatch
condition|)
block|{
define|#
directive|define
name|MISMATCH_MESSAGE
define|\
value|"Error: Configuration mismatch in the \"%s\" parameter:\n\ the configuration used when the TIE file was compiled had a value of\n\ \"%s\", while the current configuration has a value of\n\ \"%s\". Please rerun the TIE compiler with a matching\n\ configuration.\n"
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|MISMATCH_MESSAGE
argument_list|,
name|config_table
index|[
name|i
index|]
operator|.
name|param_name
argument_list|,
name|config_table
index|[
name|i
index|]
operator|.
name|param_value
argument_list|,
name|isa
operator|->
name|config
index|[
name|j
index|]
operator|.
name|param_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xtensa_add_isa
parameter_list|(
name|xtensa_isa_internal
modifier|*
name|isa
parameter_list|,
name|libisa_module_specifier
name|libisa
parameter_list|)
block|{
name|int
function_decl|(
modifier|*
name|get_num_opcodes_fn
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|struct
name|config_struct
modifier|*
argument_list|(
operator|*
name|get_config_table_fn
argument_list|)
argument_list|(
name|void
argument_list|)
decl_stmt|;
name|xtensa_opcode_internal
modifier|*
modifier|*
function_decl|(
modifier|*
name|get_opcodes_fn
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|decode_insn_fn
function_decl|)
parameter_list|(
specifier|const
name|xtensa_insnbuf
parameter_list|)
function_decl|;
name|xtensa_opcode_internal
modifier|*
modifier|*
name|opcodes
decl_stmt|;
name|int
name|opc
decl_stmt|,
name|insn_size
decl_stmt|,
name|prev_num_opcodes
decl_stmt|,
name|new_num_opcodes
decl_stmt|,
name|this_module
decl_stmt|;
name|get_num_opcodes_fn
operator|=
name|xtensa_isa_modules
index|[
name|libisa
index|]
operator|.
name|get_num_opcodes_fn
expr_stmt|;
name|get_opcodes_fn
operator|=
name|xtensa_isa_modules
index|[
name|libisa
index|]
operator|.
name|get_opcodes_fn
expr_stmt|;
name|decode_insn_fn
operator|=
name|xtensa_isa_modules
index|[
name|libisa
index|]
operator|.
name|decode_insn_fn
expr_stmt|;
name|get_config_table_fn
operator|=
name|xtensa_isa_modules
index|[
name|libisa
index|]
operator|.
name|get_config_table_fn
expr_stmt|;
if|if
condition|(
operator|!
name|get_num_opcodes_fn
operator|||
operator|!
name|get_opcodes_fn
operator|||
operator|!
name|decode_insn_fn
operator|||
operator|(
operator|!
name|get_config_table_fn
operator|&&
name|isa
operator|->
name|num_modules
operator|==
literal|0
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|get_config_table_fn
operator|&&
operator|!
name|xtensa_check_isa_config
argument_list|(
name|isa
argument_list|,
name|get_config_table_fn
argument_list|()
argument_list|)
condition|)
return|return
literal|0
return|;
name|prev_num_opcodes
operator|=
name|isa
operator|->
name|num_opcodes
expr_stmt|;
name|new_num_opcodes
operator|=
call|(
modifier|*
name|get_num_opcodes_fn
call|)
argument_list|()
expr_stmt|;
name|isa
operator|->
name|num_opcodes
operator|+=
name|new_num_opcodes
expr_stmt|;
name|isa
operator|->
name|opcode_table
operator|=
operator|(
name|xtensa_opcode_internal
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|isa
operator|->
name|opcode_table
argument_list|,
name|isa
operator|->
name|num_opcodes
operator|*
sizeof|sizeof
argument_list|(
name|xtensa_opcode_internal
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|isa
operator|->
name|opname_lookup_table
operator|=
operator|(
name|opname_lookup_entry
operator|*
operator|)
name|realloc
argument_list|(
name|isa
operator|->
name|opname_lookup_table
argument_list|,
name|isa
operator|->
name|num_opcodes
operator|*
sizeof|sizeof
argument_list|(
name|opname_lookup_entry
argument_list|)
argument_list|)
expr_stmt|;
name|opcodes
operator|=
call|(
modifier|*
name|get_opcodes_fn
call|)
argument_list|()
expr_stmt|;
name|insn_size
operator|=
name|isa
operator|->
name|insn_size
expr_stmt|;
for|for
control|(
name|opc
operator|=
literal|0
init|;
name|opc
operator|<
name|new_num_opcodes
condition|;
name|opc
operator|++
control|)
block|{
name|xtensa_opcode_internal
modifier|*
name|intopc
init|=
name|opcodes
index|[
name|opc
index|]
decl_stmt|;
name|int
name|newopc
init|=
name|prev_num_opcodes
operator|+
name|opc
decl_stmt|;
name|isa
operator|->
name|opcode_table
index|[
name|newopc
index|]
operator|=
name|intopc
expr_stmt|;
name|isa
operator|->
name|opname_lookup_table
index|[
name|newopc
index|]
operator|.
name|key
operator|=
name|intopc
operator|->
name|name
expr_stmt|;
name|isa
operator|->
name|opname_lookup_table
index|[
name|newopc
index|]
operator|.
name|opcode
operator|=
name|newopc
expr_stmt|;
if|if
condition|(
name|intopc
operator|->
name|length
operator|>
name|insn_size
condition|)
name|insn_size
operator|=
name|intopc
operator|->
name|length
expr_stmt|;
block|}
name|isa
operator|->
name|insn_size
operator|=
name|insn_size
expr_stmt|;
name|isa
operator|->
name|insnbuf_size
operator|=
operator|(
operator|(
name|isa
operator|->
name|insn_size
operator|+
sizeof|sizeof
argument_list|(
name|xtensa_insnbuf_word
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|xtensa_insnbuf_word
argument_list|)
operator|)
expr_stmt|;
name|qsort
argument_list|(
name|isa
operator|->
name|opname_lookup_table
argument_list|,
name|isa
operator|->
name|num_opcodes
argument_list|,
sizeof|sizeof
argument_list|(
name|opname_lookup_entry
argument_list|)
argument_list|,
name|opname_lookup_compare
argument_list|)
expr_stmt|;
comment|/* Check for duplicate opcode names.  */
for|for
control|(
name|opc
operator|=
literal|1
init|;
name|opc
operator|<
name|isa
operator|->
name|num_opcodes
condition|;
name|opc
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|opname_lookup_compare
argument_list|(
operator|&
name|isa
operator|->
name|opname_lookup_table
index|[
name|opc
operator|-
literal|1
index|]
argument_list|,
operator|&
name|isa
operator|->
name|opname_lookup_table
index|[
name|opc
index|]
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: Duplicate TIE opcode \"%s\"\n"
argument_list|,
name|isa
operator|->
name|opname_lookup_table
index|[
name|opc
index|]
operator|.
name|key
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|this_module
operator|=
name|isa
operator|->
name|num_modules
expr_stmt|;
name|isa
operator|->
name|num_modules
operator|+=
literal|1
expr_stmt|;
name|isa
operator|->
name|module_opcode_base
operator|=
operator|(
name|int
operator|*
operator|)
name|realloc
argument_list|(
name|isa
operator|->
name|module_opcode_base
argument_list|,
name|isa
operator|->
name|num_modules
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|isa
operator|->
name|module_decode_fn
operator|=
operator|(
name|xtensa_insn_decode_fn
operator|*
operator|)
name|realloc
argument_list|(
name|isa
operator|->
name|module_decode_fn
argument_list|,
name|isa
operator|->
name|num_modules
operator|*
sizeof|sizeof
argument_list|(
name|xtensa_insn_decode_fn
argument_list|)
argument_list|)
expr_stmt|;
name|isa
operator|->
name|module_opcode_base
index|[
name|this_module
index|]
operator|=
name|prev_num_opcodes
expr_stmt|;
name|isa
operator|->
name|module_decode_fn
index|[
name|this_module
index|]
operator|=
name|decode_insn_fn
expr_stmt|;
name|xtensa_default_isa
operator|=
name|isa
expr_stmt|;
return|return
literal|1
return|;
comment|/* Library was successfully added.  */
block|}
end_function

begin_function
name|xtensa_isa
name|xtensa_load_isa
parameter_list|(
name|libisa_module_specifier
name|libisa
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|isa
decl_stmt|;
name|isa
operator|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xtensa_isa_internal
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|isa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xtensa_isa_internal
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xtensa_add_isa
argument_list|(
name|isa
argument_list|,
name|libisa
argument_list|)
condition|)
block|{
name|xtensa_isa_free
argument_list|(
name|isa
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|(
name|xtensa_isa
operator|)
name|isa
return|;
block|}
end_function

begin_function
name|int
name|xtensa_extend_isa
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|libisa_module_specifier
name|libisa
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
return|return
name|xtensa_add_isa
argument_list|(
name|intisa
argument_list|,
name|libisa
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|xtensa_isa_free
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
if|if
condition|(
name|intisa
operator|->
name|opcode_table
condition|)
name|free
argument_list|(
name|intisa
operator|->
name|opcode_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|intisa
operator|->
name|opname_lookup_table
condition|)
name|free
argument_list|(
name|intisa
operator|->
name|opname_lookup_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|intisa
operator|->
name|module_opcode_base
condition|)
name|free
argument_list|(
name|intisa
operator|->
name|module_opcode_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|intisa
operator|->
name|module_decode_fn
condition|)
name|free
argument_list|(
name|intisa
operator|->
name|module_decode_fn
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|intisa
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|xtensa_insn_maxlength
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
return|return
name|intisa
operator|->
name|insn_size
return|;
block|}
end_function

begin_function
name|int
name|xtensa_insnbuf_size
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
return|return
name|intisa
operator|->
name|insnbuf_size
return|;
block|}
end_function

begin_function
name|int
name|xtensa_num_opcodes
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
return|return
name|intisa
operator|->
name|num_opcodes
return|;
block|}
end_function

begin_function
name|xtensa_opcode
name|xtensa_opcode_lookup
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
specifier|const
name|char
modifier|*
name|opname
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|opname_lookup_entry
name|entry
decl_stmt|,
modifier|*
name|result
decl_stmt|;
name|entry
operator|.
name|key
operator|=
name|opname
expr_stmt|;
name|result
operator|=
name|bsearch
argument_list|(
operator|&
name|entry
argument_list|,
name|intisa
operator|->
name|opname_lookup_table
argument_list|,
name|intisa
operator|->
name|num_opcodes
argument_list|,
sizeof|sizeof
argument_list|(
name|opname_lookup_entry
argument_list|)
argument_list|,
name|opname_lookup_compare
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
return|return
name|XTENSA_UNDEFINED
return|;
return|return
name|result
operator|->
name|opcode
return|;
block|}
end_function

begin_function
name|xtensa_opcode
name|xtensa_decode_insn
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
specifier|const
name|xtensa_insnbuf
name|insn
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|int
name|n
decl_stmt|,
name|opc
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|intisa
operator|->
name|num_modules
condition|;
name|n
operator|++
control|)
block|{
name|opc
operator|=
operator|(
name|intisa
operator|->
name|module_decode_fn
index|[
name|n
index|]
operator|)
operator|(
name|insn
operator|)
expr_stmt|;
if|if
condition|(
name|opc
operator|!=
name|XTENSA_UNDEFINED
condition|)
return|return
name|intisa
operator|->
name|module_opcode_base
index|[
name|n
index|]
operator|+
name|opc
return|;
block|}
return|return
name|XTENSA_UNDEFINED
return|;
block|}
end_function

begin_comment
comment|/* Opcode information.  */
end_comment

begin_function
name|void
name|xtensa_encode_insn
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|xtensa_insnbuf
name|insn
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|xtensa_insnbuf
name|template
init|=
name|intisa
operator|->
name|opcode_table
index|[
name|opc
index|]
operator|->
name|template
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|intisa
operator|->
name|opcode_table
index|[
name|opc
index|]
operator|->
name|length
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* Convert length to 32-bit words.  */
name|len
operator|=
operator|(
name|len
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
comment|/* Copy the template.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|len
condition|;
name|n
operator|++
control|)
name|insn
index|[
name|n
index|]
operator|=
name|template
index|[
name|n
index|]
expr_stmt|;
comment|/* Fill any unused buffer space with zeros.  */
for|for
control|(
init|;
name|n
operator|<
name|intisa
operator|->
name|insnbuf_size
condition|;
name|n
operator|++
control|)
name|insn
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|xtensa_opcode_name
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
return|return
name|intisa
operator|->
name|opcode_table
index|[
name|opc
index|]
operator|->
name|name
return|;
block|}
end_function

begin_function
name|int
name|xtensa_insn_length
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
return|return
name|intisa
operator|->
name|opcode_table
index|[
name|opc
index|]
operator|->
name|length
return|;
block|}
end_function

begin_function
name|int
name|xtensa_insn_length_from_first_byte
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|char
name|first_byte
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|int
name|is_density
init|=
operator|(
name|first_byte
operator|&
operator|(
name|intisa
operator|->
name|is_big_endian
condition|?
literal|0x80
else|:
literal|0x08
operator|)
operator|)
operator|!=
literal|0
decl_stmt|;
return|return
operator|(
name|intisa
operator|->
name|has_density
operator|&&
name|is_density
condition|?
literal|2
else|:
literal|3
operator|)
return|;
block|}
end_function

begin_function
name|int
name|xtensa_num_operands
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
return|return
name|intisa
operator|->
name|opcode_table
index|[
name|opc
index|]
operator|->
name|iclass
operator|->
name|num_operands
return|;
block|}
end_function

begin_function
name|xtensa_operand
name|xtensa_get_operand
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_opcode
name|opc
parameter_list|,
name|int
name|opnd
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|xtensa_iclass_internal
modifier|*
name|iclass
init|=
name|intisa
operator|->
name|opcode_table
index|[
name|opc
index|]
operator|->
name|iclass
decl_stmt|;
if|if
condition|(
name|opnd
operator|>=
name|iclass
operator|->
name|num_operands
condition|)
return|return
name|NULL
return|;
return|return
operator|(
name|xtensa_operand
operator|)
name|iclass
operator|->
name|operands
index|[
name|opnd
index|]
return|;
block|}
end_function

begin_comment
comment|/* Operand information.  */
end_comment

begin_function
name|char
modifier|*
name|xtensa_operand_kind
parameter_list|(
name|xtensa_operand
name|opnd
parameter_list|)
block|{
name|xtensa_operand_internal
modifier|*
name|intop
init|=
operator|(
name|xtensa_operand_internal
operator|*
operator|)
name|opnd
decl_stmt|;
return|return
name|intop
operator|->
name|operand_kind
return|;
block|}
end_function

begin_function
name|char
name|xtensa_operand_inout
parameter_list|(
name|xtensa_operand
name|opnd
parameter_list|)
block|{
name|xtensa_operand_internal
modifier|*
name|intop
init|=
operator|(
name|xtensa_operand_internal
operator|*
operator|)
name|opnd
decl_stmt|;
return|return
name|intop
operator|->
name|inout
return|;
block|}
end_function

begin_function
name|uint32
name|xtensa_operand_get_field
parameter_list|(
name|xtensa_operand
name|opnd
parameter_list|,
specifier|const
name|xtensa_insnbuf
name|insn
parameter_list|)
block|{
name|xtensa_operand_internal
modifier|*
name|intop
init|=
operator|(
name|xtensa_operand_internal
operator|*
operator|)
name|opnd
decl_stmt|;
return|return
call|(
modifier|*
name|intop
operator|->
name|get_field
call|)
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|xtensa_operand_set_field
parameter_list|(
name|xtensa_operand
name|opnd
parameter_list|,
name|xtensa_insnbuf
name|insn
parameter_list|,
name|uint32
name|val
parameter_list|)
block|{
name|xtensa_operand_internal
modifier|*
name|intop
init|=
operator|(
name|xtensa_operand_internal
operator|*
operator|)
name|opnd
decl_stmt|;
return|return
call|(
modifier|*
name|intop
operator|->
name|set_field
call|)
argument_list|(
name|insn
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_function
name|xtensa_encode_result
name|xtensa_operand_encode
parameter_list|(
name|xtensa_operand
name|opnd
parameter_list|,
name|uint32
modifier|*
name|valp
parameter_list|)
block|{
name|xtensa_operand_internal
modifier|*
name|intop
init|=
operator|(
name|xtensa_operand_internal
operator|*
operator|)
name|opnd
decl_stmt|;
return|return
call|(
modifier|*
name|intop
operator|->
name|encode
call|)
argument_list|(
name|valp
argument_list|)
return|;
block|}
end_function

begin_function
name|uint32
name|xtensa_operand_decode
parameter_list|(
name|xtensa_operand
name|opnd
parameter_list|,
name|uint32
name|val
parameter_list|)
block|{
name|xtensa_operand_internal
modifier|*
name|intop
init|=
operator|(
name|xtensa_operand_internal
operator|*
operator|)
name|opnd
decl_stmt|;
return|return
call|(
modifier|*
name|intop
operator|->
name|decode
call|)
argument_list|(
name|val
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|xtensa_operand_isPCRelative
parameter_list|(
name|xtensa_operand
name|opnd
parameter_list|)
block|{
name|xtensa_operand_internal
modifier|*
name|intop
init|=
operator|(
name|xtensa_operand_internal
operator|*
operator|)
name|opnd
decl_stmt|;
return|return
name|intop
operator|->
name|isPCRelative
return|;
block|}
end_function

begin_function
name|uint32
name|xtensa_operand_do_reloc
parameter_list|(
name|xtensa_operand
name|opnd
parameter_list|,
name|uint32
name|addr
parameter_list|,
name|uint32
name|pc
parameter_list|)
block|{
name|xtensa_operand_internal
modifier|*
name|intop
init|=
operator|(
name|xtensa_operand_internal
operator|*
operator|)
name|opnd
decl_stmt|;
if|if
condition|(
operator|!
name|intop
operator|->
name|isPCRelative
condition|)
return|return
name|addr
return|;
return|return
call|(
modifier|*
name|intop
operator|->
name|do_reloc
call|)
argument_list|(
name|addr
argument_list|,
name|pc
argument_list|)
return|;
block|}
end_function

begin_function
name|uint32
name|xtensa_operand_undo_reloc
parameter_list|(
name|xtensa_operand
name|opnd
parameter_list|,
name|uint32
name|offset
parameter_list|,
name|uint32
name|pc
parameter_list|)
block|{
name|xtensa_operand_internal
modifier|*
name|intop
init|=
operator|(
name|xtensa_operand_internal
operator|*
operator|)
name|opnd
decl_stmt|;
if|if
condition|(
operator|!
name|intop
operator|->
name|isPCRelative
condition|)
return|return
name|offset
return|;
return|return
call|(
modifier|*
name|intop
operator|->
name|undo_reloc
call|)
argument_list|(
name|offset
argument_list|,
name|pc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Instruction buffers.  */
end_comment

begin_function
name|xtensa_insnbuf
name|xtensa_insnbuf_alloc
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|)
block|{
return|return
operator|(
name|xtensa_insnbuf
operator|)
name|malloc
argument_list|(
name|xtensa_insnbuf_size
argument_list|(
name|isa
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|xtensa_insnbuf_word
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|xtensa_insnbuf_free
parameter_list|(
name|xtensa_insnbuf
name|buf
parameter_list|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given<byte_index>, the index of a byte in a xtensa_insnbuf, our    internal representation of a xtensa instruction word, return the index of    its word and the bit index of its low order byte in the xtensa_insnbuf.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|byte_to_word_index
parameter_list|(
name|int
name|byte_index
parameter_list|)
block|{
return|return
name|byte_index
operator|/
sizeof|sizeof
argument_list|(
name|xtensa_insnbuf_word
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|byte_to_bit_index
parameter_list|(
name|int
name|byte_index
parameter_list|)
block|{
return|return
operator|(
name|byte_index
operator|&
literal|0x3
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_comment
comment|/* Copy an instruction in the 32 bit words pointed at by<insn> to characters    pointed at by<cp>.  This is more complicated than you might think because    we want 16 bit instructions in bytes 2,3 for big endian. This function    allows us to specify which byte in<insn> to start with and which way to    increment, allowing trivial implementation for both big and little endian.    And it seems to make pretty good code for both.  */
end_comment

begin_function
name|void
name|xtensa_insnbuf_to_chars
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
specifier|const
name|xtensa_insnbuf
name|insn
parameter_list|,
name|char
modifier|*
name|cp
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|int
name|insn_size
init|=
name|xtensa_insn_maxlength
argument_list|(
name|intisa
argument_list|)
decl_stmt|;
name|int
name|fence_post
decl_stmt|,
name|start
decl_stmt|,
name|increment
decl_stmt|,
name|i
decl_stmt|,
name|byte_count
decl_stmt|;
name|xtensa_opcode
name|opc
decl_stmt|;
if|if
condition|(
name|intisa
operator|->
name|is_big_endian
condition|)
block|{
name|start
operator|=
name|insn_size
operator|-
literal|1
expr_stmt|;
name|increment
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
literal|0
expr_stmt|;
name|increment
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Find the opcode; do nothing if the buffer does not contain a valid      instruction since we need to know how many bytes to copy.  */
name|opc
operator|=
name|xtensa_decode_insn
argument_list|(
name|isa
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|opc
operator|==
name|XTENSA_UNDEFINED
condition|)
return|return;
name|byte_count
operator|=
name|xtensa_insn_length
argument_list|(
name|isa
argument_list|,
name|opc
argument_list|)
expr_stmt|;
name|fence_post
operator|=
name|start
operator|+
operator|(
name|byte_count
operator|*
name|increment
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|!=
name|fence_post
condition|;
name|i
operator|+=
name|increment
operator|,
operator|++
name|cp
control|)
block|{
name|int
name|word_inx
init|=
name|byte_to_word_index
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|bit_inx
init|=
name|byte_to_bit_index
argument_list|(
name|i
argument_list|)
decl_stmt|;
operator|*
name|cp
operator|=
operator|(
name|insn
index|[
name|word_inx
index|]
operator|>>
name|bit_inx
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Inward conversion from byte stream to xtensa_insnbuf.  See    xtensa_insnbuf_to_chars for a discussion of why this is    complicated by endianness.  */
end_comment

begin_function
name|void
name|xtensa_insnbuf_from_chars
parameter_list|(
name|xtensa_isa
name|isa
parameter_list|,
name|xtensa_insnbuf
name|insn
parameter_list|,
specifier|const
name|char
modifier|*
name|cp
parameter_list|)
block|{
name|xtensa_isa_internal
modifier|*
name|intisa
init|=
operator|(
name|xtensa_isa_internal
operator|*
operator|)
name|isa
decl_stmt|;
name|int
name|insn_size
init|=
name|xtensa_insn_maxlength
argument_list|(
name|intisa
argument_list|)
decl_stmt|;
name|int
name|fence_post
decl_stmt|,
name|start
decl_stmt|,
name|increment
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|intisa
operator|->
name|is_big_endian
condition|)
block|{
name|start
operator|=
name|insn_size
operator|-
literal|1
expr_stmt|;
name|increment
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
literal|0
expr_stmt|;
name|increment
operator|=
literal|1
expr_stmt|;
block|}
name|fence_post
operator|=
name|start
operator|+
operator|(
name|insn_size
operator|*
name|increment
operator|)
expr_stmt|;
name|memset
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
name|xtensa_insnbuf_size
argument_list|(
name|isa
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|xtensa_insnbuf_word
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|!=
name|fence_post
condition|;
name|i
operator|+=
name|increment
operator|,
operator|++
name|cp
control|)
block|{
name|int
name|word_inx
init|=
name|byte_to_word_index
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|bit_inx
init|=
name|byte_to_bit_index
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|insn
index|[
name|word_inx
index|]
operator||=
operator|(
operator|*
name|cp
operator|&
literal|0xff
operator|)
operator|<<
name|bit_inx
expr_stmt|;
block|}
block|}
end_function

end_unit

