begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ELF executable support for BFD.    Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.     Written by Fred Fish @ Cygnus Support, from information published    in "UNIX System V Release 4, Programmers Guide: ANSI C and    Programming Support Tools".  Sufficient support for gdb.     Rewritten by Mark Eichin @ Cygnus Support, from information    published in "System V Application Binary Interface", chapters 4    and 5, as well as the various "Processor Supplement" documents    derived from it. Added support for assembler and other object file    utilities.  Further work done by Ken Raeburn (Cygnus Support), Michael    Meissner (Open Software Foundation), and Peter Hoogenboom (University    of Utah) to finish and extend this.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Problems and other issues to resolve.     (1)	BFD expects there to be some fixed number of "sections" in 	the object file.  I.E. there is a "section_count" variable in the 	bfd structure which contains the number of sections.  However, ELF 	supports multiple "views" of a file.  In particular, with current 	implementations, executable files typically have two tables, a 	program header table and a section header table, both of which 	partition the executable.  	In ELF-speak, the "linking view" of the file uses the section header 	table to access "sections" within the file, and the "execution view" 	uses the program header table to access "segments" within the file. 	"Segments" typically may contain all the data from one or more 	"sections".  	Note that the section header table is optional in ELF executables, 	but it is this information that is most useful to gdb.  If the 	section header table is missing, then gdb should probably try 	to make do with the program header table.  (FIXME)     (2)  The code in this file is compiled twice, once in 32-bit mode and 	once in 64-bit mode.  More of it should be made size-independent 	and moved into elf.c.     (3)	ELF section symbols are handled rather sloppily now.  This should 	be cleaned up, and ELF section symbols reconciled with BFD section 	symbols.     (4)  We need a published spec for 64-bit ELF.  We've got some stuff here 	that we're using for SPARC V9 64-bit chips, but don't assume that 	it's cast in stone.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_comment
comment|/* Renaming structures, typedefs, macros and functions to be size-specific.  */
end_comment

begin_define
define|#
directive|define
name|Elf_External_Ehdr
value|NAME(Elf,External_Ehdr)
end_define

begin_define
define|#
directive|define
name|Elf_External_Sym
value|NAME(Elf,External_Sym)
end_define

begin_define
define|#
directive|define
name|Elf_External_Shdr
value|NAME(Elf,External_Shdr)
end_define

begin_define
define|#
directive|define
name|Elf_External_Phdr
value|NAME(Elf,External_Phdr)
end_define

begin_define
define|#
directive|define
name|Elf_External_Rel
value|NAME(Elf,External_Rel)
end_define

begin_define
define|#
directive|define
name|Elf_External_Rela
value|NAME(Elf,External_Rela)
end_define

begin_define
define|#
directive|define
name|Elf_External_Dyn
value|NAME(Elf,External_Dyn)
end_define

begin_define
define|#
directive|define
name|elf_core_file_failing_command
value|NAME(bfd_elf,core_file_failing_command)
end_define

begin_define
define|#
directive|define
name|elf_core_file_failing_signal
value|NAME(bfd_elf,core_file_failing_signal)
end_define

begin_define
define|#
directive|define
name|elf_core_file_matches_executable_p
define|\
value|NAME(bfd_elf,core_file_matches_executable_p)
end_define

begin_define
define|#
directive|define
name|elf_object_p
value|NAME(bfd_elf,object_p)
end_define

begin_define
define|#
directive|define
name|elf_core_file_p
value|NAME(bfd_elf,core_file_p)
end_define

begin_define
define|#
directive|define
name|elf_get_symtab_upper_bound
value|NAME(bfd_elf,get_symtab_upper_bound)
end_define

begin_define
define|#
directive|define
name|elf_get_dynamic_symtab_upper_bound
define|\
value|NAME(bfd_elf,get_dynamic_symtab_upper_bound)
end_define

begin_define
define|#
directive|define
name|elf_swap_reloc_in
value|NAME(bfd_elf,swap_reloc_in)
end_define

begin_define
define|#
directive|define
name|elf_swap_reloca_in
value|NAME(bfd_elf,swap_reloca_in)
end_define

begin_define
define|#
directive|define
name|elf_swap_reloc_out
value|NAME(bfd_elf,swap_reloc_out)
end_define

begin_define
define|#
directive|define
name|elf_swap_reloca_out
value|NAME(bfd_elf,swap_reloca_out)
end_define

begin_define
define|#
directive|define
name|elf_swap_symbol_in
value|NAME(bfd_elf,swap_symbol_in)
end_define

begin_define
define|#
directive|define
name|elf_swap_symbol_out
value|NAME(bfd_elf,swap_symbol_out)
end_define

begin_define
define|#
directive|define
name|elf_swap_phdr_in
value|NAME(bfd_elf,swap_phdr_in)
end_define

begin_define
define|#
directive|define
name|elf_swap_phdr_out
value|NAME(bfd_elf,swap_phdr_out)
end_define

begin_define
define|#
directive|define
name|elf_swap_dyn_in
value|NAME(bfd_elf,swap_dyn_in)
end_define

begin_define
define|#
directive|define
name|elf_swap_dyn_out
value|NAME(bfd_elf,swap_dyn_out)
end_define

begin_define
define|#
directive|define
name|elf_get_reloc_upper_bound
value|NAME(bfd_elf,get_reloc_upper_bound)
end_define

begin_define
define|#
directive|define
name|elf_canonicalize_reloc
value|NAME(bfd_elf,canonicalize_reloc)
end_define

begin_define
define|#
directive|define
name|elf_slurp_symbol_table
value|NAME(bfd_elf,slurp_symbol_table)
end_define

begin_define
define|#
directive|define
name|elf_canonicalize_symtab
value|NAME(bfd_elf,canonicalize_symtab)
end_define

begin_define
define|#
directive|define
name|elf_canonicalize_dynamic_symtab
define|\
value|NAME(bfd_elf,canonicalize_dynamic_symtab)
end_define

begin_define
define|#
directive|define
name|elf_get_synthetic_symtab
define|\
value|NAME(bfd_elf,get_synthetic_symtab)
end_define

begin_define
define|#
directive|define
name|elf_make_empty_symbol
value|NAME(bfd_elf,make_empty_symbol)
end_define

begin_define
define|#
directive|define
name|elf_get_symbol_info
value|NAME(bfd_elf,get_symbol_info)
end_define

begin_define
define|#
directive|define
name|elf_get_lineno
value|NAME(bfd_elf,get_lineno)
end_define

begin_define
define|#
directive|define
name|elf_set_arch_mach
value|NAME(bfd_elf,set_arch_mach)
end_define

begin_define
define|#
directive|define
name|elf_find_nearest_line
value|NAME(bfd_elf,find_nearest_line)
end_define

begin_define
define|#
directive|define
name|elf_sizeof_headers
value|NAME(bfd_elf,sizeof_headers)
end_define

begin_define
define|#
directive|define
name|elf_set_section_contents
value|NAME(bfd_elf,set_section_contents)
end_define

begin_define
define|#
directive|define
name|elf_no_info_to_howto
value|NAME(bfd_elf,no_info_to_howto)
end_define

begin_define
define|#
directive|define
name|elf_no_info_to_howto_rel
value|NAME(bfd_elf,no_info_to_howto_rel)
end_define

begin_define
define|#
directive|define
name|elf_find_section
value|NAME(bfd_elf,find_section)
end_define

begin_define
define|#
directive|define
name|elf_write_shdrs_and_ehdr
value|NAME(bfd_elf,write_shdrs_and_ehdr)
end_define

begin_define
define|#
directive|define
name|elf_write_out_phdrs
value|NAME(bfd_elf,write_out_phdrs)
end_define

begin_define
define|#
directive|define
name|elf_write_relocs
value|NAME(bfd_elf,write_relocs)
end_define

begin_define
define|#
directive|define
name|elf_slurp_reloc_table
value|NAME(bfd_elf,slurp_reloc_table)
end_define

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|64
end_if

begin_define
define|#
directive|define
name|ELF_R_INFO
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|ELF64_R_INFO(X,Y)
end_define

begin_define
define|#
directive|define
name|ELF_R_SYM
parameter_list|(
name|X
parameter_list|)
value|ELF64_R_SYM(X)
end_define

begin_define
define|#
directive|define
name|ELF_R_TYPE
parameter_list|(
name|X
parameter_list|)
value|ELF64_R_TYPE(X)
end_define

begin_define
define|#
directive|define
name|ELFCLASS
value|ELFCLASS64
end_define

begin_define
define|#
directive|define
name|FILE_ALIGN
value|8
end_define

begin_define
define|#
directive|define
name|LOG_FILE_ALIGN
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|32
end_if

begin_define
define|#
directive|define
name|ELF_R_INFO
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|ELF32_R_INFO(X,Y)
end_define

begin_define
define|#
directive|define
name|ELF_R_SYM
parameter_list|(
name|X
parameter_list|)
value|ELF32_R_SYM(X)
end_define

begin_define
define|#
directive|define
name|ELF_R_TYPE
parameter_list|(
name|X
parameter_list|)
value|ELF32_R_TYPE(X)
end_define

begin_define
define|#
directive|define
name|ELFCLASS
value|ELFCLASS32
end_define

begin_define
define|#
directive|define
name|FILE_ALIGN
value|4
end_define

begin_define
define|#
directive|define
name|LOG_FILE_ALIGN
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|DEBUG
operator|&
literal|2
end_if

begin_function_decl
specifier|static
name|void
name|elf_debug_section
parameter_list|(
name|int
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|DEBUG
operator|&
literal|1
end_if

begin_function_decl
specifier|static
name|void
name|elf_debug_file
parameter_list|(
name|Elf_Internal_Ehdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Structure swapping routines */
end_comment

begin_comment
comment|/* Should perhaps use put_offset, put_word, etc.  For now, the two versions    can be handled by explicitly specifying 32 bits or "the long type".  */
end_comment

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|64
end_if

begin_define
define|#
directive|define
name|H_PUT_WORD
value|H_PUT_64
end_define

begin_define
define|#
directive|define
name|H_PUT_SIGNED_WORD
value|H_PUT_S64
end_define

begin_define
define|#
directive|define
name|H_GET_WORD
value|H_GET_64
end_define

begin_define
define|#
directive|define
name|H_GET_SIGNED_WORD
value|H_GET_S64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|32
end_if

begin_define
define|#
directive|define
name|H_PUT_WORD
value|H_PUT_32
end_define

begin_define
define|#
directive|define
name|H_PUT_SIGNED_WORD
value|H_PUT_S32
end_define

begin_define
define|#
directive|define
name|H_GET_WORD
value|H_GET_32
end_define

begin_define
define|#
directive|define
name|H_GET_SIGNED_WORD
value|H_GET_S32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Translate an ELF symbol in external format into an ELF symbol in internal    format.  */
end_comment

begin_function
name|bfd_boolean
name|elf_swap_symbol_in
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|void
modifier|*
name|psrc
parameter_list|,
specifier|const
name|void
modifier|*
name|pshn
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|dst
parameter_list|)
block|{
specifier|const
name|Elf_External_Sym
modifier|*
name|src
init|=
name|psrc
decl_stmt|;
specifier|const
name|Elf_External_Sym_Shndx
modifier|*
name|shndx
init|=
name|pshn
decl_stmt|;
name|int
name|signed_vma
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sign_extend_vma
decl_stmt|;
name|dst
operator|->
name|st_name
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|signed_vma
condition|)
name|dst
operator|->
name|st_value
operator|=
name|H_GET_SIGNED_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_value
argument_list|)
expr_stmt|;
else|else
name|dst
operator|->
name|st_value
operator|=
name|H_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_value
argument_list|)
expr_stmt|;
name|dst
operator|->
name|st_size
operator|=
name|H_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_size
argument_list|)
expr_stmt|;
name|dst
operator|->
name|st_info
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_info
argument_list|)
expr_stmt|;
name|dst
operator|->
name|st_other
operator|=
name|H_GET_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_other
argument_list|)
expr_stmt|;
name|dst
operator|->
name|st_shndx
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|st_shndx
operator|==
name|SHN_XINDEX
condition|)
block|{
if|if
condition|(
name|shndx
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|dst
operator|->
name|st_shndx
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|shndx
operator|->
name|est_shndx
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Translate an ELF symbol in internal format into an ELF symbol in external    format.  */
end_comment

begin_function
name|void
name|elf_swap_symbol_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf_Internal_Sym
modifier|*
name|src
parameter_list|,
name|void
modifier|*
name|cdst
parameter_list|,
name|void
modifier|*
name|shndx
parameter_list|)
block|{
name|unsigned
name|int
name|tmp
decl_stmt|;
name|Elf_External_Sym
modifier|*
name|dst
init|=
name|cdst
decl_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_name
argument_list|,
name|dst
operator|->
name|st_name
argument_list|)
expr_stmt|;
name|H_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_value
argument_list|,
name|dst
operator|->
name|st_value
argument_list|)
expr_stmt|;
name|H_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_size
argument_list|,
name|dst
operator|->
name|st_size
argument_list|)
expr_stmt|;
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_info
argument_list|,
name|dst
operator|->
name|st_info
argument_list|)
expr_stmt|;
name|H_PUT_8
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|st_other
argument_list|,
name|dst
operator|->
name|st_other
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|src
operator|->
name|st_shndx
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
name|SHN_HIRESERVE
condition|)
block|{
if|if
condition|(
name|shndx
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|tmp
argument_list|,
name|shndx
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SHN_XINDEX
expr_stmt|;
block|}
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|tmp
argument_list|,
name|dst
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate an ELF file header in external format into an ELF file header in    internal format.  */
end_comment

begin_function
specifier|static
name|void
name|elf_swap_ehdr_in
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf_External_Ehdr
modifier|*
name|src
parameter_list|,
name|Elf_Internal_Ehdr
modifier|*
name|dst
parameter_list|)
block|{
name|int
name|signed_vma
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sign_extend_vma
decl_stmt|;
name|memcpy
argument_list|(
name|dst
operator|->
name|e_ident
argument_list|,
name|src
operator|->
name|e_ident
argument_list|,
name|EI_NIDENT
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_type
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_type
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_machine
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_machine
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_version
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|signed_vma
condition|)
name|dst
operator|->
name|e_entry
operator|=
name|H_GET_SIGNED_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_entry
argument_list|)
expr_stmt|;
else|else
name|dst
operator|->
name|e_entry
operator|=
name|H_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_entry
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_phoff
operator|=
name|H_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_phoff
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_shoff
operator|=
name|H_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_shoff
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_flags
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_flags
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_ehsize
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_ehsize
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_phentsize
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_phentsize
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_phnum
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_phnum
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_shentsize
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_shentsize
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_shnum
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_shnum
argument_list|)
expr_stmt|;
name|dst
operator|->
name|e_shstrndx
operator|=
name|H_GET_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_shstrndx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate an ELF file header in internal format into an ELF file header in    external format.  */
end_comment

begin_function
specifier|static
name|void
name|elf_swap_ehdr_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf_Internal_Ehdr
modifier|*
name|src
parameter_list|,
name|Elf_External_Ehdr
modifier|*
name|dst
parameter_list|)
block|{
name|unsigned
name|int
name|tmp
decl_stmt|;
name|int
name|signed_vma
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sign_extend_vma
decl_stmt|;
name|memcpy
argument_list|(
name|dst
operator|->
name|e_ident
argument_list|,
name|src
operator|->
name|e_ident
argument_list|,
name|EI_NIDENT
argument_list|)
expr_stmt|;
comment|/* note that all elements of dst are *arrays of unsigned char* already...  */
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_type
argument_list|,
name|dst
operator|->
name|e_type
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_machine
argument_list|,
name|dst
operator|->
name|e_machine
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_version
argument_list|,
name|dst
operator|->
name|e_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|signed_vma
condition|)
name|H_PUT_SIGNED_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_entry
argument_list|,
name|dst
operator|->
name|e_entry
argument_list|)
expr_stmt|;
else|else
name|H_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_entry
argument_list|,
name|dst
operator|->
name|e_entry
argument_list|)
expr_stmt|;
name|H_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_phoff
argument_list|,
name|dst
operator|->
name|e_phoff
argument_list|)
expr_stmt|;
name|H_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_shoff
argument_list|,
name|dst
operator|->
name|e_shoff
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_flags
argument_list|,
name|dst
operator|->
name|e_flags
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_ehsize
argument_list|,
name|dst
operator|->
name|e_ehsize
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_phentsize
argument_list|,
name|dst
operator|->
name|e_phentsize
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_phnum
argument_list|,
name|dst
operator|->
name|e_phnum
argument_list|)
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|e_shentsize
argument_list|,
name|dst
operator|->
name|e_shentsize
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|src
operator|->
name|e_shnum
expr_stmt|;
if|if
condition|(
name|tmp
operator|>=
name|SHN_LORESERVE
condition|)
name|tmp
operator|=
name|SHN_UNDEF
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|tmp
argument_list|,
name|dst
operator|->
name|e_shnum
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|src
operator|->
name|e_shstrndx
expr_stmt|;
if|if
condition|(
name|tmp
operator|>=
name|SHN_LORESERVE
condition|)
name|tmp
operator|=
name|SHN_XINDEX
expr_stmt|;
name|H_PUT_16
argument_list|(
name|abfd
argument_list|,
name|tmp
argument_list|,
name|dst
operator|->
name|e_shstrndx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate an ELF section header table entry in external format into an    ELF section header table entry in internal format.  */
end_comment

begin_function
specifier|static
name|void
name|elf_swap_shdr_in
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf_External_Shdr
modifier|*
name|src
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|dst
parameter_list|)
block|{
name|int
name|signed_vma
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sign_extend_vma
decl_stmt|;
name|dst
operator|->
name|sh_name
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_name
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_type
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_type
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_flags
operator|=
name|H_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|signed_vma
condition|)
name|dst
operator|->
name|sh_addr
operator|=
name|H_GET_SIGNED_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_addr
argument_list|)
expr_stmt|;
else|else
name|dst
operator|->
name|sh_addr
operator|=
name|H_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_addr
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_offset
operator|=
name|H_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_offset
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_size
operator|=
name|H_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_size
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_link
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_link
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_info
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_info
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_addralign
operator|=
name|H_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_addralign
argument_list|)
expr_stmt|;
name|dst
operator|->
name|sh_entsize
operator|=
name|H_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_entsize
argument_list|)
expr_stmt|;
name|dst
operator|->
name|bfd_section
operator|=
name|NULL
expr_stmt|;
name|dst
operator|->
name|contents
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate an ELF section header table entry in internal format into an    ELF section header table entry in external format.  */
end_comment

begin_function
specifier|static
name|void
name|elf_swap_shdr_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf_Internal_Shdr
modifier|*
name|src
parameter_list|,
name|Elf_External_Shdr
modifier|*
name|dst
parameter_list|)
block|{
comment|/* note that all elements of dst are *arrays of unsigned char* already...  */
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_name
argument_list|,
name|dst
operator|->
name|sh_name
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_type
argument_list|,
name|dst
operator|->
name|sh_type
argument_list|)
expr_stmt|;
name|H_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_flags
argument_list|,
name|dst
operator|->
name|sh_flags
argument_list|)
expr_stmt|;
name|H_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_addr
argument_list|,
name|dst
operator|->
name|sh_addr
argument_list|)
expr_stmt|;
name|H_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_offset
argument_list|,
name|dst
operator|->
name|sh_offset
argument_list|)
expr_stmt|;
name|H_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_size
argument_list|,
name|dst
operator|->
name|sh_size
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_link
argument_list|,
name|dst
operator|->
name|sh_link
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_info
argument_list|,
name|dst
operator|->
name|sh_info
argument_list|)
expr_stmt|;
name|H_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_addralign
argument_list|,
name|dst
operator|->
name|sh_addralign
argument_list|)
expr_stmt|;
name|H_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|sh_entsize
argument_list|,
name|dst
operator|->
name|sh_entsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate an ELF program header table entry in external format into an    ELF program header table entry in internal format.  */
end_comment

begin_function
name|void
name|elf_swap_phdr_in
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf_External_Phdr
modifier|*
name|src
parameter_list|,
name|Elf_Internal_Phdr
modifier|*
name|dst
parameter_list|)
block|{
name|int
name|signed_vma
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|sign_extend_vma
decl_stmt|;
name|dst
operator|->
name|p_type
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_type
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_flags
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_flags
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_offset
operator|=
name|H_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|signed_vma
condition|)
block|{
name|dst
operator|->
name|p_vaddr
operator|=
name|H_GET_SIGNED_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_vaddr
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_paddr
operator|=
name|H_GET_SIGNED_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_paddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dst
operator|->
name|p_vaddr
operator|=
name|H_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_vaddr
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_paddr
operator|=
name|H_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_paddr
argument_list|)
expr_stmt|;
block|}
name|dst
operator|->
name|p_filesz
operator|=
name|H_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_filesz
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_memsz
operator|=
name|H_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_memsz
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_align
operator|=
name|H_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_align
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|elf_swap_phdr_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf_Internal_Phdr
modifier|*
name|src
parameter_list|,
name|Elf_External_Phdr
modifier|*
name|dst
parameter_list|)
block|{
comment|/* note that all elements of dst are *arrays of unsigned char* already...  */
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_type
argument_list|,
name|dst
operator|->
name|p_type
argument_list|)
expr_stmt|;
name|H_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_offset
argument_list|,
name|dst
operator|->
name|p_offset
argument_list|)
expr_stmt|;
name|H_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_vaddr
argument_list|,
name|dst
operator|->
name|p_vaddr
argument_list|)
expr_stmt|;
name|H_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_paddr
argument_list|,
name|dst
operator|->
name|p_paddr
argument_list|)
expr_stmt|;
name|H_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_filesz
argument_list|,
name|dst
operator|->
name|p_filesz
argument_list|)
expr_stmt|;
name|H_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_memsz
argument_list|,
name|dst
operator|->
name|p_memsz
argument_list|)
expr_stmt|;
name|H_PUT_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_flags
argument_list|,
name|dst
operator|->
name|p_flags
argument_list|)
expr_stmt|;
name|H_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|p_align
argument_list|,
name|dst
operator|->
name|p_align
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate an ELF reloc from external format to internal format.  */
end_comment

begin_function
name|void
name|elf_swap_reloc_in
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|bfd_byte
modifier|*
name|s
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|dst
parameter_list|)
block|{
specifier|const
name|Elf_External_Rel
modifier|*
name|src
init|=
operator|(
specifier|const
name|Elf_External_Rel
operator|*
operator|)
name|s
decl_stmt|;
name|dst
operator|->
name|r_offset
operator|=
name|H_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_info
operator|=
name|H_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|elf_swap_reloca_in
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|bfd_byte
modifier|*
name|s
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|dst
parameter_list|)
block|{
specifier|const
name|Elf_External_Rela
modifier|*
name|src
init|=
operator|(
specifier|const
name|Elf_External_Rela
operator|*
operator|)
name|s
decl_stmt|;
name|dst
operator|->
name|r_offset
operator|=
name|H_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_info
operator|=
name|H_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|dst
operator|->
name|r_addend
operator|=
name|H_GET_SIGNED_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate an ELF reloc from internal format to external format.  */
end_comment

begin_function
name|void
name|elf_swap_reloc_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|src
parameter_list|,
name|bfd_byte
modifier|*
name|d
parameter_list|)
block|{
name|Elf_External_Rel
modifier|*
name|dst
init|=
operator|(
name|Elf_External_Rel
operator|*
operator|)
name|d
decl_stmt|;
name|H_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_offset
argument_list|,
name|dst
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|H_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_info
argument_list|,
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|elf_swap_reloca_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|src
parameter_list|,
name|bfd_byte
modifier|*
name|d
parameter_list|)
block|{
name|Elf_External_Rela
modifier|*
name|dst
init|=
operator|(
name|Elf_External_Rela
operator|*
operator|)
name|d
decl_stmt|;
name|H_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_offset
argument_list|,
name|dst
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|H_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_info
argument_list|,
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|H_PUT_SIGNED_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|r_addend
argument_list|,
name|dst
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|elf_swap_dyn_in
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|void
modifier|*
name|p
parameter_list|,
name|Elf_Internal_Dyn
modifier|*
name|dst
parameter_list|)
block|{
specifier|const
name|Elf_External_Dyn
modifier|*
name|src
init|=
name|p
decl_stmt|;
name|dst
operator|->
name|d_tag
operator|=
name|H_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|d_tag
argument_list|)
expr_stmt|;
name|dst
operator|->
name|d_un
operator|.
name|d_val
operator|=
name|H_GET_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|elf_swap_dyn_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf_Internal_Dyn
modifier|*
name|src
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|Elf_External_Dyn
modifier|*
name|dst
init|=
name|p
decl_stmt|;
name|H_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|d_tag
argument_list|,
name|dst
operator|->
name|d_tag
argument_list|)
expr_stmt|;
name|H_PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|d_un
operator|.
name|d_val
argument_list|,
name|dst
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ELF .o/exec file reading */
end_comment

begin_comment
comment|/* Begin processing a given object.     First we validate the file by reading in the ELF header and checking    the magic number.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bfd_boolean
name|elf_file_p
parameter_list|(
name|Elf_External_Ehdr
modifier|*
name|x_ehdrp
parameter_list|)
block|{
return|return
operator|(
operator|(
name|x_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG0
index|]
operator|==
name|ELFMAG0
operator|)
operator|&&
operator|(
name|x_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG1
index|]
operator|==
name|ELFMAG1
operator|)
operator|&&
operator|(
name|x_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG2
index|]
operator|==
name|ELFMAG2
operator|)
operator|&&
operator|(
name|x_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG3
index|]
operator|==
name|ELFMAG3
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Determines if a given section index is valid.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bfd_boolean
name|valid_section_index_p
parameter_list|(
name|unsigned
name|index
parameter_list|,
name|unsigned
name|num_sections
parameter_list|)
block|{
comment|/* Note: We allow SHN_UNDEF as a valid section index.  */
if|if
condition|(
name|index
operator|<
name|SHN_LORESERVE
operator|||
name|index
operator|>
name|SHN_HIRESERVE
condition|)
return|return
name|index
operator|<
name|num_sections
return|;
comment|/* We disallow the use of reserved indcies, except for those      with OS or Application specific meaning.  The test make use      of the knowledge that:        SHN_LORESERVE == SHN_LOPROC      and        SHN_HIPROC == SHN_LOOS - 1  */
comment|/* XXX - Should we allow SHN_XINDEX as a valid index here ?  */
return|return
operator|(
name|index
operator|>=
name|SHN_LOPROC
operator|&&
name|index
operator|<=
name|SHN_HIOS
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check to see if the file associated with ABFD matches the target vector    that ABFD points to.     Note that we may be called several times with the same ABFD, but different    target vectors, most of which will not match.  We have to avoid leaving    any side effects in ABFD, or any data it points to (like tdata), if the    file does not match the target vector.  */
end_comment

begin_function
specifier|const
name|bfd_target
modifier|*
name|elf_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|Elf_External_Ehdr
name|x_ehdr
decl_stmt|;
comment|/* Elf file header, external form */
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
comment|/* Elf file header, internal form */
name|Elf_External_Shdr
name|x_shdr
decl_stmt|;
comment|/* Section header table entry, external form */
name|Elf_Internal_Shdr
name|i_shdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|i_shdrp
decl_stmt|;
comment|/* Section header table, internal form */
name|unsigned
name|int
name|shindex
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|ebd
decl_stmt|;
name|struct
name|bfd_preserve
name|preserve
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
specifier|const
name|bfd_target
modifier|*
name|target
decl_stmt|;
specifier|const
name|bfd_target
modifier|*
specifier|const
modifier|*
name|target_ptr
decl_stmt|;
name|preserve
operator|.
name|marker
operator|=
name|NULL
expr_stmt|;
comment|/* Read in the ELF header in external format.  */
if|if
condition|(
name|bfd_bread
argument_list|(
operator|&
name|x_ehdr
argument_list|,
sizeof|sizeof
argument_list|(
name|x_ehdr
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|x_ehdr
argument_list|)
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
goto|goto
name|got_wrong_format_error
goto|;
else|else
goto|goto
name|got_no_match
goto|;
block|}
comment|/* Now check to see if we have a valid ELF file, and one that BFD can      make use of.  The magic number must match, the address size ('class')      and byte-swapping must match our XVEC entry, and it must have a      section header table (FIXME: See comments re sections at top of this      file).  */
if|if
condition|(
operator|!
name|elf_file_p
argument_list|(
operator|&
name|x_ehdr
argument_list|)
operator|||
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_VERSION
index|]
operator|!=
name|EV_CURRENT
operator|||
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
operator|!=
name|ELFCLASS
condition|)
goto|goto
name|got_wrong_format_error
goto|;
comment|/* Check that file's byte order matches xvec's */
switch|switch
condition|(
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
condition|)
block|{
case|case
name|ELFDATA2MSB
case|:
comment|/* Big-endian */
if|if
condition|(
operator|!
name|bfd_header_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|got_wrong_format_error
goto|;
break|break;
case|case
name|ELFDATA2LSB
case|:
comment|/* Little-endian */
if|if
condition|(
operator|!
name|bfd_header_little_endian
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|got_wrong_format_error
goto|;
break|break;
case|case
name|ELFDATANONE
case|:
comment|/* No data encoding specified */
default|default:
comment|/* Unknown data encoding specified */
goto|goto
name|got_wrong_format_error
goto|;
block|}
if|if
condition|(
operator|!
name|bfd_preserve_save
argument_list|(
name|abfd
argument_list|,
operator|&
name|preserve
argument_list|)
condition|)
goto|goto
name|got_no_match
goto|;
name|target
operator|=
name|abfd
operator|->
name|xvec
expr_stmt|;
comment|/* Allocate an instance of the elf_obj_tdata structure and hook it up to      the tdata pointer in the bfd.  */
if|if
condition|(
operator|!
call|(
modifier|*
name|target
operator|->
name|_bfd_set_format
index|[
name|bfd_object
index|]
call|)
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|got_no_match
goto|;
name|preserve
operator|.
name|marker
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Now that we know the byte order, swap in the rest of the header */
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|elf_swap_ehdr_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|x_ehdr
argument_list|,
name|i_ehdrp
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|&
literal|1
name|elf_debug_file
argument_list|(
name|i_ehdrp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Reject ET_CORE (header indicates core file, not object file) */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_type
operator|==
name|ET_CORE
condition|)
goto|goto
name|got_wrong_format_error
goto|;
comment|/* If this is a relocatable file and there is no section header      table, then we're hosed.  */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_shoff
operator|==
literal|0
operator|&&
name|i_ehdrp
operator|->
name|e_type
operator|==
name|ET_REL
condition|)
goto|goto
name|got_wrong_format_error
goto|;
comment|/* As a simple sanity check, verify that what BFD thinks is the      size of each section header table entry actually matches the size      recorded in the file, but only if there are any sections.  */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_shentsize
operator|!=
sizeof|sizeof
argument_list|(
name|x_shdr
argument_list|)
operator|&&
name|i_ehdrp
operator|->
name|e_shnum
operator|!=
literal|0
condition|)
goto|goto
name|got_wrong_format_error
goto|;
comment|/* Further sanity check.  */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_shoff
operator|==
literal|0
operator|&&
name|i_ehdrp
operator|->
name|e_shnum
operator|!=
literal|0
condition|)
goto|goto
name|got_wrong_format_error
goto|;
name|ebd
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Check that the ELF e_machine field matches what this particular      BFD format expects.  */
if|if
condition|(
name|ebd
operator|->
name|elf_machine_code
operator|!=
name|i_ehdrp
operator|->
name|e_machine
operator|&&
operator|(
name|ebd
operator|->
name|elf_machine_alt1
operator|==
literal|0
operator|||
name|i_ehdrp
operator|->
name|e_machine
operator|!=
name|ebd
operator|->
name|elf_machine_alt1
operator|)
operator|&&
operator|(
name|ebd
operator|->
name|elf_machine_alt2
operator|==
literal|0
operator|||
name|i_ehdrp
operator|->
name|e_machine
operator|!=
name|ebd
operator|->
name|elf_machine_alt2
operator|)
condition|)
block|{
if|if
condition|(
name|ebd
operator|->
name|elf_machine_code
operator|!=
name|EM_NONE
condition|)
goto|goto
name|got_wrong_format_error
goto|;
comment|/* This is the generic ELF target.  Let it match any ELF target 	 for which we do not have a specific backend.  */
for|for
control|(
name|target_ptr
operator|=
name|bfd_target_vector
init|;
operator|*
name|target_ptr
operator|!=
name|NULL
condition|;
name|target_ptr
operator|++
control|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|back
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|target_ptr
operator|)
operator|->
name|flavour
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
name|back
operator|=
operator|(
specifier|const
expr|struct
name|elf_backend_data
operator|*
operator|)
operator|(
operator|*
name|target_ptr
operator|)
operator|->
name|backend_data
expr_stmt|;
if|if
condition|(
name|back
operator|->
name|elf_machine_code
operator|==
name|i_ehdrp
operator|->
name|e_machine
operator|||
operator|(
name|back
operator|->
name|elf_machine_alt1
operator|!=
literal|0
operator|&&
name|back
operator|->
name|elf_machine_alt1
operator|==
name|i_ehdrp
operator|->
name|e_machine
operator|)
operator|||
operator|(
name|back
operator|->
name|elf_machine_alt2
operator|!=
literal|0
operator|&&
name|back
operator|->
name|elf_machine_alt2
operator|==
name|i_ehdrp
operator|->
name|e_machine
operator|)
condition|)
block|{
comment|/* target_ptr is an ELF backend which matches this 		 object file, so reject the generic ELF target.  */
goto|goto
name|got_wrong_format_error
goto|;
block|}
block|}
block|}
if|if
condition|(
name|i_ehdrp
operator|->
name|e_type
operator|==
name|ET_EXEC
condition|)
name|abfd
operator|->
name|flags
operator||=
name|EXEC_P
expr_stmt|;
elseif|else
if|if
condition|(
name|i_ehdrp
operator|->
name|e_type
operator|==
name|ET_DYN
condition|)
name|abfd
operator|->
name|flags
operator||=
name|DYNAMIC
expr_stmt|;
if|if
condition|(
name|i_ehdrp
operator|->
name|e_phnum
operator|>
literal|0
condition|)
name|abfd
operator|->
name|flags
operator||=
name|D_PAGED
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|ebd
operator|->
name|arch
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* It's OK if this fails for the generic target.  */
if|if
condition|(
name|ebd
operator|->
name|elf_machine_code
operator|!=
name|EM_NONE
condition|)
goto|goto
name|got_no_match
goto|;
block|}
if|if
condition|(
name|ebd
operator|->
name|elf_machine_code
operator|!=
name|EM_NONE
operator|&&
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|!=
name|ebd
operator|->
name|elf_osabi
condition|)
block|{
if|if
condition|(
name|ebd
operator|->
name|elf_osabi
operator|!=
name|ELFOSABI_NONE
condition|)
goto|goto
name|got_wrong_format_error
goto|;
comment|/* This is an ELFOSABI_NONE ELF target.  Let it match any ELF 	 target of the compatible machine for which we do not have a 	 backend with matching ELFOSABI.  */
for|for
control|(
name|target_ptr
operator|=
name|bfd_target_vector
init|;
operator|*
name|target_ptr
operator|!=
name|NULL
condition|;
name|target_ptr
operator|++
control|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|back
decl_stmt|;
comment|/* Skip this target and targets with incompatible byte 	     order.  */
if|if
condition|(
operator|*
name|target_ptr
operator|==
name|target
operator|||
operator|(
operator|*
name|target_ptr
operator|)
operator|->
name|flavour
operator|!=
name|bfd_target_elf_flavour
operator|||
operator|(
operator|*
name|target_ptr
operator|)
operator|->
name|byteorder
operator|!=
name|target
operator|->
name|byteorder
operator|||
operator|(
operator|(
operator|*
name|target_ptr
operator|)
operator|->
name|header_byteorder
operator|!=
name|target
operator|->
name|header_byteorder
operator|)
condition|)
continue|continue;
name|back
operator|=
operator|(
specifier|const
expr|struct
name|elf_backend_data
operator|*
operator|)
operator|(
operator|*
name|target_ptr
operator|)
operator|->
name|backend_data
expr_stmt|;
if|if
condition|(
name|back
operator|->
name|elf_osabi
operator|==
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|&&
operator|(
name|back
operator|->
name|elf_machine_code
operator|==
name|i_ehdrp
operator|->
name|e_machine
operator|||
operator|(
name|back
operator|->
name|elf_machine_alt1
operator|!=
literal|0
operator|&&
name|back
operator|->
name|elf_machine_alt1
operator|==
name|i_ehdrp
operator|->
name|e_machine
operator|)
operator|||
operator|(
name|back
operator|->
name|elf_machine_alt2
operator|!=
literal|0
operator|&&
name|back
operator|->
name|elf_machine_alt2
operator|==
name|i_ehdrp
operator|->
name|e_machine
operator|)
operator|)
condition|)
block|{
comment|/* target_ptr is an ELF backend which matches this 		 object file, so reject the ELFOSABI_NONE ELF target.  */
goto|goto
name|got_wrong_format_error
goto|;
block|}
block|}
block|}
if|if
condition|(
name|i_ehdrp
operator|->
name|e_shoff
operator|!=
literal|0
condition|)
block|{
name|bfd_signed_vma
name|where
init|=
name|i_ehdrp
operator|->
name|e_shoff
decl_stmt|;
if|if
condition|(
name|where
operator|!=
operator|(
name|file_ptr
operator|)
name|where
condition|)
goto|goto
name|got_wrong_format_error
goto|;
comment|/* Seek to the section header table in the file.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|where
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|got_no_match
goto|;
comment|/* Read the first section header at index 0, and convert to internal 	 form.  */
if|if
condition|(
name|bfd_bread
argument_list|(
operator|&
name|x_shdr
argument_list|,
sizeof|sizeof
name|x_shdr
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|x_shdr
argument_list|)
condition|)
goto|goto
name|got_no_match
goto|;
name|elf_swap_shdr_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|x_shdr
argument_list|,
operator|&
name|i_shdr
argument_list|)
expr_stmt|;
comment|/* If the section count is zero, the actual count is in the first 	 section header.  */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_shnum
operator|==
name|SHN_UNDEF
condition|)
block|{
name|i_ehdrp
operator|->
name|e_shnum
operator|=
name|i_shdr
operator|.
name|sh_size
expr_stmt|;
if|if
condition|(
name|i_ehdrp
operator|->
name|e_shnum
operator|!=
name|i_shdr
operator|.
name|sh_size
operator|||
name|i_ehdrp
operator|->
name|e_shnum
operator|==
literal|0
condition|)
goto|goto
name|got_wrong_format_error
goto|;
block|}
comment|/* And similarly for the string table index.  */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_shstrndx
operator|==
name|SHN_XINDEX
condition|)
block|{
name|i_ehdrp
operator|->
name|e_shstrndx
operator|=
name|i_shdr
operator|.
name|sh_link
expr_stmt|;
if|if
condition|(
name|i_ehdrp
operator|->
name|e_shstrndx
operator|!=
name|i_shdr
operator|.
name|sh_link
condition|)
goto|goto
name|got_wrong_format_error
goto|;
block|}
comment|/* Sanity check that we can read all of the section headers. 	 It ought to be good enough to just read the last one.  */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_shnum
operator|!=
literal|1
condition|)
block|{
comment|/* Check that we don't have a totally silly number of sections.  */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_shnum
operator|>
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
operator|/
sizeof|sizeof
argument_list|(
name|x_shdr
argument_list|)
operator|||
name|i_ehdrp
operator|->
name|e_shnum
operator|>
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
operator|/
sizeof|sizeof
argument_list|(
name|i_shdr
argument_list|)
condition|)
goto|goto
name|got_wrong_format_error
goto|;
name|where
operator|+=
operator|(
name|i_ehdrp
operator|->
name|e_shnum
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|x_shdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|where
operator|!=
operator|(
name|file_ptr
operator|)
name|where
condition|)
goto|goto
name|got_wrong_format_error
goto|;
if|if
condition|(
operator|(
name|bfd_size_type
operator|)
name|where
operator|<=
name|i_ehdrp
operator|->
name|e_shoff
condition|)
goto|goto
name|got_wrong_format_error
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|where
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|got_no_match
goto|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|&
name|x_shdr
argument_list|,
sizeof|sizeof
name|x_shdr
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|x_shdr
argument_list|)
condition|)
goto|goto
name|got_no_match
goto|;
comment|/* Back to where we were.  */
name|where
operator|=
name|i_ehdrp
operator|->
name|e_shoff
operator|+
sizeof|sizeof
argument_list|(
name|x_shdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|where
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|got_no_match
goto|;
block|}
block|}
comment|/* Allocate space for a copy of the section header table in      internal form.  */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_shnum
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|shdrp
decl_stmt|;
name|unsigned
name|int
name|num_sec
decl_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|i_shdrp
argument_list|)
operator|*
name|i_ehdrp
operator|->
name|e_shnum
expr_stmt|;
name|i_shdrp
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i_shdrp
condition|)
goto|goto
name|got_no_match
goto|;
name|num_sec
operator|=
name|i_ehdrp
operator|->
name|e_shnum
expr_stmt|;
if|if
condition|(
name|num_sec
operator|>
name|SHN_LORESERVE
condition|)
name|num_sec
operator|+=
name|SHN_HIRESERVE
operator|+
literal|1
operator|-
name|SHN_LORESERVE
expr_stmt|;
name|elf_numsections
argument_list|(
name|abfd
argument_list|)
operator|=
name|num_sec
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|i_shdrp
argument_list|)
operator|*
name|num_sec
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|got_no_match
goto|;
name|memcpy
argument_list|(
name|i_shdrp
argument_list|,
operator|&
name|i_shdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|i_shdrp
argument_list|)
argument_list|)
expr_stmt|;
name|shdrp
operator|=
name|i_shdrp
expr_stmt|;
name|shindex
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|num_sec
operator|>
name|SHN_LORESERVE
condition|)
block|{
for|for
control|(
init|;
name|shindex
operator|<
name|SHN_LORESERVE
condition|;
name|shindex
operator|++
control|)
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
operator|=
name|shdrp
operator|++
expr_stmt|;
for|for
control|(
init|;
name|shindex
operator|<
name|SHN_HIRESERVE
operator|+
literal|1
condition|;
name|shindex
operator|++
control|)
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
operator|=
name|i_shdrp
expr_stmt|;
block|}
for|for
control|(
init|;
name|shindex
operator|<
name|num_sec
condition|;
name|shindex
operator|++
control|)
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
operator|=
name|shdrp
operator|++
expr_stmt|;
comment|/* Read in the rest of the section header table and convert it 	 to internal form.  */
for|for
control|(
name|shindex
operator|=
literal|1
init|;
name|shindex
operator|<
name|i_ehdrp
operator|->
name|e_shnum
condition|;
name|shindex
operator|++
control|)
block|{
if|if
condition|(
name|bfd_bread
argument_list|(
operator|&
name|x_shdr
argument_list|,
sizeof|sizeof
name|x_shdr
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|x_shdr
argument_list|)
condition|)
goto|goto
name|got_no_match
goto|;
name|elf_swap_shdr_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|x_shdr
argument_list|,
name|i_shdrp
operator|+
name|shindex
argument_list|)
expr_stmt|;
comment|/* Sanity check sh_link and sh_info.  */
if|if
condition|(
operator|!
name|valid_section_index_p
argument_list|(
name|i_shdrp
index|[
name|shindex
index|]
operator|.
name|sh_link
argument_list|,
name|num_sec
argument_list|)
condition|)
goto|goto
name|got_wrong_format_error
goto|;
if|if
condition|(
operator|(
operator|(
name|i_shdrp
index|[
name|shindex
index|]
operator|.
name|sh_flags
operator|&
name|SHF_INFO_LINK
operator|)
operator|||
name|i_shdrp
index|[
name|shindex
index|]
operator|.
name|sh_type
operator|==
name|SHT_RELA
operator|||
name|i_shdrp
index|[
name|shindex
index|]
operator|.
name|sh_type
operator|==
name|SHT_REL
operator|)
operator|&&
operator|!
name|valid_section_index_p
argument_list|(
name|i_shdrp
index|[
name|shindex
index|]
operator|.
name|sh_info
argument_list|,
name|num_sec
argument_list|)
condition|)
goto|goto
name|got_wrong_format_error
goto|;
comment|/* If the section is loaded, but not page aligned, clear 	     D_PAGED.  */
if|if
condition|(
name|i_shdrp
index|[
name|shindex
index|]
operator|.
name|sh_size
operator|!=
literal|0
operator|&&
operator|(
name|i_shdrp
index|[
name|shindex
index|]
operator|.
name|sh_flags
operator|&
name|SHF_ALLOC
operator|)
operator|!=
literal|0
operator|&&
name|i_shdrp
index|[
name|shindex
index|]
operator|.
name|sh_type
operator|!=
name|SHT_NOBITS
operator|&&
operator|(
operator|(
operator|(
name|i_shdrp
index|[
name|shindex
index|]
operator|.
name|sh_addr
operator|-
name|i_shdrp
index|[
name|shindex
index|]
operator|.
name|sh_offset
operator|)
operator|%
name|ebd
operator|->
name|minpagesize
operator|)
operator|!=
literal|0
operator|)
condition|)
name|abfd
operator|->
name|flags
operator|&=
operator|~
name|D_PAGED
expr_stmt|;
block|}
block|}
comment|/* A further sanity check.  */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_shnum
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|valid_section_index_p
argument_list|(
name|i_ehdrp
operator|->
name|e_shstrndx
argument_list|,
name|elf_numsections
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
block|{
comment|/* PR 2257: 	     We used to just goto got_wrong_format_error here 	     but there are binaries in existance for which this test 	     will prevent the binutils from working with them at all. 	     So we are kind, and reset the string index value to 0 	     so that at least some processing can be done.  */
name|i_ehdrp
operator|->
name|e_shstrndx
operator|=
name|SHN_UNDEF
expr_stmt|;
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"warning: %s has a corrupt string table index - ignoring"
argument_list|)
argument_list|,
name|abfd
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|i_ehdrp
operator|->
name|e_shstrndx
operator|!=
name|SHN_UNDEF
condition|)
goto|goto
name|got_wrong_format_error
goto|;
comment|/* Read in the program headers.  */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_phnum
operator|==
literal|0
condition|)
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|phdr
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|Elf_Internal_Phdr
modifier|*
name|i_phdr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|amt
operator|=
name|i_ehdrp
operator|->
name|e_phnum
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Phdr
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|phdr
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|phdr
operator|==
name|NULL
condition|)
goto|goto
name|got_no_match
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|i_ehdrp
operator|->
name|e_phoff
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|got_no_match
goto|;
name|i_phdr
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|phdr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|i_ehdrp
operator|->
name|e_phnum
condition|;
name|i
operator|++
operator|,
name|i_phdr
operator|++
control|)
block|{
name|Elf_External_Phdr
name|x_phdr
decl_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|&
name|x_phdr
argument_list|,
sizeof|sizeof
name|x_phdr
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
name|x_phdr
condition|)
goto|goto
name|got_no_match
goto|;
name|elf_swap_phdr_in
argument_list|(
name|abfd
argument_list|,
operator|&
name|x_phdr
argument_list|,
name|i_phdr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i_ehdrp
operator|->
name|e_shstrndx
operator|!=
literal|0
operator|&&
name|i_ehdrp
operator|->
name|e_shoff
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|num_sec
decl_stmt|;
comment|/* Once all of the section headers have been read and converted, we 	 can start processing them.  Note that the first section header is 	 a dummy placeholder entry, so we ignore it.  */
name|num_sec
operator|=
name|elf_numsections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|shindex
operator|=
literal|1
init|;
name|shindex
operator|<
name|num_sec
condition|;
name|shindex
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|bfd_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|shindex
argument_list|)
condition|)
goto|goto
name|got_no_match
goto|;
if|if
condition|(
name|shindex
operator|==
name|SHN_LORESERVE
operator|-
literal|1
condition|)
name|shindex
operator|+=
name|SHN_HIRESERVE
operator|+
literal|1
operator|-
name|SHN_LORESERVE
expr_stmt|;
block|}
comment|/* Set up ELF sections for SHF_GROUP and SHF_LINK_ORDER.  */
if|if
condition|(
operator|!
name|_bfd_elf_setup_sections
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|got_wrong_format_error
goto|;
block|}
comment|/* Let the backend double check the format and override global      information.  */
if|if
condition|(
name|ebd
operator|->
name|elf_backend_object_p
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|ebd
operator|->
name|elf_backend_object_p
call|)
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|got_wrong_format_error
goto|;
block|}
comment|/* Remember the entry point specified in the ELF file header.  */
name|bfd_set_start_address
argument_list|(
name|abfd
argument_list|,
name|i_ehdrp
operator|->
name|e_entry
argument_list|)
expr_stmt|;
comment|/* If we have created any reloc sections that are associated with      debugging sections, mark the reloc sections as debugging as well.  */
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|==
name|SHT_REL
operator|||
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|==
name|SHT_RELA
operator|)
operator|&&
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_info
operator|>
literal|0
condition|)
block|{
name|unsigned
name|long
name|targ_index
decl_stmt|;
name|asection
modifier|*
name|targ_sec
decl_stmt|;
name|targ_index
operator|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_info
expr_stmt|;
name|targ_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|targ_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ_sec
operator|!=
name|NULL
operator|&&
operator|(
name|targ_sec
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
condition|)
name|s
operator|->
name|flags
operator||=
name|SEC_DEBUGGING
expr_stmt|;
block|}
block|}
name|bfd_preserve_finish
argument_list|(
name|abfd
argument_list|,
operator|&
name|preserve
argument_list|)
expr_stmt|;
return|return
name|target
return|;
name|got_wrong_format_error
label|:
comment|/* There is way too much undoing of half-known state here.  The caller,      bfd_check_format_matches, really shouldn't iterate on live bfd's to      check match/no-match like it does.  We have to rely on that a call to      bfd_default_set_arch_mach with the previously known mach, undoes what      was done by the first bfd_default_set_arch_mach (with mach 0) here.      For this to work, only elf-data and the mach may be changed by the      target-specific elf_backend_object_p function.  Note that saving the      whole bfd here and restoring it would be even worse; the first thing      you notice is that the cached bfd file position gets out of sync.  */
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
name|got_no_match
label|:
if|if
condition|(
name|preserve
operator|.
name|marker
operator|!=
name|NULL
condition|)
name|bfd_preserve_restore
argument_list|(
name|abfd
argument_list|,
operator|&
name|preserve
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ELF .o/exec file writing */
end_comment

begin_comment
comment|/* Write out the relocs.  */
end_comment

begin_function
name|void
name|elf_write_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|bfd_boolean
modifier|*
name|failedp
init|=
name|data
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|rela_hdr
decl_stmt|;
name|bfd_vma
name|addr_offset
decl_stmt|;
name|void
function_decl|(
modifier|*
name|swap_out
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|)
function_decl|;
name|size_t
name|extsize
decl_stmt|;
name|bfd_byte
modifier|*
name|dst_rela
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
name|asymbol
modifier|*
name|last_sym
decl_stmt|;
name|int
name|last_sym_idx
decl_stmt|;
comment|/* If we have already failed, don't do anything.  */
if|if
condition|(
operator|*
name|failedp
condition|)
return|return;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* The linker backend writes the relocs out itself, and sets the      reloc_count field to zero to inhibit writing them here.  Also,      sometimes the SEC_RELOC flag gets set even when there aren't any      relocs.  */
if|if
condition|(
name|sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return;
comment|/* If we have opened an existing file for update, reloc_count may be      set even though we are not linking.  In that case we have nothing      to do.  */
if|if
condition|(
name|sec
operator|->
name|orelocation
operator|==
name|NULL
condition|)
return|return;
name|rela_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
name|rela_hdr
operator|->
name|sh_size
operator|=
name|rela_hdr
operator|->
name|sh_entsize
operator|*
name|sec
operator|->
name|reloc_count
expr_stmt|;
name|rela_hdr
operator|->
name|contents
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|rela_hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rela_hdr
operator|->
name|contents
operator|==
name|NULL
condition|)
block|{
operator|*
name|failedp
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
comment|/* Figure out whether the relocations are RELA or REL relocations.  */
if|if
condition|(
name|rela_hdr
operator|->
name|sh_type
operator|==
name|SHT_RELA
condition|)
block|{
name|swap_out
operator|=
name|elf_swap_reloca_out
expr_stmt|;
name|extsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rela_hdr
operator|->
name|sh_type
operator|==
name|SHT_REL
condition|)
block|{
name|swap_out
operator|=
name|elf_swap_reloc_out
expr_stmt|;
name|extsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Rel
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Every relocation section should be either an SHT_RELA or an        SHT_REL section.  */
name|abort
argument_list|()
expr_stmt|;
comment|/* The address of an ELF reloc is section relative for an object      file, and absolute for an executable file or shared library.      The address of a BFD reloc is always section relative.  */
name|addr_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
operator|!=
literal|0
condition|)
name|addr_offset
operator|=
name|sec
operator|->
name|vma
expr_stmt|;
comment|/* orelocation has the data, reloc_count has the count...  */
name|last_sym
operator|=
literal|0
expr_stmt|;
name|last_sym_idx
operator|=
literal|0
expr_stmt|;
name|dst_rela
operator|=
name|rela_hdr
operator|->
name|contents
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|sec
operator|->
name|reloc_count
condition|;
name|idx
operator|++
operator|,
name|dst_rela
operator|+=
name|extsize
control|)
block|{
name|Elf_Internal_Rela
name|src_rela
decl_stmt|;
name|arelent
modifier|*
name|ptr
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|int
name|n
decl_stmt|;
name|ptr
operator|=
name|sec
operator|->
name|orelocation
index|[
name|idx
index|]
expr_stmt|;
name|sym
operator|=
operator|*
name|ptr
operator|->
name|sym_ptr_ptr
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|last_sym
condition|)
name|n
operator|=
name|last_sym_idx
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sym
operator|->
name|section
argument_list|)
operator|&&
name|sym
operator|->
name|value
operator|==
literal|0
condition|)
name|n
operator|=
name|STN_UNDEF
expr_stmt|;
else|else
block|{
name|last_sym
operator|=
name|sym
expr_stmt|;
name|n
operator|=
name|_bfd_elf_symbol_from_bfd_symbol
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
operator|*
name|failedp
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
name|last_sym_idx
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|ptr
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|the_bfd
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|ptr
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|the_bfd
operator|->
name|xvec
operator|!=
name|abfd
operator|->
name|xvec
operator|&&
operator|!
name|_bfd_elf_validate_reloc
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
condition|)
block|{
operator|*
name|failedp
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
name|src_rela
operator|.
name|r_offset
operator|=
name|ptr
operator|->
name|address
operator|+
name|addr_offset
expr_stmt|;
name|src_rela
operator|.
name|r_info
operator|=
name|ELF_R_INFO
argument_list|(
name|n
argument_list|,
name|ptr
operator|->
name|howto
operator|->
name|type
argument_list|)
expr_stmt|;
name|src_rela
operator|.
name|r_addend
operator|=
name|ptr
operator|->
name|addend
expr_stmt|;
call|(
modifier|*
name|swap_out
call|)
argument_list|(
name|abfd
argument_list|,
operator|&
name|src_rela
argument_list|,
name|dst_rela
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write out the program headers.  */
end_comment

begin_function
name|int
name|elf_write_out_phdrs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|Elf_Internal_Phdr
modifier|*
name|phdr
parameter_list|,
name|unsigned
name|int
name|count
parameter_list|)
block|{
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|Elf_External_Phdr
name|extphdr
decl_stmt|;
name|elf_swap_phdr_out
argument_list|(
name|abfd
argument_list|,
name|phdr
argument_list|,
operator|&
name|extphdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|&
name|extphdr
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_External_Phdr
argument_list|)
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|Elf_External_Phdr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|phdr
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Write out the section headers and the ELF file header.  */
end_comment

begin_function
name|bfd_boolean
name|elf_write_shdrs_and_ehdr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|Elf_External_Ehdr
name|x_ehdr
decl_stmt|;
comment|/* Elf file header, external form */
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
comment|/* Elf file header, internal form */
name|Elf_External_Shdr
modifier|*
name|x_shdrp
decl_stmt|;
comment|/* Section header table, external form */
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|i_shdrp
decl_stmt|;
comment|/* Section header table, internal form */
name|unsigned
name|int
name|count
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|i_shdrp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* swap the header before spitting it out...  */
if|#
directive|if
name|DEBUG
operator|&
literal|1
name|elf_debug_file
argument_list|(
name|i_ehdrp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|elf_swap_ehdr_out
argument_list|(
name|abfd
argument_list|,
name|i_ehdrp
argument_list|,
operator|&
name|x_ehdr
argument_list|)
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|x_ehdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bwrite
argument_list|(
operator|&
name|x_ehdr
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
comment|/* Some fields in the first section header handle overflow of ehdr      fields.  */
if|if
condition|(
name|i_ehdrp
operator|->
name|e_shnum
operator|>=
name|SHN_LORESERVE
condition|)
name|i_shdrp
index|[
literal|0
index|]
operator|->
name|sh_size
operator|=
name|i_ehdrp
operator|->
name|e_shnum
expr_stmt|;
if|if
condition|(
name|i_ehdrp
operator|->
name|e_shstrndx
operator|>=
name|SHN_LORESERVE
condition|)
name|i_shdrp
index|[
literal|0
index|]
operator|->
name|sh_link
operator|=
name|i_ehdrp
operator|->
name|e_shstrndx
expr_stmt|;
comment|/* at this point we've concocted all the ELF sections...  */
name|amt
operator|=
name|i_ehdrp
operator|->
name|e_shnum
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
operator|*
name|x_shdrp
argument_list|)
expr_stmt|;
name|x_shdrp
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x_shdrp
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|i_ehdrp
operator|->
name|e_shnum
condition|;
name|i_shdrp
operator|++
operator|,
name|count
operator|++
control|)
block|{
if|#
directive|if
name|DEBUG
operator|&
literal|2
name|elf_debug_section
argument_list|(
name|count
argument_list|,
operator|*
name|i_shdrp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|elf_swap_shdr_out
argument_list|(
name|abfd
argument_list|,
operator|*
name|i_shdrp
argument_list|,
name|x_shdrp
operator|+
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|SHN_LORESERVE
operator|-
literal|1
condition|)
name|i_shdrp
operator|+=
name|SHN_HIRESERVE
operator|+
literal|1
operator|-
name|SHN_LORESERVE
expr_stmt|;
block|}
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|i_ehdrp
operator|->
name|e_shoff
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bwrite
argument_list|(
name|x_shdrp
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
return|return
name|FALSE
return|;
comment|/* need to dump the string table too...  */
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|long
name|elf_slurp_symbol_table
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symptrs
parameter_list|,
name|bfd_boolean
name|dynamic
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|verhdr
decl_stmt|;
name|unsigned
name|long
name|symcount
decl_stmt|;
comment|/* Number of external ELF symbols */
name|elf_symbol_type
modifier|*
name|sym
decl_stmt|;
comment|/* Pointer to current bfd symbol */
name|elf_symbol_type
modifier|*
name|symbase
decl_stmt|;
comment|/* Buffer for generated bfd symbols */
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymend
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
name|Elf_External_Versym
modifier|*
name|xver
decl_stmt|;
name|Elf_External_Versym
modifier|*
name|xverbuf
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|ebd
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* Read each raw ELF symbol, converting from external ELF form to      internal ELF form, and then using the information to create a      canonical bfd symbol table entry.       Note that we allocate the initial bfd canonical symbol buffer      based on a one-to-one mapping of the ELF symbols to canonical      symbols.  We actually use all the ELF symbols, so there will be no      space left over at the end.  When we have all the symbols, we      build the caller's pointer vector.  */
if|if
condition|(
operator|!
name|dynamic
condition|)
block|{
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|verhdr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynsymtab_hdr
expr_stmt|;
if|if
condition|(
name|elf_dynversym
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
name|verhdr
operator|=
name|NULL
expr_stmt|;
else|else
name|verhdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynversym_hdr
expr_stmt|;
if|if
condition|(
operator|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynverdef_section
operator|!=
literal|0
operator|&&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verdef
operator|==
name|NULL
operator|)
operator|||
operator|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynverref_section
operator|!=
literal|0
operator|&&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verref
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_slurp_version_tables
argument_list|(
name|abfd
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
name|ebd
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|symcount
operator|=
name|hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|symcount
operator|==
literal|0
condition|)
name|sym
operator|=
name|symbase
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|symcount
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|amt
operator|=
name|symcount
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|elf_symbol_type
argument_list|)
expr_stmt|;
name|symbase
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbase
operator|==
operator|(
name|elf_symbol_type
operator|*
operator|)
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* Read the raw ELF version symbol information.  */
if|if
condition|(
name|verhdr
operator|!=
name|NULL
operator|&&
name|verhdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Versym
argument_list|)
operator|!=
name|symcount
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: version count (%ld) does not match symbol count (%ld)"
argument_list|)
argument_list|,
name|abfd
operator|->
name|filename
argument_list|,
call|(
name|long
call|)
argument_list|(
name|verhdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_External_Versym
argument_list|)
argument_list|)
argument_list|,
name|symcount
argument_list|)
expr_stmt|;
comment|/* Slurp in the symbols without the version information, 	     since that is more helpful than just quitting.  */
name|verhdr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|verhdr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|verhdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|xverbuf
operator|=
name|bfd_malloc
argument_list|(
name|verhdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|xverbuf
operator|==
name|NULL
operator|&&
name|verhdr
operator|->
name|sh_size
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_bread
argument_list|(
name|xverbuf
argument_list|,
name|verhdr
operator|->
name|sh_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|verhdr
operator|->
name|sh_size
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Skip first symbol, which is a null dummy.  */
name|xver
operator|=
name|xverbuf
expr_stmt|;
if|if
condition|(
name|xver
operator|!=
name|NULL
condition|)
operator|++
name|xver
expr_stmt|;
name|isymend
operator|=
name|isymbuf
operator|+
name|symcount
expr_stmt|;
for|for
control|(
name|isym
operator|=
name|isymbuf
operator|+
literal|1
operator|,
name|sym
operator|=
name|symbase
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
operator|,
name|sym
operator|++
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|sym
operator|->
name|internal_elf_sym
argument_list|,
name|isym
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Sym
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|name
operator|=
name|bfd_elf_sym_name
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|isym
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sym
operator|->
name|symbol
operator|.
name|value
operator|=
name|isym
operator|->
name|st_value
expr_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
block|{
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|<
name|SHN_LORESERVE
operator|||
name|isym
operator|->
name|st_shndx
operator|>
name|SHN_HIRESERVE
condition|)
block|{
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|symbol
operator|.
name|section
operator|==
name|NULL
condition|)
block|{
comment|/* This symbol is in a section for which we did not 		     create a BFD section.  Just use bfd_abs_section, 		     although it is wrong.  FIXME.  */
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
block|{
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
block|{
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_com_section_ptr
expr_stmt|;
comment|/* Elf puts the alignment into the `value' field, and 		 the size into the `size' field.  BFD wants to see the 		 size in the value field, and doesn't care (at the 		 moment) about the alignment.  */
name|sym
operator|->
name|symbol
operator|.
name|value
operator|=
name|isym
operator|->
name|st_size
expr_stmt|;
block|}
else|else
name|sym
operator|->
name|symbol
operator|.
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
comment|/* If this is a relocatable file, then the symbol value is 	     already section relative.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
operator|!=
literal|0
condition|)
name|sym
operator|->
name|symbol
operator|.
name|value
operator|-=
name|sym
operator|->
name|symbol
operator|.
name|section
operator|->
name|vma
expr_stmt|;
switch|switch
condition|(
name|ELF_ST_BIND
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
condition|)
block|{
case|case
name|STB_LOCAL
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_LOCAL
expr_stmt|;
break|break;
case|case
name|STB_GLOBAL
case|:
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|isym
operator|->
name|st_shndx
operator|!=
name|SHN_COMMON
condition|)
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_GLOBAL
expr_stmt|;
break|break;
case|case
name|STB_WEAK
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_WEAK
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|ELF_ST_TYPE
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
condition|)
block|{
case|case
name|STT_SECTION
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_SECTION_SYM
operator||
name|BSF_DEBUGGING
expr_stmt|;
break|break;
case|case
name|STT_FILE
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_FILE
operator||
name|BSF_DEBUGGING
expr_stmt|;
break|break;
case|case
name|STT_FUNC
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_FUNCTION
expr_stmt|;
break|break;
case|case
name|STT_OBJECT
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_OBJECT
expr_stmt|;
break|break;
case|case
name|STT_TLS
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_THREAD_LOCAL
expr_stmt|;
break|break;
case|case
name|STT_RELC
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_RELC
expr_stmt|;
break|break;
case|case
name|STT_SRELC
case|:
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_SRELC
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dynamic
condition|)
name|sym
operator|->
name|symbol
operator|.
name|flags
operator||=
name|BSF_DYNAMIC
expr_stmt|;
if|if
condition|(
name|xver
operator|!=
name|NULL
condition|)
block|{
name|Elf_Internal_Versym
name|iversym
decl_stmt|;
name|_bfd_elf_swap_versym_in
argument_list|(
name|abfd
argument_list|,
name|xver
argument_list|,
operator|&
name|iversym
argument_list|)
expr_stmt|;
name|sym
operator|->
name|version
operator|=
name|iversym
operator|.
name|vs_vers
expr_stmt|;
name|xver
operator|++
expr_stmt|;
block|}
comment|/* Do some backend-specific processing on this symbol.  */
if|if
condition|(
name|ebd
operator|->
name|elf_backend_symbol_processing
condition|)
call|(
modifier|*
name|ebd
operator|->
name|elf_backend_symbol_processing
call|)
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
operator|->
name|symbol
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Do some backend-specific processing on this symbol table.  */
if|if
condition|(
name|ebd
operator|->
name|elf_backend_symbol_table_processing
condition|)
call|(
modifier|*
name|ebd
operator|->
name|elf_backend_symbol_table_processing
call|)
argument_list|(
name|abfd
argument_list|,
name|symbase
argument_list|,
name|symcount
argument_list|)
expr_stmt|;
comment|/* We rely on the zalloc to clear out the final symbol entry.  */
name|symcount
operator|=
name|sym
operator|-
name|symbase
expr_stmt|;
comment|/* Fill in the user's symbol pointer vector if needed.  */
if|if
condition|(
name|symptrs
condition|)
block|{
name|long
name|l
init|=
name|symcount
decl_stmt|;
name|sym
operator|=
name|symbase
expr_stmt|;
while|while
condition|(
name|l
operator|--
operator|>
literal|0
condition|)
block|{
operator|*
name|symptrs
operator|++
operator|=
operator|&
name|sym
operator|->
name|symbol
expr_stmt|;
name|sym
operator|++
expr_stmt|;
block|}
operator|*
name|symptrs
operator|=
literal|0
expr_stmt|;
comment|/* Final null pointer */
block|}
if|if
condition|(
name|xverbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|xverbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
return|return
name|symcount
return|;
name|error_return
label|:
if|if
condition|(
name|xverbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|xverbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Read relocations for ASECT from REL_HDR.  There are RELOC_COUNT of    them.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_slurp_reloc_table_from_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|asect
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
parameter_list|,
name|bfd_size_type
name|reloc_count
parameter_list|,
name|arelent
modifier|*
name|relents
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|,
name|bfd_boolean
name|dynamic
parameter_list|)
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
specifier|const
name|ebd
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|void
modifier|*
name|allocated
init|=
name|NULL
decl_stmt|;
name|bfd_byte
modifier|*
name|native_relocs
decl_stmt|;
name|arelent
modifier|*
name|relent
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|entsize
decl_stmt|;
name|unsigned
name|int
name|symcount
decl_stmt|;
name|allocated
operator|=
name|bfd_malloc
argument_list|(
name|rel_hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocated
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|rel_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_bread
argument_list|(
name|allocated
argument_list|,
name|rel_hdr
operator|->
name|sh_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|rel_hdr
operator|->
name|sh_size
operator|)
condition|)
goto|goto
name|error_return
goto|;
name|native_relocs
operator|=
name|allocated
expr_stmt|;
name|entsize
operator|=
name|rel_hdr
operator|->
name|sh_entsize
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rel
argument_list|)
operator|||
name|entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic
condition|)
name|symcount
operator|=
name|bfd_get_dynamic_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
else|else
name|symcount
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|relent
operator|=
name|relents
init|;
name|i
operator|<
name|reloc_count
condition|;
name|i
operator|++
operator|,
name|relent
operator|++
operator|,
name|native_relocs
operator|+=
name|entsize
control|)
block|{
name|Elf_Internal_Rela
name|rela
decl_stmt|;
if|if
condition|(
name|entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
condition|)
name|elf_swap_reloca_in
argument_list|(
name|abfd
argument_list|,
name|native_relocs
argument_list|,
operator|&
name|rela
argument_list|)
expr_stmt|;
else|else
name|elf_swap_reloc_in
argument_list|(
name|abfd
argument_list|,
name|native_relocs
argument_list|,
operator|&
name|rela
argument_list|)
expr_stmt|;
comment|/* The address of an ELF reloc is section relative for an object 	 file, and absolute for an executable file or shared library. 	 The address of a normal BFD reloc is always section relative, 	 and the address of a dynamic reloc is absolute..  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
operator|==
literal|0
operator|||
name|dynamic
condition|)
name|relent
operator|->
name|address
operator|=
name|rela
operator|.
name|r_offset
expr_stmt|;
else|else
name|relent
operator|->
name|address
operator|=
name|rela
operator|.
name|r_offset
operator|-
name|asect
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|ELF_R_SYM
argument_list|(
name|rela
operator|.
name|r_info
argument_list|)
operator|==
literal|0
condition|)
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|ELF_R_SYM
argument_list|(
name|rela
operator|.
name|r_info
argument_list|)
operator|>
name|symcount
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s(%s): relocation %d has invalid symbol index %ld"
argument_list|)
argument_list|,
name|abfd
operator|->
name|filename
argument_list|,
name|asect
operator|->
name|name
argument_list|,
name|i
argument_list|,
name|ELF_R_SYM
argument_list|(
name|rela
operator|.
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section
operator|.
name|symbol_ptr_ptr
expr_stmt|;
block|}
else|else
block|{
name|asymbol
modifier|*
modifier|*
name|ps
decl_stmt|;
name|ps
operator|=
name|symbols
operator|+
name|ELF_R_SYM
argument_list|(
name|rela
operator|.
name|r_info
argument_list|)
operator|-
literal|1
expr_stmt|;
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|ps
expr_stmt|;
block|}
name|relent
operator|->
name|addend
operator|=
name|rela
operator|.
name|r_addend
expr_stmt|;
if|if
condition|(
operator|(
name|entsize
operator|==
sizeof|sizeof
argument_list|(
name|Elf_External_Rela
argument_list|)
operator|&&
name|ebd
operator|->
name|elf_info_to_howto
operator|!=
name|NULL
operator|)
operator|||
name|ebd
operator|->
name|elf_info_to_howto_rel
operator|==
name|NULL
condition|)
call|(
modifier|*
name|ebd
operator|->
name|elf_info_to_howto
call|)
argument_list|(
name|abfd
argument_list|,
name|relent
argument_list|,
operator|&
name|rela
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|ebd
operator|->
name|elf_info_to_howto_rel
call|)
argument_list|(
name|abfd
argument_list|,
name|relent
argument_list|,
operator|&
name|rela
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|allocated
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|allocated
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|allocated
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|allocated
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Read in and swap the external relocs.  */
end_comment

begin_function
name|bfd_boolean
name|elf_slurp_reloc_table
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|asect
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|,
name|bfd_boolean
name|dynamic
parameter_list|)
block|{
name|struct
name|bfd_elf_section_data
modifier|*
specifier|const
name|d
init|=
name|elf_section_data
argument_list|(
name|asect
argument_list|)
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|rel_hdr2
decl_stmt|;
name|bfd_size_type
name|reloc_count
decl_stmt|;
name|bfd_size_type
name|reloc_count2
decl_stmt|;
name|arelent
modifier|*
name|relents
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|asect
operator|->
name|relocation
operator|!=
name|NULL
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|dynamic
condition|)
block|{
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|asect
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|rel_hdr
operator|=
operator|&
name|d
operator|->
name|rel_hdr
expr_stmt|;
name|reloc_count
operator|=
name|NUM_SHDR_ENTRIES
argument_list|(
name|rel_hdr
argument_list|)
expr_stmt|;
name|rel_hdr2
operator|=
name|d
operator|->
name|rel_hdr2
expr_stmt|;
name|reloc_count2
operator|=
operator|(
name|rel_hdr2
condition|?
name|NUM_SHDR_ENTRIES
argument_list|(
name|rel_hdr2
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|asect
operator|->
name|reloc_count
operator|==
name|reloc_count
operator|+
name|reloc_count2
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|asect
operator|->
name|rel_filepos
operator|==
name|rel_hdr
operator|->
name|sh_offset
operator|||
operator|(
name|rel_hdr2
operator|&&
name|asect
operator|->
name|rel_filepos
operator|==
name|rel_hdr2
operator|->
name|sh_offset
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Note that ASECT->RELOC_COUNT tends not to be accurate in this 	 case because relocations against this section may use the 	 dynamic symbol table, and in that case bfd_section_from_shdr 	 in elf.c does not update the RELOC_COUNT.  */
if|if
condition|(
name|asect
operator|->
name|size
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|rel_hdr
operator|=
operator|&
name|d
operator|->
name|this_hdr
expr_stmt|;
name|reloc_count
operator|=
name|NUM_SHDR_ENTRIES
argument_list|(
name|rel_hdr
argument_list|)
expr_stmt|;
name|rel_hdr2
operator|=
name|NULL
expr_stmt|;
name|reloc_count2
operator|=
literal|0
expr_stmt|;
block|}
name|amt
operator|=
operator|(
name|reloc_count
operator|+
name|reloc_count2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
argument_list|)
expr_stmt|;
name|relents
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|relents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|elf_slurp_reloc_table_from_section
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|,
name|rel_hdr
argument_list|,
name|reloc_count
argument_list|,
name|relents
argument_list|,
name|symbols
argument_list|,
name|dynamic
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|rel_hdr2
operator|&&
operator|!
name|elf_slurp_reloc_table_from_section
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|,
name|rel_hdr2
argument_list|,
name|reloc_count2
argument_list|,
name|relents
operator|+
name|reloc_count
argument_list|,
name|symbols
argument_list|,
name|dynamic
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|asect
operator|->
name|relocation
operator|=
name|relents
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_if
if|#
directive|if
name|DEBUG
operator|&
literal|2
end_if

begin_function
specifier|static
name|void
name|elf_debug_section
parameter_list|(
name|int
name|num
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|hdr
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nSection#%d '%s' 0x%.8lx\n"
argument_list|,
name|num
argument_list|,
name|hdr
operator|->
name|bfd_section
operator|!=
name|NULL
condition|?
name|hdr
operator|->
name|bfd_section
operator|->
name|name
else|:
literal|""
argument_list|,
operator|(
name|long
operator|)
name|hdr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sh_name      = %ld\tsh_type      = %ld\tsh_flags     = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_name
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_type
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sh_addr      = %ld\tsh_offset    = %ld\tsh_size      = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_addr
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_offset
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sh_link      = %ld\tsh_info      = %ld\tsh_addralign = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_link
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_info
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_addralign
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sh_entsize   = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|hdr
operator|->
name|sh_entsize
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|DEBUG
operator|&
literal|1
end_if

begin_function
specifier|static
name|void
name|elf_debug_file
parameter_list|(
name|Elf_Internal_Ehdr
modifier|*
name|ehdrp
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"e_entry      = 0x%.8lx\n"
argument_list|,
operator|(
name|long
operator|)
name|ehdrp
operator|->
name|e_entry
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"e_phoff      = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ehdrp
operator|->
name|e_phoff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"e_phnum      = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ehdrp
operator|->
name|e_phnum
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"e_phentsize  = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ehdrp
operator|->
name|e_phentsize
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"e_shoff      = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ehdrp
operator|->
name|e_shoff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"e_shnum      = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ehdrp
operator|->
name|e_shnum
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"e_shentsize  = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ehdrp
operator|->
name|e_shentsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Create a new BFD as if by bfd_openr.  Rather than opening a file,    reconstruct an ELF file by reading the segments out of remote memory    based on the ELF file header at EHDR_VMA and the ELF program headers it    points to.  If not null, *LOADBASEP is filled in with the difference    between the VMAs from which the segments were read, and the VMAs the    file headers (and hence BFD's idea of each section's VMA) put them at.     The function TARGET_READ_MEMORY is called to copy LEN bytes from the    remote memory at target address VMA into the local buffer at MYADDR; it    should return zero on success or an `errno' code on failure.  TEMPL must    be a BFD for a target with the word size and byte order found in the    remote memory.  */
end_comment

begin_decl_stmt
name|bfd
modifier|*
name|NAME
argument_list|(
name|_bfd_elf
argument_list|,
name|bfd_from_remote_memory
argument_list|)
argument_list|(
name|bfd
operator|*
name|templ
argument_list|,
name|bfd_vma
name|ehdr_vma
argument_list|,
name|bfd_vma
operator|*
name|loadbasep
argument_list|,
name|int
argument_list|(
operator|*
name|target_read_memory
argument_list|)
argument_list|(
name|bfd_vma
argument_list|,
name|bfd_byte
operator|*
argument_list|,
name|int
argument_list|)
argument_list|)
block|{
name|Elf_External_Ehdr
name|x_ehdr
decl_stmt|;
comment|/* Elf file header, external form */
name|Elf_Internal_Ehdr
name|i_ehdr
decl_stmt|;
comment|/* Elf file header, internal form */
name|Elf_External_Phdr
modifier|*
name|x_phdrs
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|i_phdrs
decl_stmt|,
modifier|*
name|last_phdr
decl_stmt|;
name|bfd
modifier|*
name|nbfd
decl_stmt|;
name|struct
name|bfd_in_memory
modifier|*
name|bim
decl_stmt|;
name|int
name|contents_size
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|int
name|err
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_vma
name|loadbase
decl_stmt|;
comment|/* Read in the ELF header in external format.  */
name|err
operator|=
name|target_read_memory
argument_list|(
name|ehdr_vma
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|&
name|x_ehdr
argument_list|,
sizeof|sizeof
name|x_ehdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
name|errno
operator|=
name|err
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Now check to see if we have a valid ELF file, and one that BFD can      make use of.  The magic number must match, the address size ('class')      and byte-swapping must match our XVEC entry.  */
if|if
condition|(
operator|!
name|elf_file_p
argument_list|(
operator|&
name|x_ehdr
argument_list|)
operator|||
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_VERSION
index|]
operator|!=
name|EV_CURRENT
operator|||
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
operator|!=
name|ELFCLASS
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Check that file's byte order matches xvec's */
switch|switch
condition|(
name|x_ehdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
condition|)
block|{
case|case
name|ELFDATA2MSB
case|:
comment|/* Big-endian */
if|if
condition|(
operator|!
name|bfd_header_big_endian
argument_list|(
name|templ
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
break|break;
case|case
name|ELFDATA2LSB
case|:
comment|/* Little-endian */
if|if
condition|(
operator|!
name|bfd_header_little_endian
argument_list|(
name|templ
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
break|break;
case|case
name|ELFDATANONE
case|:
comment|/* No data encoding specified */
default|default:
comment|/* Unknown data encoding specified */
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|elf_swap_ehdr_in
argument_list|(
name|templ
argument_list|,
operator|&
name|x_ehdr
argument_list|,
operator|&
name|i_ehdr
argument_list|)
expr_stmt|;
comment|/* The file header tells where to find the program headers.      These are what we use to actually choose what to read.  */
if|if
condition|(
name|i_ehdr
operator|.
name|e_phentsize
operator|!=
sizeof|sizeof
argument_list|(
name|Elf_External_Phdr
argument_list|)
operator|||
name|i_ehdr
operator|.
name|e_phnum
operator|==
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|x_phdrs
operator|=
name|bfd_malloc
argument_list|(
name|i_ehdr
operator|.
name|e_phnum
operator|*
operator|(
sizeof|sizeof
expr|*
name|x_phdrs
operator|+
sizeof|sizeof
expr|*
name|i_phdrs
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_phdrs
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|err
operator|=
name|target_read_memory
argument_list|(
name|ehdr_vma
operator|+
name|i_ehdr
operator|.
name|e_phoff
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_phdrs
argument_list|,
name|i_ehdr
operator|.
name|e_phnum
operator|*
sizeof|sizeof
name|x_phdrs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|free
argument_list|(
name|x_phdrs
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
name|errno
operator|=
name|err
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|i_phdrs
operator|=
operator|(
name|Elf_Internal_Phdr
operator|*
operator|)
operator|&
name|x_phdrs
index|[
name|i_ehdr
operator|.
name|e_phnum
index|]
expr_stmt|;
name|contents_size
operator|=
literal|0
expr_stmt|;
name|last_phdr
operator|=
name|NULL
expr_stmt|;
name|loadbase
operator|=
name|ehdr_vma
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|i_ehdr
operator|.
name|e_phnum
condition|;
operator|++
name|i
control|)
block|{
name|elf_swap_phdr_in
argument_list|(
name|templ
argument_list|,
operator|&
name|x_phdrs
index|[
name|i
index|]
argument_list|,
operator|&
name|i_phdrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* IA-64 vDSO may have two mappings for one segment, where one mapping 	 is executable only, and one is read only.  We must not use the 	 executable one.  */
if|if
condition|(
name|i_phdrs
index|[
name|i
index|]
operator|.
name|p_type
operator|==
name|PT_LOAD
operator|&&
operator|(
name|i_phdrs
index|[
name|i
index|]
operator|.
name|p_flags
operator|&
name|PF_R
operator|)
condition|)
block|{
name|bfd_vma
name|segment_end
decl_stmt|;
name|segment_end
operator|=
operator|(
name|i_phdrs
index|[
name|i
index|]
operator|.
name|p_offset
operator|+
name|i_phdrs
index|[
name|i
index|]
operator|.
name|p_filesz
operator|+
name|i_phdrs
index|[
name|i
index|]
operator|.
name|p_align
operator|-
literal|1
operator|)
operator|&
operator|-
name|i_phdrs
index|[
name|i
index|]
operator|.
name|p_align
expr_stmt|;
if|if
condition|(
name|segment_end
operator|>
operator|(
name|bfd_vma
operator|)
name|contents_size
condition|)
name|contents_size
operator|=
name|segment_end
expr_stmt|;
if|if
condition|(
operator|(
name|i_phdrs
index|[
name|i
index|]
operator|.
name|p_offset
operator|&
operator|-
name|i_phdrs
index|[
name|i
index|]
operator|.
name|p_align
operator|)
operator|==
literal|0
condition|)
name|loadbase
operator|=
name|ehdr_vma
operator|-
operator|(
name|i_phdrs
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|&
operator|-
name|i_phdrs
index|[
name|i
index|]
operator|.
name|p_align
operator|)
expr_stmt|;
name|last_phdr
operator|=
operator|&
name|i_phdrs
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|last_phdr
operator|==
name|NULL
condition|)
block|{
comment|/* There were no PT_LOAD segments, so we don't have anything to read.  */
name|free
argument_list|(
name|x_phdrs
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Trim the last segment so we don't bother with zeros in the last page      that are off the end of the file.  However, if the extra bit in that      page includes the section headers, keep them.  */
if|if
condition|(
operator|(
name|bfd_vma
operator|)
name|contents_size
operator|>
name|last_phdr
operator|->
name|p_offset
operator|+
name|last_phdr
operator|->
name|p_filesz
operator|&&
operator|(
name|bfd_vma
operator|)
name|contents_size
operator|>=
operator|(
name|i_ehdr
operator|.
name|e_shoff
operator|+
name|i_ehdr
operator|.
name|e_shnum
operator|*
name|i_ehdr
operator|.
name|e_shentsize
operator|)
condition|)
block|{
name|contents_size
operator|=
name|last_phdr
operator|->
name|p_offset
operator|+
name|last_phdr
operator|->
name|p_filesz
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_vma
operator|)
name|contents_size
operator|<
operator|(
name|i_ehdr
operator|.
name|e_shoff
operator|+
name|i_ehdr
operator|.
name|e_shnum
operator|*
name|i_ehdr
operator|.
name|e_shentsize
operator|)
condition|)
name|contents_size
operator|=
name|i_ehdr
operator|.
name|e_shoff
operator|+
name|i_ehdr
operator|.
name|e_shnum
operator|*
name|i_ehdr
operator|.
name|e_shentsize
expr_stmt|;
block|}
else|else
name|contents_size
operator|=
name|last_phdr
operator|->
name|p_offset
operator|+
name|last_phdr
operator|->
name|p_filesz
expr_stmt|;
comment|/* Now we know the size of the whole image we want read in.  */
name|contents
operator|=
name|bfd_zmalloc
argument_list|(
name|contents_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|x_phdrs
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|i_ehdr
operator|.
name|e_phnum
condition|;
operator|++
name|i
control|)
comment|/* IA-64 vDSO may have two mappings for one segment, where one mapping        is executable only, and one is read only.  We must not use the        executable one.  */
if|if
condition|(
name|i_phdrs
index|[
name|i
index|]
operator|.
name|p_type
operator|==
name|PT_LOAD
operator|&&
operator|(
name|i_phdrs
index|[
name|i
index|]
operator|.
name|p_flags
operator|&
name|PF_R
operator|)
condition|)
block|{
name|bfd_vma
name|start
init|=
name|i_phdrs
index|[
name|i
index|]
operator|.
name|p_offset
operator|&
operator|-
name|i_phdrs
index|[
name|i
index|]
operator|.
name|p_align
decl_stmt|;
name|bfd_vma
name|end
init|=
operator|(
name|i_phdrs
index|[
name|i
index|]
operator|.
name|p_offset
operator|+
name|i_phdrs
index|[
name|i
index|]
operator|.
name|p_filesz
operator|+
name|i_phdrs
index|[
name|i
index|]
operator|.
name|p_align
operator|-
literal|1
operator|)
operator|&
operator|-
name|i_phdrs
index|[
name|i
index|]
operator|.
name|p_align
decl_stmt|;
if|if
condition|(
name|end
operator|>
operator|(
name|bfd_vma
operator|)
name|contents_size
condition|)
name|end
operator|=
name|contents_size
expr_stmt|;
name|err
operator|=
name|target_read_memory
argument_list|(
operator|(
name|loadbase
operator|+
name|i_phdrs
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|)
operator|&
operator|-
name|i_phdrs
index|[
name|i
index|]
operator|.
name|p_align
argument_list|,
name|contents
operator|+
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|free
argument_list|(
name|x_phdrs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
name|errno
operator|=
name|err
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|free
argument_list|(
name|x_phdrs
argument_list|)
expr_stmt|;
comment|/* If the segments visible in memory didn't include the section headers,      then clear them from the file header.  */
if|if
condition|(
operator|(
name|bfd_vma
operator|)
name|contents_size
operator|<
operator|(
name|i_ehdr
operator|.
name|e_shoff
operator|+
name|i_ehdr
operator|.
name|e_shnum
operator|*
name|i_ehdr
operator|.
name|e_shentsize
operator|)
condition|)
block|{
name|memset
argument_list|(
operator|&
name|x_ehdr
operator|.
name|e_shoff
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|x_ehdr
operator|.
name|e_shoff
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|x_ehdr
operator|.
name|e_shnum
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|x_ehdr
operator|.
name|e_shnum
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|x_ehdr
operator|.
name|e_shstrndx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|x_ehdr
operator|.
name|e_shstrndx
argument_list|)
expr_stmt|;
block|}
comment|/* This will normally have been in the first PT_LOAD segment.  But it      conceivably could be missing, and we might have just changed it.  */
name|memcpy
argument_list|(
name|contents
argument_list|,
operator|&
name|x_ehdr
argument_list|,
sizeof|sizeof
name|x_ehdr
argument_list|)
expr_stmt|;
comment|/* Now we have a memory image of the ELF file contents.  Make a BFD.  */
name|bim
operator|=
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_in_memory
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bim
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|nbfd
operator|=
name|_bfd_new_bfd
argument_list|()
expr_stmt|;
if|if
condition|(
name|nbfd
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|bim
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|nbfd
operator|->
name|filename
operator|=
literal|"<in-memory>"
expr_stmt|;
name|nbfd
operator|->
name|xvec
operator|=
name|templ
operator|->
name|xvec
expr_stmt|;
name|bim
operator|->
name|size
operator|=
name|contents_size
expr_stmt|;
name|bim
operator|->
name|buffer
operator|=
name|contents
expr_stmt|;
name|nbfd
operator|->
name|iostream
operator|=
name|bim
expr_stmt|;
name|nbfd
operator|->
name|flags
operator|=
name|BFD_IN_MEMORY
expr_stmt|;
name|nbfd
operator|->
name|direction
operator|=
name|read_direction
expr_stmt|;
name|nbfd
operator|->
name|mtime
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|nbfd
operator|->
name|mtime_set
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|loadbasep
condition|)
operator|*
name|loadbasep
operator|=
name|loadbase
expr_stmt|;
return|return
name|nbfd
return|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_include
include|#
directive|include
file|"elfcore.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Size-dependent data and functions.  */
end_comment

begin_function_decl
specifier|const
name|struct
name|elf_size_info
name|NAME
parameter_list|(
name|_bfd_elf
parameter_list|,
name|size_info
parameter_list|)
init|=
block|{
sizeof|sizeof
argument_list|(
name|Elf_External_Ehdr
argument_list|)
operator|,
function_decl|sizeof
parameter_list|(
name|Elf_External_Phdr
parameter_list|)
operator|,
function_decl|sizeof
parameter_list|(
name|Elf_External_Shdr
parameter_list|)
operator|,
function_decl|sizeof
parameter_list|(
name|Elf_External_Rel
parameter_list|)
operator|,
function_decl|sizeof
parameter_list|(
name|Elf_External_Rela
parameter_list|)
operator|,
function_decl|sizeof
parameter_list|(
name|Elf_External_Sym
parameter_list|)
operator|,
function_decl|sizeof
parameter_list|(
name|Elf_External_Dyn
parameter_list|)
operator|,
function_decl|sizeof
parameter_list|(
name|Elf_External_Note
parameter_list|)
operator|,
function_decl|4
operator|,
function_decl|1
operator|,
function_decl|ARCH_SIZE
operator|,
function_decl|LOG_FILE_ALIGN
operator|,
function_decl|ELFCLASS
operator|,
function_decl|EV_CURRENT
operator|,
function_decl|elf_write_out_phdrs
operator|,
function_decl|elf_write_shdrs_and_ehdr
operator|,
function_decl|elf_write_relocs
operator|,
function_decl|elf_swap_symbol_in
operator|,
function_decl|elf_swap_symbol_out
operator|,
function_decl|elf_slurp_reloc_table
operator|,
function_decl|elf_slurp_symbol_table
operator|,
function_decl|elf_swap_dyn_in
operator|,
function_decl|elf_swap_dyn_out
operator|,
function_decl|elf_swap_reloc_in
operator|,
function_decl|elf_swap_reloc_out
operator|,
function_decl|elf_swap_reloca_in
operator|,
function_decl|elf_swap_reloca_out
end_function_decl

unit|};
end_unit

