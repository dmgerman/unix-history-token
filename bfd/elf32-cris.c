begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* CRIS-specific support for 32-bit ELF.    Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.    Contributed by Axis Communications AB.    Written by Hans-Peter Nilsson, based on elf32-fr30.c    PIC and shlib bits based primarily on elf32-m68k.c and elf32-i386.c.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/cris.h"
end_include

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|cris_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|bfd_reloc_code_real_type
name|code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cris_info_to_howto_rela
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|cris_elf_pcrel_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|cris_elf_grok_prstatus
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|Elf_Internal_Note
operator|*
name|note
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|cris_elf_grok_psinfo
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|Elf_Internal_Note
operator|*
name|note
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|cris_elf_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|cris_final_link_relocate
name|PARAMS
argument_list|(
operator|(
name|reloc_howto_type
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|cris_elf_gc_sweep_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|cris_elf_gc_mark_hook
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|cris_elf_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cris_elf_final_write_processing
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|cris_elf_set_mach_from_flags
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|long
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|cris_elf_print_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|cris_elf_merge_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|cris_elf_copy_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|elf_cris_link_hash_entry
struct_decl|;
end_struct_decl

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_cris_discard_excess_dso_dynamics
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_cris_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_cris_discard_excess_program_dynamics
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_cris_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_cris_adjust_gotplt_to_got
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_cris_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_cris_try_fold_plt_to_got
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_cris_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|elf_cris_link_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elf_cris_link_hash_table_create
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_cris_adjust_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|cris_elf_check_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_cris_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_cris_finish_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_cris_finish_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_cris_hide_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|elf_reloc_type_class
name|elf_cris_reloc_type_class
name|PARAMS
argument_list|(
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|cris_elf_howto_table
index|[]
init|=
block|{
comment|/* This reloc does nothing.  */
name|HOWTO
argument_list|(
name|R_CRIS_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRIS_NONE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An 8 bit absolute relocation.  */
name|HOWTO
argument_list|(
name|R_CRIS_8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRIS_8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000
argument_list|,
comment|/* src_mask */
literal|0x00ff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit absolute relocation.  */
name|HOWTO
argument_list|(
name|R_CRIS_16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRIS_16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x00000000
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32 bit absolute relocation.  */
name|HOWTO
argument_list|(
name|R_CRIS_32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
comment|/* We don't want overflow complaints for 64-bit vma builds 	    for e.g. sym+0x40000000 (or actually sym-0xc0000000 in 	    32-bit ELF) where sym=0xc0001234. 	    Don't do this for the PIC relocs, as we don't expect to 	    see them with large offsets.  */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRIS_32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x00000000
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An 8 bit PC-relative relocation.  */
name|HOWTO
argument_list|(
name|R_CRIS_8_PCREL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|cris_elf_pcrel_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRIS_8_PCREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000
argument_list|,
comment|/* src_mask */
literal|0x00ff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit PC-relative relocation.  */
name|HOWTO
argument_list|(
name|R_CRIS_16_PCREL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|cris_elf_pcrel_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRIS_16_PCREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x00000000
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32 bit PC-relative relocation.  */
name|HOWTO
argument_list|(
name|R_CRIS_32_PCREL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|cris_elf_pcrel_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRIS_32_PCREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x00000000
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable hierarchy.  */
name|HOWTO
argument_list|(
name|R_CRIS_GNU_VTINHERIT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_CRIS_GNU_VTINHERIT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable member usage.  */
name|HOWTO
argument_list|(
name|R_CRIS_GNU_VTENTRY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_elf_rel_vtable_reloc_fn
argument_list|,
comment|/* special_function */
literal|"R_CRIS_GNU_VTENTRY"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* This is used only by the dynamic linker.  The symbol should exist      both in the object being run and in some shared library.  The      dynamic linker copies the data addressed by the symbol from the      shared library into the object, because the object being      run has to have the data at some particular address.  */
name|HOWTO
argument_list|(
name|R_CRIS_COPY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRIS_COPY"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_CRIS_32, but used when setting global offset table entries.  */
name|HOWTO
argument_list|(
name|R_CRIS_GLOB_DAT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRIS_GLOB_DAT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Marks a procedure linkage table entry for a symbol.  */
name|HOWTO
argument_list|(
name|R_CRIS_JUMP_SLOT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRIS_JUMP_SLOT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used only by the dynamic linker.  When the object is run, this      longword is set to the load address of the object, plus the      addend.  */
name|HOWTO
argument_list|(
name|R_CRIS_RELATIVE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRIS_RELATIVE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_CRIS_32, but referring to the GOT table entry for the symbol.  */
name|HOWTO
argument_list|(
name|R_CRIS_16_GOT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRIS_16_GOT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CRIS_32_GOT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRIS_32_GOT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_CRIS_32_GOT, but referring to (and requesting a) PLT part of      the GOT table for the symbol.  */
name|HOWTO
argument_list|(
name|R_CRIS_16_GOTPLT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRIS_16_GOTPLT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CRIS_32_GOTPLT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRIS_32_GOTPLT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32-bit offset from GOT to (local const) symbol: no GOT entry should      be necessary.  */
name|HOWTO
argument_list|(
name|R_CRIS_32_GOTREL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRIS_32_GOTREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32-bit offset from GOT to entry for this symbol in PLT and request      to create PLT entry for symbol.  */
name|HOWTO
argument_list|(
name|R_CRIS_32_PLT_GOTREL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRIS_32_PLT_GOTREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32-bit offset from PC (location after the relocation) + addend to      entry for this symbol in PLT and request to create PLT entry for      symbol.  */
name|HOWTO
argument_list|(
argument|R_CRIS_32_PLT_PCREL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
argument|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
argument|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
argument|cris_elf_pcrel_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRIS_32_PLT_PCREL"
argument_list|,
comment|/* name */
argument|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
argument|TRUE
argument_list|)
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Map BFD reloc types to CRIS ELF reloc types.  */
end_comment

begin_struct
struct|struct
name|cris_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_val
decl_stmt|;
name|unsigned
name|int
name|cris_reloc_val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|cris_reloc_map
name|cris_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_CRIS_NONE
block|}
block|,
block|{
name|BFD_RELOC_8
block|,
name|R_CRIS_8
block|}
block|,
block|{
name|BFD_RELOC_16
block|,
name|R_CRIS_16
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_CRIS_32
block|}
block|,
block|{
name|BFD_RELOC_8_PCREL
block|,
name|R_CRIS_8_PCREL
block|}
block|,
block|{
name|BFD_RELOC_16_PCREL
block|,
name|R_CRIS_16_PCREL
block|}
block|,
block|{
name|BFD_RELOC_32_PCREL
block|,
name|R_CRIS_32_PCREL
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_INHERIT
block|,
name|R_CRIS_GNU_VTINHERIT
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_ENTRY
block|,
name|R_CRIS_GNU_VTENTRY
block|}
block|,
block|{
name|BFD_RELOC_CRIS_COPY
block|,
name|R_CRIS_COPY
block|}
block|,
block|{
name|BFD_RELOC_CRIS_GLOB_DAT
block|,
name|R_CRIS_GLOB_DAT
block|}
block|,
block|{
name|BFD_RELOC_CRIS_JUMP_SLOT
block|,
name|R_CRIS_JUMP_SLOT
block|}
block|,
block|{
name|BFD_RELOC_CRIS_RELATIVE
block|,
name|R_CRIS_RELATIVE
block|}
block|,
block|{
name|BFD_RELOC_CRIS_16_GOT
block|,
name|R_CRIS_16_GOT
block|}
block|,
block|{
name|BFD_RELOC_CRIS_32_GOT
block|,
name|R_CRIS_32_GOT
block|}
block|,
block|{
name|BFD_RELOC_CRIS_16_GOTPLT
block|,
name|R_CRIS_16_GOTPLT
block|}
block|,
block|{
name|BFD_RELOC_CRIS_32_GOTPLT
block|,
name|R_CRIS_32_GOTPLT
block|}
block|,
block|{
name|BFD_RELOC_CRIS_32_GOTREL
block|,
name|R_CRIS_32_GOTREL
block|}
block|,
block|{
name|BFD_RELOC_CRIS_32_PLT_GOTREL
block|,
name|R_CRIS_32_PLT_GOTREL
block|}
block|,
block|{
name|BFD_RELOC_CRIS_32_PLT_PCREL
block|,
name|R_CRIS_32_PLT_PCREL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|cris_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|cris_reloc_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|cris_reloc_map
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cris_reloc_map
index|[
name|i
index|]
operator|.
name|bfd_reloc_val
operator|==
name|code
condition|)
return|return
operator|&
name|cris_elf_howto_table
index|[
name|cris_reloc_map
index|[
name|i
index|]
operator|.
name|cris_reloc_val
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set the howto pointer for an CRIS ELF reloc.  */
end_comment

begin_function
specifier|static
name|void
name|cris_info_to_howto_rela
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r_type
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_CRIS_max
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|cris_elf_howto_table
index|[
name|r_type
index|]
expr_stmt|;
block|}
end_function

begin_function
name|bfd_reloc_status_type
name|cris_elf_pcrel_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* By default (using only bfd_elf_generic_reloc when linking to      non-ELF formats) PC-relative relocs are relative to the beginning      of the reloc.  CRIS PC-relative relocs are relative to the position      *after* the reloc because that's what pre-CRISv32 PC points to      after reading an insn field with that reloc.  (For CRISv32, PC is      actually relative to the start of the insn, but we keep the old      definition.)  Still, we use as much generic machinery as we can.       Only adjust when doing a final link.  */
if|if
condition|(
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
name|reloc_entry
operator|->
name|addend
operator|-=
literal|1
operator|<<
name|reloc_entry
operator|->
name|howto
operator|->
name|size
expr_stmt|;
return|return
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Support for core dump NOTE sections.    The slightly unintuitive code layout is an attempt to keep at least    some similarities with other ports, hoping to simplify general    changes, while still keeping Linux/CRIS and Linux/CRISv32 code apart.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|cris_elf_grok_prstatus
parameter_list|(
name|abfd
parameter_list|,
name|note
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Note
modifier|*
name|note
decl_stmt|;
block|{
name|int
name|offset
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_mach_cris_v32
condition|)
switch|switch
condition|(
name|note
operator|->
name|descsz
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
literal|202
case|:
comment|/* Linux/CRISv32 */
comment|/* pr_cursig */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* pr_pid */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_pid
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|22
argument_list|)
expr_stmt|;
comment|/* pr_reg */
name|offset
operator|=
literal|70
expr_stmt|;
name|size
operator|=
literal|128
expr_stmt|;
break|break;
block|}
else|else
switch|switch
condition|(
name|note
operator|->
name|descsz
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
literal|214
case|:
comment|/* Linux/CRIS */
comment|/* pr_cursig */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* pr_pid */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_pid
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|22
argument_list|)
expr_stmt|;
comment|/* pr_reg */
name|offset
operator|=
literal|70
expr_stmt|;
name|size
operator|=
literal|140
expr_stmt|;
break|break;
block|}
comment|/* Make a ".reg/999" section.  */
return|return
name|_bfd_elfcore_make_pseudosection
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|,
name|size
argument_list|,
name|note
operator|->
name|descpos
operator|+
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|cris_elf_grok_psinfo
parameter_list|(
name|abfd
parameter_list|,
name|note
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Note
modifier|*
name|note
decl_stmt|;
block|{
if|if
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_mach_cris_v32
condition|)
switch|switch
condition|(
name|note
operator|->
name|descsz
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
literal|124
case|:
comment|/* Linux/CRISv32 elf_prpsinfo */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_program
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|28
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|44
argument_list|,
literal|80
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|note
operator|->
name|descsz
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
literal|124
case|:
comment|/* Linux/CRIS elf_prpsinfo */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_program
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|28
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|44
argument_list|,
literal|80
argument_list|)
expr_stmt|;
block|}
comment|/* Note that for some reason, a spurious space is tacked      onto the end of the args in some (at least one anyway)      implementations, so strip it off if it exists.  */
block|{
name|char
modifier|*
name|command
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
decl_stmt|;
name|int
name|n
init|=
name|strlen
argument_list|(
name|command
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|n
operator|&&
name|command
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|command
index|[
name|n
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The name of the dynamic interpreter.  This is put in the .interp    section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/lib/ld.so.1"
end_define

begin_comment
comment|/* The size in bytes of an entry in the procedure linkage table.  */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_SIZE
value|20
end_define

begin_define
define|#
directive|define
name|PLT_ENTRY_SIZE_V32
value|26
end_define

begin_comment
comment|/* The first entry in an absolute procedure linkage table looks like this.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_cris_plt0_entry
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0xfc
block|,
literal|0xe1
block|,
literal|0x7e
block|,
literal|0x7e
block|,
comment|/* push mof.  */
literal|0x7f
block|,
literal|0x0d
block|,
comment|/*  (dip [pc+]) */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*  Replaced with address of .got + 4.  */
literal|0x30
block|,
literal|0x7a
block|,
comment|/* move [...],mof */
literal|0x7f
block|,
literal|0x0d
block|,
comment|/*  (dip [pc+]) */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*  Replaced with address of .got + 8.  */
literal|0x30
block|,
literal|0x09
comment|/* jump [...] */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_cris_plt0_entry_v32
index|[
name|PLT_ENTRY_SIZE_V32
index|]
init|=
block|{
literal|0x84
block|,
literal|0xe2
block|,
comment|/* subq 4,$sp */
literal|0x6f
block|,
literal|0xfe
block|,
comment|/* move.d 0,$acr */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*  Replaced by address of .got + 4.  */
literal|0x7e
block|,
literal|0x7a
block|,
comment|/* move $mof,[$sp] */
literal|0x3f
block|,
literal|0x7a
block|,
comment|/* move [$acr],$mof */
literal|0x04
block|,
literal|0xf2
block|,
comment|/* addq 4,acr */
literal|0x6f
block|,
literal|0xfa
block|,
comment|/* move.d [$acr],$acr */
literal|0xbf
block|,
literal|0x09
block|,
comment|/* jump $acr */
literal|0xb0
block|,
literal|0x05
block|,
comment|/* nop */
literal|0
block|,
literal|0
comment|/*  Pad out to 26 bytes.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subsequent entries in an absolute procedure linkage table look like    this.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_cris_plt_entry
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0x7f
block|,
literal|0x0d
block|,
comment|/*  (dip [pc+]) */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*  Replaced with address of this symbol in .got.  */
literal|0x30
block|,
literal|0x09
block|,
comment|/* jump [...] */
literal|0x3f
block|,
literal|0x7e
block|,
comment|/* move [pc+],mof */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*  Replaced with offset into relocation table.  */
literal|0x2f
block|,
literal|0xfe
block|,
comment|/* add.d [pc+],pc */
literal|0xec
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
comment|/*  Replaced with offset to start of .plt.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_cris_plt_entry_v32
index|[
name|PLT_ENTRY_SIZE_V32
index|]
init|=
block|{
literal|0x6f
block|,
literal|0xfe
block|,
comment|/* move.d 0,$acr */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*  Replaced with address of this symbol in .got.  */
literal|0x6f
block|,
literal|0xfa
block|,
comment|/* move.d [$acr],$acr */
literal|0xbf
block|,
literal|0x09
block|,
comment|/* jump $acr */
literal|0xb0
block|,
literal|0x05
block|,
comment|/* nop */
literal|0x3f
block|,
literal|0x7e
block|,
comment|/* move 0,mof */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*  Replaced with offset into relocation table. */
literal|0xbf
block|,
literal|0x0e
block|,
comment|/* ba start_of_plt0_entry */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*  Replaced with offset to plt0 entry.  */
literal|0xb0
block|,
literal|0x05
comment|/* nop */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The first entry in a PIC procedure linkage table looks like this.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_cris_pic_plt0_entry
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0xfc
block|,
literal|0xe1
block|,
literal|0x7e
block|,
literal|0x7e
block|,
comment|/* push mof */
literal|0x04
block|,
literal|0x01
block|,
literal|0x30
block|,
literal|0x7a
block|,
comment|/* move [r0+4],mof */
literal|0x08
block|,
literal|0x01
block|,
literal|0x30
block|,
literal|0x09
block|,
comment|/* jump [r0+8] */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*  Pad out to 20 bytes.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_cris_pic_plt0_entry_v32
index|[
name|PLT_ENTRY_SIZE_V32
index|]
init|=
block|{
literal|0x84
block|,
literal|0xe2
block|,
comment|/* subq 4,$sp */
literal|0x04
block|,
literal|0x01
block|,
comment|/* addoq 4,$r0,$acr */
literal|0x7e
block|,
literal|0x7a
block|,
comment|/* move $mof,[$sp] */
literal|0x3f
block|,
literal|0x7a
block|,
comment|/* move [$acr],$mof */
literal|0x04
block|,
literal|0xf2
block|,
comment|/* addq 4,$acr */
literal|0x6f
block|,
literal|0xfa
block|,
comment|/* move.d [$acr],$acr */
literal|0xbf
block|,
literal|0x09
block|,
comment|/* jump $acr */
literal|0xb0
block|,
literal|0x05
block|,
comment|/* nop */
literal|0
block|,
literal|0
block|,
comment|/*  Pad out to 26 bytes.  */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subsequent entries in a PIC procedure linkage table look like this.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_cris_pic_plt_entry
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0x6f
block|,
literal|0x0d
block|,
comment|/*  (bdap [pc+].d,r0) */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*  Replaced with offset of this symbol in .got.  */
literal|0x30
block|,
literal|0x09
block|,
comment|/* jump [...] */
literal|0x3f
block|,
literal|0x7e
block|,
comment|/* move [pc+],mof */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*  Replaced with offset into relocation table.  */
literal|0x2f
block|,
literal|0xfe
block|,
comment|/* add.d [pc+],pc */
literal|0xec
block|,
literal|0xff
block|,
comment|/*  Replaced with offset to start of .plt.  */
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_cris_pic_plt_entry_v32
index|[
name|PLT_ENTRY_SIZE_V32
index|]
init|=
block|{
literal|0x6f
block|,
literal|0x0d
block|,
comment|/* addo.d 0,$r0,$acr */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*  Replaced with offset of this symbol in .got.  */
literal|0x6f
block|,
literal|0xfa
block|,
comment|/* move.d [$acr],$acr */
literal|0xbf
block|,
literal|0x09
block|,
comment|/* jump $acr */
literal|0xb0
block|,
literal|0x05
block|,
comment|/* nop */
literal|0x3f
block|,
literal|0x7e
block|,
comment|/* move relocoffs,$mof */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*  Replaced with offset into relocation table.  */
literal|0xbf
block|,
literal|0x0e
block|,
comment|/* ba start_of_plt */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*  Replaced with offset to start of .plt.  */
literal|0xb0
block|,
literal|0x05
comment|/* nop */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* We copy elf32-m68k.c and elf32-i386.c for the basic linker hash bits    (and most other PIC/shlib stuff).  Check that we don't drift away    without reason.     The CRIS linker, like the m68k and i386 linkers (and probably the rest    too) needs to keep track of the number of relocs that it decides to    copy in check_relocs for each symbol.  This is so that it can discard    PC relative relocs if it doesn't need them when linking with    -Bsymbolic.  We store the information in a field extending the regular    ELF linker hash table.  */
end_comment

begin_comment
comment|/* This structure keeps track of the number of PC relative relocs we have    copied for a given symbol.  */
end_comment

begin_struct
struct|struct
name|elf_cris_pcrel_relocs_copied
block|{
comment|/* Next section.  */
name|struct
name|elf_cris_pcrel_relocs_copied
modifier|*
name|next
decl_stmt|;
comment|/* A section in dynobj.  */
name|asection
modifier|*
name|section
decl_stmt|;
comment|/* Number of relocs copied in this section.  */
name|bfd_size_type
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* CRIS ELF linker hash entry.  */
end_comment

begin_struct
struct|struct
name|elf_cris_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|root
decl_stmt|;
comment|/* Number of PC relative relocs copied for this symbol.  */
name|struct
name|elf_cris_pcrel_relocs_copied
modifier|*
name|pcrel_relocs_copied
decl_stmt|;
comment|/* The GOTPLT references are CRIS-specific; the goal is to avoid having      both a general GOT and a PLT-specific GOT entry for the same symbol,      when it is referenced both as a function and as a function pointer.       Number of GOTPLT references for a function.  */
name|bfd_signed_vma
name|gotplt_refcount
decl_stmt|;
comment|/* Actual GOTPLT index for this symbol, if applicable, or zero if not      (zero is never used as an index).  FIXME: We should be able to fold      this with gotplt_refcount in a union, like the got and plt unions in      elf_link_hash_entry.  */
name|bfd_size_type
name|gotplt_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* CRIS ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|elf_cris_link_hash_table
block|{
name|struct
name|elf_link_hash_table
name|root
decl_stmt|;
comment|/* We can't use the PLT offset and calculate to get the GOTPLT offset,      since we try and avoid creating GOTPLT:s when there's already a GOT.      Instead, we keep and update the next available index here.  */
name|bfd_size_type
name|next_gotplt_entry
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Traverse a CRIS ELF linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|elf_cris_link_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
define|\
value|(elf_link_hash_traverse						\    (&(table)->root,							\     (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func), \     (info)))
end_define

begin_comment
comment|/* Get the CRIS ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|elf_cris_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct elf_cris_link_hash_table *) (p)->hash)
end_define

begin_comment
comment|/* Create an entry in a CRIS ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|elf_cris_link_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|elf_cris_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|elf_cris_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|elf_cris_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elf_cris_link_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_cris_link_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|elf_cris_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elf_cris_link_hash_entry
operator|*
operator|)
name|_bfd_elf_link_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|(
expr|struct
name|elf_cris_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
block|{
name|ret
operator|->
name|pcrel_relocs_copied
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|gotplt_refcount
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|gotplt_offset
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Create a CRIS ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elf_cris_link_hash_table_create
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|elf_cris_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf_cris_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elf_cris_link_hash_table
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|elf_cris_link_hash_table
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|elf_cris_link_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_cris_link_hash_entry
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Initialize to skip over the first three entries in the gotplt; they      are used for run-time symbol evaluation.  */
name|ret
operator|->
name|next_gotplt_entry
operator|=
literal|12
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform a single relocation.  By default we use the standard BFD    routines, with a few tweaks.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|cris_final_link_relocate
parameter_list|(
name|howto
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|rel
parameter_list|,
name|relocation
parameter_list|)
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
block|{
name|bfd_reloc_status_type
name|r
decl_stmt|;
comment|/* PC-relative relocations are relative to the position *after*      the reloc.  Note that for R_CRIS_8_PCREL the adjustment is      not a single byte, since PC must be 16-bit-aligned.  */
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
comment|/* Check that the 16-bit GOT relocs are positive.  */
case|case
name|R_CRIS_16_GOTPLT
case|:
case|case
name|R_CRIS_16_GOT
case|:
if|if
condition|(
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|<
literal|0
condition|)
return|return
name|bfd_reloc_overflow
return|;
break|break;
case|case
name|R_CRIS_32_PLT_PCREL
case|:
case|case
name|R_CRIS_32_PCREL
case|:
name|relocation
operator|-=
literal|2
expr_stmt|;
comment|/* Fall through.  */
case|case
name|R_CRIS_8_PCREL
case|:
case|case
name|R_CRIS_16_PCREL
case|:
name|relocation
operator|-=
literal|2
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Relocate an CRIS ELF section.  See elf32-fr30.c, from where this was    copied, for further comments.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|cris_elf_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
name|sgot
operator|=
name|NULL
expr_stmt|;
name|splt
operator|=
name|NULL
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dynobj
operator|!=
name|NULL
condition|)
block|{
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|symname
init|=
name|NULL
decl_stmt|;
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_CRIS_GNU_VTINHERIT
operator|||
name|r_type
operator|==
name|R_CRIS_GNU_VTENTRY
condition|)
continue|continue;
comment|/* This is a final link.  */
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|howto
operator|=
name|cris_elf_howto_table
operator|+
name|r_type
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|symname
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|symname
operator|==
name|NULL
condition|)
name|symname
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_boolean
name|warned
decl_stmt|;
name|bfd_boolean
name|unresolved_reloc
decl_stmt|;
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
if|if
condition|(
name|unresolved_reloc
comment|/* Perhaps we should detect the cases that 		 sec->output_section is expected to be NULL like i386 and 		 m68k, but apparently (and according to elfxx-ia64.c) all 		 valid cases are where the symbol is defined in a shared 		 object which we link dynamically against.  This includes 		 PLT relocs for which we've created a PLT entry and other 		 relocs for which we're prepared to create dynamic 		 relocations.  		 For now, new situations cause us to just err when 		 sec->output_offset is NULL but the object with the symbol 		 is *not* dynamically linked against.  Thus this will 		 automatically remind us so we can see if there are other 		 valid cases we need to revisit.  */
operator|&&
operator|(
name|sec
operator|->
name|owner
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
comment|/* Here follow the cases where the relocation value must 		 be zero (or when further handling is simplified when 		 zero).  I can't claim to understand the various 		 conditions and they weren't described in the files 		 where I copied them from (elf32-m68k.c and 		 elf32-i386.c), but let's mention examples of where 		 they happen.  FIXME: Perhaps define and use a 		 dynamic_symbol_p function like ia64.  		 - When creating a shared library, we can have an 		 ordinary relocation for a symbol defined in a shared 		 library (perhaps the one we create).  We then make 		 the relocation value zero, as the value seen now will 		 be added into the relocation addend in this shared 		 library, but must be handled only at dynamic-link 		 time.  FIXME: Not sure this example covers the 		 h->elf_link_hash_flags test, though it's there in 		 other targets.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|)
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|r_type
operator|==
name|R_CRIS_8
operator|||
name|r_type
operator|==
name|R_CRIS_16
operator|||
name|r_type
operator|==
name|R_CRIS_32
operator|||
name|r_type
operator|==
name|R_CRIS_8_PCREL
operator|||
name|r_type
operator|==
name|R_CRIS_16_PCREL
operator|||
name|r_type
operator|==
name|R_CRIS_32_PCREL
operator|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|unresolved_reloc
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"%B, section %A: unresolvable relocation %s against symbol `%s'"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|cris_elf_howto_table
index|[
name|r_type
index|]
operator|.
name|name
argument_list|,
name|symname
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_CRIS_16_GOTPLT
case|:
case|case
name|R_CRIS_32_GOTPLT
case|:
comment|/* This is like the case for R_CRIS_32_GOT and R_CRIS_16_GOT, 	     but we require a PLT, and the PLT handling will take care of 	     filling in the PLT-specific GOT entry.  For the GOT offset, 	     calculate it as we do when filling it in for the .got.plt 	     section.  If we don't have a PLT, punt to GOT handling.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|(
expr|struct
name|elf_cris_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|gotplt_offset
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|sgotplt
init|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
decl_stmt|;
name|bfd_vma
name|got_offset
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgotplt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|got_offset
operator|=
operator|(
operator|(
expr|struct
name|elf_cris_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|gotplt_offset
expr_stmt|;
name|relocation
operator|=
name|got_offset
expr_stmt|;
break|break;
block|}
comment|/* We didn't make a PLT entry for this symbol.  Maybe everything is 	     folded into the GOT.  Other than folding, this happens when 	     statically linking PIC code, or when using -Bsymbolic.  Check 	     that we instead have a GOT entry as done for us by 	     elf_cris_adjust_dynamic_symbol, and drop through into the 	     ordinary GOT cases.  This must not happen for the 	     executable, because any reference it does to a function 	     that is satisfied by a DSO must generate a PLT.  We assume 	     these call-specific relocs don't address non-functions.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
operator|(
name|h
operator|->
name|def_regular
operator|||
operator|(
operator|!
name|h
operator|->
name|def_dynamic
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|)
condition|?
name|_
argument_list|(
literal|"%B, section %A: No PLT nor GOT for relocation %s"
literal|" against symbol `%s'"
argument_list|)
else|:
name|_
argument_list|(
literal|"%B, section %A: No PLT for relocation %s"
literal|" against symbol `%s'"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|cris_elf_howto_table
index|[
name|r_type
index|]
operator|.
name|name
argument_list|,
operator|(
name|symname
operator|!=
name|NULL
operator|&&
name|symname
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|?
name|symname
else|:
name|_
argument_list|(
literal|"[whose name is lost]"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* FIXME: Perhaps blaming input is not the right thing to 		 do; this is probably an internal error.  But it is true 		 that we didn't like that particular input.  */
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Fall through.  */
comment|/* The size of the actual relocation is not used here; we only 	     fill in the GOT table here.  */
case|case
name|R_CRIS_16_GOT
case|:
case|case
name|R_CRIS_32_GOT
case|:
block|{
name|bfd_vma
name|off
decl_stmt|;
comment|/* Note that despite using RELA relocations, the .got contents 	       is always filled in with the link-relative relocation 	       value; the addend.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|off
operator|=
name|h
operator|->
name|got
operator|.
name|offset
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|off
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|->
name|def_regular
operator|||
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|||
name|h
operator|->
name|needs_plt
operator|)
operator|)
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|)
operator|&&
name|h
operator|->
name|def_regular
operator|)
condition|)
block|{
comment|/* This wasn't checked above for ! info->shared, but 		       must hold there if we get here; the symbol must 		       be defined in the regular program or be undefweak 		       or be a function or otherwise need a PLT.  */
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|||
name|info
operator|->
name|shared
operator|||
name|h
operator|->
name|def_regular
operator|||
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|||
name|h
operator|->
name|needs_plt
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
argument_list|)
expr_stmt|;
comment|/* This is actually a static link, or it is a 		       -Bsymbolic link and the symbol is defined locally, 		       or is undefweak, or the symbol was forced to be 		       local because of a version file, or we're not 		       creating a dynamic object.  We must initialize this 		       entry in the global offset table.  Since the offset 		       must always be a multiple of 4, we use the least 		       significant bit to record whether we have 		       initialized it already.  		       If this GOT entry should be runtime-initialized, we 		       will create a .rela.got relocation entry to 		       initialize the value.  This is done in the 		       finish_dynamic_symbol routine.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|offset
operator||=
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|local_got_offsets
operator|!=
name|NULL
operator|&&
name|local_got_offsets
index|[
name|r_symndx
index|]
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|off
operator|=
name|local_got_offsets
index|[
name|r_symndx
index|]
expr_stmt|;
comment|/* The offset must always be a multiple of 4.  We use 		   the least significant bit to record whether we have 		   already generated the necessary reloc.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_CRIS_RELATIVE
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
expr_stmt|;
name|loc
operator|=
name|s
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|s
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
name|local_got_offsets
index|[
name|r_symndx
index|]
operator||=
literal|1
expr_stmt|;
block|}
block|}
name|relocation
operator|=
name|sgot
operator|->
name|output_offset
operator|+
name|off
expr_stmt|;
if|if
condition|(
name|rel
operator|->
name|r_addend
operator|!=
literal|0
condition|)
block|{
comment|/* We can't do anything for a relocation which is against 		   a symbol *plus offset*.  GOT holds relocations for 		   symbols.  Make this an error; the compiler isn't 		   allowed to pass us these kinds of things.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B, section %A: relocation %s with non-zero addend %d"
literal|" against local symbol"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|cris_elf_howto_table
index|[
name|r_type
index|]
operator|.
name|name
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B, section %A: relocation %s with non-zero addend %d"
literal|" against symbol `%s'"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|cris_elf_howto_table
index|[
name|r_type
index|]
operator|.
name|name
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|symname
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|?
name|symname
else|:
name|_
argument_list|(
literal|"[whose name is lost]"
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
break|break;
case|case
name|R_CRIS_32_GOTREL
case|:
comment|/* This relocation must only be performed against local symbols. 	     It's also ok when we link a program and the symbol is either 	     defined in an ordinary (non-DSO) object or is undefined weak.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|&&
operator|!
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|->
name|def_regular
operator|||
operator|(
operator|!
name|h
operator|->
name|def_dynamic
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
operator|)
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B, section %A: relocation %s is"
literal|" not allowed for global symbol: `%s'"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|cris_elf_howto_table
index|[
name|r_type
index|]
operator|.
name|name
argument_list|,
name|symname
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* This can happen if we get a link error with the input ELF 	     variant mismatching the output variant.  Emit an error so 	     it's noticed if it happens elsewhere.  */
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B, section %A: relocation %s with no GOT created"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|cris_elf_howto_table
index|[
name|r_type
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* This relocation is like a PC-relative one, except the 	     reference point is the location of GOT.  Note that 	     sgot->output_offset is not involved in this calculation.  We 	     always want the start of entire .got section, not the 	     position after the reserved header.  */
name|relocation
operator|-=
name|sgot
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|R_CRIS_32_PLT_PCREL
case|:
comment|/* Relocation is to the entry for this symbol in the 	     procedure linkage table.  */
comment|/* Resolve a PLT_PCREL reloc against a local symbol directly, 	     without using the procedure linkage table.  */
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_DEFAULT
condition|)
break|break;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|||
name|splt
operator|==
name|NULL
condition|)
block|{
comment|/* We didn't make a PLT entry for this symbol.  This 		 happens when statically linking PIC code, or when 		 using -Bsymbolic.  */
break|break;
block|}
name|relocation
operator|=
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
break|break;
case|case
name|R_CRIS_32_PLT_GOTREL
case|:
comment|/* Like R_CRIS_32_PLT_PCREL, but the reference point is the 	     start of the .got section.  See also comment at 	     R_CRIS_32_GOT.  */
name|relocation
operator|-=
name|sgot
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
comment|/* Resolve a PLT_GOTREL reloc against a local symbol directly, 	     without using the procedure linkage table.  */
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_DEFAULT
condition|)
break|break;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|||
name|splt
operator|==
name|NULL
condition|)
block|{
comment|/* We didn't make a PLT entry for this symbol.  This 		 happens when statically linking PIC code, or when 		 using -Bsymbolic.  */
break|break;
block|}
name|relocation
operator|=
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|-
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
break|break;
case|case
name|R_CRIS_8_PCREL
case|:
case|case
name|R_CRIS_16_PCREL
case|:
case|case
name|R_CRIS_32_PCREL
case|:
comment|/* If the symbol was local, we need no shlib-specific handling.  */
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_DEFAULT
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|R_CRIS_8
case|:
case|case
name|R_CRIS_16
case|:
case|case
name|R_CRIS_32
case|:
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
name|r_symndx
operator|!=
literal|0
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|r_type
operator|!=
name|R_CRIS_8_PCREL
operator|&&
name|r_type
operator|!=
name|R_CRIS_16_PCREL
operator|&&
name|r_type
operator|!=
name|R_CRIS_32_PCREL
operator|)
operator|||
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_boolean
name|skip
decl_stmt|,
name|relocate
decl_stmt|;
comment|/* When generating a shared object, these relocations 		 are copied into the output file to be resolved at run 		 time.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|elf_elfheader
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|BFD_ASSERT
argument_list|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* That section should have been created in 		     cris_elf_check_relocs, but that function will not be 		     called for objects which fail in 		     cris_elf_merge_private_bfd_data.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: Internal inconsistency; no relocation section %s"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|skip
operator|=
name|FALSE
expr_stmt|;
name|relocate
operator|=
name|FALSE
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|skip
operator|=
name|TRUE
operator|,
name|relocate
operator|=
name|TRUE
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|outrel
argument_list|)
expr_stmt|;
comment|/* h->dynindx may be -1 if the symbol was marked to 		 become local.  */
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|)
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|r_type
operator|==
name|R_CRIS_32
condition|)
block|{
name|relocate
operator|=
name|TRUE
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_CRIS_RELATIVE
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
else|else
block|{
name|long
name|indx
decl_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
condition|)
name|indx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
name|sec
operator|->
name|owner
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|asection
modifier|*
name|osec
decl_stmt|;
name|osec
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
name|indx
operator|=
name|elf_section_data
argument_list|(
name|osec
argument_list|)
operator|->
name|dynindx
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|indx
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
block|}
name|loc
operator|=
name|sreloc
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|sreloc
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
comment|/* This reloc will be computed at runtime, so there's no                  need to do anything now, except for R_CRIS_32 relocations                  that have been turned into R_CRIS_RELATIVE.  */
if|if
condition|(
operator|!
name|relocate
condition|)
continue|continue;
block|}
break|break;
block|}
name|r
operator|=
name|cris_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_overflow
case|:
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
argument_list|(
name|info
argument_list|,
operator|(
name|h
condition|?
operator|&
name|h
operator|->
name|root
else|:
name|NULL
operator|)
argument_list|,
name|symname
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_undefined
case|:
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
argument_list|(
name|info
argument_list|,
name|symname
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: out of range error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_notsupported
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unsupported relocation error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_dangerous
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: dangerous relocation"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unknown error"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|msg
condition|)
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|msg
argument_list|,
name|symname
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_cris_finish_dynamic_symbol
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
comment|/* Where in the plt entry to put values.  */
name|int
name|plt_off1
init|=
literal|2
decl_stmt|,
name|plt_off2
init|=
literal|10
decl_stmt|,
name|plt_off3
init|=
literal|16
decl_stmt|;
comment|/* What offset to add to the distance to the first PLT entry for the      value at plt_off3.   */
name|int
name|plt_off3_value_bias
init|=
literal|4
decl_stmt|;
comment|/* Where in the PLT entry the call-dynlink-stub is (happens to be same      for PIC and non-PIC for v32 and pre-v32).  */
name|int
name|plt_stub_offset
init|=
literal|8
decl_stmt|;
name|int
name|plt_entry_size
init|=
name|PLT_ENTRY_SIZE
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
name|plt_entry
init|=
name|elf_cris_plt_entry
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
name|plt_pic_entry
init|=
name|elf_cris_pic_plt_entry
decl_stmt|;
comment|/* Adjust the various PLT entry offsets.  */
if|if
condition|(
name|bfd_get_mach
argument_list|(
name|output_bfd
argument_list|)
operator|==
name|bfd_mach_cris_v32
condition|)
block|{
name|plt_off2
operator|=
literal|14
expr_stmt|;
name|plt_off3
operator|=
literal|20
expr_stmt|;
name|plt_off3_value_bias
operator|=
operator|-
literal|2
expr_stmt|;
name|plt_stub_offset
operator|=
literal|12
expr_stmt|;
name|plt_entry_size
operator|=
name|PLT_ENTRY_SIZE_V32
expr_stmt|;
name|plt_entry
operator|=
name|elf_cris_plt_entry_v32
expr_stmt|;
name|plt_pic_entry
operator|=
name|elf_cris_pic_plt_entry_v32
expr_stmt|;
block|}
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|sgotplt
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srela
decl_stmt|;
name|bfd_vma
name|got_base
decl_stmt|;
name|bfd_vma
name|gotplt_offset
init|=
operator|(
operator|(
expr|struct
name|elf_cris_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|gotplt_offset
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_boolean
name|has_gotplt
init|=
name|gotplt_offset
operator|!=
literal|0
decl_stmt|;
comment|/* Get the index in the procedure linkage table which 	 corresponds to this symbol.  This is the index of this symbol 	 in all the symbols for which we are making plt entries.  The 	 first entry in the procedure linkage table is reserved.  */
comment|/* We have to count backwards here, and the result is only valid as 	 an index into .got.plt and its relocations.  FIXME: Constants...  */
name|bfd_vma
name|gotplt_index
init|=
name|gotplt_offset
operator|/
literal|4
operator|-
literal|3
decl_stmt|;
comment|/* Get the offset into the .got table of the entry that corresponds 	 to this function.  Note that we embed knowledge that "incoming" 	 .got goes after .got.plt in the output without padding (pointer 	 aligned).  However, that knowledge is present in several other 	 places too.  */
name|bfd_vma
name|got_offset
init|=
operator|(
name|has_gotplt
condition|?
name|gotplt_offset
else|:
name|h
operator|->
name|got
operator|.
name|offset
operator|+
name|elf_cris_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|next_gotplt_entry
operator|)
decl_stmt|;
comment|/* This symbol has an entry in the procedure linkage table.  Set it 	 up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|sgotplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
name|srela
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|sgotplt
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|has_gotplt
operator|||
name|srela
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|got_base
operator|=
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgotplt
operator|->
name|output_offset
expr_stmt|;
comment|/* Fill in the entry in the procedure linkage table.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|,
name|plt_entry
argument_list|,
name|plt_entry_size
argument_list|)
expr_stmt|;
comment|/* We need to enter the absolute address of the GOT entry here.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|got_base
operator|+
name|got_offset
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|plt_off1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|,
name|plt_pic_entry
argument_list|,
name|plt_entry_size
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|got_offset
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|plt_off1
argument_list|)
expr_stmt|;
block|}
comment|/* Fill in the plt entry and make a relocation, if this is a "real" 	 PLT entry.  */
if|if
condition|(
name|has_gotplt
condition|)
block|{
comment|/* Fill in the offset to the reloc table.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|gotplt_index
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|plt_off2
argument_list|)
expr_stmt|;
comment|/* Fill in the offset to the first PLT entry, where to "jump".  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|-
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|plt_off3
operator|+
name|plt_off3_value_bias
operator|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|plt_off3
argument_list|)
expr_stmt|;
comment|/* Fill in the entry in the global offset table with the address of 	     the relocating stub.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|plt_stub_offset
operator|)
argument_list|,
name|sgotplt
operator|->
name|contents
operator|+
name|got_offset
argument_list|)
expr_stmt|;
comment|/* Fill in the entry in the .rela.plt section.  */
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgotplt
operator|->
name|output_offset
operator|+
name|got_offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_CRIS_JUMP_SLOT
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
name|srela
operator|->
name|contents
operator|+
name|gotplt_index
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
comment|/* Mark the symbol as undefined, rather than as defined in 	     the .plt section.  Leave the value alone.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
comment|/* FIXME: From elf32-sparc.c 2001-02-19 (1.18).  I still don't 	     know whether resetting the value is significant; if it really 	     is, rather than a quirk or bug in the sparc port, then I 	     believe we'd see this elsewhere.  */
comment|/* If the symbol is weak, we do need to clear the value. 	     Otherwise, the PLT entry would provide a definition for 	     the symbol even if the symbol wasn't defined anywhere, 	     and so the symbol would never be NULL.  */
if|if
condition|(
operator|!
name|h
operator|->
name|ref_regular_nonweak
condition|)
name|sym
operator|->
name|st_value
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* For an ordinary program, we emit .got relocs only for symbols that      are in the dynamic-symbols table and are either defined by the      program or are undefined weak symbols, or are function symbols      where we do not output a PLT: the PLT reloc was output above and all      references to the function symbol are redirected to the PLT.  */
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
operator|(
name|info
operator|->
name|shared
operator|||
operator|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
name|h
operator|->
name|plt
operator|.
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|def_regular
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
operator|)
condition|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srela
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_byte
modifier|*
name|where
decl_stmt|;
comment|/* This symbol has an entry in the global offset table.  Set it up.  */
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|srela
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
operator|&&
name|srela
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* If this is a static link, or it is a -Bsymbolic link and the 	 symbol is defined locally or was forced to be local because 	 of a version file, we just want to emit a RELATIVE reloc. 	 The entry in the global offset table will already have been 	 initialized in the relocate_section function.  */
name|where
operator|=
name|sgot
operator|->
name|contents
operator|+
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|)
operator|&&
name|h
operator|->
name|def_regular
operator|)
condition|)
block|{
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_CRIS_RELATIVE
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
name|bfd_get_signed_32
argument_list|(
name|output_bfd
argument_list|,
name|where
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_CRIS_GLOB_DAT
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
name|loc
operator|=
name|srela
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|srela
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|needs_copy
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
comment|/* This symbol needs a copy reloc.  Set it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|,
literal|".rela.bss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_CRIS_COPY
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
name|s
operator|->
name|contents
operator|+
name|s
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
comment|/* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
name|h
operator|==
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hgot
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_cris_finish_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|Elf32_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_elf32_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
default|default:
break|break;
case|case
name|DT_PLTGOT
case|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_JMPREL
case|:
comment|/* Yes, we *can* have a .plt and no .plt.rela, for instance 		 if all symbols are found in the .got (not .got.plt).  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|!=
name|NULL
condition|?
name|s
operator|->
name|vma
else|:
literal|0
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
literal|0
expr_stmt|;
else|else
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|size
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_RELASZ
case|:
comment|/* The procedure linkage table relocs (DT_JMPREL) should 		 not be included in the overall relocs (DT_RELA). 		 Therefore, we override the DT_RELASZ entry here to 		 make it not include the JMPREL relocs.  Since the 		 linker script arranges for .rela.plt to follow all 		 other relocation sections, we don't have to worry 		 about changing the DT_RELA entry.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|-=
name|s
operator|->
name|size
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Fill in the first entry in the procedure linkage table.  */
if|if
condition|(
name|splt
operator|->
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bfd_get_mach
argument_list|(
name|output_bfd
argument_list|)
operator|==
name|bfd_mach_cris_v32
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
argument_list|,
name|elf_cris_pic_plt0_entry_v32
argument_list|,
name|PLT_ENTRY_SIZE_V32
argument_list|)
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
argument_list|,
name|elf_cris_plt0_entry_v32
argument_list|,
name|PLT_ENTRY_SIZE_V32
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
literal|4
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
name|elf_section_data
argument_list|(
name|splt
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
name|PLT_ENTRY_SIZE_V32
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
argument_list|,
name|elf_cris_pic_plt0_entry
argument_list|,
name|PLT_ENTRY_SIZE
argument_list|)
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
argument_list|,
name|elf_cris_plt0_entry
argument_list|,
name|PLT_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
literal|4
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|6
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
literal|8
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|14
argument_list|)
expr_stmt|;
name|elf_section_data
argument_list|(
name|splt
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
name|PLT_ENTRY_SIZE
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Fill in the first three entries in the global offset table.  */
if|if
condition|(
name|sgot
operator|->
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sdyn
operator|==
name|NULL
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
else|else
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sdyn
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sdyn
operator|->
name|output_offset
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
name|elf_section_data
argument_list|(
name|sgot
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|4
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the section that should be marked against GC for a given    relocation.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|cris_elf_gc_mark_hook
parameter_list|(
name|sec
parameter_list|,
name|info
parameter_list|,
name|rel
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_CRIS_GNU_VTINHERIT
case|:
case|case
name|R_CRIS_GNU_VTENTRY
case|:
break|break;
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
default|default:
break|break;
block|}
block|}
block|}
else|else
return|return
name|bfd_section_from_elf_index
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Update the got entry reference counts for the section being removed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|cris_elf_gc_sweep_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_CRIS_16_GOT
case|:
case|case
name|R_CRIS_32_GOT
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
operator|--
name|h
operator|->
name|got
operator|.
name|refcount
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|==
literal|0
condition|)
block|{
comment|/* We don't need the .got entry any more.  */
name|sgot
operator|->
name|size
operator|-=
literal|4
expr_stmt|;
name|srelgot
operator|->
name|size
operator|-=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
name|local_got_reloc
label|:
if|if
condition|(
name|local_got_refcounts
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|>
literal|0
condition|)
block|{
operator|--
name|local_got_refcounts
index|[
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|==
literal|0
condition|)
block|{
comment|/* We don't need the .got entry any more.  */
name|sgot
operator|->
name|size
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|srelgot
operator|->
name|size
operator|-=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|R_CRIS_16_GOTPLT
case|:
case|case
name|R_CRIS_32_GOTPLT
case|:
comment|/* For local symbols, treat these like GOT relocs.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
goto|goto
name|local_got_reloc
goto|;
comment|/* Fall through.  */
case|case
name|R_CRIS_32_PLT_GOTREL
case|:
comment|/* FIXME: We don't garbage-collect away the .got section.  */
if|if
condition|(
name|local_got_refcounts
operator|!=
name|NULL
condition|)
name|local_got_refcounts
index|[
operator|-
literal|1
index|]
operator|--
expr_stmt|;
comment|/* Fall through.  */
case|case
name|R_CRIS_8_PCREL
case|:
case|case
name|R_CRIS_16_PCREL
case|:
case|case
name|R_CRIS_32_PCREL
case|:
case|case
name|R_CRIS_32_PLT_PCREL
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|&&
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
operator|--
name|h
operator|->
name|plt
operator|.
name|refcount
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Make sure we emit a GOT entry if the symbol was supposed to have a PLT    entry but we found we will not create any.  Called when we find we will    not have any PLT for this symbol, by for example    elf_cris_adjust_dynamic_symbol when we're doing a proper dynamic link,    or elf_cris_size_dynamic_sections if no dynamic sections will be    created (we're only linking static objects).  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_cris_adjust_gotplt_to_got
parameter_list|(
name|h
parameter_list|,
name|p
parameter_list|)
name|struct
name|elf_cris_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|p
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_cris_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* If nobody wanted a GOTPLT with this symbol, we're done.  */
if|if
condition|(
name|h
operator|->
name|gotplt_refcount
operator|<=
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
comment|/* There's a GOT entry for this symbol.  Just adjust the refcount. 	 Probably not necessary at this stage, but keeping it accurate 	 helps avoiding surprises later.  */
name|h
operator|->
name|root
operator|.
name|got
operator|.
name|refcount
operator|+=
name|h
operator|->
name|gotplt_refcount
expr_stmt|;
name|h
operator|->
name|gotplt_refcount
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* No GOT entry for this symbol.  We need to create one.  */
name|bfd
modifier|*
name|dynobj
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
comment|/* Put an accurate refcount there.  */
name|h
operator|->
name|root
operator|.
name|got
operator|.
name|refcount
operator|=
name|h
operator|->
name|gotplt_refcount
expr_stmt|;
name|h
operator|->
name|gotplt_refcount
operator|=
literal|0
expr_stmt|;
comment|/* We always have a .got and a .rela.got section if there were 	 GOTPLT relocs in input.  */
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
operator|&&
name|srelgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Allocate space in the .got section.  */
name|sgot
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
comment|/* Allocate relocation space.  */
name|srelgot
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Try to fold PLT entries with GOT entries.  There are two cases when we    want to do this:     - When all PLT references are GOTPLT references, and there are GOT      references, and this is not the executable.  We don't have to      generate a PLT at all.     - When there are both (ordinary) PLT references and GOT references,      and this isn't the executable.      We want to make the PLT reference use the ordinary GOT entry rather      than R_CRIS_JUMP_SLOT, a run-time dynamically resolved GOTPLT entry,      since the GOT entry will have to be resolved at startup anyway.     Though the latter case is handled when room for the PLT is allocated,    not here.     By folding into the GOT, we may need a round-trip to a PLT in the    executable for calls, a loss in performance.  Still, losing a    reloc is a win in size and at least in start-up time.     Note that this function is called before symbols are forced local by    version scripts.  The differing cases are handled by    elf_cris_hide_symbol.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_cris_try_fold_plt_to_got
parameter_list|(
name|h
parameter_list|,
name|p
parameter_list|)
name|struct
name|elf_cris_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|p
decl_stmt|;
comment|/* If there are no GOT references for this symbol, we can't fold any      other reference so there's nothing to do.  Likewise if there are no      PLT references; GOTPLT references included.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|got
operator|.
name|refcount
operator|<=
literal|0
operator|||
name|h
operator|->
name|root
operator|.
name|plt
operator|.
name|refcount
operator|<=
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* GOTPLT relocs are supposed to be included into the PLT refcount.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|gotplt_refcount
operator|<=
name|h
operator|->
name|root
operator|.
name|plt
operator|.
name|refcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|gotplt_refcount
operator|==
name|h
operator|->
name|root
operator|.
name|plt
operator|.
name|refcount
condition|)
block|{
comment|/* The only PLT references are GOTPLT references, and there are GOT 	 references.  Convert PLT to GOT references.  */
if|if
condition|(
operator|!
name|elf_cris_adjust_gotplt_to_got
argument_list|(
name|h
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Clear the PLT references, so no PLT will be created.  */
name|h
operator|->
name|root
operator|.
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Our own version of hide_symbol, so that we can adjust a GOTPLT reloc    to use a GOT entry (and create one) rather than requiring a GOTPLT    entry.  */
end_comment

begin_function
specifier|static
name|void
name|elf_cris_hide_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|,
name|force_local
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_boolean
name|force_local
decl_stmt|;
block|{
name|elf_cris_adjust_gotplt_to_got
argument_list|(
operator|(
expr|struct
name|elf_cris_link_hash_entry
operator|*
operator|)
name|h
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|_bfd_elf_link_hash_hide_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|force_local
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_cris_adjust_dynamic_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|power_of_two
decl_stmt|;
name|bfd_size_type
name|plt_entry_size
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* Make sure we know what is going on here.  */
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|needs_plt
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
operator|||
operator|(
name|h
operator|->
name|def_dynamic
operator|&&
name|h
operator|->
name|ref_regular
operator|&&
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
argument_list|)
expr_stmt|;
name|plt_entry_size
operator|=
operator|(
name|bfd_get_mach
argument_list|(
name|dynobj
argument_list|)
operator|==
name|bfd_mach_cris_v32
condition|?
name|PLT_ENTRY_SIZE_V32
else|:
name|PLT_ENTRY_SIZE
operator|)
expr_stmt|;
comment|/* If this is a function, put it in the procedure linkage table.  We      will fill in the contents of the procedure linkage table later,      when we know the address of the .got section.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|||
name|h
operator|->
name|needs_plt
condition|)
block|{
comment|/* If we link a program (not a DSO), we'll get rid of unnecessary 	 PLT entries; we point to the actual symbols -- even for pic 	 relocs, because a program built with -fpic should have the same 	 result as one built without -fpic, specifically considering weak 	 symbols. 	 FIXME: m68k and i386 differ here, for unclear reasons.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|h
operator|->
name|def_dynamic
condition|)
block|{
comment|/* This case can occur if we saw a PLT reloc in an input file, 	     but the symbol was not defined by a dynamic object.  In such 	     a case, we don't actually need to build a procedure linkage 	     table, and we can just do an absolute or PC reloc instead, or 	     change a .got.plt index to a .got index for GOTPLT relocs.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|needs_plt
argument_list|)
expr_stmt|;
name|h
operator|->
name|needs_plt
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|elf_cris_adjust_gotplt_to_got
argument_list|(
operator|(
expr|struct
name|elf_cris_link_hash_entry
operator|*
operator|)
name|h
argument_list|,
name|info
argument_list|)
return|;
block|}
comment|/* If we had a R_CRIS_GLOB_DAT that didn't have to point to a PLT; 	 where a pointer-equivalent symbol was unimportant (i.e. more 	 like R_CRIS_JUMP_SLOT after symbol evaluation) we could get rid 	 of the PLT.  We can't for the executable, because the GOT 	 entries will point to the PLT there (and be constant).  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|elf_cris_try_fold_plt_to_got
argument_list|(
operator|(
expr|struct
name|elf_cris_link_hash_entry
operator|*
operator|)
name|h
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* GC or folding may have rendered this entry unused.  */
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|<=
literal|0
condition|)
block|{
name|h
operator|->
name|needs_plt
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Make sure this symbol is output as a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* If this is the first .plt entry, make room for the special 	 first entry.  */
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
name|s
operator|->
name|size
operator|+=
name|plt_entry_size
expr_stmt|;
comment|/* If this symbol is not defined in a regular file, and we are 	 not generating a shared library, then set the symbol to this 	 location in the .plt.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|size
expr_stmt|;
block|}
comment|/* If there's already a GOT entry, use that, not a .got.plt.  A 	 GOT field still has a reference count when we get here; it's 	 not yet changed to an offset.  We can't do this for an 	 executable, because then the reloc associated with the PLT 	 would get a non-PLT reloc pointing to the PLT.  FIXME: Move 	 this to elf_cris_try_fold_plt_to_got.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
name|h
operator|->
name|got
operator|.
name|refcount
operator|+=
name|h
operator|->
name|plt
operator|.
name|refcount
expr_stmt|;
comment|/* Mark the PLT offset to use the GOT entry by setting the low 	     bit in the plt offset; it is always a multiple of 	     plt_entry_size (which is at least a multiple of 2).  */
name|BFD_ASSERT
argument_list|(
operator|(
name|s
operator|->
name|size
operator|%
name|plt_entry_size
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Change the PLT refcount to an offset.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|size
expr_stmt|;
comment|/* By not setting gotplt_offset (i.e. it remains at 0), we signal 	     that the got entry should be used instead.  */
name|BFD_ASSERT
argument_list|(
operator|(
operator|(
expr|struct
name|elf_cris_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|gotplt_offset
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Make room for this entry.  */
name|s
operator|->
name|size
operator|+=
name|plt_entry_size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* No GOT reference for this symbol; prepare for an ordinary PLT.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|size
expr_stmt|;
comment|/* Make room for this entry.  */
name|s
operator|->
name|size
operator|+=
name|plt_entry_size
expr_stmt|;
comment|/* We also need to make an entry in the .got.plt section, which 	 will be placed in the .got section by the linker script.  */
operator|(
operator|(
expr|struct
name|elf_cris_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|gotplt_offset
operator|=
name|elf_cris_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|next_gotplt_entry
expr_stmt|;
name|elf_cris_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|next_gotplt_entry
operator|+=
literal|4
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
comment|/* We also need to make an entry in the .rela.plt section.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Reinitialize the plt offset now that it is not used as a reference      count any more.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
comment|/* If we are creating a shared library, we must presume that the      only references to the symbol are via the global offset table.      For such cases we need not do anything here; the relocations will      be handled correctly by relocate_section.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
return|return
name|TRUE
return|;
comment|/* If there are no references to this symbol that do not use the      GOT, we don't need to generate a copy reloc.  */
if|if
condition|(
operator|!
name|h
operator|->
name|non_got_ref
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|size
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"dynamic variable `%s' is zero size"
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* We must allocate the symbol in our .dynbss section, which will      become part of the .bss section of the executable.  There will be      an entry for this symbol in the .dynsym section.  The dynamic      object will contain position independent code, so all references      from the dynamic object to this symbol will go through the global      offset table.  The dynamic linker will use the .dynsym entry to      determine the address it must put in the global offset table, so      both the dynamic object and the regular object will refer to the      same memory location for the variable.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* We must generate a R_CRIS_COPY reloc to tell the dynamic linker to      copy the initial value out of the dynamic object and into the      runtime process image.  We need to remember the offset into the      .rela.bss section we are going to use.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|srel
decl_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.bss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|srel
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|h
operator|->
name|needs_copy
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Historic precedent: m68k and i386 allow max 8-byte alignment for the      thing to copy; so do we.  */
comment|/* We need to figure out the alignment required for this symbol.  I      have no idea how ELF linkers handle this.  */
name|power_of_two
operator|=
name|bfd_log2
argument_list|(
name|h
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
literal|3
condition|)
name|power_of_two
operator|=
literal|3
expr_stmt|;
comment|/* Apply the required alignment.  */
name|s
operator|->
name|size
operator|=
name|BFD_ALIGN
argument_list|(
name|s
operator|->
name|size
argument_list|,
call|(
name|bfd_size_type
call|)
argument_list|(
literal|1
operator|<<
name|power_of_two
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
name|bfd_get_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
name|power_of_two
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Define the symbol as being at this point in the section.  */
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|size
expr_stmt|;
comment|/* Increment the section size to make room for the symbol.  */
name|s
operator|->
name|size
operator|+=
name|h
operator|->
name|size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|cris_elf_check_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|,
modifier|*
modifier|*
name|sym_hashes_end
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_hashes_end
operator|=
name|sym_hashes
operator|+
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|NULL
expr_stmt|;
name|srelgot
operator|=
name|NULL
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|sym_hashes_end
operator|-=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|enum
name|elf_cris_reloc_type
name|r_type
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
comment|/* Some relocs require linker-created sections; we need to hang them 	 on the first input bfd we found that contained dynamic relocs.  */
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_CRIS_16_GOT
case|:
case|case
name|R_CRIS_32_GOT
case|:
case|case
name|R_CRIS_32_GOTREL
case|:
case|case
name|R_CRIS_32_PLT_GOTREL
case|:
case|case
name|R_CRIS_32_PLT_PCREL
case|:
case|case
name|R_CRIS_16_GOTPLT
case|:
case|case
name|R_CRIS_32_GOTPLT
case|:
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
block|{
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
comment|/* We could handle this if we can get a handle on the 		 output bfd in elf_cris_adjust_dynamic_symbol.  Failing 		 that, we must insist on dynobj being a specific mach.  */
if|if
condition|(
name|bfd_get_mach
argument_list|(
name|dynobj
argument_list|)
operator|==
name|bfd_mach_cris_v10_v32
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B, section %A:\n  v10/v32 compatible object %s"
literal|" must not contain a PIC relocation"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Create the .got section, so we can assume it's always 		 present whenever there's a dynobj.  */
if|if
condition|(
operator|!
name|_bfd_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* Some relocs require a global offset table (but perhaps not a 	 specific GOT entry).  */
switch|switch
condition|(
name|r_type
condition|)
block|{
comment|/* For R_CRIS_16_GOTPLT and R_CRIS_32_GOTPLT, we need a GOT 	     entry only for local symbols.  Unfortunately, we don't know 	     until later on if there's a version script that forces the 	     symbol local.  We must have the .rela.got section in place 	     before we know if the symbol looks global now, so we need 	     to treat the reloc just like for R_CRIS_16_GOT and 	     R_CRIS_32_GOT.  */
case|case
name|R_CRIS_16_GOTPLT
case|:
case|case
name|R_CRIS_32_GOTPLT
case|:
case|case
name|R_CRIS_16_GOT
case|:
case|case
name|R_CRIS_32_GOT
case|:
if|if
condition|(
name|srelgot
operator|==
name|NULL
operator|&&
operator|(
name|h
operator|!=
name|NULL
operator|||
name|info
operator|->
name|shared
operator|)
condition|)
block|{
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srelgot
operator|==
name|NULL
condition|)
block|{
name|srelgot
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|srelgot
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|srelgot
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Fall through.  */
case|case
name|R_CRIS_32_GOTREL
case|:
case|case
name|R_CRIS_32_PLT_GOTREL
case|:
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|amt
decl_stmt|;
comment|/* We use index local_got_refcounts[-1] to count all 		 GOT-relative relocations that do not have explicit 		 GOT entries.  */
name|amt
operator|=
name|symtab_hdr
operator|->
name|sh_info
operator|+
literal|1
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|bfd_signed_vma
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
operator|(
operator|(
name|bfd_signed_vma
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|local_got_refcounts
operator|++
expr_stmt|;
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_got_refcounts
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_CRIS_16_GOTPLT
case|:
case|case
name|R_CRIS_32_GOTPLT
case|:
comment|/* Mark that we need a GOT entry if the PLT entry (and its GOT 	     entry) is eliminated.  We can only do this for a non-local 	     symbol.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
operator|(
operator|(
expr|struct
name|elf_cris_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|gotplt_refcount
operator|++
expr_stmt|;
goto|goto
name|handle_gotplt_reloc
goto|;
block|}
comment|/* If h is NULL then this is a local symbol, and we must make a 	     GOT entry for it, so handle it like a GOT reloc.  */
comment|/* Fall through.  */
case|case
name|R_CRIS_16_GOT
case|:
case|case
name|R_CRIS_32_GOT
case|:
comment|/* This symbol requires a global offset table entry.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|==
literal|0
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Allocate space in the .got section.  */
name|sgot
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
comment|/* Allocate relocation space.  */
name|srelgot
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
name|h
operator|->
name|got
operator|.
name|refcount
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a global offset table entry for a local symbol.  */
if|if
condition|(
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|==
literal|0
condition|)
block|{
name|sgot
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* If we are generating a shared object, we need to 			 output a R_CRIS_RELATIVE reloc so that the dynamic 			 linker can adjust this GOT entry.  */
name|srelgot
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
block|}
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|R_CRIS_32_GOTREL
case|:
comment|/* This reference requires a global offset table. 	     FIXME: The actual refcount isn't used currently; the .got 	     section can't be removed if there were any references in the 	     input.  */
name|local_got_refcounts
index|[
operator|-
literal|1
index|]
operator|++
expr_stmt|;
break|break;
name|handle_gotplt_reloc
label|:
case|case
name|R_CRIS_32_PLT_GOTREL
case|:
comment|/* This reference requires a global offset table.  */
name|local_got_refcounts
index|[
operator|-
literal|1
index|]
operator|++
expr_stmt|;
comment|/* Fall through.  */
case|case
name|R_CRIS_32_PLT_PCREL
case|:
comment|/* This symbol requires a procedure linkage table entry.  We 	     actually build the entry in adjust_dynamic_symbol,              because this might be a case of linking PIC code which is              never referenced by a dynamic object, in which case we              don't need to generate a procedure linkage table entry              after all.  */
comment|/* Beware: if we'd check for visibility of the symbol here 	     (and not marking the need for a PLT when non-visible), we'd 	     get into trouble with keeping handling consistent with 	     regards to relocs found before definition and GOTPLT 	     handling.  Eliminable PLT entries will be dealt with later 	     anyway.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
continue|continue;
name|h
operator|->
name|needs_plt
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|refcount
operator|++
expr_stmt|;
break|break;
case|case
name|R_CRIS_8
case|:
case|case
name|R_CRIS_16
case|:
case|case
name|R_CRIS_32
case|:
comment|/* Let's help debug shared library creation.  Any of these 	     relocs can be used in shared libs, but pages containing them 	     cannot be shared.  Don't warn for sections we don't care 	     about, such as debug sections or non-constant sections.  We 	     can't help tables of (global) function pointers, for example, 	     though they must be emitted in a data section to avoid having 	     impure text sections.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* FIXME: How do we make this optionally a warning only?  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B, section %A:\n  relocation %s should not"
literal|" be used in a shared object; recompile with -fPIC"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
name|cris_elf_howto_table
index|[
name|r_type
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Fall through.  */
case|case
name|R_CRIS_8_PCREL
case|:
case|case
name|R_CRIS_16_PCREL
case|:
case|case
name|R_CRIS_32_PCREL
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|h
operator|->
name|non_got_ref
operator|=
literal|1
expr_stmt|;
comment|/* Make sure a plt entry is created for this symbol if it 		 turns out to be a function defined by a dynamic object.  */
if|if
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
condition|)
name|h
operator|->
name|plt
operator|.
name|refcount
operator|++
expr_stmt|;
block|}
comment|/* If we are creating a shared library and this is not a local 	     symbol, we need to copy the reloc into the shared library. 	     However when linking with -Bsymbolic and this is a global 	     symbol which is defined in an object we are including in the 	     link (i.e., DEF_REGULAR is set), then we can resolve the 	     reloc directly.  At this point we have not seen all the input 	     files, so it is possible that DEF_REGULAR is not set now but 	     will be set later (it is never cleared).  In case of a weak 	     definition, DEF_REGULAR may be cleared later by a strong 	     definition in a shared library.  We account for that 	     possibility below by storing information in the relocs_copied 	     field of the hash table entry.  A similar situation occurs 	     when creating shared libraries and symbol visibility changes 	     render the symbol local.  */
comment|/* No need to do anything if we're not creating a shared object.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
break|break;
comment|/* We don't need to handle relocs into sections not going into 	     the "real" output.  */
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* We can only eliminate PC-relative relocs.  */
if|if
condition|(
name|r_type
operator|==
name|R_CRIS_8_PCREL
operator|||
name|r_type
operator|==
name|R_CRIS_16_PCREL
operator|||
name|r_type
operator|==
name|R_CRIS_32_PCREL
condition|)
block|{
comment|/* If the symbol is local, then we can eliminate the reloc.  */
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_DEFAULT
condition|)
break|break;
comment|/* If this is with -Bsymbolic and the symbol isn't weak, and 		 is defined by an ordinary object (the ones we include in 		 this shared library) then we can also eliminate the 		 reloc.  See comment above for more eliminable cases which 		 we can't identify at this time.  */
if|if
condition|(
name|info
operator|->
name|symbolic
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|&&
name|h
operator|->
name|def_regular
condition|)
break|break;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* FIXME: How do we make this optionally a warning only?  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B, section %A:\n  relocation %s should not be used"
literal|" in a shared object; recompile with -fPIC"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
name|cris_elf_howto_table
index|[
name|r_type
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We create a reloc section in dynobj and make room for this 	     reloc.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|BFD_ASSERT
argument_list|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|sreloc
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|sec
operator|->
name|flags
operator|&
name|SEC_READONLY
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
name|sreloc
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
comment|/* If we are linking with -Bsymbolic, we count the number of PC 	     relative relocations we have entered for this symbol, so that 	     we can discard them again if the symbol is later defined by a 	     regular object.  We know that h is really a pointer to an 	     elf_cris_link_hash_entry.  */
if|if
condition|(
operator|(
name|r_type
operator|==
name|R_CRIS_8_PCREL
operator|||
name|r_type
operator|==
name|R_CRIS_16_PCREL
operator|||
name|r_type
operator|==
name|R_CRIS_32_PCREL
operator|)
operator|&&
name|info
operator|->
name|symbolic
condition|)
block|{
name|struct
name|elf_cris_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf_cris_pcrel_relocs_copied
modifier|*
name|p
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf_cris_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|pcrel_relocs_copied
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|section
operator|==
name|sreloc
condition|)
break|break;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
operator|(
operator|(
expr|struct
name|elf_cris_pcrel_relocs_copied
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|dynobj
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
expr|*
name|p
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|p
operator|->
name|next
operator|=
name|eh
operator|->
name|pcrel_relocs_copied
expr_stmt|;
name|eh
operator|->
name|pcrel_relocs_copied
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|section
operator|=
name|sreloc
expr_stmt|;
name|p
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
operator|++
name|p
operator|->
name|count
expr_stmt|;
block|}
break|break;
comment|/* This relocation describes the C++ object vtable hierarchy.            Reconstruct it for later use during GC.  */
case|case
name|R_CRIS_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually            used.  Record for later use during GC.  */
case|case
name|R_CRIS_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
default|default:
comment|/* Other relocs do not appear here.  */
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_cris_size_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_boolean
name|plt
decl_stmt|;
name|bfd_boolean
name|relocs
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Adjust all expected GOTPLT uses to use a GOT entry instead.  */
name|elf_cris_link_hash_traverse
argument_list|(
name|elf_cris_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_cris_adjust_gotplt_to_got
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
comment|/* We may have created entries in the .rela.got section. 	 However, if we are not creating the dynamic sections, we will 	 not actually use these entries.  Reset the size of .rela.got, 	 which will cause it to get stripped from the output file 	 below.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|s
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this is a -Bsymbolic shared link, then we need to discard all PC      relative relocs against symbols defined in a regular object.  We      allocated space for them in the check_relocs routine, but we will not      fill them in in the relocate_section routine.  We also discard space      for relocs that have become for local symbols due to symbol      visibility changes.  For programs, we discard space for relocs for      symbols not referenced by any dynamic object.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|elf_cris_link_hash_traverse
argument_list|(
name|elf_cris_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_cris_discard_excess_dso_dynamics
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
else|else
name|elf_cris_link_hash_traverse
argument_list|(
name|elf_cris_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_cris_discard_excess_program_dynamics
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
comment|/* The check_relocs and adjust_dynamic_symbol entry points have      determined the sizes of the various dynamic sections.  Allocate      memory for them.  */
name|plt
operator|=
name|FALSE
expr_stmt|;
name|relocs
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* It's OK to base decisions on the section name, because none 	 of the dynobj section names depend upon the input files.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".plt"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Remember whether there is a PLT.  */
name|plt
operator|=
name|s
operator|->
name|size
operator|!=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
comment|/* Remember whether there are any reloc sections other                  than .rela.plt.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rela.plt"
argument_list|)
operator|!=
literal|0
condition|)
name|relocs
operator|=
name|TRUE
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need 		 to copy relocs into the output file.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".got"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".dynbss"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
block|{
comment|/* If we don't need this section, strip it from the 	     output file.  This is mostly to handle .rela.bss and 	     .rela.plt.  We must create both sections in 	     create_dynamic_sections, because they must be created 	     before the linker maps input sections to output 	     sections.  The linker does that before 	     adjust_dynamic_symbol is called, and it is that 	     function which decides whether anything needs to go 	     into these sections.  */
name|s
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Allocate memory for the section contents. We use bfd_zalloc here 	 in case unused entries are not reclaimed before the section's 	 contents are written out.  This should not happen, but this way 	 if it does, we will not write out garbage.  For reloc sections, 	 this will make entries have the type R_CRIS_NONE.  */
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in elf_cris_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
define|#
directive|define
name|add_dynamic_entry
parameter_list|(
name|TAG
parameter_list|,
name|VAL
parameter_list|)
define|\
value|_bfd_elf_add_dynamic_entry (info, TAG, VAL)
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|plt
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTREL
argument_list|,
name|DT_RELA
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|relocs
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELA
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELAENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|add_dynamic_entry
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This function is called via elf_cris_link_hash_traverse if we are    creating a shared object.  In the -Bsymbolic case, it discards the    space allocated to copy PC relative relocs against symbols which    are defined in regular objects.  For the normal non-symbolic case,    we also discard space for relocs that have become local due to    symbol visibility changes.  We allocated space for them in the    check_relocs routine, but we won't fill them in in the    relocate_section routine.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_cris_discard_excess_dso_dynamics
parameter_list|(
name|h
parameter_list|,
name|inf
parameter_list|)
name|struct
name|elf_cris_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|inf
decl_stmt|;
block|{
name|struct
name|elf_cris_pcrel_relocs_copied
modifier|*
name|s
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_cris_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* If a symbol has been forced local or we have found a regular      definition for the symbolic link case, then we won't be needing      any relocs.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|def_regular
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|forced_local
operator|||
name|info
operator|->
name|symbolic
operator|)
condition|)
block|{
for|for
control|(
name|s
operator|=
name|h
operator|->
name|pcrel_relocs_copied
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
name|s
operator|->
name|section
operator|->
name|size
operator|-=
name|s
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This function is called via elf_cris_link_hash_traverse if we are *not*    creating a shared object.  We discard space for relocs for symbols put    in the .got, but which we found we do not have to resolve at run-time.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_cris_discard_excess_program_dynamics
parameter_list|(
name|h
parameter_list|,
name|inf
parameter_list|)
name|struct
name|elf_cris_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|inf
decl_stmt|;
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_cris_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* If we're not creating a shared library and have a symbol which is      referred to by .got references, but the symbol is defined locally,      (or rather, not defined by a DSO) then lose the reloc for the .got      (don't allocate room for it).  Likewise for relocs for something      for which we create a PLT.  */
if|if
condition|(
operator|!
name|h
operator|->
name|root
operator|.
name|def_dynamic
operator|||
name|h
operator|->
name|root
operator|.
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|got
operator|.
name|refcount
operator|>
literal|0
comment|/* The size of this section is only valid and in sync with the 	     various reference counts if we do dynamic; don't decrement it 	     otherwise.  */
operator|&&
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|bfd
modifier|*
name|dynobj
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srelgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|srelgot
operator|->
name|size
operator|-=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
comment|/* If the locally-defined symbol isn't used by a DSO, then we don't 	 have to export it as a dynamic symbol.  This was already done for 	 functions; doing this for all symbols would presumably not 	 introduce new problems.  Of course we don't do this if we're 	 exporting all dynamic symbols.  */
if|if
condition|(
operator|!
name|info
operator|->
name|export_dynamic
operator|&&
name|h
operator|->
name|root
operator|.
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|root
operator|.
name|def_dynamic
operator|&&
operator|!
name|h
operator|->
name|root
operator|.
name|ref_dynamic
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|dynindx
operator|=
operator|-
literal|1
expr_stmt|;
name|_bfd_elf_strtab_delref
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynstr
argument_list|,
name|h
operator|->
name|root
operator|.
name|dynstr_index
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Reject a file depending on presence and expectation of prefixed    underscores on symbols.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|cris_elf_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|cris_elf_set_mach_from_flags
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_CRIS_UNDERSCORE
operator|)
condition|)
return|return
operator|(
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
operator|==
literal|'_'
operator|)
return|;
else|else
return|return
operator|(
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Mark presence or absence of leading underscore.  Set machine type    flags from mach type.  */
end_comment

begin_function
specifier|static
name|void
name|cris_elf_final_write_processing
parameter_list|(
name|abfd
parameter_list|,
name|linker
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_boolean
name|linker
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|long
name|e_flags
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
decl_stmt|;
name|e_flags
operator|&=
operator|~
name|EF_CRIS_UNDERSCORE
expr_stmt|;
if|if
condition|(
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
operator|==
literal|'_'
condition|)
name|e_flags
operator||=
name|EF_CRIS_UNDERSCORE
expr_stmt|;
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_mach_cris_v0_v10
case|:
name|e_flags
operator||=
name|EF_CRIS_VARIANT_ANY_V0_V10
expr_stmt|;
break|break;
case|case
name|bfd_mach_cris_v10_v32
case|:
name|e_flags
operator||=
name|EF_CRIS_VARIANT_COMMON_V10_V32
expr_stmt|;
break|break;
case|case
name|bfd_mach_cris_v32
case|:
name|e_flags
operator||=
name|EF_CRIS_VARIANT_V32
expr_stmt|;
break|break;
default|default:
name|_bfd_abort
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|_
argument_list|(
literal|"Unexpected machine number"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|=
name|e_flags
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the mach type from e_flags value.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|cris_elf_set_mach_from_flags
parameter_list|(
name|abfd
parameter_list|,
name|flags
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
block|{
switch|switch
condition|(
name|flags
operator|&
name|EF_CRIS_VARIANT_MASK
condition|)
block|{
case|case
name|EF_CRIS_VARIANT_ANY_V0_V10
case|:
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_cris
argument_list|,
name|bfd_mach_cris_v0_v10
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_CRIS_VARIANT_V32
case|:
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_cris
argument_list|,
name|bfd_mach_cris_v32
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_CRIS_VARIANT_COMMON_V10_V32
case|:
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_cris
argument_list|,
name|bfd_mach_cris_v10_v32
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Since we don't recognize them, we obviously can't support them 	 with this code; we'd have to require that all future handling 	 would be optional.  */
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Display the flags field.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|cris_elf_print_private_bfd_data
parameter_list|(
name|abfd
parameter_list|,
name|ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|ptr
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|ptr
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|abfd
operator|!=
name|NULL
operator|&&
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|_bfd_elf_print_private_bfd_data
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"private flags = %lx:"
argument_list|)
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_CRIS_UNDERSCORE
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [symbols have a _ prefix]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_CRIS_VARIANT_MASK
operator|)
operator|==
name|EF_CRIS_VARIANT_COMMON_V10_V32
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [v10 and v32]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_CRIS_VARIANT_MASK
operator|)
operator|==
name|EF_CRIS_VARIANT_V32
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [v32]"
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Don't mix files with and without a leading underscore.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|cris_elf_merge_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
name|int
name|imach
decl_stmt|,
name|omach
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_generic_verify_endian_match
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
name|imach
operator|=
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
comment|/* This happens when ld starts out with a 'blank' output file.  */
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
comment|/* We ignore the linker-set mach, and instead set it according to 	 the first input file.  This would also happen if we could 	 somehow filter out the OUTPUT_ARCH () setting from elf.sc. 	 This allows us to keep the same linker config across 	 cris(v0..v10) and crisv32.  The drawback is that we can't force 	 the output type, which might be a sane thing to do for a 	 v10+v32 compatibility object.  */
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_arch_cris
argument_list|,
name|imach
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|bfd_get_symbol_leading_char
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_get_symbol_leading_char
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|bfd_get_symbol_leading_char
argument_list|(
name|ibfd
argument_list|)
operator|==
literal|'_'
condition|?
name|_
argument_list|(
literal|"%B: uses _-prefixed symbols, but writing file with non-prefixed symbols"
argument_list|)
else|:
name|_
argument_list|(
literal|"%B: uses non-prefixed symbols, but writing file with _-prefixed symbols"
argument_list|)
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|omach
operator|=
name|bfd_get_mach
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|imach
operator|!=
name|omach
condition|)
block|{
comment|/* We can get an incompatible combination only if either is 	 bfd_mach_cris_v32, and the other one isn't compatible.  */
if|if
condition|(
operator|(
name|imach
operator|==
name|bfd_mach_cris_v32
operator|&&
name|omach
operator|!=
name|bfd_mach_cris_v10_v32
operator|)
operator|||
operator|(
name|omach
operator|==
name|bfd_mach_cris_v32
operator|&&
name|imach
operator|!=
name|bfd_mach_cris_v10_v32
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
operator|(
name|imach
operator|==
name|bfd_mach_cris_v32
operator|)
condition|?
name|_
argument_list|(
literal|"%B contains CRIS v32 code, incompatible"
literal|" with previous objects"
argument_list|)
else|:
name|_
argument_list|(
literal|"%B contains non-CRIS-v32 code, incompatible"
literal|" with previous objects"
argument_list|)
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* We don't have to check the case where the input is compatible 	 with v10 and v32, because the output is already known to be set 	 to the other (compatible) mach.  */
if|if
condition|(
name|omach
operator|==
name|bfd_mach_cris_v10_v32
operator|&&
operator|!
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_arch_cris
argument_list|,
name|imach
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Do side-effects of e_flags copying to obfd.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|cris_elf_copy_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
comment|/* Call the base function.  */
if|if
condition|(
operator|!
name|_bfd_elf_copy_private_bfd_data
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If output is big-endian for some obscure reason, stop here.  */
if|if
condition|(
name|_bfd_generic_verify_endian_match
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
operator|==
name|FALSE
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
comment|/* Do what we really came here for.  */
return|return
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_arch_cris
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|elf_reloc_type_class
name|elf_cris_reloc_type_class
parameter_list|(
name|rela
parameter_list|)
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rela
decl_stmt|;
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|ELF32_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_CRIS_RELATIVE
case|:
return|return
name|reloc_class_relative
return|;
case|case
name|R_CRIS_JUMP_SLOT
case|:
return|return
name|reloc_class_plt
return|;
case|case
name|R_CRIS_COPY
case|:
return|return
name|reloc_class_copy
return|;
default|default:
return|return
name|reloc_class_normal
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_cris
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_CRIS
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x2000
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_cris_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-cris"
end_define

begin_define
define|#
directive|define
name|elf_symbol_leading_char
value|0
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|NULL
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|cris_info_to_howto_rela
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|cris_elf_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|cris_elf_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|cris_elf_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|cris_elf_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_prstatus
value|cris_elf_grok_prstatus
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_psinfo
value|cris_elf_grok_psinfo
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_can_refcount
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|cris_elf_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
define|\
value|cris_elf_final_write_processing
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_print_private_bfd_data
define|\
value|cris_elf_print_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_merge_private_bfd_data
define|\
value|cris_elf_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_copy_private_bfd_data
define|\
value|cris_elf_copy_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|cris_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
define|\
value|elf_cris_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
define|\
value|elf_cris_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
define|\
value|elf_cris_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
define|\
value|elf_cris_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
define|\
value|elf_cris_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
define|\
value|_bfd_elf_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_final_link
define|\
value|bfd_elf_gc_common_final_link
end_define

begin_define
define|#
directive|define
name|elf_backend_hide_symbol
value|elf_cris_hide_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_reloc_type_class
value|elf_cris_reloc_type_class
end_define

begin_define
define|#
directive|define
name|elf_backend_want_got_plt
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_readonly
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|12
end_define

begin_comment
comment|/* Later, we my want to optimize RELA entries into REL entries for dynamic    linking and libraries (if it's a win of any significance).  Until then,    take the easy route.  */
end_comment

begin_define
define|#
directive|define
name|elf_backend_may_use_rel_p
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_may_use_rela_p
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_rela_normal
value|1
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

begin_define
define|#
directive|define
name|INCLUDED_TARGET_FILE
end_define

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_SYM
end_undef

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_NAME
end_undef

begin_undef
undef|#
directive|undef
name|elf_symbol_leading_char
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_us_cris_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-us-cris"
end_define

begin_define
define|#
directive|define
name|elf_symbol_leading_char
value|'_'
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

