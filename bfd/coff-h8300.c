begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for Renesas H8/300 COFF binaries.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.    Written by Steve Chamberlain,<sac@cygnus.com>.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"genlink.h"
end_include

begin_include
include|#
directive|include
file|"coff/h8300.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_define
define|#
directive|define
name|COFF_DEFAULT_SECTION_ALIGNMENT_POWER
value|(1)
end_define

begin_comment
comment|/* We derive a hash table from the basic BFD hash table to    hold entries in the function vector.  Aside from the    info stored by the basic hash table, we need the offset    of a particular entry within the hash table as well as    the offset where we'll add the next entry.  */
end_comment

begin_struct
struct|struct
name|funcvec_hash_entry
block|{
comment|/* The basic hash table entry.  */
name|struct
name|bfd_hash_entry
name|root
decl_stmt|;
comment|/* The offset within the vectors section where        this entry lives.  */
name|bfd_vma
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|funcvec_hash_table
block|{
comment|/* The basic hash table.  */
name|struct
name|bfd_hash_table
name|root
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
comment|/* Offset at which we'll add the next entry.  */
name|unsigned
name|int
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|funcvec_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|bfd_boolean
name|funcvec_hash_table_init
argument_list|(
expr|struct
name|funcvec_hash_table
operator|*
argument_list|,
name|bfd
operator|*
argument_list|,
expr|struct
name|bfd_hash_entry
operator|*
call|(
modifier|*
call|)
argument_list|(
expr|struct
name|bfd_hash_entry
operator|*
argument_list|,
expr|struct
name|bfd_hash_table
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|special
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|PTR
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|select_reloc
parameter_list|(
name|reloc_howto_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtype2howto
parameter_list|(
name|arelent
modifier|*
parameter_list|,
name|struct
name|internal_reloc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reloc_processing
parameter_list|(
name|arelent
modifier|*
parameter_list|,
name|struct
name|internal_reloc
modifier|*
parameter_list|,
name|asymbol
modifier|*
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|h8300_symbol_address_p
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|h8300_reloc16_estimate
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|h8300_reloc16_extra_cases
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|struct
name|bfd_link_order
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|unsigned
name|int
modifier|*
parameter_list|,
name|unsigned
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|h8300_bfd_link_add_symbols
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* To lookup a value in the function vector hash table.  */
end_comment

begin_define
define|#
directive|define
name|funcvec_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|)
define|\
value|((struct funcvec_hash_entry *) \    bfd_hash_lookup (&(table)->root, (string), (create), (copy)))
end_define

begin_comment
comment|/* The derived h8300 COFF linker table.  Note it's derived from    the generic linker hash table, not the COFF backend linker hash    table!  We use this to attach additional data structures we    need while linking on the h8300.  */
end_comment

begin_struct
struct|struct
name|h8300_coff_link_hash_table
block|{
comment|/* The main hash table.  */
name|struct
name|generic_link_hash_table
name|root
decl_stmt|;
comment|/* Section for the vectors table.  This gets attached to a      random input bfd, we keep it here for easy access.  */
name|asection
modifier|*
name|vectors_sec
decl_stmt|;
comment|/* Hash table of the functions we need to enter into the function      vector.  */
name|struct
name|funcvec_hash_table
modifier|*
name|funcvec_hash_table
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|h8300_coff_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Get the H8/300 COFF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|h8300_coff_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct h8300_coff_link_hash_table *) ((coff_hash_table (p))))
end_define

begin_comment
comment|/* Initialize fields within a funcvec hash table entry.  Called whenever    a new entry is added to the funcvec hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|funcvec_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|gen_table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|struct
name|funcvec_hash_entry
modifier|*
name|ret
decl_stmt|;
name|struct
name|funcvec_hash_table
modifier|*
name|table
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|funcvec_hash_entry
operator|*
operator|)
name|entry
expr_stmt|;
name|table
operator|=
operator|(
expr|struct
name|funcvec_hash_table
operator|*
operator|)
name|gen_table
expr_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|funcvec_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|gen_table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|funcvec_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|funcvec_hash_entry
operator|*
operator|)
name|bfd_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|gen_table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Note where this entry will reside in the function vector table.  */
name|ret
operator|->
name|offset
operator|=
name|table
operator|->
name|offset
expr_stmt|;
comment|/* Bump the offset at which we store entries in the function      vector.  We'd like to bump up the size of the vectors section,      but it's not easily available here.  */
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|table
operator|->
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_mach_h8300
case|:
case|case
name|bfd_mach_h8300hn
case|:
case|case
name|bfd_mach_h8300sn
case|:
name|table
operator|->
name|offset
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|bfd_mach_h8300h
case|:
case|case
name|bfd_mach_h8300s
case|:
name|table
operator|->
name|offset
operator|+=
literal|4
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
comment|/* Everything went OK.  */
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Initialize the function vector hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|funcvec_hash_table_init
argument_list|(
expr|struct
name|funcvec_hash_table
operator|*
name|table
argument_list|,
name|bfd
operator|*
name|abfd
argument_list|,
expr|struct
name|bfd_hash_entry
operator|*
call|(
modifier|*
name|newfunc
call|)
argument_list|(
expr|struct
name|bfd_hash_entry
operator|*
argument_list|,
expr|struct
name|bfd_hash_table
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
block|{
comment|/* Initialize our local fields, then call the generic initialization      routine.  */
name|table
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|abfd
operator|=
name|abfd
expr_stmt|;
return|return
operator|(
name|bfd_hash_table_init
argument_list|(
operator|&
name|table
operator|->
name|root
argument_list|,
name|newfunc
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Create the derived linker hash table.  We use a derived hash table    basically to hold "static" information during an H8/300 coff link    without using static variables.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|h8300_coff_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|h8300_coff_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|h8300_coff_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|h8300_coff_link_hash_table
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
operator|.
name|root
argument_list|,
name|abfd
argument_list|,
name|_bfd_generic_link_hash_newfunc
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Initialize our data.  */
name|ret
operator|->
name|vectors_sec
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|funcvec_hash_table
operator|=
name|NULL
expr_stmt|;
comment|/* OK.  Everything's initialized, return the base pointer.  */
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Special handling for H8/300 relocs.    We only come here for pcrel stuff and return normally if not an -r link.    When doing -r, we can't do any arithmetic for the pcrel stuff, because    the code in reloc.c assumes that we can manipulate the targets of    the pcrel branches.  This isn't so, since the H8/300 can do relaxing,    which means that the gap after the instruction may not be enough to    contain the offset required for the branch, so we have to use only    the addend until the final link.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|special
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
name|symbol
name|ATTRIBUTE_UNUSED
parameter_list|,
name|PTR
name|data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|input_section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
return|return
name|bfd_reloc_continue
return|;
comment|/* Adjust the reloc address to that in the output section.  */
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|R_RELBYTE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"8"
argument_list|,
name|FALSE
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_RELWORD
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"16"
argument_list|,
name|FALSE
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_RELLONG
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"32"
argument_list|,
name|FALSE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_PCRBYTE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|special
argument_list|,
literal|"DISP8"
argument_list|,
name|FALSE
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_PCRWORD
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|special
argument_list|,
literal|"DISP16"
argument_list|,
name|FALSE
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_PCRLONG
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|special
argument_list|,
literal|"DISP32"
argument_list|,
name|FALSE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_MOV16B1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"relaxable mov.b:16"
argument_list|,
name|FALSE
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_MOV16B2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"relaxed mov.b:16"
argument_list|,
name|FALSE
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_JMP1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"16/pcrel"
argument_list|,
name|FALSE
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_JMP2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"pcrecl/16"
argument_list|,
name|FALSE
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_JMPL1
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"24/pcrell"
argument_list|,
name|FALSE
argument_list|,
literal|0x00ffffff
argument_list|,
literal|0x00ffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_JMPL2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"pc8/24"
argument_list|,
name|FALSE
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_MOV24B1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"relaxable mov.b:24"
argument_list|,
name|FALSE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_MOV24B2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"relaxed mov.b:24"
argument_list|,
name|FALSE
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|FALSE
argument_list|)
block|,
comment|/* An indirect reference to a function.  This causes the function's address      to be added to the function vector in lo-mem and puts the address of      the function vector's entry in the jsr instruction.  */
name|HOWTO
argument_list|(
name|R_MEM_INDIRECT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"8/indirect"
argument_list|,
name|FALSE
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|FALSE
argument_list|)
block|,
comment|/* Internal reloc for relaxing.  This is created when a 16-bit pc-relative      branch is turned into an 8-bit pc-relative branch.  */
name|HOWTO
argument_list|(
name|R_PCRWORD_B
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"relaxed bCC:16"
argument_list|,
name|FALSE
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_MOVL1
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"32/24 relaxable move"
argument_list|,
name|FALSE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_MOVL2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|special
argument_list|,
literal|"32/24 relaxed move"
argument_list|,
name|FALSE
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_BCC_INV
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|special
argument_list|,
literal|"DISP8 inverted"
argument_list|,
name|FALSE
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_JMP_DEL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|special
argument_list|,
literal|"Deleted jump"
argument_list|,
name|FALSE
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|TRUE
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Turn a howto into a reloc number.  */
end_comment

begin_define
define|#
directive|define
name|SELECT_RELOC
parameter_list|(
name|x
parameter_list|,
name|howto
parameter_list|)
define|\
value|{ x.r_type = select_reloc (howto); }
end_define

begin_define
define|#
directive|define
name|BADMAG
parameter_list|(
name|x
parameter_list|)
value|(H8300BADMAG (x)&& H8300HBADMAG (x)&& H8300SBADMAG (x) \&& H8300HNBADMAG(x)&& H8300SNBADMAG(x))
end_define

begin_define
define|#
directive|define
name|H8300
value|1
end_define

begin_comment
comment|/* Customize coffcode.h  */
end_comment

begin_define
define|#
directive|define
name|__A_MAGIC_SET__
end_define

begin_comment
comment|/* Code to swap in the reloc.  */
end_comment

begin_define
define|#
directive|define
name|SWAP_IN_RELOC_OFFSET
value|H_GET_32
end_define

begin_define
define|#
directive|define
name|SWAP_OUT_RELOC_OFFSET
value|H_PUT_32
end_define

begin_define
define|#
directive|define
name|SWAP_OUT_RELOC_EXTRA
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
define|\
value|dst->r_stuff[0] = 'S'; \   dst->r_stuff[1] = 'C';
end_define

begin_function
specifier|static
name|int
name|select_reloc
parameter_list|(
name|reloc_howto_type
modifier|*
name|howto
parameter_list|)
block|{
return|return
name|howto
operator|->
name|type
return|;
block|}
end_function

begin_comment
comment|/* Code to turn a r_type into a howto ptr, uses the above howto table.  */
end_comment

begin_function
specifier|static
name|void
name|rtype2howto
parameter_list|(
name|arelent
modifier|*
name|internal
parameter_list|,
name|struct
name|internal_reloc
modifier|*
name|dst
parameter_list|)
block|{
switch|switch
condition|(
name|dst
operator|->
name|r_type
condition|)
block|{
case|case
name|R_RELBYTE
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|0
expr_stmt|;
break|break;
case|case
name|R_RELWORD
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|R_RELLONG
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|2
expr_stmt|;
break|break;
case|case
name|R_PCRBYTE
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|3
expr_stmt|;
break|break;
case|case
name|R_PCRWORD
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|4
expr_stmt|;
break|break;
case|case
name|R_PCRLONG
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|5
expr_stmt|;
break|break;
case|case
name|R_MOV16B1
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|6
expr_stmt|;
break|break;
case|case
name|R_MOV16B2
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|7
expr_stmt|;
break|break;
case|case
name|R_JMP1
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|8
expr_stmt|;
break|break;
case|case
name|R_JMP2
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|9
expr_stmt|;
break|break;
case|case
name|R_JMPL1
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|10
expr_stmt|;
break|break;
case|case
name|R_JMPL2
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|11
expr_stmt|;
break|break;
case|case
name|R_MOV24B1
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|12
expr_stmt|;
break|break;
case|case
name|R_MOV24B2
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|13
expr_stmt|;
break|break;
case|case
name|R_MEM_INDIRECT
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|14
expr_stmt|;
break|break;
case|case
name|R_PCRWORD_B
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|15
expr_stmt|;
break|break;
case|case
name|R_MOVL1
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|16
expr_stmt|;
break|break;
case|case
name|R_MOVL2
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|17
expr_stmt|;
break|break;
case|case
name|R_BCC_INV
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|18
expr_stmt|;
break|break;
case|case
name|R_JMP_DEL
case|:
name|internal
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|19
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|RTYPE2HOWTO
parameter_list|(
name|internal
parameter_list|,
name|relocentry
parameter_list|)
value|rtype2howto (internal, relocentry)
end_define

begin_comment
comment|/* Perform any necessary magic to the addend in a reloc entry.  */
end_comment

begin_define
define|#
directive|define
name|CALC_ADDEND
parameter_list|(
name|abfd
parameter_list|,
name|symbol
parameter_list|,
name|ext_reloc
parameter_list|,
name|cache_ptr
parameter_list|)
define|\
value|cache_ptr->addend = ext_reloc.r_offset;
end_define

begin_define
define|#
directive|define
name|RELOC_PROCESSING
parameter_list|(
name|relent
parameter_list|,
name|reloc
parameter_list|,
name|symbols
parameter_list|,
name|abfd
parameter_list|,
name|section
parameter_list|)
define|\
value|reloc_processing (relent, reloc, symbols, abfd, section)
end_define

begin_function
specifier|static
name|void
name|reloc_processing
parameter_list|(
name|arelent
modifier|*
name|relent
parameter_list|,
name|struct
name|internal_reloc
modifier|*
name|reloc
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|)
block|{
name|relent
operator|->
name|address
operator|=
name|reloc
operator|->
name|r_vaddr
expr_stmt|;
name|rtype2howto
argument_list|(
name|relent
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|reloc
operator|->
name|r_symndx
operator|)
operator|>
literal|0
condition|)
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|symbols
operator|+
name|obj_convert
argument_list|(
name|abfd
argument_list|)
index|[
name|reloc
operator|->
name|r_symndx
index|]
expr_stmt|;
else|else
name|relent
operator|->
name|sym_ptr_ptr
operator|=
name|bfd_abs_section_ptr
operator|->
name|symbol_ptr_ptr
expr_stmt|;
name|relent
operator|->
name|addend
operator|=
name|reloc
operator|->
name|r_offset
expr_stmt|;
name|relent
operator|->
name|address
operator|-=
name|section
operator|->
name|vma
expr_stmt|;
if|#
directive|if
literal|0
block|relent->section = 0;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|h8300_symbol_address_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_vma
name|address
parameter_list|)
block|{
name|asymbol
modifier|*
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|_bfd_generic_link_get_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* Search all the symbols for one in INPUT_SECTION with      address ADDRESS.  */
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|asymbol
modifier|*
name|p
init|=
operator|*
name|s
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|section
operator|==
name|input_section
operator|&&
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|p
operator|->
name|value
operator|)
operator|==
name|address
condition|)
return|return
name|TRUE
return|;
name|s
operator|++
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* If RELOC represents a relaxable instruction/reloc, change it into    the relaxed reloc, notify the linker that symbol addresses    have changed (bfd_perform_slip) and return how much the current    section has shrunk by.     FIXME: Much of this code has knowledge of the ordering of entries    in the howto table.  This needs to be fixed.  */
end_comment

begin_function
specifier|static
name|int
name|h8300_reloc16_estimate
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|arelent
modifier|*
name|reloc
parameter_list|,
name|unsigned
name|int
name|shrink
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|)
block|{
name|bfd_vma
name|value
decl_stmt|;
name|bfd_vma
name|dot
decl_stmt|;
name|bfd_vma
name|gap
decl_stmt|;
specifier|static
name|asection
modifier|*
name|last_input_section
init|=
name|NULL
decl_stmt|;
specifier|static
name|arelent
modifier|*
name|last_reloc
init|=
name|NULL
decl_stmt|;
comment|/* The address of the thing to be relocated will have moved back by      the size of the shrink - but we don't change reloc->address here,      since we need it to know where the relocation lives in the source      uncooked section.  */
name|bfd_vma
name|address
init|=
name|reloc
operator|->
name|address
operator|-
name|shrink
decl_stmt|;
if|if
condition|(
name|input_section
operator|!=
name|last_input_section
condition|)
name|last_reloc
operator|=
name|NULL
expr_stmt|;
comment|/* Only examine the relocs which might be relaxable.  */
switch|switch
condition|(
name|reloc
operator|->
name|howto
operator|->
name|type
condition|)
block|{
comment|/* This is the 16-/24-bit absolute branch which could become an 	 8-bit pc-relative branch.  */
case|case
name|R_JMP1
case|:
case|case
name|R_JMPL1
case|:
comment|/* Get the address of the target of this branch.  */
name|value
operator|=
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
comment|/* Get the address of the next instruction (not the reloc).  */
name|dot
operator|=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|address
operator|)
expr_stmt|;
comment|/* Adjust for R_JMP1 vs R_JMPL1.  */
name|dot
operator|+=
operator|(
name|reloc
operator|->
name|howto
operator|->
name|type
operator|==
name|R_JMP1
condition|?
literal|1
else|:
literal|2
operator|)
expr_stmt|;
comment|/* Compute the distance from this insn to the branch target.  */
name|gap
operator|=
name|value
operator|-
name|dot
expr_stmt|;
comment|/* If the distance is within -128..+128 inclusive, then we can relax 	 this jump.  +128 is valid since the target will move two bytes 	 closer if we do relax this branch.  */
if|if
condition|(
operator|(
name|int
operator|)
name|gap
operator|>=
operator|-
literal|128
operator|&&
operator|(
name|int
operator|)
name|gap
operator|<=
literal|128
condition|)
block|{
name|bfd_byte
name|code
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|input_section
argument_list|,
operator|&
name|code
argument_list|,
name|reloc
operator|->
name|address
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|&
name|code
argument_list|)
expr_stmt|;
comment|/* It's possible we may be able to eliminate this branch entirely; 	     if the previous instruction is a branch around this instruction, 	     and there's no label at this instruction, then we can reverse 	     the condition on the previous branch and eliminate this jump.  	       original:			new: 		 bCC lab1			bCC' lab2 		 jmp lab2 		lab1:				lab1:  	     This saves 4 bytes instead of two, and should be relatively 	     common.  	     Only perform this optimisation for jumps (code 0x5a) not 	     subroutine calls, as otherwise it could transform:  			     mov.w   r0,r0 			     beq     .L1 			     jsr     @_bar 		      .L1:   rts 		      _bar:  rts 	     into: 			     mov.w   r0,r0 			     bne     _bar 			     rts 		      _bar:  rts  	     which changes the call (jsr) into a branch (bne).  */
if|if
condition|(
name|code
operator|==
literal|0x5a
operator|&&
name|gap
operator|<=
literal|126
operator|&&
name|last_reloc
operator|&&
name|last_reloc
operator|->
name|howto
operator|->
name|type
operator|==
name|R_PCRBYTE
condition|)
block|{
name|bfd_vma
name|last_value
decl_stmt|;
name|last_value
operator|=
name|bfd_coff_reloc16_get_value
argument_list|(
name|last_reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|last_value
operator|==
name|dot
operator|+
literal|2
operator|&&
name|last_reloc
operator|->
name|address
operator|+
literal|1
operator|==
name|reloc
operator|->
name|address
operator|&&
operator|!
name|h8300_symbol_address_p
argument_list|(
name|abfd
argument_list|,
name|input_section
argument_list|,
name|dot
operator|-
literal|2
argument_list|)
condition|)
block|{
name|reloc
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|19
expr_stmt|;
name|last_reloc
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|18
expr_stmt|;
name|last_reloc
operator|->
name|sym_ptr_ptr
operator|=
name|reloc
operator|->
name|sym_ptr_ptr
expr_stmt|;
name|last_reloc
operator|->
name|addend
operator|=
name|reloc
operator|->
name|addend
expr_stmt|;
name|shrink
operator|+=
literal|4
expr_stmt|;
name|bfd_perform_slip
argument_list|(
name|abfd
argument_list|,
literal|4
argument_list|,
name|input_section
argument_list|,
name|address
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Change the reloc type.  */
name|reloc
operator|->
name|howto
operator|=
name|reloc
operator|->
name|howto
operator|+
literal|1
expr_stmt|;
comment|/* This shrinks this section by two bytes.  */
name|shrink
operator|+=
literal|2
expr_stmt|;
name|bfd_perform_slip
argument_list|(
name|abfd
argument_list|,
literal|2
argument_list|,
name|input_section
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* This is the 16-bit pc-relative branch which could become an 8-bit        pc-relative branch.  */
case|case
name|R_PCRWORD
case|:
comment|/* Get the address of the target of this branch, add one to the value 	 because the addend field in PCrel jumps is off by -1.  */
name|value
operator|=
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Get the address of the next instruction if we were to relax.  */
name|dot
operator|=
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|address
expr_stmt|;
comment|/* Compute the distance from this insn to the branch target.  */
name|gap
operator|=
name|value
operator|-
name|dot
expr_stmt|;
comment|/* If the distance is within -128..+128 inclusive, then we can relax 	 this jump.  +128 is valid since the target will move two bytes 	 closer if we do relax this branch.  */
if|if
condition|(
operator|(
name|int
operator|)
name|gap
operator|>=
operator|-
literal|128
operator|&&
operator|(
name|int
operator|)
name|gap
operator|<=
literal|128
condition|)
block|{
comment|/* Change the reloc type.  */
name|reloc
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|15
expr_stmt|;
comment|/* This shrinks this section by two bytes.  */
name|shrink
operator|+=
literal|2
expr_stmt|;
name|bfd_perform_slip
argument_list|(
name|abfd
argument_list|,
literal|2
argument_list|,
name|input_section
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* This is a 16-bit absolute address in a mov.b insn, which can        become an 8-bit absolute address if it's in the right range.  */
case|case
name|R_MOV16B1
case|:
comment|/* Get the address of the data referenced by this mov.b insn.  */
name|value
operator|=
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|value
operator|=
name|bfd_h8300_pad_address
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* If the address is in the top 256 bytes of the address space 	 then we can relax this instruction.  */
if|if
condition|(
name|value
operator|>=
literal|0xffffff00u
condition|)
block|{
comment|/* Change the reloc type.  */
name|reloc
operator|->
name|howto
operator|=
name|reloc
operator|->
name|howto
operator|+
literal|1
expr_stmt|;
comment|/* This shrinks this section by two bytes.  */
name|shrink
operator|+=
literal|2
expr_stmt|;
name|bfd_perform_slip
argument_list|(
name|abfd
argument_list|,
literal|2
argument_list|,
name|input_section
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Similarly for a 24-bit absolute address in a mov.b.  Note that        if we can't relax this into an 8-bit absolute, we'll fall through        and try to relax it into a 16-bit absolute.  */
case|case
name|R_MOV24B1
case|:
comment|/* Get the address of the data referenced by this mov.b insn.  */
name|value
operator|=
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|value
operator|=
name|bfd_h8300_pad_address
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|>=
literal|0xffffff00u
condition|)
block|{
comment|/* Change the reloc type.  */
name|reloc
operator|->
name|howto
operator|=
name|reloc
operator|->
name|howto
operator|+
literal|1
expr_stmt|;
comment|/* This shrinks this section by four bytes.  */
name|shrink
operator|+=
literal|4
expr_stmt|;
name|bfd_perform_slip
argument_list|(
name|abfd
argument_list|,
literal|4
argument_list|,
name|input_section
argument_list|,
name|address
argument_list|)
expr_stmt|;
comment|/* Done with this reloc.  */
break|break;
block|}
comment|/* FALLTHROUGH and try to turn the 24-/32-bit reloc into a 16-bit 	 reloc.  */
comment|/* This is a 24-/32-bit absolute address in a mov insn, which can        become an 16-bit absolute address if it's in the right range.  */
case|case
name|R_MOVL1
case|:
comment|/* Get the address of the data referenced by this mov insn.  */
name|value
operator|=
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|value
operator|=
name|bfd_h8300_pad_address
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* If the address is a sign-extended 16-bit value then we can          relax this instruction.  */
if|if
condition|(
name|value
operator|<=
literal|0x7fff
operator|||
name|value
operator|>=
literal|0xffff8000u
condition|)
block|{
comment|/* Change the reloc type.  */
name|reloc
operator|->
name|howto
operator|=
name|howto_table
operator|+
literal|17
expr_stmt|;
comment|/* This shrinks this section by two bytes.  */
name|shrink
operator|+=
literal|2
expr_stmt|;
name|bfd_perform_slip
argument_list|(
name|abfd
argument_list|,
literal|2
argument_list|,
name|input_section
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* No other reloc types represent relaxing opportunities.  */
default|default:
break|break;
block|}
name|last_reloc
operator|=
name|reloc
expr_stmt|;
name|last_input_section
operator|=
name|input_section
expr_stmt|;
return|return
name|shrink
return|;
block|}
end_function

begin_comment
comment|/* Handle relocations for the H8/300, including relocs for relaxed    instructions.     FIXME: Not all relocations check for overflow!  */
end_comment

begin_function
specifier|static
name|void
name|h8300_reloc16_extra_cases
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|struct
name|bfd_link_order
modifier|*
name|link_order
parameter_list|,
name|arelent
modifier|*
name|reloc
parameter_list|,
name|bfd_byte
modifier|*
name|data
parameter_list|,
name|unsigned
name|int
modifier|*
name|src_ptr
parameter_list|,
name|unsigned
name|int
modifier|*
name|dst_ptr
parameter_list|)
block|{
name|unsigned
name|int
name|src_address
init|=
operator|*
name|src_ptr
decl_stmt|;
name|unsigned
name|int
name|dst_address
init|=
operator|*
name|dst_ptr
decl_stmt|;
name|asection
modifier|*
name|input_section
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|bfd_vma
name|dot
decl_stmt|;
name|int
name|gap
decl_stmt|,
name|tmp
decl_stmt|;
name|unsigned
name|char
name|temp_code
decl_stmt|;
switch|switch
condition|(
name|reloc
operator|->
name|howto
operator|->
name|type
condition|)
block|{
comment|/* Generic 8-bit pc-relative relocation.  */
case|case
name|R_PCRBYTE
case|:
comment|/* Get the address of the target of this branch.  */
name|value
operator|=
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|dot
operator|=
operator|(
name|link_order
operator|->
name|offset
operator|+
name|dst_address
operator|+
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|gap
operator|=
name|value
operator|-
name|dot
expr_stmt|;
comment|/* Sanity check.  */
if|if
condition|(
name|gap
operator|<
operator|-
literal|128
operator|||
name|gap
operator|>
literal|126
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|link_info
argument_list|,
name|bfd_asymbol_name
argument_list|(
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
name|reloc
operator|->
name|howto
operator|->
name|name
argument_list|,
name|reloc
operator|->
name|addend
argument_list|,
name|input_section
operator|->
name|owner
argument_list|,
name|input_section
argument_list|,
name|reloc
operator|->
name|address
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Everything looks OK.  Apply the relocation and update the 	 src/dst address appropriately.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|gap
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
name|dst_address
operator|++
expr_stmt|;
name|src_address
operator|++
expr_stmt|;
comment|/* All done.  */
break|break;
comment|/* Generic 16-bit pc-relative relocation.  */
case|case
name|R_PCRWORD
case|:
comment|/* Get the address of the target of this branch.  */
name|value
operator|=
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
comment|/* Get the address of the instruction (not the reloc).  */
name|dot
operator|=
operator|(
name|link_order
operator|->
name|offset
operator|+
name|dst_address
operator|+
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
literal|1
operator|)
expr_stmt|;
name|gap
operator|=
name|value
operator|-
name|dot
expr_stmt|;
comment|/* Sanity check.  */
if|if
condition|(
name|gap
operator|>
literal|32766
operator|||
name|gap
operator|<
operator|-
literal|32768
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|link_info
argument_list|,
name|bfd_asymbol_name
argument_list|(
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
name|reloc
operator|->
name|howto
operator|->
name|name
argument_list|,
name|reloc
operator|->
name|addend
argument_list|,
name|input_section
operator|->
name|owner
argument_list|,
name|input_section
argument_list|,
name|reloc
operator|->
name|address
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Everything looks OK.  Apply the relocation and update the 	 src/dst address appropriately.  */
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|gap
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
name|dst_address
operator|+=
literal|2
expr_stmt|;
name|src_address
operator|+=
literal|2
expr_stmt|;
comment|/* All done.  */
break|break;
comment|/* Generic 8-bit absolute relocation.  */
case|case
name|R_RELBYTE
case|:
comment|/* Get the address of the object referenced by this insn.  */
name|value
operator|=
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|value
operator|&
literal|0xff
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
name|dst_address
operator|+=
literal|1
expr_stmt|;
name|src_address
operator|+=
literal|1
expr_stmt|;
comment|/* All done.  */
break|break;
comment|/* Various simple 16-bit absolute relocations.  */
case|case
name|R_MOV16B1
case|:
case|case
name|R_JMP1
case|:
case|case
name|R_RELWORD
case|:
name|value
operator|=
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
name|dst_address
operator|+=
literal|2
expr_stmt|;
name|src_address
operator|+=
literal|2
expr_stmt|;
break|break;
comment|/* Various simple 24-/32-bit absolute relocations.  */
case|case
name|R_MOV24B1
case|:
case|case
name|R_MOVL1
case|:
case|case
name|R_RELLONG
case|:
comment|/* Get the address of the target of this branch.  */
name|value
operator|=
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
name|dst_address
operator|+=
literal|4
expr_stmt|;
name|src_address
operator|+=
literal|4
expr_stmt|;
break|break;
comment|/* Another 24-/32-bit absolute relocation.  */
case|case
name|R_JMPL1
case|:
comment|/* Get the address of the target of this branch.  */
name|value
operator|=
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
operator|(
name|value
operator|&
literal|0x00ffffff
operator|)
operator||
operator|(
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|src_address
argument_list|)
operator|&
literal|0xff000000
operator|)
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
name|dst_address
operator|+=
literal|4
expr_stmt|;
name|src_address
operator|+=
literal|4
expr_stmt|;
break|break;
comment|/* This is a 24-/32-bit absolute address in one of the following 	 instructions:  	   "band", "bclr", "biand", "bild", "bior", "bist", "bixor", 	   "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", "ldc.w", 	   "stc.w" and "mov.[bwl]"  	 We may relax this into an 16-bit absolute address if it's in 	 the right range.  */
case|case
name|R_MOVL2
case|:
name|value
operator|=
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|value
operator|=
name|bfd_h8300_pad_address
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Sanity check.  */
if|if
condition|(
name|value
operator|<=
literal|0x7fff
operator|||
name|value
operator|>=
literal|0xffff8000u
condition|)
block|{
comment|/* Insert the 16-bit value into the proper location.  */
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
comment|/* Fix the opcode.  For all the instructions that belong to 	     this relaxation, we simply need to turn off bit 0x20 in 	     the previous byte.  */
name|data
index|[
name|dst_address
operator|-
literal|1
index|]
operator|&=
operator|~
literal|0x20
expr_stmt|;
name|dst_address
operator|+=
literal|2
expr_stmt|;
name|src_address
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|link_info
argument_list|,
name|bfd_asymbol_name
argument_list|(
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
name|reloc
operator|->
name|howto
operator|->
name|name
argument_list|,
name|reloc
operator|->
name|addend
argument_list|,
name|input_section
operator|->
name|owner
argument_list|,
name|input_section
argument_list|,
name|reloc
operator|->
name|address
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
comment|/* A 16-bit absolute branch that is now an 8-bit pc-relative branch.  */
case|case
name|R_JMP2
case|:
comment|/* Get the address of the target of this branch.  */
name|value
operator|=
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
comment|/* Get the address of the next instruction.  */
name|dot
operator|=
operator|(
name|link_order
operator|->
name|offset
operator|+
name|dst_address
operator|+
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
literal|1
operator|)
expr_stmt|;
name|gap
operator|=
name|value
operator|-
name|dot
expr_stmt|;
comment|/* Sanity check.  */
if|if
condition|(
name|gap
operator|<
operator|-
literal|128
operator|||
name|gap
operator|>
literal|126
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|link_info
argument_list|,
name|bfd_asymbol_name
argument_list|(
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
name|reloc
operator|->
name|howto
operator|->
name|name
argument_list|,
name|reloc
operator|->
name|addend
argument_list|,
name|input_section
operator|->
name|owner
argument_list|,
name|input_section
argument_list|,
name|reloc
operator|->
name|address
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Now fix the instruction itself.  */
switch|switch
condition|(
name|data
index|[
name|dst_address
operator|-
literal|1
index|]
condition|)
block|{
case|case
literal|0x5e
case|:
comment|/* jsr -> bsr */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x55
argument_list|,
name|data
operator|+
name|dst_address
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x5a
case|:
comment|/* jmp -> bra */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x40
argument_list|,
name|data
operator|+
name|dst_address
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Write out the 8-bit value.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|gap
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
name|dst_address
operator|+=
literal|1
expr_stmt|;
name|src_address
operator|+=
literal|3
expr_stmt|;
break|break;
comment|/* A 16-bit pc-relative branch that is now an 8-bit pc-relative branch.  */
case|case
name|R_PCRWORD_B
case|:
comment|/* Get the address of the target of this branch.  */
name|value
operator|=
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
comment|/* Get the address of the instruction (not the reloc).  */
name|dot
operator|=
operator|(
name|link_order
operator|->
name|offset
operator|+
name|dst_address
operator|+
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|-
literal|1
operator|)
expr_stmt|;
name|gap
operator|=
name|value
operator|-
name|dot
expr_stmt|;
comment|/* Sanity check.  */
if|if
condition|(
name|gap
operator|<
operator|-
literal|128
operator|||
name|gap
operator|>
literal|126
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|link_info
argument_list|,
name|bfd_asymbol_name
argument_list|(
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
name|reloc
operator|->
name|howto
operator|->
name|name
argument_list|,
name|reloc
operator|->
name|addend
argument_list|,
name|input_section
operator|->
name|owner
argument_list|,
name|input_section
argument_list|,
name|reloc
operator|->
name|address
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Now fix the instruction.  */
switch|switch
condition|(
name|data
index|[
name|dst_address
operator|-
literal|2
index|]
condition|)
block|{
case|case
literal|0x58
case|:
comment|/* bCC:16 -> bCC:8 */
comment|/* Get the second byte of the original insn, which contains 	     the condition code.  */
name|tmp
operator|=
name|data
index|[
name|dst_address
operator|-
literal|1
index|]
expr_stmt|;
comment|/* Compute the fisrt byte of the relaxed instruction.  The 	     original sequence 0x58 0xX0 is relaxed to 0x4X, where X 	     represents the condition code.  */
name|tmp
operator|&=
literal|0xf0
expr_stmt|;
name|tmp
operator|>>=
literal|4
expr_stmt|;
name|tmp
operator||=
literal|0x40
expr_stmt|;
comment|/* Write it.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|tmp
argument_list|,
name|data
operator|+
name|dst_address
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x5c
case|:
comment|/* bsr:16 -> bsr:8 */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x55
argument_list|,
name|data
operator|+
name|dst_address
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Output the target.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|gap
argument_list|,
name|data
operator|+
name|dst_address
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* We don't advance dst_address -- the 8-bit reloc is applied at 	 dst_address - 1, so the next insn should begin at dst_address.  */
name|src_address
operator|+=
literal|2
expr_stmt|;
break|break;
comment|/* Similarly for a 24-bit absolute that is now 8 bits.  */
case|case
name|R_JMPL2
case|:
comment|/* Get the address of the target of this branch.  */
name|value
operator|=
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
comment|/* Get the address of the instruction (not the reloc).  */
name|dot
operator|=
operator|(
name|link_order
operator|->
name|offset
operator|+
name|dst_address
operator|+
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
literal|2
operator|)
expr_stmt|;
name|gap
operator|=
name|value
operator|-
name|dot
expr_stmt|;
comment|/* Fix the instruction.  */
switch|switch
condition|(
name|data
index|[
name|src_address
index|]
condition|)
block|{
case|case
literal|0x5e
case|:
comment|/* jsr -> bsr */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x55
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x5a
case|:
comment|/* jmp ->bra */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x40
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|gap
argument_list|,
name|data
operator|+
name|dst_address
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dst_address
operator|+=
literal|2
expr_stmt|;
name|src_address
operator|+=
literal|4
expr_stmt|;
break|break;
comment|/* This is a 16-bit absolute address in one of the following 	 instructions:  	   "band", "bclr", "biand", "bild", "bior", "bist", "bixor", 	   "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", and 	   "mov.b"  	 We may relax this into an 8-bit absolute address if it's in 	 the right range.  */
case|case
name|R_MOV16B2
case|:
name|value
operator|=
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
comment|/* All instructions with R_H8_DIR16B2 start with 0x6a.  */
if|if
condition|(
name|data
index|[
name|dst_address
operator|-
literal|2
index|]
operator|!=
literal|0x6a
condition|)
name|abort
argument_list|()
expr_stmt|;
name|temp_code
operator|=
name|data
index|[
name|src_address
operator|-
literal|1
index|]
expr_stmt|;
comment|/* If this is a mov.b instruction, clear the lower nibble, which 	 contains the source/destination register number.  */
if|if
condition|(
operator|(
name|temp_code
operator|&
literal|0x10
operator|)
operator|!=
literal|0x10
condition|)
name|temp_code
operator|&=
literal|0xf0
expr_stmt|;
comment|/* Fix up the opcode.  */
switch|switch
condition|(
name|temp_code
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* This is mov.b @aa:16,Rd.  */
name|data
index|[
name|dst_address
operator|-
literal|2
index|]
operator|=
operator|(
name|data
index|[
name|src_address
operator|-
literal|1
index|]
operator|&
literal|0xf
operator|)
operator||
literal|0x20
expr_stmt|;
break|break;
case|case
literal|0x80
case|:
comment|/* This is mov.b Rs,@aa:16.  */
name|data
index|[
name|dst_address
operator|-
literal|2
index|]
operator|=
operator|(
name|data
index|[
name|src_address
operator|-
literal|1
index|]
operator|&
literal|0xf
operator|)
operator||
literal|0x30
expr_stmt|;
break|break;
case|case
literal|0x18
case|:
comment|/* This is a bit-maniputation instruction that stores one 	     bit into memory, one of "bclr", "bist", "bnot", "bset", 	     and "bst".  */
name|data
index|[
name|dst_address
operator|-
literal|2
index|]
operator|=
literal|0x7f
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
comment|/* This is a bit-maniputation instruction that loads one bit 	     from memory, one of "band", "biand", "bild", "bior", 	     "bixor", "bld", "bor", "btst", and "bxor".  */
name|data
index|[
name|dst_address
operator|-
literal|2
index|]
operator|=
literal|0x7e
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|value
operator|&
literal|0xff
argument_list|,
name|data
operator|+
name|dst_address
operator|-
literal|1
argument_list|)
expr_stmt|;
name|src_address
operator|+=
literal|2
expr_stmt|;
break|break;
comment|/* This is a 24-bit absolute address in one of the following 	 instructions:  	   "band", "bclr", "biand", "bild", "bior", "bist", "bixor", 	   "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", and 	   "mov.b"  	 We may relax this into an 8-bit absolute address if it's in 	 the right range.  */
case|case
name|R_MOV24B2
case|:
name|value
operator|=
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
comment|/* All instructions with R_MOV24B2 start with 0x6a.  */
if|if
condition|(
name|data
index|[
name|dst_address
operator|-
literal|2
index|]
operator|!=
literal|0x6a
condition|)
name|abort
argument_list|()
expr_stmt|;
name|temp_code
operator|=
name|data
index|[
name|src_address
operator|-
literal|1
index|]
expr_stmt|;
comment|/* If this is a mov.b instruction, clear the lower nibble, which 	 contains the source/destination register number.  */
if|if
condition|(
operator|(
name|temp_code
operator|&
literal|0x30
operator|)
operator|!=
literal|0x30
condition|)
name|temp_code
operator|&=
literal|0xf0
expr_stmt|;
comment|/* Fix up the opcode.  */
switch|switch
condition|(
name|temp_code
condition|)
block|{
case|case
literal|0x20
case|:
comment|/* This is mov.b @aa:24/32,Rd.  */
name|data
index|[
name|dst_address
operator|-
literal|2
index|]
operator|=
operator|(
name|data
index|[
name|src_address
operator|-
literal|1
index|]
operator|&
literal|0xf
operator|)
operator||
literal|0x20
expr_stmt|;
break|break;
case|case
literal|0xa0
case|:
comment|/* This is mov.b Rs,@aa:24/32.  */
name|data
index|[
name|dst_address
operator|-
literal|2
index|]
operator|=
operator|(
name|data
index|[
name|src_address
operator|-
literal|1
index|]
operator|&
literal|0xf
operator|)
operator||
literal|0x30
expr_stmt|;
break|break;
case|case
literal|0x38
case|:
comment|/* This is a bit-maniputation instruction that stores one 	     bit into memory, one of "bclr", "bist", "bnot", "bset", 	     and "bst".  */
name|data
index|[
name|dst_address
operator|-
literal|2
index|]
operator|=
literal|0x7f
expr_stmt|;
break|break;
case|case
literal|0x30
case|:
comment|/* This is a bit-maniputation instruction that loads one bit 	     from memory, one of "band", "biand", "bild", "bior", 	     "bixor", "bld", "bor", "btst", and "bxor".  */
name|data
index|[
name|dst_address
operator|-
literal|2
index|]
operator|=
literal|0x7e
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|value
operator|&
literal|0xff
argument_list|,
name|data
operator|+
name|dst_address
operator|-
literal|1
argument_list|)
expr_stmt|;
name|src_address
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|R_BCC_INV
case|:
comment|/* Get the address of the target of this branch.  */
name|value
operator|=
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
name|dot
operator|=
operator|(
name|link_order
operator|->
name|offset
operator|+
name|dst_address
operator|+
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
operator|+
literal|1
expr_stmt|;
name|gap
operator|=
name|value
operator|-
name|dot
expr_stmt|;
comment|/* Sanity check.  */
if|if
condition|(
name|gap
operator|<
operator|-
literal|128
operator|||
name|gap
operator|>
literal|126
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|link_info
argument_list|,
name|bfd_asymbol_name
argument_list|(
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
name|reloc
operator|->
name|howto
operator|->
name|name
argument_list|,
name|reloc
operator|->
name|addend
argument_list|,
name|input_section
operator|->
name|owner
argument_list|,
name|input_section
argument_list|,
name|reloc
operator|->
name|address
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Everything looks OK.  Fix the condition in the instruction, apply 	 the relocation, and update the src/dst address appropriately.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|dst_address
operator|-
literal|1
argument_list|)
operator|^
literal|1
argument_list|,
name|data
operator|+
name|dst_address
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|gap
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
name|dst_address
operator|++
expr_stmt|;
name|src_address
operator|++
expr_stmt|;
comment|/* All done.  */
break|break;
case|case
name|R_JMP_DEL
case|:
name|src_address
operator|+=
literal|4
expr_stmt|;
break|break;
comment|/* An 8-bit memory indirect instruction (jmp/jsr).         There's several things that need to be done to handle        this relocation.         If this is a reloc against the absolute symbol, then        we should handle it just R_RELBYTE.  Likewise if it's        for a symbol with a value ge 0 and le 0xff.         Otherwise it's a jump/call through the function vector,        and the linker is expected to set up the function vector        and put the right value into the jump/call instruction.  */
case|case
name|R_MEM_INDIRECT
case|:
block|{
comment|/* We need to find the symbol so we can determine it's 	   address in the function vector table.  */
name|asymbol
modifier|*
name|symbol
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|funcvec_hash_table
modifier|*
name|ftab
decl_stmt|;
name|struct
name|funcvec_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|h8300_coff_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|asection
modifier|*
name|vectors_sec
decl_stmt|;
if|if
condition|(
name|link_info
operator|->
name|hash
operator|->
name|creator
operator|!=
name|abfd
operator|->
name|xvec
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"cannot handle R_MEM_INDIRECT reloc when using %s output"
argument_list|)
argument_list|,
name|link_info
operator|->
name|hash
operator|->
name|creator
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* What else can we do?  This function doesn't allow return 	       of an error, and we don't want to call abort as that 	       indicates an internal error.  */
ifndef|#
directive|ifndef
name|EXIT_FAILURE
define|#
directive|define
name|EXIT_FAILURE
value|1
endif|#
directive|endif
name|xexit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|htab
operator|=
name|h8300_coff_hash_table
argument_list|(
name|link_info
argument_list|)
expr_stmt|;
name|vectors_sec
operator|=
name|htab
operator|->
name|vectors_sec
expr_stmt|;
comment|/* First see if this is a reloc against the absolute symbol 	   or against a symbol with a nonnegative value<= 0xff.  */
name|symbol
operator|=
operator|*
operator|(
name|reloc
operator|->
name|sym_ptr_ptr
operator|)
expr_stmt|;
name|value
operator|=
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
operator|==
name|bfd_abs_section_ptr
operator|->
name|symbol
operator|||
name|value
operator|<=
literal|0xff
condition|)
block|{
comment|/* This should be handled in a manner very similar to 	       R_RELBYTES.   If the value is in range, then just slam 	       the value into the right location.  Else trigger a 	       reloc overflow callback.  */
if|if
condition|(
name|value
operator|<=
literal|0xff
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
name|dst_address
operator|+=
literal|1
expr_stmt|;
name|src_address
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|link_info
argument_list|,
name|bfd_asymbol_name
argument_list|(
operator|*
name|reloc
operator|->
name|sym_ptr_ptr
argument_list|)
argument_list|,
name|reloc
operator|->
name|howto
operator|->
name|name
argument_list|,
name|reloc
operator|->
name|addend
argument_list|,
name|input_section
operator|->
name|owner
argument_list|,
name|input_section
argument_list|,
name|reloc
operator|->
name|address
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
comment|/* This is a jump/call through a function vector, and we're 	   expected to create the function vector ourselves.  	   First look up this symbol in the linker hash table -- we need 	   the derived linker symbol which holds this symbol's index 	   in the function vector.  */
name|name
operator|=
name|symbol
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_LOCAL
condition|)
block|{
name|char
modifier|*
name|new_name
init|=
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|9
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_name
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
name|new_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new_name
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"_%08x"
argument_list|,
operator|(
name|int
operator|)
name|symbol
operator|->
name|section
argument_list|)
expr_stmt|;
name|name
operator|=
name|new_name
expr_stmt|;
block|}
name|ftab
operator|=
name|htab
operator|->
name|funcvec_hash_table
expr_stmt|;
name|h
operator|=
name|funcvec_hash_lookup
argument_list|(
name|ftab
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* This shouldn't ever happen.  If it does that means we've got 	   data corruption of some kind.  Aborting seems like a reasonable 	   thing to do here.  */
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|vectors_sec
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Place the address of the function vector entry into the 	   reloc's address.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|vectors_sec
operator|->
name|output_offset
operator|+
name|h
operator|->
name|offset
argument_list|,
name|data
operator|+
name|dst_address
argument_list|)
expr_stmt|;
name|dst_address
operator|++
expr_stmt|;
name|src_address
operator|++
expr_stmt|;
comment|/* Now create an entry in the function vector itself.  */
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|input_section
operator|->
name|owner
argument_list|)
condition|)
block|{
case|case
name|bfd_mach_h8300
case|:
case|case
name|bfd_mach_h8300hn
case|:
case|case
name|bfd_mach_h8300sn
case|:
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
argument_list|,
name|vectors_sec
operator|->
name|contents
operator|+
name|h
operator|->
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_mach_h8300h
case|:
case|case
name|bfd_mach_h8300s
case|:
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|bfd_coff_reloc16_get_value
argument_list|(
name|reloc
argument_list|,
name|link_info
argument_list|,
name|input_section
argument_list|)
argument_list|,
name|vectors_sec
operator|->
name|contents
operator|+
name|h
operator|->
name|offset
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Gross.  We've already written the contents of the vector section 	   before we get here...  So we write it again with the new data.  */
name|bfd_set_section_contents
argument_list|(
name|vectors_sec
operator|->
name|output_section
operator|->
name|owner
argument_list|,
name|vectors_sec
operator|->
name|output_section
argument_list|,
name|vectors_sec
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
name|vectors_sec
operator|->
name|output_offset
argument_list|,
name|vectors_sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
operator|*
name|src_ptr
operator|=
name|src_address
expr_stmt|;
operator|*
name|dst_ptr
operator|=
name|dst_address
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Routine for the h8300 linker.     This routine is necessary to handle the special R_MEM_INDIRECT    relocs on the h8300.  It's responsible for generating a vectors    section and attaching it to an input bfd as well as sizing    the vectors section.  It also creates our vectors hash table.     It uses the generic linker routines to actually add the symbols.    from this BFD to the bfd linker hash table.  It may add a few    selected static symbols to the bfd linker hash table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|h8300_bfd_link_add_symbols
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|funcvec_hash_table
modifier|*
name|funcvec_hash_table
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|struct
name|h8300_coff_link_hash_table
modifier|*
name|htab
decl_stmt|;
comment|/* Add the symbols using the generic code.  */
name|_bfd_generic_link_add_symbols
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|!=
name|abfd
operator|->
name|xvec
condition|)
return|return
name|TRUE
return|;
name|htab
operator|=
name|h8300_coff_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* If we haven't created a vectors section, do so now.  */
if|if
condition|(
operator|!
name|htab
operator|->
name|vectors_sec
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
comment|/* Make sure the appropriate flags are set, including SEC_IN_MEMORY.  */
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_READONLY
operator|)
expr_stmt|;
name|htab
operator|->
name|vectors_sec
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".vectors"
argument_list|)
expr_stmt|;
comment|/* If the section wasn't created, or we couldn't set the flags, 	 quit quickly now, rather than dying a painful death later.  */
if|if
condition|(
operator|!
name|htab
operator|->
name|vectors_sec
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|htab
operator|->
name|vectors_sec
argument_list|,
name|flags
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Also create the vector hash table.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|funcvec_hash_table
argument_list|)
expr_stmt|;
name|funcvec_hash_table
operator|=
operator|(
expr|struct
name|funcvec_hash_table
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|funcvec_hash_table
condition|)
return|return
name|FALSE
return|;
comment|/* And initialize the funcvec hash table.  */
if|if
condition|(
operator|!
name|funcvec_hash_table_init
argument_list|(
name|funcvec_hash_table
argument_list|,
name|abfd
argument_list|,
name|funcvec_hash_newfunc
argument_list|)
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|funcvec_hash_table
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Store away a pointer to the funcvec hash table.  */
name|htab
operator|->
name|funcvec_hash_table
operator|=
name|funcvec_hash_table
expr_stmt|;
block|}
comment|/* Load up the function vector hash table.  */
name|funcvec_hash_table
operator|=
name|htab
operator|->
name|funcvec_hash_table
expr_stmt|;
comment|/* Now scan the relocs for all the sections in this bfd; create      additional space in the .vectors section as needed.  */
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|long
name|reloc_size
decl_stmt|,
name|reloc_count
decl_stmt|,
name|i
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relocs
decl_stmt|;
comment|/* Suck in the relocs, symbols& canonicalize them.  */
name|reloc_size
operator|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_size
operator|<=
literal|0
condition|)
continue|continue;
name|relocs
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|reloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|relocs
condition|)
return|return
name|FALSE
return|;
comment|/* The symbols should have been read in by _bfd_generic link_add_symbols 	 call abovec, so we can cheat and use the pointer to them that was 	 saved in the above call.  */
name|symbols
operator|=
name|_bfd_generic_link_get_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|reloc_count
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|relocs
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_count
operator|<=
literal|0
condition|)
block|{
name|free
argument_list|(
name|relocs
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Now walk through all the relocations in this section.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reloc_count
condition|;
name|i
operator|++
control|)
block|{
name|arelent
modifier|*
name|reloc
init|=
name|relocs
index|[
name|i
index|]
decl_stmt|;
name|asymbol
modifier|*
name|symbol
init|=
operator|*
operator|(
name|reloc
operator|->
name|sym_ptr_ptr
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* We've got an indirect reloc.  See if we need to add it 	     to the function vector table.   At this point, we have 	     to add a new entry for each unique symbol referenced 	     by an R_MEM_INDIRECT relocation except for a reloc 	     against the absolute section symbol.  */
if|if
condition|(
name|reloc
operator|->
name|howto
operator|->
name|type
operator|==
name|R_MEM_INDIRECT
operator|&&
name|symbol
operator|!=
name|bfd_abs_section_ptr
operator|->
name|symbol
condition|)
block|{
name|struct
name|funcvec_hash_table
modifier|*
name|ftab
decl_stmt|;
name|struct
name|funcvec_hash_entry
modifier|*
name|h
decl_stmt|;
name|name
operator|=
name|symbol
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_LOCAL
condition|)
block|{
name|char
modifier|*
name|new_name
decl_stmt|;
name|new_name
operator|=
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|9
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_name
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
name|new_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new_name
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"_%08x"
argument_list|,
operator|(
name|int
operator|)
name|symbol
operator|->
name|section
argument_list|)
expr_stmt|;
name|name
operator|=
name|new_name
expr_stmt|;
block|}
comment|/* Look this symbol up in the function vector hash table.  */
name|ftab
operator|=
name|htab
operator|->
name|funcvec_hash_table
expr_stmt|;
name|h
operator|=
name|funcvec_hash_lookup
argument_list|(
name|ftab
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* If this symbol isn't already in the hash table, add 		 it and bump up the size of the hash table.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
name|h
operator|=
name|funcvec_hash_lookup
argument_list|(
name|ftab
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|relocs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Bump the size of the vectors section.  Each vector 		     takes 2 bytes on the h8300 and 4 bytes on the h8300h.  */
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_mach_h8300
case|:
case|case
name|bfd_mach_h8300hn
case|:
case|case
name|bfd_mach_h8300sn
case|:
name|htab
operator|->
name|vectors_sec
operator|->
name|_raw_size
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|bfd_mach_h8300h
case|:
case|case
name|bfd_mach_h8300s
case|:
name|htab
operator|->
name|vectors_sec
operator|->
name|_raw_size
operator|+=
literal|4
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* We're done with the relocations, release them.  */
name|free
argument_list|(
name|relocs
argument_list|)
expr_stmt|;
block|}
comment|/* Now actually allocate some space for the function vector.  It's      wasteful to do this more than once, but this is easier.  */
name|sec
operator|=
name|htab
operator|->
name|vectors_sec
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
comment|/* Free the old contents.  */
if|if
condition|(
name|sec
operator|->
name|contents
condition|)
name|free
argument_list|(
name|sec
operator|->
name|contents
argument_list|)
expr_stmt|;
comment|/* Allocate new contents.  */
name|sec
operator|->
name|contents
operator|=
name|bfd_malloc
argument_list|(
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_define
define|#
directive|define
name|coff_reloc16_extra_cases
value|h8300_reloc16_extra_cases
end_define

begin_define
define|#
directive|define
name|coff_reloc16_estimate
value|h8300_reloc16_estimate
end_define

begin_define
define|#
directive|define
name|coff_bfd_link_add_symbols
value|h8300_bfd_link_add_symbols
end_define

begin_define
define|#
directive|define
name|coff_bfd_link_hash_table_create
value|h8300_coff_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|COFF_LONG_FILENAMES
end_define

begin_include
include|#
directive|include
file|"coffcode.h"
end_include

begin_undef
undef|#
directive|undef
name|coff_bfd_get_relocated_section_contents
end_undef

begin_undef
undef|#
directive|undef
name|coff_bfd_relax_section
end_undef

begin_define
define|#
directive|define
name|coff_bfd_get_relocated_section_contents
define|\
value|bfd_coff_reloc16_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|coff_bfd_relax_section
value|bfd_coff_reloc16_relax_section
end_define

begin_macro
name|CREATE_BIG_COFF_TARGET_VEC
argument_list|(
argument|h8300coff_vec
argument_list|,
literal|"coff-h8300"
argument_list|,
argument|BFD_IS_RELAXABLE
argument_list|,
literal|0
argument_list|,
literal|'_'
argument_list|,
argument|NULL
argument_list|,
argument|COFF_SWAP_TABLE
argument_list|)
end_macro

end_unit

