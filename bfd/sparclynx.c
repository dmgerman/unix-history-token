begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD support for Sparc binaries under LynxOS.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1997, 1998, 2000,    2001, 2002, 2003 Free Software Foundation, Inc.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|N_SHARED_LIB
parameter_list|(
name|x
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|TEXT_START_ADDR
value|0
end_define

begin_define
define|#
directive|define
name|TARGET_PAGE_SIZE
value|4096
end_define

begin_define
define|#
directive|define
name|SEGMENT_SIZE
value|TARGET_PAGE_SIZE
end_define

begin_define
define|#
directive|define
name|DEFAULT_ARCH
value|bfd_arch_sparc
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Do not "beautify" the CONCAT* macro args.  Traditional C will not    remove whitespace added here, and thus will fail to concatenate    the tokens.  */
end_comment

begin_define
define|#
directive|define
name|MY
parameter_list|(
name|OP
parameter_list|)
value|CONCAT2 (sparclynx_aout_,OP)
end_define

begin_define
define|#
directive|define
name|TARGETNAME
value|"a.out-sparc-lynx"
end_define

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"aout/sun4.h"
end_include

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_comment
comment|/* BFD a.out internal data structures */
end_comment

begin_include
include|#
directive|include
file|"aout/aout64.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_include
include|#
directive|include
file|"aout/ar.h"
end_include

begin_function_decl
name|void
name|NAME
parameter_list|(
name|lynx
parameter_list|,
name|set_arch_mach
parameter_list|)
function_decl|PARAMS
parameter_list|(
function_decl|(bfd *
operator|,
function_decl|unsigned long
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|static
name|void
name|choose_reloc_size
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|bfd_boolean
name|NAME
parameter_list|(
name|aout
parameter_list|,
name|sparclynx_write_object_contents
parameter_list|)
function_decl|PARAMS
parameter_list|(
function_decl|(bfd *
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* This is needed to reject a NewsOS file, e.g. in    gdb/testsuite/gdb.t10/crossload.exp.<kingdon@cygnus.com>    I needed to add M_UNKNOWN to recognize a 68000 object, so this will    probably no longer reject a NewsOS object.<ian@cygnus.com>.  */
end_comment

begin_define
define|#
directive|define
name|MACHTYPE_OK
parameter_list|(
name|mtype
parameter_list|)
value|((mtype) == M_UNKNOWN \ 			    || (mtype) == M_68010 \ 			    || (mtype) == M_68020 \ 			    || (mtype) == M_SPARC)
end_define

begin_comment
comment|/* The file @code{aoutf1.h} contains the code for BFD's    a.out back end. Control over the generated back end is given by these    two preprocessor names:    @table @code    @item ARCH_SIZE    This value should be either 32 or 64, depending upon the size of an    int in the target format. It changes the sizes of the structs which    perform the memory/disk mapping of structures.     The 64 bit backend may only be used if the host compiler supports 64    ints (eg long long with gcc), by defining the name @code{BFD_HOST_64_BIT} in @code{bfd.h}.    With this name defined, @emph{all} bfd operations are performed with 64bit    arithmetic, not just those to a 64bit target.     @item TARGETNAME    The name put into the target vector.    @item    @end table  */
end_comment

begin_decl_stmt
name|void
name|NAME
argument_list|(
name|lynx
argument_list|,
name|set_arch_mach
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|machtype
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|machtype
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Determine the architecture and machine type of the object file.  */
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
name|unsigned
name|long
name|machine
decl_stmt|;
switch|switch
condition|(
name|machtype
condition|)
block|{
case|case
name|M_UNKNOWN
case|:
comment|/* Some Sun3s make magic numbers without cpu types in them, so 	 we'll default to the 68000.  */
name|arch
operator|=
name|bfd_arch_m68k
expr_stmt|;
name|machine
operator|=
name|bfd_mach_m68000
expr_stmt|;
break|break;
case|case
name|M_68010
case|:
case|case
name|M_HP200
case|:
name|arch
operator|=
name|bfd_arch_m68k
expr_stmt|;
name|machine
operator|=
name|bfd_mach_m68010
expr_stmt|;
break|break;
case|case
name|M_68020
case|:
case|case
name|M_HP300
case|:
name|arch
operator|=
name|bfd_arch_m68k
expr_stmt|;
name|machine
operator|=
name|bfd_mach_m68020
expr_stmt|;
break|break;
case|case
name|M_SPARC
case|:
name|arch
operator|=
name|bfd_arch_sparc
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|M_386
case|:
case|case
name|M_386_DYNIX
case|:
name|arch
operator|=
name|bfd_arch_i386
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|M_29K
case|:
name|arch
operator|=
name|bfd_arch_a29k
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|M_HPUX
case|:
name|arch
operator|=
name|bfd_arch_m68k
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|arch
operator|=
name|bfd_arch_obscure
expr_stmt|;
name|machine
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|SET_ARCH_MACH
parameter_list|(
name|ABFD
parameter_list|,
name|EXEC
parameter_list|)
define|\
value|NAME(lynx,set_arch_mach) (ABFD, N_MACHTYPE (EXEC)); \   choose_reloc_size(ABFD);
end_define

begin_comment
comment|/* Determine the size of a relocation entry, based on the architecture.  */
end_comment

begin_function
specifier|static
name|void
name|choose_reloc_size
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_arch_sparc
case|:
case|case
name|bfd_arch_a29k
case|:
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|RELOC_EXT_SIZE
expr_stmt|;
break|break;
default|default:
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|RELOC_STD_SIZE
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Write an object file in LynxOS format.   Section contents have already been written.  We write the   file header, symbols, and relocation.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|NAME
argument_list|(
name|aout
argument_list|,
name|sparclynx_write_object_contents
argument_list|)
argument_list|(
name|abfd
argument_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|external_exec
name|exec_bytes
decl_stmt|;
name|struct
name|internal_exec
modifier|*
name|execp
init|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
comment|/* Magic number, maestro, please!  */
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_arch_m68k
case|:
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_mach_m68010
case|:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_68010
argument_list|)
expr_stmt|;
break|break;
default|default:
case|case
name|bfd_mach_m68020
case|:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_68020
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|bfd_arch_sparc
case|:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_SPARC
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_arch_i386
case|:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_386
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_arch_a29k
case|:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_29K
argument_list|)
expr_stmt|;
break|break;
default|default:
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_UNKNOWN
argument_list|)
expr_stmt|;
block|}
name|choose_reloc_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|N_SET_FLAGS
argument_list|(
operator|*
name|execp
argument_list|,
name|aout_backend_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|exec_hdr_flags
argument_list|)
expr_stmt|;
name|WRITE_HEADERS
argument_list|(
name|abfd
argument_list|,
name|execp
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block

begin_define
define|#
directive|define
name|MY_set_sizes
value|sparclynx_set_sizes
end_define

begin_decl_stmt
specifier|static
name|bfd_boolean
name|sparclynx_set_sizes
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_boolean
name|sparclynx_set_sizes
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
case|case
name|bfd_arch_sparc
case|:
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|page_size
operator|=
literal|0x2000
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|segment_size
operator|=
literal|0x2000
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|exec_bytes_size
operator|=
name|EXEC_BYTES_SIZE
expr_stmt|;
return|return
name|TRUE
return|;
case|case
name|bfd_arch_m68k
case|:
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|page_size
operator|=
literal|0x2000
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|segment_size
operator|=
literal|0x20000
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|exec_bytes_size
operator|=
name|EXEC_BYTES_SIZE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|aout_backend_data
name|sparclynx_aout_backend
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
name|sparclynx_set_sizes
block|,
literal|0
block|,
literal|0
block|,
comment|/* add_dynamic_symbols */
literal|0
block|,
comment|/* add_one_symbol */
literal|0
block|,
comment|/* link_dynamic_object */
literal|0
block|,
comment|/* write_dynamic_symbol */
literal|0
block|,
comment|/* check_dynamic_reloc */
literal|0
comment|/* finish_dynamic_link */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_define
define|#
directive|define
name|MY_bfd_debug_info_start
value|bfd_void
end_define

begin_define
define|#
directive|define
name|MY_bfd_debug_info_end
value|bfd_void
end_define

begin_define
define|#
directive|define
name|MY_bfd_debug_info_accumulate
define|\
value|(void (*) PARAMS ((bfd *, struct bfd_section *))) bfd_void
end_define

begin_define
define|#
directive|define
name|MY_write_object_contents
value|NAME(aout,sparclynx_write_object_contents)
end_define

begin_define
define|#
directive|define
name|MY_backend_data
value|&sparclynx_aout_backend
end_define

begin_define
define|#
directive|define
name|TARGET_IS_BIG_ENDIAN_P
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|LYNX_CORE
end_ifdef

begin_function_decl
name|char
modifier|*
name|lynx_core_file_failing_command
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|lynx_core_file_failing_signal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|bfd_boolean
name|lynx_core_file_matches_executable_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|bfd_target
modifier|*
name|lynx_core_file_p
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MY_core_file_failing_command
value|lynx_core_file_failing_command
end_define

begin_define
define|#
directive|define
name|MY_core_file_failing_signal
value|lynx_core_file_failing_signal
end_define

begin_define
define|#
directive|define
name|MY_core_file_matches_executable_p
value|lynx_core_file_matches_executable_p
end_define

begin_define
define|#
directive|define
name|MY_core_file_p
value|lynx_core_file_p
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LYNX_CORE */
end_comment

begin_include
include|#
directive|include
file|"aout-target.h"
end_include

end_unit

