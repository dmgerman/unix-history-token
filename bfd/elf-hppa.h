begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Common code for PA ELF implementations.    Copyright 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_define
define|#
directive|define
name|ELF_HOWTO_TABLE_SIZE
value|R_PARISC_UNIMPLEMENTED + 1
end_define

begin_comment
comment|/* This file is included by multiple PA ELF BFD backends with different    sizes.     Most of the routines are written to be size independent, but sometimes    external constraints require 32 or 64 bit specific code.  We remap    the definitions/functions as necessary here.  */
end_comment

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|64
end_if

begin_define
define|#
directive|define
name|ELF_R_TYPE
parameter_list|(
name|X
parameter_list|)
value|ELF64_R_TYPE(X)
end_define

begin_define
define|#
directive|define
name|ELF_R_SYM
parameter_list|(
name|X
parameter_list|)
value|ELF64_R_SYM(X)
end_define

begin_define
define|#
directive|define
name|elf_hppa_reloc_final_type
value|elf64_hppa_reloc_final_type
end_define

begin_define
define|#
directive|define
name|_bfd_elf_hppa_gen_reloc_type
value|_bfd_elf64_hppa_gen_reloc_type
end_define

begin_define
define|#
directive|define
name|elf_hppa_relocate_section
value|elf64_hppa_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_hppa_final_link
value|elf64_hppa_final_link
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|32
end_if

begin_define
define|#
directive|define
name|ELF_R_TYPE
parameter_list|(
name|X
parameter_list|)
value|ELF32_R_TYPE(X)
end_define

begin_define
define|#
directive|define
name|ELF_R_SYM
parameter_list|(
name|X
parameter_list|)
value|ELF32_R_SYM(X)
end_define

begin_define
define|#
directive|define
name|elf_hppa_reloc_final_type
value|elf32_hppa_reloc_final_type
end_define

begin_define
define|#
directive|define
name|_bfd_elf_hppa_gen_reloc_type
value|_bfd_elf32_hppa_gen_reloc_type
end_define

begin_define
define|#
directive|define
name|elf_hppa_relocate_section
value|elf32_hppa_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_hppa_final_link
value|elf32_hppa_final_link
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|64
end_if

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|elf_hppa_final_link_relocate
parameter_list|(
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
parameter_list|,
name|struct
name|elf64_hppa_dyn_hash_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|elf_hppa_relocate_insn
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ELF/PA relocation howto entries.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_hppa_howto_table
index|[
name|ELF_HOWTO_TABLE_SIZE
index|]
init|=
block|{
block|{
name|R_PARISC_NONE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_NONE"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* The values in DIR32 are to placate the check in      _bfd_stab_section_find_nearest_line.  */
block|{
name|R_PARISC_DIR32
block|,
literal|0
block|,
literal|2
block|,
literal|32
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DIR32"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0xffffffff
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_DIR21L
block|,
literal|0
block|,
literal|0
block|,
literal|21
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DIR21L"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_DIR17R
block|,
literal|0
block|,
literal|0
block|,
literal|17
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DIR17R"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_DIR17F
block|,
literal|0
block|,
literal|0
block|,
literal|17
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DIR17F"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_DIR14R
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DIR14R"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_DIR14F
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DIR14F"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 8 */
block|{
name|R_PARISC_PCREL12F
block|,
literal|0
block|,
literal|0
block|,
literal|12
block|,
name|TRUE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PCREL12F"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_PCREL32
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|TRUE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PCREL32"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_PCREL21L
block|,
literal|0
block|,
literal|0
block|,
literal|21
block|,
name|TRUE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PCREL21L"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_PCREL17R
block|,
literal|0
block|,
literal|0
block|,
literal|17
block|,
name|TRUE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PCREL17R"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_PCREL17F
block|,
literal|0
block|,
literal|0
block|,
literal|17
block|,
name|TRUE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PCREL17F"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_PCREL17C
block|,
literal|0
block|,
literal|0
block|,
literal|17
block|,
name|TRUE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PCREL17C"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_PCREL14R
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|TRUE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PCREL14R"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_PCREL14F
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|TRUE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PCREL14F"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 16 */
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_DPREL21L
block|,
literal|0
block|,
literal|0
block|,
literal|21
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DPREL21L"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_DPREL14WR
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DPREL14WR"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_DPREL14DR
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DPREL14DR"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_DPREL14R
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DPREL14R"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_DPREL14F
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DPREL14F"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 24 */
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_DLTREL21L
block|,
literal|0
block|,
literal|0
block|,
literal|21
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DLTREL21L"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_DLTREL14R
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DLTREL14R"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_DLTREL14F
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DLTREL14F"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 32 */
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_DLTIND21L
block|,
literal|0
block|,
literal|0
block|,
literal|21
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DLTIND21L"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_DLTIND14R
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DLTIND14R"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_DLTIND14F
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DLTIND14F"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 40 */
block|{
name|R_PARISC_SETBASE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_SETBASE"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_SECREL32
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_SECREL32"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_BASEREL21L
block|,
literal|0
block|,
literal|0
block|,
literal|21
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_BASEREL21L"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_BASEREL17R
block|,
literal|0
block|,
literal|0
block|,
literal|17
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_BASEREL17R"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_BASEREL17F
block|,
literal|0
block|,
literal|0
block|,
literal|17
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_BASEREL17F"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_BASEREL14R
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_BASEREL14R"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_BASEREL14F
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_BASEREL14F"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 48 */
block|{
name|R_PARISC_SEGBASE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_SEGBASE"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_SEGREL32
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_SEGREL32"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_PLTOFF21L
block|,
literal|0
block|,
literal|0
block|,
literal|21
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PLTOFF21L"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_PLTOFF14R
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PLTOFF14R"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_PLTOFF14F
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PLTOFF14F"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 56 */
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_LTOFF_FPTR32
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_LTOFF_FPTR32"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_LTOFF_FPTR21L
block|,
literal|0
block|,
literal|0
block|,
literal|21
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_LTOFF_FPTR21L"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_LTOFF_FPTR14R
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_LTOFF_FPTR14R"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 64 */
block|{
name|R_PARISC_FPTR64
block|,
literal|0
block|,
literal|0
block|,
literal|64
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_FPTR64"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_PLABEL32
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PLABEL32"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_PLABEL21L
block|,
literal|0
block|,
literal|0
block|,
literal|21
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PLABEL21L"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_PLABEL14R
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PLABEL14R"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 72 */
block|{
name|R_PARISC_PCREL64
block|,
literal|0
block|,
literal|0
block|,
literal|64
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PCREL64"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_PCREL22C
block|,
literal|0
block|,
literal|0
block|,
literal|22
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PCREL22C"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_PCREL22F
block|,
literal|0
block|,
literal|0
block|,
literal|22
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PCREL22F"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_PCREL14WR
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PCREL14WR"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_PCREL14DR
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PCREL14DR"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_PCREL16F
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PCREL16F"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_PCREL16WF
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PCREL16WF"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_PCREL16DF
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PCREL16DF"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 80 */
block|{
name|R_PARISC_DIR64
block|,
literal|0
block|,
literal|0
block|,
literal|64
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DIR64"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_DIR14WR
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DIR14WR"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_DIR14DR
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DIR14DR"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_DIR16F
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DIR16F"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_DIR16WF
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DIR16WF"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_DIR16DF
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DIR16DF"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 88 */
block|{
name|R_PARISC_GPREL64
block|,
literal|0
block|,
literal|0
block|,
literal|64
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_GPREL64"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_DLTREL14WR
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DLTREL14WR"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_DLTREL14DR
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DLTREL14DR"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_GPREL16F
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_GPREL16F"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_GPREL16WF
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_GPREL16WF"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_GPREL16DF
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_GPREL16DF"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 96 */
block|{
name|R_PARISC_LTOFF64
block|,
literal|0
block|,
literal|0
block|,
literal|64
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_LTOFF64"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_DLTIND14WR
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DLTIND14WR"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_DLTIND14DR
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_DLTIND14DR"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_LTOFF16F
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_LTOFF16F"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_LTOFF16WF
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_LTOFF16DF"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_LTOFF16DF
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_LTOFF16DF"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 104 */
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_BASEREL14WR
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_BASEREL14WR"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_BASEREL14DR
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_BASEREL14DR"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 112 */
block|{
name|R_PARISC_SEGREL64
block|,
literal|0
block|,
literal|0
block|,
literal|64
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_SEGREL64"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_PLTOFF14WR
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PLTOFF14WR"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_PLTOFF14DR
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PLTOFF14DR"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_PLTOFF16F
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PLTOFF16F"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_PLTOFF16WF
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PLTOFF16WF"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_PLTOFF16DF
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_PLTOFF16DF"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 120 */
block|{
name|R_PARISC_LTOFF_FPTR64
block|,
literal|0
block|,
literal|0
block|,
literal|64
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_LTOFF_FPTR14WR
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_LTOFF_FPTR14WR"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_LTOFF_FPTR14DR
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_LTOFF_FPTR14DR"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_LTOFF_FPTR16F
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_LTOFF_FPTR16F"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_LTOFF_FPTR16WF
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_LTOFF_FPTR16WF"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_LTOFF_FPTR16DF
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 128 */
block|{
name|R_PARISC_COPY
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_COPY"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_IPLT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_IPLT"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_EPLT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_EPLT"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 136 */
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 144 */
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 152 */
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_TPREL32
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_TPREL32"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_TPREL21L
block|,
literal|0
block|,
literal|0
block|,
literal|21
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_TPREL21L"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_TPREL14R
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_TPREL14R"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 160 */
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_LTOFF_TP21L
block|,
literal|0
block|,
literal|0
block|,
literal|21
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_LTOFF_TP21L"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_LTOFF_TP14R
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_LTOFF_TP14F
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_LTOFF_TP14F"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 168 */
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 176 */
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 184 */
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 192 */
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 200 */
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 208 */
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 216 */
block|{
name|R_PARISC_TPREL64
block|,
literal|0
block|,
literal|0
block|,
literal|64
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_TPREL64"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_TPREL14WR
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_TPREL14WR"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_TPREL14DR
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_TPREL14DR"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_TPREL16F
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_TPREL16F"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_TPREL16WF
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_TPREL16WF"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_TPREL16DF
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_TPREL16DF"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 224 */
block|{
name|R_PARISC_LTOFF_TP64
block|,
literal|0
block|,
literal|0
block|,
literal|64
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_LTOFF_TP64"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_UNIMPLEMENTED
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_UNIMPLEMENTED"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_LTOFF_TP14WR
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_LTOFF_TP14WR"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_LTOFF_TP14DR
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_LTOFF_TP14DR"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_LTOFF_TP16F
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_LTOFF_TP16F"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_LTOFF_TP16WF
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_LTOFF_TP16WF"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_LTOFF_TP16DF
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_bitfield
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_LTOFF_TP16DF"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
comment|/* 232 */
block|{
name|R_PARISC_GNU_VTENTRY
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_GNU_VTENTRY"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|,
block|{
name|R_PARISC_GNU_VTINHERIT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|0
block|,
name|complain_overflow_dont
block|,
name|bfd_elf_generic_reloc
block|,
literal|"R_PARISC_GNU_VTINHERIT"
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OFFSET_14R_FROM_21L
value|4
end_define

begin_define
define|#
directive|define
name|OFFSET_14F_FROM_21L
value|5
end_define

begin_comment
comment|/* Return the final relocation type for the given base type, instruction    format, and field selector.  */
end_comment

begin_function
name|elf_hppa_reloc_type
name|elf_hppa_reloc_final_type
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|elf_hppa_reloc_type
name|base_type
parameter_list|,
name|int
name|format
parameter_list|,
name|unsigned
name|int
name|field
parameter_list|)
block|{
name|elf_hppa_reloc_type
name|final_type
init|=
name|base_type
decl_stmt|;
comment|/* Just a tangle of nested switch statements to deal with the braindamage      that a different field selector means a completely different relocation      for PA ELF.  */
switch|switch
condition|(
name|base_type
condition|)
block|{
comment|/* We have been using generic relocation types.  However, that may not        really make sense.  Anyway, we need to support both R_PARISC_DIR64        and R_PARISC_DIR32 here.  */
case|case
name|R_PARISC_DIR32
case|:
case|case
name|R_PARISC_DIR64
case|:
case|case
name|R_HPPA_ABS_CALL
case|:
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|14
case|:
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|e_fsel
case|:
name|final_type
operator|=
name|R_PARISC_DIR14F
expr_stmt|;
break|break;
case|case
name|e_rsel
case|:
case|case
name|e_rrsel
case|:
case|case
name|e_rdsel
case|:
name|final_type
operator|=
name|R_PARISC_DIR14R
expr_stmt|;
break|break;
case|case
name|e_rtsel
case|:
name|final_type
operator|=
name|R_PARISC_DLTIND14R
expr_stmt|;
break|break;
case|case
name|e_rtpsel
case|:
name|final_type
operator|=
name|R_PARISC_LTOFF_FPTR14DR
expr_stmt|;
break|break;
case|case
name|e_tsel
case|:
name|final_type
operator|=
name|R_PARISC_DLTIND14F
expr_stmt|;
break|break;
case|case
name|e_rpsel
case|:
name|final_type
operator|=
name|R_PARISC_PLABEL14R
expr_stmt|;
break|break;
default|default:
return|return
name|R_PARISC_NONE
return|;
block|}
break|break;
case|case
literal|17
case|:
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|e_fsel
case|:
name|final_type
operator|=
name|R_PARISC_DIR17F
expr_stmt|;
break|break;
case|case
name|e_rsel
case|:
case|case
name|e_rrsel
case|:
case|case
name|e_rdsel
case|:
name|final_type
operator|=
name|R_PARISC_DIR17R
expr_stmt|;
break|break;
default|default:
return|return
name|R_PARISC_NONE
return|;
block|}
break|break;
case|case
literal|21
case|:
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|e_lsel
case|:
case|case
name|e_lrsel
case|:
case|case
name|e_ldsel
case|:
case|case
name|e_nlsel
case|:
case|case
name|e_nlrsel
case|:
name|final_type
operator|=
name|R_PARISC_DIR21L
expr_stmt|;
break|break;
case|case
name|e_ltsel
case|:
name|final_type
operator|=
name|R_PARISC_DLTIND21L
expr_stmt|;
break|break;
case|case
name|e_ltpsel
case|:
name|final_type
operator|=
name|R_PARISC_LTOFF_FPTR21L
expr_stmt|;
break|break;
case|case
name|e_lpsel
case|:
name|final_type
operator|=
name|R_PARISC_PLABEL21L
expr_stmt|;
break|break;
default|default:
return|return
name|R_PARISC_NONE
return|;
block|}
break|break;
case|case
literal|32
case|:
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|e_fsel
case|:
name|final_type
operator|=
name|R_PARISC_DIR32
expr_stmt|;
comment|/* When in 64bit mode, a 32bit relocation is supposed to 		 be a section relative relocation.  Dwarf2 (for example) 		 uses 32bit section relative relocations.  */
if|if
condition|(
name|bfd_get_arch_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|bits_per_address
operator|!=
literal|32
condition|)
name|final_type
operator|=
name|R_PARISC_SECREL32
expr_stmt|;
break|break;
case|case
name|e_psel
case|:
name|final_type
operator|=
name|R_PARISC_PLABEL32
expr_stmt|;
break|break;
default|default:
return|return
name|R_PARISC_NONE
return|;
block|}
break|break;
case|case
literal|64
case|:
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|e_fsel
case|:
name|final_type
operator|=
name|R_PARISC_DIR64
expr_stmt|;
break|break;
case|case
name|e_psel
case|:
name|final_type
operator|=
name|R_PARISC_FPTR64
expr_stmt|;
break|break;
default|default:
return|return
name|R_PARISC_NONE
return|;
block|}
break|break;
default|default:
return|return
name|R_PARISC_NONE
return|;
block|}
break|break;
case|case
name|R_HPPA_GOTOFF
case|:
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|14
case|:
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|e_rsel
case|:
case|case
name|e_rrsel
case|:
case|case
name|e_rdsel
case|:
comment|/* R_PARISC_DLTREL14R for elf64, R_PARISC_DPREL14R for elf32  */
name|final_type
operator|=
name|base_type
operator|+
name|OFFSET_14R_FROM_21L
expr_stmt|;
break|break;
case|case
name|e_fsel
case|:
comment|/* R_PARISC_DLTREL14F for elf64, R_PARISC_DPREL14F for elf32  */
name|final_type
operator|=
name|base_type
operator|+
name|OFFSET_14F_FROM_21L
expr_stmt|;
break|break;
default|default:
return|return
name|R_PARISC_NONE
return|;
block|}
break|break;
case|case
literal|21
case|:
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|e_lsel
case|:
case|case
name|e_lrsel
case|:
case|case
name|e_ldsel
case|:
case|case
name|e_nlsel
case|:
case|case
name|e_nlrsel
case|:
comment|/* R_PARISC_DLTREL21L for elf64, R_PARISC_DPREL21L for elf32  */
name|final_type
operator|=
name|base_type
expr_stmt|;
break|break;
default|default:
return|return
name|R_PARISC_NONE
return|;
block|}
break|break;
default|default:
return|return
name|R_PARISC_NONE
return|;
block|}
break|break;
case|case
name|R_HPPA_PCREL_CALL
case|:
switch|switch
condition|(
name|format
condition|)
block|{
case|case
literal|12
case|:
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|e_fsel
case|:
name|final_type
operator|=
name|R_PARISC_PCREL12F
expr_stmt|;
break|break;
default|default:
return|return
name|R_PARISC_NONE
return|;
block|}
break|break;
case|case
literal|14
case|:
comment|/* Contrary to appearances, these are not calls of any sort. 	     Rather, they are loads/stores with a pcrel reloc.  */
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|e_rsel
case|:
case|case
name|e_rrsel
case|:
case|case
name|e_rdsel
case|:
name|final_type
operator|=
name|R_PARISC_PCREL14R
expr_stmt|;
break|break;
case|case
name|e_fsel
case|:
if|if
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
operator|<
literal|25
condition|)
name|final_type
operator|=
name|R_PARISC_PCREL14F
expr_stmt|;
else|else
name|final_type
operator|=
name|R_PARISC_PCREL16F
expr_stmt|;
break|break;
default|default:
return|return
name|R_PARISC_NONE
return|;
block|}
break|break;
case|case
literal|17
case|:
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|e_rsel
case|:
case|case
name|e_rrsel
case|:
case|case
name|e_rdsel
case|:
name|final_type
operator|=
name|R_PARISC_PCREL17R
expr_stmt|;
break|break;
case|case
name|e_fsel
case|:
name|final_type
operator|=
name|R_PARISC_PCREL17F
expr_stmt|;
break|break;
default|default:
return|return
name|R_PARISC_NONE
return|;
block|}
break|break;
case|case
literal|21
case|:
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|e_lsel
case|:
case|case
name|e_lrsel
case|:
case|case
name|e_ldsel
case|:
case|case
name|e_nlsel
case|:
case|case
name|e_nlrsel
case|:
name|final_type
operator|=
name|R_PARISC_PCREL21L
expr_stmt|;
break|break;
default|default:
return|return
name|R_PARISC_NONE
return|;
block|}
break|break;
case|case
literal|22
case|:
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|e_fsel
case|:
name|final_type
operator|=
name|R_PARISC_PCREL22F
expr_stmt|;
break|break;
default|default:
return|return
name|R_PARISC_NONE
return|;
block|}
break|break;
case|case
literal|32
case|:
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|e_fsel
case|:
name|final_type
operator|=
name|R_PARISC_PCREL32
expr_stmt|;
break|break;
default|default:
return|return
name|R_PARISC_NONE
return|;
block|}
break|break;
case|case
literal|64
case|:
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|e_fsel
case|:
name|final_type
operator|=
name|R_PARISC_PCREL64
expr_stmt|;
break|break;
default|default:
return|return
name|R_PARISC_NONE
return|;
block|}
break|break;
default|default:
return|return
name|R_PARISC_NONE
return|;
block|}
break|break;
case|case
name|R_PARISC_GNU_VTENTRY
case|:
case|case
name|R_PARISC_GNU_VTINHERIT
case|:
case|case
name|R_PARISC_SEGREL32
case|:
case|case
name|R_PARISC_SEGBASE
case|:
comment|/* The defaults are fine for these cases.  */
break|break;
default|default:
return|return
name|R_PARISC_NONE
return|;
block|}
return|return
name|final_type
return|;
block|}
end_function

begin_comment
comment|/* Return one (or more) BFD relocations which implement the base    relocation with modifications based on format and field.  */
end_comment

begin_function
name|elf_hppa_reloc_type
modifier|*
modifier|*
name|_bfd_elf_hppa_gen_reloc_type
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|elf_hppa_reloc_type
name|base_type
parameter_list|,
name|int
name|format
parameter_list|,
name|unsigned
name|int
name|field
parameter_list|,
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
name|sym
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|elf_hppa_reloc_type
modifier|*
name|finaltype
decl_stmt|;
name|elf_hppa_reloc_type
modifier|*
modifier|*
name|final_types
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|elf_hppa_reloc_type
operator|*
argument_list|)
operator|*
literal|2
decl_stmt|;
comment|/* Allocate slots for the BFD relocation.  */
name|final_types
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|final_types
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Allocate space for the relocation itself.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|elf_hppa_reloc_type
argument_list|)
expr_stmt|;
name|finaltype
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|finaltype
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Some reasonable defaults.  */
name|final_types
index|[
literal|0
index|]
operator|=
name|finaltype
expr_stmt|;
name|final_types
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|finaltype
operator|=
name|elf_hppa_reloc_final_type
argument_list|(
name|abfd
argument_list|,
name|base_type
argument_list|,
name|format
argument_list|,
name|field
argument_list|)
expr_stmt|;
return|return
name|final_types
return|;
block|}
end_function

begin_comment
comment|/* Translate from an elf into field into a howto relocation pointer.  */
end_comment

begin_function
specifier|static
name|void
name|elf_hppa_info_to_howto
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|bfd_reloc
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|elf_reloc
parameter_list|)
block|{
name|BFD_ASSERT
argument_list|(
name|ELF_R_TYPE
argument_list|(
name|elf_reloc
operator|->
name|r_info
argument_list|)
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_PARISC_UNIMPLEMENTED
argument_list|)
expr_stmt|;
name|bfd_reloc
operator|->
name|howto
operator|=
operator|&
name|elf_hppa_howto_table
index|[
name|ELF_R_TYPE
argument_list|(
name|elf_reloc
operator|->
name|r_info
argument_list|)
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate from an elf into field into a howto relocation pointer.  */
end_comment

begin_function
specifier|static
name|void
name|elf_hppa_info_to_howto_rel
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|bfd_reloc
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|elf_reloc
parameter_list|)
block|{
name|BFD_ASSERT
argument_list|(
name|ELF_R_TYPE
argument_list|(
name|elf_reloc
operator|->
name|r_info
argument_list|)
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_PARISC_UNIMPLEMENTED
argument_list|)
expr_stmt|;
name|bfd_reloc
operator|->
name|howto
operator|=
operator|&
name|elf_hppa_howto_table
index|[
name|ELF_R_TYPE
argument_list|(
name|elf_reloc
operator|->
name|r_info
argument_list|)
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the address of the howto table entry to perform the CODE    relocation for an ARCH machine.  */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|elf_hppa_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|code
operator|<
operator|(
name|int
operator|)
name|R_PARISC_UNIMPLEMENTED
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|(
name|int
operator|)
name|elf_hppa_howto_table
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|.
name|type
operator|==
operator|(
name|int
operator|)
name|code
argument_list|)
expr_stmt|;
return|return
operator|&
name|elf_hppa_howto_table
index|[
operator|(
name|int
operator|)
name|code
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if SYM represents a local label symbol.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_hppa_is_local_label_name
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'L'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'$'
condition|)
return|return
literal|1
return|;
return|return
name|_bfd_elf_is_local_label_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set the correct type for an ELF section.  We do this by the    section name, which is a hack, but ought to work.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_hppa_fake_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|hdr
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".PARISC.unwind"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|indx
decl_stmt|;
name|asection
modifier|*
name|asec
decl_stmt|;
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|64
name|hdr
operator|->
name|sh_type
operator|=
name|SHT_LOPROC
operator|+
literal|1
expr_stmt|;
else|#
directive|else
name|hdr
operator|->
name|sh_type
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* ?!? How are unwinds supposed to work for symbols in arbitrary 	 sections?  Or what if we have multiple .text sections in a single 	 .o file?  HP really messed up on this one.  	 Ugh.  We can not use elf_section_data (sec)->this_idx at this 	 point because it is not initialized yet.  	 So we (gasp) recompute it here.  Hopefully nobody ever changes the 	 way sections are numbered in elf.c!  */
for|for
control|(
name|asec
operator|=
name|abfd
operator|->
name|sections
operator|,
name|indx
operator|=
literal|1
init|;
name|asec
condition|;
name|asec
operator|=
name|asec
operator|->
name|next
operator|,
name|indx
operator|++
control|)
block|{
if|if
condition|(
name|asec
operator|->
name|name
operator|&&
name|strcmp
argument_list|(
name|asec
operator|->
name|name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|sh_info
operator|=
name|indx
expr_stmt|;
break|break;
block|}
block|}
comment|/* I have no idea if this is really necessary or what it means.  */
name|hdr
operator|->
name|sh_entsize
operator|=
literal|4
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf_hppa_final_write_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|linker
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|mach
init|=
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
operator|(
name|EF_PARISC_ARCH
operator||
name|EF_PARISC_TRAPNIL
operator||
name|EF_PARISC_EXT
operator||
name|EF_PARISC_LSB
operator||
name|EF_PARISC_WIDE
operator||
name|EF_PARISC_NO_KABP
operator||
name|EF_PARISC_LAZYSWAP
operator|)
expr_stmt|;
if|if
condition|(
name|mach
operator|==
literal|10
condition|)
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator||=
name|EFA_PARISC_1_0
expr_stmt|;
elseif|else
if|if
condition|(
name|mach
operator|==
literal|11
condition|)
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator||=
name|EFA_PARISC_1_1
expr_stmt|;
elseif|else
if|if
condition|(
name|mach
operator|==
literal|20
condition|)
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator||=
name|EFA_PARISC_2_0
expr_stmt|;
elseif|else
if|if
condition|(
name|mach
operator|==
literal|25
condition|)
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator||=
operator|(
name|EF_PARISC_WIDE
operator||
name|EFA_PARISC_2_0
comment|/* The GNU tools have trapped without 					 option since 1993, so need to take 					 a step backwards with the ELF 					 based toolchains.  */
operator||
name|EF_PARISC_TRAPNIL
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Comparison function for qsort to sort unwind section during a    final link.  */
end_comment

begin_function
specifier|static
name|int
name|hppa_unwind_entry_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|bfd_byte
modifier|*
name|ap
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|unsigned
name|long
name|av
decl_stmt|,
name|bv
decl_stmt|;
name|ap
operator|=
name|a
expr_stmt|;
name|av
operator|=
operator|(
name|unsigned
name|long
operator|)
name|ap
index|[
literal|0
index|]
operator|<<
literal|24
expr_stmt|;
name|av
operator||=
operator|(
name|unsigned
name|long
operator|)
name|ap
index|[
literal|1
index|]
operator|<<
literal|16
expr_stmt|;
name|av
operator||=
operator|(
name|unsigned
name|long
operator|)
name|ap
index|[
literal|2
index|]
operator|<<
literal|8
expr_stmt|;
name|av
operator||=
operator|(
name|unsigned
name|long
operator|)
name|ap
index|[
literal|3
index|]
expr_stmt|;
name|bp
operator|=
name|b
expr_stmt|;
name|bv
operator|=
operator|(
name|unsigned
name|long
operator|)
name|bp
index|[
literal|0
index|]
operator|<<
literal|24
expr_stmt|;
name|bv
operator||=
operator|(
name|unsigned
name|long
operator|)
name|bp
index|[
literal|1
index|]
operator|<<
literal|16
expr_stmt|;
name|bv
operator||=
operator|(
name|unsigned
name|long
operator|)
name|bp
index|[
literal|2
index|]
operator|<<
literal|8
expr_stmt|;
name|bv
operator||=
operator|(
name|unsigned
name|long
operator|)
name|bp
index|[
literal|3
index|]
expr_stmt|;
return|return
name|av
operator|<
name|bv
condition|?
operator|-
literal|1
else|:
name|av
operator|>
name|bv
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf_hppa_sort_unwind
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* Magic section names, but this is much safer than having      relocate_section remember where SEGREL32 relocs occurred.      Consider what happens if someone inept creates a linker script      that puts unwind information in .text.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".PARISC.unwind"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|char
modifier|*
name|contents
decl_stmt|;
name|size
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|contents
operator|=
name|bfd_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|size
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|qsort
argument_list|(
name|contents
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|size
operator|/
literal|16
argument_list|)
argument_list|,
literal|16
argument_list|,
name|hppa_unwind_entry_compare
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|size
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_if
if|#
directive|if
name|ARCH_SIZE
operator|==
literal|64
end_if

begin_comment
comment|/* Hook called by the linker routine which adds symbols from an object    file.  HP's libraries define symbols with HP specific section    indices, which we have to handle.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_hppa_add_symbol_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|namep
name|ATTRIBUTE_UNUSED
parameter_list|,
name|flagword
modifier|*
name|flagsp
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
modifier|*
name|secp
parameter_list|,
name|bfd_vma
modifier|*
name|valp
parameter_list|)
block|{
name|int
name|index
init|=
name|sym
operator|->
name|st_shndx
decl_stmt|;
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|SHN_PARISC_ANSI_COMMON
case|:
operator|*
name|secp
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".PARISC.ansi.common"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|secp
operator|)
operator|->
name|flags
operator||=
name|SEC_IS_COMMON
expr_stmt|;
operator|*
name|valp
operator|=
name|sym
operator|->
name|st_size
expr_stmt|;
break|break;
case|case
name|SHN_PARISC_HUGE_COMMON
case|:
operator|*
name|secp
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".PARISC.huge.common"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|secp
operator|)
operator|->
name|flags
operator||=
name|SEC_IS_COMMON
expr_stmt|;
operator|*
name|valp
operator|=
name|sym
operator|->
name|st_size
expr_stmt|;
break|break;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf_hppa_unmark_useless_dynamic_symbols
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
name|data
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* If we are not creating a shared library, and this symbol is      referenced by a shared library but is not defined anywhere, then      the generic code will warn that it is undefined.       This behavior is undesirable on HPs since the standard shared      libraries contain references to undefined symbols.       So we twiddle the flags associated with such symbols so that they      will not trigger the warning.  ?!? FIXME.  This is horribly fragile.       Ultimately we should have better controls over the generic ELF BFD      linker code.  */
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
operator|&&
name|info
operator|->
name|unresolved_syms_in_shared_libs
operator|!=
name|RM_IGNORE
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_REF_DYNAMIC
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
literal|0x8000
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf_hppa_remark_useless_dynamic_symbols
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
name|data
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* If we are not creating a shared library, and this symbol is      referenced by a shared library but is not defined anywhere, then      the generic code will warn that it is undefined.       This behavior is undesirable on HPs since the standard shared      libraries contain references to undefined symbols.       So we twiddle the flags associated with such symbols so that they      will not trigger the warning.  ?!? FIXME.  This is horribly fragile.       Ultimately we should have better controls over the generic ELF BFD      linker code.  */
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
operator|&&
name|info
operator|->
name|unresolved_syms_in_shared_libs
operator|!=
name|RM_IGNORE
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
condition|)
block|{
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_REF_DYNAMIC
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
literal|0x8000
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf_hppa_is_dynamic_loader_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__CPU_REVISION"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__CPU_KEYBITS_1"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__SYSTEM_ID_D"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__FPU_MODEL"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__FPU_REVISION"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__ARGC"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__ARGV"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__ENVP"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__TLS_SIZE_D"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__LOAD_INFO"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__systab"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Record the lowest address for the data and text segments.  */
end_comment

begin_function
specifier|static
name|void
name|elf_hppa_record_segment_addrs
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|elf64_hppa_link_hash_table
modifier|*
name|hppa_info
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|hppa_info
operator|=
name|data
expr_stmt|;
name|value
operator|=
name|section
operator|->
name|vma
operator|-
name|section
operator|->
name|filepos
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|section
operator|->
name|flags
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator|)
operator|)
operator|==
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator|)
operator|)
operator|&&
name|value
operator|<
name|hppa_info
operator|->
name|text_segment_base
condition|)
name|hppa_info
operator|->
name|text_segment_base
operator|=
name|value
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|section
operator|->
name|flags
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator|)
operator|)
operator|==
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
operator|)
operator|&&
name|value
operator|<
name|hppa_info
operator|->
name|data_segment_base
condition|)
name|hppa_info
operator|->
name|data_segment_base
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called after we have seen all the input files/sections, but before    final symbol resolution and section placement has been determined.     We use this hook to (possibly) provide a value for __gp, then we    fall back to the generic ELF final link routine.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_hppa_final_link
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd_boolean
name|retval
decl_stmt|;
name|struct
name|elf64_hppa_link_hash_table
modifier|*
name|hppa_info
init|=
name|elf64_hppa_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|gp
decl_stmt|;
name|bfd_vma
name|gp_val
decl_stmt|;
comment|/* The linker script defines a value for __gp iff it was referenced 	 by one of the objects being linked.  First try to find the symbol 	 in the hash table.  If that fails, just compute the value __gp 	 should have had.  */
name|gp
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
literal|"__gp"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
condition|)
block|{
comment|/* Adjust the value of __gp as we may want to slide it into the 	     .plt section so that the stubs can access PLT entries without 	     using an addil sequence.  */
name|gp
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+=
name|hppa_info
operator|->
name|gp_offset
expr_stmt|;
name|gp_val
operator|=
operator|(
name|gp
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|gp
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|gp
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|)
expr_stmt|;
block|}
else|else
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* First look for a .plt section.  If found, then __gp is the 	     address of the .plt + gp_offset.  	     If no .plt is found, then look for .dlt, .opd and .data (in 	     that order) and set __gp to the base address of whichever 	     section is found first.  */
name|sec
operator|=
name|hppa_info
operator|->
name|plt_sec
expr_stmt|;
if|if
condition|(
name|sec
operator|&&
operator|!
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
condition|)
name|gp_val
operator|=
operator|(
name|sec
operator|->
name|output_offset
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|hppa_info
operator|->
name|gp_offset
operator|)
expr_stmt|;
else|else
block|{
name|sec
operator|=
name|hppa_info
operator|->
name|dlt_sec
expr_stmt|;
if|if
condition|(
operator|!
name|sec
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
condition|)
name|sec
operator|=
name|hppa_info
operator|->
name|opd_sec
expr_stmt|;
if|if
condition|(
operator|!
name|sec
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
condition|)
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".data"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sec
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
operator|)
condition|)
return|return
name|FALSE
return|;
name|gp_val
operator|=
name|sec
operator|->
name|output_offset
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
block|}
block|}
comment|/* Install whatever value we found/computed for __gp.  */
name|_bfd_set_gp_value
argument_list|(
name|abfd
argument_list|,
name|gp_val
argument_list|)
expr_stmt|;
block|}
comment|/* We need to know the base of the text and data segments so that we      can perform SEGREL relocations.  We will record the base addresses      when we encounter the first SEGREL relocation.  */
name|hppa_info
operator|->
name|text_segment_base
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|hppa_info
operator|->
name|data_segment_base
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* HP's shared libraries have references to symbols that are not      defined anywhere.  The generic ELF BFD linker code will complain      about such symbols.       So we detect the losing case and arrange for the flags on the symbol      to indicate that it was never referenced.  This keeps the generic      ELF BFD link code happy and appears to not create any secondary      problems.  Ultimately we need a way to control the behavior of the      generic ELF BFD link code better.  */
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_hppa_unmark_useless_dynamic_symbols
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* Invoke the regular ELF backend linker to do all the work.  */
name|retval
operator|=
name|bfd_elf_final_link
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_hppa_remark_useless_dynamic_symbols
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* If we're producing a final executable, sort the contents of the      unwind section. */
if|if
condition|(
name|retval
condition|)
name|retval
operator|=
name|elf_hppa_sort_unwind
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Relocate an HPPA ELF section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_hppa_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|struct
name|elf64_hppa_link_hash_table
modifier|*
name|hppa_info
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|hppa_info
operator|=
name|elf64_hppa_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
init|=
name|elf_hppa_howto_table
operator|+
name|ELF_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|dyn_name
decl_stmt|;
name|char
modifier|*
name|dynh_buf
init|=
name|NULL
decl_stmt|;
name|size_t
name|dynh_buflen
init|=
literal|0
decl_stmt|;
name|struct
name|elf64_hppa_dyn_hash_entry
modifier|*
name|dyn_h
init|=
name|NULL
decl_stmt|;
name|r_type
operator|=
name|ELF_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|<
literal|0
operator|||
name|r_type
operator|>=
operator|(
name|int
operator|)
name|R_PARISC_UNIMPLEMENTED
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* This is a final link.  */
name|r_symndx
operator|=
name|ELF_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sym_sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* This is a local symbol.  */
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sym_sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sym_sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
comment|/* If this symbol has an entry in the PA64 dynamic hash 	     table, then get it.  */
name|dyn_name
operator|=
name|get_dyn_name
argument_list|(
name|input_bfd
argument_list|,
name|h
argument_list|,
name|rel
argument_list|,
operator|&
name|dynh_buf
argument_list|,
operator|&
name|dynh_buflen
argument_list|)
expr_stmt|;
name|dyn_h
operator|=
name|elf64_hppa_dyn_hash_lookup
argument_list|(
operator|&
name|hppa_info
operator|->
name|dyn_hash_table
argument_list|,
name|dyn_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is not a local symbol.  */
name|long
name|indx
decl_stmt|;
name|indx
operator|=
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sym_sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
comment|/* If this symbol has an entry in the PA64 dynamic hash 		 table, then get it.  */
name|dyn_name
operator|=
name|get_dyn_name
argument_list|(
name|input_bfd
argument_list|,
name|h
argument_list|,
name|rel
argument_list|,
operator|&
name|dynh_buf
argument_list|,
operator|&
name|dynh_buflen
argument_list|)
expr_stmt|;
name|dyn_h
operator|=
name|elf64_hppa_dyn_hash_lookup
argument_list|(
operator|&
name|hppa_info
operator|->
name|dyn_hash_table
argument_list|,
name|dyn_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* If we have a relocation against a symbol defined in a 		 shared library and we have not created an entry in the 		 PA64 dynamic symbol hash table for it, then we lose.  */
if|if
condition|(
name|sym_sec
operator|->
name|output_section
operator|==
name|NULL
operator|&&
name|dyn_h
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: warning: unresolvable relocation against symbol `%s' from %s section"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|)
expr_stmt|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym_sec
operator|->
name|output_section
condition|)
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sym_sec
operator|->
name|output_offset
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Value will be provided via one of the offsets in the 		 dyn_h hash table entry.  */
else|else
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|unresolved_syms_in_objects
operator|==
name|RM_IGNORE
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
condition|)
block|{
comment|/* If this symbol has an entry in the PA64 dynamic hash 		 table, then get it.  */
name|dyn_name
operator|=
name|get_dyn_name
argument_list|(
name|input_bfd
argument_list|,
name|h
argument_list|,
name|rel
argument_list|,
operator|&
name|dynh_buf
argument_list|,
operator|&
name|dynh_buflen
argument_list|)
expr_stmt|;
name|dyn_h
operator|=
name|elf64_hppa_dyn_hash_lookup
argument_list|(
operator|&
name|hppa_info
operator|->
name|dyn_hash_table
argument_list|,
name|dyn_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyn_h
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: warning: unresolvable relocation against symbol `%s' from %s section"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
name|dyn_name
operator|=
name|get_dyn_name
argument_list|(
name|input_bfd
argument_list|,
name|h
argument_list|,
name|rel
argument_list|,
operator|&
name|dynh_buf
argument_list|,
operator|&
name|dynh_buflen
argument_list|)
expr_stmt|;
name|dyn_h
operator|=
name|elf64_hppa_dyn_hash_lookup
argument_list|(
operator|&
name|hppa_info
operator|->
name|dyn_hash_table
argument_list|,
name|dyn_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyn_h
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: warning: unresolvable relocation against symbol `%s' from %s section"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Ignore dynamic loader defined symbols.  */
if|if
condition|(
name|elf_hppa_is_dynamic_loader_symbol
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
operator|(
name|info
operator|->
name|unresolved_syms_in_objects
operator|==
name|RM_GENERATE_ERROR
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|)
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|sym_name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|sym_name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|*
name|sym_name
operator|==
literal|'\0'
condition|)
name|sym_name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sym_sec
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|elf_hppa_final_link_relocate
argument_list|(
name|rel
argument_list|,
name|input_bfd
argument_list|,
name|output_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|relocation
argument_list|,
name|info
argument_list|,
name|sym_sec
argument_list|,
name|h
argument_list|,
name|dyn_h
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
switch|switch
condition|(
name|r
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_overflow
case|:
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|sym_name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
break|break;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Compute the value for a relocation (REL) during a final link stage,    then insert the value into the proper location in CONTENTS.     VALUE is a tentative value for the relocation and may be overridden    and modified here based on the specific relocation to be performed.     For example we do conversions for PC-relative branches in this routine    or redirection of calls to external routines to stubs.     The work of actually applying the relocation is left to a helper    routine in an attempt to reduce the complexity and size of this    function.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|elf_hppa_final_link_relocate
parameter_list|(
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|bfd_vma
name|value
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sym_sec
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|elf64_hppa_dyn_hash_entry
modifier|*
name|dyn_h
parameter_list|)
block|{
name|int
name|insn
decl_stmt|;
name|bfd_vma
name|offset
init|=
name|rel
operator|->
name|r_offset
decl_stmt|;
name|bfd_signed_vma
name|addend
init|=
name|rel
operator|->
name|r_addend
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
init|=
name|elf_hppa_howto_table
operator|+
name|ELF_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|r_type
init|=
name|howto
operator|->
name|type
decl_stmt|;
name|bfd_byte
modifier|*
name|hit_data
init|=
name|contents
operator|+
name|offset
decl_stmt|;
name|struct
name|elf64_hppa_link_hash_table
modifier|*
name|hppa_info
init|=
name|elf64_hppa_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_PARISC_NONE
case|:
break|break;
comment|/* Basic function call support.         Note for a call to a function defined in another dynamic library        we want to redirect the call to a stub.  */
comment|/* Random PC relative relocs.  */
case|case
name|R_PARISC_PCREL21L
case|:
case|case
name|R_PARISC_PCREL14R
case|:
case|case
name|R_PARISC_PCREL14F
case|:
case|case
name|R_PARISC_PCREL14WR
case|:
case|case
name|R_PARISC_PCREL14DR
case|:
case|case
name|R_PARISC_PCREL16F
case|:
case|case
name|R_PARISC_PCREL16WF
case|:
case|case
name|R_PARISC_PCREL16DF
case|:
block|{
comment|/* If this is a call to a function defined in another dynamic 	   library, then redirect the call to the local stub for this 	   function.  */
if|if
condition|(
name|sym_sec
operator|==
name|NULL
operator|||
name|sym_sec
operator|->
name|output_section
operator|==
name|NULL
condition|)
name|value
operator|=
operator|(
name|dyn_h
operator|->
name|stub_offset
operator|+
name|hppa_info
operator|->
name|stub_sec
operator|->
name|output_offset
operator|+
name|hppa_info
operator|->
name|stub_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Turn VALUE into a proper PC relative address.  */
name|value
operator|-=
operator|(
name|offset
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Adjust for any field selectors.  */
if|if
condition|(
name|r_type
operator|==
name|R_PARISC_PCREL21L
condition|)
name|value
operator|=
name|hppa_field_adjust
argument_list|(
name|value
argument_list|,
operator|-
literal|8
operator|+
name|addend
argument_list|,
name|e_lsel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_PARISC_PCREL14F
operator|||
name|r_type
operator|==
name|R_PARISC_PCREL16F
operator|||
name|r_type
operator|==
name|R_PARISC_PCREL16WF
operator|||
name|r_type
operator|==
name|R_PARISC_PCREL16DF
condition|)
name|value
operator|=
name|hppa_field_adjust
argument_list|(
name|value
argument_list|,
operator|-
literal|8
operator|+
name|addend
argument_list|,
name|e_fsel
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|hppa_field_adjust
argument_list|(
name|value
argument_list|,
operator|-
literal|8
operator|+
name|addend
argument_list|,
name|e_rsel
argument_list|)
expr_stmt|;
comment|/* Apply the relocation to the given instruction.  */
name|insn
operator|=
name|elf_hppa_relocate_insn
argument_list|(
name|insn
argument_list|,
operator|(
name|int
operator|)
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|R_PARISC_PCREL12F
case|:
case|case
name|R_PARISC_PCREL22F
case|:
case|case
name|R_PARISC_PCREL17F
case|:
case|case
name|R_PARISC_PCREL22C
case|:
case|case
name|R_PARISC_PCREL17C
case|:
case|case
name|R_PARISC_PCREL17R
case|:
block|{
comment|/* If this is a call to a function defined in another dynamic 	   library, then redirect the call to the local stub for this 	   function.  */
if|if
condition|(
name|sym_sec
operator|==
name|NULL
operator|||
name|sym_sec
operator|->
name|output_section
operator|==
name|NULL
condition|)
name|value
operator|=
operator|(
name|dyn_h
operator|->
name|stub_offset
operator|+
name|hppa_info
operator|->
name|stub_sec
operator|->
name|output_offset
operator|+
name|hppa_info
operator|->
name|stub_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Turn VALUE into a proper PC relative address.  */
name|value
operator|-=
operator|(
name|offset
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Adjust for any field selectors.  */
if|if
condition|(
name|r_type
operator|==
name|R_PARISC_PCREL17R
condition|)
name|value
operator|=
name|hppa_field_adjust
argument_list|(
name|value
argument_list|,
operator|-
literal|8
operator|+
name|addend
argument_list|,
name|e_rsel
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|hppa_field_adjust
argument_list|(
name|value
argument_list|,
operator|-
literal|8
operator|+
name|addend
argument_list|,
name|e_fsel
argument_list|)
expr_stmt|;
comment|/* All branches are implicitly shifted by 2 places.  */
name|value
operator|>>=
literal|2
expr_stmt|;
comment|/* Apply the relocation to the given instruction.  */
name|insn
operator|=
name|elf_hppa_relocate_insn
argument_list|(
name|insn
argument_list|,
operator|(
name|int
operator|)
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Indirect references to data through the DLT.  */
case|case
name|R_PARISC_DLTIND14R
case|:
case|case
name|R_PARISC_DLTIND14F
case|:
case|case
name|R_PARISC_DLTIND14DR
case|:
case|case
name|R_PARISC_DLTIND14WR
case|:
case|case
name|R_PARISC_DLTIND21L
case|:
case|case
name|R_PARISC_LTOFF_FPTR14R
case|:
case|case
name|R_PARISC_LTOFF_FPTR14DR
case|:
case|case
name|R_PARISC_LTOFF_FPTR14WR
case|:
case|case
name|R_PARISC_LTOFF_FPTR21L
case|:
case|case
name|R_PARISC_LTOFF_FPTR16F
case|:
case|case
name|R_PARISC_LTOFF_FPTR16WF
case|:
case|case
name|R_PARISC_LTOFF_FPTR16DF
case|:
case|case
name|R_PARISC_LTOFF_TP21L
case|:
case|case
name|R_PARISC_LTOFF_TP14R
case|:
case|case
name|R_PARISC_LTOFF_TP14F
case|:
case|case
name|R_PARISC_LTOFF_TP14WR
case|:
case|case
name|R_PARISC_LTOFF_TP14DR
case|:
case|case
name|R_PARISC_LTOFF_TP16F
case|:
case|case
name|R_PARISC_LTOFF_TP16WF
case|:
case|case
name|R_PARISC_LTOFF_TP16DF
case|:
case|case
name|R_PARISC_LTOFF16F
case|:
case|case
name|R_PARISC_LTOFF16WF
case|:
case|case
name|R_PARISC_LTOFF16DF
case|:
block|{
comment|/* If this relocation was against a local symbol, then we still 	   have not set up the DLT entry (it's not convenient to do so 	   in the "finalize_dlt" routine because it is difficult to get 	   to the local symbol's value).  	   So, if this is a local symbol (h == NULL), then we need to 	   fill in its DLT entry.  	   Similarly we may still need to set up an entry in .opd for 	   a local function which had its address taken.  */
if|if
condition|(
name|dyn_h
operator|->
name|h
operator|==
name|NULL
condition|)
block|{
comment|/* Now do .opd creation if needed.  */
if|if
condition|(
name|r_type
operator|==
name|R_PARISC_LTOFF_FPTR14R
operator|||
name|r_type
operator|==
name|R_PARISC_LTOFF_FPTR14DR
operator|||
name|r_type
operator|==
name|R_PARISC_LTOFF_FPTR14WR
operator|||
name|r_type
operator|==
name|R_PARISC_LTOFF_FPTR21L
operator|||
name|r_type
operator|==
name|R_PARISC_LTOFF_FPTR16F
operator|||
name|r_type
operator|==
name|R_PARISC_LTOFF_FPTR16WF
operator|||
name|r_type
operator|==
name|R_PARISC_LTOFF_FPTR16DF
condition|)
block|{
comment|/* The first two words of an .opd entry are zero.  */
name|memset
argument_list|(
name|hppa_info
operator|->
name|opd_sec
operator|->
name|contents
operator|+
name|dyn_h
operator|->
name|opd_offset
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* The next word is the address of the function.  */
name|bfd_put_64
argument_list|(
name|hppa_info
operator|->
name|opd_sec
operator|->
name|owner
argument_list|,
name|value
operator|+
name|addend
argument_list|,
operator|(
name|hppa_info
operator|->
name|opd_sec
operator|->
name|contents
operator|+
name|dyn_h
operator|->
name|opd_offset
operator|+
literal|16
operator|)
argument_list|)
expr_stmt|;
comment|/* The last word is our local __gp value.  */
name|value
operator|=
name|_bfd_get_gp_value
argument_list|(
name|hppa_info
operator|->
name|opd_sec
operator|->
name|output_section
operator|->
name|owner
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|hppa_info
operator|->
name|opd_sec
operator|->
name|owner
argument_list|,
name|value
argument_list|,
operator|(
name|hppa_info
operator|->
name|opd_sec
operator|->
name|contents
operator|+
name|dyn_h
operator|->
name|opd_offset
operator|+
literal|24
operator|)
argument_list|)
expr_stmt|;
comment|/* The DLT value is the address of the .opd entry.  */
name|value
operator|=
operator|(
name|dyn_h
operator|->
name|opd_offset
operator|+
name|hppa_info
operator|->
name|opd_sec
operator|->
name|output_offset
operator|+
name|hppa_info
operator|->
name|opd_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
block|}
name|bfd_put_64
argument_list|(
name|hppa_info
operator|->
name|dlt_sec
operator|->
name|owner
argument_list|,
name|value
operator|+
name|addend
argument_list|,
name|hppa_info
operator|->
name|dlt_sec
operator|->
name|contents
operator|+
name|dyn_h
operator|->
name|dlt_offset
argument_list|)
expr_stmt|;
block|}
comment|/* We want the value of the DLT offset for this symbol, not 	   the symbol's actual address.  Note that __gp may not point 	   to the start of the DLT, so we have to compute the absolute 	   address, then subtract out the value of __gp.  */
name|value
operator|=
operator|(
name|dyn_h
operator|->
name|dlt_offset
operator|+
name|hppa_info
operator|->
name|dlt_sec
operator|->
name|output_offset
operator|+
name|hppa_info
operator|->
name|dlt_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|value
operator|-=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* All DLTIND relocations are basically the same at this point, 	   except that we need different field selectors for the 21bit 	   version vs the 14bit versions.  */
if|if
condition|(
name|r_type
operator|==
name|R_PARISC_DLTIND21L
operator|||
name|r_type
operator|==
name|R_PARISC_LTOFF_FPTR21L
operator|||
name|r_type
operator|==
name|R_PARISC_LTOFF_TP21L
condition|)
name|value
operator|=
name|hppa_field_adjust
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
name|e_lsel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_PARISC_DLTIND14F
operator|||
name|r_type
operator|==
name|R_PARISC_LTOFF_FPTR16F
operator|||
name|r_type
operator|==
name|R_PARISC_LTOFF_FPTR16WF
operator|||
name|r_type
operator|==
name|R_PARISC_LTOFF_FPTR16DF
operator|||
name|r_type
operator|==
name|R_PARISC_LTOFF16F
operator|||
name|r_type
operator|==
name|R_PARISC_LTOFF16DF
operator|||
name|r_type
operator|==
name|R_PARISC_LTOFF16WF
operator|||
name|r_type
operator|==
name|R_PARISC_LTOFF_TP16F
operator|||
name|r_type
operator|==
name|R_PARISC_LTOFF_TP16WF
operator|||
name|r_type
operator|==
name|R_PARISC_LTOFF_TP16DF
condition|)
name|value
operator|=
name|hppa_field_adjust
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
name|e_fsel
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|hppa_field_adjust
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
name|e_rsel
argument_list|)
expr_stmt|;
name|insn
operator|=
name|elf_hppa_relocate_insn
argument_list|(
name|insn
argument_list|,
operator|(
name|int
operator|)
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|R_PARISC_DLTREL14R
case|:
case|case
name|R_PARISC_DLTREL14F
case|:
case|case
name|R_PARISC_DLTREL14DR
case|:
case|case
name|R_PARISC_DLTREL14WR
case|:
case|case
name|R_PARISC_DLTREL21L
case|:
case|case
name|R_PARISC_DPREL21L
case|:
case|case
name|R_PARISC_DPREL14WR
case|:
case|case
name|R_PARISC_DPREL14DR
case|:
case|case
name|R_PARISC_DPREL14R
case|:
case|case
name|R_PARISC_DPREL14F
case|:
case|case
name|R_PARISC_GPREL16F
case|:
case|case
name|R_PARISC_GPREL16WF
case|:
case|case
name|R_PARISC_GPREL16DF
case|:
block|{
comment|/* Subtract out the global pointer value to make value a DLT 	   relative address.  */
name|value
operator|-=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* All DLTREL relocations are basically the same at this point, 	   except that we need different field selectors for the 21bit 	   version vs the 14bit versions.  */
if|if
condition|(
name|r_type
operator|==
name|R_PARISC_DLTREL21L
operator|||
name|r_type
operator|==
name|R_PARISC_DPREL21L
condition|)
name|value
operator|=
name|hppa_field_adjust
argument_list|(
name|value
argument_list|,
name|addend
argument_list|,
name|e_lrsel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_PARISC_DLTREL14F
operator|||
name|r_type
operator|==
name|R_PARISC_DPREL14F
operator|||
name|r_type
operator|==
name|R_PARISC_GPREL16F
operator|||
name|r_type
operator|==
name|R_PARISC_GPREL16WF
operator|||
name|r_type
operator|==
name|R_PARISC_GPREL16DF
condition|)
name|value
operator|=
name|hppa_field_adjust
argument_list|(
name|value
argument_list|,
name|addend
argument_list|,
name|e_fsel
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|hppa_field_adjust
argument_list|(
name|value
argument_list|,
name|addend
argument_list|,
name|e_rrsel
argument_list|)
expr_stmt|;
name|insn
operator|=
name|elf_hppa_relocate_insn
argument_list|(
name|insn
argument_list|,
operator|(
name|int
operator|)
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|R_PARISC_DIR21L
case|:
case|case
name|R_PARISC_DIR17R
case|:
case|case
name|R_PARISC_DIR17F
case|:
case|case
name|R_PARISC_DIR14R
case|:
case|case
name|R_PARISC_DIR14F
case|:
case|case
name|R_PARISC_DIR14WR
case|:
case|case
name|R_PARISC_DIR14DR
case|:
case|case
name|R_PARISC_DIR16F
case|:
case|case
name|R_PARISC_DIR16WF
case|:
case|case
name|R_PARISC_DIR16DF
case|:
block|{
comment|/* All DIR relocations are basically the same at this point, 	   except that branch offsets need to be divided by four, and 	   we need different field selectors.  Note that we don't 	   redirect absolute calls to local stubs.  */
if|if
condition|(
name|r_type
operator|==
name|R_PARISC_DIR21L
condition|)
name|value
operator|=
name|hppa_field_adjust
argument_list|(
name|value
argument_list|,
name|addend
argument_list|,
name|e_lrsel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_PARISC_DIR17F
operator|||
name|r_type
operator|==
name|R_PARISC_DIR16F
operator|||
name|r_type
operator|==
name|R_PARISC_DIR16WF
operator|||
name|r_type
operator|==
name|R_PARISC_DIR16DF
operator|||
name|r_type
operator|==
name|R_PARISC_DIR14F
condition|)
name|value
operator|=
name|hppa_field_adjust
argument_list|(
name|value
argument_list|,
name|addend
argument_list|,
name|e_fsel
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|hppa_field_adjust
argument_list|(
name|value
argument_list|,
name|addend
argument_list|,
name|e_rrsel
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_PARISC_DIR17R
operator|||
name|r_type
operator|==
name|R_PARISC_DIR17F
condition|)
block|{
comment|/* All branches are implicitly shifted by 2 places.  */
name|value
operator|>>=
literal|2
expr_stmt|;
block|}
name|insn
operator|=
name|elf_hppa_relocate_insn
argument_list|(
name|insn
argument_list|,
operator|(
name|int
operator|)
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|R_PARISC_PLTOFF21L
case|:
case|case
name|R_PARISC_PLTOFF14R
case|:
case|case
name|R_PARISC_PLTOFF14F
case|:
case|case
name|R_PARISC_PLTOFF14WR
case|:
case|case
name|R_PARISC_PLTOFF14DR
case|:
case|case
name|R_PARISC_PLTOFF16F
case|:
case|case
name|R_PARISC_PLTOFF16WF
case|:
case|case
name|R_PARISC_PLTOFF16DF
case|:
block|{
comment|/* We want the value of the PLT offset for this symbol, not 	   the symbol's actual address.  Note that __gp may not point 	   to the start of the DLT, so we have to compute the absolute 	   address, then subtract out the value of __gp.  */
name|value
operator|=
operator|(
name|dyn_h
operator|->
name|plt_offset
operator|+
name|hppa_info
operator|->
name|plt_sec
operator|->
name|output_offset
operator|+
name|hppa_info
operator|->
name|plt_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|value
operator|-=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
comment|/* All PLTOFF relocations are basically the same at this point, 	   except that we need different field selectors for the 21bit 	   version vs the 14bit versions.  */
if|if
condition|(
name|r_type
operator|==
name|R_PARISC_PLTOFF21L
condition|)
name|value
operator|=
name|hppa_field_adjust
argument_list|(
name|value
argument_list|,
name|addend
argument_list|,
name|e_lrsel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_PARISC_PLTOFF14F
operator|||
name|r_type
operator|==
name|R_PARISC_PLTOFF16F
operator|||
name|r_type
operator|==
name|R_PARISC_PLTOFF16WF
operator|||
name|r_type
operator|==
name|R_PARISC_PLTOFF16DF
condition|)
name|value
operator|=
name|hppa_field_adjust
argument_list|(
name|value
argument_list|,
name|addend
argument_list|,
name|e_fsel
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|hppa_field_adjust
argument_list|(
name|value
argument_list|,
name|addend
argument_list|,
name|e_rrsel
argument_list|)
expr_stmt|;
name|insn
operator|=
name|elf_hppa_relocate_insn
argument_list|(
name|insn
argument_list|,
operator|(
name|int
operator|)
name|value
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|R_PARISC_LTOFF_FPTR32
case|:
block|{
comment|/* We may still need to create the FPTR itself if it was for 	   a local symbol.  */
if|if
condition|(
name|dyn_h
operator|->
name|h
operator|==
name|NULL
condition|)
block|{
comment|/* The first two words of an .opd entry are zero.  */
name|memset
argument_list|(
name|hppa_info
operator|->
name|opd_sec
operator|->
name|contents
operator|+
name|dyn_h
operator|->
name|opd_offset
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* The next word is the address of the function.  */
name|bfd_put_64
argument_list|(
name|hppa_info
operator|->
name|opd_sec
operator|->
name|owner
argument_list|,
name|value
operator|+
name|addend
argument_list|,
operator|(
name|hppa_info
operator|->
name|opd_sec
operator|->
name|contents
operator|+
name|dyn_h
operator|->
name|opd_offset
operator|+
literal|16
operator|)
argument_list|)
expr_stmt|;
comment|/* The last word is our local __gp value.  */
name|value
operator|=
name|_bfd_get_gp_value
argument_list|(
name|hppa_info
operator|->
name|opd_sec
operator|->
name|output_section
operator|->
name|owner
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|hppa_info
operator|->
name|opd_sec
operator|->
name|owner
argument_list|,
name|value
argument_list|,
name|hppa_info
operator|->
name|opd_sec
operator|->
name|contents
operator|+
name|dyn_h
operator|->
name|opd_offset
operator|+
literal|24
argument_list|)
expr_stmt|;
comment|/* The DLT value is the address of the .opd entry.  */
name|value
operator|=
operator|(
name|dyn_h
operator|->
name|opd_offset
operator|+
name|hppa_info
operator|->
name|opd_sec
operator|->
name|output_offset
operator|+
name|hppa_info
operator|->
name|opd_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|hppa_info
operator|->
name|dlt_sec
operator|->
name|owner
argument_list|,
name|value
argument_list|,
name|hppa_info
operator|->
name|dlt_sec
operator|->
name|contents
operator|+
name|dyn_h
operator|->
name|dlt_offset
argument_list|)
expr_stmt|;
block|}
comment|/* We want the value of the DLT offset for this symbol, not 	   the symbol's actual address.  Note that __gp may not point 	   to the start of the DLT, so we have to compute the absolute 	   address, then subtract out the value of __gp.  */
name|value
operator|=
operator|(
name|dyn_h
operator|->
name|dlt_offset
operator|+
name|hppa_info
operator|->
name|dlt_sec
operator|->
name|output_offset
operator|+
name|hppa_info
operator|->
name|dlt_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|value
operator|-=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
case|case
name|R_PARISC_LTOFF_FPTR64
case|:
case|case
name|R_PARISC_LTOFF_TP64
case|:
block|{
comment|/* We may still need to create the FPTR itself if it was for 	   a local symbol.  */
if|if
condition|(
name|dyn_h
operator|->
name|h
operator|==
name|NULL
operator|&&
name|r_type
operator|==
name|R_PARISC_LTOFF_FPTR64
condition|)
block|{
comment|/* The first two words of an .opd entry are zero.  */
name|memset
argument_list|(
name|hppa_info
operator|->
name|opd_sec
operator|->
name|contents
operator|+
name|dyn_h
operator|->
name|opd_offset
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* The next word is the address of the function.  */
name|bfd_put_64
argument_list|(
name|hppa_info
operator|->
name|opd_sec
operator|->
name|owner
argument_list|,
name|value
operator|+
name|addend
argument_list|,
operator|(
name|hppa_info
operator|->
name|opd_sec
operator|->
name|contents
operator|+
name|dyn_h
operator|->
name|opd_offset
operator|+
literal|16
operator|)
argument_list|)
expr_stmt|;
comment|/* The last word is our local __gp value.  */
name|value
operator|=
name|_bfd_get_gp_value
argument_list|(
name|hppa_info
operator|->
name|opd_sec
operator|->
name|output_section
operator|->
name|owner
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|hppa_info
operator|->
name|opd_sec
operator|->
name|owner
argument_list|,
name|value
argument_list|,
name|hppa_info
operator|->
name|opd_sec
operator|->
name|contents
operator|+
name|dyn_h
operator|->
name|opd_offset
operator|+
literal|24
argument_list|)
expr_stmt|;
comment|/* The DLT value is the address of the .opd entry.  */
name|value
operator|=
operator|(
name|dyn_h
operator|->
name|opd_offset
operator|+
name|hppa_info
operator|->
name|opd_sec
operator|->
name|output_offset
operator|+
name|hppa_info
operator|->
name|opd_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|hppa_info
operator|->
name|dlt_sec
operator|->
name|owner
argument_list|,
name|value
argument_list|,
name|hppa_info
operator|->
name|dlt_sec
operator|->
name|contents
operator|+
name|dyn_h
operator|->
name|dlt_offset
argument_list|)
expr_stmt|;
block|}
comment|/* We want the value of the DLT offset for this symbol, not 	   the symbol's actual address.  Note that __gp may not point 	   to the start of the DLT, so we have to compute the absolute 	   address, then subtract out the value of __gp.  */
name|value
operator|=
operator|(
name|dyn_h
operator|->
name|dlt_offset
operator|+
name|hppa_info
operator|->
name|dlt_sec
operator|->
name|output_offset
operator|+
name|hppa_info
operator|->
name|dlt_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|value
operator|-=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
case|case
name|R_PARISC_DIR32
case|:
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
operator|+
name|addend
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_PARISC_DIR64
case|:
name|bfd_put_64
argument_list|(
name|input_bfd
argument_list|,
name|value
operator|+
name|addend
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_PARISC_GPREL64
case|:
comment|/* Subtract out the global pointer value to make value a DLT 	 relative address.  */
name|value
operator|-=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|input_bfd
argument_list|,
name|value
operator|+
name|addend
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_PARISC_LTOFF64
case|:
comment|/* We want the value of the DLT offset for this symbol, not 	   the symbol's actual address.  Note that __gp may not point 	   to the start of the DLT, so we have to compute the absolute 	   address, then subtract out the value of __gp.  */
name|value
operator|=
operator|(
name|dyn_h
operator|->
name|dlt_offset
operator|+
name|hppa_info
operator|->
name|dlt_sec
operator|->
name|output_offset
operator|+
name|hppa_info
operator|->
name|dlt_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|value
operator|-=
name|_bfd_get_gp_value
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|input_bfd
argument_list|,
name|value
operator|+
name|addend
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_PARISC_PCREL32
case|:
block|{
comment|/* If this is a call to a function defined in another dynamic 	   library, then redirect the call to the local stub for this 	   function.  */
if|if
condition|(
name|sym_sec
operator|==
name|NULL
operator|||
name|sym_sec
operator|->
name|output_section
operator|==
name|NULL
condition|)
name|value
operator|=
operator|(
name|dyn_h
operator|->
name|stub_offset
operator|+
name|hppa_info
operator|->
name|stub_sec
operator|->
name|output_offset
operator|+
name|hppa_info
operator|->
name|stub_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Turn VALUE into a proper PC relative address.  */
name|value
operator|-=
operator|(
name|offset
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|value
operator|+=
name|addend
expr_stmt|;
name|value
operator|-=
literal|8
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
case|case
name|R_PARISC_PCREL64
case|:
block|{
comment|/* If this is a call to a function defined in another dynamic 	   library, then redirect the call to the local stub for this 	   function.  */
if|if
condition|(
name|sym_sec
operator|==
name|NULL
operator|||
name|sym_sec
operator|->
name|output_section
operator|==
name|NULL
condition|)
name|value
operator|=
operator|(
name|dyn_h
operator|->
name|stub_offset
operator|+
name|hppa_info
operator|->
name|stub_sec
operator|->
name|output_offset
operator|+
name|hppa_info
operator|->
name|stub_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
comment|/* Turn VALUE into a proper PC relative address.  */
name|value
operator|-=
operator|(
name|offset
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|value
operator|+=
name|addend
expr_stmt|;
name|value
operator|-=
literal|8
expr_stmt|;
name|bfd_put_64
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
case|case
name|R_PARISC_FPTR64
case|:
block|{
comment|/* We may still need to create the FPTR itself if it was for 	   a local symbol.  */
if|if
condition|(
name|dyn_h
operator|->
name|h
operator|==
name|NULL
condition|)
block|{
comment|/* The first two words of an .opd entry are zero.  */
name|memset
argument_list|(
name|hppa_info
operator|->
name|opd_sec
operator|->
name|contents
operator|+
name|dyn_h
operator|->
name|opd_offset
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* The next word is the address of the function.  */
name|bfd_put_64
argument_list|(
name|hppa_info
operator|->
name|opd_sec
operator|->
name|owner
argument_list|,
name|value
operator|+
name|addend
argument_list|,
operator|(
name|hppa_info
operator|->
name|opd_sec
operator|->
name|contents
operator|+
name|dyn_h
operator|->
name|opd_offset
operator|+
literal|16
operator|)
argument_list|)
expr_stmt|;
comment|/* The last word is our local __gp value.  */
name|value
operator|=
name|_bfd_get_gp_value
argument_list|(
name|hppa_info
operator|->
name|opd_sec
operator|->
name|output_section
operator|->
name|owner
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|hppa_info
operator|->
name|opd_sec
operator|->
name|owner
argument_list|,
name|value
argument_list|,
name|hppa_info
operator|->
name|opd_sec
operator|->
name|contents
operator|+
name|dyn_h
operator|->
name|opd_offset
operator|+
literal|24
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dyn_h
operator|->
name|want_opd
condition|)
comment|/* We want the value of the OPD offset for this symbol.  */
name|value
operator|=
operator|(
name|dyn_h
operator|->
name|opd_offset
operator|+
name|hppa_info
operator|->
name|opd_sec
operator|->
name|output_offset
operator|+
name|hppa_info
operator|->
name|opd_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
else|else
comment|/* We want the address of the symbol.  */
name|value
operator|+=
name|addend
expr_stmt|;
name|bfd_put_64
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
case|case
name|R_PARISC_SECREL32
case|:
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
operator|+
name|addend
operator|-
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_PARISC_SEGREL32
case|:
case|case
name|R_PARISC_SEGREL64
case|:
block|{
comment|/* If this is the first SEGREL relocation, then initialize 	   the segment base values.  */
if|if
condition|(
name|hppa_info
operator|->
name|text_segment_base
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|bfd_map_over_sections
argument_list|(
name|output_bfd
argument_list|,
name|elf_hppa_record_segment_addrs
argument_list|,
name|hppa_info
argument_list|)
expr_stmt|;
comment|/* VALUE holds the absolute address.  We want to include the 	   addend, then turn it into a segment relative address.  	   The segment is derived from SYM_SEC.  We assume that there are 	   only two segments of note in the resulting executable/shlib. 	   A readonly segment (.text) and a readwrite segment (.data).  */
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
name|sym_sec
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
name|value
operator|-=
name|hppa_info
operator|->
name|text_segment_base
expr_stmt|;
else|else
name|value
operator|-=
name|hppa_info
operator|->
name|data_segment_base
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_PARISC_SEGREL32
condition|)
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
else|else
name|bfd_put_64
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* Something we don't know how to handle.  */
default|default:
return|return
name|bfd_reloc_notsupported
return|;
block|}
comment|/* Update the instruction word.  */
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Relocate the given INSN.  VALUE should be the actual value we want    to insert into the instruction, ie by this point we should not be    concerned with computing an offset relative to the DLT, PC, etc.    Instead this routine is meant to handle the bit manipulations needed    to insert the relocation into the given instruction.  */
end_comment

begin_function
specifier|static
name|int
name|elf_hppa_relocate_insn
parameter_list|(
name|int
name|insn
parameter_list|,
name|int
name|sym_value
parameter_list|,
name|unsigned
name|int
name|r_type
parameter_list|)
block|{
switch|switch
condition|(
name|r_type
condition|)
block|{
comment|/* This is any 22 bit branch.  In PA2.0 syntax it corresponds to        the "B" instruction.  */
case|case
name|R_PARISC_PCREL22F
case|:
case|case
name|R_PARISC_PCREL22C
case|:
return|return
operator|(
name|insn
operator|&
operator|~
literal|0x3ff1ffd
operator|)
operator||
name|re_assemble_22
argument_list|(
name|sym_value
argument_list|)
return|;
comment|/* This is any 12 bit branch.  */
case|case
name|R_PARISC_PCREL12F
case|:
return|return
operator|(
name|insn
operator|&
operator|~
literal|0x1ffd
operator|)
operator||
name|re_assemble_12
argument_list|(
name|sym_value
argument_list|)
return|;
comment|/* This is any 17 bit branch.  In PA2.0 syntax it also corresponds        to the "B" instruction as well as BE.  */
case|case
name|R_PARISC_PCREL17F
case|:
case|case
name|R_PARISC_DIR17F
case|:
case|case
name|R_PARISC_DIR17R
case|:
case|case
name|R_PARISC_PCREL17C
case|:
case|case
name|R_PARISC_PCREL17R
case|:
return|return
operator|(
name|insn
operator|&
operator|~
literal|0x1f1ffd
operator|)
operator||
name|re_assemble_17
argument_list|(
name|sym_value
argument_list|)
return|;
comment|/* ADDIL or LDIL instructions.  */
case|case
name|R_PARISC_DLTREL21L
case|:
case|case
name|R_PARISC_DLTIND21L
case|:
case|case
name|R_PARISC_LTOFF_FPTR21L
case|:
case|case
name|R_PARISC_PCREL21L
case|:
case|case
name|R_PARISC_LTOFF_TP21L
case|:
case|case
name|R_PARISC_DPREL21L
case|:
case|case
name|R_PARISC_PLTOFF21L
case|:
case|case
name|R_PARISC_DIR21L
case|:
return|return
operator|(
name|insn
operator|&
operator|~
literal|0x1fffff
operator|)
operator||
name|re_assemble_21
argument_list|(
name|sym_value
argument_list|)
return|;
comment|/* LDO and integer loads/stores with 14 bit displacements.  */
case|case
name|R_PARISC_DLTREL14R
case|:
case|case
name|R_PARISC_DLTREL14F
case|:
case|case
name|R_PARISC_DLTIND14R
case|:
case|case
name|R_PARISC_DLTIND14F
case|:
case|case
name|R_PARISC_LTOFF_FPTR14R
case|:
case|case
name|R_PARISC_PCREL14R
case|:
case|case
name|R_PARISC_PCREL14F
case|:
case|case
name|R_PARISC_LTOFF_TP14R
case|:
case|case
name|R_PARISC_LTOFF_TP14F
case|:
case|case
name|R_PARISC_DPREL14R
case|:
case|case
name|R_PARISC_DPREL14F
case|:
case|case
name|R_PARISC_PLTOFF14R
case|:
case|case
name|R_PARISC_PLTOFF14F
case|:
case|case
name|R_PARISC_DIR14R
case|:
case|case
name|R_PARISC_DIR14F
case|:
return|return
operator|(
name|insn
operator|&
operator|~
literal|0x3fff
operator|)
operator||
name|low_sign_unext
argument_list|(
name|sym_value
argument_list|,
literal|14
argument_list|)
return|;
comment|/* PA2.0W LDO and integer loads/stores with 16 bit displacements.  */
case|case
name|R_PARISC_LTOFF_FPTR16F
case|:
case|case
name|R_PARISC_PCREL16F
case|:
case|case
name|R_PARISC_LTOFF_TP16F
case|:
case|case
name|R_PARISC_GPREL16F
case|:
case|case
name|R_PARISC_PLTOFF16F
case|:
case|case
name|R_PARISC_DIR16F
case|:
case|case
name|R_PARISC_LTOFF16F
case|:
return|return
operator|(
name|insn
operator|&
operator|~
literal|0xffff
operator|)
operator||
name|re_assemble_16
argument_list|(
name|sym_value
argument_list|)
return|;
comment|/* Doubleword loads and stores with a 14 bit displacement.  */
case|case
name|R_PARISC_DLTREL14DR
case|:
case|case
name|R_PARISC_DLTIND14DR
case|:
case|case
name|R_PARISC_LTOFF_FPTR14DR
case|:
case|case
name|R_PARISC_LTOFF_FPTR16DF
case|:
case|case
name|R_PARISC_PCREL14DR
case|:
case|case
name|R_PARISC_PCREL16DF
case|:
case|case
name|R_PARISC_LTOFF_TP14DR
case|:
case|case
name|R_PARISC_LTOFF_TP16DF
case|:
case|case
name|R_PARISC_DPREL14DR
case|:
case|case
name|R_PARISC_GPREL16DF
case|:
case|case
name|R_PARISC_PLTOFF14DR
case|:
case|case
name|R_PARISC_PLTOFF16DF
case|:
case|case
name|R_PARISC_DIR14DR
case|:
case|case
name|R_PARISC_DIR16DF
case|:
case|case
name|R_PARISC_LTOFF16DF
case|:
return|return
operator|(
name|insn
operator|&
operator|~
literal|0x3ff1
operator|)
operator||
operator|(
operator|(
operator|(
name|sym_value
operator|&
literal|0x2000
operator|)
operator|>>
literal|13
operator|)
operator||
operator|(
operator|(
name|sym_value
operator|&
literal|0x1ff8
operator|)
operator|<<
literal|1
operator|)
operator|)
return|;
comment|/* Floating point single word load/store instructions.  */
case|case
name|R_PARISC_DLTREL14WR
case|:
case|case
name|R_PARISC_DLTIND14WR
case|:
case|case
name|R_PARISC_LTOFF_FPTR14WR
case|:
case|case
name|R_PARISC_LTOFF_FPTR16WF
case|:
case|case
name|R_PARISC_PCREL14WR
case|:
case|case
name|R_PARISC_PCREL16WF
case|:
case|case
name|R_PARISC_LTOFF_TP14WR
case|:
case|case
name|R_PARISC_LTOFF_TP16WF
case|:
case|case
name|R_PARISC_DPREL14WR
case|:
case|case
name|R_PARISC_GPREL16WF
case|:
case|case
name|R_PARISC_PLTOFF14WR
case|:
case|case
name|R_PARISC_PLTOFF16WF
case|:
case|case
name|R_PARISC_DIR16WF
case|:
case|case
name|R_PARISC_DIR14WR
case|:
case|case
name|R_PARISC_LTOFF16WF
case|:
return|return
operator|(
name|insn
operator|&
operator|~
literal|0x3ff9
operator|)
operator||
operator|(
operator|(
operator|(
name|sym_value
operator|&
literal|0x2000
operator|)
operator|>>
literal|13
operator|)
operator||
operator|(
operator|(
name|sym_value
operator|&
literal|0x1ffc
operator|)
operator|<<
literal|1
operator|)
operator|)
return|;
default|default:
return|return
name|insn
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

