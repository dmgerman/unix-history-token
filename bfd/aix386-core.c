begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for AIX on PS/2 core files.    This was based on trad-core.c, which was written by John Gilmore of         Cygnus Support.    Copyright 1988, 1989, 1991, 1992, 1993, 1994, 1996, 1998, 1999, 2000,    2001, 2002, 2004    Free Software Foundation, Inc.    Written by Minh Tran-Le<TRANLE@INTELLICORP.COM>.    Converted to back end form by Ian Lance Taylor<ian@cygnus.com>.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"coff/i386.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_AIX
argument_list|)
operator|&&
name|defined
argument_list|(
name|_I386
argument_list|)
end_if

begin_define
define|#
directive|define
name|NOCHECKS
end_define

begin_comment
comment|/* This is for coredump.h.  */
end_comment

begin_define
define|#
directive|define
name|_h_USER
end_define

begin_comment
comment|/* Avoid including user.h from coredump.h.  */
end_comment

begin_include
include|#
directive|include
file|<uinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/i386/coredump.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _AIX&& _I386 */
end_comment

begin_comment
comment|/* Maybe this could work on some other i386 but I have not tried it  * mtranle@paris - Tue Sep 24 12:49:35 1991  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|COR_MAGIC
end_ifndef

begin_define
define|#
directive|define
name|COR_MAGIC
value|"core"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Need this cast because ptr is really void *.  */
end_comment

begin_define
define|#
directive|define
name|core_hdr
parameter_list|(
name|bfd
parameter_list|)
define|\
value|(((bfd->tdata.trad_core_data))->hdr)
end_define

begin_define
define|#
directive|define
name|core_section
parameter_list|(
name|bfd
parameter_list|,
name|n
parameter_list|)
define|\
value|(((bfd)->tdata.trad_core_data)->sections[n])
end_define

begin_define
define|#
directive|define
name|core_regsec
parameter_list|(
name|bfd
parameter_list|)
define|\
value|(((bfd)->tdata.trad_core_data)->reg_section)
end_define

begin_define
define|#
directive|define
name|core_reg2sec
parameter_list|(
name|bfd
parameter_list|)
define|\
value|(((bfd)->tdata.trad_core_data)->reg2_section)
end_define

begin_comment
comment|/* These are stored in the bfd's tdata.  */
end_comment

begin_struct
struct|struct
name|trad_core_struct
block|{
name|struct
name|corehdr
modifier|*
name|hdr
decl_stmt|;
comment|/* core file header */
name|asection
modifier|*
name|reg_section
decl_stmt|;
name|asection
modifier|*
name|reg2_section
decl_stmt|;
name|asection
modifier|*
name|sections
index|[
name|MAX_CORE_SEGS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|swap_abort
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|aix386_core_file_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|unsigned
name|char
name|longbuf
index|[
literal|4
index|]
decl_stmt|;
comment|/* Raw bytes of various header fields */
name|bfd_size_type
name|core_size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|corehdr
argument_list|)
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|struct
name|corehdr
modifier|*
name|core
decl_stmt|;
struct|struct
name|mergem
block|{
name|struct
name|trad_core_struct
name|coredata
decl_stmt|;
name|struct
name|corehdr
name|internal_core
decl_stmt|;
block|}
modifier|*
name|mergem
struct|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|longbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
name|longbuf
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|longbuf
argument_list|,
name|COR_MAGIC
argument_list|,
literal|4
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mergem
argument_list|)
expr_stmt|;
name|mergem
operator|=
operator|(
expr|struct
name|mergem
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|mergem
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|core
operator|=
operator|&
name|mergem
operator|->
name|internal_core
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
name|core
argument_list|,
name|core_size
argument_list|,
name|abfd
argument_list|)
operator|)
operator|!=
name|core_size
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
name|loser
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mergem
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|=
name|NULL
expr_stmt|;
name|bfd_section_list_clear
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|set_tdata
argument_list|(
name|abfd
argument_list|,
operator|&
name|mergem
operator|->
name|coredata
argument_list|)
expr_stmt|;
name|core_hdr
argument_list|(
name|abfd
argument_list|)
operator|=
name|core
expr_stmt|;
comment|/* Create the sections.  */
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|loser
goto|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|core
operator|->
name|cd_regs
argument_list|)
expr_stmt|;
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* We'll access the regs afresh in the core file, like any section.  */
name|core_regsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
operator|(
name|file_ptr
operator|)
name|offsetof
argument_list|(
expr|struct
name|corehdr
argument_list|,
name|cd_regs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
literal|".reg2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
comment|/* bfd_release frees everything allocated after it's arg.  */
goto|goto
name|loser
goto|;
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
expr_stmt|;
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|core
operator|->
name|cd_fpregs
argument_list|)
expr_stmt|;
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|core_reg2sec
argument_list|(
name|abfd
argument_list|)
operator|->
name|filepos
operator|=
operator|(
name|file_ptr
operator|)
name|offsetof
argument_list|(
expr|struct
name|corehdr
argument_list|,
name|cd_fpregs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|n
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|MAX_CORE_SEGS
operator|)
operator|&&
operator|(
name|core
operator|->
name|cd_segs
index|[
name|i
index|]
operator|.
name|cs_type
operator|)
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|sname
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
if|if
condition|(
name|core
operator|->
name|cd_segs
index|[
name|i
index|]
operator|.
name|cs_offset
operator|==
literal|0
condition|)
continue|continue;
switch|switch
condition|(
name|core
operator|->
name|cd_segs
index|[
name|i
index|]
operator|.
name|cs_type
condition|)
block|{
case|case
name|COR_TYPE_DATA
case|:
name|sname
operator|=
literal|".data"
expr_stmt|;
name|flags
operator|=
name|SEC_ALLOC
operator|+
name|SEC_LOAD
operator|+
name|SEC_HAS_CONTENTS
expr_stmt|;
break|break;
case|case
name|COR_TYPE_STACK
case|:
name|sname
operator|=
literal|".stack"
expr_stmt|;
name|flags
operator|=
name|SEC_ALLOC
operator|+
name|SEC_LOAD
operator|+
name|SEC_HAS_CONTENTS
expr_stmt|;
break|break;
case|case
name|COR_TYPE_LIBDATA
case|:
name|sname
operator|=
literal|".libdata"
expr_stmt|;
name|flags
operator|=
name|SEC_ALLOC
operator|+
name|SEC_HAS_CONTENTS
expr_stmt|;
break|break;
case|case
name|COR_TYPE_WRITE
case|:
name|sname
operator|=
literal|".writeable"
expr_stmt|;
name|flags
operator|=
name|SEC_ALLOC
operator|+
name|SEC_HAS_CONTENTS
expr_stmt|;
break|break;
case|case
name|COR_TYPE_MSC
case|:
name|sname
operator|=
literal|".misc"
expr_stmt|;
name|flags
operator|=
name|SEC_ALLOC
operator|+
name|SEC_HAS_CONTENTS
expr_stmt|;
break|break;
default|default:
name|sname
operator|=
literal|".unknown"
expr_stmt|;
name|flags
operator|=
name|SEC_ALLOC
operator|+
name|SEC_HAS_CONTENTS
expr_stmt|;
break|break;
block|}
name|core_section
argument_list|(
name|abfd
argument_list|,
name|n
argument_list|)
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|sname
argument_list|)
expr_stmt|;
if|if
condition|(
name|core_section
argument_list|(
name|abfd
argument_list|,
name|n
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|loser
goto|;
name|core_section
argument_list|(
name|abfd
argument_list|,
name|n
argument_list|)
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|core_section
argument_list|(
name|abfd
argument_list|,
name|n
argument_list|)
operator|->
name|size
operator|=
name|core
operator|->
name|cd_segs
index|[
name|i
index|]
operator|.
name|cs_len
expr_stmt|;
name|core_section
argument_list|(
name|abfd
argument_list|,
name|n
argument_list|)
operator|->
name|vma
operator|=
name|core
operator|->
name|cd_segs
index|[
name|i
index|]
operator|.
name|cs_address
expr_stmt|;
name|core_section
argument_list|(
name|abfd
argument_list|,
name|n
argument_list|)
operator|->
name|filepos
operator|=
name|core
operator|->
name|cd_segs
index|[
name|i
index|]
operator|.
name|cs_offset
expr_stmt|;
name|core_section
argument_list|(
name|abfd
argument_list|,
name|n
argument_list|)
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|aix386_core_file_failing_command
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|core_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|cd_comm
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aix386_core_file_failing_signal
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|core_hdr
argument_list|(
name|abfd
argument_list|)
operator|->
name|cd_cursig
return|;
block|}
end_function

begin_define
define|#
directive|define
name|aix386_core_file_matches_executable_p
value|generic_core_file_matches_executable_p
end_define

begin_comment
comment|/* If somebody calls any byte-swapping routines, shoot them.  */
end_comment

begin_function
specifier|static
name|void
name|swap_abort
parameter_list|()
block|{
comment|/* This way doesn't require any declaration for ANSI to fuck up.  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|NO_GET
value|((bfd_vma (*) (const void *)) swap_abort)
end_define

begin_define
define|#
directive|define
name|NO_PUT
value|((void (*) (bfd_vma, void *)) swap_abort)
end_define

begin_define
define|#
directive|define
name|NO_GETS
value|((bfd_signed_vma (*) (const void *)) swap_abort)
end_define

begin_define
define|#
directive|define
name|NO_GET64
value|((bfd_uint64_t (*) (const void *)) swap_abort)
end_define

begin_define
define|#
directive|define
name|NO_PUT64
value|((void (*) (bfd_uint64_t, void *)) swap_abort)
end_define

begin_define
define|#
directive|define
name|NO_GETS64
value|((bfd_int64_t (*) (const void *)) swap_abort)
end_define

begin_decl_stmt
specifier|const
name|bfd_target
name|aix386_core_vec
init|=
block|{
literal|"aix386-core"
block|,
name|bfd_target_unknown_flavour
block|,
name|BFD_ENDIAN_BIG
block|,
comment|/* target byte order */
name|BFD_ENDIAN_BIG
block|,
comment|/* target headers byte order */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
comment|/* section flags */
literal|0
block|,
comment|/* leading underscore */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
name|NO_GET64
block|,
name|NO_GETS64
block|,
name|NO_PUT64
block|,
name|NO_GET
block|,
name|NO_GETS
block|,
name|NO_PUT
block|,
name|NO_GET
block|,
name|NO_GETS
block|,
name|NO_PUT
block|,
comment|/* data */
name|NO_GET64
block|,
name|NO_GETS64
block|,
name|NO_PUT64
block|,
name|NO_GET
block|,
name|NO_GETS
block|,
name|NO_PUT
block|,
name|NO_GET
block|,
name|NO_GETS
block|,
name|NO_PUT
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|_bfd_dummy_target
block|,
name|_bfd_dummy_target
block|,
name|aix386_core_file_p
block|}
block|,
block|{
name|bfd_false
block|,
name|bfd_false
block|,
comment|/* bfd_create_object */
name|bfd_false
block|,
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|bfd_false
block|,
comment|/* bfd_write_contents */
name|bfd_false
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|aix386
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_noarchive
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|_bfd_nosymbols
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|_bfd_norelocs
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|_bfd_nolink
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|NULL
block|,
operator|(
name|PTR
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

end_unit

