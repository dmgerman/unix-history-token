begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* SuperH SH64-specific support for 32-bit ELF    Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_define
define|#
directive|define
name|SH64_ELF
end_define

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"../opcodes/sh64-opc.h"
end_include

begin_include
include|#
directive|include
file|"elf32-sh64.h"
end_include

begin_comment
comment|/* Add a suffix for datalabel indirection symbols.  It must not match any    other symbols; user symbols with or without version or other    decoration.  It must only be used internally and not emitted by any    means.  */
end_comment

begin_define
define|#
directive|define
name|DATALABEL_SUFFIX
value|" DL"
end_define

begin_comment
comment|/* Used to hold data for function called through bfd_map_over_sections.  */
end_comment

begin_struct
struct|struct
name|sh64_find_section_vma_data
block|{
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|bfd_boolean
name|sh64_elf_new_section_hook
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sh64_elf_copy_private_data
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sh64_elf_merge_private_data
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sh64_elf_fake_sections
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sh64_elf_set_private_flags
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|flagword
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sh64_elf_set_mach_from_flags
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|shmedia_prepare_reloc
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|bfd_vma
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sh64_elf_get_symbol_type
parameter_list|(
name|Elf_Internal_Sym
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sh64_elf_add_symbol_hook
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|Elf_Internal_Sym
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|flagword
modifier|*
parameter_list|,
name|asection
modifier|*
modifier|*
parameter_list|,
name|bfd_vma
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sh64_elf_link_output_symbol_hook
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|Elf_Internal_Sym
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sh64_backend_section_from_shdr
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sh64_elf_final_write_processing
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sh64_bfd_elf_copy_private_section_data
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sh64_find_section_for_address
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Let elf32-sh.c handle the "bfd_" definitions, so we only have to    intrude with an #ifndef around the function definition.  */
end_comment

begin_define
define|#
directive|define
name|sh_elf_copy_private_data
value|sh64_elf_copy_private_data
end_define

begin_define
define|#
directive|define
name|sh_elf_merge_private_data
value|sh64_elf_merge_private_data
end_define

begin_define
define|#
directive|define
name|sh_elf_set_private_flags
value|sh64_elf_set_private_flags
end_define

begin_comment
comment|/* Typo in elf32-sh.c (and unlinear name).  */
end_comment

begin_define
define|#
directive|define
name|bfd_elf32_bfd_set_private_flags
value|sh64_elf_set_private_flags
end_define

begin_define
define|#
directive|define
name|sh_elf_set_mach_from_flags
value|sh64_elf_set_mach_from_flags
end_define

begin_define
define|#
directive|define
name|elf_backend_sign_extend_vma
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_fake_sections
value|sh64_elf_fake_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_get_symbol_type
value|sh64_elf_get_symbol_type
end_define

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
value|sh64_elf_add_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_link_output_symbol_hook
define|\
value|sh64_elf_link_output_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_merge_symbol_attribute
value|sh64_elf_merge_symbol_attribute
end_define

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
value|sh64_elf_final_write_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_section_from_shdr
value|sh64_backend_section_from_shdr
end_define

begin_define
define|#
directive|define
name|elf_backend_special_sections
value|sh64_elf_special_sections
end_define

begin_define
define|#
directive|define
name|bfd_elf32_new_section_hook
value|sh64_elf_new_section_hook
end_define

begin_comment
comment|/* For objcopy, we need to set up sh64_elf_section_data (asection *) from    incoming section flags.  This is otherwise done in sh64elf.em when    linking or tc-sh64.c when assembling.  */
end_comment

begin_define
define|#
directive|define
name|bfd_elf32_bfd_copy_private_section_data
define|\
value|sh64_bfd_elf_copy_private_section_data
end_define

begin_comment
comment|/* This COFF-only function (only compiled with COFF support, making    ELF-only chains problematic) returns TRUE early for SH4, so let's just    define it TRUE here.  */
end_comment

begin_define
define|#
directive|define
name|_bfd_sh_align_load_span
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|f
parameter_list|,
name|g
parameter_list|,
name|h
parameter_list|,
name|i
parameter_list|,
name|j
parameter_list|)
value|TRUE
end_define

begin_define
define|#
directive|define
name|GOT_BIAS
value|(-((long)-32768))
end_define

begin_define
define|#
directive|define
name|INCLUDE_SHMEDIA
end_define

begin_include
include|#
directive|include
file|"elf32-sh.c"
end_include

begin_comment
comment|/* Tack some extra info on struct bfd_elf_section_data.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sh64_elf_new_section_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
name|struct
name|_sh64_elf_section_data
modifier|*
name|sdata
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
operator|*
name|sdata
argument_list|)
decl_stmt|;
name|sdata
operator|=
operator|(
expr|struct
name|_sh64_elf_section_data
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdata
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sec
operator|->
name|used_by_bfd
operator|=
name|sdata
expr_stmt|;
return|return
name|_bfd_elf_new_section_hook
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set the SHF_SH5_ISA32 flag for ISA SHmedia code sections, and pass    through SHT_SH5_CR_SORTED on a sorted .cranges section.  */
end_comment

begin_function
name|bfd_boolean
name|sh64_elf_fake_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|elf_section_hdr
parameter_list|,
name|asection
modifier|*
name|asect
parameter_list|)
block|{
if|if
condition|(
name|sh64_elf_section_data
argument_list|(
name|asect
argument_list|)
operator|->
name|sh64_info
operator|!=
name|NULL
condition|)
name|elf_section_hdr
operator|->
name|sh_flags
operator||=
name|sh64_elf_section_data
argument_list|(
name|asect
argument_list|)
operator|->
name|sh64_info
operator|->
name|contents_flags
expr_stmt|;
comment|/* If this section has the SEC_SORT_ENTRIES flag set, it is a sorted      .cranges section passing through objcopy.  */
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|output_bfd
argument_list|,
name|asect
argument_list|)
operator|&
name|SEC_SORT_ENTRIES
operator|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|asect
argument_list|)
argument_list|,
name|SH64_CRANGES_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
name|elf_section_hdr
operator|->
name|sh_type
operator|=
name|SHT_SH5_CR_SORTED
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|sh64_elf_set_mach_from_flags
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|flagword
name|flags
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
decl_stmt|;
name|asection
modifier|*
name|cranges
decl_stmt|;
switch|switch
condition|(
name|flags
operator|&
name|EF_SH_MACH_MASK
condition|)
block|{
case|case
name|EF_SH5
case|:
comment|/* These are fit to execute on SH5.  Just one but keep the switch 	 construct to make additions easy.  */
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_sh
argument_list|,
name|bfd_mach_sh5
argument_list|)
expr_stmt|;
break|break;
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* We also need to set SEC_DEBUGGING on an incoming .cranges section.      We could have used elf_backend_section_flags if it had given us the      section name; the bfd_section member in the header argument is not      set at the point of the call.  FIXME: Find out whether that is by      undocumented design or a bug.  */
name|cranges
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|SH64_CRANGES_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|cranges
operator|!=
name|NULL
operator|&&
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|cranges
argument_list|,
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|cranges
argument_list|)
operator||
name|SEC_DEBUGGING
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|sh64_elf_copy_private_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|||
operator|(
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|==
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
operator|)
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|sh64_elf_merge_private_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|flagword
name|old_flags
decl_stmt|,
name|new_flags
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_generic_verify_endian_match
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|bfd_get_arch_size
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_get_arch_size
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
name|bfd_get_arch_size
argument_list|(
name|ibfd
argument_list|)
operator|==
literal|32
operator|&&
name|bfd_get_arch_size
argument_list|(
name|obfd
argument_list|)
operator|==
literal|64
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"%s: compiled as 32-bit object and %s is 64-bit"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_get_arch_size
argument_list|(
name|ibfd
argument_list|)
operator|==
literal|64
operator|&&
name|bfd_get_arch_size
argument_list|(
name|obfd
argument_list|)
operator|==
literal|32
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"%s: compiled as 64-bit object and %s is 32-bit"
argument_list|)
expr_stmt|;
else|else
name|msg
operator|=
name|_
argument_list|(
literal|"%s: object size does not match that of target %s"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|msg
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|old_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|new_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
comment|/* This happens when ld starts out with a 'blank' output file.  */
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|old_flags
operator|=
name|new_flags
expr_stmt|;
block|}
comment|/* We don't allow linking in non-SH64 code.  */
elseif|else
if|if
condition|(
operator|(
name|new_flags
operator|&
name|EF_SH_MACH_MASK
operator|)
operator|!=
name|EF_SH5
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: uses non-SH64 instructions while previous modules use SH64 instructions"
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* I can't think of anything sane other than old_flags being EF_SH5 and      that we need to preserve that.  */
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|old_flags
expr_stmt|;
return|return
name|sh64_elf_set_mach_from_flags
argument_list|(
name|obfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Handle a SH64-specific section when reading an object file.  This    is called when elfcode.h finds a section with an unknown type.     We only recognize SHT_SH5_CR_SORTED, on the .cranges section.  */
end_comment

begin_function
name|bfd_boolean
name|sh64_backend_section_from_shdr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|hdr
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|flagword
name|flags
init|=
literal|0
decl_stmt|;
comment|/* We do like MIPS with a bit switch for recognized types, and returning      FALSE for a recognized section type with an unexpected name.  Right      now we only have one recognized type, but that might change.  */
switch|switch
condition|(
name|hdr
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_SH5_CR_SORTED
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SH64_CRANGES_SECTION_NAME
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* We set the SEC_SORT_ENTRIES flag so it can be passed on to 	 sh64_elf_fake_sections, keeping SHT_SH5_CR_SORTED if this object 	 passes through objcopy.  Perhaps it is brittle; the flag can 	 suddenly be used by other BFD parts, but it seems not really used 	 anywhere at the moment.  */
name|flags
operator|=
name|SEC_DEBUGGING
operator||
name|SEC_SORT_ENTRIES
expr_stmt|;
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|flags
operator|&&
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|,
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|)
operator||
name|flags
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* In contrast to sh64_backend_section_from_shdr, this is called for all    sections, but only when copying sections, not when linking or    assembling.  We need to set up the sh64_elf_section_data (asection *)    structure for the SH64 ELF section flags to be copied correctly.  */
end_comment

begin_function
name|bfd_boolean
name|sh64_bfd_elf_copy_private_section_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|asection
modifier|*
name|isec
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|,
name|asection
modifier|*
name|osec
parameter_list|)
block|{
name|struct
name|sh64_section_data
modifier|*
name|sh64_sec_data
decl_stmt|;
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_elf_flavour
operator|||
name|obfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|_bfd_elf_copy_private_section_data
argument_list|(
name|ibfd
argument_list|,
name|isec
argument_list|,
name|obfd
argument_list|,
name|osec
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|sh64_sec_data
operator|=
name|sh64_elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|sh64_info
expr_stmt|;
if|if
condition|(
name|sh64_sec_data
operator|==
name|NULL
condition|)
block|{
name|sh64_sec_data
operator|=
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sh64_section_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh64_sec_data
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sh64_sec_data
operator|->
name|contents_flags
operator|=
operator|(
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_flags
operator|&
operator|(
name|SHF_SH5_ISA32
operator||
name|SHF_SH5_ISA32_MIXED
operator|)
operator|)
expr_stmt|;
name|sh64_elf_section_data
argument_list|(
name|osec
argument_list|)
operator|->
name|sh64_info
operator|=
name|sh64_sec_data
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Function to keep SH64 specific file flags.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sh64_elf_set_private_flags
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|flagword
name|flags
parameter_list|)
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|||
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|==
name|flags
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
return|return
name|sh64_elf_set_mach_from_flags
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called when writing out an object file to decide the type of a symbol.  */
end_comment

begin_function
specifier|static
name|int
name|sh64_elf_get_symbol_type
parameter_list|(
name|Elf_Internal_Sym
modifier|*
name|elf_sym
parameter_list|,
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|elf_sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_DATALABEL
condition|)
return|return
name|STT_DATALABEL
return|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Hook called by the linker routine which adds symbols from an object    file.  We must make indirect symbols for undefined symbols marked with    STT_DATALABEL, so relocations passing them will pick up that attribute    and neutralize STO_SH5_ISA32 found on the symbol definition.     There is a problem, though: We want to fill in the hash-table entry for    this symbol and signal to the caller that no further processing is    needed.  But we don't have the index for this hash-table entry.  We    rely here on that the current entry is the first hash-entry with NULL,    which seems brittle.  Also, iterating over the hash-table to find that    entry is a linear operation on the number of symbols in this input    file, and this function should take constant time, so that's not good    too.  Only comfort is that DataLabel references should only be found in    hand-written assembly code and thus be rare.  FIXME: Talk maintainers    into adding an option to elf_add_symbol_hook (preferably) for the index    or the hash entry, alternatively adding the index to Elf_Internal_Sym    (not so good).  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sh64_elf_add_symbol_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|namep
parameter_list|,
name|flagword
modifier|*
name|flagsp
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
modifier|*
name|secp
parameter_list|,
name|bfd_vma
modifier|*
name|valp
parameter_list|)
block|{
comment|/* We want to do this for relocatable as well as final linking.  */
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_DATALABEL
operator|&&
name|is_elf_hash_table
argument_list|(
name|info
operator|->
name|hash
argument_list|)
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* For relocatable links, we register the DataLabel sym in its own 	 right, and tweak the name when it's output.  Otherwise, we make 	 an indirect symbol of it.  */
name|flagword
name|flags
init|=
name|info
operator|->
name|relocatable
operator|||
name|info
operator|->
name|emitrelocations
condition|?
name|BSF_GLOBAL
else|:
name|BSF_GLOBAL
operator||
name|BSF_INDIRECT
decl_stmt|;
name|char
modifier|*
name|dl_name
init|=
name|bfd_malloc
argument_list|(
name|strlen
argument_list|(
operator|*
name|namep
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|DATALABEL_SUFFIX
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hash
init|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sym_hash
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Allocation may fail.  */
if|if
condition|(
name|dl_name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|strcpy
argument_list|(
name|dl_name
argument_list|,
operator|*
name|namep
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dl_name
argument_list|,
name|DATALABEL_SUFFIX
argument_list|)
expr_stmt|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|dl_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
comment|/* No previous datalabel symbol.  Make one.  */
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|dl_name
argument_list|,
name|flags
argument_list|,
operator|*
name|secp
argument_list|,
operator|*
name|valp
argument_list|,
operator|*
name|namep
argument_list|,
name|FALSE
argument_list|,
name|bed
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|dl_name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_ELF
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_DATALABEL
expr_stmt|;
block|}
else|else
comment|/* If a new symbol was created, it holds the allocated name. 	   Otherwise, we don't need it anymore and should deallocate it.  */
name|free
argument_list|(
name|dl_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|STT_DATALABEL
operator|||
operator|(
operator|(
name|info
operator|->
name|relocatable
operator|||
name|info
operator|->
name|emitrelocations
operator|)
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefined
operator|)
operator|||
operator|(
operator|!
name|info
operator|->
name|relocatable
operator|&&
operator|!
name|info
operator|->
name|emitrelocations
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_indirect
operator|)
condition|)
block|{
comment|/* Make sure we don't get confused on invalid input.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: encountered datalabel symbol in input"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Now find the hash-table slot for this entry and fill it in.  */
while|while
condition|(
operator|*
name|sym_hash
operator|!=
name|NULL
condition|)
name|sym_hash
operator|++
expr_stmt|;
operator|*
name|sym_hash
operator|=
name|h
expr_stmt|;
comment|/* Signal to caller to skip this symbol - we've handled it.  */
operator|*
name|namep
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This hook function is called before the linker writes out a global    symbol.  For relocatable links, DataLabel symbols will be present in    linker output.  We cut off the special suffix on those symbols, so the    right name appears in the output.     When linking and emitting relocations, there can appear global symbols    that are not referenced by relocs, but rather only implicitly through    DataLabel references, a relation that is not visible to the linker.    Since no stripping of global symbols in done when doing such linking,    we don't need to look up and make sure to emit the main symbol for each    DataLabel symbol.  */
end_comment

begin_function
name|bfd_boolean
name|sh64_elf_link_output_symbol_hook
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|cname
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|,
name|asection
modifier|*
name|input_sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
name|cname
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
operator|||
name|info
operator|->
name|emitrelocations
condition|)
block|{
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_DATALABEL
condition|)
name|name
index|[
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
name|strlen
argument_list|(
name|DATALABEL_SUFFIX
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Check a SH64-specific reloc and put the value to relocate to into    RELOCATION, ready to pass to _bfd_final_link_relocate.  Return FALSE if    bad value, TRUE if ok.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|shmedia_prepare_reloc
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|bfd_vma
modifier|*
name|relocation
parameter_list|)
block|{
name|bfd_vma
name|disp
decl_stmt|,
name|dropped
decl_stmt|;
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_SH_PT_16
case|:
comment|/* Check the lowest bit of the destination field.  If it is 1, we 	 check the ISA type of the destination (i.e. the low bit of the 	 "relocation" value, and emit an error if the instruction does not 	 match).  If it is 0, we change a PTA to PTB.  There should never 	 be a PTB that should change to a PTA; that indicates a toolchain 	 error; a mismatch with GAS.  */
block|{
name|char
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
name|bfd_vma
name|insn
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|insn
operator|&
operator|(
literal|1
operator|<<
literal|10
operator|)
condition|)
block|{
comment|/* Check matching insn and ISA (address of target).  */
if|if
condition|(
operator|(
name|insn
operator|&
name|SHMEDIA_PTB_BIT
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
operator|*
name|relocation
operator|+
name|rel
operator|->
name|r_addend
operator|)
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"PTB mismatch: a SHmedia address (bit 0 == 1)"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
name|SHMEDIA_PTB_BIT
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
operator|*
name|relocation
operator|+
name|rel
operator|->
name|r_addend
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"PTA mismatch: a SHcompact address (bit 0 == 0)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
operator|&&
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|info
argument_list|,
name|msg
argument_list|,
name|abfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
comment|/* We shouldn't get here with a PTB insn and a R_SH_PT_16.  It 	       means GAS output does not match expectations; a PTA or PTB 	       expressed as such (or a PT found at assembly to be PTB) 	       would match the test above, and PT expansion with an 	       unknown destination (or when relaxing) will get us here.  */
if|if
condition|(
operator|(
name|insn
operator|&
name|SHMEDIA_PTB_BIT
operator|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: GAS error: unexpected PTB insn with R_SH_PT_16"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_section
operator|->
name|owner
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Change the PTA to a PTB, if destination indicates so.  */
if|if
condition|(
operator|(
operator|(
operator|*
name|relocation
operator|+
name|rel
operator|->
name|r_addend
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
operator||
name|SHMEDIA_PTB_BIT
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
block|}
case|case
name|R_SH_SHMEDIA_CODE
case|:
case|case
name|R_SH_DIR5U
case|:
case|case
name|R_SH_DIR6S
case|:
case|case
name|R_SH_DIR6U
case|:
case|case
name|R_SH_DIR10S
case|:
case|case
name|R_SH_DIR10SW
case|:
case|case
name|R_SH_DIR10SL
case|:
case|case
name|R_SH_DIR10SQ
case|:
case|case
name|R_SH_IMMS16
case|:
case|case
name|R_SH_IMMU16
case|:
case|case
name|R_SH_IMM_LOW16
case|:
case|case
name|R_SH_IMM_LOW16_PCREL
case|:
case|case
name|R_SH_IMM_MEDLOW16
case|:
case|case
name|R_SH_IMM_MEDLOW16_PCREL
case|:
case|case
name|R_SH_IMM_MEDHI16
case|:
case|case
name|R_SH_IMM_MEDHI16_PCREL
case|:
case|case
name|R_SH_IMM_HI16
case|:
case|case
name|R_SH_IMM_HI16_PCREL
case|:
case|case
name|R_SH_64
case|:
case|case
name|R_SH_64_PCREL
case|:
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
name|disp
operator|=
operator|(
operator|*
name|relocation
operator|&
literal|0xf
operator|)
expr_stmt|;
name|dropped
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_SH_DIR10SW
case|:
name|dropped
operator|=
name|disp
operator|&
literal|1
expr_stmt|;
break|break;
case|case
name|R_SH_DIR10SL
case|:
name|dropped
operator|=
name|disp
operator|&
literal|3
expr_stmt|;
break|break;
case|case
name|R_SH_DIR10SQ
case|:
name|dropped
operator|=
name|disp
operator|&
literal|7
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dropped
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: error: unaligned relocation type %d at %08x reloc %08x\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_section
operator|->
name|owner
argument_list|)
argument_list|,
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
operator|(
name|unsigned
operator|)
name|relocation
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Helper function to locate the section holding a certain address.  This    is called via bfd_map_over_sections.  */
end_comment

begin_function
specifier|static
name|void
name|sh64_find_section_for_address
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|bfd_vma
name|vma
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|struct
name|sh64_find_section_vma_data
modifier|*
name|fsec_datap
init|=
operator|(
expr|struct
name|sh64_find_section_vma_data
operator|*
operator|)
name|data
decl_stmt|;
comment|/* Return if already found.  */
if|if
condition|(
name|fsec_datap
operator|->
name|section
condition|)
return|return;
comment|/* If this section isn't part of the addressable contents, skip it.  */
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
return|return;
name|vma
operator|=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsec_datap
operator|->
name|addr
operator|<
name|vma
condition|)
return|return;
comment|/* FIXME: section->reloc_done isn't set properly; a generic buglet      preventing us from using bfd_get_section_size_after_reloc.  */
name|size
operator|=
name|section
operator|->
name|_cooked_size
condition|?
name|section
operator|->
name|_cooked_size
else|:
name|section
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|fsec_datap
operator|->
name|addr
operator|>=
name|vma
operator|+
name|size
condition|)
return|return;
name|fsec_datap
operator|->
name|section
operator|=
name|section
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make sure to write out the generated entries in the .cranges section    when doing partial linking, and set bit 0 on the entry address if it    points to SHmedia code and write sorted .cranges entries when writing    executables (final linking and objcopy).  */
end_comment

begin_function
specifier|static
name|void
name|sh64_elf_final_write_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|linker
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_vma
name|ld_generated_cranges_size
decl_stmt|;
name|asection
modifier|*
name|cranges
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|SH64_CRANGES_SECTION_NAME
argument_list|)
decl_stmt|;
comment|/* If no new .cranges were added, the generic ELF linker parts will      write it all out.  If not, we need to write them out when doing      partial linking.  For a final link, we will sort them and write them      all out further below.  */
if|if
condition|(
name|linker
operator|&&
name|cranges
operator|!=
name|NULL
operator|&&
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_type
operator|!=
name|ET_EXEC
operator|&&
operator|(
name|ld_generated_cranges_size
operator|=
name|sh64_elf_section_data
argument_list|(
name|cranges
argument_list|)
operator|->
name|sh64_info
operator|->
name|cranges_growth
operator|)
operator|!=
literal|0
condition|)
block|{
name|bfd_vma
name|incoming_cranges_size
init|=
operator|(
operator|(
name|cranges
operator|->
name|_cooked_size
operator|!=
literal|0
condition|?
name|cranges
operator|->
name|_cooked_size
else|:
name|cranges
operator|->
name|_raw_size
operator|)
operator|-
name|ld_generated_cranges_size
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|cranges
argument_list|,
name|cranges
operator|->
name|contents
operator|+
name|incoming_cranges_size
argument_list|,
name|cranges
operator|->
name|output_offset
operator|+
name|incoming_cranges_size
argument_list|,
name|ld_generated_cranges_size
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: could not write out added .cranges entries"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Only set entry address bit 0 and sort .cranges when linking to an      executable; never with objcopy or strip.  */
if|if
condition|(
name|linker
operator|&&
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_type
operator|==
name|ET_EXEC
condition|)
block|{
name|struct
name|sh64_find_section_vma_data
name|fsec_data
decl_stmt|;
name|sh64_elf_crange
name|dummy
decl_stmt|;
comment|/* For a final link, set the low bit of the entry address to 	 reflect whether or not it is a SHmedia address. 	 FIXME: Perhaps we shouldn't do this if the entry address was 	 supplied numerically, but we currently lack the infrastructure to 	 recognize that: The entry symbol, and info whether it is numeric 	 or a symbol name is kept private in the linker.  */
name|fsec_data
operator|.
name|addr
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_entry
expr_stmt|;
name|fsec_data
operator|.
name|section
operator|=
name|NULL
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|sh64_find_section_for_address
argument_list|,
operator|&
name|fsec_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsec_data
operator|.
name|section
operator|&&
operator|(
name|sh64_get_contents_type
argument_list|(
name|fsec_data
operator|.
name|section
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_entry
argument_list|,
operator|&
name|dummy
argument_list|)
operator|==
name|CRT_SH5_ISA32
operator|)
condition|)
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_entry
operator||=
literal|1
expr_stmt|;
comment|/* If we have a .cranges section, sort the entries.  */
if|if
condition|(
name|cranges
operator|!=
name|NULL
condition|)
block|{
name|bfd_size_type
name|cranges_size
init|=
operator|(
name|cranges
operator|->
name|_cooked_size
operator|!=
literal|0
condition|?
name|cranges
operator|->
name|_cooked_size
else|:
name|cranges
operator|->
name|_raw_size
operator|)
decl_stmt|;
comment|/* We know we always have these in memory at this time.  */
name|BFD_ASSERT
argument_list|(
name|cranges
operator|->
name|contents
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* The .cranges may already have been sorted in the process of 	     finding out the ISA-type of the entry address.  If not, we do 	     it here.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|cranges
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|!=
name|SHT_SH5_CR_SORTED
condition|)
block|{
name|qsort
argument_list|(
name|cranges
operator|->
name|contents
argument_list|,
name|cranges_size
operator|/
name|SH64_CRANGE_SIZE
argument_list|,
name|SH64_CRANGE_SIZE
argument_list|,
name|bfd_big_endian
argument_list|(
name|cranges
operator|->
name|owner
argument_list|)
condition|?
name|_bfd_sh64_crange_qsort_cmpb
else|:
name|_bfd_sh64_crange_qsort_cmpl
argument_list|)
expr_stmt|;
name|elf_section_data
argument_list|(
name|cranges
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|=
name|SHT_SH5_CR_SORTED
expr_stmt|;
block|}
comment|/* We need to write it out in whole as sorted.  */
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|cranges
argument_list|,
name|cranges
operator|->
name|contents
argument_list|,
name|cranges
operator|->
name|output_offset
argument_list|,
name|cranges_size
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: could not write out sorted .cranges entries"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Merge non visibility st_other attribute when the symbol comes from    a dynamic object.  */
end_comment

begin_function
specifier|static
name|void
name|sh64_elf_merge_symbol_attribute
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
specifier|const
name|Elf_Internal_Sym
modifier|*
name|isym
parameter_list|,
name|bfd_boolean
name|definition
parameter_list|,
name|bfd_boolean
name|dynamic
parameter_list|)
block|{
if|if
condition|(
name|isym
operator|->
name|st_other
operator|!=
literal|0
operator|&&
name|dynamic
condition|)
block|{
name|unsigned
name|char
name|other
decl_stmt|;
comment|/* Take the balance of OTHER from the definition.  */
name|other
operator|=
operator|(
name|definition
condition|?
name|isym
operator|->
name|st_other
else|:
name|h
operator|->
name|other
operator|)
expr_stmt|;
name|other
operator|&=
operator|~
name|ELF_ST_VISIBILITY
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|h
operator|->
name|other
operator|=
name|other
operator||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|bfd_elf_special_section
specifier|const
name|sh64_elf_special_sections
index|[]
init|=
block|{
block|{
literal|".cranges"
block|,
literal|8
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|TARGET_BIG_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_sh64_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BIG_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-sh64"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_sh64l_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-sh64l"
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

begin_comment
comment|/* NetBSD support.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_BIG_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_sh64nbsd_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BIG_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-sh64-nbsd"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_sh64lnbsd_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-sh64l-nbsd"
end_define

begin_undef
undef|#
directive|undef
name|ELF_MAXPAGESIZE
end_undef

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x10000
end_define

begin_undef
undef|#
directive|undef
name|elf_symbol_leading_char
end_undef

begin_define
define|#
directive|define
name|elf_symbol_leading_char
value|0
end_define

begin_undef
undef|#
directive|undef
name|elf32_bed
end_undef

begin_define
define|#
directive|define
name|elf32_bed
value|elf32_sh64_nbsd_bed
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

begin_comment
comment|/* Linux support.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_BIG_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_sh64blin_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BIG_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-sh64big-linux"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_sh64lin_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-sh64-linux"
end_define

begin_undef
undef|#
directive|undef
name|elf32_bed
end_undef

begin_define
define|#
directive|define
name|elf32_bed
value|elf32_sh64_lin_bed
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

