begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Matsushita 10300 specific support for 32-bit ELF    Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,    2006 Free Software Foundation, Inc.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/mn10300.h"
end_include

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mn10300_elf_final_link_relocate
name|PARAMS
argument_list|(
operator|(
name|reloc_howto_type
operator|*
operator|,
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|unsigned
name|long
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mn10300_elf_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mn10300_elf_relax_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd_boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_byte
modifier|*
name|mn10300_elf_get_relocated_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|bfd_link_order
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_boolean
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|elf_mn10300_mach
name|PARAMS
argument_list|(
operator|(
name|flagword
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|_bfd_mn10300_elf_final_write_processing
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_boolean
name|_bfd_mn10300_elf_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_boolean
name|_bfd_mn10300_elf_merge_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The mn10300 linker needs to keep track of the number of relocs that    it decides to copy in check_relocs for each symbol.  This is so    that it can discard PC relative relocs if it doesn't need them when    linking with -Bsymbolic.  We store the information in a field    extending the regular ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|elf32_mn10300_link_hash_entry
block|{
comment|/* The basic elf link hash table entry.  */
name|struct
name|elf_link_hash_entry
name|root
decl_stmt|;
comment|/* For function symbols, the number of times this function is      called directly (ie by name).  */
name|unsigned
name|int
name|direct_calls
decl_stmt|;
comment|/* For function symbols, the size of this function's stack      (if<= 255 bytes).  We stuff this into "call" instructions      to this target when it's valid and profitable to do so.       This does not include stack allocated by movm!  */
name|unsigned
name|char
name|stack_size
decl_stmt|;
comment|/* For function symbols, arguments (if any) for movm instruction      in the prologue.  We stuff this value into "call" instructions      to the target when it's valid and profitable to do so.  */
name|unsigned
name|char
name|movm_args
decl_stmt|;
comment|/* For function symbols, the amount of stack space that would be allocated      by the movm instruction.  This is redundant with movm_args, but we      add it to the hash table to avoid computing it over and over.  */
name|unsigned
name|char
name|movm_stack_size
decl_stmt|;
comment|/* When set, convert all "call" instructions to this target into "calls"    instructions.  */
define|#
directive|define
name|MN10300_CONVERT_CALL_TO_CALLS
value|0x1
comment|/* Used to mark functions which have had redundant parts of their    prologue deleted.  */
define|#
directive|define
name|MN10300_DELETED_PROLOGUE_BYTES
value|0x2
name|unsigned
name|char
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* We derive a hash table from the main elf linker hash table so    we can store state variables and a secondary hash table without    resorting to global variables.  */
end_comment

begin_struct
struct|struct
name|elf32_mn10300_link_hash_table
block|{
comment|/* The main hash table.  */
name|struct
name|elf_link_hash_table
name|root
decl_stmt|;
comment|/* A hash table for static functions.  We could derive a new hash table      instead of using the full elf32_mn10300_link_hash_table if we wanted      to save some memory.  */
name|struct
name|elf32_mn10300_link_hash_table
modifier|*
name|static_hash_table
decl_stmt|;
comment|/* Random linker state flags.  */
define|#
directive|define
name|MN10300_HASH_ENTRIES_INITIALIZED
value|0x1
name|char
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* For MN10300 linker hash table.  */
end_comment

begin_comment
comment|/* Get the MN10300 ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|elf32_mn10300_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct elf32_mn10300_link_hash_table *) ((p)->hash))
end_define

begin_define
define|#
directive|define
name|elf32_mn10300_link_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
define|\
value|(elf_link_hash_traverse						\    (&(table)->root,							\     (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func), \     (info)))
end_define

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|elf32_mn10300_link_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elf32_mn10300_link_hash_table_create
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf32_mn10300_link_hash_table_free
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_hash_table
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|bfd_elf32_bfd_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|bfd_reloc_code_real_type
name|code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mn10300_info_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mn10300_elf_check_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|mn10300_elf_gc_mark_hook
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
name|info
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mn10300_elf_relax_delete_bytes
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mn10300_elf_symbol_address_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf32_mn10300_finish_hash_table_entry
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_function_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|elf32_mn10300_link_hash_entry
operator|*
operator|,
name|bfd_vma
operator|,
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|_bfd_mn10300_elf_create_got_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|_bfd_mn10300_elf_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|_bfd_mn10300_elf_adjust_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|_bfd_mn10300_elf_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|_bfd_mn10300_elf_finish_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|_bfd_mn10300_elf_finish_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_mn10300_howto_table
index|[]
init|=
block|{
comment|/* Dummy relocation.  Does nothing.  */
name|HOWTO
argument_list|(
name|R_MN10300_NONE
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_MN10300_NONE"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
block|,
comment|/* Standard 32 bit reloc.  */
name|HOWTO
argument_list|(
name|R_MN10300_32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_MN10300_32"
argument_list|,
name|FALSE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
comment|/* Standard 16 bit reloc.  */
name|HOWTO
argument_list|(
name|R_MN10300_16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_MN10300_16"
argument_list|,
name|FALSE
argument_list|,
literal|0xffff
argument_list|,
literal|0xffff
argument_list|,
name|FALSE
argument_list|)
block|,
comment|/* Standard 8 bit reloc.  */
name|HOWTO
argument_list|(
name|R_MN10300_8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_MN10300_8"
argument_list|,
name|FALSE
argument_list|,
literal|0xff
argument_list|,
literal|0xff
argument_list|,
name|FALSE
argument_list|)
block|,
comment|/* Standard 32bit pc-relative reloc.  */
name|HOWTO
argument_list|(
name|R_MN10300_PCREL32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_MN10300_PCREL32"
argument_list|,
name|FALSE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|TRUE
argument_list|)
block|,
comment|/* Standard 16bit pc-relative reloc.  */
name|HOWTO
argument_list|(
name|R_MN10300_PCREL16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_MN10300_PCREL16"
argument_list|,
name|FALSE
argument_list|,
literal|0xffff
argument_list|,
literal|0xffff
argument_list|,
name|TRUE
argument_list|)
block|,
comment|/* Standard 8 pc-relative reloc.  */
name|HOWTO
argument_list|(
name|R_MN10300_PCREL8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_MN10300_PCREL8"
argument_list|,
name|FALSE
argument_list|,
literal|0xff
argument_list|,
literal|0xff
argument_list|,
name|TRUE
argument_list|)
block|,
comment|/* GNU extension to record C++ vtable hierarchy */
name|HOWTO
argument_list|(
name|R_MN10300_GNU_VTINHERIT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_MN10300_GNU_VTINHERIT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable member usage */
name|HOWTO
argument_list|(
name|R_MN10300_GNU_VTENTRY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_MN10300_GNU_VTENTRY"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Standard 24 bit reloc.  */
name|HOWTO
argument_list|(
name|R_MN10300_24
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|24
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_MN10300_24"
argument_list|,
name|FALSE
argument_list|,
literal|0xffffff
argument_list|,
literal|0xffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_MN10300_GOTPC32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* */
literal|"R_MN10300_GOTPC32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MN10300_GOTPC16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* */
literal|"R_MN10300_GOTPC16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MN10300_GOTOFF32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* */
literal|"R_MN10300_GOTOFF32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MN10300_GOTOFF24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|24
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* */
literal|"R_MN10300_GOTOFF24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffff
argument_list|,
comment|/* src_mask */
literal|0xffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MN10300_GOTOFF16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* */
literal|"R_MN10300_GOTOFF16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MN10300_PLT32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* */
literal|"R_MN10300_PLT32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MN10300_PLT16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* */
literal|"R_MN10300_PLT16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MN10300_GOT32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* */
literal|"R_MN10300_GOT32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MN10300_GOT24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|24
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* */
literal|"R_MN10300_GOT24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MN10300_GOT16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* */
literal|"R_MN10300_GOT16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MN10300_COPY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* */
literal|"R_MN10300_COPY"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MN10300_GLOB_DAT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* */
literal|"R_MN10300_GLOB_DAT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MN10300_JMP_SLOT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* */
literal|"R_MN10300_JMP_SLOT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MN10300_RELATIVE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* */
literal|"R_MN10300_RELATIVE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|mn10300_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_val
decl_stmt|;
name|unsigned
name|char
name|elf_reloc_val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|mn10300_reloc_map
name|mn10300_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_MN10300_NONE
block|, }
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_MN10300_32
block|, }
block|,
block|{
name|BFD_RELOC_16
block|,
name|R_MN10300_16
block|, }
block|,
block|{
name|BFD_RELOC_8
block|,
name|R_MN10300_8
block|, }
block|,
block|{
name|BFD_RELOC_32_PCREL
block|,
name|R_MN10300_PCREL32
block|, }
block|,
block|{
name|BFD_RELOC_16_PCREL
block|,
name|R_MN10300_PCREL16
block|, }
block|,
block|{
name|BFD_RELOC_8_PCREL
block|,
name|R_MN10300_PCREL8
block|, }
block|,
block|{
name|BFD_RELOC_24
block|,
name|R_MN10300_24
block|, }
block|,
block|{
name|BFD_RELOC_VTABLE_INHERIT
block|,
name|R_MN10300_GNU_VTINHERIT
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_ENTRY
block|,
name|R_MN10300_GNU_VTENTRY
block|}
block|,
block|{
name|BFD_RELOC_32_GOT_PCREL
block|,
name|R_MN10300_GOTPC32
block|}
block|,
block|{
name|BFD_RELOC_16_GOT_PCREL
block|,
name|R_MN10300_GOTPC16
block|}
block|,
block|{
name|BFD_RELOC_32_GOTOFF
block|,
name|R_MN10300_GOTOFF32
block|}
block|,
block|{
name|BFD_RELOC_MN10300_GOTOFF24
block|,
name|R_MN10300_GOTOFF24
block|}
block|,
block|{
name|BFD_RELOC_16_GOTOFF
block|,
name|R_MN10300_GOTOFF16
block|}
block|,
block|{
name|BFD_RELOC_32_PLT_PCREL
block|,
name|R_MN10300_PLT32
block|}
block|,
block|{
name|BFD_RELOC_16_PLT_PCREL
block|,
name|R_MN10300_PLT16
block|}
block|,
block|{
name|BFD_RELOC_MN10300_GOT32
block|,
name|R_MN10300_GOT32
block|}
block|,
block|{
name|BFD_RELOC_MN10300_GOT24
block|,
name|R_MN10300_GOT24
block|}
block|,
block|{
name|BFD_RELOC_MN10300_GOT16
block|,
name|R_MN10300_GOT16
block|}
block|,
block|{
name|BFD_RELOC_MN10300_COPY
block|,
name|R_MN10300_COPY
block|}
block|,
block|{
name|BFD_RELOC_MN10300_GLOB_DAT
block|,
name|R_MN10300_GLOB_DAT
block|}
block|,
block|{
name|BFD_RELOC_MN10300_JMP_SLOT
block|,
name|R_MN10300_JMP_SLOT
block|}
block|,
block|{
name|BFD_RELOC_MN10300_RELATIVE
block|,
name|R_MN10300_RELATIVE
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create the GOT section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|_bfd_mn10300_elf_create_got_section
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|;
name|flagword
name|pltflags
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|int
name|ptralign
decl_stmt|;
comment|/* This function may be called more than once.  */
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|TRUE
return|;
switch|switch
condition|(
name|bed
operator|->
name|s
operator|->
name|arch_size
condition|)
block|{
case|case
literal|32
case|:
name|ptralign
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|ptralign
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|pltflags
operator|=
name|flags
expr_stmt|;
name|pltflags
operator||=
name|SEC_CODE
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|plt_not_loaded
condition|)
name|pltflags
operator|&=
operator|~
operator|(
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator|)
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|plt_readonly
condition|)
name|pltflags
operator||=
name|SEC_READONLY
expr_stmt|;
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".plt"
argument_list|,
name|pltflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|bed
operator|->
name|plt_alignment
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the      .plt section.  */
if|if
condition|(
name|bed
operator|->
name|want_plt_sym
condition|)
block|{
name|h
operator|=
name|_bfd_elf_define_linkage_sym
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|s
argument_list|,
literal|"_PROCEDURE_LINKAGE_TABLE_"
argument_list|)
expr_stmt|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hplt
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|ptralign
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bed
operator|->
name|want_got_plt
condition|)
block|{
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".got.plt"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|ptralign
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the .got      (or .got.plt) section.  We don't do this in the linker script      because we don't want to define the symbol if we are not creating      a global offset table.  */
name|h
operator|=
name|_bfd_elf_define_linkage_sym
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|s
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
expr_stmt|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hgot
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* The first bit of the global offset table is the header.  */
name|s
operator|->
name|size
operator|+=
name|bed
operator|->
name|got_header_size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|bfd_elf32_bfd_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|mn10300_reloc_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|mn10300_reloc_map
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mn10300_reloc_map
index|[
name|i
index|]
operator|.
name|bfd_reloc_val
operator|==
name|code
condition|)
return|return
operator|&
name|elf_mn10300_howto_table
index|[
name|mn10300_reloc_map
index|[
name|i
index|]
operator|.
name|elf_reloc_val
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set the howto pointer for an MN10300 ELF reloc.  */
end_comment

begin_function
specifier|static
name|void
name|mn10300_info_to_howto
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r_type
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_MN10300_MAX
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf_mn10300_howto_table
index|[
name|r_type
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase.    Since we don't do .gots or .plts, we just need to consider the    virtual table relocs for gc.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mn10300_elf_check_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|,
modifier|*
modifier|*
name|sym_hashes_end
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|sgot
operator|=
name|NULL
expr_stmt|;
name|srelgot
operator|=
name|NULL
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_hashes_end
operator|=
name|sym_hashes
operator|+
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|sym_hashes_end
operator|-=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
comment|/* Some relocs require a global offset table.  */
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_MN10300_GOT32
case|:
case|case
name|R_MN10300_GOT24
case|:
case|case
name|R_MN10300_GOT16
case|:
case|case
name|R_MN10300_GOTOFF32
case|:
case|case
name|R_MN10300_GOTOFF24
case|:
case|case
name|R_MN10300_GOTOFF16
case|:
case|case
name|R_MN10300_GOTPC32
case|:
case|case
name|R_MN10300_GOTPC16
case|:
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_mn10300_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
default|default:
break|break;
block|}
block|}
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
comment|/* This relocation describes the C++ object vtable hierarchy. 	   Reconstruct it for later use during GC.  */
case|case
name|R_MN10300_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually 	   used.  Record for later use during GC.  */
case|case
name|R_MN10300_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|R_MN10300_GOT32
case|:
case|case
name|R_MN10300_GOT24
case|:
case|case
name|R_MN10300_GOT16
case|:
comment|/* This symbol requires a global offset table entry.  */
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
block|{
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|srelgot
operator|==
name|NULL
operator|&&
operator|(
name|h
operator|!=
name|NULL
operator|||
name|info
operator|->
name|shared
operator|)
condition|)
block|{
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srelgot
operator|==
name|NULL
condition|)
block|{
name|srelgot
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|srelgot
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|srelgot
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
comment|/* We have already allocated space in the .got.  */
break|break;
name|h
operator|->
name|got
operator|.
name|offset
operator|=
name|sgot
operator|->
name|size
expr_stmt|;
comment|/* Make sure this symbol is output as a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|srelgot
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a global offset table entry for a local 		 symbol.  */
if|if
condition|(
name|local_got_offsets
operator|==
name|NULL
condition|)
block|{
name|size_t
name|size
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|size
operator|=
name|symtab_hdr
operator|->
name|sh_info
operator|*
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
expr_stmt|;
name|local_got_offsets
operator|=
operator|(
name|bfd_vma
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_offsets
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_local_got_offsets
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_got_offsets
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|;
name|i
operator|++
control|)
name|local_got_offsets
index|[
name|i
index|]
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|local_got_offsets
index|[
name|r_symndx
index|]
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
comment|/* We have already allocated space in the .got.  */
break|break;
name|local_got_offsets
index|[
name|r_symndx
index|]
operator|=
name|sgot
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
comment|/* If we are generating a shared object, we need to 		   output a R_MN10300_RELATIVE reloc so that the dynamic 		   linker can adjust this GOT entry.  */
name|srelgot
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
name|sgot
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|R_MN10300_PLT32
case|:
case|case
name|R_MN10300_PLT16
case|:
comment|/* This symbol requires a procedure linkage table entry.  We 	     actually build the entry in adjust_dynamic_symbol, 	     because this might be a case of linking PIC code which is 	     never referenced by a dynamic object, in which case we 	     don't need to generate a procedure linkage table entry 	     after all.  */
comment|/* If this is a local symbol, we resolve it directly without 	     creating a procedure linkage table entry.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_INTERNAL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_HIDDEN
condition|)
break|break;
name|h
operator|->
name|needs_plt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_MN10300_24
case|:
case|case
name|R_MN10300_16
case|:
case|case
name|R_MN10300_8
case|:
case|case
name|R_MN10300_PCREL32
case|:
case|case
name|R_MN10300_PCREL16
case|:
case|case
name|R_MN10300_PCREL8
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|h
operator|->
name|non_got_ref
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_MN10300_32
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|h
operator|->
name|non_got_ref
operator|=
literal|1
expr_stmt|;
comment|/* If we are creating a shared library, then we need to copy 	     the reloc into the shared library.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* When creating a shared object, we must copy these 		 reloc types into the output file.  We create a reloc 		 section in dynobj and make room for this reloc.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|BFD_ASSERT
argument_list|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
name|flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
name|sreloc
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
name|sreloc
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return the section that should be marked against GC for a given    relocation.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|mn10300_elf_gc_mark_hook
parameter_list|(
name|sec
parameter_list|,
name|info
parameter_list|,
name|rel
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_MN10300_GNU_VTINHERIT
case|:
case|case
name|R_MN10300_GNU_VTENTRY
case|:
break|break;
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
default|default:
break|break;
block|}
block|}
block|}
else|else
return|return
name|bfd_section_from_elf_index
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Perform a relocation as part of a final link.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mn10300_elf_final_link_relocate
parameter_list|(
name|howto
parameter_list|,
name|input_bfd
parameter_list|,
name|output_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|offset
parameter_list|,
name|value
parameter_list|,
name|addend
parameter_list|,
name|h
parameter_list|,
name|symndx
parameter_list|,
name|info
parameter_list|,
name|sym_sec
parameter_list|,
name|is_local
parameter_list|)
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|unsigned
name|long
name|symndx
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sym_sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|is_local
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|long
name|r_type
init|=
name|howto
operator|->
name|type
decl_stmt|;
name|bfd_byte
modifier|*
name|hit_data
init|=
name|contents
operator|+
name|offset
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|NULL
expr_stmt|;
name|splt
operator|=
name|NULL
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_MN10300_24
case|:
case|case
name|R_MN10300_16
case|:
case|case
name|R_MN10300_8
case|:
case|case
name|R_MN10300_PCREL8
case|:
case|case
name|R_MN10300_PCREL16
case|:
case|case
name|R_MN10300_PCREL32
case|:
case|case
name|R_MN10300_GOTOFF32
case|:
case|case
name|R_MN10300_GOTOFF24
case|:
case|case
name|R_MN10300_GOTOFF16
case|:
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|!=
name|NULL
operator|&&
operator|!
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|bfd_reloc_dangerous
return|;
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_MN10300_NONE
case|:
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_MN10300_32
case|:
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_boolean
name|skip
decl_stmt|,
name|relocate
decl_stmt|;
comment|/* When generating a shared object, these relocations are 	     copied into the output file to be resolved at run 	     time.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|elf_elfheader
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|BFD_ASSERT
argument_list|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|skip
operator|=
name|FALSE
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|input_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
block|{
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|outrel
argument_list|)
expr_stmt|;
name|relocate
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* h->dynindx may be -1 if this symbol was marked to 		 become local.  */
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|relocate
operator|=
name|TRUE
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_MN10300_RELATIVE
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|value
operator|+
name|addend
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|relocate
operator|=
name|FALSE
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_MN10300_32
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|value
operator|+
name|addend
expr_stmt|;
block|}
block|}
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|(
operator|(
operator|(
name|Elf32_External_Rela
operator|*
operator|)
name|sreloc
operator|->
name|contents
operator|)
operator|+
name|sreloc
operator|->
name|reloc_count
operator|)
argument_list|)
expr_stmt|;
operator|++
name|sreloc
operator|->
name|reloc_count
expr_stmt|;
comment|/* If this reloc is against an external symbol, we do 	     not want to fiddle with the addend.  Otherwise, we 	     need to include the symbol value so that it becomes 	     an addend for the dynamic reloc.  */
if|if
condition|(
operator|!
name|relocate
condition|)
return|return
name|bfd_reloc_ok
return|;
block|}
name|value
operator|+=
name|addend
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_MN10300_24
case|:
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0x7fffff
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x800000
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|bfd_put_8
argument_list|(
name|input_bfd
argument_list|,
name|value
operator|&
literal|0xff
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|hit_data
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
name|hit_data
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_MN10300_16
case|:
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0x7fff
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x8000
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_MN10300_8
case|:
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0x7f
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x80
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|bfd_put_8
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_MN10300_PCREL8
case|:
name|value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|offset
expr_stmt|;
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0xff
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x100
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|bfd_put_8
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_MN10300_PCREL16
case|:
name|value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|offset
expr_stmt|;
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0xffff
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x10000
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_MN10300_PCREL32
case|:
name|value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|offset
expr_stmt|;
name|value
operator|+=
name|addend
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_MN10300_GNU_VTINHERIT
case|:
case|case
name|R_MN10300_GNU_VTENTRY
case|:
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_MN10300_GOTPC32
case|:
comment|/* Use global offset table as symbol value.  */
name|value
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|offset
expr_stmt|;
name|value
operator|+=
name|addend
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_MN10300_GOTPC16
case|:
comment|/* Use global offset table as symbol value.  */
name|value
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|offset
expr_stmt|;
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0xffff
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x10000
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_MN10300_GOTOFF32
case|:
name|value
operator|-=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|value
operator|+=
name|addend
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_MN10300_GOTOFF24
case|:
name|value
operator|-=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0x7fffff
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x800000
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|bfd_put_8
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|hit_data
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
name|hit_data
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_MN10300_GOTOFF16
case|:
name|value
operator|-=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0xffff
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x10000
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_MN10300_PLT32
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_INTERNAL
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_HIDDEN
operator|&&
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
operator|-
name|value
expr_stmt|;
block|}
name|value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|offset
expr_stmt|;
name|value
operator|+=
name|addend
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_MN10300_PLT16
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_INTERNAL
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_HIDDEN
operator|&&
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
operator|-
name|value
expr_stmt|;
block|}
name|value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|offset
expr_stmt|;
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0xffff
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x10000
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_MN10300_GOT32
case|:
case|case
name|R_MN10300_GOT24
case|:
case|case
name|R_MN10300_GOT16
case|:
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|bfd_vma
name|off
decl_stmt|;
name|off
operator|=
name|h
operator|->
name|got
operator|.
name|offset
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|off
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|||
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
comment|/* This is actually a static link, or it is a 		   -Bsymbolic link and the symbol is defined 		   locally, or the symbol was forced to be local 		   because of a version file.  We must initialize 		   this entry in the global offset table.  		   When doing a dynamic link, we create a .rela.got 		   relocation entry to initialize the value.  This 		   is done in the finish_dynamic_symbol routine.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
name|value
operator|=
name|sgot
operator|->
name|output_offset
operator|+
name|off
expr_stmt|;
block|}
else|else
block|{
name|bfd_vma
name|off
decl_stmt|;
name|off
operator|=
name|elf_local_got_offsets
argument_list|(
name|input_bfd
argument_list|)
index|[
name|symndx
index|]
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|value
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srelgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_MN10300_RELATIVE
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|value
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|(
operator|(
operator|(
name|Elf32_External_Rela
operator|*
operator|)
name|srelgot
operator|->
name|contents
operator|)
operator|+
name|srelgot
operator|->
name|reloc_count
operator|)
argument_list|)
expr_stmt|;
operator|++
name|srelgot
operator|->
name|reloc_count
expr_stmt|;
block|}
name|value
operator|=
name|sgot
operator|->
name|output_offset
operator|+
name|off
expr_stmt|;
block|}
block|}
name|value
operator|+=
name|addend
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_MN10300_GOT32
condition|)
block|{
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MN10300_GOT24
condition|)
block|{
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0x7fffff
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x800000
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|bfd_put_8
argument_list|(
name|input_bfd
argument_list|,
name|value
operator|&
literal|0xff
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|hit_data
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
name|hit_data
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_MN10300_GOT16
condition|)
block|{
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0xffff
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x10000
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* Fall through.  */
default|default:
return|return
name|bfd_reloc_notsupported
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Relocate an MN10300 ELF section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mn10300_elf_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf32_mn10300_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|howto
operator|=
name|elf_mn10300_howto_table
operator|+
name|r_type
expr_stmt|;
comment|/* Just skip the vtable gc relocs.  */
if|if
condition|(
name|r_type
operator|==
name|R_MN10300_GNU_VTINHERIT
operator|||
name|r_type
operator|==
name|R_MN10300_GNU_VTENTRY
condition|)
continue|continue;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_boolean
name|unresolved_reloc
decl_stmt|;
name|bfd_boolean
name|warned
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|hh
decl_stmt|;
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|hh
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
name|h
operator|=
operator|(
expr|struct
name|elf32_mn10300_link_hash_entry
operator|*
operator|)
name|hh
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|(
name|r_type
operator|==
name|R_MN10300_GOTPC32
operator|||
name|r_type
operator|==
name|R_MN10300_GOTPC16
operator|||
operator|(
operator|(
name|r_type
operator|==
name|R_MN10300_PLT32
operator|||
name|r_type
operator|==
name|R_MN10300_PLT16
operator|)
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|root
operator|.
name|other
argument_list|)
operator|!=
name|STV_INTERNAL
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|root
operator|.
name|other
argument_list|)
operator|!=
name|STV_HIDDEN
operator|&&
name|h
operator|->
name|root
operator|.
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|)
operator|||
operator|(
operator|(
name|r_type
operator|==
name|R_MN10300_GOT32
operator|||
name|r_type
operator|==
name|R_MN10300_GOT24
operator|||
name|r_type
operator|==
name|R_MN10300_GOT16
operator|)
operator|&&
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|&&
operator|!
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|hh
argument_list|)
operator|)
operator|||
operator|(
name|r_type
operator|==
name|R_MN10300_32
operator|&&
operator|!
name|SYMBOL_REFERENCES_LOCAL
argument_list|(
name|info
argument_list|,
name|hh
argument_list|)
operator|&&
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
comment|/* DWARF will emit R_MN10300_32 relocations 			     in its sections against symbols defined 			     externally in shared libraries.  We can't 			     do anything with them here.  */
operator|||
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|->
name|root
operator|.
name|def_dynamic
operator|)
operator|)
operator|)
operator|)
condition|)
comment|/* In these cases, we don't need the relocation 	       value.  We check specially because in some 	       obscure cases sec->output_section will be NULL.  */
name|relocation
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|unresolved_reloc
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|mn10300_elf_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|output_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
argument_list|,
name|r_symndx
argument_list|,
name|info
argument_list|,
name|sec
argument_list|,
name|h
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
operator|(
name|h
condition|?
operator|&
name|h
operator|->
name|root
operator|.
name|root
else|:
name|NULL
operator|)
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|bfd_reloc_undefined
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: out of range error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
name|bfd_reloc_notsupported
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unsupported relocation error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
name|bfd_reloc_dangerous
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: dangerous error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
default|default:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unknown error"
argument_list|)
expr_stmt|;
comment|/* fall through */
name|common_error
label|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish initializing one hash table entry.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_mn10300_finish_hash_table_entry
parameter_list|(
name|gen_entry
parameter_list|,
name|in_args
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|gen_entry
decl_stmt|;
name|PTR
name|in_args
decl_stmt|;
block|{
name|struct
name|elf32_mn10300_link_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|in_args
decl_stmt|;
name|unsigned
name|int
name|byte_count
init|=
literal|0
decl_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|elf32_mn10300_link_hash_entry
operator|*
operator|)
name|gen_entry
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|entry
operator|=
operator|(
expr|struct
name|elf32_mn10300_link_hash_entry
operator|*
operator|)
name|entry
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* If we already know we want to convert "call" to "calls" for calls      to this symbol, then return now.  */
if|if
condition|(
name|entry
operator|->
name|flags
operator|==
name|MN10300_CONVERT_CALL_TO_CALLS
condition|)
return|return
name|TRUE
return|;
comment|/* If there are no named calls to this symbol, or there's nothing we      can move from the function itself into the "call" instruction,      then note that all "call" instructions should be converted into      "calls" instructions and return.  If a symbol is available for      dynamic symbol resolution (overridable or overriding), avoid      custom calling conventions.  */
if|if
condition|(
name|entry
operator|->
name|direct_calls
operator|==
literal|0
operator|||
operator|(
name|entry
operator|->
name|stack_size
operator|==
literal|0
operator|&&
name|entry
operator|->
name|movm_args
operator|==
literal|0
operator|)
operator|||
operator|(
name|elf_hash_table
argument_list|(
name|link_info
argument_list|)
operator|->
name|dynamic_sections_created
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|entry
operator|->
name|root
operator|.
name|other
argument_list|)
operator|!=
name|STV_INTERNAL
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|entry
operator|->
name|root
operator|.
name|other
argument_list|)
operator|!=
name|STV_HIDDEN
operator|)
condition|)
block|{
comment|/* Make a note that we should convert "call" instructions to "calls" 	 instructions for calls to this symbol.  */
name|entry
operator|->
name|flags
operator||=
name|MN10300_CONVERT_CALL_TO_CALLS
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* We may be able to move some instructions from the function itself into      the "call" instruction.  Count how many bytes we might be able to      eliminate in the function itself.  */
comment|/* A movm instruction is two bytes.  */
if|if
condition|(
name|entry
operator|->
name|movm_args
condition|)
name|byte_count
operator|+=
literal|2
expr_stmt|;
comment|/* Count the insn to allocate stack space too.  */
if|if
condition|(
name|entry
operator|->
name|stack_size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|stack_size
operator|<=
literal|128
condition|)
name|byte_count
operator|+=
literal|3
expr_stmt|;
else|else
name|byte_count
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* If using "call" will result in larger code, then turn all      the associated "call" instructions into "calls" instructions.  */
if|if
condition|(
name|byte_count
operator|<
name|entry
operator|->
name|direct_calls
condition|)
name|entry
operator|->
name|flags
operator||=
name|MN10300_CONVERT_CALL_TO_CALLS
expr_stmt|;
comment|/* This routine never fails.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This function handles relaxing for the mn10300.     There are quite a few relaxing opportunities available on the mn10300:  	* calls:32 -> calls:16 					   2 bytes 	* call:32  -> call:16					   2 bytes  	* call:32 -> calls:32					   1 byte 	* call:16 -> calls:16					   1 byte 		* These are done anytime using "calls" would result 		in smaller code, or when necessary to preserve the 		meaning of the program.  	* call:32						   varies 	* call:16 		* In some circumstances we can move instructions 		from a function prologue into a "call" instruction. 		This is only done if the resulting code is no larger 		than the original code.  	* jmp:32 -> jmp:16					   2 bytes 	* jmp:16 -> bra:8					   1 byte  		* If the previous instruction is a conditional branch 		around the jump/bra, we may be able to reverse its condition 		and change its target to the jump's target.  The jump/bra 		can then be deleted.				   2 bytes  	* mov abs32 -> mov abs16				   1 or 2 bytes  	* Most instructions which accept imm32 can relax to imm16  1 or 2 bytes 	- Most instructions which accept imm16 can relax to imm8   1 or 2 bytes  	* Most instructions which accept d32 can relax to d16	   1 or 2 bytes 	- Most instructions which accept d16 can relax to d8	   1 or 2 bytes  	We don't handle imm16->imm8 or d16->d8 as they're very rare 	and somewhat more difficult to support.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mn10300_elf_relax_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|link_info
parameter_list|,
name|again
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|bfd_boolean
modifier|*
name|again
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
name|struct
name|elf32_mn10300_link_hash_table
modifier|*
name|hash_table
decl_stmt|;
name|asection
modifier|*
name|section
init|=
name|sec
decl_stmt|;
comment|/* Assume nothing changes.  */
operator|*
name|again
operator|=
name|FALSE
expr_stmt|;
comment|/* We need a pointer to the mn10300 specific hash table.  */
name|hash_table
operator|=
name|elf32_mn10300_hash_table
argument_list|(
name|link_info
argument_list|)
expr_stmt|;
comment|/* Initialize fields in each hash table entry the first time through.  */
if|if
condition|(
operator|(
name|hash_table
operator|->
name|flags
operator|&
name|MN10300_HASH_ENTRIES_INITIALIZED
operator|)
operator|==
literal|0
condition|)
block|{
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
comment|/* Iterate over all the input bfds.  */
for|for
control|(
name|input_bfd
operator|=
name|link_info
operator|->
name|input_bfds
init|;
name|input_bfd
operator|!=
name|NULL
condition|;
name|input_bfd
operator|=
name|input_bfd
operator|->
name|link_next
control|)
block|{
comment|/* We're going to need all the symbols for each bfd.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Iterate over each section in this bfd.  */
for|for
control|(
name|section
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
name|struct
name|elf32_mn10300_link_hash_entry
modifier|*
name|hash
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sym_sec
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
name|char
modifier|*
name|new_name
decl_stmt|;
comment|/* If there's nothing to do in this section, skip it.  */
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|section
operator|->
name|reloc_count
operator|!=
literal|0
operator|)
operator|||
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
comment|/* Get cached copy of section contents if it exists.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
elseif|else
if|if
condition|(
name|section
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
comment|/* Go get them off disk.  */
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|input_bfd
argument_list|,
name|section
argument_list|,
operator|&
name|contents
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
else|else
name|contents
operator|=
name|NULL
expr_stmt|;
comment|/* If there aren't any relocs, then there's nothing to do.  */
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|section
operator|->
name|reloc_count
operator|!=
literal|0
condition|)
block|{
comment|/* Get a copy of the native relocations.  */
name|internal_relocs
operator|=
operator|(
name|_bfd_elf_link_read_relocs
argument_list|(
name|input_bfd
argument_list|,
name|section
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* Now examine each relocation.  */
name|irel
operator|=
name|internal_relocs
expr_stmt|;
name|irelend
operator|=
name|irel
operator|+
name|section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|long
name|r_type
decl_stmt|;
name|unsigned
name|long
name|r_index
decl_stmt|;
name|unsigned
name|char
name|code
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_index
operator|=
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|<
literal|0
operator|||
name|r_type
operator|>=
operator|(
name|int
operator|)
name|R_MN10300_MAX
condition|)
goto|goto
name|error_return
goto|;
comment|/* We need the name and hash table entry of the target 			 symbol!  */
name|hash
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sym_sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_index
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* A local symbol.  */
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|struct
name|elf_link_hash_table
modifier|*
name|elftab
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|isym
operator|=
name|isymbuf
operator|+
name|r_index
expr_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|sym_sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|sym_sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|sym_sec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
name|sym_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|input_bfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|sym_name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|symtab_hdr
operator|->
name|sh_link
operator|)
argument_list|,
name|isym
operator|->
name|st_name
argument_list|)
expr_stmt|;
comment|/* If it isn't a function, then we don't care 			     about it.  */
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_FUNC
condition|)
continue|continue;
comment|/* Tack on an ID so we can uniquely identify this 			     local symbol in the global hash table.  */
name|amt
operator|=
name|strlen
argument_list|(
name|sym_name
argument_list|)
operator|+
literal|10
expr_stmt|;
name|new_name
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_name
operator|==
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|sprintf
argument_list|(
name|new_name
argument_list|,
literal|"%s_%08x"
argument_list|,
name|sym_name
argument_list|,
name|sym_sec
operator|->
name|id
argument_list|)
expr_stmt|;
name|sym_name
operator|=
name|new_name
expr_stmt|;
name|elftab
operator|=
operator|&
name|hash_table
operator|->
name|static_hash_table
operator|->
name|root
expr_stmt|;
name|hash
operator|=
operator|(
operator|(
expr|struct
name|elf32_mn10300_link_hash_entry
operator|*
operator|)
name|elf_link_hash_lookup
argument_list|(
name|elftab
argument_list|,
name|sym_name
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
operator|)
expr_stmt|;
name|free
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r_index
operator|-=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|hash
operator|=
operator|(
expr|struct
name|elf32_mn10300_link_hash_entry
operator|*
operator|)
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|r_index
index|]
expr_stmt|;
block|}
comment|/* If this is not a "call" instruction, then we 			 should convert "call" instructions to "calls" 			 instructions.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0xdd
operator|&&
name|code
operator|!=
literal|0xcd
condition|)
name|hash
operator|->
name|flags
operator||=
name|MN10300_CONVERT_CALL_TO_CALLS
expr_stmt|;
comment|/* If this is a jump/call, then bump the 			 direct_calls counter.  Else force "call" to 			 "calls" conversions.  */
if|if
condition|(
name|r_type
operator|==
name|R_MN10300_PCREL32
operator|||
name|r_type
operator|==
name|R_MN10300_PLT32
operator|||
name|r_type
operator|==
name|R_MN10300_PLT16
operator|||
name|r_type
operator|==
name|R_MN10300_PCREL16
condition|)
name|hash
operator|->
name|direct_calls
operator|++
expr_stmt|;
else|else
name|hash
operator|->
name|flags
operator||=
name|MN10300_CONVERT_CALL_TO_CALLS
expr_stmt|;
block|}
block|}
comment|/* Now look at the actual contents to get the stack size, 		 and a list of what registers were saved in the prologue 		 (ie movm_args).  */
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|,
modifier|*
name|isymend
decl_stmt|;
name|unsigned
name|int
name|sec_shndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|end_hashes
decl_stmt|;
name|unsigned
name|int
name|symcount
decl_stmt|;
name|sec_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|input_bfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|symcount
operator|=
operator|(
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|end_hashes
operator|=
name|hashes
operator|+
name|symcount
expr_stmt|;
comment|/* Look at each function defined in this section and 		     update info for that function.  */
name|isymend
operator|=
name|isymbuf
operator|+
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
name|isym
operator|=
name|isymbuf
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
control|)
block|{
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|sec_shndx
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_FUNC
condition|)
block|{
name|struct
name|elf_link_hash_table
modifier|*
name|elftab
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|lhashes
init|=
name|hashes
decl_stmt|;
comment|/* Skip a local symbol if it aliases a 			     global one.  */
for|for
control|(
init|;
name|lhashes
operator|<
name|end_hashes
condition|;
name|lhashes
operator|++
control|)
block|{
name|hash
operator|=
operator|(
expr|struct
name|elf32_mn10300_link_hash_entry
operator|*
operator|)
operator|*
name|lhashes
expr_stmt|;
if|if
condition|(
operator|(
name|hash
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|hash
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|hash
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|section
operator|&&
name|hash
operator|->
name|root
operator|.
name|type
operator|==
name|STT_FUNC
operator|&&
name|hash
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|==
name|isym
operator|->
name|st_value
condition|)
break|break;
block|}
if|if
condition|(
name|lhashes
operator|!=
name|end_hashes
condition|)
continue|continue;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|sym_sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|sym_sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|sym_sec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
name|sym_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|input_bfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|sym_name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|isym
operator|->
name|st_name
argument_list|)
operator|)
expr_stmt|;
comment|/* Tack on an ID so we can uniquely identify this 			     local symbol in the global hash table.  */
name|amt
operator|=
name|strlen
argument_list|(
name|sym_name
argument_list|)
operator|+
literal|10
expr_stmt|;
name|new_name
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_name
operator|==
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|sprintf
argument_list|(
name|new_name
argument_list|,
literal|"%s_%08x"
argument_list|,
name|sym_name
argument_list|,
name|sym_sec
operator|->
name|id
argument_list|)
expr_stmt|;
name|sym_name
operator|=
name|new_name
expr_stmt|;
name|elftab
operator|=
operator|&
name|hash_table
operator|->
name|static_hash_table
operator|->
name|root
expr_stmt|;
name|hash
operator|=
operator|(
operator|(
expr|struct
name|elf32_mn10300_link_hash_entry
operator|*
operator|)
name|elf_link_hash_lookup
argument_list|(
name|elftab
argument_list|,
name|sym_name
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
operator|)
expr_stmt|;
name|free
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
name|compute_function_info
argument_list|(
name|input_bfd
argument_list|,
name|hash
argument_list|,
name|isym
operator|->
name|st_value
argument_list|,
name|contents
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|hashes
operator|<
name|end_hashes
condition|;
name|hashes
operator|++
control|)
block|{
name|hash
operator|=
operator|(
expr|struct
name|elf32_mn10300_link_hash_entry
operator|*
operator|)
operator|*
name|hashes
expr_stmt|;
if|if
condition|(
operator|(
name|hash
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|hash
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|hash
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|section
operator|&&
name|hash
operator|->
name|root
operator|.
name|type
operator|==
name|STT_FUNC
condition|)
name|compute_function_info
argument_list|(
name|input_bfd
argument_list|,
name|hash
argument_list|,
operator|(
name|hash
operator|)
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
argument_list|,
name|contents
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Cache or free any memory we allocated for the relocs.  */
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
name|internal_relocs
operator|=
name|NULL
expr_stmt|;
comment|/* Cache or free any memory we allocated for the contents.  */
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the section contents for elf_link_input_bfd.  */
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
block|}
block|}
name|contents
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Cache or free any memory we allocated for the symbols.  */
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the symbols for elf_link_input_bfd.  */
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
block|}
block|}
name|isymbuf
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now iterate on each symbol in the hash table and perform 	 the final initialization steps on each.  */
name|elf32_mn10300_link_hash_traverse
argument_list|(
name|hash_table
argument_list|,
name|elf32_mn10300_finish_hash_table_entry
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
name|elf32_mn10300_link_hash_traverse
argument_list|(
name|hash_table
operator|->
name|static_hash_table
argument_list|,
name|elf32_mn10300_finish_hash_table_entry
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
comment|/* All entries in the hash table are fully initialized.  */
name|hash_table
operator|->
name|flags
operator||=
name|MN10300_HASH_ENTRIES_INITIALIZED
expr_stmt|;
comment|/* Now that everything has been initialized, go through each 	 code section and delete any prologue insns which will be 	 redundant because their operations will be performed by 	 a "call" instruction.  */
for|for
control|(
name|input_bfd
operator|=
name|link_info
operator|->
name|input_bfds
init|;
name|input_bfd
operator|!=
name|NULL
condition|;
name|input_bfd
operator|=
name|input_bfd
operator|->
name|link_next
control|)
block|{
comment|/* We're going to need all the local symbols for each bfd.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Walk over each section in this bfd.  */
for|for
control|(
name|section
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
name|unsigned
name|int
name|sec_shndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|,
modifier|*
name|isymend
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|end_hashes
decl_stmt|;
name|unsigned
name|int
name|symcount
decl_stmt|;
comment|/* Skip non-code sections and empty sections.  */
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
operator|||
name|section
operator|->
name|size
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|section
operator|->
name|reloc_count
operator|!=
literal|0
condition|)
block|{
comment|/* Get a copy of the native relocations.  */
name|internal_relocs
operator|=
operator|(
name|_bfd_elf_link_read_relocs
argument_list|(
name|input_bfd
argument_list|,
name|section
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Get cached copy of section contents if it exists.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
comment|/* Go get them off disk.  */
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|input_bfd
argument_list|,
name|section
argument_list|,
operator|&
name|contents
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
name|sec_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|input_bfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
comment|/* Now look for any function in this section which needs 		 insns deleted from its prologue.  */
name|isymend
operator|=
name|isymbuf
operator|+
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
name|isym
operator|=
name|isymbuf
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
control|)
block|{
name|struct
name|elf32_mn10300_link_hash_entry
modifier|*
name|sym_hash
decl_stmt|;
name|asection
modifier|*
name|sym_sec
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
name|char
modifier|*
name|new_name
decl_stmt|;
name|struct
name|elf_link_hash_table
modifier|*
name|elftab
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|!=
name|sec_shndx
condition|)
continue|continue;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|sym_sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|sym_sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|sym_sec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
name|sym_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|input_bfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|sym_name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|isym
operator|->
name|st_name
argument_list|)
expr_stmt|;
comment|/* Tack on an ID so we can uniquely identify this 		     local symbol in the global hash table.  */
name|amt
operator|=
name|strlen
argument_list|(
name|sym_name
argument_list|)
operator|+
literal|10
expr_stmt|;
name|new_name
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_name
operator|==
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|sprintf
argument_list|(
name|new_name
argument_list|,
literal|"%s_%08x"
argument_list|,
name|sym_name
argument_list|,
name|sym_sec
operator|->
name|id
argument_list|)
expr_stmt|;
name|sym_name
operator|=
name|new_name
expr_stmt|;
name|elftab
operator|=
operator|&
name|hash_table
operator|->
name|static_hash_table
operator|->
name|root
expr_stmt|;
name|sym_hash
operator|=
operator|(
operator|(
expr|struct
name|elf32_mn10300_link_hash_entry
operator|*
operator|)
name|elf_link_hash_lookup
argument_list|(
name|elftab
argument_list|,
name|sym_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
operator|)
expr_stmt|;
name|free
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_hash
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|sym_hash
operator|->
name|flags
operator|&
name|MN10300_CONVERT_CALL_TO_CALLS
operator|)
operator|&&
operator|!
operator|(
name|sym_hash
operator|->
name|flags
operator|&
name|MN10300_DELETED_PROLOGUE_BYTES
operator|)
condition|)
block|{
name|int
name|bytes
init|=
literal|0
decl_stmt|;
comment|/* Note that we've changed things.  */
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Count how many bytes we're going to delete.  */
if|if
condition|(
name|sym_hash
operator|->
name|movm_args
condition|)
name|bytes
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|sym_hash
operator|->
name|stack_size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sym_hash
operator|->
name|stack_size
operator|<=
literal|128
condition|)
name|bytes
operator|+=
literal|3
expr_stmt|;
else|else
name|bytes
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* Note that we've deleted prologue bytes for this 			 function.  */
name|sym_hash
operator|->
name|flags
operator||=
name|MN10300_DELETED_PROLOGUE_BYTES
expr_stmt|;
comment|/* Actually delete the bytes.  */
if|if
condition|(
operator|!
name|mn10300_elf_relax_delete_bytes
argument_list|(
name|input_bfd
argument_list|,
name|section
argument_list|,
name|isym
operator|->
name|st_value
argument_list|,
name|bytes
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Something changed.  Not strictly necessary, but 			 may lead to more relaxing opportunities.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Look for any global functions in this section which 		 need insns deleted from their prologues.  */
name|symcount
operator|=
operator|(
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|end_hashes
operator|=
name|hashes
operator|+
name|symcount
expr_stmt|;
for|for
control|(
init|;
name|hashes
operator|<
name|end_hashes
condition|;
name|hashes
operator|++
control|)
block|{
name|struct
name|elf32_mn10300_link_hash_entry
modifier|*
name|sym_hash
decl_stmt|;
name|sym_hash
operator|=
operator|(
expr|struct
name|elf32_mn10300_link_hash_entry
operator|*
operator|)
operator|*
name|hashes
expr_stmt|;
if|if
condition|(
operator|(
name|sym_hash
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|sym_hash
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|section
operator|&&
operator|!
operator|(
name|sym_hash
operator|->
name|flags
operator|&
name|MN10300_CONVERT_CALL_TO_CALLS
operator|)
operator|&&
operator|!
operator|(
name|sym_hash
operator|->
name|flags
operator|&
name|MN10300_DELETED_PROLOGUE_BYTES
operator|)
condition|)
block|{
name|int
name|bytes
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|symval
decl_stmt|;
comment|/* Note that we've changed things.  */
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Count how many bytes we're going to delete.  */
if|if
condition|(
name|sym_hash
operator|->
name|movm_args
condition|)
name|bytes
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|sym_hash
operator|->
name|stack_size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sym_hash
operator|->
name|stack_size
operator|<=
literal|128
condition|)
name|bytes
operator|+=
literal|3
expr_stmt|;
else|else
name|bytes
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* Note that we've deleted prologue bytes for this 			 function.  */
name|sym_hash
operator|->
name|flags
operator||=
name|MN10300_DELETED_PROLOGUE_BYTES
expr_stmt|;
comment|/* Actually delete the bytes.  */
name|symval
operator|=
name|sym_hash
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|mn10300_elf_relax_delete_bytes
argument_list|(
name|input_bfd
argument_list|,
name|section
argument_list|,
name|symval
argument_list|,
name|bytes
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Something changed.  Not strictly necessary, but 			 may lead to more relaxing opportunities.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Cache or free any memory we allocated for the relocs.  */
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
name|internal_relocs
operator|=
name|NULL
expr_stmt|;
comment|/* Cache or free any memory we allocated for the contents.  */
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the section contents for elf_link_input_bfd.  */
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
block|}
block|}
name|contents
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Cache or free any memory we allocated for the symbols.  */
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the symbols for elf_link_input_bfd.  */
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
block|}
block|}
name|isymbuf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* (Re)initialize for the basic instruction shortening/relaxing pass.  */
name|contents
operator|=
name|NULL
expr_stmt|;
name|internal_relocs
operator|=
name|NULL
expr_stmt|;
name|isymbuf
operator|=
name|NULL
expr_stmt|;
comment|/* For error_return.  */
name|section
operator|=
name|sec
expr_stmt|;
comment|/* We don't have to do anything for a relocatable link, if      this section does not have relocs, or if this is not a      code section.  */
if|if
condition|(
name|link_info
operator|->
name|relocatable
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|sec
operator|->
name|reloc_count
operator|==
literal|0
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
comment|/* Get a copy of the native relocations.  */
name|internal_relocs
operator|=
operator|(
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* Walk through them looking for relaxing opportunities.  */
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|symval
decl_stmt|;
name|struct
name|elf32_mn10300_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
comment|/* If this isn't something that can be relaxed, then ignore 	 this reloc.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_NONE
operator|||
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_8
operator|||
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_MAX
condition|)
continue|continue;
comment|/* Get the section contents if we haven't done so already.  */
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
block|{
comment|/* Get cached copy if it exists.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
comment|/* Go get them off disk.  */
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|&
name|contents
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* Read this BFD's symbols if we haven't done so already.  */
if|if
condition|(
name|isymbuf
operator|==
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Get the value of the symbol referred to by the reloc.  */
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|asection
modifier|*
name|sym_sec
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
name|char
modifier|*
name|new_name
decl_stmt|;
name|bfd_vma
name|saved_addend
decl_stmt|;
comment|/* A local symbol.  */
name|isym
operator|=
name|isymbuf
operator|+
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|sym_sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|sym_sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|sym_sec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
name|sym_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|sym_name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|isym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sym_sec
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
operator|&&
name|sym_sec
operator|->
name|sec_info_type
operator|==
name|ELF_INFO_TYPE_MERGE
condition|)
block|{
name|saved_addend
operator|=
name|irel
operator|->
name|r_addend
expr_stmt|;
name|symval
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|abfd
argument_list|,
name|isym
argument_list|,
operator|&
name|sym_sec
argument_list|,
name|irel
argument_list|)
expr_stmt|;
name|symval
operator|+=
name|irel
operator|->
name|r_addend
expr_stmt|;
name|irel
operator|->
name|r_addend
operator|=
name|saved_addend
expr_stmt|;
block|}
else|else
block|{
name|symval
operator|=
operator|(
name|isym
operator|->
name|st_value
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sym_sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
comment|/* Tack on an ID so we can uniquely identify this 	     local symbol in the global hash table.  */
name|new_name
operator|=
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|strlen
argument_list|(
name|sym_name
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_name
operator|==
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|sprintf
argument_list|(
name|new_name
argument_list|,
literal|"%s_%08x"
argument_list|,
name|sym_name
argument_list|,
name|sym_sec
operator|->
name|id
argument_list|)
expr_stmt|;
name|sym_name
operator|=
name|new_name
expr_stmt|;
name|h
operator|=
operator|(
expr|struct
name|elf32_mn10300_link_hash_entry
operator|*
operator|)
name|elf_link_hash_lookup
argument_list|(
operator|&
name|hash_table
operator|->
name|static_hash_table
operator|->
name|root
argument_list|,
name|sym_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|indx
decl_stmt|;
comment|/* An external symbol.  */
name|indx
operator|=
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
operator|(
expr|struct
name|elf32_mn10300_link_hash_entry
operator|*
operator|)
operator|(
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
operator|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
block|{
comment|/* This appears to be a reference to an undefined  		symbol.  Just ignore it--it will be caught by the  		regular reloc processing.  */
continue|continue;
block|}
name|symval
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
comment|/* For simplicity of coding, we are going to modify the section 	 contents, the section relocs, and the BFD symbol table.  We 	 must tell the rest of the code not to free up this 	 information.  It would be possible to instead create a table 	 of changes which have to be made, as is done in coff-mips.c; 	 that would be more work, but would require less memory when 	 the linker is run.  */
comment|/* Try to turn a 32bit pc-relative branch/call into a 16bit pc-relative 	 branch/call, also deal with "call" -> "calls" conversions and 	 insertion of prologue data into "call" instructions.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_PCREL32
operator|||
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_PLT32
condition|)
block|{
name|bfd_vma
name|value
init|=
name|symval
decl_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_PLT32
operator|&&
name|h
operator|!=
name|NULL
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|root
operator|.
name|other
argument_list|)
operator|!=
name|STV_INTERNAL
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|root
operator|.
name|other
argument_list|)
operator|!=
name|STV_HIDDEN
operator|&&
name|h
operator|->
name|root
operator|.
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|elf_hash_table
argument_list|(
name|link_info
argument_list|)
operator|->
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|root
operator|.
name|plt
operator|.
name|offset
operator|)
operator|-
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|irel
operator|->
name|r_offset
operator|)
operator|)
expr_stmt|;
block|}
comment|/* If we've got a "call" instruction that needs to be turned 	     into a "calls" instruction, do so now.  It saves a byte.  */
if|if
condition|(
name|h
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|MN10300_CONVERT_CALL_TO_CALLS
operator|)
condition|)
block|{
name|unsigned
name|char
name|code
decl_stmt|;
comment|/* Get the opcode.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Make sure we're working with a "call" instruction!  */
if|if
condition|(
name|code
operator|==
literal|0xdd
condition|)
block|{
comment|/* Note that we've changed the relocs, section contents, 		     etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Fix the opcode.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xfc
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xff
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Fix irel->r_offset and irel->r_addend.  */
name|irel
operator|->
name|r_offset
operator|+=
literal|1
expr_stmt|;
name|irel
operator|->
name|r_addend
operator|+=
literal|1
expr_stmt|;
comment|/* Delete one byte of data.  */
if|if
condition|(
operator|!
name|mn10300_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|3
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 		     Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|h
condition|)
block|{
comment|/* We've got a "call" instruction which needs some data 		 from target function filled in.  */
name|unsigned
name|char
name|code
decl_stmt|;
comment|/* Get the opcode.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Insert data from the target function into the "call" 		 instruction if needed.  */
if|if
condition|(
name|code
operator|==
literal|0xdd
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|h
operator|->
name|movm_args
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|h
operator|->
name|stack_size
operator|+
name|h
operator|->
name|movm_stack_size
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|5
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Deal with pc-relative gunk.  */
name|value
operator|-=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|irel
operator|->
name|r_offset
expr_stmt|;
name|value
operator|+=
name|irel
operator|->
name|r_addend
expr_stmt|;
comment|/* See if the value will fit in 16 bits, note the high value is 	     0x7fff + 2 as the target will be two bytes closer if we are 	     able to relax.  */
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|<
literal|0x8001
operator|&&
operator|(
name|long
operator|)
name|value
operator|>
operator|-
literal|0x8000
condition|)
block|{
name|unsigned
name|char
name|code
decl_stmt|;
comment|/* Get the opcode.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0xdc
operator|&&
name|code
operator|!=
literal|0xdd
operator|&&
name|code
operator|!=
literal|0xff
condition|)
continue|continue;
comment|/* Note that we've changed the relocs, section contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Fix the opcode.  */
if|if
condition|(
name|code
operator|==
literal|0xdc
condition|)
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xcc
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|0xdd
condition|)
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xcd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|0xff
condition|)
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xfa
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_PLT32
operator|)
condition|?
name|R_MN10300_PLT16
else|:
name|R_MN10300_PCREL16
argument_list|)
expr_stmt|;
comment|/* Delete two bytes of data.  */
if|if
condition|(
operator|!
name|mn10300_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 		 Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Try to turn a 16bit pc-relative branch into a 8bit pc-relative 	 branch.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_PCREL16
condition|)
block|{
name|bfd_vma
name|value
init|=
name|symval
decl_stmt|;
comment|/* If we've got a "call" instruction that needs to be turned 	     into a "calls" instruction, do so now.  It saves a byte.  */
if|if
condition|(
name|h
operator|&&
operator|(
name|h
operator|->
name|flags
operator|&
name|MN10300_CONVERT_CALL_TO_CALLS
operator|)
condition|)
block|{
name|unsigned
name|char
name|code
decl_stmt|;
comment|/* Get the opcode.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Make sure we're working with a "call" instruction!  */
if|if
condition|(
name|code
operator|==
literal|0xcd
condition|)
block|{
comment|/* Note that we've changed the relocs, section contents, 		     etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Fix the opcode.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xfa
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xff
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Fix irel->r_offset and irel->r_addend.  */
name|irel
operator|->
name|r_offset
operator|+=
literal|1
expr_stmt|;
name|irel
operator|->
name|r_addend
operator|+=
literal|1
expr_stmt|;
comment|/* Delete one byte of data.  */
if|if
condition|(
operator|!
name|mn10300_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 		     Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|h
condition|)
block|{
name|unsigned
name|char
name|code
decl_stmt|;
comment|/* Get the opcode.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Insert data from the target function into the "call" 		 instruction if needed.  */
if|if
condition|(
name|code
operator|==
literal|0xcd
condition|)
block|{
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|h
operator|->
name|movm_args
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|h
operator|->
name|stack_size
operator|+
name|h
operator|->
name|movm_stack_size
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Deal with pc-relative gunk.  */
name|value
operator|-=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|irel
operator|->
name|r_offset
expr_stmt|;
name|value
operator|+=
name|irel
operator|->
name|r_addend
expr_stmt|;
comment|/* See if the value will fit in 8 bits, note the high value is 	     0x7f + 1 as the target will be one bytes closer if we are 	     able to relax.  */
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|<
literal|0x80
operator|&&
operator|(
name|long
operator|)
name|value
operator|>
operator|-
literal|0x80
condition|)
block|{
name|unsigned
name|char
name|code
decl_stmt|;
comment|/* Get the opcode.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0xcc
condition|)
continue|continue;
comment|/* Note that we've changed the relocs, section contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Fix the opcode.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xca
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_MN10300_PCREL8
argument_list|)
expr_stmt|;
comment|/* Delete one byte of data.  */
if|if
condition|(
operator|!
name|mn10300_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 		 Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Try to eliminate an unconditional 8 bit pc-relative branch 	 which immediately follows a conditional 8 bit pc-relative 	 branch around the unconditional branch.  	    original:		new: 	    bCC lab1		bCC' lab2 	    bra lab2 	   lab1:	       lab1:  	 This happens when the bCC can't reach lab2 at assembly time, 	 but due to other relaxations it can reach at link time.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_PCREL8
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|nrel
decl_stmt|;
name|bfd_vma
name|value
init|=
name|symval
decl_stmt|;
name|unsigned
name|char
name|code
decl_stmt|;
comment|/* Deal with pc-relative gunk.  */
name|value
operator|-=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|irel
operator|->
name|r_offset
expr_stmt|;
name|value
operator|+=
name|irel
operator|->
name|r_addend
expr_stmt|;
comment|/* Do nothing if this reloc is the last byte in the section.  */
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|==
name|sec
operator|->
name|size
condition|)
continue|continue;
comment|/* See if the next instruction is an unconditional pc-relative 	     branch, more often than not this test will fail, so we 	     test it first to speed things up.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0xca
condition|)
continue|continue;
comment|/* Also make sure the next relocation applies to the next 	     instruction and that it's a pc-relative 8 bit branch.  */
name|nrel
operator|=
name|irel
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nrel
operator|==
name|irelend
operator|||
name|irel
operator|->
name|r_offset
operator|+
literal|2
operator|!=
name|nrel
operator|->
name|r_offset
operator|||
name|ELF32_R_TYPE
argument_list|(
name|nrel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_MN10300_PCREL8
condition|)
continue|continue;
comment|/* Make sure our destination immediately follows the 	     unconditional branch.  */
if|if
condition|(
name|symval
operator|!=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|3
operator|)
condition|)
continue|continue;
comment|/* Now make sure we are a conditional branch.  This may not 	     be necessary, but why take the chance.  	     Note these checks assume that R_MN10300_PCREL8 relocs 	     only occur on bCC and bCCx insns.  If they occured 	     elsewhere, we'd need to know the start of this insn 	     for this check to be accurate.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0xc0
operator|&&
name|code
operator|!=
literal|0xc1
operator|&&
name|code
operator|!=
literal|0xc2
operator|&&
name|code
operator|!=
literal|0xc3
operator|&&
name|code
operator|!=
literal|0xc4
operator|&&
name|code
operator|!=
literal|0xc5
operator|&&
name|code
operator|!=
literal|0xc6
operator|&&
name|code
operator|!=
literal|0xc7
operator|&&
name|code
operator|!=
literal|0xc8
operator|&&
name|code
operator|!=
literal|0xc9
operator|&&
name|code
operator|!=
literal|0xe8
operator|&&
name|code
operator|!=
literal|0xe9
operator|&&
name|code
operator|!=
literal|0xea
operator|&&
name|code
operator|!=
literal|0xeb
condition|)
continue|continue;
comment|/* We also have to be sure there is no symbol/label 	     at the unconditional branch.  */
if|if
condition|(
name|mn10300_elf_symbol_address_p
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|isymbuf
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|)
condition|)
continue|continue;
comment|/* Note that we've changed the relocs, section contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Reverse the condition of the first branch.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|0xc8
case|:
name|code
operator|=
literal|0xc9
expr_stmt|;
break|break;
case|case
literal|0xc9
case|:
name|code
operator|=
literal|0xc8
expr_stmt|;
break|break;
case|case
literal|0xc0
case|:
name|code
operator|=
literal|0xc2
expr_stmt|;
break|break;
case|case
literal|0xc2
case|:
name|code
operator|=
literal|0xc0
expr_stmt|;
break|break;
case|case
literal|0xc3
case|:
name|code
operator|=
literal|0xc1
expr_stmt|;
break|break;
case|case
literal|0xc1
case|:
name|code
operator|=
literal|0xc3
expr_stmt|;
break|break;
case|case
literal|0xc4
case|:
name|code
operator|=
literal|0xc6
expr_stmt|;
break|break;
case|case
literal|0xc6
case|:
name|code
operator|=
literal|0xc4
expr_stmt|;
break|break;
case|case
literal|0xc7
case|:
name|code
operator|=
literal|0xc5
expr_stmt|;
break|break;
case|case
literal|0xc5
case|:
name|code
operator|=
literal|0xc7
expr_stmt|;
break|break;
case|case
literal|0xe8
case|:
name|code
operator|=
literal|0xe9
expr_stmt|;
break|break;
case|case
literal|0x9d
case|:
name|code
operator|=
literal|0xe8
expr_stmt|;
break|break;
case|case
literal|0xea
case|:
name|code
operator|=
literal|0xeb
expr_stmt|;
break|break;
case|case
literal|0xeb
case|:
name|code
operator|=
literal|0xea
expr_stmt|;
break|break;
block|}
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Set the reloc type and symbol for the first branch 	     from the second branch.  */
name|irel
operator|->
name|r_info
operator|=
name|nrel
operator|->
name|r_info
expr_stmt|;
comment|/* Make the reloc for the second branch a null reloc.  */
name|nrel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|nrel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_MN10300_NONE
argument_list|)
expr_stmt|;
comment|/* Delete two bytes of data.  */
if|if
condition|(
operator|!
name|mn10300_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 	     Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Try to turn a 24 immediate, displacement or absolute address 	 into a 8 immediate, displacement or absolute address.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_24
condition|)
block|{
name|bfd_vma
name|value
init|=
name|symval
decl_stmt|;
name|value
operator|+=
name|irel
operator|->
name|r_addend
expr_stmt|;
comment|/* See if the value will fit in 8 bits.  */
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|<
literal|0x7f
operator|&&
operator|(
name|long
operator|)
name|value
operator|>
operator|-
literal|0x80
condition|)
block|{
name|unsigned
name|char
name|code
decl_stmt|;
comment|/* AM33 insns which have 24 operands are 6 bytes long and 		 will have 0xfd as the first byte.  */
comment|/* Get the first opcode.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|0xfd
condition|)
block|{
comment|/* Get the second opcode.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* We can not relax 0x6b, 0x7b, 0x8b, 0x9b as no 24bit 		     equivalent instructions exists.  */
if|if
condition|(
name|code
operator|!=
literal|0x6b
operator|&&
name|code
operator|!=
literal|0x7b
operator|&&
name|code
operator|!=
literal|0x8b
operator|&&
name|code
operator|!=
literal|0x9b
operator|&&
operator|(
operator|(
name|code
operator|&
literal|0x0f
operator|)
operator|==
literal|0x09
operator|||
operator|(
name|code
operator|&
literal|0x0f
operator|)
operator|==
literal|0x08
operator|||
operator|(
name|code
operator|&
literal|0x0f
operator|)
operator|==
literal|0x0a
operator|||
operator|(
name|code
operator|&
literal|0x0f
operator|)
operator|==
literal|0x0b
operator|||
operator|(
name|code
operator|&
literal|0x0f
operator|)
operator|==
literal|0x0e
operator|)
condition|)
block|{
comment|/* Not safe if the high bit is on as relaxing may 			 move the value out of high mem and thus not fit 			 in a signed 8bit value.  This is currently over 			 conservative.  */
if|if
condition|(
operator|(
name|value
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Note that we've changed the relocation contents, 			     etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Fix the opcode.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xfb
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|3
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_MN10300_8
argument_list|)
expr_stmt|;
comment|/* Delete two bytes of data.  */
if|if
condition|(
operator|!
name|mn10300_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax 			     again.  Note that this is not required, and it 			     may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
comment|/* Try to turn a 32bit immediate, displacement or absolute address 	 into a 16bit immediate, displacement or absolute address.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_32
operator|||
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_GOT32
operator|||
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_GOTOFF32
operator|||
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_GOTPC32
condition|)
block|{
name|bfd_vma
name|value
init|=
name|symval
decl_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_MN10300_32
condition|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|elf_hash_table
argument_list|(
name|link_info
argument_list|)
operator|->
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_GOT32
condition|)
block|{
name|value
operator|=
name|sgot
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|h
condition|)
name|value
operator|+=
name|h
operator|->
name|root
operator|.
name|got
operator|.
name|offset
expr_stmt|;
else|else
name|value
operator|+=
operator|(
name|elf_local_got_offsets
argument_list|(
name|abfd
argument_list|)
index|[
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
index|]
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_GOTOFF32
condition|)
name|value
operator|-=
name|sgot
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
elseif|else
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_GOTPC32
condition|)
name|value
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|-
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|irel
operator|->
name|r_offset
operator|)
operator|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
name|value
operator|+=
name|irel
operator|->
name|r_addend
expr_stmt|;
comment|/* See if the value will fit in 24 bits. 	     We allow any 16bit match here.  We prune those we can't 	     handle below.  */
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|<
literal|0x7fffff
operator|&&
operator|(
name|long
operator|)
name|value
operator|>
operator|-
literal|0x800000
condition|)
block|{
name|unsigned
name|char
name|code
decl_stmt|;
comment|/* AM33 insns which have 32bit operands are 7 bytes long and 		 will have 0xfe as the first byte.  */
comment|/* Get the first opcode.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|0xfe
condition|)
block|{
comment|/* Get the second opcode.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* All the am33 32 -> 24 relaxing possibilities.  */
comment|/* We can not relax 0x6b, 0x7b, 0x8b, 0x9b as no 24bit 		     equivalent instructions exists.  */
if|if
condition|(
name|code
operator|!=
literal|0x6b
operator|&&
name|code
operator|!=
literal|0x7b
operator|&&
name|code
operator|!=
literal|0x8b
operator|&&
name|code
operator|!=
literal|0x9b
operator|&&
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_MN10300_GOTPC32
operator|)
operator|&&
operator|(
operator|(
name|code
operator|&
literal|0x0f
operator|)
operator|==
literal|0x09
operator|||
operator|(
name|code
operator|&
literal|0x0f
operator|)
operator|==
literal|0x08
operator|||
operator|(
name|code
operator|&
literal|0x0f
operator|)
operator|==
literal|0x0a
operator|||
operator|(
name|code
operator|&
literal|0x0f
operator|)
operator|==
literal|0x0b
operator|||
operator|(
name|code
operator|&
literal|0x0f
operator|)
operator|==
literal|0x0e
operator|)
condition|)
block|{
comment|/* Not safe if the high bit is on as relaxing may 			 move the value out of high mem and thus not fit 			 in a signed 16bit value.  This is currently over 			 conservative.  */
if|if
condition|(
operator|(
name|value
operator|&
literal|0x8000
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Note that we've changed the relocation contents, 			     etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Fix the opcode.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|3
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_GOTOFF32
operator|)
condition|?
name|R_MN10300_GOTOFF24
else|:
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_GOT32
operator|)
condition|?
name|R_MN10300_GOT24
else|:
name|R_MN10300_24
argument_list|)
expr_stmt|;
comment|/* Delete one byte of data.  */
if|if
condition|(
operator|!
name|mn10300_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|3
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax 			     again.  Note that this is not required, and it 			     may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* See if the value will fit in 16 bits. 	     We allow any 16bit match here.  We prune those we can't 	     handle below.  */
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|<
literal|0x7fff
operator|&&
operator|(
name|long
operator|)
name|value
operator|>
operator|-
literal|0x8000
condition|)
block|{
name|unsigned
name|char
name|code
decl_stmt|;
comment|/* Most insns which have 32bit operands are 6 bytes long; 		 exceptions are pcrel insns and bit insns.  		 We handle pcrel insns above.  We don't bother trying 		 to handle the bit insns here.  		 The first byte of the remaining insns will be 0xfc.  */
comment|/* Get the first opcode.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0xfc
condition|)
continue|continue;
comment|/* Get the second opcode.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|0xf0
operator|)
operator|<
literal|0x80
condition|)
switch|switch
condition|(
name|code
operator|&
literal|0xf0
condition|)
block|{
comment|/* mov (d32,am),dn   -> mov (d32,am),dn 		     mov dm,(d32,am)   -> mov dn,(d32,am) 		     mov (d32,am),an   -> mov (d32,am),an 		     mov dm,(d32,am)   -> mov dn,(d32,am) 		     movbu (d32,am),dn -> movbu (d32,am),dn 		     movbu dm,(d32,am) -> movbu dn,(d32,am) 		     movhu (d32,am),dn -> movhu (d32,am),dn 		     movhu dm,(d32,am) -> movhu dn,(d32,am) */
case|case
literal|0x00
case|:
case|case
literal|0x10
case|:
case|case
literal|0x20
case|:
case|case
literal|0x30
case|:
case|case
literal|0x40
case|:
case|case
literal|0x50
case|:
case|case
literal|0x60
case|:
case|case
literal|0x70
case|:
comment|/* Not safe if the high bit is on as relaxing may 		       move the value out of high mem and thus not fit 		       in a signed 16bit value.  */
if|if
condition|(
name|code
operator|==
literal|0xcc
operator|&&
operator|(
name|value
operator|&
literal|0x8000
operator|)
condition|)
continue|continue;
comment|/* Note that we've changed the relocation contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Fix the opcode.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xfa
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_GOTOFF32
operator|)
condition|?
name|R_MN10300_GOTOFF16
else|:
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_GOT32
operator|)
condition|?
name|R_MN10300_GOT16
else|:
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_GOTPC32
operator|)
condition|?
name|R_MN10300_GOTPC16
else|:
name|R_MN10300_16
argument_list|)
expr_stmt|;
comment|/* Delete two bytes of data.  */
if|if
condition|(
operator|!
name|mn10300_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 		       Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xf0
operator|)
operator|==
literal|0x80
operator|||
operator|(
name|code
operator|&
literal|0xf0
operator|)
operator|==
literal|0x90
condition|)
switch|switch
condition|(
name|code
operator|&
literal|0xf3
condition|)
block|{
comment|/* mov dn,(abs32)   -> mov dn,(abs16) 		     movbu dn,(abs32) -> movbu dn,(abs16) 		     movhu dn,(abs32) -> movhu dn,(abs16)  */
case|case
literal|0x81
case|:
case|case
literal|0x82
case|:
case|case
literal|0x83
case|:
comment|/* Note that we've changed the relocation contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|0xf3
operator|)
operator|==
literal|0x81
condition|)
name|code
operator|=
literal|0x01
operator|+
operator|(
name|code
operator|&
literal|0x0c
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xf3
operator|)
operator|==
literal|0x82
condition|)
name|code
operator|=
literal|0x02
operator|+
operator|(
name|code
operator|&
literal|0x0c
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xf3
operator|)
operator|==
literal|0x83
condition|)
name|code
operator|=
literal|0x03
operator|+
operator|(
name|code
operator|&
literal|0x0c
operator|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Fix the opcode.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_GOTOFF32
operator|)
condition|?
name|R_MN10300_GOTOFF16
else|:
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_GOT32
operator|)
condition|?
name|R_MN10300_GOT16
else|:
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_GOTPC32
operator|)
condition|?
name|R_MN10300_GOTPC16
else|:
name|R_MN10300_16
argument_list|)
expr_stmt|;
comment|/* The opcode got shorter too, so we have to fix the 		       addend and offset too!  */
name|irel
operator|->
name|r_offset
operator|-=
literal|1
expr_stmt|;
comment|/* Delete three bytes of data.  */
if|if
condition|(
operator|!
name|mn10300_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|,
literal|3
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 		       Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
break|break;
comment|/* mov am,(abs32)    -> mov am,(abs16) 		     mov am,(d32,sp)   -> mov am,(d16,sp) 		     mov dm,(d32,sp)   -> mov dm,(d32,sp) 		     movbu dm,(d32,sp) -> movbu dm,(d32,sp) 		     movhu dm,(d32,sp) -> movhu dm,(d32,sp) */
case|case
literal|0x80
case|:
case|case
literal|0x90
case|:
case|case
literal|0x91
case|:
case|case
literal|0x92
case|:
case|case
literal|0x93
case|:
comment|/* sp-based offsets are zero-extended.  */
if|if
condition|(
name|code
operator|>=
literal|0x90
operator|&&
name|code
operator|<=
literal|0x93
operator|&&
operator|(
name|long
operator|)
name|value
operator|<
literal|0
condition|)
continue|continue;
comment|/* Note that we've changed the relocation contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Fix the opcode.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xfa
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_GOTOFF32
operator|)
condition|?
name|R_MN10300_GOTOFF16
else|:
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_GOT32
operator|)
condition|?
name|R_MN10300_GOT16
else|:
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_GOTPC32
operator|)
condition|?
name|R_MN10300_GOTPC16
else|:
name|R_MN10300_16
argument_list|)
expr_stmt|;
comment|/* Delete two bytes of data.  */
if|if
condition|(
operator|!
name|mn10300_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 		       Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xf0
operator|)
operator|<
literal|0xf0
condition|)
switch|switch
condition|(
name|code
operator|&
literal|0xfc
condition|)
block|{
comment|/* mov imm32,dn     -> mov imm16,dn 		     mov imm32,an     -> mov imm16,an 		     mov (abs32),dn   -> mov (abs16),dn 		     movbu (abs32),dn -> movbu (abs16),dn 		     movhu (abs32),dn -> movhu (abs16),dn  */
case|case
literal|0xcc
case|:
case|case
literal|0xdc
case|:
case|case
literal|0xa4
case|:
case|case
literal|0xa8
case|:
case|case
literal|0xac
case|:
comment|/* Not safe if the high bit is on as relaxing may 		       move the value out of high mem and thus not fit 		       in a signed 16bit value.  */
if|if
condition|(
name|code
operator|==
literal|0xcc
operator|&&
operator|(
name|value
operator|&
literal|0x8000
operator|)
condition|)
continue|continue;
comment|/* mov imm16, an zero-extends the immediate.  */
if|if
condition|(
name|code
operator|==
literal|0xdc
operator|&&
operator|(
name|long
operator|)
name|value
operator|<
literal|0
condition|)
continue|continue;
comment|/* Note that we've changed the relocation contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0xcc
condition|)
name|code
operator|=
literal|0x2c
operator|+
operator|(
name|code
operator|&
literal|0x03
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0xdc
condition|)
name|code
operator|=
literal|0x24
operator|+
operator|(
name|code
operator|&
literal|0x03
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0xa4
condition|)
name|code
operator|=
literal|0x30
operator|+
operator|(
name|code
operator|&
literal|0x03
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0xa8
condition|)
name|code
operator|=
literal|0x34
operator|+
operator|(
name|code
operator|&
literal|0x03
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfc
operator|)
operator|==
literal|0xac
condition|)
name|code
operator|=
literal|0x38
operator|+
operator|(
name|code
operator|&
literal|0x03
operator|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Fix the opcode.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_GOTOFF32
operator|)
condition|?
name|R_MN10300_GOTOFF16
else|:
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_GOT32
operator|)
condition|?
name|R_MN10300_GOT16
else|:
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_GOTPC32
operator|)
condition|?
name|R_MN10300_GOTPC16
else|:
name|R_MN10300_16
argument_list|)
expr_stmt|;
comment|/* The opcode got shorter too, so we have to fix the 		       addend and offset too!  */
name|irel
operator|->
name|r_offset
operator|-=
literal|1
expr_stmt|;
comment|/* Delete three bytes of data.  */
if|if
condition|(
operator|!
name|mn10300_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|,
literal|3
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 		       Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
break|break;
comment|/* mov (abs32),an    -> mov (abs16),an 		     mov (d32,sp),an   -> mov (d16,sp),an 		     mov (d32,sp),dn   -> mov (d16,sp),dn 		     movbu (d32,sp),dn -> movbu (d16,sp),dn 		     movhu (d32,sp),dn -> movhu (d16,sp),dn 		     add imm32,dn      -> add imm16,dn 		     cmp imm32,dn      -> cmp imm16,dn 		     add imm32,an      -> add imm16,an 		     cmp imm32,an      -> cmp imm16,an 		     and imm32,dn      -> and imm16,dn 		     or imm32,dn       -> or imm16,dn 		     xor imm32,dn      -> xor imm16,dn 		     btst imm32,dn     -> btst imm16,dn */
case|case
literal|0xa0
case|:
case|case
literal|0xb0
case|:
case|case
literal|0xb1
case|:
case|case
literal|0xb2
case|:
case|case
literal|0xb3
case|:
case|case
literal|0xc0
case|:
case|case
literal|0xc8
case|:
case|case
literal|0xd0
case|:
case|case
literal|0xd8
case|:
case|case
literal|0xe0
case|:
case|case
literal|0xe1
case|:
case|case
literal|0xe2
case|:
case|case
literal|0xe3
case|:
comment|/* cmp imm16, an zero-extends the immediate.  */
if|if
condition|(
name|code
operator|==
literal|0xdc
operator|&&
operator|(
name|long
operator|)
name|value
operator|<
literal|0
condition|)
continue|continue;
comment|/* So do sp-based offsets.  */
if|if
condition|(
name|code
operator|>=
literal|0xb0
operator|&&
name|code
operator|<=
literal|0xb3
operator|&&
operator|(
name|long
operator|)
name|value
operator|<
literal|0
condition|)
continue|continue;
comment|/* Note that we've changed the relocation contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Fix the opcode.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xfa
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_GOTOFF32
operator|)
condition|?
name|R_MN10300_GOTOFF16
else|:
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_GOT32
operator|)
condition|?
name|R_MN10300_GOT16
else|:
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_GOTPC32
operator|)
condition|?
name|R_MN10300_GOTPC16
else|:
name|R_MN10300_16
argument_list|)
expr_stmt|;
comment|/* Delete two bytes of data.  */
if|if
condition|(
operator|!
name|mn10300_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 		       Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
literal|0xfe
condition|)
block|{
comment|/* add imm32,sp -> add imm16,sp  */
comment|/* Note that we've changed the relocation contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Fix the opcode.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xfa
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xfe
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_GOT32
operator|)
condition|?
name|R_MN10300_GOT16
else|:
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_GOTOFF32
operator|)
condition|?
name|R_MN10300_GOTOFF16
else|:
operator|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MN10300_GOTPC32
operator|)
condition|?
name|R_MN10300_GOTPC16
else|:
name|R_MN10300_16
argument_list|)
expr_stmt|;
comment|/* Delete two bytes of data.  */
if|if
condition|(
operator|!
name|mn10300_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 		     Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the symbols for elf_link_input_bfd.  */
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
block|}
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the section contents for elf_link_input_bfd.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
block|}
block|}
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Compute the stack size and movm arguments for the function    referred to by HASH at address ADDR in section with    contents CONTENTS, store the information in the hash table.  */
end_comment

begin_function
specifier|static
name|void
name|compute_function_info
parameter_list|(
name|abfd
parameter_list|,
name|hash
parameter_list|,
name|addr
parameter_list|,
name|contents
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|elf32_mn10300_link_hash_entry
modifier|*
name|hash
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|contents
decl_stmt|;
block|{
name|unsigned
name|char
name|byte1
decl_stmt|,
name|byte2
decl_stmt|;
comment|/* We only care about a very small subset of the possible prologue      sequences here.  Basically we look for:       movm [d2,d3,a2,a3],sp (optional)      add<size>,sp (optional, and only for sizes which fit in an unsigned 		    8 bit number)       If we find anything else, we quit.  */
comment|/* Look for movm [regs],sp */
name|byte1
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|addr
argument_list|)
expr_stmt|;
name|byte2
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|addr
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte1
operator|==
literal|0xcf
condition|)
block|{
name|hash
operator|->
name|movm_args
operator|=
name|byte2
expr_stmt|;
name|addr
operator|+=
literal|2
expr_stmt|;
name|byte1
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|addr
argument_list|)
expr_stmt|;
name|byte2
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|addr
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now figure out how much stack space will be allocated by the movm      instruction.  We need this kept separate from the function's normal      stack space.  */
if|if
condition|(
name|hash
operator|->
name|movm_args
condition|)
block|{
comment|/* Space for d2.  */
if|if
condition|(
name|hash
operator|->
name|movm_args
operator|&
literal|0x80
condition|)
name|hash
operator|->
name|movm_stack_size
operator|+=
literal|4
expr_stmt|;
comment|/* Space for d3.  */
if|if
condition|(
name|hash
operator|->
name|movm_args
operator|&
literal|0x40
condition|)
name|hash
operator|->
name|movm_stack_size
operator|+=
literal|4
expr_stmt|;
comment|/* Space for a2.  */
if|if
condition|(
name|hash
operator|->
name|movm_args
operator|&
literal|0x20
condition|)
name|hash
operator|->
name|movm_stack_size
operator|+=
literal|4
expr_stmt|;
comment|/* Space for a3.  */
if|if
condition|(
name|hash
operator|->
name|movm_args
operator|&
literal|0x10
condition|)
name|hash
operator|->
name|movm_stack_size
operator|+=
literal|4
expr_stmt|;
comment|/* "other" space.  d0, d1, a0, a1, mdr, lir, lar, 4 byte pad.  */
if|if
condition|(
name|hash
operator|->
name|movm_args
operator|&
literal|0x08
condition|)
name|hash
operator|->
name|movm_stack_size
operator|+=
literal|8
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_mach_am33
operator|||
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_mach_am33_2
condition|)
block|{
comment|/* "exother" space.  e0, e1, mdrq, mcrh, mcrl, mcvf */
if|if
condition|(
name|hash
operator|->
name|movm_args
operator|&
literal|0x1
condition|)
name|hash
operator|->
name|movm_stack_size
operator|+=
literal|6
operator|*
literal|4
expr_stmt|;
comment|/* exreg1 space.  e4, e5, e6, e7 */
if|if
condition|(
name|hash
operator|->
name|movm_args
operator|&
literal|0x2
condition|)
name|hash
operator|->
name|movm_stack_size
operator|+=
literal|4
operator|*
literal|4
expr_stmt|;
comment|/* exreg0 space.  e2, e3  */
if|if
condition|(
name|hash
operator|->
name|movm_args
operator|&
literal|0x4
condition|)
name|hash
operator|->
name|movm_stack_size
operator|+=
literal|2
operator|*
literal|4
expr_stmt|;
block|}
block|}
comment|/* Now look for the two stack adjustment variants.  */
if|if
condition|(
name|byte1
operator|==
literal|0xf8
operator|&&
name|byte2
operator|==
literal|0xfe
condition|)
block|{
name|int
name|temp
init|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|addr
operator|+
literal|2
argument_list|)
decl_stmt|;
name|temp
operator|=
operator|(
operator|(
name|temp
operator|&
literal|0xff
operator|)
operator|^
operator|(
operator|~
literal|0x7f
operator|)
operator|)
operator|+
literal|0x80
expr_stmt|;
name|hash
operator|->
name|stack_size
operator|=
operator|-
name|temp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|byte1
operator|==
literal|0xfa
operator|&&
name|byte2
operator|==
literal|0xfe
condition|)
block|{
name|int
name|temp
init|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|addr
operator|+
literal|2
argument_list|)
decl_stmt|;
name|temp
operator|=
operator|(
operator|(
name|temp
operator|&
literal|0xffff
operator|)
operator|^
operator|(
operator|~
literal|0x7fff
operator|)
operator|)
operator|+
literal|0x8000
expr_stmt|;
name|temp
operator|=
operator|-
name|temp
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|255
condition|)
name|hash
operator|->
name|stack_size
operator|=
name|temp
expr_stmt|;
block|}
comment|/* If the total stack to be allocated by the call instruction is more      than 255 bytes, then we can't remove the stack adjustment by using      "call" (we might still be able to remove the "movm" instruction.  */
if|if
condition|(
name|hash
operator|->
name|stack_size
operator|+
name|hash
operator|->
name|movm_stack_size
operator|>
literal|255
condition|)
name|hash
operator|->
name|stack_size
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Delete some bytes from a section while relaxing.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mn10300_elf_relax_delete_bytes
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|addr
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|unsigned
name|int
name|sec_shndx
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelalign
decl_stmt|;
name|bfd_vma
name|toaddr
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|,
modifier|*
name|isymend
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|end_hashes
decl_stmt|;
name|unsigned
name|int
name|symcount
decl_stmt|;
name|sec_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
comment|/* The deletion must stop at the next ALIGN reloc for an aligment      power larger than the number of bytes we are deleting.  */
name|irelalign
operator|=
name|NULL
expr_stmt|;
name|toaddr
operator|=
name|sec
operator|->
name|size
expr_stmt|;
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
expr_stmt|;
name|irelend
operator|=
name|irel
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
comment|/* Actually delete the bytes.  */
name|memmove
argument_list|(
name|contents
operator|+
name|addr
argument_list|,
name|contents
operator|+
name|addr
operator|+
name|count
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|toaddr
operator|-
name|addr
operator|-
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|sec
operator|->
name|size
operator|-=
name|count
expr_stmt|;
comment|/* Adjust all the relocs.  */
for|for
control|(
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
comment|/* Get the new reloc address.  */
if|if
condition|(
operator|(
name|irel
operator|->
name|r_offset
operator|>
name|addr
operator|&&
name|irel
operator|->
name|r_offset
operator|<
name|toaddr
operator|)
condition|)
name|irel
operator|->
name|r_offset
operator|-=
name|count
expr_stmt|;
block|}
comment|/* Adjust the local symbols defined in this section.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|isym
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
for|for
control|(
name|isymend
operator|=
name|isym
operator|+
name|symtab_hdr
operator|->
name|sh_info
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
control|)
block|{
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|sec_shndx
operator|&&
name|isym
operator|->
name|st_value
operator|>
name|addr
operator|&&
name|isym
operator|->
name|st_value
operator|<
name|toaddr
condition|)
name|isym
operator|->
name|st_value
operator|-=
name|count
expr_stmt|;
block|}
comment|/* Now adjust the global symbols defined in this section.  */
name|symcount
operator|=
operator|(
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|end_hashes
operator|=
name|sym_hashes
operator|+
name|symcount
expr_stmt|;
for|for
control|(
init|;
name|sym_hashes
operator|<
name|end_hashes
condition|;
name|sym_hashes
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|sym_hash
init|=
operator|*
name|sym_hashes
decl_stmt|;
if|if
condition|(
operator|(
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|sec
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|>
name|addr
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|<
name|toaddr
condition|)
block|{
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|-=
name|count
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if a symbol exists at the given address, else return    FALSE.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mn10300_elf_symbol_address_p
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|isym
parameter_list|,
name|addr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|unsigned
name|int
name|sec_shndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymend
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|end_hashes
decl_stmt|;
name|unsigned
name|int
name|symcount
decl_stmt|;
name|sec_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
comment|/* Examine all the symbols.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
for|for
control|(
name|isymend
operator|=
name|isym
operator|+
name|symtab_hdr
operator|->
name|sh_info
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
control|)
block|{
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|sec_shndx
operator|&&
name|isym
operator|->
name|st_value
operator|==
name|addr
condition|)
return|return
name|TRUE
return|;
block|}
name|symcount
operator|=
operator|(
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|end_hashes
operator|=
name|sym_hashes
operator|+
name|symcount
expr_stmt|;
for|for
control|(
init|;
name|sym_hashes
operator|<
name|end_hashes
condition|;
name|sym_hashes
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|sym_hash
init|=
operator|*
name|sym_hashes
decl_stmt|;
if|if
condition|(
operator|(
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|sec
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|==
name|addr
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* This is a version of bfd_generic_get_relocated_section_contents    which uses mn10300_elf_relocate_section.  */
end_comment

begin_function
specifier|static
name|bfd_byte
modifier|*
name|mn10300_elf_get_relocated_section_contents
parameter_list|(
name|output_bfd
parameter_list|,
name|link_info
parameter_list|,
name|link_order
parameter_list|,
name|data
parameter_list|,
name|relocatable
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|bfd_boolean
name|relocatable
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|input_section
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
init|=
name|input_section
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sections
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
comment|/* We only need to handle the case of relaxing, or of having a      particular set of section contents, specially.  */
if|if
condition|(
name|relocatable
operator|||
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|==
name|NULL
condition|)
return|return
name|bfd_generic_get_relocated_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|link_info
argument_list|,
name|link_order
argument_list|,
name|data
argument_list|,
name|relocatable
argument_list|,
name|symbols
argument_list|)
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
argument_list|,
operator|(
name|size_t
operator|)
name|input_section
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|input_section
operator|->
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|asection
modifier|*
modifier|*
name|secpp
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|,
modifier|*
name|isymend
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|internal_relocs
operator|=
operator|(
name|_bfd_elf_link_read_relocs
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
name|amt
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|sections
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sections
operator|==
name|NULL
operator|&&
name|amt
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|isymend
operator|=
name|isymbuf
operator|+
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
name|isym
operator|=
name|isymbuf
operator|,
name|secpp
operator|=
name|sections
init|;
name|isym
operator|<
name|isymend
condition|;
operator|++
name|isym
operator|,
operator|++
name|secpp
control|)
block|{
name|asection
modifier|*
name|isec
decl_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|isec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|isec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|isec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
name|isec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|input_bfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
operator|*
name|secpp
operator|=
name|isec
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mn10300_elf_relocate_section
argument_list|(
name|output_bfd
argument_list|,
name|link_info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|data
argument_list|,
name|internal_relocs
argument_list|,
name|isymbuf
argument_list|,
name|sections
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
return|return
name|data
return|;
name|error_return
label|:
if|if
condition|(
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|internal_relocs
operator|!=
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Assorted hash table functions.  */
end_comment

begin_comment
comment|/* Initialize an entry in the link hash table.  */
end_comment

begin_comment
comment|/* Create an entry in an MN10300 ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|elf32_mn10300_link_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|elf32_mn10300_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|elf32_mn10300_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|elf32_mn10300_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elf32_mn10300_link_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf32_mn10300_link_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|elf32_mn10300_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elf32_mn10300_link_hash_entry
operator|*
operator|)
name|_bfd_elf_link_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|(
expr|struct
name|elf32_mn10300_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
block|{
name|ret
operator|->
name|direct_calls
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|stack_size
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|movm_args
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|movm_stack_size
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Create an mn10300 ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elf32_mn10300_link_hash_table_create
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|elf32_mn10300_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf32_mn10300_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|elf32_mn10300_link_hash_table
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|elf32_mn10300_link_hash_table
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|elf32_mn10300_link_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf32_mn10300_link_hash_entry
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_hash_table
argument_list|)
expr_stmt|;
name|ret
operator|->
name|static_hash_table
operator|=
operator|(
expr|struct
name|elf32_mn10300_link_hash_table
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|->
name|static_hash_table
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|static_hash_table
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|elf32_mn10300_link_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf32_mn10300_link_hash_entry
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
operator|->
name|static_hash_table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Free an mn10300 ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|void
name|elf32_mn10300_link_hash_table_free
parameter_list|(
name|hash
parameter_list|)
name|struct
name|bfd_link_hash_table
modifier|*
name|hash
decl_stmt|;
block|{
name|struct
name|elf32_mn10300_link_hash_table
modifier|*
name|ret
init|=
operator|(
expr|struct
name|elf32_mn10300_link_hash_table
operator|*
operator|)
name|hash
decl_stmt|;
name|_bfd_generic_link_hash_table_free
argument_list|(
operator|(
expr|struct
name|bfd_link_hash_table
operator|*
operator|)
name|ret
operator|->
name|static_hash_table
argument_list|)
expr_stmt|;
name|_bfd_generic_link_hash_table_free
argument_list|(
operator|(
expr|struct
name|bfd_link_hash_table
operator|*
operator|)
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|elf_mn10300_mach
parameter_list|(
name|flags
parameter_list|)
name|flagword
name|flags
decl_stmt|;
block|{
switch|switch
condition|(
name|flags
operator|&
name|EF_MN10300_MACH
condition|)
block|{
case|case
name|E_MN10300_MACH_MN10300
case|:
default|default:
return|return
name|bfd_mach_mn10300
return|;
case|case
name|E_MN10300_MACH_AM33
case|:
return|return
name|bfd_mach_am33
return|;
case|case
name|E_MN10300_MACH_AM33_2
case|:
return|return
name|bfd_mach_am33_2
return|;
block|}
block|}
end_function

begin_comment
comment|/* The final processing done just before writing out a MN10300 ELF object    file.  This gets the MN10300 architecture right based on the machine    number.  */
end_comment

begin_function
name|void
name|_bfd_mn10300_elf_final_write_processing
parameter_list|(
name|abfd
parameter_list|,
name|linker
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_boolean
name|linker
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|long
name|val
decl_stmt|;
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
default|default:
case|case
name|bfd_mach_mn10300
case|:
name|val
operator|=
name|E_MN10300_MACH_MN10300
expr_stmt|;
break|break;
case|case
name|bfd_mach_am33
case|:
name|val
operator|=
name|E_MN10300_MACH_AM33
expr_stmt|;
break|break;
case|case
name|bfd_mach_am33_2
case|:
name|val
operator|=
name|E_MN10300_MACH_AM33_2
expr_stmt|;
break|break;
block|}
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
operator|(
name|EF_MN10300_MACH
operator|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator||=
name|val
expr_stmt|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_mn10300_elf_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_mn10300
argument_list|,
name|elf_mn10300_mach
argument_list|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mn10300_elf_merge_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|bfd_get_arch
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
operator|&&
name|bfd_get_mach
argument_list|(
name|obfd
argument_list|)
operator|<
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PLT0_ENTRY_SIZE
value|15
end_define

begin_define
define|#
directive|define
name|PLT_ENTRY_SIZE
value|20
end_define

begin_define
define|#
directive|define
name|PIC_PLT_ENTRY_SIZE
value|24
end_define

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_mn10300_plt0_entry
index|[
name|PLT0_ENTRY_SIZE
index|]
init|=
block|{
literal|0xfc
block|,
literal|0xa0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* mov	(.got+8),a0 */
literal|0xfe
block|,
literal|0xe
block|,
literal|0x10
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* mov	(.got+4),r1 */
literal|0xf0
block|,
literal|0xf4
block|,
comment|/* jmp	(a0) */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_mn10300_plt_entry
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0xfc
block|,
literal|0xa0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* mov	(nameN@GOT + .got),a0 */
literal|0xf0
block|,
literal|0xf4
block|,
comment|/* jmp	(a0) */
literal|0xfe
block|,
literal|8
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* mov	reloc-table-address,r0 */
literal|0xdc
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* jmp	.plt0 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_mn10300_pic_plt_entry
index|[
name|PIC_PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0xfc
block|,
literal|0x22
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* mov	(nameN@GOT,a2),a0 */
literal|0xf0
block|,
literal|0xf4
block|,
comment|/* jmp	(a0) */
literal|0xfe
block|,
literal|8
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* mov	reloc-table-address,r0 */
literal|0xf8
block|,
literal|0x22
block|,
literal|8
block|,
comment|/* mov	(8,a2),a0 */
literal|0xfb
block|,
literal|0xa
block|,
literal|0x1a
block|,
literal|4
block|,
comment|/* mov	(4,a2),r1 */
literal|0xf0
block|,
literal|0xf4
block|,
comment|/* jmp	(a0) */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return size of the first PLT entry.  */
end_comment

begin_define
define|#
directive|define
name|elf_mn10300_sizeof_plt0
parameter_list|(
name|info
parameter_list|)
define|\
value|(info->shared ? PIC_PLT_ENTRY_SIZE : PLT0_ENTRY_SIZE)
end_define

begin_comment
comment|/* Return size of a PLT entry.  */
end_comment

begin_define
define|#
directive|define
name|elf_mn10300_sizeof_plt
parameter_list|(
name|info
parameter_list|)
define|\
value|(info->shared ? PIC_PLT_ENTRY_SIZE : PLT_ENTRY_SIZE)
end_define

begin_comment
comment|/* Return offset of the PLT0 address in an absolute PLT entry.  */
end_comment

begin_define
define|#
directive|define
name|elf_mn10300_plt_plt0_offset
parameter_list|(
name|info
parameter_list|)
value|16
end_define

begin_comment
comment|/* Return offset of the linker in PLT0 entry.  */
end_comment

begin_define
define|#
directive|define
name|elf_mn10300_plt0_linker_offset
parameter_list|(
name|info
parameter_list|)
value|2
end_define

begin_comment
comment|/* Return offset of the GOT id in PLT0 entry.  */
end_comment

begin_define
define|#
directive|define
name|elf_mn10300_plt0_gotid_offset
parameter_list|(
name|info
parameter_list|)
value|9
end_define

begin_comment
comment|/* Return offset of the temporary in PLT entry */
end_comment

begin_define
define|#
directive|define
name|elf_mn10300_plt_temp_offset
parameter_list|(
name|info
parameter_list|)
value|8
end_define

begin_comment
comment|/* Return offset of the symbol in PLT entry.  */
end_comment

begin_define
define|#
directive|define
name|elf_mn10300_plt_symbol_offset
parameter_list|(
name|info
parameter_list|)
value|2
end_define

begin_comment
comment|/* Return offset of the relocation in PLT entry.  */
end_comment

begin_define
define|#
directive|define
name|elf_mn10300_plt_reloc_offset
parameter_list|(
name|info
parameter_list|)
value|11
end_define

begin_comment
comment|/* The name of the dynamic interpreter.  This is put in the .interp    section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/lib/ld.so.1"
end_define

begin_comment
comment|/* Create dynamic sections when linking against a dynamic object.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|_bfd_mn10300_elf_create_dynamic_sections
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|int
name|ptralign
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|bed
operator|->
name|s
operator|->
name|arch_size
condition|)
block|{
case|case
literal|32
case|:
name|ptralign
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|ptralign
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* We need to create .plt, .rel[a].plt, .got, .got.plt, .dynbss, and      .rel[a].bss sections.  */
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
operator|(
name|bed
operator|->
name|default_use_rela_p
condition|?
literal|".rela.plt"
else|:
literal|".rel.plt"
operator|)
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|ptralign
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|_bfd_mn10300_elf_create_got_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|{
specifier|const
name|char
modifier|*
name|secname
decl_stmt|;
name|char
modifier|*
name|relname
decl_stmt|;
name|flagword
name|secflags
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|secflags
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|secflags
operator|&
operator|(
name|SEC_DATA
operator||
name|SEC_LINKER_CREATED
operator|)
operator|)
operator|||
operator|(
operator|(
name|secflags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
name|SEC_HAS_CONTENTS
operator|)
condition|)
continue|continue;
name|secname
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|relname
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|strlen
argument_list|(
name|secname
argument_list|)
operator|+
literal|6
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|relname
argument_list|,
literal|".rela"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|relname
argument_list|,
name|secname
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
name|relname
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|ptralign
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|bed
operator|->
name|want_dynbss
condition|)
block|{
comment|/* The .dynbss section is a place to put symbols which are defined 	 by dynamic objects, are referenced by regular objects, and are 	 not functions.  We must allocate space for them in the process 	 image and use a R_*_COPY reloc to tell the dynamic linker to 	 initialize them at run time.  The linker script puts the .dynbss 	 section into the .bss section of the final image.  */
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".dynbss"
argument_list|,
name|SEC_ALLOC
operator||
name|SEC_LINKER_CREATED
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* The .rel[a].bss section holds copy relocs.  This section is not 	 normally needed.  We need to create it here, though, so that the 	 linker will map it to an output section.  We can't just create it 	 only if we need it, because we will not know whether we need it 	 until we have seen all the input files, and the first time the 	 main linker code calls BFD after examining all the input files 	 (size_dynamic_sections) the input sections have already been 	 mapped to the output sections.  If the section turns out not to 	 be needed, we can discard it later.  We will never need this 	 section when generating a shared object, since they do not use 	 copy relocs.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
operator|(
name|bed
operator|->
name|default_use_rela_p
condition|?
literal|".rela.bss"
else|:
literal|".rel.bss"
operator|)
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|ptralign
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|_bfd_mn10300_elf_adjust_dynamic_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|power_of_two
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* Make sure we know what is going on here.  */
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|needs_plt
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
operator|||
operator|(
name|h
operator|->
name|def_dynamic
operator|&&
name|h
operator|->
name|ref_regular
operator|&&
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If this is a function, put it in the procedure linkage table.  We      will fill in the contents of the procedure linkage table later,      when we know the address of the .got section.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|||
name|h
operator|->
name|needs_plt
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|h
operator|->
name|def_dynamic
operator|&&
operator|!
name|h
operator|->
name|ref_dynamic
condition|)
block|{
comment|/* This case can occur if we saw a PLT reloc in an input 	     file, but the symbol was never referred to by a dynamic 	     object.  In such a case, we don't actually need to build 	     a procedure linkage table, and we can just do a REL32 	     reloc instead.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|needs_plt
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Make sure this symbol is output as a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* If this is the first .plt entry, make room for the special 	 first entry.  */
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
name|s
operator|->
name|size
operator|+=
name|elf_mn10300_sizeof_plt0
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* If this symbol is not defined in a regular file, and we are 	 not generating a shared library, then set the symbol to this 	 location in the .plt.  This is required to make function 	 pointers compare as equal between the normal executable and 	 the shared library.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|size
expr_stmt|;
block|}
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|size
expr_stmt|;
comment|/* Make room for this entry.  */
name|s
operator|->
name|size
operator|+=
name|elf_mn10300_sizeof_plt
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* We also need to make an entry in the .got.plt section, which 	 will be placed in the .got section by the linker script.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
comment|/* We also need to make an entry in the .rela.plt section.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
comment|/* If we are creating a shared library, we must presume that the      only references to the symbol are via the global offset table.      For such cases we need not do anything here; the relocations will      be handled correctly by relocate_section.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
return|return
name|TRUE
return|;
comment|/* If there are no references to this symbol that do not use the      GOT, we don't need to generate a copy reloc.  */
if|if
condition|(
operator|!
name|h
operator|->
name|non_got_ref
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|size
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"dynamic variable `%s' is zero size"
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* We must allocate the symbol in our .dynbss section, which will      become part of the .bss section of the executable.  There will be      an entry for this symbol in the .dynsym section.  The dynamic      object will contain position independent code, so all references      from the dynamic object to this symbol will go through the global      offset table.  The dynamic linker will use the .dynsym entry to      determine the address it must put in the global offset table, so      both the dynamic object and the regular object will refer to the      same memory location for the variable.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* We must generate a R_MN10300_COPY reloc to tell the dynamic linker to      copy the initial value out of the dynamic object and into the      runtime process image.  We need to remember the offset into the      .rela.bss section we are going to use.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|srel
decl_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.bss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|srel
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|h
operator|->
name|needs_copy
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We need to figure out the alignment required for this symbol.  I      have no idea how ELF linkers handle this.  */
name|power_of_two
operator|=
name|bfd_log2
argument_list|(
name|h
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
literal|3
condition|)
name|power_of_two
operator|=
literal|3
expr_stmt|;
comment|/* Apply the required alignment.  */
name|s
operator|->
name|size
operator|=
name|BFD_ALIGN
argument_list|(
name|s
operator|->
name|size
argument_list|,
call|(
name|bfd_size_type
call|)
argument_list|(
literal|1
operator|<<
name|power_of_two
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
name|bfd_get_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
name|power_of_two
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Define the symbol as being at this point in the section.  */
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|size
expr_stmt|;
comment|/* Increment the section size to make room for the symbol.  */
name|s
operator|->
name|size
operator|+=
name|h
operator|->
name|size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|_bfd_mn10300_elf_size_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_boolean
name|plt
decl_stmt|;
name|bfd_boolean
name|relocs
decl_stmt|;
name|bfd_boolean
name|reltext
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We may have created entries in the .rela.got section. 	 However, if we are not creating the dynamic sections, we will 	 not actually use these entries.  Reset the size of .rela.got, 	 which will cause it to get stripped from the output file 	 below.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|s
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* The check_relocs and adjust_dynamic_symbol entry points have      determined the sizes of the various dynamic sections.  Allocate      memory for them.  */
name|plt
operator|=
name|FALSE
expr_stmt|;
name|relocs
operator|=
name|FALSE
expr_stmt|;
name|reltext
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* It's OK to base decisions on the section name, because none 	 of the dynobj section names depend upon the input files.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".plt"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Remember whether there is a PLT.  */
name|plt
operator|=
name|s
operator|->
name|size
operator|!=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|target
decl_stmt|;
comment|/* Remember whether there are any reloc sections other 		 than .rela.plt.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rela.plt"
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|outname
decl_stmt|;
name|relocs
operator|=
name|TRUE
expr_stmt|;
comment|/* If this relocation section applies to a read only 		     section, then we probably need a DT_TEXTREL 		     entry.  The entries in the .rela.plt section 		     really apply to the .got section, which we 		     created ourselves and so know is not readonly.  */
name|outname
operator|=
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|output_section
argument_list|)
expr_stmt|;
name|target
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|outname
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|NULL
operator|&&
operator|(
name|target
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|target
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|reltext
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* We use the reloc_count field as a counter if we need 		 to copy relocs into the output file.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".got"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".dynbss"
argument_list|)
operator|!=
literal|0
condition|)
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
block|{
comment|/* If we don't need this section, strip it from the 	     output file.  This is mostly to handle .rela.bss and 	     .rela.plt.  We must create both sections in 	     create_dynamic_sections, because they must be created 	     before the linker maps input sections to output 	     sections.  The linker does that before 	     adjust_dynamic_symbol is called, and it is that 	     function which decides whether anything needs to go 	     into these sections.  */
name|s
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Allocate memory for the section contents.  We use bfd_zalloc 	 here in case unused entries are not reclaimed before the 	 section's contents are written out.  This should not happen, 	 but this way if it does, we get a R_MN10300_NONE reloc 	 instead of garbage.  */
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in _bfd_mn10300_elf_finish_dynamic_sections, 	 but we must add the entries now so that we get the correct 	 size for the .dynamic section.  The DT_DEBUG entry is filled 	 in by the dynamic linker and used by the debugger.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|plt
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PLTREL
argument_list|,
name|DT_RELA
argument_list|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|relocs
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RELA
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RELAENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|reltext
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|_bfd_mn10300_elf_finish_dynamic_symbol
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
name|bfd_vma
name|plt_index
decl_stmt|;
name|bfd_vma
name|got_offset
decl_stmt|;
name|Elf_Internal_Rela
name|rel
decl_stmt|;
comment|/* This symbol has an entry in the procedure linkage table.  Set 	 it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|sgot
operator|!=
name|NULL
operator|&&
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Get the index in the procedure linkage table which 	 corresponds to this symbol.  This is the index of this symbol 	 in all the symbols for which we are making plt entries.  The 	 first entry in the procedure linkage table is reserved.  */
name|plt_index
operator|=
operator|(
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|-
name|elf_mn10300_sizeof_plt0
argument_list|(
name|info
argument_list|)
operator|)
operator|/
name|elf_mn10300_sizeof_plt
argument_list|(
name|info
argument_list|)
operator|)
expr_stmt|;
comment|/* Get the offset into the .got table of the entry that 	 corresponds to this function.  Each .got entry is 4 bytes. 	 The first three are reserved.  */
name|got_offset
operator|=
operator|(
name|plt_index
operator|+
literal|3
operator|)
operator|*
literal|4
expr_stmt|;
comment|/* Fill in the entry in the procedure linkage table.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|,
name|elf_mn10300_plt_entry
argument_list|,
name|elf_mn10300_sizeof_plt
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|got_offset
operator|)
argument_list|,
operator|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|elf_mn10300_plt_symbol_offset
argument_list|(
name|info
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
literal|1
operator|-
name|h
operator|->
name|plt
operator|.
name|offset
operator|-
name|elf_mn10300_plt_plt0_offset
argument_list|(
name|info
argument_list|)
operator|)
argument_list|,
operator|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|elf_mn10300_plt_plt0_offset
argument_list|(
name|info
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|,
name|elf_mn10300_pic_plt_entry
argument_list|,
name|elf_mn10300_sizeof_plt
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|got_offset
argument_list|,
operator|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|elf_mn10300_plt_symbol_offset
argument_list|(
name|info
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_index
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
argument_list|,
operator|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|elf_mn10300_plt_reloc_offset
argument_list|(
name|info
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Fill in the entry in the global offset table.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|elf_mn10300_plt_temp_offset
argument_list|(
name|info
argument_list|)
operator|)
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|got_offset
argument_list|)
expr_stmt|;
comment|/* Fill in the entry in the .rela.plt section.  */
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|got_offset
operator|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_MN10300_JMP_SLOT
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|(
operator|(
name|Elf32_External_Rela
operator|*
operator|)
name|srel
operator|->
name|contents
operator|+
name|plt_index
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h
operator|->
name|def_regular
condition|)
comment|/* Mark the symbol as undefined, rather than as defined in 	   the .plt section.  Leave the value alone.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
name|Elf_Internal_Rela
name|rel
decl_stmt|;
comment|/* This symbol has an entry in the global offset table.  Set it up.  */
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
operator|&&
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
operator|~
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* If this is a -Bsymbolic link, and the symbol is defined 	 locally, we just want to emit a RELATIVE reloc.  Likewise if 	 the symbol was forced to be local because of a version file. 	 The entry in the global offset table will already have been 	 initialized in the relocate_section function.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|)
operator|&&
name|h
operator|->
name|def_regular
condition|)
block|{
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_MN10300_RELATIVE
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|h
operator|->
name|got
operator|.
name|offset
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_MN10300_GLOB_DAT
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|(
operator|(
name|Elf32_External_Rela
operator|*
operator|)
name|srel
operator|->
name|contents
operator|+
name|srel
operator|->
name|reloc_count
operator|)
argument_list|)
expr_stmt|;
operator|++
name|srel
operator|->
name|reloc_count
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|needs_copy
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|Elf_Internal_Rela
name|rel
decl_stmt|;
comment|/* This symbol needs a copy reloc.  Set it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|,
literal|".rela.bss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_MN10300_COPY
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|(
operator|(
name|Elf32_External_Rela
operator|*
operator|)
name|s
operator|->
name|contents
operator|+
name|s
operator|->
name|reloc_count
operator|)
argument_list|)
expr_stmt|;
operator|++
name|s
operator|->
name|reloc_count
expr_stmt|;
block|}
comment|/* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
name|h
operator|==
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hgot
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|_bfd_mn10300_elf_finish_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|Elf32_External_Dyn
modifier|*
name|dyncon
decl_stmt|;
name|Elf32_External_Dyn
modifier|*
name|dynconend
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_elf32_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
default|default:
break|break;
case|case
name|DT_PLTGOT
case|:
name|name
operator|=
literal|".got"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_JMPREL
case|:
name|name
operator|=
literal|".rela.plt"
expr_stmt|;
name|get_vma
label|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|size
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_RELASZ
case|:
comment|/* My reading of the SVR4 ABI indicates that the 		 procedure linkage table relocs (DT_JMPREL) should be 		 included in the overall relocs (DT_RELA).  This is 		 what Solaris does.  However, UnixWare can not handle 		 that case.  Therefore, we override the DT_RELASZ entry 		 here to make it not include the JMPREL relocs.  Since 		 the linker script arranges for .rela.plt to follow all 		 other relocation sections, we don't have to worry 		 about changing the DT_RELA entry.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|-=
name|s
operator|->
name|size
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Fill in the first entry in the procedure linkage table.  */
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|splt
operator|&&
name|splt
operator|->
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
argument_list|,
name|elf_mn10300_pic_plt_entry
argument_list|,
name|elf_mn10300_sizeof_plt
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
argument_list|,
name|elf_mn10300_plt0_entry
argument_list|,
name|PLT0_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
literal|4
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|elf_mn10300_plt0_gotid_offset
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
literal|8
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|elf_mn10300_plt0_linker_offset
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* UnixWare sets the entsize of .plt to 4, although that doesn't 	     really seem like the right value.  */
name|elf_section_data
argument_list|(
name|splt
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|4
expr_stmt|;
block|}
block|}
comment|/* Fill in the first three entries in the global offset table.  */
if|if
condition|(
name|sgot
operator|->
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sdyn
operator|==
name|NULL
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
else|else
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sdyn
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sdyn
operator|->
name|output_offset
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
name|elf_section_data
argument_list|(
name|sgot
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|4
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Classify relocation types, such that combreloc can sort them    properly.  */
end_comment

begin_function
specifier|static
name|enum
name|elf_reloc_type_class
name|_bfd_mn10300_elf_reloc_type_class
parameter_list|(
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rela
parameter_list|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|ELF32_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_MN10300_RELATIVE
case|:
return|return
name|reloc_class_relative
return|;
case|case
name|R_MN10300_JMP_SLOT
case|:
return|return
name|reloc_class_plt
return|;
case|case
name|R_MN10300_COPY
case|:
return|return
name|reloc_class_copy
return|;
default|default:
return|return
name|reloc_class_normal
return|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ELF_ARCH
end_ifndef

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_mn10300_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-mn10300"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_mn10300
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_MN10300
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT1
value|EM_CYGNUS_MN10300
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|elf_info_to_howto
value|mn10300_info_to_howto
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_rela_normal
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|mn10300_elf_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|mn10300_elf_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|mn10300_elf_relocate_section
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_relax_section
value|mn10300_elf_relax_section
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_get_relocated_section_contents
define|\
value|mn10300_elf_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
define|\
value|elf32_mn10300_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_free
define|\
value|elf32_mn10300_link_hash_table_free
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|elf_symbol_leading_char
end_ifndef

begin_define
define|#
directive|define
name|elf_symbol_leading_char
value|'_'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* So we can set bits in e_flags.  */
end_comment

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
define|\
value|_bfd_mn10300_elf_final_write_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|_bfd_mn10300_elf_object_p
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_merge_private_bfd_data
define|\
value|_bfd_mn10300_elf_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
define|\
value|_bfd_mn10300_elf_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
define|\
value|_bfd_mn10300_elf_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
define|\
value|_bfd_mn10300_elf_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
define|\
value|_bfd_mn10300_elf_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
define|\
value|_bfd_mn10300_elf_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_reloc_type_class
define|\
value|_bfd_mn10300_elf_reloc_type_class
end_define

begin_define
define|#
directive|define
name|elf_backend_want_got_plt
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_readonly
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|12
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

