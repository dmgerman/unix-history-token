begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* DWARF 2 support.    Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,    2004, 2005, 2006, 2007 Free Software Foundation, Inc.     Adapted from gdb/dwarf2read.c by Gavin Koch of Cygnus Solutions    (gavin@cygnus.com).     From the dwarf2read.c header:    Adapted by Gary Funck (gary@intrepid.com), Intrepid Technology,    Inc.  with support from Florida State University (under contract    with the Ada Joint Program Office), and Silicon Graphics, Inc.    Initial contribution by Brent Benson, Harris Computer Systems, Inc.,    based on Fred Fish's (Cygnus Support) implementation of DWARF 1    support in dwarfread.c     This file is part of BFD.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or (at    your option) any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/dwarf2.h"
end_include

begin_comment
comment|/* The data in the .debug_line statement prologue looks like this.  */
end_comment

begin_struct
struct|struct
name|line_head
block|{
name|bfd_vma
name|total_length
decl_stmt|;
name|unsigned
name|short
name|version
decl_stmt|;
name|bfd_vma
name|prologue_length
decl_stmt|;
name|unsigned
name|char
name|minimum_instruction_length
decl_stmt|;
name|unsigned
name|char
name|default_is_stmt
decl_stmt|;
name|int
name|line_base
decl_stmt|;
name|unsigned
name|char
name|line_range
decl_stmt|;
name|unsigned
name|char
name|opcode_base
decl_stmt|;
name|unsigned
name|char
modifier|*
name|standard_opcode_lengths
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Attributes have a name and a value.  */
end_comment

begin_struct
struct|struct
name|attribute
block|{
name|enum
name|dwarf_attribute
name|name
decl_stmt|;
name|enum
name|dwarf_form
name|form
decl_stmt|;
union|union
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|struct
name|dwarf_block
modifier|*
name|blk
decl_stmt|;
name|bfd_uint64_t
name|val
decl_stmt|;
name|bfd_int64_t
name|sval
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Blocks are a bunch of untyped bytes.  */
end_comment

begin_struct
struct|struct
name|dwarf_block
block|{
name|unsigned
name|int
name|size
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|loadable_section
block|{
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|adj_vma
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dwarf2_debug
block|{
comment|/* A list of all previously read comp_units.  */
name|struct
name|comp_unit
modifier|*
name|all_comp_units
decl_stmt|;
comment|/* The next unread compilation unit within the .debug_info section.      Zero indicates that the .debug_info section has not been loaded      into a buffer yet.  */
name|bfd_byte
modifier|*
name|info_ptr
decl_stmt|;
comment|/* Pointer to the end of the .debug_info section memory buffer.  */
name|bfd_byte
modifier|*
name|info_ptr_end
decl_stmt|;
comment|/* Pointer to the bfd, section and address of the beginning of the      section.  The bfd might be different than expected because of      gnu_debuglink sections.  */
name|bfd
modifier|*
name|bfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_byte
modifier|*
name|sec_info_ptr
decl_stmt|;
comment|/* Pointer to the symbol table.  */
name|asymbol
modifier|*
modifier|*
name|syms
decl_stmt|;
comment|/* Pointer to the .debug_abbrev section loaded into memory.  */
name|bfd_byte
modifier|*
name|dwarf_abbrev_buffer
decl_stmt|;
comment|/* Length of the loaded .debug_abbrev section.  */
name|unsigned
name|long
name|dwarf_abbrev_size
decl_stmt|;
comment|/* Buffer for decode_line_info.  */
name|bfd_byte
modifier|*
name|dwarf_line_buffer
decl_stmt|;
comment|/* Length of the loaded .debug_line section.  */
name|unsigned
name|long
name|dwarf_line_size
decl_stmt|;
comment|/* Pointer to the .debug_str section loaded into memory.  */
name|bfd_byte
modifier|*
name|dwarf_str_buffer
decl_stmt|;
comment|/* Length of the loaded .debug_str section.  */
name|unsigned
name|long
name|dwarf_str_size
decl_stmt|;
comment|/* Pointer to the .debug_ranges section loaded into memory. */
name|bfd_byte
modifier|*
name|dwarf_ranges_buffer
decl_stmt|;
comment|/* Length of the loaded .debug_ranges section. */
name|unsigned
name|long
name|dwarf_ranges_size
decl_stmt|;
comment|/* If the most recent call to bfd_find_nearest_line was given an      address in an inlined function, preserve a pointer into the      calling chain for subsequent calls to bfd_find_inliner_info to      use. */
name|struct
name|funcinfo
modifier|*
name|inliner_chain
decl_stmt|;
comment|/* Number of loadable sections.  */
name|unsigned
name|int
name|loadable_section_count
decl_stmt|;
comment|/* Array of loadable sections.  */
name|struct
name|loadable_section
modifier|*
name|loadable_sections
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|arange
block|{
name|struct
name|arange
modifier|*
name|next
decl_stmt|;
name|bfd_vma
name|low
decl_stmt|;
name|bfd_vma
name|high
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A minimal decoding of DWARF2 compilation units.  We only decode    what's needed to get to the line number information.  */
end_comment

begin_struct
struct|struct
name|comp_unit
block|{
comment|/* Chain the previously read compilation units.  */
name|struct
name|comp_unit
modifier|*
name|next_unit
decl_stmt|;
comment|/* Keep the bfd convenient (for memory allocation).  */
name|bfd
modifier|*
name|abfd
decl_stmt|;
comment|/* The lowest and highest addresses contained in this compilation      unit as specified in the compilation unit header.  */
name|struct
name|arange
name|arange
decl_stmt|;
comment|/* The DW_AT_name attribute (for error messages).  */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The abbrev hash table.  */
name|struct
name|abbrev_info
modifier|*
modifier|*
name|abbrevs
decl_stmt|;
comment|/* Note that an error was found by comp_unit_find_nearest_line.  */
name|int
name|error
decl_stmt|;
comment|/* The DW_AT_comp_dir attribute.  */
name|char
modifier|*
name|comp_dir
decl_stmt|;
comment|/* TRUE if there is a line number table associated with this comp. unit.  */
name|int
name|stmtlist
decl_stmt|;
comment|/* Pointer to the current comp_unit so that we can find a given entry      by its reference.  */
name|bfd_byte
modifier|*
name|info_ptr_unit
decl_stmt|;
comment|/* The offset into .debug_line of the line number table.  */
name|unsigned
name|long
name|line_offset
decl_stmt|;
comment|/* Pointer to the first child die for the comp unit.  */
name|bfd_byte
modifier|*
name|first_child_die_ptr
decl_stmt|;
comment|/* The end of the comp unit.  */
name|bfd_byte
modifier|*
name|end_ptr
decl_stmt|;
comment|/* The decoded line number, NULL if not yet decoded.  */
name|struct
name|line_info_table
modifier|*
name|line_table
decl_stmt|;
comment|/* A list of the functions found in this comp. unit.  */
name|struct
name|funcinfo
modifier|*
name|function_table
decl_stmt|;
comment|/* A list of the variables found in this comp. unit.  */
name|struct
name|varinfo
modifier|*
name|variable_table
decl_stmt|;
comment|/* Pointer to dwarf2_debug structure.  */
name|struct
name|dwarf2_debug
modifier|*
name|stash
decl_stmt|;
comment|/* Address size for this unit - from unit header.  */
name|unsigned
name|char
name|addr_size
decl_stmt|;
comment|/* Offset size for this unit - from unit header.  */
name|unsigned
name|char
name|offset_size
decl_stmt|;
comment|/* Base address for this unit - from DW_AT_low_pc attribute of      DW_TAG_compile_unit DIE */
name|bfd_vma
name|base_address
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This data structure holds the information of an abbrev.  */
end_comment

begin_struct
struct|struct
name|abbrev_info
block|{
name|unsigned
name|int
name|number
decl_stmt|;
comment|/* Number identifying abbrev.  */
name|enum
name|dwarf_tag
name|tag
decl_stmt|;
comment|/* DWARF tag.  */
name|int
name|has_children
decl_stmt|;
comment|/* Boolean.  */
name|unsigned
name|int
name|num_attrs
decl_stmt|;
comment|/* Number of attributes.  */
name|struct
name|attr_abbrev
modifier|*
name|attrs
decl_stmt|;
comment|/* An array of attribute descriptions.  */
name|struct
name|abbrev_info
modifier|*
name|next
decl_stmt|;
comment|/* Next in chain.  */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|attr_abbrev
block|{
name|enum
name|dwarf_attribute
name|name
decl_stmt|;
name|enum
name|dwarf_form
name|form
decl_stmt|;
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|ABBREV_HASH_SIZE
end_ifndef

begin_define
define|#
directive|define
name|ABBREV_HASH_SIZE
value|121
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ATTR_ALLOC_CHUNK
end_ifndef

begin_define
define|#
directive|define
name|ATTR_ALLOC_CHUNK
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VERBATIM    The following function up to the END VERBATIM mark are    copied directly from dwarf2read.c.  */
end_comment

begin_comment
comment|/* Read dwarf information from a buffer.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|read_1_byte
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_byte
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_1_signed_byte
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_byte
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|bfd_get_signed_8
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|read_2_bytes
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|read_4_bytes
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_uint64_t
name|read_8_bytes
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_byte
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_byte
modifier|*
name|read_n_bytes
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_byte
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* If the size of a host char is 8 bits, we can return a pointer      to the buffer, otherwise we have to copy the data to a buffer      allocated on the temporary obstack.  */
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|read_string
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_byte
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
modifier|*
name|bytes_read_ptr
parameter_list|)
block|{
comment|/* Return a pointer to the embedded string.  */
name|char
modifier|*
name|str
init|=
operator|(
name|char
operator|*
operator|)
name|buf
decl_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|bytes_read_ptr
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|bytes_read_ptr
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|read_indirect_string
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|bfd_byte
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
modifier|*
name|bytes_read_ptr
parameter_list|)
block|{
name|bfd_uint64_t
name|offset
decl_stmt|;
name|struct
name|dwarf2_debug
modifier|*
name|stash
init|=
name|unit
operator|->
name|stash
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|unit
operator|->
name|offset_size
operator|==
literal|4
condition|)
name|offset
operator|=
name|read_4_bytes
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|offset
operator|=
name|read_8_bytes
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|*
name|bytes_read_ptr
operator|=
name|unit
operator|->
name|offset_size
expr_stmt|;
if|if
condition|(
operator|!
name|stash
operator|->
name|dwarf_str_buffer
condition|)
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
name|bfd
modifier|*
name|abfd
init|=
name|unit
operator|->
name|abfd
decl_stmt|;
name|bfd_size_type
name|sz
decl_stmt|;
name|msec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".debug_str"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msec
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Can't find .debug_str section."
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sz
operator|=
name|msec
operator|->
name|rawsize
condition|?
name|msec
operator|->
name|rawsize
else|:
name|msec
operator|->
name|size
expr_stmt|;
name|stash
operator|->
name|dwarf_str_size
operator|=
name|sz
expr_stmt|;
name|stash
operator|->
name|dwarf_str_buffer
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stash
operator|->
name|dwarf_str_buffer
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|msec
argument_list|,
name|stash
operator|->
name|dwarf_str_buffer
argument_list|,
literal|0
argument_list|,
name|sz
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|offset
operator|>=
name|stash
operator|->
name|dwarf_str_size
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: DW_FORM_strp offset (%lu) greater than or equal to .debug_str size (%lu)."
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|offset
argument_list|,
name|stash
operator|->
name|dwarf_str_size
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|stash
operator|->
name|dwarf_str_buffer
operator|+
name|offset
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* END VERBATIM */
end_comment

begin_function
specifier|static
name|bfd_uint64_t
name|read_address
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|bfd_byte
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|signed_vma
init|=
name|get_elf_backend_data
argument_list|(
name|unit
operator|->
name|abfd
argument_list|)
operator|->
name|sign_extend_vma
decl_stmt|;
if|if
condition|(
name|signed_vma
condition|)
block|{
switch|switch
condition|(
name|unit
operator|->
name|addr_size
condition|)
block|{
case|case
literal|8
case|:
return|return
name|bfd_get_signed_64
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|buf
argument_list|)
return|;
case|case
literal|4
case|:
return|return
name|bfd_get_signed_32
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|buf
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|bfd_get_signed_16
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|buf
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|unit
operator|->
name|addr_size
condition|)
block|{
case|case
literal|8
case|:
return|return
name|bfd_get_64
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|buf
argument_list|)
return|;
case|case
literal|4
case|:
return|return
name|bfd_get_32
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|buf
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|bfd_get_16
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|buf
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Lookup an abbrev_info structure in the abbrev hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|abbrev_info
modifier|*
name|lookup_abbrev
parameter_list|(
name|unsigned
name|int
name|number
parameter_list|,
name|struct
name|abbrev_info
modifier|*
modifier|*
name|abbrevs
parameter_list|)
block|{
name|unsigned
name|int
name|hash_number
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
name|abbrev
decl_stmt|;
name|hash_number
operator|=
name|number
operator|%
name|ABBREV_HASH_SIZE
expr_stmt|;
name|abbrev
operator|=
name|abbrevs
index|[
name|hash_number
index|]
expr_stmt|;
while|while
condition|(
name|abbrev
condition|)
block|{
if|if
condition|(
name|abbrev
operator|->
name|number
operator|==
name|number
condition|)
return|return
name|abbrev
return|;
else|else
name|abbrev
operator|=
name|abbrev
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* In DWARF version 2, the description of the debugging information is    stored in a separate .debug_abbrev section.  Before we read any    dies from a section we read in all abbreviations and install them    in a hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|abbrev_info
modifier|*
modifier|*
name|read_abbrevs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_uint64_t
name|offset
parameter_list|,
name|struct
name|dwarf2_debug
modifier|*
name|stash
parameter_list|)
block|{
name|struct
name|abbrev_info
modifier|*
modifier|*
name|abbrevs
decl_stmt|;
name|bfd_byte
modifier|*
name|abbrev_ptr
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
name|cur_abbrev
decl_stmt|;
name|unsigned
name|int
name|abbrev_number
decl_stmt|,
name|bytes_read
decl_stmt|,
name|abbrev_name
decl_stmt|;
name|unsigned
name|int
name|abbrev_form
decl_stmt|,
name|hash_number
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
operator|!
name|stash
operator|->
name|dwarf_abbrev_buffer
condition|)
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
name|msec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".debug_abbrev"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msec
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Can't find .debug_abbrev section."
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|stash
operator|->
name|dwarf_abbrev_size
operator|=
name|msec
operator|->
name|size
expr_stmt|;
name|stash
operator|->
name|dwarf_abbrev_buffer
operator|=
name|bfd_simple_get_relocated_section_contents
argument_list|(
name|abfd
argument_list|,
name|msec
argument_list|,
name|NULL
argument_list|,
name|stash
operator|->
name|syms
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stash
operator|->
name|dwarf_abbrev_buffer
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|offset
operator|>=
name|stash
operator|->
name|dwarf_abbrev_size
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Abbrev offset (%lu) greater than or equal to .debug_abbrev size (%lu)."
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|offset
argument_list|,
name|stash
operator|->
name|dwarf_abbrev_size
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|abbrev_info
operator|*
argument_list|)
operator|*
name|ABBREV_HASH_SIZE
expr_stmt|;
name|abbrevs
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|=
name|stash
operator|->
name|dwarf_abbrev_buffer
operator|+
name|offset
expr_stmt|;
name|abbrev_number
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
comment|/* Loop until we reach an abbrev number of 0.  */
while|while
condition|(
name|abbrev_number
condition|)
block|{
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|abbrev_info
argument_list|)
expr_stmt|;
name|cur_abbrev
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
comment|/* Read in abbrev header.  */
name|cur_abbrev
operator|->
name|number
operator|=
name|abbrev_number
expr_stmt|;
name|cur_abbrev
operator|->
name|tag
operator|=
operator|(
expr|enum
name|dwarf_tag
operator|)
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|cur_abbrev
operator|->
name|has_children
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
literal|1
expr_stmt|;
comment|/* Now read in declarations.  */
name|abbrev_name
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|abbrev_form
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
while|while
condition|(
name|abbrev_name
condition|)
block|{
if|if
condition|(
operator|(
name|cur_abbrev
operator|->
name|num_attrs
operator|%
name|ATTR_ALLOC_CHUNK
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|attr_abbrev
modifier|*
name|tmp
decl_stmt|;
name|amt
operator|=
name|cur_abbrev
operator|->
name|num_attrs
operator|+
name|ATTR_ALLOC_CHUNK
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|attr_abbrev
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|bfd_realloc
argument_list|(
name|cur_abbrev
operator|->
name|attrs
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ABBREV_HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|abbrev_info
modifier|*
name|abbrev
init|=
name|abbrevs
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|abbrev
condition|)
block|{
name|free
argument_list|(
name|abbrev
operator|->
name|attrs
argument_list|)
expr_stmt|;
name|abbrev
operator|=
name|abbrev
operator|->
name|next
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
block|}
name|cur_abbrev
operator|->
name|attrs
operator|=
name|tmp
expr_stmt|;
block|}
name|cur_abbrev
operator|->
name|attrs
index|[
name|cur_abbrev
operator|->
name|num_attrs
index|]
operator|.
name|name
operator|=
operator|(
expr|enum
name|dwarf_attribute
operator|)
name|abbrev_name
expr_stmt|;
name|cur_abbrev
operator|->
name|attrs
index|[
name|cur_abbrev
operator|->
name|num_attrs
operator|++
index|]
operator|.
name|form
operator|=
operator|(
expr|enum
name|dwarf_form
operator|)
name|abbrev_form
expr_stmt|;
name|abbrev_name
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|abbrev_form
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
block|}
name|hash_number
operator|=
name|abbrev_number
operator|%
name|ABBREV_HASH_SIZE
expr_stmt|;
name|cur_abbrev
operator|->
name|next
operator|=
name|abbrevs
index|[
name|hash_number
index|]
expr_stmt|;
name|abbrevs
index|[
name|hash_number
index|]
operator|=
name|cur_abbrev
expr_stmt|;
comment|/* Get next abbreviation. 	 Under Irix6 the abbreviations for a compilation unit are not 	 always properly terminated with an abbrev number of 0. 	 Exit loop if we encounter an abbreviation which we have 	 already read (which means we are about to read the abbreviations 	 for the next compile unit) or if the end of the abbreviation 	 table is reached.  */
if|if
condition|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|abbrev_ptr
operator|-
name|stash
operator|->
name|dwarf_abbrev_buffer
argument_list|)
operator|>=
name|stash
operator|->
name|dwarf_abbrev_size
condition|)
break|break;
name|abbrev_number
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
name|lookup_abbrev
argument_list|(
name|abbrev_number
argument_list|,
name|abbrevs
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
block|}
return|return
name|abbrevs
return|;
block|}
end_function

begin_comment
comment|/* Read an attribute value described by an attribute form.  */
end_comment

begin_function
specifier|static
name|bfd_byte
modifier|*
name|read_attribute_value
parameter_list|(
name|struct
name|attribute
modifier|*
name|attr
parameter_list|,
name|unsigned
name|form
parameter_list|,
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|bfd_byte
modifier|*
name|info_ptr
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
init|=
name|unit
operator|->
name|abfd
decl_stmt|;
name|unsigned
name|int
name|bytes_read
decl_stmt|;
name|struct
name|dwarf_block
modifier|*
name|blk
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|attr
operator|->
name|form
operator|=
operator|(
expr|enum
name|dwarf_form
operator|)
name|form
expr_stmt|;
switch|switch
condition|(
name|form
condition|)
block|{
case|case
name|DW_FORM_addr
case|:
comment|/* FIXME: DWARF3 draft says DW_FORM_ref_addr is offset_size.  */
case|case
name|DW_FORM_ref_addr
case|:
name|attr
operator|->
name|u
operator|.
name|val
operator|=
name|read_address
argument_list|(
name|unit
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|unit
operator|->
name|addr_size
expr_stmt|;
break|break;
case|case
name|DW_FORM_block2
case|:
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf_block
argument_list|)
expr_stmt|;
name|blk
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|blk
operator|->
name|size
operator|=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|2
expr_stmt|;
name|blk
operator|->
name|data
operator|=
name|read_n_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|blk
operator|->
name|size
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|blk
operator|->
name|size
expr_stmt|;
name|attr
operator|->
name|u
operator|.
name|blk
operator|=
name|blk
expr_stmt|;
break|break;
case|case
name|DW_FORM_block4
case|:
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf_block
argument_list|)
expr_stmt|;
name|blk
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|blk
operator|->
name|size
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|4
expr_stmt|;
name|blk
operator|->
name|data
operator|=
name|read_n_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|blk
operator|->
name|size
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|blk
operator|->
name|size
expr_stmt|;
name|attr
operator|->
name|u
operator|.
name|blk
operator|=
name|blk
expr_stmt|;
break|break;
case|case
name|DW_FORM_data2
case|:
name|attr
operator|->
name|u
operator|.
name|val
operator|=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_FORM_data4
case|:
name|attr
operator|->
name|u
operator|.
name|val
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_FORM_data8
case|:
name|attr
operator|->
name|u
operator|.
name|val
operator|=
name|read_8_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_FORM_string
case|:
name|attr
operator|->
name|u
operator|.
name|str
operator|=
name|read_string
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_strp
case|:
name|attr
operator|->
name|u
operator|.
name|str
operator|=
name|read_indirect_string
argument_list|(
name|unit
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_block
case|:
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf_block
argument_list|)
expr_stmt|;
name|blk
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|blk
operator|->
name|size
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|blk
operator|->
name|data
operator|=
name|read_n_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|blk
operator|->
name|size
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|blk
operator|->
name|size
expr_stmt|;
name|attr
operator|->
name|u
operator|.
name|blk
operator|=
name|blk
expr_stmt|;
break|break;
case|case
name|DW_FORM_block1
case|:
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf_block
argument_list|)
expr_stmt|;
name|blk
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|blk
operator|->
name|size
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|1
expr_stmt|;
name|blk
operator|->
name|data
operator|=
name|read_n_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|blk
operator|->
name|size
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|blk
operator|->
name|size
expr_stmt|;
name|attr
operator|->
name|u
operator|.
name|blk
operator|=
name|blk
expr_stmt|;
break|break;
case|case
name|DW_FORM_data1
case|:
name|attr
operator|->
name|u
operator|.
name|val
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_FORM_flag
case|:
name|attr
operator|->
name|u
operator|.
name|val
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_FORM_sdata
case|:
name|attr
operator|->
name|u
operator|.
name|sval
operator|=
name|read_signed_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_udata
case|:
name|attr
operator|->
name|u
operator|.
name|val
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref1
case|:
name|attr
operator|->
name|u
operator|.
name|val
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref2
case|:
name|attr
operator|->
name|u
operator|.
name|val
operator|=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref4
case|:
name|attr
operator|->
name|u
operator|.
name|val
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref8
case|:
name|attr
operator|->
name|u
operator|.
name|val
operator|=
name|read_8_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref_udata
case|:
name|attr
operator|->
name|u
operator|.
name|val
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_indirect
case|:
name|form
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|info_ptr
operator|=
name|read_attribute_value
argument_list|(
name|attr
argument_list|,
name|form
argument_list|,
name|unit
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
break|break;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Invalid or unhandled FORM value: %u."
argument_list|)
argument_list|,
name|form
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
block|}
return|return
name|info_ptr
return|;
block|}
end_function

begin_comment
comment|/* Read an attribute described by an abbreviated attribute.  */
end_comment

begin_function
specifier|static
name|bfd_byte
modifier|*
name|read_attribute
parameter_list|(
name|struct
name|attribute
modifier|*
name|attr
parameter_list|,
name|struct
name|attr_abbrev
modifier|*
name|abbrev
parameter_list|,
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|bfd_byte
modifier|*
name|info_ptr
parameter_list|)
block|{
name|attr
operator|->
name|name
operator|=
name|abbrev
operator|->
name|name
expr_stmt|;
name|info_ptr
operator|=
name|read_attribute_value
argument_list|(
name|attr
argument_list|,
name|abbrev
operator|->
name|form
argument_list|,
name|unit
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
return|return
name|info_ptr
return|;
block|}
end_function

begin_comment
comment|/* Source line information table routines.  */
end_comment

begin_define
define|#
directive|define
name|FILE_ALLOC_CHUNK
value|5
end_define

begin_define
define|#
directive|define
name|DIR_ALLOC_CHUNK
value|5
end_define

begin_struct
struct|struct
name|line_info
block|{
name|struct
name|line_info
modifier|*
name|prev_line
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|unsigned
name|int
name|column
decl_stmt|;
name|int
name|end_sequence
decl_stmt|;
comment|/* End of (sequential) code sequence.  */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|fileinfo
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|dir
decl_stmt|;
name|unsigned
name|int
name|time
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|line_info_table
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|num_files
decl_stmt|;
name|unsigned
name|int
name|num_dirs
decl_stmt|;
name|char
modifier|*
name|comp_dir
decl_stmt|;
name|char
modifier|*
modifier|*
name|dirs
decl_stmt|;
name|struct
name|fileinfo
modifier|*
name|files
decl_stmt|;
name|struct
name|line_info
modifier|*
name|last_line
decl_stmt|;
comment|/* largest VMA */
name|struct
name|line_info
modifier|*
name|lcl_head
decl_stmt|;
comment|/* local head; used in 'add_line_info' */
block|}
struct|;
end_struct

begin_comment
comment|/* Remember some information about each function.  If the function is    inlined (DW_TAG_inlined_subroutine) it may have two additional    attributes, DW_AT_call_file and DW_AT_call_line, which specify the    source code location where this function was inlined. */
end_comment

begin_struct
struct|struct
name|funcinfo
block|{
name|struct
name|funcinfo
modifier|*
name|prev_func
decl_stmt|;
comment|/* Pointer to previous function in list of all functions */
name|struct
name|funcinfo
modifier|*
name|caller_func
decl_stmt|;
comment|/* Pointer to function one scope higher */
name|char
modifier|*
name|caller_file
decl_stmt|;
comment|/* Source location file name where caller_func inlines this func */
name|int
name|caller_line
decl_stmt|;
comment|/* Source location line number where caller_func inlines this func */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* Source location file name */
name|int
name|line
decl_stmt|;
comment|/* Source location line number */
name|int
name|tag
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|arange
name|arange
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* Where the symbol is defined */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|varinfo
block|{
comment|/* Pointer to previous variable in list of all variables */
name|struct
name|varinfo
modifier|*
name|prev_var
decl_stmt|;
comment|/* Source location file name */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* Source location line number */
name|int
name|line
decl_stmt|;
name|int
name|tag
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
comment|/* Where the symbol is defined */
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* Is this a stack variable? */
name|unsigned
name|int
name|stack
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Return TRUE if NEW_LINE should sort after LINE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bfd_boolean
name|new_line_sorts_after
parameter_list|(
name|struct
name|line_info
modifier|*
name|new_line
parameter_list|,
name|struct
name|line_info
modifier|*
name|line
parameter_list|)
block|{
return|return
operator|(
name|new_line
operator|->
name|address
operator|>
name|line
operator|->
name|address
operator|||
operator|(
name|new_line
operator|->
name|address
operator|==
name|line
operator|->
name|address
operator|&&
name|new_line
operator|->
name|end_sequence
operator|<
name|line
operator|->
name|end_sequence
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Adds a new entry to the line_info list in the line_info_table, ensuring    that the list is sorted.  Note that the line_info list is sorted from    highest to lowest VMA (with possible duplicates); that is,    line_info->prev_line always accesses an equal or smaller VMA.  */
end_comment

begin_function
specifier|static
name|void
name|add_line_info
parameter_list|(
name|struct
name|line_info_table
modifier|*
name|table
parameter_list|,
name|bfd_vma
name|address
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|,
name|unsigned
name|int
name|column
parameter_list|,
name|int
name|end_sequence
parameter_list|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|line_info
argument_list|)
decl_stmt|;
name|struct
name|line_info
modifier|*
name|info
init|=
name|bfd_alloc
argument_list|(
name|table
operator|->
name|abfd
argument_list|,
name|amt
argument_list|)
decl_stmt|;
comment|/* Set member data of 'info'.  */
name|info
operator|->
name|address
operator|=
name|address
expr_stmt|;
name|info
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|info
operator|->
name|column
operator|=
name|column
expr_stmt|;
name|info
operator|->
name|end_sequence
operator|=
name|end_sequence
expr_stmt|;
if|if
condition|(
name|filename
operator|&&
name|filename
index|[
literal|0
index|]
condition|)
block|{
name|info
operator|->
name|filename
operator|=
name|bfd_alloc
argument_list|(
name|table
operator|->
name|abfd
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|filename
condition|)
name|strcpy
argument_list|(
name|info
operator|->
name|filename
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
name|info
operator|->
name|filename
operator|=
name|NULL
expr_stmt|;
comment|/* Find the correct location for 'info'.  Normally we will receive      new line_info data 1) in order and 2) with increasing VMAs.      However some compilers break the rules (cf. decode_line_info) and      so we include some heuristics for quickly finding the correct      location for 'info'. In particular, these heuristics optimize for      the common case in which the VMA sequence that we receive is a      list of locally sorted VMAs such as        p...z a...j  (where a< j< p< z)       Note: table->lcl_head is used to head an *actual* or *possible*      sequence within the list (such as a...j) that is not directly      headed by table->last_line       Note: we may receive duplicate entries from 'decode_line_info'.  */
if|if
condition|(
operator|!
name|table
operator|->
name|last_line
operator|||
name|new_line_sorts_after
argument_list|(
name|info
argument_list|,
name|table
operator|->
name|last_line
argument_list|)
condition|)
block|{
comment|/* Normal case: add 'info' to the beginning of the list */
name|info
operator|->
name|prev_line
operator|=
name|table
operator|->
name|last_line
expr_stmt|;
name|table
operator|->
name|last_line
operator|=
name|info
expr_stmt|;
comment|/* lcl_head: initialize to head a *possible* sequence at the end.  */
if|if
condition|(
operator|!
name|table
operator|->
name|lcl_head
condition|)
name|table
operator|->
name|lcl_head
operator|=
name|info
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|new_line_sorts_after
argument_list|(
name|info
argument_list|,
name|table
operator|->
name|lcl_head
argument_list|)
operator|&&
operator|(
operator|!
name|table
operator|->
name|lcl_head
operator|->
name|prev_line
operator|||
name|new_line_sorts_after
argument_list|(
name|info
argument_list|,
name|table
operator|->
name|lcl_head
operator|->
name|prev_line
argument_list|)
operator|)
condition|)
block|{
comment|/* Abnormal but easy: lcl_head is the head of 'info'.  */
name|info
operator|->
name|prev_line
operator|=
name|table
operator|->
name|lcl_head
operator|->
name|prev_line
expr_stmt|;
name|table
operator|->
name|lcl_head
operator|->
name|prev_line
operator|=
name|info
expr_stmt|;
block|}
else|else
block|{
comment|/* Abnormal and hard: Neither 'last_line' nor 'lcl_head' are valid 	 heads for 'info'.  Reset 'lcl_head'.  */
name|struct
name|line_info
modifier|*
name|li2
init|=
name|table
operator|->
name|last_line
decl_stmt|;
comment|/* always non-NULL */
name|struct
name|line_info
modifier|*
name|li1
init|=
name|li2
operator|->
name|prev_line
decl_stmt|;
while|while
condition|(
name|li1
condition|)
block|{
if|if
condition|(
operator|!
name|new_line_sorts_after
argument_list|(
name|info
argument_list|,
name|li2
argument_list|)
operator|&&
name|new_line_sorts_after
argument_list|(
name|info
argument_list|,
name|li1
argument_list|)
condition|)
break|break;
name|li2
operator|=
name|li1
expr_stmt|;
comment|/* always non-NULL */
name|li1
operator|=
name|li1
operator|->
name|prev_line
expr_stmt|;
block|}
name|table
operator|->
name|lcl_head
operator|=
name|li2
expr_stmt|;
name|info
operator|->
name|prev_line
operator|=
name|table
operator|->
name|lcl_head
operator|->
name|prev_line
expr_stmt|;
name|table
operator|->
name|lcl_head
operator|->
name|prev_line
operator|=
name|info
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Extract a fully qualified filename from a line info table.    The returned string has been malloc'ed and it is the caller's    responsibility to free it.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|concat_filename
parameter_list|(
name|struct
name|line_info_table
modifier|*
name|table
parameter_list|,
name|unsigned
name|int
name|file
parameter_list|)
block|{
name|char
modifier|*
name|filename
decl_stmt|;
if|if
condition|(
name|file
operator|-
literal|1
operator|>=
name|table
operator|->
name|num_files
condition|)
block|{
comment|/* FILE == 0 means unknown.  */
if|if
condition|(
name|file
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: mangled line number section (bad file number)."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|strdup
argument_list|(
literal|"<unknown>"
argument_list|)
return|;
block|}
name|filename
operator|=
name|table
operator|->
name|files
index|[
name|file
operator|-
literal|1
index|]
operator|.
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|IS_ABSOLUTE_PATH
argument_list|(
name|filename
argument_list|)
condition|)
block|{
name|char
modifier|*
name|dirname
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|subdirname
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|table
operator|->
name|files
index|[
name|file
operator|-
literal|1
index|]
operator|.
name|dir
condition|)
name|subdirname
operator|=
name|table
operator|->
name|dirs
index|[
name|table
operator|->
name|files
index|[
name|file
operator|-
literal|1
index|]
operator|.
name|dir
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|subdirname
operator|||
operator|!
name|IS_ABSOLUTE_PATH
argument_list|(
name|subdirname
argument_list|)
condition|)
name|dirname
operator|=
name|table
operator|->
name|comp_dir
expr_stmt|;
if|if
condition|(
operator|!
name|dirname
condition|)
block|{
name|dirname
operator|=
name|subdirname
expr_stmt|;
name|subdirname
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dirname
condition|)
return|return
name|strdup
argument_list|(
name|filename
argument_list|)
return|;
name|len
operator|=
name|strlen
argument_list|(
name|dirname
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|subdirname
condition|)
block|{
name|len
operator|+=
name|strlen
argument_list|(
name|subdirname
argument_list|)
operator|+
literal|1
expr_stmt|;
name|name
operator|=
name|bfd_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|dirname
argument_list|,
name|subdirname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|bfd_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s/%s"
argument_list|,
name|dirname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
return|return
name|strdup
argument_list|(
name|filename
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arange_add
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|arange
modifier|*
name|first_arange
parameter_list|,
name|bfd_vma
name|low_pc
parameter_list|,
name|bfd_vma
name|high_pc
parameter_list|)
block|{
name|struct
name|arange
modifier|*
name|arange
decl_stmt|;
comment|/* If the first arange is empty, use it. */
if|if
condition|(
name|first_arange
operator|->
name|high
operator|==
literal|0
condition|)
block|{
name|first_arange
operator|->
name|low
operator|=
name|low_pc
expr_stmt|;
name|first_arange
operator|->
name|high
operator|=
name|high_pc
expr_stmt|;
return|return;
block|}
comment|/* Next see if we can cheaply extend an existing range.  */
name|arange
operator|=
name|first_arange
expr_stmt|;
do|do
block|{
if|if
condition|(
name|low_pc
operator|==
name|arange
operator|->
name|high
condition|)
block|{
name|arange
operator|->
name|high
operator|=
name|high_pc
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|high_pc
operator|==
name|arange
operator|->
name|low
condition|)
block|{
name|arange
operator|->
name|low
operator|=
name|low_pc
expr_stmt|;
return|return;
block|}
name|arange
operator|=
name|arange
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|arange
condition|)
do|;
comment|/* Need to allocate a new arange and insert it into the arange list.      Order isn't significant, so just insert after the first arange. */
name|arange
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|arange
argument_list|)
argument_list|)
expr_stmt|;
name|arange
operator|->
name|low
operator|=
name|low_pc
expr_stmt|;
name|arange
operator|->
name|high
operator|=
name|high_pc
expr_stmt|;
name|arange
operator|->
name|next
operator|=
name|first_arange
operator|->
name|next
expr_stmt|;
name|first_arange
operator|->
name|next
operator|=
name|arange
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decode the line number information for UNIT.  */
end_comment

begin_function
specifier|static
name|struct
name|line_info_table
modifier|*
name|decode_line_info
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|struct
name|dwarf2_debug
modifier|*
name|stash
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
init|=
name|unit
operator|->
name|abfd
decl_stmt|;
name|struct
name|line_info_table
modifier|*
name|table
decl_stmt|;
name|bfd_byte
modifier|*
name|line_ptr
decl_stmt|;
name|bfd_byte
modifier|*
name|line_end
decl_stmt|;
name|struct
name|line_head
name|lh
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|bytes_read
decl_stmt|,
name|offset_size
decl_stmt|;
name|char
modifier|*
name|cur_file
decl_stmt|,
modifier|*
name|cur_dir
decl_stmt|;
name|unsigned
name|char
name|op_code
decl_stmt|,
name|extended_op
decl_stmt|,
name|adj_opcode
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
if|if
condition|(
operator|!
name|stash
operator|->
name|dwarf_line_buffer
condition|)
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
name|msec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".debug_line"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msec
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Can't find .debug_line section."
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|stash
operator|->
name|dwarf_line_size
operator|=
name|msec
operator|->
name|size
expr_stmt|;
name|stash
operator|->
name|dwarf_line_buffer
operator|=
name|bfd_simple_get_relocated_section_contents
argument_list|(
name|abfd
argument_list|,
name|msec
argument_list|,
name|NULL
argument_list|,
name|stash
operator|->
name|syms
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stash
operator|->
name|dwarf_line_buffer
condition|)
return|return
literal|0
return|;
block|}
comment|/* It is possible to get a bad value for the line_offset.  Validate      it here so that we won't get a segfault below.  */
if|if
condition|(
name|unit
operator|->
name|line_offset
operator|>=
name|stash
operator|->
name|dwarf_line_size
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Line offset (%lu) greater than or equal to .debug_line size (%lu)."
argument_list|)
argument_list|,
name|unit
operator|->
name|line_offset
argument_list|,
name|stash
operator|->
name|dwarf_line_size
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|line_info_table
argument_list|)
expr_stmt|;
name|table
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|table
operator|->
name|abfd
operator|=
name|abfd
expr_stmt|;
name|table
operator|->
name|comp_dir
operator|=
name|unit
operator|->
name|comp_dir
expr_stmt|;
name|table
operator|->
name|num_files
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|files
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|num_dirs
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|dirs
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|files
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|last_line
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|lcl_head
operator|=
name|NULL
expr_stmt|;
name|line_ptr
operator|=
name|stash
operator|->
name|dwarf_line_buffer
operator|+
name|unit
operator|->
name|line_offset
expr_stmt|;
comment|/* Read in the prologue.  */
name|lh
operator|.
name|total_length
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|4
expr_stmt|;
name|offset_size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|lh
operator|.
name|total_length
operator|==
literal|0xffffffff
condition|)
block|{
name|lh
operator|.
name|total_length
operator|=
name|read_8_bytes
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|8
expr_stmt|;
name|offset_size
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lh
operator|.
name|total_length
operator|==
literal|0
operator|&&
name|unit
operator|->
name|addr_size
operator|==
literal|8
condition|)
block|{
comment|/* Handle (non-standard) 64-bit DWARF2 formats.  */
name|lh
operator|.
name|total_length
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|4
expr_stmt|;
name|offset_size
operator|=
literal|8
expr_stmt|;
block|}
name|line_end
operator|=
name|line_ptr
operator|+
name|lh
operator|.
name|total_length
expr_stmt|;
name|lh
operator|.
name|version
operator|=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|offset_size
operator|==
literal|4
condition|)
name|lh
operator|.
name|prologue_length
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
else|else
name|lh
operator|.
name|prologue_length
operator|=
name|read_8_bytes
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|offset_size
expr_stmt|;
name|lh
operator|.
name|minimum_instruction_length
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|lh
operator|.
name|default_is_stmt
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|lh
operator|.
name|line_base
operator|=
name|read_1_signed_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|lh
operator|.
name|line_range
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|lh
operator|.
name|opcode_base
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|amt
operator|=
name|lh
operator|.
name|opcode_base
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
expr_stmt|;
name|lh
operator|.
name|standard_opcode_lengths
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|lh
operator|.
name|standard_opcode_lengths
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|lh
operator|.
name|opcode_base
condition|;
operator|++
name|i
control|)
block|{
name|lh
operator|.
name|standard_opcode_lengths
index|[
name|i
index|]
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Read directory table.  */
while|while
condition|(
operator|(
name|cur_dir
operator|=
name|read_string
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
operator|(
name|table
operator|->
name|num_dirs
operator|%
name|DIR_ALLOC_CHUNK
operator|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
modifier|*
name|tmp
decl_stmt|;
name|amt
operator|=
name|table
operator|->
name|num_dirs
operator|+
name|DIR_ALLOC_CHUNK
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|bfd_realloc
argument_list|(
name|table
operator|->
name|dirs
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|table
operator|->
name|dirs
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|table
operator|->
name|dirs
operator|=
name|tmp
expr_stmt|;
block|}
name|table
operator|->
name|dirs
index|[
name|table
operator|->
name|num_dirs
operator|++
index|]
operator|=
name|cur_dir
expr_stmt|;
block|}
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
comment|/* Read file name table.  */
while|while
condition|(
operator|(
name|cur_file
operator|=
name|read_string
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
operator|(
name|table
operator|->
name|num_files
operator|%
name|FILE_ALLOC_CHUNK
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|fileinfo
modifier|*
name|tmp
decl_stmt|;
name|amt
operator|=
name|table
operator|->
name|num_files
operator|+
name|FILE_ALLOC_CHUNK
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|fileinfo
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|bfd_realloc
argument_list|(
name|table
operator|->
name|files
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|table
operator|->
name|files
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|table
operator|->
name|dirs
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|table
operator|->
name|files
operator|=
name|tmp
expr_stmt|;
block|}
name|table
operator|->
name|files
index|[
name|table
operator|->
name|num_files
index|]
operator|.
name|name
operator|=
name|cur_file
expr_stmt|;
name|table
operator|->
name|files
index|[
name|table
operator|->
name|num_files
index|]
operator|.
name|dir
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|table
operator|->
name|files
index|[
name|table
operator|->
name|num_files
index|]
operator|.
name|time
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|table
operator|->
name|files
index|[
name|table
operator|->
name|num_files
index|]
operator|.
name|size
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|table
operator|->
name|num_files
operator|++
expr_stmt|;
block|}
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
comment|/* Read the statement sequences until there's nothing left.  */
while|while
condition|(
name|line_ptr
operator|<
name|line_end
condition|)
block|{
comment|/* State machine registers.  */
name|bfd_vma
name|address
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|filename
init|=
name|table
operator|->
name|num_files
condition|?
name|concat_filename
argument_list|(
name|table
argument_list|,
literal|1
argument_list|)
else|:
name|NULL
decl_stmt|;
name|unsigned
name|int
name|line
init|=
literal|1
decl_stmt|;
name|unsigned
name|int
name|column
init|=
literal|0
decl_stmt|;
name|int
name|is_stmt
init|=
name|lh
operator|.
name|default_is_stmt
decl_stmt|;
name|int
name|end_sequence
init|=
literal|0
decl_stmt|;
comment|/* eraxxon@alumni.rice.edu: Against the DWARF2 specs, some 	 compilers generate address sequences that are wildly out of 	 order using DW_LNE_set_address (e.g. Intel C++ 6.0 compiler 	 for ia64-Linux).  Thus, to determine the low and high 	 address, we must compare on every DW_LNS_copy, etc.  */
name|bfd_vma
name|low_pc
init|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
decl_stmt|;
name|bfd_vma
name|high_pc
init|=
literal|0
decl_stmt|;
comment|/* Decode the table.  */
while|while
condition|(
operator|!
name|end_sequence
condition|)
block|{
name|op_code
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|op_code
operator|>=
name|lh
operator|.
name|opcode_base
condition|)
block|{
comment|/* Special operand.  */
name|adj_opcode
operator|=
name|op_code
operator|-
name|lh
operator|.
name|opcode_base
expr_stmt|;
name|address
operator|+=
operator|(
name|adj_opcode
operator|/
name|lh
operator|.
name|line_range
operator|)
operator|*
name|lh
operator|.
name|minimum_instruction_length
expr_stmt|;
name|line
operator|+=
name|lh
operator|.
name|line_base
operator|+
operator|(
name|adj_opcode
operator|%
name|lh
operator|.
name|line_range
operator|)
expr_stmt|;
comment|/* Append row to matrix using current values.  */
name|add_line_info
argument_list|(
name|table
argument_list|,
name|address
argument_list|,
name|filename
argument_list|,
name|line
argument_list|,
name|column
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|address
operator|<
name|low_pc
condition|)
name|low_pc
operator|=
name|address
expr_stmt|;
if|if
condition|(
name|address
operator|>
name|high_pc
condition|)
name|high_pc
operator|=
name|address
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|op_code
condition|)
block|{
case|case
name|DW_LNS_extended_op
case|:
comment|/* Ignore length.  */
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|extended_op
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
switch|switch
condition|(
name|extended_op
condition|)
block|{
case|case
name|DW_LNE_end_sequence
case|:
name|end_sequence
operator|=
literal|1
expr_stmt|;
name|add_line_info
argument_list|(
name|table
argument_list|,
name|address
argument_list|,
name|filename
argument_list|,
name|line
argument_list|,
name|column
argument_list|,
name|end_sequence
argument_list|)
expr_stmt|;
if|if
condition|(
name|address
operator|<
name|low_pc
condition|)
name|low_pc
operator|=
name|address
expr_stmt|;
if|if
condition|(
name|address
operator|>
name|high_pc
condition|)
name|high_pc
operator|=
name|address
expr_stmt|;
name|arange_add
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
operator|&
name|unit
operator|->
name|arange
argument_list|,
name|low_pc
argument_list|,
name|high_pc
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNE_set_address
case|:
name|address
operator|=
name|read_address
argument_list|(
name|unit
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|unit
operator|->
name|addr_size
expr_stmt|;
break|break;
case|case
name|DW_LNE_define_file
case|:
name|cur_file
operator|=
name|read_string
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
operator|(
name|table
operator|->
name|num_files
operator|%
name|FILE_ALLOC_CHUNK
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|fileinfo
modifier|*
name|tmp
decl_stmt|;
name|amt
operator|=
name|table
operator|->
name|num_files
operator|+
name|FILE_ALLOC_CHUNK
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|fileinfo
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|bfd_realloc
argument_list|(
name|table
operator|->
name|files
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|table
operator|->
name|files
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|table
operator|->
name|dirs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|table
operator|->
name|files
operator|=
name|tmp
expr_stmt|;
block|}
name|table
operator|->
name|files
index|[
name|table
operator|->
name|num_files
index|]
operator|.
name|name
operator|=
name|cur_file
expr_stmt|;
name|table
operator|->
name|files
index|[
name|table
operator|->
name|num_files
index|]
operator|.
name|dir
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|table
operator|->
name|files
index|[
name|table
operator|->
name|num_files
index|]
operator|.
name|time
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|table
operator|->
name|files
index|[
name|table
operator|->
name|num_files
index|]
operator|.
name|size
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|table
operator|->
name|num_files
operator|++
expr_stmt|;
break|break;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: mangled line number section."
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|table
operator|->
name|files
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|table
operator|->
name|dirs
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
break|break;
case|case
name|DW_LNS_copy
case|:
name|add_line_info
argument_list|(
name|table
argument_list|,
name|address
argument_list|,
name|filename
argument_list|,
name|line
argument_list|,
name|column
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|address
operator|<
name|low_pc
condition|)
name|low_pc
operator|=
name|address
expr_stmt|;
if|if
condition|(
name|address
operator|>
name|high_pc
condition|)
name|high_pc
operator|=
name|address
expr_stmt|;
break|break;
case|case
name|DW_LNS_advance_pc
case|:
name|address
operator|+=
name|lh
operator|.
name|minimum_instruction_length
operator|*
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_LNS_advance_line
case|:
name|line
operator|+=
name|read_signed_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_LNS_set_file
case|:
block|{
name|unsigned
name|int
name|file
decl_stmt|;
comment|/* The file and directory tables are 0 		   based, the references are 1 based.  */
name|file
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
name|filename
condition|)
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|filename
operator|=
name|concat_filename
argument_list|(
name|table
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DW_LNS_set_column
case|:
name|column
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_LNS_negate_stmt
case|:
name|is_stmt
operator|=
operator|(
operator|!
name|is_stmt
operator|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_set_basic_block
case|:
break|break;
case|case
name|DW_LNS_const_add_pc
case|:
name|address
operator|+=
name|lh
operator|.
name|minimum_instruction_length
operator|*
operator|(
operator|(
literal|255
operator|-
name|lh
operator|.
name|opcode_base
operator|)
operator|/
name|lh
operator|.
name|line_range
operator|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_fixed_advance_pc
case|:
name|address
operator|+=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
block|{
name|int
name|i
decl_stmt|;
comment|/* Unknown standard opcode, ignore it.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lh
operator|.
name|standard_opcode_lengths
index|[
name|op_code
index|]
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|filename
condition|)
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
return|return
name|table
return|;
block|}
end_function

begin_comment
comment|/* If ADDR is within TABLE set the output parameters and return TRUE,    otherwise return FALSE.  The output parameters, FILENAME_PTR and    LINENUMBER_PTR, are pointers to the objects to be filled in.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|lookup_address_in_line_info_table
parameter_list|(
name|struct
name|line_info_table
modifier|*
name|table
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
name|struct
name|funcinfo
modifier|*
name|function
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
parameter_list|,
name|unsigned
name|int
modifier|*
name|linenumber_ptr
parameter_list|)
block|{
comment|/* Note: table->last_line should be a descendingly sorted list. */
name|struct
name|line_info
modifier|*
name|next_line
init|=
name|table
operator|->
name|last_line
decl_stmt|;
name|struct
name|line_info
modifier|*
name|each_line
init|=
name|NULL
decl_stmt|;
operator|*
name|filename_ptr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|next_line
condition|)
return|return
name|FALSE
return|;
name|each_line
operator|=
name|next_line
operator|->
name|prev_line
expr_stmt|;
comment|/* Check for large addresses */
if|if
condition|(
name|addr
operator|>
name|next_line
operator|->
name|address
condition|)
name|each_line
operator|=
name|NULL
expr_stmt|;
comment|/* ensure we skip over the normal case */
comment|/* Normal case: search the list; save  */
while|while
condition|(
name|each_line
operator|&&
name|next_line
condition|)
block|{
comment|/* If we have an address match, save this info.  This allows us 	 to return as good as results as possible for strange debugging 	 info.  */
name|bfd_boolean
name|addr_match
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|each_line
operator|->
name|address
operator|<=
name|addr
operator|&&
name|addr
operator|<
name|next_line
operator|->
name|address
condition|)
block|{
name|addr_match
operator|=
name|TRUE
expr_stmt|;
comment|/* If this line appears to span functions, and addr is in the 	     later function, return the first line of that function instead 	     of the last line of the earlier one.  This check is for GCC 	     2.95, which emits the first line number for a function late.  */
if|if
condition|(
name|function
operator|!=
name|NULL
condition|)
block|{
name|bfd_vma
name|lowest_pc
decl_stmt|;
name|struct
name|arange
modifier|*
name|arange
decl_stmt|;
comment|/* Find the lowest address in the function's range list */
name|lowest_pc
operator|=
name|function
operator|->
name|arange
operator|.
name|low
expr_stmt|;
for|for
control|(
name|arange
operator|=
operator|&
name|function
operator|->
name|arange
init|;
name|arange
condition|;
name|arange
operator|=
name|arange
operator|->
name|next
control|)
block|{
if|if
condition|(
name|function
operator|->
name|arange
operator|.
name|low
operator|<
name|lowest_pc
condition|)
name|lowest_pc
operator|=
name|function
operator|->
name|arange
operator|.
name|low
expr_stmt|;
block|}
comment|/* Check for spanning function and set outgoing line info */
if|if
condition|(
name|addr
operator|>=
name|lowest_pc
operator|&&
name|each_line
operator|->
name|address
operator|<
name|lowest_pc
operator|&&
name|next_line
operator|->
name|address
operator|>
name|lowest_pc
condition|)
block|{
operator|*
name|filename_ptr
operator|=
name|next_line
operator|->
name|filename
expr_stmt|;
operator|*
name|linenumber_ptr
operator|=
name|next_line
operator|->
name|line
expr_stmt|;
block|}
else|else
block|{
operator|*
name|filename_ptr
operator|=
name|each_line
operator|->
name|filename
expr_stmt|;
operator|*
name|linenumber_ptr
operator|=
name|each_line
operator|->
name|line
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|filename_ptr
operator|=
name|each_line
operator|->
name|filename
expr_stmt|;
operator|*
name|linenumber_ptr
operator|=
name|each_line
operator|->
name|line
expr_stmt|;
block|}
block|}
if|if
condition|(
name|addr_match
operator|&&
operator|!
name|each_line
operator|->
name|end_sequence
condition|)
return|return
name|TRUE
return|;
comment|/* we have definitely found what we want */
name|next_line
operator|=
name|each_line
expr_stmt|;
name|each_line
operator|=
name|each_line
operator|->
name|prev_line
expr_stmt|;
block|}
comment|/* At this point each_line is NULL but next_line is not.  If we found      a candidate end-of-sequence point in the loop above, we can return      that (compatibility with a bug in the Intel compiler); otherwise,      assuming that we found the containing function for this address in      this compilation unit, return the first line we have a number for      (compatibility with GCC 2.95).  */
if|if
condition|(
operator|*
name|filename_ptr
operator|==
name|NULL
operator|&&
name|function
operator|!=
name|NULL
condition|)
block|{
operator|*
name|filename_ptr
operator|=
name|next_line
operator|->
name|filename
expr_stmt|;
operator|*
name|linenumber_ptr
operator|=
name|next_line
operator|->
name|line
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Read in the .debug_ranges section for future reference */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|read_debug_ranges
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|)
block|{
name|struct
name|dwarf2_debug
modifier|*
name|stash
init|=
name|unit
operator|->
name|stash
decl_stmt|;
if|if
condition|(
operator|!
name|stash
operator|->
name|dwarf_ranges_buffer
condition|)
block|{
name|bfd
modifier|*
name|abfd
init|=
name|unit
operator|->
name|abfd
decl_stmt|;
name|asection
modifier|*
name|msec
decl_stmt|;
name|msec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".debug_ranges"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msec
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Can't find .debug_ranges section."
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|stash
operator|->
name|dwarf_ranges_size
operator|=
name|msec
operator|->
name|size
expr_stmt|;
name|stash
operator|->
name|dwarf_ranges_buffer
operator|=
name|bfd_simple_get_relocated_section_contents
argument_list|(
name|abfd
argument_list|,
name|msec
argument_list|,
name|NULL
argument_list|,
name|stash
operator|->
name|syms
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stash
operator|->
name|dwarf_ranges_buffer
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Function table functions.  */
end_comment

begin_comment
comment|/* If ADDR is within TABLE, set FUNCTIONNAME_PTR, and return TRUE.    Note that we need to find the function that has the smallest    range that contains ADDR, to handle inlined functions without    depending upon them being ordered in TABLE by increasing range. */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|lookup_address_in_function_table
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
name|struct
name|funcinfo
modifier|*
modifier|*
name|function_ptr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
parameter_list|)
block|{
name|struct
name|funcinfo
modifier|*
name|each_func
decl_stmt|;
name|struct
name|funcinfo
modifier|*
name|best_fit
init|=
name|NULL
decl_stmt|;
name|struct
name|arange
modifier|*
name|arange
decl_stmt|;
for|for
control|(
name|each_func
operator|=
name|unit
operator|->
name|function_table
init|;
name|each_func
condition|;
name|each_func
operator|=
name|each_func
operator|->
name|prev_func
control|)
block|{
for|for
control|(
name|arange
operator|=
operator|&
name|each_func
operator|->
name|arange
init|;
name|arange
condition|;
name|arange
operator|=
name|arange
operator|->
name|next
control|)
block|{
if|if
condition|(
name|addr
operator|>=
name|arange
operator|->
name|low
operator|&&
name|addr
operator|<
name|arange
operator|->
name|high
condition|)
block|{
if|if
condition|(
operator|!
name|best_fit
operator|||
operator|(
operator|(
name|arange
operator|->
name|high
operator|-
name|arange
operator|->
name|low
operator|)
operator|<
operator|(
name|best_fit
operator|->
name|arange
operator|.
name|high
operator|-
name|best_fit
operator|->
name|arange
operator|.
name|low
operator|)
operator|)
condition|)
name|best_fit
operator|=
name|each_func
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|best_fit
condition|)
block|{
operator|*
name|functionname_ptr
operator|=
name|best_fit
operator|->
name|name
expr_stmt|;
operator|*
name|function_ptr
operator|=
name|best_fit
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/* If SYM at ADDR is within function table of UNIT, set FILENAME_PTR    and LINENUMBER_PTR, and return TRUE.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|lookup_symbol_in_function_table
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|asymbol
modifier|*
name|sym
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
parameter_list|,
name|unsigned
name|int
modifier|*
name|linenumber_ptr
parameter_list|)
block|{
name|struct
name|funcinfo
modifier|*
name|each_func
decl_stmt|;
name|struct
name|funcinfo
modifier|*
name|best_fit
init|=
name|NULL
decl_stmt|;
name|struct
name|arange
modifier|*
name|arange
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|sec
init|=
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
decl_stmt|;
for|for
control|(
name|each_func
operator|=
name|unit
operator|->
name|function_table
init|;
name|each_func
condition|;
name|each_func
operator|=
name|each_func
operator|->
name|prev_func
control|)
block|{
for|for
control|(
name|arange
operator|=
operator|&
name|each_func
operator|->
name|arange
init|;
name|arange
condition|;
name|arange
operator|=
name|arange
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
operator|!
name|each_func
operator|->
name|sec
operator|||
name|each_func
operator|->
name|sec
operator|==
name|sec
operator|)
operator|&&
name|addr
operator|>=
name|arange
operator|->
name|low
operator|&&
name|addr
operator|<
name|arange
operator|->
name|high
operator|&&
name|each_func
operator|->
name|name
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|each_func
operator|->
name|name
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|best_fit
operator|||
operator|(
operator|(
name|arange
operator|->
name|high
operator|-
name|arange
operator|->
name|low
operator|)
operator|<
operator|(
name|best_fit
operator|->
name|arange
operator|.
name|high
operator|-
name|best_fit
operator|->
name|arange
operator|.
name|low
operator|)
operator|)
operator|)
condition|)
name|best_fit
operator|=
name|each_func
expr_stmt|;
block|}
block|}
if|if
condition|(
name|best_fit
condition|)
block|{
name|best_fit
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
operator|*
name|filename_ptr
operator|=
name|best_fit
operator|->
name|file
expr_stmt|;
operator|*
name|linenumber_ptr
operator|=
name|best_fit
operator|->
name|line
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Variable table functions.  */
end_comment

begin_comment
comment|/* If SYM is within variable table of UNIT, set FILENAME_PTR and    LINENUMBER_PTR, and return TRUE.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|lookup_symbol_in_variable_table
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|asymbol
modifier|*
name|sym
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
parameter_list|,
name|unsigned
name|int
modifier|*
name|linenumber_ptr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|bfd_asymbol_name
argument_list|(
name|sym
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|sec
init|=
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
decl_stmt|;
name|struct
name|varinfo
modifier|*
name|each
decl_stmt|;
for|for
control|(
name|each
operator|=
name|unit
operator|->
name|variable_table
init|;
name|each
condition|;
name|each
operator|=
name|each
operator|->
name|prev_var
control|)
if|if
condition|(
name|each
operator|->
name|stack
operator|==
literal|0
operator|&&
name|each
operator|->
name|file
operator|!=
name|NULL
operator|&&
name|each
operator|->
name|name
operator|!=
name|NULL
operator|&&
name|each
operator|->
name|addr
operator|==
name|addr
operator|&&
operator|(
operator|!
name|each
operator|->
name|sec
operator|||
name|each
operator|->
name|sec
operator|==
name|sec
operator|)
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|each
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|each
condition|)
block|{
name|each
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
operator|*
name|filename_ptr
operator|=
name|each
operator|->
name|file
expr_stmt|;
operator|*
name|linenumber_ptr
operator|=
name|each
operator|->
name|line
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|find_abstract_instance_name
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|bfd_uint64_t
name|die_ref
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
init|=
name|unit
operator|->
name|abfd
decl_stmt|;
name|bfd_byte
modifier|*
name|info_ptr
decl_stmt|;
name|unsigned
name|int
name|abbrev_number
decl_stmt|,
name|bytes_read
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
name|abbrev
decl_stmt|;
name|struct
name|attribute
name|attr
decl_stmt|;
name|char
modifier|*
name|name
init|=
literal|0
decl_stmt|;
name|info_ptr
operator|=
name|unit
operator|->
name|info_ptr_unit
operator|+
name|die_ref
expr_stmt|;
name|abbrev_number
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
name|abbrev_number
condition|)
block|{
name|abbrev
operator|=
name|lookup_abbrev
argument_list|(
name|abbrev_number
argument_list|,
name|unit
operator|->
name|abbrevs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abbrev
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Could not find abbrev number %u."
argument_list|)
argument_list|,
name|abbrev_number
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abbrev
operator|->
name|num_attrs
condition|;
operator|++
name|i
control|)
block|{
name|info_ptr
operator|=
name|read_attribute
argument_list|(
operator|&
name|attr
argument_list|,
operator|&
name|abbrev
operator|->
name|attrs
index|[
name|i
index|]
argument_list|,
name|unit
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|attr
operator|.
name|name
condition|)
block|{
case|case
name|DW_AT_name
case|:
comment|/* Prefer DW_AT_MIPS_linkage_name over DW_AT_name.  */
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|attr
operator|.
name|u
operator|.
name|str
expr_stmt|;
break|break;
case|case
name|DW_AT_specification
case|:
name|name
operator|=
name|find_abstract_instance_name
argument_list|(
name|unit
argument_list|,
name|attr
operator|.
name|u
operator|.
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_MIPS_linkage_name
case|:
name|name
operator|=
name|attr
operator|.
name|u
operator|.
name|str
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
block|}
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_rangelist
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|struct
name|arange
modifier|*
name|arange
parameter_list|,
name|bfd_uint64_t
name|offset
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|ranges_ptr
decl_stmt|;
name|bfd_vma
name|base_address
init|=
name|unit
operator|->
name|base_address
decl_stmt|;
if|if
condition|(
operator|!
name|unit
operator|->
name|stash
operator|->
name|dwarf_ranges_buffer
condition|)
block|{
if|if
condition|(
operator|!
name|read_debug_ranges
argument_list|(
name|unit
argument_list|)
condition|)
return|return;
block|}
name|ranges_ptr
operator|=
name|unit
operator|->
name|stash
operator|->
name|dwarf_ranges_buffer
operator|+
name|offset
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bfd_vma
name|low_pc
decl_stmt|;
name|bfd_vma
name|high_pc
decl_stmt|;
if|if
condition|(
name|unit
operator|->
name|addr_size
operator|==
literal|4
condition|)
block|{
name|low_pc
operator|=
name|read_4_bytes
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|ranges_ptr
argument_list|)
expr_stmt|;
name|ranges_ptr
operator|+=
literal|4
expr_stmt|;
name|high_pc
operator|=
name|read_4_bytes
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|ranges_ptr
argument_list|)
expr_stmt|;
name|ranges_ptr
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|low_pc
operator|=
name|read_8_bytes
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|ranges_ptr
argument_list|)
expr_stmt|;
name|ranges_ptr
operator|+=
literal|8
expr_stmt|;
name|high_pc
operator|=
name|read_8_bytes
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|ranges_ptr
argument_list|)
expr_stmt|;
name|ranges_ptr
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|low_pc
operator|==
literal|0
operator|&&
name|high_pc
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|low_pc
operator|==
operator|-
literal|1UL
operator|&&
name|high_pc
operator|!=
operator|-
literal|1UL
condition|)
name|base_address
operator|=
name|high_pc
expr_stmt|;
else|else
name|arange_add
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
name|arange
argument_list|,
name|base_address
operator|+
name|low_pc
argument_list|,
name|base_address
operator|+
name|high_pc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* DWARF2 Compilation unit functions.  */
end_comment

begin_comment
comment|/* Scan over each die in a comp. unit looking for functions to add    to the function table and variables to the variable table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|scan_unit_for_symbols
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
init|=
name|unit
operator|->
name|abfd
decl_stmt|;
name|bfd_byte
modifier|*
name|info_ptr
init|=
name|unit
operator|->
name|first_child_die_ptr
decl_stmt|;
name|int
name|nesting_level
init|=
literal|1
decl_stmt|;
name|struct
name|funcinfo
modifier|*
modifier|*
name|nested_funcs
decl_stmt|;
name|int
name|nested_funcs_size
decl_stmt|;
comment|/* Maintain a stack of in-scope functions and inlined functions, which we      can use to set the caller_func field.  */
name|nested_funcs_size
operator|=
literal|32
expr_stmt|;
name|nested_funcs
operator|=
name|bfd_malloc
argument_list|(
name|nested_funcs_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|funcinfo
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nested_funcs
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|nested_funcs
index|[
name|nesting_level
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nesting_level
condition|)
block|{
name|unsigned
name|int
name|abbrev_number
decl_stmt|,
name|bytes_read
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
name|abbrev
decl_stmt|;
name|struct
name|attribute
name|attr
decl_stmt|;
name|struct
name|funcinfo
modifier|*
name|func
decl_stmt|;
name|struct
name|varinfo
modifier|*
name|var
decl_stmt|;
name|bfd_vma
name|low_pc
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|high_pc
init|=
literal|0
decl_stmt|;
name|abbrev_number
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
operator|!
name|abbrev_number
condition|)
block|{
name|nesting_level
operator|--
expr_stmt|;
continue|continue;
block|}
name|abbrev
operator|=
name|lookup_abbrev
argument_list|(
name|abbrev_number
argument_list|,
name|unit
operator|->
name|abbrevs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abbrev
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Could not find abbrev number %u."
argument_list|)
argument_list|,
name|abbrev_number
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nested_funcs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|var
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|abbrev
operator|->
name|tag
operator|==
name|DW_TAG_subprogram
operator|||
name|abbrev
operator|->
name|tag
operator|==
name|DW_TAG_entry_point
operator|||
name|abbrev
operator|->
name|tag
operator|==
name|DW_TAG_inlined_subroutine
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|funcinfo
argument_list|)
decl_stmt|;
name|func
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|func
operator|->
name|tag
operator|=
name|abbrev
operator|->
name|tag
expr_stmt|;
name|func
operator|->
name|prev_func
operator|=
name|unit
operator|->
name|function_table
expr_stmt|;
name|unit
operator|->
name|function_table
operator|=
name|func
expr_stmt|;
if|if
condition|(
name|func
operator|->
name|tag
operator|==
name|DW_TAG_inlined_subroutine
condition|)
for|for
control|(
name|i
operator|=
name|nesting_level
operator|-
literal|1
init|;
name|i
operator|>=
literal|1
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|nested_funcs
index|[
name|i
index|]
condition|)
block|{
name|func
operator|->
name|caller_func
operator|=
name|nested_funcs
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
name|nested_funcs
index|[
name|nesting_level
index|]
operator|=
name|func
expr_stmt|;
block|}
else|else
block|{
name|func
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|abbrev
operator|->
name|tag
operator|==
name|DW_TAG_variable
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|varinfo
argument_list|)
decl_stmt|;
name|var
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|var
operator|->
name|tag
operator|=
name|abbrev
operator|->
name|tag
expr_stmt|;
name|var
operator|->
name|stack
operator|=
literal|1
expr_stmt|;
name|var
operator|->
name|prev_var
operator|=
name|unit
operator|->
name|variable_table
expr_stmt|;
name|unit
operator|->
name|variable_table
operator|=
name|var
expr_stmt|;
block|}
comment|/* No inline function in scope at this nesting level.  */
name|nested_funcs
index|[
name|nesting_level
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abbrev
operator|->
name|num_attrs
condition|;
operator|++
name|i
control|)
block|{
name|info_ptr
operator|=
name|read_attribute
argument_list|(
operator|&
name|attr
argument_list|,
operator|&
name|abbrev
operator|->
name|attrs
index|[
name|i
index|]
argument_list|,
name|unit
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
condition|)
block|{
switch|switch
condition|(
name|attr
operator|.
name|name
condition|)
block|{
case|case
name|DW_AT_call_file
case|:
name|func
operator|->
name|caller_file
operator|=
name|concat_filename
argument_list|(
name|unit
operator|->
name|line_table
argument_list|,
name|attr
operator|.
name|u
operator|.
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_call_line
case|:
name|func
operator|->
name|caller_line
operator|=
name|attr
operator|.
name|u
operator|.
name|val
expr_stmt|;
break|break;
case|case
name|DW_AT_abstract_origin
case|:
name|func
operator|->
name|name
operator|=
name|find_abstract_instance_name
argument_list|(
name|unit
argument_list|,
name|attr
operator|.
name|u
operator|.
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_name
case|:
comment|/* Prefer DW_AT_MIPS_linkage_name over DW_AT_name.  */
if|if
condition|(
name|func
operator|->
name|name
operator|==
name|NULL
condition|)
name|func
operator|->
name|name
operator|=
name|attr
operator|.
name|u
operator|.
name|str
expr_stmt|;
break|break;
case|case
name|DW_AT_MIPS_linkage_name
case|:
name|func
operator|->
name|name
operator|=
name|attr
operator|.
name|u
operator|.
name|str
expr_stmt|;
break|break;
case|case
name|DW_AT_low_pc
case|:
name|low_pc
operator|=
name|attr
operator|.
name|u
operator|.
name|val
expr_stmt|;
break|break;
case|case
name|DW_AT_high_pc
case|:
name|high_pc
operator|=
name|attr
operator|.
name|u
operator|.
name|val
expr_stmt|;
break|break;
case|case
name|DW_AT_ranges
case|:
name|read_rangelist
argument_list|(
name|unit
argument_list|,
operator|&
name|func
operator|->
name|arange
argument_list|,
name|attr
operator|.
name|u
operator|.
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_decl_file
case|:
name|func
operator|->
name|file
operator|=
name|concat_filename
argument_list|(
name|unit
operator|->
name|line_table
argument_list|,
name|attr
operator|.
name|u
operator|.
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_decl_line
case|:
name|func
operator|->
name|line
operator|=
name|attr
operator|.
name|u
operator|.
name|val
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|var
condition|)
block|{
switch|switch
condition|(
name|attr
operator|.
name|name
condition|)
block|{
case|case
name|DW_AT_name
case|:
name|var
operator|->
name|name
operator|=
name|attr
operator|.
name|u
operator|.
name|str
expr_stmt|;
break|break;
case|case
name|DW_AT_decl_file
case|:
name|var
operator|->
name|file
operator|=
name|concat_filename
argument_list|(
name|unit
operator|->
name|line_table
argument_list|,
name|attr
operator|.
name|u
operator|.
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_decl_line
case|:
name|var
operator|->
name|line
operator|=
name|attr
operator|.
name|u
operator|.
name|val
expr_stmt|;
break|break;
case|case
name|DW_AT_external
case|:
if|if
condition|(
name|attr
operator|.
name|u
operator|.
name|val
operator|!=
literal|0
condition|)
name|var
operator|->
name|stack
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DW_AT_location
case|:
switch|switch
condition|(
name|attr
operator|.
name|form
condition|)
block|{
case|case
name|DW_FORM_block
case|:
case|case
name|DW_FORM_block1
case|:
case|case
name|DW_FORM_block2
case|:
case|case
name|DW_FORM_block4
case|:
if|if
condition|(
operator|*
name|attr
operator|.
name|u
operator|.
name|blk
operator|->
name|data
operator|==
name|DW_OP_addr
condition|)
block|{
name|var
operator|->
name|stack
operator|=
literal|0
expr_stmt|;
comment|/* Verify that DW_OP_addr is the only opcode in the 			     location, in which case the block size will be 1 			     plus the address size.  */
comment|/* ??? For TLS variables, gcc can emit 			     DW_OP_addr<addr> DW_OP_GNU_push_tls_address 			     which we don't handle here yet.  */
if|if
condition|(
name|attr
operator|.
name|u
operator|.
name|blk
operator|->
name|size
operator|==
name|unit
operator|->
name|addr_size
operator|+
literal|1U
condition|)
name|var
operator|->
name|addr
operator|=
name|bfd_get
argument_list|(
name|unit
operator|->
name|addr_size
operator|*
literal|8
argument_list|,
name|unit
operator|->
name|abfd
argument_list|,
name|attr
operator|.
name|u
operator|.
name|blk
operator|->
name|data
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
if|if
condition|(
name|func
operator|&&
name|high_pc
operator|!=
literal|0
condition|)
block|{
name|arange_add
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
operator|&
name|func
operator|->
name|arange
argument_list|,
name|low_pc
argument_list|,
name|high_pc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|abbrev
operator|->
name|has_children
condition|)
block|{
name|nesting_level
operator|++
expr_stmt|;
if|if
condition|(
name|nesting_level
operator|>=
name|nested_funcs_size
condition|)
block|{
name|struct
name|funcinfo
modifier|*
modifier|*
name|tmp
decl_stmt|;
name|nested_funcs_size
operator|*=
literal|2
expr_stmt|;
name|tmp
operator|=
name|bfd_realloc
argument_list|(
name|nested_funcs
argument_list|,
operator|(
name|nested_funcs_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|funcinfo
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|nested_funcs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|nested_funcs
operator|=
name|tmp
expr_stmt|;
block|}
name|nested_funcs
index|[
name|nesting_level
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|nested_funcs
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Parse a DWARF2 compilation unit starting at INFO_PTR.  This    includes the compilation unit header that proceeds the DIE's, but    does not include the length field that precedes each compilation    unit header.  END_PTR points one past the end of this comp unit.    OFFSET_SIZE is the size of DWARF2 offsets (either 4 or 8 bytes).     This routine does not read the whole compilation unit; only enough    to get to the line number information for the compilation unit.  */
end_comment

begin_function
specifier|static
name|struct
name|comp_unit
modifier|*
name|parse_comp_unit
parameter_list|(
name|struct
name|dwarf2_debug
modifier|*
name|stash
parameter_list|,
name|bfd_vma
name|unit_length
parameter_list|,
name|bfd_byte
modifier|*
name|info_ptr_unit
parameter_list|,
name|unsigned
name|int
name|offset_size
parameter_list|)
block|{
name|struct
name|comp_unit
modifier|*
name|unit
decl_stmt|;
name|unsigned
name|int
name|version
decl_stmt|;
name|bfd_uint64_t
name|abbrev_offset
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|addr_size
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
modifier|*
name|abbrevs
decl_stmt|;
name|unsigned
name|int
name|abbrev_number
decl_stmt|,
name|bytes_read
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
name|abbrev
decl_stmt|;
name|struct
name|attribute
name|attr
decl_stmt|;
name|bfd_byte
modifier|*
name|info_ptr
init|=
name|stash
operator|->
name|info_ptr
decl_stmt|;
name|bfd_byte
modifier|*
name|end_ptr
init|=
name|info_ptr
operator|+
name|unit_length
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|bfd_vma
name|low_pc
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|high_pc
init|=
literal|0
decl_stmt|;
name|bfd
modifier|*
name|abfd
init|=
name|stash
operator|->
name|bfd
decl_stmt|;
name|version
operator|=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|2
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|offset_size
operator|==
literal|4
operator|||
name|offset_size
operator|==
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset_size
operator|==
literal|4
condition|)
name|abbrev_offset
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
else|else
name|abbrev_offset
operator|=
name|read_8_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|offset_size
expr_stmt|;
name|addr_size
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|version
operator|!=
literal|2
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: found dwarf version '%u', this reader only handles version 2 information."
argument_list|)
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|addr_size
operator|>
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: found address size '%u', this reader can not handle sizes greater than '%u'."
argument_list|)
argument_list|,
name|addr_size
argument_list|,
operator|(
name|unsigned
name|int
operator|)
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|addr_size
operator|!=
literal|2
operator|&&
name|addr_size
operator|!=
literal|4
operator|&&
name|addr_size
operator|!=
literal|8
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"Dwarf Error: found address size '%u', this reader can only handle address sizes '2', '4' and '8'."
argument_list|,
name|addr_size
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Read the abbrevs for this compilation unit into a table.  */
name|abbrevs
operator|=
name|read_abbrevs
argument_list|(
name|abfd
argument_list|,
name|abbrev_offset
argument_list|,
name|stash
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abbrevs
condition|)
return|return
literal|0
return|;
name|abbrev_number
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
operator|!
name|abbrev_number
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Bad abbrev number: %u."
argument_list|)
argument_list|,
name|abbrev_number
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|abbrev
operator|=
name|lookup_abbrev
argument_list|(
name|abbrev_number
argument_list|,
name|abbrevs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abbrev
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Dwarf Error: Could not find abbrev number %u."
argument_list|)
argument_list|,
name|abbrev_number
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|comp_unit
argument_list|)
expr_stmt|;
name|unit
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
name|unit
operator|->
name|abfd
operator|=
name|abfd
expr_stmt|;
name|unit
operator|->
name|addr_size
operator|=
name|addr_size
expr_stmt|;
name|unit
operator|->
name|offset_size
operator|=
name|offset_size
expr_stmt|;
name|unit
operator|->
name|abbrevs
operator|=
name|abbrevs
expr_stmt|;
name|unit
operator|->
name|end_ptr
operator|=
name|end_ptr
expr_stmt|;
name|unit
operator|->
name|stash
operator|=
name|stash
expr_stmt|;
name|unit
operator|->
name|info_ptr_unit
operator|=
name|info_ptr_unit
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abbrev
operator|->
name|num_attrs
condition|;
operator|++
name|i
control|)
block|{
name|info_ptr
operator|=
name|read_attribute
argument_list|(
operator|&
name|attr
argument_list|,
operator|&
name|abbrev
operator|->
name|attrs
index|[
name|i
index|]
argument_list|,
name|unit
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
comment|/* Store the data if it is of an attribute we want to keep in a 	 partial symbol table.  */
switch|switch
condition|(
name|attr
operator|.
name|name
condition|)
block|{
case|case
name|DW_AT_stmt_list
case|:
name|unit
operator|->
name|stmtlist
operator|=
literal|1
expr_stmt|;
name|unit
operator|->
name|line_offset
operator|=
name|attr
operator|.
name|u
operator|.
name|val
expr_stmt|;
break|break;
case|case
name|DW_AT_name
case|:
name|unit
operator|->
name|name
operator|=
name|attr
operator|.
name|u
operator|.
name|str
expr_stmt|;
break|break;
case|case
name|DW_AT_low_pc
case|:
name|low_pc
operator|=
name|attr
operator|.
name|u
operator|.
name|val
expr_stmt|;
comment|/* If the compilation unit DIE has a DW_AT_low_pc attribute, 	     this is the base address to use when reading location 	     lists or range lists. */
name|unit
operator|->
name|base_address
operator|=
name|low_pc
expr_stmt|;
break|break;
case|case
name|DW_AT_high_pc
case|:
name|high_pc
operator|=
name|attr
operator|.
name|u
operator|.
name|val
expr_stmt|;
break|break;
case|case
name|DW_AT_ranges
case|:
name|read_rangelist
argument_list|(
name|unit
argument_list|,
operator|&
name|unit
operator|->
name|arange
argument_list|,
name|attr
operator|.
name|u
operator|.
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_comp_dir
case|:
block|{
name|char
modifier|*
name|comp_dir
init|=
name|attr
operator|.
name|u
operator|.
name|str
decl_stmt|;
if|if
condition|(
name|comp_dir
condition|)
block|{
comment|/* Irix 6.2 native cc prepends<machine>.: to the compilation 		   directory, get rid of it.  */
name|char
modifier|*
name|cp
init|=
name|strchr
argument_list|(
name|comp_dir
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
operator|&&
name|cp
operator|!=
name|comp_dir
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
name|comp_dir
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
name|unit
operator|->
name|comp_dir
operator|=
name|comp_dir
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|high_pc
operator|!=
literal|0
condition|)
block|{
name|arange_add
argument_list|(
name|unit
operator|->
name|abfd
argument_list|,
operator|&
name|unit
operator|->
name|arange
argument_list|,
name|low_pc
argument_list|,
name|high_pc
argument_list|)
expr_stmt|;
block|}
name|unit
operator|->
name|first_child_die_ptr
operator|=
name|info_ptr
expr_stmt|;
return|return
name|unit
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if UNIT may contain the address given by ADDR.  When    there are functions written entirely with inline asm statements, the    range info in the compilation unit header may not be correct.  We    need to consult the line info table to see if a compilation unit    really contains the given address.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|comp_unit_contains_address
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|bfd_vma
name|addr
parameter_list|)
block|{
name|struct
name|arange
modifier|*
name|arange
decl_stmt|;
if|if
condition|(
name|unit
operator|->
name|error
condition|)
return|return
name|FALSE
return|;
name|arange
operator|=
operator|&
name|unit
operator|->
name|arange
expr_stmt|;
do|do
block|{
if|if
condition|(
name|addr
operator|>=
name|arange
operator|->
name|low
operator|&&
name|addr
operator|<
name|arange
operator|->
name|high
condition|)
return|return
name|TRUE
return|;
name|arange
operator|=
name|arange
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|arange
condition|)
do|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* If UNIT contains ADDR, set the output parameters to the values for    the line containing ADDR.  The output parameters, FILENAME_PTR,    FUNCTIONNAME_PTR, and LINENUMBER_PTR, are pointers to the objects    to be filled in.     Return TRUE if UNIT contains ADDR, and no errors were encountered;    FALSE otherwise.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|comp_unit_find_nearest_line
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
parameter_list|,
name|unsigned
name|int
modifier|*
name|linenumber_ptr
parameter_list|,
name|struct
name|dwarf2_debug
modifier|*
name|stash
parameter_list|)
block|{
name|bfd_boolean
name|line_p
decl_stmt|;
name|bfd_boolean
name|func_p
decl_stmt|;
name|struct
name|funcinfo
modifier|*
name|function
decl_stmt|;
if|if
condition|(
name|unit
operator|->
name|error
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|unit
operator|->
name|line_table
condition|)
block|{
if|if
condition|(
operator|!
name|unit
operator|->
name|stmtlist
condition|)
block|{
name|unit
operator|->
name|error
operator|=
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|unit
operator|->
name|line_table
operator|=
name|decode_line_info
argument_list|(
name|unit
argument_list|,
name|stash
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unit
operator|->
name|line_table
condition|)
block|{
name|unit
operator|->
name|error
operator|=
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|unit
operator|->
name|first_child_die_ptr
operator|<
name|unit
operator|->
name|end_ptr
operator|&&
operator|!
name|scan_unit_for_symbols
argument_list|(
name|unit
argument_list|)
condition|)
block|{
name|unit
operator|->
name|error
operator|=
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|function
operator|=
name|NULL
expr_stmt|;
name|func_p
operator|=
name|lookup_address_in_function_table
argument_list|(
name|unit
argument_list|,
name|addr
argument_list|,
operator|&
name|function
argument_list|,
name|functionname_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|func_p
operator|&&
operator|(
name|function
operator|->
name|tag
operator|==
name|DW_TAG_inlined_subroutine
operator|)
condition|)
name|stash
operator|->
name|inliner_chain
operator|=
name|function
expr_stmt|;
name|line_p
operator|=
name|lookup_address_in_line_info_table
argument_list|(
name|unit
operator|->
name|line_table
argument_list|,
name|addr
argument_list|,
name|function
argument_list|,
name|filename_ptr
argument_list|,
name|linenumber_ptr
argument_list|)
expr_stmt|;
return|return
name|line_p
operator|||
name|func_p
return|;
block|}
end_function

begin_comment
comment|/* If UNIT contains SYM at ADDR, set the output parameters to the    values for the line containing SYM.  The output parameters,    FILENAME_PTR, and LINENUMBER_PTR, are pointers to the objects to be    filled in.     Return TRUE if UNIT contains SYM, and no errors were encountered;    FALSE otherwise.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|comp_unit_find_line
parameter_list|(
name|struct
name|comp_unit
modifier|*
name|unit
parameter_list|,
name|asymbol
modifier|*
name|sym
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
parameter_list|,
name|unsigned
name|int
modifier|*
name|linenumber_ptr
parameter_list|,
name|struct
name|dwarf2_debug
modifier|*
name|stash
parameter_list|)
block|{
if|if
condition|(
name|unit
operator|->
name|error
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|unit
operator|->
name|line_table
condition|)
block|{
if|if
condition|(
operator|!
name|unit
operator|->
name|stmtlist
condition|)
block|{
name|unit
operator|->
name|error
operator|=
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|unit
operator|->
name|line_table
operator|=
name|decode_line_info
argument_list|(
name|unit
argument_list|,
name|stash
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unit
operator|->
name|line_table
condition|)
block|{
name|unit
operator|->
name|error
operator|=
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|unit
operator|->
name|first_child_die_ptr
operator|<
name|unit
operator|->
name|end_ptr
operator|&&
operator|!
name|scan_unit_for_symbols
argument_list|(
name|unit
argument_list|)
condition|)
block|{
name|unit
operator|->
name|error
operator|=
literal|1
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|sym
operator|->
name|flags
operator|&
name|BSF_FUNCTION
condition|)
return|return
name|lookup_symbol_in_function_table
argument_list|(
name|unit
argument_list|,
name|sym
argument_list|,
name|addr
argument_list|,
name|filename_ptr
argument_list|,
name|linenumber_ptr
argument_list|)
return|;
else|else
return|return
name|lookup_symbol_in_variable_table
argument_list|(
name|unit
argument_list|,
name|sym
argument_list|,
name|addr
argument_list|,
name|filename_ptr
argument_list|,
name|linenumber_ptr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Locate a section in a BFD containing debugging info.  The search starts    from the section after AFTER_SEC, or from the first section in the BFD if    AFTER_SEC is NULL.  The search works by examining the names of the    sections.  There are two permissiable names.  The first is .debug_info.    This is the standard DWARF2 name.  The second is a prefix .gnu.linkonce.wi.    This is a variation on the .debug_info section which has a checksum    describing the contents appended onto the name.  This allows the linker to    identify and discard duplicate debugging sections for different    compilation units.  */
end_comment

begin_define
define|#
directive|define
name|DWARF2_DEBUG_INFO
value|".debug_info"
end_define

begin_define
define|#
directive|define
name|GNU_LINKONCE_INFO
value|".gnu.linkonce.wi."
end_define

begin_function
specifier|static
name|asection
modifier|*
name|find_debug_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|after_sec
parameter_list|)
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
name|msec
operator|=
name|after_sec
operator|!=
name|NULL
condition|?
name|after_sec
operator|->
name|next
else|:
name|abfd
operator|->
name|sections
expr_stmt|;
while|while
condition|(
name|msec
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|msec
operator|->
name|name
argument_list|,
name|DWARF2_DEBUG_INFO
argument_list|)
operator|==
literal|0
condition|)
return|return
name|msec
return|;
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|msec
operator|->
name|name
argument_list|,
name|GNU_LINKONCE_INFO
argument_list|)
condition|)
return|return
name|msec
return|;
name|msec
operator|=
name|msec
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Unset vmas for loadable sections in STASH.  */
end_comment

begin_function
specifier|static
name|void
name|unset_sections
parameter_list|(
name|struct
name|dwarf2_debug
modifier|*
name|stash
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|loadable_section
modifier|*
name|p
decl_stmt|;
name|i
operator|=
name|stash
operator|->
name|loadable_section_count
expr_stmt|;
name|p
operator|=
name|stash
operator|->
name|loadable_sections
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|p
operator|++
control|)
name|p
operator|->
name|section
operator|->
name|vma
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set unique vmas for loadable sections in ABFD and save vmas in    STASH for unset_sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|place_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|dwarf2_debug
modifier|*
name|stash
parameter_list|)
block|{
name|struct
name|loadable_section
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|stash
operator|->
name|loadable_section_count
operator|!=
literal|0
condition|)
block|{
name|i
operator|=
name|stash
operator|->
name|loadable_section_count
expr_stmt|;
name|p
operator|=
name|stash
operator|->
name|loadable_sections
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|p
operator|++
control|)
name|p
operator|->
name|section
operator|->
name|vma
operator|=
name|p
operator|->
name|adj_vma
expr_stmt|;
block|}
else|else
block|{
name|asection
modifier|*
name|sect
decl_stmt|;
name|bfd_vma
name|last_vma
init|=
literal|0
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|struct
name|loadable_section
modifier|*
name|p
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sect
operator|=
name|abfd
operator|->
name|sections
init|;
name|sect
operator|!=
name|NULL
condition|;
name|sect
operator|=
name|sect
operator|->
name|next
control|)
block|{
name|bfd_size_type
name|sz
decl_stmt|;
if|if
condition|(
name|sect
operator|->
name|vma
operator|!=
literal|0
operator|||
operator|(
name|sect
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|sz
operator|=
name|sect
operator|->
name|rawsize
condition|?
name|sect
operator|->
name|rawsize
else|:
name|sect
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|sz
operator|==
literal|0
condition|)
continue|continue;
name|i
operator|++
expr_stmt|;
block|}
name|amt
operator|=
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|loadable_section
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|loadable_section
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|FALSE
return|;
name|stash
operator|->
name|loadable_sections
operator|=
name|p
expr_stmt|;
name|stash
operator|->
name|loadable_section_count
operator|=
name|i
expr_stmt|;
for|for
control|(
name|sect
operator|=
name|abfd
operator|->
name|sections
init|;
name|sect
operator|!=
name|NULL
condition|;
name|sect
operator|=
name|sect
operator|->
name|next
control|)
block|{
name|bfd_size_type
name|sz
decl_stmt|;
if|if
condition|(
name|sect
operator|->
name|vma
operator|!=
literal|0
operator|||
operator|(
name|sect
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|sz
operator|=
name|sect
operator|->
name|rawsize
condition|?
name|sect
operator|->
name|rawsize
else|:
name|sect
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|sz
operator|==
literal|0
condition|)
continue|continue;
name|p
operator|->
name|section
operator|=
name|sect
expr_stmt|;
if|if
condition|(
name|last_vma
operator|!=
literal|0
condition|)
block|{
comment|/* Align the new address to the current section 		 alignment.  */
name|last_vma
operator|=
operator|(
operator|(
name|last_vma
operator|+
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|<<
name|sect
operator|->
name|alignment_power
operator|)
operator|)
operator|&
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|<<
name|sect
operator|->
name|alignment_power
operator|)
operator|)
expr_stmt|;
name|sect
operator|->
name|vma
operator|=
name|last_vma
expr_stmt|;
block|}
name|p
operator|->
name|adj_vma
operator|=
name|sect
operator|->
name|vma
expr_stmt|;
name|last_vma
operator|+=
name|sect
operator|->
name|vma
operator|+
name|sz
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Find the source code location of SYMBOL.  If SYMBOL is NULL    then find the nearest source code location corresponding to    the address SECTION + OFFSET.    Returns TRUE if the line is found without error and fills in    FILENAME_PTR and LINENUMBER_PTR.  In the case where SYMBOL was    NULL the FUNCTIONNAME_PTR is also filled in.    SYMBOLS contains the symbol table for ABFD.    ADDR_SIZE is the number of bytes in the initial .debug_info length    field and in the abbreviation offset, or zero to indicate that the    default value should be used.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|find_line
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
parameter_list|,
name|unsigned
name|int
modifier|*
name|linenumber_ptr
parameter_list|,
name|unsigned
name|int
name|addr_size
parameter_list|,
name|void
modifier|*
modifier|*
name|pinfo
parameter_list|)
block|{
comment|/* Read each compilation unit from the section .debug_info, and check      to see if it contains the address we are searching for.  If yes,      lookup the address, and return the line number info.  If no, go      on to the next compilation unit.       We keep a list of all the previously read compilation units, and      a pointer to the next un-read compilation unit.  Check the      previously read units before reading more.  */
name|struct
name|dwarf2_debug
modifier|*
name|stash
decl_stmt|;
comment|/* What address are we looking for?  */
name|bfd_vma
name|addr
decl_stmt|;
name|struct
name|comp_unit
modifier|*
name|each
decl_stmt|;
name|bfd_vma
name|found
init|=
name|FALSE
decl_stmt|;
name|bfd_boolean
name|do_line
decl_stmt|;
name|stash
operator|=
operator|*
name|pinfo
expr_stmt|;
if|if
condition|(
operator|!
name|stash
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf2_debug
argument_list|)
decl_stmt|;
name|stash
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stash
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* In a relocatable file, 2 functions may have the same address.      We change the section vma so that they won't overlap.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|place_sections
argument_list|(
name|abfd
argument_list|,
name|stash
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|do_line
operator|=
operator|(
name|section
operator|==
name|NULL
operator|&&
name|offset
operator|==
literal|0
operator|&&
name|functionname_ptr
operator|==
name|NULL
operator|&&
name|symbol
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|do_line
condition|)
block|{
name|addr
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|section
operator|=
name|bfd_get_section
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|section
operator|!=
name|NULL
operator|&&
name|functionname_ptr
operator|!=
name|NULL
operator|&&
name|symbol
operator|==
name|NULL
condition|)
name|addr
operator|=
name|offset
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|output_section
condition|)
name|addr
operator|+=
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|section
operator|->
name|output_offset
expr_stmt|;
else|else
name|addr
operator|+=
name|section
operator|->
name|vma
expr_stmt|;
operator|*
name|filename_ptr
operator|=
name|NULL
expr_stmt|;
operator|*
name|functionname_ptr
operator|=
name|NULL
expr_stmt|;
operator|*
name|linenumber_ptr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pinfo
condition|)
block|{
name|bfd
modifier|*
name|debug_bfd
decl_stmt|;
name|bfd_size_type
name|total_size
decl_stmt|;
name|asection
modifier|*
name|msec
decl_stmt|;
operator|*
name|pinfo
operator|=
name|stash
expr_stmt|;
name|msec
operator|=
name|find_debug_info
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msec
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|debug_filename
init|=
name|bfd_follow_gnu_debuglink
argument_list|(
name|abfd
argument_list|,
name|DEBUGDIR
argument_list|)
decl_stmt|;
if|if
condition|(
name|debug_filename
operator|==
name|NULL
condition|)
comment|/* No dwarf2 info, and no gnu_debuglink to follow. 	       Note that at this point the stash has been allocated, but 	       contains zeros.  This lets future calls to this function 	       fail more quickly.  */
goto|goto
name|done
goto|;
if|if
condition|(
operator|(
name|debug_bfd
operator|=
name|bfd_openr
argument_list|(
name|debug_filename
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|!
name|bfd_check_format
argument_list|(
name|debug_bfd
argument_list|,
name|bfd_object
argument_list|)
operator|||
operator|(
name|msec
operator|=
name|find_debug_info
argument_list|(
name|debug_bfd
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|debug_bfd
condition|)
name|bfd_close
argument_list|(
name|debug_bfd
argument_list|)
expr_stmt|;
comment|/* FIXME: Should we report our failure to follow the debuglink ?  */
name|free
argument_list|(
name|debug_filename
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
else|else
name|debug_bfd
operator|=
name|abfd
expr_stmt|;
comment|/* There can be more than one DWARF2 info section in a BFD these days. 	 Read them all in and produce one large stash.  We do this in two 	 passes - in the first pass we just accumulate the section sizes. 	 In the second pass we read in the section's contents.  The allows 	 us to avoid reallocing the data as we add sections to the stash.  */
for|for
control|(
name|total_size
operator|=
literal|0
init|;
name|msec
condition|;
name|msec
operator|=
name|find_debug_info
argument_list|(
name|debug_bfd
argument_list|,
name|msec
argument_list|)
control|)
name|total_size
operator|+=
name|msec
operator|->
name|size
expr_stmt|;
name|stash
operator|->
name|info_ptr
operator|=
name|bfd_alloc
argument_list|(
name|debug_bfd
argument_list|,
name|total_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|stash
operator|->
name|info_ptr
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|stash
operator|->
name|info_ptr_end
operator|=
name|stash
operator|->
name|info_ptr
expr_stmt|;
for|for
control|(
name|msec
operator|=
name|find_debug_info
argument_list|(
name|debug_bfd
argument_list|,
name|NULL
argument_list|)
init|;
name|msec
condition|;
name|msec
operator|=
name|find_debug_info
argument_list|(
name|debug_bfd
argument_list|,
name|msec
argument_list|)
control|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_size_type
name|start
decl_stmt|;
name|size
operator|=
name|msec
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
continue|continue;
name|start
operator|=
name|stash
operator|->
name|info_ptr_end
operator|-
name|stash
operator|->
name|info_ptr
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_simple_get_relocated_section_contents
argument_list|(
name|debug_bfd
argument_list|,
name|msec
argument_list|,
name|stash
operator|->
name|info_ptr
operator|+
name|start
argument_list|,
name|symbols
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|stash
operator|->
name|info_ptr_end
operator|=
name|stash
operator|->
name|info_ptr
operator|+
name|start
operator|+
name|size
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|stash
operator|->
name|info_ptr_end
operator|==
name|stash
operator|->
name|info_ptr
operator|+
name|total_size
argument_list|)
expr_stmt|;
name|stash
operator|->
name|sec
operator|=
name|find_debug_info
argument_list|(
name|debug_bfd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|stash
operator|->
name|sec_info_ptr
operator|=
name|stash
operator|->
name|info_ptr
expr_stmt|;
name|stash
operator|->
name|syms
operator|=
name|symbols
expr_stmt|;
name|stash
operator|->
name|bfd
operator|=
name|debug_bfd
expr_stmt|;
block|}
comment|/* A null info_ptr indicates that there is no dwarf2 info      (or that an error occured while setting up the stash).  */
if|if
condition|(
operator|!
name|stash
operator|->
name|info_ptr
condition|)
goto|goto
name|done
goto|;
name|stash
operator|->
name|inliner_chain
operator|=
name|NULL
expr_stmt|;
comment|/* Check the previously read comp. units first.  */
for|for
control|(
name|each
operator|=
name|stash
operator|->
name|all_comp_units
init|;
name|each
condition|;
name|each
operator|=
name|each
operator|->
name|next_unit
control|)
block|{
if|if
condition|(
name|do_line
condition|)
name|found
operator|=
operator|(
operator|(
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_FUNCTION
operator|)
operator|==
literal|0
operator|||
name|comp_unit_contains_address
argument_list|(
name|each
argument_list|,
name|addr
argument_list|)
operator|)
operator|&&
name|comp_unit_find_line
argument_list|(
name|each
argument_list|,
name|symbol
argument_list|,
name|addr
argument_list|,
name|filename_ptr
argument_list|,
name|linenumber_ptr
argument_list|,
name|stash
argument_list|)
operator|)
expr_stmt|;
else|else
name|found
operator|=
operator|(
name|comp_unit_contains_address
argument_list|(
name|each
argument_list|,
name|addr
argument_list|)
operator|&&
name|comp_unit_find_nearest_line
argument_list|(
name|each
argument_list|,
name|addr
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|linenumber_ptr
argument_list|,
name|stash
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* The DWARF2 spec says that the initial length field, and the      offset of the abbreviation table, should both be 4-byte values.      However, some compilers do things differently.  */
if|if
condition|(
name|addr_size
operator|==
literal|0
condition|)
name|addr_size
operator|=
literal|4
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|addr_size
operator|==
literal|4
operator|||
name|addr_size
operator|==
literal|8
argument_list|)
expr_stmt|;
comment|/* Read each remaining comp. units checking each as they are read.  */
while|while
condition|(
name|stash
operator|->
name|info_ptr
operator|<
name|stash
operator|->
name|info_ptr_end
condition|)
block|{
name|bfd_vma
name|length
decl_stmt|;
name|unsigned
name|int
name|offset_size
init|=
name|addr_size
decl_stmt|;
name|bfd_byte
modifier|*
name|info_ptr_unit
init|=
name|stash
operator|->
name|info_ptr
decl_stmt|;
name|length
operator|=
name|read_4_bytes
argument_list|(
name|stash
operator|->
name|bfd
argument_list|,
name|stash
operator|->
name|info_ptr
argument_list|)
expr_stmt|;
comment|/* A 0xffffff length is the DWARF3 way of indicating 	 we use 64-bit offsets, instead of 32-bit offsets.  */
if|if
condition|(
name|length
operator|==
literal|0xffffffff
condition|)
block|{
name|offset_size
operator|=
literal|8
expr_stmt|;
name|length
operator|=
name|read_8_bytes
argument_list|(
name|stash
operator|->
name|bfd
argument_list|,
name|stash
operator|->
name|info_ptr
operator|+
literal|4
argument_list|)
expr_stmt|;
name|stash
operator|->
name|info_ptr
operator|+=
literal|12
expr_stmt|;
block|}
comment|/* A zero length is the IRIX way of indicating 64-bit offsets, 	 mostly because the 64-bit length will generally fit in 32 	 bits, and the endianness helps.  */
elseif|else
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|offset_size
operator|=
literal|8
expr_stmt|;
name|length
operator|=
name|read_4_bytes
argument_list|(
name|stash
operator|->
name|bfd
argument_list|,
name|stash
operator|->
name|info_ptr
operator|+
literal|4
argument_list|)
expr_stmt|;
name|stash
operator|->
name|info_ptr
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* In the absence of the hints above, we assume 32-bit DWARF2 	 offsets even for targets with 64-bit addresses, because: 	   a) most of the time these targets will not have generated 	      more than 2Gb of debug info and so will not need 64-bit 	      offsets, 	 and 	   b) if they do use 64-bit offsets but they are not using 	      the size hints that are tested for above then they are 	      not conforming to the DWARF3 standard anyway.  */
elseif|else
if|if
condition|(
name|addr_size
operator|==
literal|8
condition|)
block|{
name|offset_size
operator|=
literal|4
expr_stmt|;
name|stash
operator|->
name|info_ptr
operator|+=
literal|4
expr_stmt|;
block|}
else|else
name|stash
operator|->
name|info_ptr
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|each
operator|=
name|parse_comp_unit
argument_list|(
name|stash
argument_list|,
name|length
argument_list|,
name|info_ptr_unit
argument_list|,
name|offset_size
argument_list|)
expr_stmt|;
name|stash
operator|->
name|info_ptr
operator|+=
name|length
expr_stmt|;
if|if
condition|(
call|(
name|bfd_vma
call|)
argument_list|(
name|stash
operator|->
name|info_ptr
operator|-
name|stash
operator|->
name|sec_info_ptr
argument_list|)
operator|==
name|stash
operator|->
name|sec
operator|->
name|size
condition|)
block|{
name|stash
operator|->
name|sec
operator|=
name|find_debug_info
argument_list|(
name|stash
operator|->
name|bfd
argument_list|,
name|stash
operator|->
name|sec
argument_list|)
expr_stmt|;
name|stash
operator|->
name|sec_info_ptr
operator|=
name|stash
operator|->
name|info_ptr
expr_stmt|;
block|}
if|if
condition|(
name|each
condition|)
block|{
name|each
operator|->
name|next_unit
operator|=
name|stash
operator|->
name|all_comp_units
expr_stmt|;
name|stash
operator|->
name|all_comp_units
operator|=
name|each
expr_stmt|;
comment|/* DW_AT_low_pc and DW_AT_high_pc are optional for 		 compilation units.  If we don't have them (i.e., 		 unit->high == 0), we need to consult the line info 		 table to see if a compilation unit contains the given 		 address.  */
if|if
condition|(
name|do_line
condition|)
name|found
operator|=
operator|(
operator|(
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_FUNCTION
operator|)
operator|==
literal|0
operator|||
name|each
operator|->
name|arange
operator|.
name|high
operator|==
literal|0
operator|||
name|comp_unit_contains_address
argument_list|(
name|each
argument_list|,
name|addr
argument_list|)
operator|)
operator|&&
name|comp_unit_find_line
argument_list|(
name|each
argument_list|,
name|symbol
argument_list|,
name|addr
argument_list|,
name|filename_ptr
argument_list|,
name|linenumber_ptr
argument_list|,
name|stash
argument_list|)
operator|)
expr_stmt|;
else|else
name|found
operator|=
operator|(
operator|(
name|each
operator|->
name|arange
operator|.
name|high
operator|==
literal|0
operator|||
name|comp_unit_contains_address
argument_list|(
name|each
argument_list|,
name|addr
argument_list|)
operator|)
operator|&&
name|comp_unit_find_nearest_line
argument_list|(
name|each
argument_list|,
name|addr
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|linenumber_ptr
argument_list|,
name|stash
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
goto|goto
name|done
goto|;
block|}
block|}
block|}
name|done
label|:
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
operator|==
literal|0
condition|)
name|unset_sections
argument_list|(
name|stash
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/* The DWARF2 version of find_nearest_line.    Return TRUE if the line is found without error.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_dwarf2_find_nearest_line
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
parameter_list|,
name|unsigned
name|int
modifier|*
name|linenumber_ptr
parameter_list|,
name|unsigned
name|int
name|addr_size
parameter_list|,
name|void
modifier|*
modifier|*
name|pinfo
parameter_list|)
block|{
return|return
name|find_line
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|offset
argument_list|,
name|NULL
argument_list|,
name|symbols
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|linenumber_ptr
argument_list|,
name|addr_size
argument_list|,
name|pinfo
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The DWARF2 version of find_line.    Return TRUE if the line is found without error.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_dwarf2_find_line
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
parameter_list|,
name|unsigned
name|int
modifier|*
name|linenumber_ptr
parameter_list|,
name|unsigned
name|int
name|addr_size
parameter_list|,
name|void
modifier|*
modifier|*
name|pinfo
parameter_list|)
block|{
return|return
name|find_line
argument_list|(
name|abfd
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|symbol
argument_list|,
name|symbols
argument_list|,
name|filename_ptr
argument_list|,
name|NULL
argument_list|,
name|linenumber_ptr
argument_list|,
name|addr_size
argument_list|,
name|pinfo
argument_list|)
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_dwarf2_find_inliner_info
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|filename_ptr
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|functionname_ptr
parameter_list|,
name|unsigned
name|int
modifier|*
name|linenumber_ptr
parameter_list|,
name|void
modifier|*
modifier|*
name|pinfo
parameter_list|)
block|{
name|struct
name|dwarf2_debug
modifier|*
name|stash
decl_stmt|;
name|stash
operator|=
operator|*
name|pinfo
expr_stmt|;
if|if
condition|(
name|stash
condition|)
block|{
name|struct
name|funcinfo
modifier|*
name|func
init|=
name|stash
operator|->
name|inliner_chain
decl_stmt|;
if|if
condition|(
name|func
operator|&&
name|func
operator|->
name|caller_func
condition|)
block|{
operator|*
name|filename_ptr
operator|=
name|func
operator|->
name|caller_file
expr_stmt|;
operator|*
name|functionname_ptr
operator|=
name|func
operator|->
name|caller_func
operator|->
name|name
expr_stmt|;
operator|*
name|linenumber_ptr
operator|=
name|func
operator|->
name|caller_line
expr_stmt|;
name|stash
operator|->
name|inliner_chain
operator|=
name|func
operator|->
name|caller_func
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|void
name|_bfd_dwarf2_cleanup_debug_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|comp_unit
modifier|*
name|each
decl_stmt|;
name|struct
name|dwarf2_debug
modifier|*
name|stash
decl_stmt|;
if|if
condition|(
name|abfd
operator|==
name|NULL
operator|||
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|==
name|NULL
condition|)
return|return;
name|stash
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dwarf2_find_line_info
expr_stmt|;
if|if
condition|(
name|stash
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|each
operator|=
name|stash
operator|->
name|all_comp_units
init|;
name|each
condition|;
name|each
operator|=
name|each
operator|->
name|next_unit
control|)
block|{
name|struct
name|abbrev_info
modifier|*
modifier|*
name|abbrevs
init|=
name|each
operator|->
name|abbrevs
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ABBREV_HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|abbrev_info
modifier|*
name|abbrev
init|=
name|abbrevs
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|abbrev
condition|)
block|{
name|free
argument_list|(
name|abbrev
operator|->
name|attrs
argument_list|)
expr_stmt|;
name|abbrev
operator|=
name|abbrev
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|each
operator|->
name|line_table
condition|)
block|{
name|free
argument_list|(
name|each
operator|->
name|line_table
operator|->
name|dirs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|each
operator|->
name|line_table
operator|->
name|files
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|stash
operator|->
name|dwarf_abbrev_buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|stash
operator|->
name|dwarf_line_buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|stash
operator|->
name|dwarf_ranges_buffer
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

