begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* MMIX-specific support for 64-bit ELF.    Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.    Contributed by Hans-Peter Nilsson<hp@bitrange.com>  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* No specific ABI or "processor-specific supplement" defined.  */
end_comment

begin_comment
comment|/* TODO:    - "Traditional" linker relaxation (shrinking whole sections).    - Merge reloc stubs jumping to same location.    - GETA stub relaxation (call a stub for out of range new      R_MMIX_GETA_STUBBABLE).  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/mmix.h"
end_include

begin_include
include|#
directive|include
file|"opcode/mmix.h"
end_include

begin_define
define|#
directive|define
name|MINUS_ONE
value|(((bfd_vma) 0) - 1)
end_define

begin_define
define|#
directive|define
name|MAX_PUSHJ_STUB_SIZE
value|(5 * 4)
end_define

begin_comment
comment|/* Put these everywhere in new code.  */
end_comment

begin_define
define|#
directive|define
name|FATAL_DEBUG
define|\
value|_bfd_abort (__FILE__, __LINE__,				\ 	     "Internal: Non-debugged code (test-case missing)")
end_define

begin_define
define|#
directive|define
name|BAD_CASE
parameter_list|(
name|x
parameter_list|)
define|\
value|_bfd_abort (__FILE__, __LINE__,		\ 	     "bad case for " #x)
end_define

begin_struct
struct|struct
name|_mmix_elf_section_data
block|{
name|struct
name|bfd_elf_section_data
name|elf
decl_stmt|;
union|union
block|{
name|struct
name|bpo_reloc_section_info
modifier|*
name|reloc
decl_stmt|;
name|struct
name|bpo_greg_section_info
modifier|*
name|greg
decl_stmt|;
block|}
name|bpo
union|;
struct|struct
name|pushj_stub_info
block|{
comment|/* Maximum number of stubs needed for this section.  */
name|bfd_size_type
name|n_pushj_relocs
decl_stmt|;
comment|/* Size of stubs after a mmix_elf_relax_section round.  */
name|bfd_size_type
name|stubs_size_sum
decl_stmt|;
comment|/* Per-reloc stubs_size_sum information.  The stubs_size_sum member is the sum        of these.  Allocated in mmix_elf_check_common_relocs.  */
name|bfd_size_type
modifier|*
name|stub_size
decl_stmt|;
comment|/* Offset of next stub during relocation.  Somewhat redundant with the        above: error coverage is easier and we don't have to reset the        stubs_size_sum for relocation.  */
name|bfd_size_type
name|stub_offset
decl_stmt|;
block|}
name|pjs
struct|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|mmix_elf_section_data
parameter_list|(
name|sec
parameter_list|)
define|\
value|((struct _mmix_elf_section_data *) elf_section_data (sec))
end_define

begin_comment
comment|/* For each section containing a base-plus-offset (BPO) reloc, we attach    this struct as mmix_elf_section_data (section)->bpo, which is otherwise    NULL.  */
end_comment

begin_struct
struct|struct
name|bpo_reloc_section_info
block|{
comment|/* The base is 1; this is the first number in this section.  */
name|size_t
name|first_base_plus_offset_reloc
decl_stmt|;
comment|/* Number of BPO-relocs in this section.  */
name|size_t
name|n_bpo_relocs_this_section
decl_stmt|;
comment|/* Running index, used at relocation time.  */
name|size_t
name|bpo_index
decl_stmt|;
comment|/* We don't have access to the bfd_link_info struct in        mmix_final_link_relocate.  What we really want to get at is the        global single struct greg_relocation, so we stash it here.  */
name|asection
modifier|*
name|bpo_greg_section
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Helper struct (in global context) for the one below.    There's one of these created for every BPO reloc.  */
end_comment

begin_struct
struct|struct
name|bpo_reloc_request
block|{
name|bfd_vma
name|value
decl_stmt|;
comment|/* Valid after relaxation.  The base is 0; the first register number        must be added.  The offset is in range 0..255.  */
name|size_t
name|regindex
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
comment|/* The order number for this BPO reloc, corresponding to the order in        which BPO relocs were found.  Used to create an index after reloc        requests are sorted.  */
name|size_t
name|bpo_reloc_no
decl_stmt|;
comment|/* Set when the value is computed.  Better than coding "guard values"        into the other members.  Is FALSE only for BPO relocs in a GC:ed        section.  */
name|bfd_boolean
name|valid
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* We attach this as mmix_elf_section_data (sec)->bpo in the linker-allocated    greg contents section (MMIX_LD_ALLOCATED_REG_CONTENTS_SECTION_NAME),    which is linked into the register contents section    (MMIX_REG_CONTENTS_SECTION_NAME).  This section is created by the    linker; using the same hook as for usual with BPO relocs does not    collide.  */
end_comment

begin_struct
struct|struct
name|bpo_greg_section_info
block|{
comment|/* After GC, this reflects the number of remaining, non-excluded        BPO-relocs.  */
name|size_t
name|n_bpo_relocs
decl_stmt|;
comment|/* This is the number of allocated bpo_reloc_requests; the size of        sorted_indexes.  Valid after the check.*relocs functions are called        for all incoming sections.  It includes the number of BPO relocs in        sections that were GC:ed.  */
name|size_t
name|n_max_bpo_relocs
decl_stmt|;
comment|/* A counter used to find out when to fold the BPO gregs, since we        don't have a single "after-relaxation" hook.  */
name|size_t
name|n_remaining_bpo_relocs_this_relaxation_round
decl_stmt|;
comment|/* The number of linker-allocated GREGs resulting from BPO relocs.        This is an approximation after _bfd_mmix_before_linker_allocation        and supposedly accurate after mmix_elf_relax_section is called for        all incoming non-collected sections.  */
name|size_t
name|n_allocated_bpo_gregs
decl_stmt|;
comment|/* Index into reloc_request[], sorted on increasing "value", secondary        by increasing index for strict sorting order.  */
name|size_t
modifier|*
name|bpo_reloc_indexes
decl_stmt|;
comment|/* An array of all relocations, with the "value" member filled in by        the relaxation function.  */
name|struct
name|bpo_reloc_request
modifier|*
name|reloc_request
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmix_elf_link_output_symbol_hook
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mmix_elf_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|bfd_elf64_bfd_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmix_info_to_howto_rela
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mmix_elf_sort_relocs
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmix_elf_new_section_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmix_elf_check_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmix_elf_check_common_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmix_elf_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mmix_final_link_relocate
name|PARAMS
argument_list|(
operator|(
name|reloc_howto_type
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_signed_vma
operator|,
name|bfd_vma
operator|,
specifier|const
name|char
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|mmix_elf_perform_relocation
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
name|reloc_howto_type
operator|*
operator|,
name|PTR
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmix_elf_section_from_bfd_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmix_elf_add_symbol_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|flagword
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmix_elf_is_local_label_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bpo_reloc_request_sort_fn
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmix_elf_relax_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|asection
operator|*
name|sec
operator|,
expr|struct
name|bfd_link_info
operator|*
name|link_info
operator|,
name|bfd_boolean
operator|*
name|again
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bfd_boolean
name|mmix_elf_final_link
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|mmix_elf_symbol_processing
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Only intended to be called from a debugger.  */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|mmix_dump_bpo_gregs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd_error_handler_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmix_set_relaxable_size
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Watch out: this currently needs to have elements with the same index as    their R_MMIX_ number.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_mmix_howto_table
index|[]
init|=
block|{
comment|/* This reloc does nothing.  */
name|HOWTO
argument_list|(
name|R_MMIX_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_NONE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An 8 bit absolute relocation.  */
name|HOWTO
argument_list|(
name|R_MMIX_8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An 16 bit absolute relocation.  */
name|HOWTO
argument_list|(
name|R_MMIX_16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An 24 bit absolute relocation.  */
name|HOWTO
argument_list|(
name|R_MMIX_24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|24
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
operator|~
literal|0xffffff
argument_list|,
comment|/* src_mask */
literal|0xffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32 bit absolute relocation.  */
name|HOWTO
argument_list|(
name|R_MMIX_32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64 bit relocation.  */
name|HOWTO
argument_list|(
name|R_MMIX_64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|MINUS_ONE
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An 8 bit PC-relative relocation.  */
name|HOWTO
argument_list|(
name|R_MMIX_PC_8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_PC_8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An 16 bit PC-relative relocation.  */
name|HOWTO
argument_list|(
name|R_MMIX_PC_16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_PC_16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An 24 bit PC-relative relocation.  */
name|HOWTO
argument_list|(
name|R_MMIX_PC_24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|24
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_PC_24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
operator|~
literal|0xffffff
argument_list|,
comment|/* src_mask */
literal|0xffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32 bit absolute PC-relative relocation.  */
name|HOWTO
argument_list|(
name|R_MMIX_PC_32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_PC_32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 64 bit PC-relative relocation.  */
name|HOWTO
argument_list|(
name|R_MMIX_PC_64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_PC_64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
name|MINUS_ONE
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable hierarchy.  */
name|HOWTO
argument_list|(
name|R_MMIX_GNU_VTINHERIT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_MMIX_GNU_VTINHERIT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable member usage.  */
name|HOWTO
argument_list|(
name|R_MMIX_GNU_VTENTRY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_elf_rel_vtable_reloc_fn
argument_list|,
comment|/* special_function */
literal|"R_MMIX_GNU_VTENTRY"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The GETA relocation is supposed to get any address that could      possibly be reached by the GETA instruction.  It can silently expand      to get a 64-bit operand, but will complain if any of the two least      significant bits are set.  The howto members reflect a simple GETA.  */
name|HOWTO
argument_list|(
name|R_MMIX_GETA
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|19
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mmix_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_GETA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
operator|~
literal|0x0100ffff
argument_list|,
comment|/* src_mask */
literal|0x0100ffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MMIX_GETA_1
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|19
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mmix_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_GETA_1"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
operator|~
literal|0x0100ffff
argument_list|,
comment|/* src_mask */
literal|0x0100ffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MMIX_GETA_2
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|19
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mmix_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_GETA_2"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
operator|~
literal|0x0100ffff
argument_list|,
comment|/* src_mask */
literal|0x0100ffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MMIX_GETA_3
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|19
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mmix_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_GETA_3"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
operator|~
literal|0x0100ffff
argument_list|,
comment|/* src_mask */
literal|0x0100ffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The conditional branches are supposed to reach any (code) address.      It can silently expand to a 64-bit operand, but will emit an error if      any of the two least significant bits are set.  The howto members      reflect a simple branch.  */
name|HOWTO
argument_list|(
name|R_MMIX_CBRANCH
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|19
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mmix_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_CBRANCH"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
operator|~
literal|0x0100ffff
argument_list|,
comment|/* src_mask */
literal|0x0100ffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MMIX_CBRANCH_J
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|19
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mmix_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_CBRANCH_J"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
operator|~
literal|0x0100ffff
argument_list|,
comment|/* src_mask */
literal|0x0100ffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MMIX_CBRANCH_1
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|19
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mmix_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_CBRANCH_1"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
operator|~
literal|0x0100ffff
argument_list|,
comment|/* src_mask */
literal|0x0100ffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MMIX_CBRANCH_2
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|19
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mmix_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_CBRANCH_2"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
operator|~
literal|0x0100ffff
argument_list|,
comment|/* src_mask */
literal|0x0100ffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MMIX_CBRANCH_3
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|19
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mmix_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_CBRANCH_3"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
operator|~
literal|0x0100ffff
argument_list|,
comment|/* src_mask */
literal|0x0100ffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The PUSHJ instruction can reach any (code) address, as long as it's      the beginning of a function (no usable restriction).  It can silently      expand to a 64-bit operand, but will emit an error if any of the two      least significant bits are set.  It can also expand into a call to a      stub; see R_MMIX_PUSHJ_STUBBABLE.  The howto members reflect a simple      PUSHJ.  */
name|HOWTO
argument_list|(
name|R_MMIX_PUSHJ
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|19
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mmix_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_PUSHJ"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
operator|~
literal|0x0100ffff
argument_list|,
comment|/* src_mask */
literal|0x0100ffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MMIX_PUSHJ_1
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|19
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mmix_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_PUSHJ_1"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
operator|~
literal|0x0100ffff
argument_list|,
comment|/* src_mask */
literal|0x0100ffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MMIX_PUSHJ_2
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|19
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mmix_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_PUSHJ_2"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
operator|~
literal|0x0100ffff
argument_list|,
comment|/* src_mask */
literal|0x0100ffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MMIX_PUSHJ_3
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|19
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mmix_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_PUSHJ_3"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
operator|~
literal|0x0100ffff
argument_list|,
comment|/* src_mask */
literal|0x0100ffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A JMP is supposed to reach any (code) address.  By itself, it can      reach +-64M; the expansion can reach all 64 bits.  Note that the 64M      limit is soon reached if you link the program in wildly different      memory segments.  The howto members reflect a trivial JMP.  */
name|HOWTO
argument_list|(
name|R_MMIX_JMP
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|27
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mmix_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_JMP"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
operator|~
literal|0x1ffffff
argument_list|,
comment|/* src_mask */
literal|0x1ffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MMIX_JMP_1
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|27
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mmix_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_JMP_1"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
operator|~
literal|0x1ffffff
argument_list|,
comment|/* src_mask */
literal|0x1ffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MMIX_JMP_2
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|27
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mmix_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_JMP_2"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
operator|~
literal|0x1ffffff
argument_list|,
comment|/* src_mask */
literal|0x1ffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MMIX_JMP_3
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|27
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mmix_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_JMP_3"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
operator|~
literal|0x1ffffff
argument_list|,
comment|/* src_mask */
literal|0x1ffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* When we don't emit link-time-relaxable code from the assembler, or      when relaxation has done all it can do, these relocs are used.  For      GETA/PUSHJ/branches.  */
name|HOWTO
argument_list|(
name|R_MMIX_ADDR19
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|19
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mmix_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_ADDR19"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
operator|~
literal|0x0100ffff
argument_list|,
comment|/* src_mask */
literal|0x0100ffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* For JMP.  */
name|HOWTO
argument_list|(
name|R_MMIX_ADDR27
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|27
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|mmix_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_ADDR27"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
operator|~
literal|0x1ffffff
argument_list|,
comment|/* src_mask */
literal|0x1ffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A general register or the value 0..255.  If a value, then the      instruction (offset -3) needs adjusting.  */
name|HOWTO
argument_list|(
name|R_MMIX_REG_OR_BYTE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|mmix_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_REG_OR_BYTE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A general register.  */
name|HOWTO
argument_list|(
name|R_MMIX_REG
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|mmix_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_REG"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A register plus an index, corresponding to the relocation expression.      The sizes must correspond to the valid range of the expression, while      the bitmasks correspond to what we store in the image.  */
name|HOWTO
argument_list|(
name|R_MMIX_BASE_PLUS_OFFSET
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|mmix_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_BASE_PLUS_OFFSET"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A "magic" relocation for a LOCAL expression, asserting that the      expression is less than the number of global registers.  No actual      modification of the contents is done.  Implementing this as a      relocation was less intrusive than e.g. putting such expressions in a      section to discard *after* relocation.  */
name|HOWTO
argument_list|(
name|R_MMIX_LOCAL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|mmix_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_LOCAL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
argument|R_MMIX_PUSHJ_STUBBABLE
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|19
argument_list|,
comment|/* bitsize */
argument|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
argument|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
argument|mmix_elf_reloc
argument_list|,
comment|/* special_function */
literal|"R_MMIX_PUSHJ_STUBBABLE"
argument_list|,
comment|/* name */
argument|FALSE
argument_list|,
comment|/* partial_inplace */
argument|~
literal|0x0100ffff
argument_list|,
comment|/* src_mask */
literal|0x0100ffff
argument_list|,
comment|/* dst_mask */
argument|TRUE
argument_list|)
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map BFD reloc types to MMIX ELF reloc types.  */
end_comment

begin_struct
struct|struct
name|mmix_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_val
decl_stmt|;
name|enum
name|elf_mmix_reloc_type
name|elf_reloc_val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|mmix_reloc_map
name|mmix_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_MMIX_NONE
block|}
block|,
block|{
name|BFD_RELOC_8
block|,
name|R_MMIX_8
block|}
block|,
block|{
name|BFD_RELOC_16
block|,
name|R_MMIX_16
block|}
block|,
block|{
name|BFD_RELOC_24
block|,
name|R_MMIX_24
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_MMIX_32
block|}
block|,
block|{
name|BFD_RELOC_64
block|,
name|R_MMIX_64
block|}
block|,
block|{
name|BFD_RELOC_8_PCREL
block|,
name|R_MMIX_PC_8
block|}
block|,
block|{
name|BFD_RELOC_16_PCREL
block|,
name|R_MMIX_PC_16
block|}
block|,
block|{
name|BFD_RELOC_24_PCREL
block|,
name|R_MMIX_PC_24
block|}
block|,
block|{
name|BFD_RELOC_32_PCREL
block|,
name|R_MMIX_PC_32
block|}
block|,
block|{
name|BFD_RELOC_64_PCREL
block|,
name|R_MMIX_PC_64
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_INHERIT
block|,
name|R_MMIX_GNU_VTINHERIT
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_ENTRY
block|,
name|R_MMIX_GNU_VTENTRY
block|}
block|,
block|{
name|BFD_RELOC_MMIX_GETA
block|,
name|R_MMIX_GETA
block|}
block|,
block|{
name|BFD_RELOC_MMIX_CBRANCH
block|,
name|R_MMIX_CBRANCH
block|}
block|,
block|{
name|BFD_RELOC_MMIX_PUSHJ
block|,
name|R_MMIX_PUSHJ
block|}
block|,
block|{
name|BFD_RELOC_MMIX_JMP
block|,
name|R_MMIX_JMP
block|}
block|,
block|{
name|BFD_RELOC_MMIX_ADDR19
block|,
name|R_MMIX_ADDR19
block|}
block|,
block|{
name|BFD_RELOC_MMIX_ADDR27
block|,
name|R_MMIX_ADDR27
block|}
block|,
block|{
name|BFD_RELOC_MMIX_REG_OR_BYTE
block|,
name|R_MMIX_REG_OR_BYTE
block|}
block|,
block|{
name|BFD_RELOC_MMIX_REG
block|,
name|R_MMIX_REG
block|}
block|,
block|{
name|BFD_RELOC_MMIX_BASE_PLUS_OFFSET
block|,
name|R_MMIX_BASE_PLUS_OFFSET
block|}
block|,
block|{
name|BFD_RELOC_MMIX_LOCAL
block|,
name|R_MMIX_LOCAL
block|}
block|,
block|{
name|BFD_RELOC_MMIX_PUSHJ_STUBBABLE
block|,
name|R_MMIX_PUSHJ_STUBBABLE
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|bfd_elf64_bfd_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|mmix_reloc_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mmix_reloc_map
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mmix_reloc_map
index|[
name|i
index|]
operator|.
name|bfd_reloc_val
operator|==
name|code
condition|)
return|return
operator|&
name|elf_mmix_howto_table
index|[
name|mmix_reloc_map
index|[
name|i
index|]
operator|.
name|elf_reloc_val
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|bfd_elf64_bfd_reloc_name_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|r_name
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|elf_mmix_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|elf_mmix_howto_table
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|elf_mmix_howto_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcasecmp
argument_list|(
name|elf_mmix_howto_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|elf_mmix_howto_table
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|mmix_elf_new_section_hook
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|sec
operator|->
name|used_by_bfd
condition|)
block|{
name|struct
name|_mmix_elf_section_data
modifier|*
name|sdata
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
operator|*
name|sdata
argument_list|)
decl_stmt|;
name|sdata
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdata
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|sec
operator|->
name|used_by_bfd
operator|=
name|sdata
expr_stmt|;
block|}
return|return
name|_bfd_elf_new_section_hook
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This function performs the actual bitfiddling and sanity check for a    final relocation.  Each relocation gets its *worst*-case expansion    in size when it arrives here; any reduction in size should have been    caught in linker relaxation earlier.  When we get here, the relocation    looks like the smallest instruction with SWYM:s (nop:s) appended to the    max size.  We fill in those nop:s.     R_MMIX_GETA: (FIXME: Relaxation should break this up in 1, 2, 3 tetra)     GETA $N,foo    ->     SETL $N,foo& 0xffff     INCML $N,(foo>> 16)& 0xffff     INCMH $N,(foo>> 32)& 0xffff     INCH $N,(foo>> 48)& 0xffff     R_MMIX_CBRANCH: (FIXME: Relaxation should break this up, but    condbranches needing relaxation might be rare enough to not be    worthwhile.)     [P]Bcc $N,foo    ->     [~P]B~cc $N,.+20     SETL $255,foo& ...     INCML ...     INCMH ...     INCH ...     GO $255,$255,0     R_MMIX_PUSHJ: (FIXME: Relaxation...)     PUSHJ $N,foo    ->     SETL $255,foo& ...     INCML ...     INCMH ...     INCH ...     PUSHGO $N,$255,0     R_MMIX_JMP: (FIXME: Relaxation...)     JMP foo    ->     SETL $255,foo& ...     INCML ...     INCMH ...     INCH ...     GO $255,$255,0     R_MMIX_ADDR19 and R_MMIX_ADDR27 are just filled in.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mmix_elf_perform_relocation
parameter_list|(
name|isec
parameter_list|,
name|howto
parameter_list|,
name|datap
parameter_list|,
name|addr
parameter_list|,
name|value
parameter_list|)
name|asection
modifier|*
name|isec
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|PTR
name|datap
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
init|=
name|isec
operator|->
name|owner
decl_stmt|;
name|bfd_reloc_status_type
name|flag
init|=
name|bfd_reloc_ok
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|int
name|offs
init|=
literal|0
decl_stmt|;
name|int
name|reg
init|=
literal|255
decl_stmt|;
comment|/* The worst case bits are all similar SETL/INCML/INCMH/INCH sequences.      We handle the differences here and the common sequence later.  */
switch|switch
condition|(
name|howto
operator|->
name|type
condition|)
block|{
case|case
name|R_MMIX_GETA
case|:
name|offs
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|datap
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* We change to an absolute value.  */
name|value
operator|+=
name|addr
expr_stmt|;
break|break;
case|case
name|R_MMIX_CBRANCH
case|:
block|{
name|int
name|in1
init|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|datap
argument_list|)
operator|<<
literal|16
decl_stmt|;
comment|/* Invert the condition and prediction bit, and set the offset 	   to five instructions ahead.  	   We *can* do better if we want to.  If the branch is found to be 	   within limits, we could leave the branch as is; there'll just 	   be a bunch of NOP:s after it.  But we shouldn't see this 	   sequence often enough that it's worth doing it.  */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
operator|(
name|in1
operator|^
operator|(
operator|(
name|PRED_INV_BIT
operator||
name|COND_INV_BIT
operator|)
operator|<<
literal|24
operator|)
operator|)
operator|&
operator|~
literal|0xffff
operator|)
operator||
operator|(
literal|24
operator|/
literal|4
operator|)
operator|)
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|datap
argument_list|)
expr_stmt|;
comment|/* Put a "GO $255,$255,0" after the common sequence.  */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|GO_INSN_BYTE
operator||
name|IMM_OFFSET_BIT
operator|)
operator|<<
literal|24
operator|)
operator||
literal|0xffff00
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|datap
operator|+
literal|20
argument_list|)
expr_stmt|;
comment|/* Common sequence starts at offset 4.  */
name|offs
operator|=
literal|4
expr_stmt|;
comment|/* We change to an absolute value.  */
name|value
operator|+=
name|addr
expr_stmt|;
block|}
break|break;
case|case
name|R_MMIX_PUSHJ_STUBBABLE
case|:
comment|/* If the address fits, we're fine.  */
if|if
condition|(
operator|(
name|value
operator|&
literal|3
operator|)
operator|==
literal|0
comment|/* Note rightshift 0; see R_MMIX_JMP case below.  */
operator|&&
operator|(
name|r
operator|=
name|bfd_check_overflow
argument_list|(
name|complain_overflow_signed
argument_list|,
name|howto
operator|->
name|bitsize
argument_list|,
literal|0
argument_list|,
name|bfd_arch_bits_per_address
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|value
argument_list|)
operator|)
operator|==
name|bfd_reloc_ok
condition|)
goto|goto
name|pcrel_mmix_reloc_fits
goto|;
else|else
block|{
name|bfd_size_type
name|size
init|=
name|isec
operator|->
name|rawsize
condition|?
name|isec
operator|->
name|rawsize
else|:
name|isec
operator|->
name|size
decl_stmt|;
comment|/* We have the bytes at the PUSHJ insn and need to get the 	     position for the stub.  There's supposed to be room allocated 	     for the stub.  */
name|bfd_byte
modifier|*
name|stubcontents
init|=
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|datap
operator|-
operator|(
name|addr
operator|-
operator|(
name|isec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|isec
operator|->
name|output_offset
operator|)
operator|)
operator|+
name|size
operator|+
name|mmix_elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|pjs
operator|.
name|stub_offset
operator|)
decl_stmt|;
name|bfd_vma
name|stubaddr
decl_stmt|;
comment|/* The address doesn't fit, so redirect the PUSHJ to the 	     location of the stub.  */
name|r
operator|=
name|mmix_elf_perform_relocation
argument_list|(
name|isec
argument_list|,
operator|&
name|elf_mmix_howto_table
index|[
name|R_MMIX_ADDR19
index|]
argument_list|,
name|datap
argument_list|,
name|addr
argument_list|,
name|isec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|isec
operator|->
name|output_offset
operator|+
name|size
operator|+
operator|(
name|mmix_elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|pjs
operator|.
name|stub_offset
operator|)
operator|-
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|r
return|;
name|stubaddr
operator|=
operator|(
name|isec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|isec
operator|->
name|output_offset
operator|+
name|size
operator|+
name|mmix_elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|pjs
operator|.
name|stub_offset
operator|)
expr_stmt|;
comment|/* We generate a simple JMP if that suffices, else the whole 5 	     insn stub.  */
if|if
condition|(
name|bfd_check_overflow
argument_list|(
name|complain_overflow_signed
argument_list|,
name|elf_mmix_howto_table
index|[
name|R_MMIX_ADDR27
index|]
operator|.
name|bitsize
argument_list|,
literal|0
argument_list|,
name|bfd_arch_bits_per_address
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|addr
operator|+
name|value
operator|-
name|stubaddr
argument_list|)
operator|==
name|bfd_reloc_ok
condition|)
block|{
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|JMP_INSN_BYTE
operator|<<
literal|24
argument_list|,
name|stubcontents
argument_list|)
expr_stmt|;
name|r
operator|=
name|mmix_elf_perform_relocation
argument_list|(
name|isec
argument_list|,
operator|&
name|elf_mmix_howto_table
index|[
name|R_MMIX_ADDR27
index|]
argument_list|,
name|stubcontents
argument_list|,
name|stubaddr
argument_list|,
name|value
operator|+
name|addr
operator|-
name|stubaddr
argument_list|)
expr_stmt|;
name|mmix_elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|pjs
operator|.
name|stub_offset
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|size
operator|+
name|mmix_elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|pjs
operator|.
name|stub_offset
operator|>
name|isec
operator|->
name|size
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
else|else
block|{
comment|/* Put a "GO $255,0" after the common sequence.  */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|GO_INSN_BYTE
operator||
name|IMM_OFFSET_BIT
operator|)
operator|<<
literal|24
operator|)
operator||
literal|0xff00
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|stubcontents
operator|+
literal|16
argument_list|)
expr_stmt|;
comment|/* Prepare for the general code to set the first part of the 		 linker stub, and */
name|value
operator|+=
name|addr
expr_stmt|;
name|datap
operator|=
name|stubcontents
expr_stmt|;
name|mmix_elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|pjs
operator|.
name|stub_offset
operator|+=
name|MAX_PUSHJ_STUB_SIZE
expr_stmt|;
block|}
block|}
break|break;
case|case
name|R_MMIX_PUSHJ
case|:
block|{
name|int
name|inreg
init|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|datap
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* Put a "PUSHGO $N,$255,0" after the common sequence.  */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|PUSHGO_INSN_BYTE
operator||
name|IMM_OFFSET_BIT
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
name|inreg
operator|<<
literal|16
operator|)
operator||
literal|0xff00
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|datap
operator|+
literal|16
argument_list|)
expr_stmt|;
comment|/* We change to an absolute value.  */
name|value
operator|+=
name|addr
expr_stmt|;
block|}
break|break;
case|case
name|R_MMIX_JMP
case|:
comment|/* This one is a little special.  If we get here on a non-relaxing 	 link, and the destination is actually in range, we don't need to 	 execute the nops. 	 If so, we fall through to the bit-fiddling relocs.  	 FIXME: bfd_check_overflow seems broken; the relocation is 	 rightshifted before testing, so supply a zero rightshift.  */
if|if
condition|(
operator|!
operator|(
operator|(
name|value
operator|&
literal|3
operator|)
operator|==
literal|0
operator|&&
operator|(
name|r
operator|=
name|bfd_check_overflow
argument_list|(
name|complain_overflow_signed
argument_list|,
name|howto
operator|->
name|bitsize
argument_list|,
literal|0
argument_list|,
name|bfd_arch_bits_per_address
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|value
argument_list|)
operator|)
operator|==
name|bfd_reloc_ok
operator|)
condition|)
block|{
comment|/* If the relocation doesn't fit in a JMP, we let the NOP:s be 	     modified below, and put a "GO $255,$255,0" after the 	     address-loading sequence.  */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|GO_INSN_BYTE
operator||
name|IMM_OFFSET_BIT
operator|)
operator|<<
literal|24
operator|)
operator||
literal|0xffff00
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|datap
operator|+
literal|16
argument_list|)
expr_stmt|;
comment|/* We change to an absolute value.  */
name|value
operator|+=
name|addr
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH.  */
case|case
name|R_MMIX_ADDR19
case|:
case|case
name|R_MMIX_ADDR27
case|:
name|pcrel_mmix_reloc_fits
label|:
comment|/* These must be in range, or else we emit an error.  */
if|if
condition|(
operator|(
name|value
operator|&
literal|3
operator|)
operator|==
literal|0
comment|/* Note rightshift 0; see above.  */
operator|&&
operator|(
name|r
operator|=
name|bfd_check_overflow
argument_list|(
name|complain_overflow_signed
argument_list|,
name|howto
operator|->
name|bitsize
argument_list|,
literal|0
argument_list|,
name|bfd_arch_bits_per_address
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|value
argument_list|)
operator|)
operator|==
name|bfd_reloc_ok
condition|)
block|{
name|bfd_vma
name|in1
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|datap
argument_list|)
decl_stmt|;
name|bfd_vma
name|highbit
decl_stmt|;
if|if
condition|(
operator|(
name|bfd_signed_vma
operator|)
name|value
operator|<
literal|0
condition|)
block|{
name|highbit
operator|=
literal|1
operator|<<
literal|24
expr_stmt|;
name|value
operator|+=
operator|(
literal|1
operator|<<
operator|(
name|howto
operator|->
name|bitsize
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
else|else
name|highbit
operator|=
literal|0
expr_stmt|;
name|value
operator|>>=
literal|2
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|in1
operator|&
name|howto
operator|->
name|src_mask
operator|)
operator||
name|highbit
operator||
operator|(
name|value
operator|&
name|howto
operator|->
name|dst_mask
operator|)
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|datap
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
else|else
return|return
name|bfd_reloc_overflow
return|;
case|case
name|R_MMIX_BASE_PLUS_OFFSET
case|:
block|{
name|struct
name|bpo_reloc_section_info
modifier|*
name|bpodata
init|=
name|mmix_elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|bpo
operator|.
name|reloc
decl_stmt|;
name|asection
modifier|*
name|bpo_greg_section
init|=
name|bpodata
operator|->
name|bpo_greg_section
decl_stmt|;
name|struct
name|bpo_greg_section_info
modifier|*
name|gregdata
init|=
name|mmix_elf_section_data
argument_list|(
name|bpo_greg_section
argument_list|)
operator|->
name|bpo
operator|.
name|greg
decl_stmt|;
name|size_t
name|bpo_index
init|=
name|gregdata
operator|->
name|bpo_reloc_indexes
index|[
name|bpodata
operator|->
name|bpo_index
operator|++
index|]
decl_stmt|;
comment|/* A consistency check: The value we now have in "relocation" must 	   be the same as the value we stored for that relocation.  It 	   doesn't cost much, so can be left in at all times.  */
if|if
condition|(
name|value
operator|!=
name|gregdata
operator|->
name|reloc_request
index|[
name|bpo_index
index|]
operator|.
name|value
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: Internal inconsistency error for value for\n\  linker-allocated global register: linked: 0x%lx%08lx != relaxed: 0x%lx%08lx\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|isec
operator|->
name|owner
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|value
operator|>>
literal|32
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|value
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|gregdata
operator|->
name|reloc_request
index|[
name|bpo_index
index|]
operator|.
name|value
operator|>>
literal|32
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|gregdata
operator|->
name|reloc_request
index|[
name|bpo_index
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_overflow
return|;
block|}
comment|/* Then store the register number and offset for that register 	   into datap and datap + 1 respectively.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|gregdata
operator|->
name|reloc_request
index|[
name|bpo_index
index|]
operator|.
name|regindex
operator|+
name|bpo_greg_section
operator|->
name|output_section
operator|->
name|vma
operator|/
literal|8
argument_list|,
name|datap
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|gregdata
operator|->
name|reloc_request
index|[
name|bpo_index
index|]
operator|.
name|offset
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|datap
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
case|case
name|R_MMIX_REG_OR_BYTE
case|:
case|case
name|R_MMIX_REG
case|:
if|if
condition|(
name|value
operator|>
literal|255
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|datap
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
default|default:
name|BAD_CASE
argument_list|(
name|howto
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* This code adds the common SETL/INCML/INCMH/INCH worst-case      sequence.  */
comment|/* Lowest two bits must be 0.  We return bfd_reloc_overflow for      everything that looks strange.  */
if|if
condition|(
name|value
operator|&
literal|3
condition|)
name|flag
operator|=
name|bfd_reloc_overflow
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|SETL_INSN_BYTE
operator|<<
literal|24
operator|)
operator||
operator|(
name|value
operator|&
literal|0xffff
operator|)
operator||
operator|(
name|reg
operator|<<
literal|16
operator|)
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|datap
operator|+
name|offs
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|INCML_INSN_BYTE
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator||
operator|(
name|reg
operator|<<
literal|16
operator|)
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|datap
operator|+
name|offs
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|INCMH_INSN_BYTE
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|value
operator|>>
literal|32
operator|)
operator|&
literal|0xffff
operator|)
operator||
operator|(
name|reg
operator|<<
literal|16
operator|)
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|datap
operator|+
name|offs
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|INCH_INSN_BYTE
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|value
operator|>>
literal|48
operator|)
operator|&
literal|0xffff
operator|)
operator||
operator|(
name|reg
operator|<<
literal|16
operator|)
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|datap
operator|+
name|offs
operator|+
literal|12
argument_list|)
expr_stmt|;
return|return
name|flag
return|;
block|}
end_function

begin_comment
comment|/* Set the howto pointer for an MMIX ELF reloc (type RELA).  */
end_comment

begin_function
specifier|static
name|void
name|mmix_info_to_howto_rela
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r_type
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_MMIX_max
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf_mmix_howto_table
index|[
name|r_type
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Any MMIX-specific relocation gets here at assembly time or when linking    to other formats (such as mmo); this is the relocation function from    the reloc_table.  We don't get here for final pure ELF linking.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mmix_elf_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|asection
modifier|*
name|reloc_target_output_section
decl_stmt|;
name|bfd_reloc_status_type
name|flag
init|=
name|bfd_reloc_ok
decl_stmt|;
name|bfd_vma
name|output_base
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|r
operator|=
name|bfd_elf_generic_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
comment|/* If that was all that was needed (i.e. this isn't a final link, only      some segment adjustments), we're done.  */
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_continue
condition|)
return|return
name|r
return|;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|==
literal|0
operator|&&
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
return|return
name|bfd_reloc_undefined
return|;
comment|/* Is the address of the relocation really within the section?  */
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|input_section
argument_list|)
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* Work out which section the relocation is targeted at and the      initial relocation command value.  */
comment|/* Get symbol value.  (Common symbols are special.)  */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|reloc_target_output_section
operator|=
name|bfd_get_output_section
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
comment|/* Here the variable relocation holds the final address of the symbol we      are relocating against, plus any addend.  */
if|if
condition|(
name|output_bfd
condition|)
name|output_base
operator|=
literal|0
expr_stmt|;
else|else
name|output_base
operator|=
name|reloc_target_output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|output_base
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
comment|/* Get position of relocation.  */
name|addr
operator|=
operator|(
name|reloc_entry
operator|->
name|address
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Add in supplied addend.  */
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
comment|/* This is a partial relocation, and we want to apply the 	 relocation to the reloc entry rather than the raw data. 	 Modify the reloc inplace to reflect what we now know.  */
name|reloc_entry
operator|->
name|addend
operator|=
name|relocation
expr_stmt|;
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|flag
return|;
block|}
return|return
name|mmix_final_link_relocate
argument_list|(
name|reloc_entry
operator|->
name|howto
argument_list|,
name|input_section
argument_list|,
name|data
argument_list|,
name|reloc_entry
operator|->
name|address
argument_list|,
name|reloc_entry
operator|->
name|addend
argument_list|,
name|relocation
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|reloc_target_output_section
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Relocate an MMIX ELF section.  Modified from elf32-fr30.c; look to it    for guidance if you're thinking of copying this.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mmix_elf_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|size_t
name|pjsno
init|=
literal|0
decl_stmt|;
name|size
operator|=
name|input_section
operator|->
name|rawsize
condition|?
name|input_section
operator|->
name|rawsize
else|:
name|input_section
operator|->
name|size
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
comment|/* Zero the stub area before we start.  */
if|if
condition|(
name|input_section
operator|->
name|rawsize
operator|!=
literal|0
operator|&&
name|input_section
operator|->
name|size
operator|>
name|input_section
operator|->
name|rawsize
condition|)
name|memset
argument_list|(
name|contents
operator|+
name|input_section
operator|->
name|rawsize
argument_list|,
literal|0
argument_list|,
name|input_section
operator|->
name|size
operator|-
name|input_section
operator|->
name|rawsize
argument_list|)
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|int
name|r_type
decl_stmt|;
name|bfd_boolean
name|undefined_signalled
init|=
name|FALSE
decl_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_MMIX_GNU_VTINHERIT
operator|||
name|r_type
operator|==
name|R_MMIX_GNU_VTENTRY
condition|)
continue|continue;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|howto
operator|=
name|elf_mmix_howto_table
operator|+
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_boolean
name|unresolved_reloc
decl_stmt|;
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|undefined_signalled
argument_list|)
expr_stmt|;
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
block|}
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|elf_discarded_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
comment|/* For relocs against symbols from removed linkonce sections, 	     or sections discarded by a linker script, we just want the 	     section contents zeroed.  Avoid any special processing.  */
name|_bfd_clear_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
block|{
comment|/* This is a relocatable link.  For most relocs we don't have to 	     change anything, unless the reloc is against a section 	     symbol, in which case we have to adjust according to where 	     the section symbol winds up in the output section.  */
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
name|rel
operator|->
name|r_addend
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
comment|/* For PUSHJ stub relocs however, we may need to change the 	     reloc and the section contents, if the reloc doesn't reach 	     beyond the end of the output section and previous stubs. 	     Then we change the section contents to be a PUSHJ to the end 	     of the input section plus stubs (we can do that without using 	     a reloc), and then we change the reloc to be a R_MMIX_PUSHJ 	     at the stub location.  */
if|if
condition|(
name|r_type
operator|==
name|R_MMIX_PUSHJ_STUBBABLE
condition|)
block|{
comment|/* We've already checked whether we need a stub; use that 		 knowledge.  */
if|if
condition|(
name|mmix_elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|pjs
operator|.
name|stub_size
index|[
name|pjsno
index|]
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Rela
name|relcpy
decl_stmt|;
if|if
condition|(
name|mmix_elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|pjs
operator|.
name|stub_size
index|[
name|pjsno
index|]
operator|!=
name|MAX_PUSHJ_STUB_SIZE
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* There's already a PUSHJ insn there, so just fill in 		     the offset bits to the stub.  */
if|if
condition|(
name|mmix_final_link_relocate
argument_list|(
name|elf_mmix_howto_table
operator|+
name|R_MMIX_ADDR19
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
literal|0
argument_list|,
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|size
operator|+
name|mmix_elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|pjs
operator|.
name|stub_offset
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|!=
name|bfd_reloc_ok
condition|)
return|return
name|FALSE
return|;
comment|/* Put a JMP insn at the stub; it goes with the 		     R_MMIX_JMP reloc.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|JMP_INSN_BYTE
operator|<<
literal|24
argument_list|,
name|contents
operator|+
name|size
operator|+
name|mmix_elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|pjs
operator|.
name|stub_offset
argument_list|)
expr_stmt|;
comment|/* Change the reloc to be at the stub, and to a full 		     R_MMIX_JMP reloc.  */
name|rel
operator|->
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|R_MMIX_JMP
argument_list|)
expr_stmt|;
name|rel
operator|->
name|r_offset
operator|=
operator|(
name|size
operator|+
name|mmix_elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|pjs
operator|.
name|stub_offset
operator|)
expr_stmt|;
name|mmix_elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|pjs
operator|.
name|stub_offset
operator|+=
name|MAX_PUSHJ_STUB_SIZE
expr_stmt|;
comment|/* Shift this reloc to the end of the relocs to maintain 		     the r_offset sorted reloc order.  */
name|relcpy
operator|=
operator|*
name|rel
expr_stmt|;
name|memmove
argument_list|(
name|rel
argument_list|,
name|rel
operator|+
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|relend
operator|-
operator|(
name|char
operator|*
operator|)
name|rel
argument_list|)
expr_stmt|;
name|relend
index|[
operator|-
literal|1
index|]
operator|=
name|relcpy
expr_stmt|;
comment|/* Back up one reloc, or else we'd skip the next reloc 		   in turn.  */
name|rel
operator|--
expr_stmt|;
block|}
name|pjsno
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
name|r
operator|=
name|mmix_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|relocation
argument_list|,
name|name
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
name|bfd_boolean
name|check_ok
init|=
name|TRUE
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_overflow
case|:
name|check_ok
operator|=
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
argument_list|(
name|info
argument_list|,
operator|(
name|h
condition|?
operator|&
name|h
operator|->
name|root
else|:
name|NULL
operator|)
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_undefined
case|:
comment|/* We may have sent this message above.  */
if|if
condition|(
operator|!
name|undefined_signalled
condition|)
name|check_ok
operator|=
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|undefined_signalled
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: out of range error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_notsupported
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unsupported relocation error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_dangerous
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: dangerous relocation"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unknown error"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|msg
condition|)
name|check_ok
operator|=
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|check_ok
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform a single relocation.  By default we use the standard BFD    routines.  A few relocs we have to do ourselves.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|mmix_final_link_relocate
parameter_list|(
name|howto
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|r_offset
parameter_list|,
name|r_addend
parameter_list|,
name|relocation
parameter_list|,
name|symname
parameter_list|,
name|symsec
parameter_list|)
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|r_offset
decl_stmt|;
name|bfd_signed_vma
name|r_addend
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
specifier|const
name|char
modifier|*
name|symname
decl_stmt|;
name|asection
modifier|*
name|symsec
decl_stmt|;
block|{
name|bfd_reloc_status_type
name|r
init|=
name|bfd_reloc_ok
decl_stmt|;
name|bfd_vma
name|addr
init|=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|r_offset
operator|)
decl_stmt|;
name|bfd_signed_vma
name|srel
init|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|r_addend
decl_stmt|;
switch|switch
condition|(
name|howto
operator|->
name|type
condition|)
block|{
comment|/* All these are PC-relative.  */
case|case
name|R_MMIX_PUSHJ_STUBBABLE
case|:
case|case
name|R_MMIX_PUSHJ
case|:
case|case
name|R_MMIX_CBRANCH
case|:
case|case
name|R_MMIX_ADDR19
case|:
case|case
name|R_MMIX_GETA
case|:
case|case
name|R_MMIX_ADDR27
case|:
case|case
name|R_MMIX_JMP
case|:
name|contents
operator|+=
name|r_offset
expr_stmt|;
name|srel
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|r_offset
operator|)
expr_stmt|;
name|r
operator|=
name|mmix_elf_perform_relocation
argument_list|(
name|input_section
argument_list|,
name|howto
argument_list|,
name|contents
argument_list|,
name|addr
argument_list|,
name|srel
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MMIX_BASE_PLUS_OFFSET
case|:
if|if
condition|(
name|symsec
operator|==
name|NULL
condition|)
return|return
name|bfd_reloc_undefined
return|;
comment|/* Check that we're not relocating against a register symbol.  */
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|symsec
operator|->
name|owner
argument_list|,
name|symsec
argument_list|)
argument_list|,
name|MMIX_REG_CONTENTS_SECTION_NAME
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|symsec
operator|->
name|owner
argument_list|,
name|symsec
argument_list|)
argument_list|,
name|MMIX_REG_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Note: This is separated out into two messages in order 	     to ease the translation into other languages.  */
if|if
condition|(
name|symname
operator|==
name|NULL
operator|||
operator|*
name|symname
operator|==
literal|0
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: base-plus-offset relocation against register symbol: (unknown) in %s"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_section
operator|->
name|owner
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|symsec
operator|->
name|owner
argument_list|,
name|symsec
argument_list|)
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: base-plus-offset relocation against register symbol: %s in %s"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_section
operator|->
name|owner
argument_list|)
argument_list|,
name|symname
argument_list|,
name|bfd_get_section_name
argument_list|(
name|symsec
operator|->
name|owner
argument_list|,
name|symsec
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_overflow
return|;
block|}
goto|goto
name|do_mmix_reloc
goto|;
case|case
name|R_MMIX_REG_OR_BYTE
case|:
case|case
name|R_MMIX_REG
case|:
comment|/* For now, we handle these alike.  They must refer to an register 	 symbol, which is either relative to the register section and in 	 the range 0..255, or is in the register contents section with vma 	 regno * 8.  */
comment|/* FIXME: A better way to check for reg contents section? 	 FIXME: Postpone section->scaling to mmix_elf_perform_relocation? */
if|if
condition|(
name|symsec
operator|==
name|NULL
condition|)
return|return
name|bfd_reloc_undefined
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|symsec
operator|->
name|owner
argument_list|,
name|symsec
argument_list|)
argument_list|,
name|MMIX_REG_CONTENTS_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|srel
operator|&
literal|7
operator|)
operator|!=
literal|0
operator|||
name|srel
operator|<
literal|32
operator|*
literal|8
operator|||
name|srel
operator|>
literal|255
operator|*
literal|8
condition|)
block|{
comment|/* The bfd_reloc_outofrange return value, though intuitively 		 a better value, will not get us an error.  */
return|return
name|bfd_reloc_overflow
return|;
block|}
name|srel
operator|/=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|symsec
operator|->
name|owner
argument_list|,
name|symsec
argument_list|)
argument_list|,
name|MMIX_REG_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|srel
operator|<
literal|0
operator|||
name|srel
operator|>
literal|255
condition|)
comment|/* The bfd_reloc_outofrange return value, though intuitively a 	       better value, will not get us an error.  */
return|return
name|bfd_reloc_overflow
return|;
block|}
else|else
block|{
comment|/* Note: This is separated out into two messages in order 	     to ease the translation into other languages.  */
if|if
condition|(
name|symname
operator|==
name|NULL
operator|||
operator|*
name|symname
operator|==
literal|0
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: register relocation against non-register symbol: (unknown) in %s"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_section
operator|->
name|owner
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|symsec
operator|->
name|owner
argument_list|,
name|symsec
argument_list|)
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: register relocation against non-register symbol: %s in %s"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_section
operator|->
name|owner
argument_list|)
argument_list|,
name|symname
argument_list|,
name|bfd_get_section_name
argument_list|(
name|symsec
operator|->
name|owner
argument_list|,
name|symsec
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The bfd_reloc_outofrange return value, though intuitively a 	     better value, will not get us an error.  */
return|return
name|bfd_reloc_overflow
return|;
block|}
name|do_mmix_reloc
label|:
name|contents
operator|+=
name|r_offset
expr_stmt|;
name|r
operator|=
name|mmix_elf_perform_relocation
argument_list|(
name|input_section
argument_list|,
name|howto
argument_list|,
name|contents
argument_list|,
name|addr
argument_list|,
name|srel
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MMIX_LOCAL
case|:
comment|/* This isn't a real relocation, it's just an assertion that the 	 final relocation value corresponds to a local register.  We 	 ignore the actual relocation; nothing is changed.  */
block|{
name|asection
modifier|*
name|regsec
init|=
name|bfd_get_section_by_name
argument_list|(
name|input_section
operator|->
name|output_section
operator|->
name|owner
argument_list|,
name|MMIX_REG_CONTENTS_SECTION_NAME
argument_list|)
decl_stmt|;
name|bfd_vma
name|first_global
decl_stmt|;
comment|/* Check that this is an absolute value, or a reference to the 	   register contents section or the register (symbol) section. 	   Absolute numbers can get here as undefined section.  Undefined 	   symbols are signalled elsewhere, so there's no conflict in us 	   accidentally handling it.  */
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|symsec
argument_list|)
operator|&&
operator|!
name|bfd_is_und_section
argument_list|(
name|symsec
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|symsec
operator|->
name|owner
argument_list|,
name|symsec
argument_list|)
argument_list|,
name|MMIX_REG_CONTENTS_SECTION_NAME
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|symsec
operator|->
name|owner
argument_list|,
name|symsec
argument_list|)
argument_list|,
name|MMIX_REG_SECTION_NAME
argument_list|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: directive LOCAL valid only with a register or absolute value"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_section
operator|->
name|owner
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_overflow
return|;
block|}
comment|/* If we don't have a register contents section, then $255 is the 	 first global register.  */
if|if
condition|(
name|regsec
operator|==
name|NULL
condition|)
name|first_global
operator|=
literal|255
expr_stmt|;
else|else
block|{
name|first_global
operator|=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|regsec
argument_list|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|symsec
operator|->
name|owner
argument_list|,
name|symsec
argument_list|)
argument_list|,
name|MMIX_REG_CONTENTS_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|srel
operator|&
literal|7
operator|)
operator|!=
literal|0
operator|||
name|srel
operator|<
literal|32
operator|*
literal|8
operator|||
name|srel
operator|>
literal|255
operator|*
literal|8
condition|)
comment|/* The bfd_reloc_outofrange return value, though 		   intuitively a better value, will not get us an error.  */
return|return
name|bfd_reloc_overflow
return|;
name|srel
operator|/=
literal|8
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|bfd_vma
operator|)
name|srel
operator|>=
name|first_global
condition|)
block|{
comment|/* FIXME: Better error message.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: LOCAL directive: Register $%ld is not a local register.  First global register is $%ld."
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_section
operator|->
name|owner
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|srel
argument_list|,
operator|(
name|long
operator|)
name|first_global
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_overflow
return|;
block|}
block|}
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
break|break;
default|default:
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_section
operator|->
name|owner
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|r_addend
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the section that should be marked against GC for a given    relocation.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|mmix_elf_gc_mark_hook
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
switch|switch
condition|(
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_MMIX_GNU_VTINHERIT
case|:
case|case
name|R_MMIX_GNU_VTENTRY
case|:
return|return
name|NULL
return|;
block|}
return|return
name|_bfd_elf_gc_mark_hook
argument_list|(
name|sec
argument_list|,
name|info
argument_list|,
name|rel
argument_list|,
name|h
argument_list|,
name|sym
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Update relocation info for a GC-excluded section.  We could supposedly    perform the allocation after GC, but there's no suitable hook between    GC (or section merge) and the point when all input sections must be    present.  Better to waste some memory and (perhaps) a little time.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mmix_elf_gc_sweep_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|bpo_reloc_section_info
modifier|*
name|bpodata
init|=
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|bpo
operator|.
name|reloc
decl_stmt|;
name|asection
modifier|*
name|allocated_gregs_section
decl_stmt|;
comment|/* If no bpodata here, we have nothing to do.  */
if|if
condition|(
name|bpodata
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|allocated_gregs_section
operator|=
name|bpodata
operator|->
name|bpo_greg_section
expr_stmt|;
name|mmix_elf_section_data
argument_list|(
name|allocated_gregs_section
argument_list|)
operator|->
name|bpo
operator|.
name|greg
operator|->
name|n_bpo_relocs
operator|-=
name|bpodata
operator|->
name|n_bpo_relocs_this_section
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Sort register relocs to come before expanding relocs.  */
end_comment

begin_function
specifier|static
name|int
name|mmix_elf_sort_relocs
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
specifier|const
name|PTR
name|p1
decl_stmt|;
specifier|const
name|PTR
name|p2
decl_stmt|;
block|{
specifier|const
name|Elf_Internal_Rela
modifier|*
name|r1
init|=
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
name|p1
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|r2
init|=
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
name|p2
decl_stmt|;
name|int
name|r1_is_reg
decl_stmt|,
name|r2_is_reg
decl_stmt|;
comment|/* Sort primarily on r_offset& ~3, so relocs are done to consecutive      insns.  */
if|if
condition|(
operator|(
name|r1
operator|->
name|r_offset
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|3
operator|)
operator|>
operator|(
name|r2
operator|->
name|r_offset
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|3
operator|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
name|r1
operator|->
name|r_offset
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|3
operator|)
operator|<
operator|(
name|r2
operator|->
name|r_offset
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|3
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|r1_is_reg
operator|=
operator|(
name|ELF64_R_TYPE
argument_list|(
name|r1
operator|->
name|r_info
argument_list|)
operator|==
name|R_MMIX_REG_OR_BYTE
operator|||
name|ELF64_R_TYPE
argument_list|(
name|r1
operator|->
name|r_info
argument_list|)
operator|==
name|R_MMIX_REG
operator|)
expr_stmt|;
name|r2_is_reg
operator|=
operator|(
name|ELF64_R_TYPE
argument_list|(
name|r2
operator|->
name|r_info
argument_list|)
operator|==
name|R_MMIX_REG_OR_BYTE
operator|||
name|ELF64_R_TYPE
argument_list|(
name|r2
operator|->
name|r_info
argument_list|)
operator|==
name|R_MMIX_REG
operator|)
expr_stmt|;
if|if
condition|(
name|r1_is_reg
operator|!=
name|r2_is_reg
condition|)
return|return
name|r2_is_reg
operator|-
name|r1_is_reg
return|;
comment|/* Neither or both are register relocs.  Then sort on full offset.  */
if|if
condition|(
name|r1
operator|->
name|r_offset
operator|>
name|r2
operator|->
name|r_offset
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|r1
operator|->
name|r_offset
operator|<
name|r2
operator|->
name|r_offset
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Subset of mmix_elf_check_relocs, common to ELF and mmo linking.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mmix_elf_check_common_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|bfd
modifier|*
name|bpo_greg_owner
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|allocated_gregs_section
init|=
name|NULL
decl_stmt|;
name|struct
name|bpo_greg_section_info
modifier|*
name|gregdata
init|=
name|NULL
decl_stmt|;
name|struct
name|bpo_reloc_section_info
modifier|*
name|bpodata
init|=
name|NULL
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
comment|/* We currently have to abuse this COFF-specific member, since there's      no target-machine-dedicated member.  There's no alternative outside      the bfd_link_info struct; we can't specialize a hash-table since      they're different between ELF and mmo.  */
name|bpo_greg_owner
operator|=
operator|(
name|bfd
operator|*
operator|)
name|info
operator|->
name|base_file
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
switch|switch
condition|(
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
comment|/* This relocation causes a GREG allocation.  We need to count 	     them, and we need to create a section for them, so we need an 	     object to fake as the owner of that section.  We can't use 	     the ELF dynobj for this, since the ELF bits assume lots of 	     DSO-related stuff if that member is non-NULL.  */
case|case
name|R_MMIX_BASE_PLUS_OFFSET
case|:
comment|/* We don't do anything with this reloc for a relocatable link.  */
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
break|break;
if|if
condition|(
name|bpo_greg_owner
operator|==
name|NULL
condition|)
block|{
name|bpo_greg_owner
operator|=
name|abfd
expr_stmt|;
name|info
operator|->
name|base_file
operator|=
operator|(
name|PTR
operator|)
name|bpo_greg_owner
expr_stmt|;
block|}
if|if
condition|(
name|allocated_gregs_section
operator|==
name|NULL
condition|)
name|allocated_gregs_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|bpo_greg_owner
argument_list|,
name|MMIX_LD_ALLOCATED_REG_CONTENTS_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocated_gregs_section
operator|==
name|NULL
condition|)
block|{
name|allocated_gregs_section
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|bpo_greg_owner
argument_list|,
name|MMIX_LD_ALLOCATED_REG_CONTENTS_SECTION_NAME
argument_list|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
argument_list|)
expr_stmt|;
comment|/* Setting both SEC_ALLOC and SEC_LOAD means the section is 		 treated like any other section, and we'd get errors for 		 address overlap with the text section.  Let's set none of 		 those flags, as that is what currently happens for usual 		 GREG allocations, and that works.  */
if|if
condition|(
name|allocated_gregs_section
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|bpo_greg_owner
argument_list|,
name|allocated_gregs_section
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|gregdata
operator|=
operator|(
expr|struct
name|bpo_greg_section_info
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|bpo_greg_owner
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bpo_greg_section_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gregdata
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|mmix_elf_section_data
argument_list|(
name|allocated_gregs_section
argument_list|)
operator|->
name|bpo
operator|.
name|greg
operator|=
name|gregdata
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gregdata
operator|==
name|NULL
condition|)
name|gregdata
operator|=
name|mmix_elf_section_data
argument_list|(
name|allocated_gregs_section
argument_list|)
operator|->
name|bpo
operator|.
name|greg
expr_stmt|;
comment|/* Get ourselves some auxiliary info for the BPO-relocs.  */
if|if
condition|(
name|bpodata
operator|==
name|NULL
condition|)
block|{
comment|/* No use doing a separate iteration pass to find the upper 		 limit - just use the number of relocs.  */
name|bpodata
operator|=
operator|(
expr|struct
name|bpo_reloc_section_info
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|bpo_greg_owner
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bpo_reloc_section_info
argument_list|)
operator|*
operator|(
name|sec
operator|->
name|reloc_count
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpodata
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|bpo
operator|.
name|reloc
operator|=
name|bpodata
expr_stmt|;
name|bpodata
operator|->
name|first_base_plus_offset_reloc
operator|=
name|bpodata
operator|->
name|bpo_index
operator|=
name|gregdata
operator|->
name|n_max_bpo_relocs
expr_stmt|;
name|bpodata
operator|->
name|bpo_greg_section
operator|=
name|allocated_gregs_section
expr_stmt|;
name|bpodata
operator|->
name|n_bpo_relocs_this_section
operator|=
literal|0
expr_stmt|;
block|}
name|bpodata
operator|->
name|n_bpo_relocs_this_section
operator|++
expr_stmt|;
name|gregdata
operator|->
name|n_max_bpo_relocs
operator|++
expr_stmt|;
comment|/* We don't get another chance to set this before GC; we've not 	     set up any hook that runs before GC.  */
name|gregdata
operator|->
name|n_bpo_relocs
operator|=
name|gregdata
operator|->
name|n_max_bpo_relocs
expr_stmt|;
break|break;
case|case
name|R_MMIX_PUSHJ_STUBBABLE
case|:
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|n_pushj_relocs
operator|++
expr_stmt|;
break|break;
block|}
block|}
comment|/* Allocate per-reloc stub storage and initialize it to the max stub      size.  */
if|if
condition|(
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|n_pushj_relocs
operator|!=
literal|0
condition|)
block|{
name|size_t
name|i
decl_stmt|;
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|stub_size
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|n_pushj_relocs
operator|*
sizeof|sizeof
argument_list|(
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|stub_size
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|stub_size
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|n_pushj_relocs
condition|;
name|i
operator|++
control|)
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|stub_size
index|[
name|i
index|]
operator|=
name|MAX_PUSHJ_STUB_SIZE
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mmix_elf_check_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|,
modifier|*
modifier|*
name|sym_hashes_end
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_hashes_end
operator|=
name|sym_hashes
operator|+
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf64_External_Sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|sym_hashes_end
operator|-=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
comment|/* First we sort the relocs so that any register relocs come before      expansion-relocs to the same insn.  FIXME: Not done for mmo.  */
name|qsort
argument_list|(
operator|(
name|PTR
operator|)
name|relocs
argument_list|,
name|sec
operator|->
name|reloc_count
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
argument_list|,
name|mmix_elf_sort_relocs
argument_list|)
expr_stmt|;
comment|/* Do the common part.  */
if|if
condition|(
operator|!
name|mmix_elf_check_common_relocs
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|sec
argument_list|,
name|relocs
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
switch|switch
condition|(
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
comment|/* This relocation describes the C++ object vtable hierarchy.            Reconstruct it for later use during GC.  */
case|case
name|R_MMIX_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually            used.  Record for later use during GC.  */
case|case
name|R_MMIX_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Wrapper for mmix_elf_check_common_relocs, called when linking to mmo.    Copied from elf_link_add_object_symbols.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mmix_check_all_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|asection
modifier|*
name|o
decl_stmt|;
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|bfd_boolean
name|ok
decl_stmt|;
if|if
condition|(
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|o
operator|->
name|reloc_count
operator|==
literal|0
operator|||
operator|(
operator|(
name|info
operator|->
name|strip
operator|==
name|strip_all
operator|||
name|info
operator|->
name|strip
operator|==
name|strip_debugger
operator|)
operator|&&
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|)
operator|||
name|bfd_is_abs_section
argument_list|(
name|o
operator|->
name|output_section
argument_list|)
condition|)
continue|continue;
name|internal_relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|ok
operator|=
name|mmix_elf_check_common_relocs
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|o
argument_list|,
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Change symbols relative to the reg contents section to instead be to    the register section, and scale them down to correspond to the register    number.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mmix_elf_link_output_symbol_hook
parameter_list|(
name|info
parameter_list|,
name|name
parameter_list|,
name|sym
parameter_list|,
name|input_sec
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|input_sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|input_sec
operator|!=
name|NULL
operator|&&
name|input_sec
operator|->
name|name
operator|!=
name|NULL
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_SECTION
operator|&&
name|strcmp
argument_list|(
name|input_sec
operator|->
name|name
argument_list|,
name|MMIX_REG_CONTENTS_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym
operator|->
name|st_value
operator|/=
literal|8
expr_stmt|;
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_REGISTER
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* We fake a register section that holds values that are register numbers.    Having a SHN_REGISTER and register section translates better to other    formats (e.g. mmo) than for example a STT_REGISTER attribute.    This section faking is based on a construct in elf32-mips.c.  */
end_comment

begin_decl_stmt
specifier|static
name|asection
name|mmix_elf_reg_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
name|mmix_elf_reg_section_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|mmix_elf_reg_section_symbol_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle the special section numbers that a symbol may use.  */
end_comment

begin_function
name|void
name|mmix_elf_symbol_processing
parameter_list|(
name|abfd
parameter_list|,
name|asym
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asymbol
modifier|*
name|asym
decl_stmt|;
block|{
name|elf_symbol_type
modifier|*
name|elfsym
decl_stmt|;
name|elfsym
operator|=
operator|(
name|elf_symbol_type
operator|*
operator|)
name|asym
expr_stmt|;
switch|switch
condition|(
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_shndx
condition|)
block|{
case|case
name|SHN_REGISTER
case|:
if|if
condition|(
name|mmix_elf_reg_section
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* Initialize the register section.  */
name|mmix_elf_reg_section
operator|.
name|name
operator|=
name|MMIX_REG_SECTION_NAME
expr_stmt|;
name|mmix_elf_reg_section
operator|.
name|flags
operator|=
name|SEC_NO_FLAGS
expr_stmt|;
name|mmix_elf_reg_section
operator|.
name|output_section
operator|=
operator|&
name|mmix_elf_reg_section
expr_stmt|;
name|mmix_elf_reg_section
operator|.
name|symbol
operator|=
operator|&
name|mmix_elf_reg_section_symbol
expr_stmt|;
name|mmix_elf_reg_section
operator|.
name|symbol_ptr_ptr
operator|=
operator|&
name|mmix_elf_reg_section_symbol_ptr
expr_stmt|;
name|mmix_elf_reg_section_symbol
operator|.
name|name
operator|=
name|MMIX_REG_SECTION_NAME
expr_stmt|;
name|mmix_elf_reg_section_symbol
operator|.
name|flags
operator|=
name|BSF_SECTION_SYM
expr_stmt|;
name|mmix_elf_reg_section_symbol
operator|.
name|section
operator|=
operator|&
name|mmix_elf_reg_section
expr_stmt|;
name|mmix_elf_reg_section_symbol_ptr
operator|=
operator|&
name|mmix_elf_reg_section_symbol
expr_stmt|;
block|}
name|asym
operator|->
name|section
operator|=
operator|&
name|mmix_elf_reg_section
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Given a BFD section, try to locate the corresponding ELF section    index.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mmix_elf_section_from_bfd_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|retval
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|MMIX_REG_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|retval
operator|=
name|SHN_REGISTER
expr_stmt|;
else|else
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Hook called by the linker routine which adds symbols from an object    file.  We must handle the special SHN_REGISTER section number here.     We also check that we only have *one* each of the section-start    symbols, since otherwise having two with the same value would cause    them to be "merged", but with the contents serialized.  */
end_comment

begin_function
name|bfd_boolean
name|mmix_elf_add_symbol_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sym
parameter_list|,
name|namep
parameter_list|,
name|flagsp
parameter_list|,
name|secp
parameter_list|,
name|valp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|namep
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|flagword
modifier|*
name|flagsp
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secp
decl_stmt|;
name|bfd_vma
modifier|*
name|valp
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_REGISTER
condition|)
block|{
operator|*
name|secp
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
name|MMIX_REG_SECTION_NAME
argument_list|)
expr_stmt|;
operator|(
operator|*
name|secp
operator|)
operator|->
name|flags
operator||=
name|SEC_LINKER_CREATED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|namep
operator|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
operator|(
operator|*
name|namep
operator|)
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
operator|(
operator|*
name|namep
operator|)
index|[
literal|2
index|]
operator|==
literal|'.'
operator|&&
name|CONST_STRNEQ
argument_list|(
operator|*
name|namep
argument_list|,
name|MMIX_LOC_SECTION_START_SYMBOL_PREFIX
argument_list|)
condition|)
block|{
comment|/* See if we have another one.  */
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
init|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
operator|*
name|namep
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_undefined
condition|)
block|{
comment|/* How do we get the asymbol (or really: the filename) from h? 	     h->u.def.section->owner is NULL.  */
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: Error: multiple definition of `%s'; start of %s is set in a earlier linked file\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|*
name|namep
argument_list|,
operator|*
name|namep
operator|+
name|strlen
argument_list|(
name|MMIX_LOC_SECTION_START_SYMBOL_PREFIX
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* We consider symbols matching "L.*:[0-9]+" to be local symbols.  */
end_comment

begin_function
name|bfd_boolean
name|mmix_elf_is_local_label_name
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|colpos
decl_stmt|;
name|int
name|digits
decl_stmt|;
comment|/* Also include the default local-label definition.  */
if|if
condition|(
name|_bfd_elf_is_local_label_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|*
name|name
operator|!=
literal|'L'
condition|)
return|return
name|FALSE
return|;
comment|/* If there's no ":", or more than one, it's not a local symbol.  */
name|colpos
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|colpos
operator|==
name|NULL
operator|||
name|strchr
argument_list|(
name|colpos
operator|+
literal|1
argument_list|,
literal|':'
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Check that there are remaining characters and that they are digits.  */
if|if
condition|(
name|colpos
index|[
literal|1
index|]
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
name|digits
operator|=
name|strspn
argument_list|(
name|colpos
operator|+
literal|1
argument_list|,
literal|"0123456789"
argument_list|)
expr_stmt|;
return|return
name|digits
operator|!=
literal|0
operator|&&
name|colpos
index|[
literal|1
operator|+
name|digits
index|]
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* We get rid of the register section here.  */
end_comment

begin_function
name|bfd_boolean
name|mmix_elf_final_link
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
comment|/* We never output a register section, though we create one for      temporary measures.  Check that nobody entered contents into it.  */
name|asection
modifier|*
name|reg_section
decl_stmt|;
name|reg_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|MMIX_REG_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_section
operator|!=
name|NULL
condition|)
block|{
comment|/* FIXME: Pass error state gracefully.  */
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|reg_section
argument_list|)
operator|&
name|SEC_HAS_CONTENTS
condition|)
name|_bfd_abort
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|_
argument_list|(
literal|"Register section has contents\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Really remove the section, if it hasn't already been done.  */
if|if
condition|(
operator|!
name|bfd_section_removed_from_list
argument_list|(
name|abfd
argument_list|,
name|reg_section
argument_list|)
condition|)
block|{
name|bfd_section_list_remove
argument_list|(
name|abfd
argument_list|,
name|reg_section
argument_list|)
expr_stmt|;
operator|--
name|abfd
operator|->
name|section_count
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|bfd_elf_final_link
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Since this section is marked SEC_LINKER_CREATED, it isn't output by      the regular linker machinery.  We do it here, like other targets with      special sections.  */
if|if
condition|(
name|info
operator|->
name|base_file
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|greg_section
init|=
name|bfd_get_section_by_name
argument_list|(
operator|(
name|bfd
operator|*
operator|)
name|info
operator|->
name|base_file
argument_list|,
name|MMIX_LD_ALLOCATED_REG_CONTENTS_SECTION_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_contents
argument_list|(
name|abfd
argument_list|,
name|greg_section
operator|->
name|output_section
argument_list|,
name|greg_section
operator|->
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
name|greg_section
operator|->
name|output_offset
argument_list|,
name|greg_section
operator|->
name|size
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* We need to include the maximum size of PUSHJ-stubs in the initial    section size.  This is expected to shrink during linker relaxation.  */
end_comment

begin_function
specifier|static
name|void
name|mmix_set_relaxable_size
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
name|ptr
decl_stmt|;
comment|/* Make sure we only do this for section where we know we want this,      otherwise we might end up resetting the size of COMMONs.  */
if|if
condition|(
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|n_pushj_relocs
operator|==
literal|0
condition|)
return|return;
name|sec
operator|->
name|rawsize
operator|=
name|sec
operator|->
name|size
expr_stmt|;
name|sec
operator|->
name|size
operator|+=
operator|(
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|n_pushj_relocs
operator|*
name|MAX_PUSHJ_STUB_SIZE
operator|)
expr_stmt|;
comment|/* For use in relocatable link, we start with a max stubs size.  See      mmix_elf_relax_section.  */
if|if
condition|(
name|info
operator|->
name|relocatable
operator|&&
name|sec
operator|->
name|output_section
condition|)
name|mmix_elf_section_data
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
operator|->
name|pjs
operator|.
name|stubs_size_sum
operator|+=
operator|(
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|n_pushj_relocs
operator|*
name|MAX_PUSHJ_STUB_SIZE
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize stuff for the linker-generated GREGs to match    R_MMIX_BASE_PLUS_OFFSET relocs seen by the linker.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mmix_before_linker_allocation
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|asection
modifier|*
name|bpo_gregs_section
decl_stmt|;
name|bfd
modifier|*
name|bpo_greg_owner
decl_stmt|;
name|struct
name|bpo_greg_section_info
modifier|*
name|gregdata
decl_stmt|;
name|size_t
name|n_gregs
decl_stmt|;
name|bfd_vma
name|gregs_size
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|size_t
modifier|*
name|bpo_reloc_indexes
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
comment|/* Set the initial size of sections.  */
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
name|bfd_map_over_sections
argument_list|(
name|ibfd
argument_list|,
name|mmix_set_relaxable_size
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* The bpo_greg_owner bfd is supposed to have been set by      mmix_elf_check_relocs when the first R_MMIX_BASE_PLUS_OFFSET is seen.      If there is no such object, there was no R_MMIX_BASE_PLUS_OFFSET.  */
name|bpo_greg_owner
operator|=
operator|(
name|bfd
operator|*
operator|)
name|info
operator|->
name|base_file
expr_stmt|;
if|if
condition|(
name|bpo_greg_owner
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|bpo_gregs_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|bpo_greg_owner
argument_list|,
name|MMIX_LD_ALLOCATED_REG_CONTENTS_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpo_gregs_section
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* We use the target-data handle in the ELF section data.  */
name|gregdata
operator|=
name|mmix_elf_section_data
argument_list|(
name|bpo_gregs_section
argument_list|)
operator|->
name|bpo
operator|.
name|greg
expr_stmt|;
if|if
condition|(
name|gregdata
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|n_gregs
operator|=
name|gregdata
operator|->
name|n_bpo_relocs
expr_stmt|;
name|gregdata
operator|->
name|n_allocated_bpo_gregs
operator|=
name|n_gregs
expr_stmt|;
comment|/* When this reaches zero during relaxation, all entries have been      filled in and the size of the linker gregs can be calculated.  */
name|gregdata
operator|->
name|n_remaining_bpo_relocs_this_relaxation_round
operator|=
name|n_gregs
expr_stmt|;
comment|/* Set the zeroth-order estimate for the GREGs size.  */
name|gregs_size
operator|=
name|n_gregs
operator|*
literal|8
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_size
argument_list|(
name|bpo_greg_owner
argument_list|,
name|bpo_gregs_section
argument_list|,
name|gregs_size
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Allocate and set up the GREG arrays.  They're filled in at relaxation      time.  Note that we must use the max number ever noted for the array,      since the index numbers were created before GC.  */
name|gregdata
operator|->
name|reloc_request
operator|=
name|bfd_zalloc
argument_list|(
name|bpo_greg_owner
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bpo_reloc_request
argument_list|)
operator|*
name|gregdata
operator|->
name|n_max_bpo_relocs
argument_list|)
expr_stmt|;
name|gregdata
operator|->
name|bpo_reloc_indexes
operator|=
name|bpo_reloc_indexes
operator|=
name|bfd_alloc
argument_list|(
name|bpo_greg_owner
argument_list|,
name|gregdata
operator|->
name|n_max_bpo_relocs
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpo_reloc_indexes
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* The default order is an identity mapping.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|gregdata
operator|->
name|n_max_bpo_relocs
condition|;
name|i
operator|++
control|)
block|{
name|bpo_reloc_indexes
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|gregdata
operator|->
name|reloc_request
index|[
name|i
index|]
operator|.
name|bpo_reloc_no
operator|=
name|i
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fill in contents in the linker allocated gregs.  Everything is    calculated at this point; we just move the contents into place here.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_mmix_after_linker_allocation
parameter_list|(
name|abfd
parameter_list|,
name|link_info
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
block|{
name|asection
modifier|*
name|bpo_gregs_section
decl_stmt|;
name|bfd
modifier|*
name|bpo_greg_owner
decl_stmt|;
name|struct
name|bpo_greg_section_info
modifier|*
name|gregdata
decl_stmt|;
name|size_t
name|n_gregs
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|size_t
name|lastreg
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
comment|/* The bpo_greg_owner bfd is supposed to have been set by mmix_elf_check_relocs      when the first R_MMIX_BASE_PLUS_OFFSET is seen.  If there is no such      object, there was no R_MMIX_BASE_PLUS_OFFSET.  */
name|bpo_greg_owner
operator|=
operator|(
name|bfd
operator|*
operator|)
name|link_info
operator|->
name|base_file
expr_stmt|;
if|if
condition|(
name|bpo_greg_owner
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|bpo_gregs_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|bpo_greg_owner
argument_list|,
name|MMIX_LD_ALLOCATED_REG_CONTENTS_SECTION_NAME
argument_list|)
expr_stmt|;
comment|/* This can't happen without DSO handling.  When DSOs are handled      without any R_MMIX_BASE_PLUS_OFFSET seen, there will be no such      section.  */
if|if
condition|(
name|bpo_gregs_section
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* We use the target-data handle in the ELF section data.  */
name|gregdata
operator|=
name|mmix_elf_section_data
argument_list|(
name|bpo_gregs_section
argument_list|)
operator|->
name|bpo
operator|.
name|greg
expr_stmt|;
if|if
condition|(
name|gregdata
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|n_gregs
operator|=
name|gregdata
operator|->
name|n_allocated_bpo_gregs
expr_stmt|;
name|bpo_gregs_section
operator|->
name|contents
operator|=
name|contents
operator|=
name|bfd_alloc
argument_list|(
name|bpo_greg_owner
argument_list|,
name|bpo_gregs_section
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Sanity check: If these numbers mismatch, some relocation has not been      accounted for and the rest of gregdata is probably inconsistent.      It's a bug, but it's more helpful to identify it than segfaulting      below.  */
if|if
condition|(
name|gregdata
operator|->
name|n_remaining_bpo_relocs_this_relaxation_round
operator|!=
name|gregdata
operator|->
name|n_bpo_relocs
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Internal inconsistency: remaining %u != max %u.\n\   Please report this bug."
argument_list|)
argument_list|,
name|gregdata
operator|->
name|n_remaining_bpo_relocs_this_relaxation_round
argument_list|,
name|gregdata
operator|->
name|n_bpo_relocs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|lastreg
operator|=
literal|255
operator|,
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_gregs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|gregdata
operator|->
name|reloc_request
index|[
name|i
index|]
operator|.
name|regindex
operator|!=
name|lastreg
condition|)
block|{
name|bfd_put_64
argument_list|(
name|bpo_greg_owner
argument_list|,
name|gregdata
operator|->
name|reloc_request
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|contents
operator|+
name|j
operator|*
literal|8
argument_list|)
expr_stmt|;
name|lastreg
operator|=
name|gregdata
operator|->
name|reloc_request
index|[
name|i
index|]
operator|.
name|regindex
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Sort valid relocs to come before non-valid relocs, then on increasing    value.  */
end_comment

begin_function
specifier|static
name|int
name|bpo_reloc_request_sort_fn
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
specifier|const
name|PTR
name|p1
decl_stmt|;
specifier|const
name|PTR
name|p2
decl_stmt|;
block|{
specifier|const
name|struct
name|bpo_reloc_request
modifier|*
name|r1
init|=
operator|(
specifier|const
expr|struct
name|bpo_reloc_request
operator|*
operator|)
name|p1
decl_stmt|;
specifier|const
name|struct
name|bpo_reloc_request
modifier|*
name|r2
init|=
operator|(
specifier|const
expr|struct
name|bpo_reloc_request
operator|*
operator|)
name|p2
decl_stmt|;
comment|/* Primary function is validity; non-valid relocs sorted after valid      ones.  */
if|if
condition|(
name|r1
operator|->
name|valid
operator|!=
name|r2
operator|->
name|valid
condition|)
return|return
name|r2
operator|->
name|valid
operator|-
name|r1
operator|->
name|valid
return|;
comment|/* Then sort on value.  Don't simplify and return just the difference of      the values: the upper bits of the 64-bit value would be truncated on      a host with 32-bit ints.  */
if|if
condition|(
name|r1
operator|->
name|value
operator|!=
name|r2
operator|->
name|value
condition|)
return|return
name|r1
operator|->
name|value
operator|>
name|r2
operator|->
name|value
condition|?
literal|1
else|:
operator|-
literal|1
return|;
comment|/* As a last re-sort, use the relocation number, so we get a stable      sort.  The *addresses* aren't stable since items are swapped during      sorting.  It depends on the qsort implementation if this actually      happens.  */
return|return
name|r1
operator|->
name|bpo_reloc_no
operator|>
name|r2
operator|->
name|bpo_reloc_no
condition|?
literal|1
else|:
operator|(
name|r1
operator|->
name|bpo_reloc_no
operator|<
name|r2
operator|->
name|bpo_reloc_no
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* For debug use only.  Dumps the global register allocations resulting    from base-plus-offset relocs.  */
end_comment

begin_function
name|void
name|mmix_dump_bpo_gregs
parameter_list|(
name|link_info
parameter_list|,
name|pf
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|bfd_error_handler_type
name|pf
decl_stmt|;
block|{
name|bfd
modifier|*
name|bpo_greg_owner
decl_stmt|;
name|asection
modifier|*
name|bpo_gregs_section
decl_stmt|;
name|struct
name|bpo_greg_section_info
modifier|*
name|gregdata
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|link_info
operator|==
name|NULL
operator|||
name|link_info
operator|->
name|base_file
operator|==
name|NULL
condition|)
return|return;
name|bpo_greg_owner
operator|=
operator|(
name|bfd
operator|*
operator|)
name|link_info
operator|->
name|base_file
expr_stmt|;
name|bpo_gregs_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|bpo_greg_owner
argument_list|,
name|MMIX_LD_ALLOCATED_REG_CONTENTS_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpo_gregs_section
operator|==
name|NULL
condition|)
return|return;
name|gregdata
operator|=
name|mmix_elf_section_data
argument_list|(
name|bpo_gregs_section
argument_list|)
operator|->
name|bpo
operator|.
name|greg
expr_stmt|;
if|if
condition|(
name|gregdata
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|pf
operator|==
name|NULL
condition|)
name|pf
operator|=
name|_bfd_error_handler
expr_stmt|;
comment|/* These format strings are not translated.  They are for debug purposes      only and never displayed to an end user.  Should they escape, we      surely want them in original.  */
call|(
modifier|*
name|pf
call|)
argument_list|(
literal|" n_bpo_relocs: %u\n n_max_bpo_relocs: %u\n n_remain...round: %u\n\  n_allocated_bpo_gregs: %u\n"
argument_list|,
name|gregdata
operator|->
name|n_bpo_relocs
argument_list|,
name|gregdata
operator|->
name|n_max_bpo_relocs
argument_list|,
name|gregdata
operator|->
name|n_remaining_bpo_relocs_this_relaxation_round
argument_list|,
name|gregdata
operator|->
name|n_allocated_bpo_gregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|gregdata
operator|->
name|reloc_request
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|gregdata
operator|->
name|n_max_bpo_relocs
condition|;
name|i
operator|++
control|)
call|(
modifier|*
name|pf
call|)
argument_list|(
literal|"%4u (%4u)/%4u#%u: 0x%08lx%08lx  r: %3u o: %3u\n"
argument_list|,
name|i
argument_list|,
operator|(
name|gregdata
operator|->
name|bpo_reloc_indexes
operator|!=
name|NULL
condition|?
name|gregdata
operator|->
name|bpo_reloc_indexes
index|[
name|i
index|]
else|:
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|)
argument_list|,
name|gregdata
operator|->
name|reloc_request
index|[
name|i
index|]
operator|.
name|bpo_reloc_no
argument_list|,
name|gregdata
operator|->
name|reloc_request
index|[
name|i
index|]
operator|.
name|valid
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|gregdata
operator|->
name|reloc_request
index|[
name|i
index|]
operator|.
name|value
operator|>>
literal|32
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|gregdata
operator|->
name|reloc_request
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|gregdata
operator|->
name|reloc_request
index|[
name|i
index|]
operator|.
name|regindex
argument_list|,
name|gregdata
operator|->
name|reloc_request
index|[
name|i
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This links all R_MMIX_BASE_PLUS_OFFSET relocs into a special array, and    when the last such reloc is done, an index-array is sorted according to    the values and iterated over to produce register numbers (indexed by 0    from the first allocated register number) and offsets for use in real    relocation.     PUSHJ stub accounting is also done here.     Symbol- and reloc-reading infrastructure copied from elf-m10200.c.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mmix_elf_relax_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|link_info
parameter_list|,
name|again
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|bfd_boolean
modifier|*
name|again
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|asection
modifier|*
name|bpo_gregs_section
init|=
name|NULL
decl_stmt|;
name|struct
name|bpo_greg_section_info
modifier|*
name|gregdata
decl_stmt|;
name|struct
name|bpo_reloc_section_info
modifier|*
name|bpodata
init|=
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|bpo
operator|.
name|reloc
decl_stmt|;
comment|/* The initialization is to quiet compiler warnings.  The value is to      spot a missing actual initialization.  */
name|size_t
name|bpono
init|=
operator|(
name|size_t
operator|)
operator|-
literal|1
decl_stmt|;
name|size_t
name|pjsno
init|=
literal|0
decl_stmt|;
name|bfd
modifier|*
name|bpo_greg_owner
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|size
init|=
name|sec
operator|->
name|rawsize
condition|?
name|sec
operator|->
name|rawsize
else|:
name|sec
operator|->
name|size
decl_stmt|;
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|stubs_size_sum
operator|=
literal|0
expr_stmt|;
comment|/* Assume nothing changes.  */
operator|*
name|again
operator|=
name|FALSE
expr_stmt|;
comment|/* We don't have to do anything if this section does not have relocs, or      if this is not a code section.  */
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|sec
operator|->
name|reloc_count
operator|==
literal|0
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|!=
literal|0
comment|/* If no R_MMIX_BASE_PLUS_OFFSET relocs and no PUSHJ-stub relocs,          then nothing to do.  */
operator|||
operator|(
name|bpodata
operator|==
name|NULL
operator|&&
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|n_pushj_relocs
operator|==
literal|0
operator|)
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|bpo_greg_owner
operator|=
operator|(
name|bfd
operator|*
operator|)
name|link_info
operator|->
name|base_file
expr_stmt|;
if|if
condition|(
name|bpodata
operator|!=
name|NULL
condition|)
block|{
name|bpo_gregs_section
operator|=
name|bpodata
operator|->
name|bpo_greg_section
expr_stmt|;
name|gregdata
operator|=
name|mmix_elf_section_data
argument_list|(
name|bpo_gregs_section
argument_list|)
operator|->
name|bpo
operator|.
name|greg
expr_stmt|;
name|bpono
operator|=
name|bpodata
operator|->
name|first_base_plus_offset_reloc
expr_stmt|;
block|}
else|else
name|gregdata
operator|=
name|NULL
expr_stmt|;
comment|/* Get a copy of the native relocations.  */
name|internal_relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* Walk through them looking for relaxing opportunities.  */
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|symval
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
comment|/* We only process two relocs.  */
if|if
condition|(
name|ELF64_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_MMIX_BASE_PLUS_OFFSET
operator|&&
name|ELF64_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_MMIX_PUSHJ_STUBBABLE
condition|)
continue|continue;
comment|/* We process relocs in a distinctly different way when this is a 	 relocatable link (for one, we don't look at symbols), so we avoid 	 mixing its code with that for the "normal" relaxation.  */
if|if
condition|(
name|link_info
operator|->
name|relocatable
condition|)
block|{
comment|/* The only transformation in a relocatable link is to generate 	     a full stub at the location of the stub calculated for the 	     input section, if the relocated stub location, the end of the 	     output section plus earlier stubs, cannot be reached.  Thus 	     relocatable linking can only lead to worse code, but it still 	     works.  */
if|if
condition|(
name|ELF64_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
name|R_MMIX_PUSHJ_STUBBABLE
condition|)
block|{
comment|/* If we can reach the end of the output-section and beyond 		 any current stubs, then we don't need a stub for this 		 reloc.  The relaxed order of output stub allocation may 		 not exactly match the straightforward order, so we always 		 assume presence of output stubs, which will allow 		 relaxation only on relocations indifferent to the 		 presence of output stub allocations for other relocations 		 and thus the order of output stub allocation.  */
if|if
condition|(
name|bfd_check_overflow
argument_list|(
name|complain_overflow_signed
argument_list|,
literal|19
argument_list|,
literal|0
argument_list|,
name|bfd_arch_bits_per_address
argument_list|(
name|abfd
argument_list|)
argument_list|,
comment|/* Output-stub location.  */
name|sec
operator|->
name|output_section
operator|->
name|rawsize
operator|+
operator|(
name|mmix_elf_section_data
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
operator|->
name|pjs
operator|.
name|stubs_size_sum
operator|)
comment|/* Location of this PUSHJ reloc.  */
operator|-
operator|(
name|sec
operator|->
name|output_offset
operator|+
name|irel
operator|->
name|r_offset
operator|)
comment|/* Don't count *this* stub twice.  */
operator|-
operator|(
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|stub_size
index|[
name|pjsno
index|]
operator|+
name|MAX_PUSHJ_STUB_SIZE
operator|)
argument_list|)
operator|==
name|bfd_reloc_ok
condition|)
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|stub_size
index|[
name|pjsno
index|]
operator|=
literal|0
expr_stmt|;
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|stubs_size_sum
operator|+=
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|stub_size
index|[
name|pjsno
index|]
expr_stmt|;
name|pjsno
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Get the value of the symbol referred to by the reloc.  */
if|if
condition|(
name|ELF64_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* A local symbol.  */
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
comment|/* Read this BFD's local symbols if we haven't already.  */
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
literal|0
condition|)
goto|goto
name|error_return
goto|;
block|}
name|isym
operator|=
name|isymbuf
operator|+
name|ELF64_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|sym_sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|sym_sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|sym_sec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
name|sym_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|symval
operator|=
operator|(
name|isym
operator|->
name|st_value
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sym_sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|indx
decl_stmt|;
comment|/* An external symbol.  */
name|indx
operator|=
name|ELF64_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
block|{
comment|/* This appears to be a reference to an undefined symbol.  Just 		 ignore it--it will be caught by the regular reloc processing. 		 We need to keep BPO reloc accounting consistent, though 		 else we'll abort instead of emitting an error message.  */
if|if
condition|(
name|ELF64_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
name|R_MMIX_BASE_PLUS_OFFSET
operator|&&
name|gregdata
operator|!=
name|NULL
condition|)
block|{
name|gregdata
operator|->
name|n_remaining_bpo_relocs_this_relaxation_round
operator|--
expr_stmt|;
name|bpono
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
name|symval
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|ELF64_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MMIX_PUSHJ_STUBBABLE
condition|)
block|{
name|bfd_vma
name|value
init|=
name|symval
operator|+
name|irel
operator|->
name|r_addend
decl_stmt|;
name|bfd_vma
name|dot
init|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|irel
operator|->
name|r_offset
operator|)
decl_stmt|;
name|bfd_vma
name|stubaddr
init|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|size
operator|+
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|stubs_size_sum
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
literal|3
operator|)
operator|==
literal|0
operator|&&
name|bfd_check_overflow
argument_list|(
name|complain_overflow_signed
argument_list|,
literal|19
argument_list|,
literal|0
argument_list|,
name|bfd_arch_bits_per_address
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|value
operator|-
name|dot
operator|-
operator|(
name|value
operator|>
name|dot
condition|?
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|stub_size
index|[
name|pjsno
index|]
else|:
literal|0
operator|)
argument_list|)
operator|==
name|bfd_reloc_ok
condition|)
comment|/* If the reloc fits, no stub is needed.  */
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|stub_size
index|[
name|pjsno
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
comment|/* Maybe we can get away with just a JMP insn?  */
if|if
condition|(
operator|(
name|value
operator|&
literal|3
operator|)
operator|==
literal|0
operator|&&
name|bfd_check_overflow
argument_list|(
name|complain_overflow_signed
argument_list|,
literal|27
argument_list|,
literal|0
argument_list|,
name|bfd_arch_bits_per_address
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|value
operator|-
name|stubaddr
operator|-
operator|(
name|value
operator|>
name|dot
condition|?
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|stub_size
index|[
name|pjsno
index|]
operator|-
literal|4
else|:
literal|0
operator|)
argument_list|)
operator|==
name|bfd_reloc_ok
condition|)
comment|/* Yep, account for a stub consisting of a single JMP insn.  */
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|stub_size
index|[
name|pjsno
index|]
operator|=
literal|4
expr_stmt|;
else|else
comment|/* Nope, go for the full insn stub.  It doesn't seem useful to 	       emit the intermediate sizes; those will only be useful for 	       a>64M program assuming contiguous code.  */
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|stub_size
index|[
name|pjsno
index|]
operator|=
name|MAX_PUSHJ_STUB_SIZE
expr_stmt|;
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|stubs_size_sum
operator|+=
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|stub_size
index|[
name|pjsno
index|]
expr_stmt|;
name|pjsno
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* We're looking at a R_MMIX_BASE_PLUS_OFFSET reloc.  */
name|gregdata
operator|->
name|reloc_request
index|[
name|gregdata
operator|->
name|bpo_reloc_indexes
index|[
name|bpono
index|]
index|]
operator|.
name|value
operator|=
name|symval
operator|+
name|irel
operator|->
name|r_addend
expr_stmt|;
name|gregdata
operator|->
name|reloc_request
index|[
name|gregdata
operator|->
name|bpo_reloc_indexes
index|[
name|bpono
operator|++
index|]
index|]
operator|.
name|valid
operator|=
name|TRUE
expr_stmt|;
name|gregdata
operator|->
name|n_remaining_bpo_relocs_this_relaxation_round
operator|--
expr_stmt|;
block|}
comment|/* Check if that was the last BPO-reloc.  If so, sort the values and      calculate how many registers we need to cover them.  Set the size of      the linker gregs, and if the number of registers changed, indicate      that we need to relax some more because we have more work to do.  */
if|if
condition|(
name|gregdata
operator|!=
name|NULL
operator|&&
name|gregdata
operator|->
name|n_remaining_bpo_relocs_this_relaxation_round
operator|==
literal|0
condition|)
block|{
name|size_t
name|i
decl_stmt|;
name|bfd_vma
name|prev_base
decl_stmt|;
name|size_t
name|regindex
decl_stmt|;
comment|/* First, reset the remaining relocs for the next round.  */
name|gregdata
operator|->
name|n_remaining_bpo_relocs_this_relaxation_round
operator|=
name|gregdata
operator|->
name|n_bpo_relocs
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|PTR
operator|)
name|gregdata
operator|->
name|reloc_request
argument_list|,
name|gregdata
operator|->
name|n_max_bpo_relocs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bpo_reloc_request
argument_list|)
argument_list|,
name|bpo_reloc_request_sort_fn
argument_list|)
expr_stmt|;
comment|/* Recalculate indexes.  When we find a change (however unlikely 	 after the initial iteration), we know we need to relax again, 	 since items in the GREG-array are sorted by increasing value and 	 stored in the relaxation phase.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|gregdata
operator|->
name|n_max_bpo_relocs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|gregdata
operator|->
name|bpo_reloc_indexes
index|[
name|gregdata
operator|->
name|reloc_request
index|[
name|i
index|]
operator|.
name|bpo_reloc_no
index|]
operator|!=
name|i
condition|)
block|{
name|gregdata
operator|->
name|bpo_reloc_indexes
index|[
name|gregdata
operator|->
name|reloc_request
index|[
name|i
index|]
operator|.
name|bpo_reloc_no
index|]
operator|=
name|i
expr_stmt|;
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Allocate register numbers (indexing from 0).  Stop at the first 	 non-valid reloc.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|regindex
operator|=
literal|0
operator|,
name|prev_base
operator|=
name|gregdata
operator|->
name|reloc_request
index|[
literal|0
index|]
operator|.
name|value
init|;
name|i
operator|<
name|gregdata
operator|->
name|n_bpo_relocs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gregdata
operator|->
name|reloc_request
index|[
name|i
index|]
operator|.
name|value
operator|>
name|prev_base
operator|+
literal|255
condition|)
block|{
name|regindex
operator|++
expr_stmt|;
name|prev_base
operator|=
name|gregdata
operator|->
name|reloc_request
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
block|}
name|gregdata
operator|->
name|reloc_request
index|[
name|i
index|]
operator|.
name|regindex
operator|=
name|regindex
expr_stmt|;
name|gregdata
operator|->
name|reloc_request
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|gregdata
operator|->
name|reloc_request
index|[
name|i
index|]
operator|.
name|value
operator|-
name|prev_base
expr_stmt|;
block|}
comment|/* If it's not the same as the last time, we need to relax again, 	 because the size of the section has changed.  I'm not sure we 	 actually need to do any adjustments since the shrinking happens 	 at the start of this section, but better safe than sorry.  */
if|if
condition|(
name|gregdata
operator|->
name|n_allocated_bpo_gregs
operator|!=
name|regindex
operator|+
literal|1
condition|)
block|{
name|gregdata
operator|->
name|n_allocated_bpo_gregs
operator|=
name|regindex
operator|+
literal|1
expr_stmt|;
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
name|bpo_gregs_section
operator|->
name|size
operator|=
operator|(
name|regindex
operator|+
literal|1
operator|)
operator|*
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
operator|!=
name|symtab_hdr
operator|->
name|contents
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the symbols for elf_link_input_bfd.  */
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
block|}
block|}
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|size
operator|<
name|size
operator|+
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|stubs_size_sum
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|size
operator|>
name|size
operator|+
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|stubs_size_sum
condition|)
block|{
name|sec
operator|->
name|size
operator|=
name|size
operator|+
name|mmix_elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|pjs
operator|.
name|stubs_size_sum
expr_stmt|;
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
operator|!=
name|symtab_hdr
operator|->
name|contents
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_mmix
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_MMIX
end_define

begin_comment
comment|/* According to mmix-doc page 36 (paragraph 45), this should be (1LL<< 48LL).    However, that's too much for something somewhere in the linker part of    BFD; perhaps the start-address has to be a non-zero multiple of this    number, or larger than this number.  The symptom is that the linker    complains: "warning: allocated section `.text' not in segment".  We    settle for 64k; the page-size used in examples is 8k.    #define ELF_MAXPAGESIZE 0x10000     Unfortunately, this causes excessive padding in the supposedly small    for-education programs that are the expected usage (where people would    inspect output).  We stick to 256 bytes just to have *some* default    alignment.  */
end_comment

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x100
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf64_mmix_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf64-mmix"
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|NULL
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|mmix_info_to_howto_rela
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|mmix_elf_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|mmix_elf_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|mmix_elf_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_link_output_symbol_hook
define|\
value|mmix_elf_link_output_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
value|mmix_elf_add_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|mmix_elf_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_symbol_processing
value|mmix_elf_symbol_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_omit_section_dynsym
define|\
value|((bfd_boolean (*) (bfd *, struct bfd_link_info *, asection *)) bfd_true)
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_is_local_label_name
define|\
value|mmix_elf_is_local_label_name
end_define

begin_define
define|#
directive|define
name|elf_backend_may_use_rel_p
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_may_use_rela_p
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_default_use_rela_p
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_section_from_bfd_section
define|\
value|mmix_elf_section_from_bfd_section
end_define

begin_define
define|#
directive|define
name|bfd_elf64_new_section_hook
value|mmix_elf_new_section_hook
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_final_link
value|mmix_elf_final_link
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_relax_section
value|mmix_elf_relax_section
end_define

begin_include
include|#
directive|include
file|"elf64-target.h"
end_include

end_unit

