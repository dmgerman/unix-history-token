begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for RISC iX (Acorn, arm) binaries.    Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004,    2005, 2007 Free Software Foundation, Inc.    Contributed by Richard Earnshaw (rwe@pegasus.esprit.ec.org)     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* RISC iX overloads the MAGIC field to indicate more than just the usual    [ZNO]MAGIC values.  Also included are squeezing information and    shared library usage.  */
end_comment

begin_comment
comment|/* The following come from the man page.  */
end_comment

begin_define
define|#
directive|define
name|SHLIBLEN
value|60
end_define

begin_define
define|#
directive|define
name|MF_IMPURE
value|00200
end_define

begin_define
define|#
directive|define
name|MF_SQUEEZED
value|01000
end_define

begin_define
define|#
directive|define
name|MF_USES_SL
value|02000
end_define

begin_define
define|#
directive|define
name|MF_IS_SL
value|04000
end_define

begin_comment
comment|/* Common combinations.  */
end_comment

begin_comment
comment|/* Demand load (impure text).  */
end_comment

begin_define
define|#
directive|define
name|IMAGIC
value|(MF_IMPURE | ZMAGIC)
end_define

begin_comment
comment|/* OMAGIC with large header.    May contain a ref to a shared lib required by the object.  */
end_comment

begin_define
define|#
directive|define
name|SPOMAGIC
value|(MF_USES_SL | OMAGIC)
end_define

begin_comment
comment|/* A reference to a shared library.    The text portion of the object contains "overflow text" from    the shared library to be linked in with an object.  */
end_comment

begin_define
define|#
directive|define
name|SLOMAGIC
value|(MF_IS_SL | OMAGIC)
end_define

begin_comment
comment|/* Sqeezed demand paged.    NOTE: This interpretation of QMAGIC seems to be at variance    with that used on other architectures.  */
end_comment

begin_define
define|#
directive|define
name|QMAGIC
value|(MF_SQUEEZED | ZMAGIC)
end_define

begin_comment
comment|/* Program which uses sl.  */
end_comment

begin_define
define|#
directive|define
name|SPZMAGIC
value|(MF_USES_SL | ZMAGIC)
end_define

begin_comment
comment|/* Sqeezed ditto.  */
end_comment

begin_define
define|#
directive|define
name|SPQMAGIC
value|(MF_USES_SL | QMAGIC)
end_define

begin_comment
comment|/* Shared lib part of prog.  */
end_comment

begin_define
define|#
directive|define
name|SLZMAGIC
value|(MF_IS_SL | ZMAGIC)
end_define

begin_comment
comment|/* Sl which uses another.  */
end_comment

begin_define
define|#
directive|define
name|SLPZMAGIC
value|(MF_USES_SL | SLZMAGIC)
end_define

begin_define
define|#
directive|define
name|N_SHARED_LIB
parameter_list|(
name|x
parameter_list|)
value|((x).a_info& MF_USES_SL)
end_define

begin_comment
comment|/* Only a pure OMAGIC file has the minimal header.  */
end_comment

begin_define
define|#
directive|define
name|N_TXTOFF
parameter_list|(
name|x
parameter_list|)
define|\
value|((x).a_info == OMAGIC		\   ? 32				\   : (N_MAGIC(x) == ZMAGIC	\      ? TARGET_PAGE_SIZE		\      : 999))
end_define

begin_define
define|#
directive|define
name|N_TXTADDR
parameter_list|(
name|x
parameter_list|)
define|\
value|(N_MAGIC(x) != ZMAGIC							     \    ? (bfd_vma) 0
comment|/* object file or NMAGIC */
value|\
comment|/* Programs with shared libs are loaded at the first page after all the   \       text segments of the shared library programs.  Without looking this    \       up we can't know exactly what the address will be.  A reasonable guess \       is that a_entry will be in the first page of the executable.  */
value|\    : (N_SHARED_LIB(x)							     \       ? ((x).a_entry& ~(bfd_vma) (TARGET_PAGE_SIZE - 1))		     \       : (bfd_vma) TEXT_START_ADDR))
end_define

begin_define
define|#
directive|define
name|N_SYMOFF
parameter_list|(
name|x
parameter_list|)
define|\
value|(N_TXTOFF (x) + (x).a_text + (x).a_data + (x).a_trsize + (x).a_drsize)
end_define

begin_define
define|#
directive|define
name|N_STROFF
parameter_list|(
name|x
parameter_list|)
value|(N_SYMOFF (x) + (x).a_syms)
end_define

begin_define
define|#
directive|define
name|TEXT_START_ADDR
value|32768
end_define

begin_define
define|#
directive|define
name|TARGET_PAGE_SIZE
value|32768
end_define

begin_define
define|#
directive|define
name|SEGMENT_SIZE
value|TARGET_PAGE_SIZE
end_define

begin_define
define|#
directive|define
name|DEFAULT_ARCH
value|bfd_arch_arm
end_define

begin_comment
comment|/* Do not "beautify" the CONCAT* macro args.  Traditional C will not    remove whitespace added here, and thus will fail to concatenate    the tokens.  */
end_comment

begin_define
define|#
directive|define
name|MY
parameter_list|(
name|OP
parameter_list|)
value|CONCAT2 (riscix_,OP)
end_define

begin_define
define|#
directive|define
name|TARGETNAME
value|"a.out-riscix"
end_define

begin_define
define|#
directive|define
name|N_BADMAG
parameter_list|(
name|x
parameter_list|)
value|((((x).a_info& ~007200) != ZMAGIC) \&& (((x).a_info& ~006000) != OMAGIC) \&& ((x).a_info != NMAGIC))
end_define

begin_define
define|#
directive|define
name|N_MAGIC
parameter_list|(
name|x
parameter_list|)
value|((x).a_info& ~07200)
end_define

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_define
define|#
directive|define
name|WRITE_HEADERS
parameter_list|(
name|abfd
parameter_list|,
name|execp
parameter_list|)
define|\
value|{									    \     bfd_size_type text_size;
comment|/* Dummy vars.  */
value|\     file_ptr text_end;							    \     									    \     if (adata (abfd).magic == undecided_magic)				    \       NAME (aout, adjust_sizes_and_vmas) (abfd,& text_size,& text_end);   \     									    \     execp->a_syms = bfd_get_symcount (abfd) * EXTERNAL_NLIST_SIZE;	    \     execp->a_entry = bfd_get_start_address (abfd);			    \     									    \     execp->a_trsize = ((obj_textsec (abfd)->reloc_count) *		    \ 		       obj_reloc_entry_size (abfd));			    \     execp->a_drsize = ((obj_datasec (abfd)->reloc_count) *		    \ 		       obj_reloc_entry_size (abfd));			    \     NAME (aout, swap_exec_header_out) (abfd, execp,& exec_bytes);	    \     									    \     if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0			    \ 	|| bfd_bwrite ((void *)& exec_bytes, (bfd_size_type) EXEC_BYTES_SIZE,  \ 		      abfd) != EXEC_BYTES_SIZE)				    \       return FALSE;							    \
comment|/* Now write out reloc info, followed by syms and strings.  */
value|\ 									    \     if (bfd_get_outsymbols (abfd) != NULL			    	    \&& bfd_get_symcount (abfd) != 0)				    \       {									    \ 	if (bfd_seek (abfd, (file_ptr) (N_SYMOFF (* execp)), SEEK_SET) != 0)\ 	  return FALSE;							    \ 									    \ 	if (! NAME (aout, write_syms) (abfd))				    \           return FALSE;							    \ 									    \ 	if (bfd_seek (abfd, (file_ptr) (N_TRELOFF (* execp)), SEEK_SET) != 0)\ 	  return FALSE;							    \ 									    \ 	if (! riscix_squirt_out_relocs (abfd, obj_textsec (abfd)))	    \ 	  return FALSE;							    \ 	if (bfd_seek (abfd, (file_ptr) (N_DRELOFF (* execp)), SEEK_SET) != 0)\ 	  return FALSE;							    \ 									    \ 	if (!NAME (aout, squirt_out_relocs) (abfd, obj_datasec (abfd)))	    \ 	  return FALSE;							    \       }									    \   }
end_define

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_include
include|#
directive|include
file|"aout/aout64.h"
end_include

begin_function
specifier|static
name|bfd_reloc_status_type
name|riscix_fix_pcrel_26_done
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
name|symbol
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|input_section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* This is dead simple at present.  */
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|riscix_fix_pcrel_26
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|bfd_target
modifier|*
name|riscix_callback
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|riscix_std_reloc_howto
index|[]
init|=
block|{
comment|/* Type              rs size bsz  pcrel bitpos ovrf                     sf name     part_inpl readmask  setmask    pcdone */
name|HOWTO
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"8"
argument_list|,
name|TRUE
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"16"
argument_list|,
name|TRUE
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"32"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|26
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|riscix_fix_pcrel_26
argument_list|,
literal|"ARM26"
argument_list|,
name|TRUE
argument_list|,
literal|0x00ffffff
argument_list|,
literal|0x00ffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"DISP8"
argument_list|,
name|TRUE
argument_list|,
literal|0x000000ff
argument_list|,
literal|0x000000ff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"DISP16"
argument_list|,
name|TRUE
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|6
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
literal|0
argument_list|,
literal|"DISP32"
argument_list|,
name|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|7
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|26
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|riscix_fix_pcrel_26_done
argument_list|,
literal|"ARM26D"
argument_list|,
name|TRUE
argument_list|,
literal|0x00ffffff
argument_list|,
literal|0x00ffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|9
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"NEG16"
argument_list|,
name|TRUE
argument_list|,
literal|0x0000ffff
argument_list|,
literal|0x0000ffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
literal|10
argument_list|,
literal|0
argument_list|,
argument|-
literal|2
argument_list|,
literal|32
argument_list|,
argument|FALSE
argument_list|,
literal|0
argument_list|,
argument|complain_overflow_bitfield
argument_list|,
literal|0
argument_list|,
literal|"NEG32"
argument_list|,
argument|TRUE
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
argument|FALSE
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RISCIX_TABLE_SIZE
define|\
value|(sizeof (riscix_std_reloc_howto) / sizeof (reloc_howto_type))
end_define

begin_function
specifier|static
name|bfd_reloc_status_type
name|riscix_fix_pcrel_26
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_size_type
name|addr
init|=
name|reloc_entry
operator|->
name|address
decl_stmt|;
name|long
name|target
init|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
decl_stmt|;
name|bfd_reloc_status_type
name|flag
init|=
name|bfd_reloc_ok
decl_stmt|;
comment|/* If this is an undefined symbol, return error.  */
if|if
condition|(
name|symbol
operator|->
name|section
operator|==
operator|&
name|bfd_und_section
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_WEAK
operator|)
operator|==
literal|0
condition|)
return|return
name|output_bfd
condition|?
name|bfd_reloc_continue
else|:
name|bfd_reloc_undefined
return|;
comment|/* If the sections are different, and we are doing a partial relocation,      just ignore it for now.  */
if|if
condition|(
name|symbol
operator|->
name|section
operator|->
name|name
operator|!=
name|input_section
operator|->
name|name
operator|&&
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_reloc_continue
return|;
name|relocation
operator|=
operator|(
name|target
operator|&
literal|0x00ffffff
operator|)
operator|<<
literal|2
expr_stmt|;
name|relocation
operator|=
operator|(
name|relocation
operator|^
literal|0x02000000
operator|)
operator|-
literal|0x02000000
expr_stmt|;
comment|/* Sign extend.  */
name|relocation
operator|+=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|relocation
operator|-=
name|input_section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|-=
name|input_section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|-=
name|addr
expr_stmt|;
if|if
condition|(
name|relocation
operator|&
literal|3
condition|)
return|return
name|bfd_reloc_overflow
return|;
comment|/* Check for overflow.  */
if|if
condition|(
name|relocation
operator|&
literal|0x02000000
condition|)
block|{
if|if
condition|(
operator|(
name|relocation
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x03ffffff
operator|)
operator|!=
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x03ffffff
condition|)
name|flag
operator|=
name|bfd_reloc_overflow
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|relocation
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x03ffffff
condition|)
name|flag
operator|=
name|bfd_reloc_overflow
expr_stmt|;
name|target
operator|&=
operator|~
literal|0x00ffffff
expr_stmt|;
name|target
operator||=
operator|(
name|relocation
operator|>>
literal|2
operator|)
operator|&
literal|0x00ffffff
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|target
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|addr
argument_list|)
expr_stmt|;
comment|/* Now the ARM magic... Change the reloc type so that it is marked as done.      Strictly this is only necessary if we are doing a partial relocation.  */
name|reloc_entry
operator|->
name|howto
operator|=
operator|&
name|riscix_std_reloc_howto
index|[
literal|7
index|]
expr_stmt|;
return|return
name|flag
return|;
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|riscix_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
define|#
directive|define
name|ASTD
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|)
value|case i: return&riscix_std_reloc_howto[j]
if|if
condition|(
name|code
operator|==
name|BFD_RELOC_CTOR
condition|)
switch|switch
condition|(
name|bfd_get_arch_info
argument_list|(
name|abfd
argument_list|)
operator|->
name|bits_per_address
condition|)
block|{
case|case
literal|32
case|:
name|code
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
name|ASTD
argument_list|(
name|BFD_RELOC_16
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ASTD
argument_list|(
name|BFD_RELOC_32
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ASTD
argument_list|(
name|BFD_RELOC_ARM_PCREL_BRANCH
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ASTD
argument_list|(
name|BFD_RELOC_8_PCREL
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ASTD
argument_list|(
name|BFD_RELOC_16_PCREL
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|ASTD
argument_list|(
name|BFD_RELOC_32_PCREL
argument_list|,
literal|6
argument_list|)
expr_stmt|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|riscix_reloc_name_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|r_name
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|riscix_std_reloc_howto
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|riscix_std_reloc_howto
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|riscix_std_reloc_howto
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcasecmp
argument_list|(
name|riscix_std_reloc_howto
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|riscix_std_reloc_howto
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MY_bfd_link_hash_table_create
value|_bfd_generic_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|MY_bfd_link_add_symbols
value|_bfd_generic_link_add_symbols
end_define

begin_define
define|#
directive|define
name|MY_final_link_callback
value|should_not_be_used
end_define

begin_define
define|#
directive|define
name|MY_bfd_final_link
value|_bfd_generic_final_link
end_define

begin_define
define|#
directive|define
name|MY_bfd_reloc_type_lookup
value|riscix_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|MY_bfd_reloc_name_lookup
value|riscix_reloc_name_lookup
end_define

begin_define
define|#
directive|define
name|MY_canonicalize_reloc
value|riscix_canonicalize_reloc
end_define

begin_define
define|#
directive|define
name|MY_object_p
value|riscix_object_p
end_define

begin_function
specifier|static
name|void
name|riscix_swap_std_reloc_out
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|g
parameter_list|,
name|struct
name|reloc_std_external
modifier|*
name|natptr
parameter_list|)
block|{
name|int
name|r_index
decl_stmt|;
name|asymbol
modifier|*
name|sym
init|=
operator|*
operator|(
name|g
operator|->
name|sym_ptr_ptr
operator|)
decl_stmt|;
name|int
name|r_extern
decl_stmt|;
name|int
name|r_length
decl_stmt|;
name|int
name|r_pcrel
decl_stmt|;
name|int
name|r_neg
init|=
literal|0
decl_stmt|;
comment|/* Negative relocs use the BASEREL bit.  */
name|asection
modifier|*
name|output_section
init|=
name|sym
operator|->
name|section
operator|->
name|output_section
decl_stmt|;
name|PUT_WORD
argument_list|(
name|abfd
argument_list|,
name|g
operator|->
name|address
argument_list|,
name|natptr
operator|->
name|r_address
argument_list|)
expr_stmt|;
name|r_length
operator|=
name|g
operator|->
name|howto
operator|->
name|size
expr_stmt|;
comment|/* Size as a power of two.  */
if|if
condition|(
name|r_length
operator|<
literal|0
condition|)
block|{
name|r_length
operator|=
operator|-
name|r_length
expr_stmt|;
name|r_neg
operator|=
literal|1
expr_stmt|;
block|}
name|r_pcrel
operator|=
operator|(
name|int
operator|)
name|g
operator|->
name|howto
operator|->
name|pc_relative
expr_stmt|;
comment|/* Relative to PC?  */
comment|/* For RISC iX, in pc-relative relocs the r_pcrel bit means that the      relocation has been done already (Only for the 26-bit one I think)?  */
if|if
condition|(
name|r_length
operator|==
literal|3
condition|)
name|r_pcrel
operator|=
name|r_pcrel
condition|?
literal|0
else|:
literal|1
expr_stmt|;
comment|/* Name was clobbered by aout_write_syms to be symbol index.  */
comment|/* If this relocation is relative to a symbol then set the      r_index to the symbols index, and the r_extern bit.       Absolute symbols can come in in two ways, either as an offset      from the abs section, or as a symbol which has an abs value.      check for that here.  */
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|output_section
argument_list|)
operator|||
name|output_section
operator|==
operator|&
name|bfd_abs_section
operator|||
name|output_section
operator|==
operator|&
name|bfd_und_section
condition|)
block|{
if|if
condition|(
name|bfd_abs_section
operator|.
name|symbol
operator|==
name|sym
condition|)
block|{
comment|/* Whoops, looked like an abs symbol, but is really an offset 	     from the abs section.  */
name|r_index
operator|=
literal|0
expr_stmt|;
name|r_extern
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Fill in symbol.  */
name|r_extern
operator|=
literal|1
expr_stmt|;
name|r_index
operator|=
operator|(
operator|*
name|g
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|udata
operator|.
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Just an ordinary section.  */
name|r_extern
operator|=
literal|0
expr_stmt|;
name|r_index
operator|=
name|output_section
operator|->
name|target_index
expr_stmt|;
block|}
comment|/* Now the fun stuff.  */
if|if
condition|(
name|bfd_header_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|natptr
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
name|r_index
operator|>>
literal|16
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
name|r_index
operator|>>
literal|8
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
name|r_index
expr_stmt|;
name|natptr
operator|->
name|r_type
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|r_extern
condition|?
name|RELOC_STD_BITS_EXTERN_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|r_pcrel
condition|?
name|RELOC_STD_BITS_PCREL_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|r_neg
condition|?
name|RELOC_STD_BITS_BASEREL_BIG
else|:
literal|0
operator|)
operator||
operator|(
name|r_length
operator|<<
name|RELOC_STD_BITS_LENGTH_SH_BIG
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|natptr
operator|->
name|r_index
index|[
literal|2
index|]
operator|=
name|r_index
operator|>>
literal|16
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|1
index|]
operator|=
name|r_index
operator|>>
literal|8
expr_stmt|;
name|natptr
operator|->
name|r_index
index|[
literal|0
index|]
operator|=
name|r_index
expr_stmt|;
name|natptr
operator|->
name|r_type
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|r_extern
condition|?
name|RELOC_STD_BITS_EXTERN_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|r_pcrel
condition|?
name|RELOC_STD_BITS_PCREL_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|r_neg
condition|?
name|RELOC_STD_BITS_BASEREL_LITTLE
else|:
literal|0
operator|)
operator||
operator|(
name|r_length
operator|<<
name|RELOC_STD_BITS_LENGTH_SH_LITTLE
operator|)
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|riscix_squirt_out_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|)
block|{
name|arelent
modifier|*
modifier|*
name|generic
decl_stmt|;
name|unsigned
name|char
modifier|*
name|native
decl_stmt|,
modifier|*
name|natptr
decl_stmt|;
name|size_t
name|each_size
decl_stmt|;
name|unsigned
name|int
name|count
init|=
name|section
operator|->
name|reloc_count
decl_stmt|;
name|bfd_size_type
name|natsize
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|each_size
operator|=
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|natsize
operator|=
name|each_size
expr_stmt|;
name|natsize
operator|*=
name|count
expr_stmt|;
name|native
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|natsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|native
condition|)
return|return
name|FALSE
return|;
name|generic
operator|=
name|section
operator|->
name|orelocation
expr_stmt|;
for|for
control|(
name|natptr
operator|=
name|native
init|;
name|count
operator|!=
literal|0
condition|;
operator|--
name|count
operator|,
name|natptr
operator|+=
name|each_size
operator|,
operator|++
name|generic
control|)
name|riscix_swap_std_reloc_out
argument_list|(
name|abfd
argument_list|,
operator|*
name|generic
argument_list|,
operator|(
expr|struct
name|reloc_std_external
operator|*
operator|)
name|natptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|native
argument_list|,
name|natsize
argument_list|,
name|abfd
argument_list|)
operator|!=
name|natsize
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|native
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|native
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This is just like the standard aoutx.h version but we need to do our    own mapping of external reloc type values to howto entries.  */
end_comment

begin_function
specifier|static
name|long
name|MY
function|(
name|canonicalize_reloc
function|)
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|sec_ptr
name|section
parameter_list|,
name|arelent
modifier|*
modifier|*
name|relptr
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|)
block|{
name|arelent
modifier|*
name|tblptr
init|=
name|section
operator|->
name|relocation
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
specifier|extern
name|reloc_howto_type
name|NAME
argument_list|(
name|aout
argument_list|,
name|std_howto_table
argument_list|)
decl|[]
decl_stmt|;
comment|/* If we have already read in the relocation table, return the values.  */
if|if
condition|(
name|section
operator|->
name|flags
operator|&
name|SEC_CONSTRUCTOR
condition|)
block|{
name|arelent_chain
modifier|*
name|chain
init|=
name|section
operator|->
name|constructor_chain
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|section
operator|->
name|reloc_count
condition|;
name|count
operator|++
control|)
block|{
operator|*
name|relptr
operator|++
operator|=
operator|&
name|chain
operator|->
name|relent
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|relptr
operator|=
literal|0
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
return|;
block|}
if|if
condition|(
name|tblptr
operator|&&
name|section
operator|->
name|reloc_count
condition|)
block|{
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|++
operator|<
name|section
operator|->
name|reloc_count
condition|;
control|)
operator|*
name|relptr
operator|++
operator|=
name|tblptr
operator|++
expr_stmt|;
operator|*
name|relptr
operator|=
literal|0
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
return|;
block|}
if|if
condition|(
operator|!
name|NAME
argument_list|(
name|aout
argument_list|,
name|slurp_reloc_table
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|tblptr
operator|=
name|section
operator|->
name|relocation
expr_stmt|;
comment|/* Fix up howto entries.  */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|++
operator|<
name|section
operator|->
name|reloc_count
condition|;
control|)
block|{
name|c
operator|=
name|tblptr
operator|->
name|howto
operator|-
name|NAME
argument_list|(
name|aout
argument_list|,
name|std_howto_table
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|c
operator|<
name|RISCIX_TABLE_SIZE
argument_list|)
expr_stmt|;
name|tblptr
operator|->
name|howto
operator|=
operator|&
name|riscix_std_reloc_howto
index|[
name|c
index|]
expr_stmt|;
operator|*
name|relptr
operator|++
operator|=
name|tblptr
operator|++
expr_stmt|;
block|}
operator|*
name|relptr
operator|=
literal|0
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
return|;
block|}
end_function

begin_comment
comment|/* This is the same as NAME(aout,some_aout_object_p), but has different    expansions of the macro definitions.  */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|riscix_some_aout_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|internal_exec
modifier|*
name|execp
parameter_list|,
specifier|const
name|bfd_target
modifier|*
function_decl|(
modifier|*
name|callback_to_real_object_p
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|)
parameter_list|)
block|{
name|struct
name|aout_data_struct
modifier|*
name|rawptr
decl_stmt|,
modifier|*
name|oldrawptr
decl_stmt|;
specifier|const
name|bfd_target
modifier|*
name|result
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|aout_data_struct
argument_list|)
decl_stmt|;
name|rawptr
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rawptr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|oldrawptr
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|=
name|rawptr
expr_stmt|;
comment|/* Copy the contents of the old tdata struct.      In particular, we want the subformat, since for hpux it was set in      hp300hpux.c:swap_exec_header_in and will be used in      hp300hpux.c:callback.  */
if|if
condition|(
name|oldrawptr
operator|!=
name|NULL
condition|)
operator|*
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|=
operator|*
name|oldrawptr
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|->
name|a
operator|.
name|hdr
operator|=
operator|&
name|rawptr
operator|->
name|e
expr_stmt|;
comment|/* Copy in the internal_exec struct.  */
operator|*
operator|(
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|->
name|a
operator|.
name|hdr
operator|)
operator|=
operator|*
name|execp
expr_stmt|;
name|execp
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|->
name|a
operator|.
name|hdr
expr_stmt|;
comment|/* Set the file flags.  */
name|abfd
operator|->
name|flags
operator|=
name|BFD_NO_FLAGS
expr_stmt|;
if|if
condition|(
name|execp
operator|->
name|a_drsize
operator|||
name|execp
operator|->
name|a_trsize
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_RELOC
expr_stmt|;
comment|/* Setting of EXEC_P has been deferred to the bottom of this function.  */
if|if
condition|(
name|execp
operator|->
name|a_syms
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
expr_stmt|;
if|if
condition|(
name|N_DYNAMIC
argument_list|(
operator|*
name|execp
argument_list|)
condition|)
name|abfd
operator|->
name|flags
operator||=
name|DYNAMIC
expr_stmt|;
comment|/* Squeezed files aren't supported (yet)!  */
if|if
condition|(
operator|(
name|execp
operator|->
name|a_info
operator|&
name|MF_SQUEEZED
operator|)
operator|!=
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|execp
operator|->
name|a_info
operator|&
name|MF_IS_SL
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Nor are shared libraries.  */
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|N_MAGIC
argument_list|(
operator|*
name|execp
argument_list|)
operator|==
name|ZMAGIC
condition|)
block|{
name|abfd
operator|->
name|flags
operator||=
name|D_PAGED
operator||
name|WP_TEXT
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|magic
operator|=
name|z_magic
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|N_MAGIC
argument_list|(
operator|*
name|execp
argument_list|)
operator|==
name|NMAGIC
condition|)
block|{
name|abfd
operator|->
name|flags
operator||=
name|WP_TEXT
expr_stmt|;
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|magic
operator|=
name|n_magic
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|N_MAGIC
argument_list|(
operator|*
name|execp
argument_list|)
operator|==
name|OMAGIC
condition|)
name|adata
argument_list|(
name|abfd
argument_list|)
operator|.
name|magic
operator|=
name|o_magic
expr_stmt|;
else|else
comment|/* Should have been checked with N_BADMAG before this routine        was called.  */
name|abort
argument_list|()
expr_stmt|;
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
operator|=
name|execp
operator|->
name|a_entry
expr_stmt|;
name|obj_aout_symbols
argument_list|(
name|abfd
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|execp
operator|->
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|external_nlist
argument_list|)
expr_stmt|;
comment|/* The default relocation entry size is that of traditional V7 Unix.  */
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|RELOC_STD_SIZE
expr_stmt|;
comment|/* The default symbol entry size is that of traditional Unix.  */
name|obj_symbol_entry_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|EXTERNAL_NLIST_SIZE
expr_stmt|;
name|obj_aout_external_syms
argument_list|(
name|abfd
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|obj_aout_external_strings
argument_list|(
name|abfd
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|obj_aout_sym_hashes
argument_list|(
name|abfd
argument_list|)
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|NAME
argument_list|(
name|aout
argument_list|,
name|make_sections
argument_list|)
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|NULL
return|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|size
operator|=
name|execp
operator|->
name|a_data
expr_stmt|;
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|size
operator|=
name|execp
operator|->
name|a_bss
expr_stmt|;
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
operator|(
name|execp
operator|->
name|a_trsize
operator|!=
literal|0
condition|?
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_CODE
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_RELOC
operator|)
else|:
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_CODE
operator||
name|SEC_HAS_CONTENTS
operator|)
operator|)
expr_stmt|;
name|obj_datasec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
operator|(
name|execp
operator|->
name|a_drsize
operator|!=
literal|0
condition|?
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_RELOC
operator|)
else|:
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator|)
operator|)
expr_stmt|;
name|obj_bsssec
argument_list|(
name|abfd
argument_list|)
operator|->
name|flags
operator|=
name|SEC_ALLOC
expr_stmt|;
name|result
operator|=
call|(
modifier|*
name|callback_to_real_object_p
call|)
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MACH
argument_list|)
operator|||
name|defined
argument_list|(
name|STAT_FOR_EXEC
argument_list|)
comment|/* The original heuristic doesn't work in some important cases. The      a.out file has no information about the text start address. For      files (like kernels) linked to non-standard addresses (ld -Ttext      nnn) the entry point may not be between the default text start      (obj_textsec(abfd)->vma) and (obj_textsec(abfd)->vma) + text size      This is not just a mach issue. Many kernels are loaded at non      standard addresses.  */
block|{
name|struct
name|stat
name|stat_buf
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|iostream
operator|!=
name|NULL
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|BFD_IN_MEMORY
operator|)
operator|==
literal|0
operator|&&
operator|(
name|fstat
argument_list|(
name|fileno
argument_list|(
operator|(
name|FILE
operator|*
operator|)
operator|(
name|abfd
operator|->
name|iostream
operator|)
argument_list|)
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|stat_buf
operator|.
name|st_mode
operator|&
literal|0111
operator|)
operator|!=
literal|0
operator|)
condition|)
name|abfd
operator|->
name|flags
operator||=
name|EXEC_P
expr_stmt|;
block|}
else|#
directive|else
comment|/* ! MACH */
comment|/* Now that the segment addresses have been worked out, take a better      guess at whether the file is executable.  If the entry point      is within the text segment, assume it is.  (This makes files      executable even if their entry point address is 0, as long as      their text starts at zero.)       At some point we should probably break down and stat the file and      declare it executable if (one of) its 'x' bits are on...  */
if|if
condition|(
operator|(
name|execp
operator|->
name|a_entry
operator|>=
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|)
operator|&&
operator|(
name|execp
operator|->
name|a_entry
operator|<
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|vma
operator|+
name|obj_textsec
argument_list|(
name|abfd
argument_list|)
operator|->
name|size
operator|)
condition|)
name|abfd
operator|->
name|flags
operator||=
name|EXEC_P
expr_stmt|;
endif|#
directive|endif
comment|/* MACH */
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rawptr
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|aout_data
operator|=
name|oldrawptr
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|MY
function|(
name|object_p
function|)
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|external_exec
name|exec_bytes
decl_stmt|;
comment|/* Raw exec header from file.  */
name|struct
name|internal_exec
name|exec
decl_stmt|;
comment|/* Cleaned-up exec header.  */
specifier|const
name|bfd_target
modifier|*
name|target
decl_stmt|;
if|if
condition|(
name|bfd_bread
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|exec_bytes
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|EXEC_BYTES_SIZE
argument_list|,
name|abfd
argument_list|)
operator|!=
name|EXEC_BYTES_SIZE
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|exec
operator|.
name|a_info
operator|=
name|H_GET_32
argument_list|(
name|abfd
argument_list|,
name|exec_bytes
operator|.
name|e_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|N_BADMAG
argument_list|(
name|exec
argument_list|)
condition|)
return|return
name|NULL
return|;
ifdef|#
directive|ifdef
name|MACHTYPE_OK
if|if
condition|(
operator|!
operator|(
name|MACHTYPE_OK
argument_list|(
name|N_MACHTYPE
argument_list|(
name|exec
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
endif|#
directive|endif
name|NAME
argument_list|(
name|aout
argument_list|,
name|swap_exec_header_in
argument_list|)
argument_list|(
name|abfd
argument_list|,
operator|&
name|exec_bytes
argument_list|,
operator|&
name|exec
argument_list|)
expr_stmt|;
name|target
operator|=
name|riscix_some_aout_object_p
argument_list|(
name|abfd
argument_list|,
operator|&
name|exec
argument_list|,
name|MY
argument_list|(
name|callback
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"aout-target.h"
end_include

end_unit

