begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Renesas / SuperH specific support for Symbian 32-bit ELF files    Copyright 2004, 2005, 2006    Free Software Foundation, Inc.    Contributed by Red Hat     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Stop elf32-sh.c from defining any target vectors.  */
end_comment

begin_define
define|#
directive|define
name|SH_TARGET_ALREADY_DEFINED
end_define

begin_define
define|#
directive|define
name|sh_find_elf_flags
value|sh_symbian_find_elf_flags
end_define

begin_define
define|#
directive|define
name|sh_elf_get_flags_from_mach
value|sh_symbian_elf_get_flags_from_mach
end_define

begin_include
include|#
directive|include
file|"elf32-sh.c"
end_include

begin_comment
comment|//#define SYMBIAN_DEBUG 1
end_comment

begin_define
define|#
directive|define
name|SYMBIAN_DEBUG
value|0
end_define

begin_define
define|#
directive|define
name|DIRECTIVE_HEADER
value|"#<SYMEDIT>#\n"
end_define

begin_define
define|#
directive|define
name|DIRECTIVE_IMPORT
value|"IMPORT "
end_define

begin_define
define|#
directive|define
name|DIRECTIVE_EXPORT
value|"EXPORT "
end_define

begin_define
define|#
directive|define
name|DIRECTIVE_AS
value|"AS "
end_define

begin_comment
comment|/* Macro to advance 's' until either it reaches 'e' or the    character pointed to by 's' is equal to 'c'.  If 'e' is    reached and SYMBIAN_DEBUG is enabled then the error message 'm'    is displayed.  */
end_comment

begin_define
define|#
directive|define
name|SKIP_UNTIL
parameter_list|(
name|s
parameter_list|,
name|e
parameter_list|,
name|c
parameter_list|,
name|m
parameter_list|)
define|\
value|do								\     {								\       while (s< e&& *s != c)					\ 	++ s;							\       if (s>= e)						\ 	{							\           if (SYMBIAN_DEBUG)					\ 	    fprintf (stderr, "Corrupt directive: %s\n", m);	\ 	  result = FALSE;					\ 	}							\     }								\   while (0);							\   if (!result)							\      break;
end_define

begin_comment
comment|/* Like SKIP_UNTIL except there are two terminator characters    c1 and c2.  */
end_comment

begin_define
define|#
directive|define
name|SKIP_UNTIL2
parameter_list|(
name|s
parameter_list|,
name|e
parameter_list|,
name|c1
parameter_list|,
name|c2
parameter_list|,
name|m
parameter_list|)
define|\
value|do								\     {								\       while (s< e&& *s != c1&& *s != c2)			\ 	++ s;							\       if (s>= e)						\ 	{							\           if (SYMBIAN_DEBUG)					\ 	    fprintf (stderr, "Corrupt directive: %s\n", m);	\ 	  result = FALSE;					\ 	}							\     }								\   while (0);							\   if (!result)							\      break;
end_define

begin_comment
comment|/* Macro to advance 's' until either it reaches 'e' or the    character pointed to by 's' is not equal to 'c'.  If 'e'    is reached and SYMBIAN_DEBUG is enabled then the error message    'm' is displayed.  */
end_comment

begin_define
define|#
directive|define
name|SKIP_WHILE
parameter_list|(
name|s
parameter_list|,
name|e
parameter_list|,
name|c
parameter_list|,
name|m
parameter_list|)
define|\
value|do								\     {								\       while (s< e&& *s == c)					\ 	++ s;							\       if (s>= e)						\ 	{							\           if (SYMBIAN_DEBUG)					\ 	    fprintf (stderr, "Corrupt directive: %s\n", m);	\ 	  result = FALSE;					\ 	}							\     }								\   while (0);							\   if (!result)							\      break;
end_define

begin_typedef
typedef|typedef
struct|struct
name|symbol_rename
block|{
name|struct
name|symbol_rename
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|current_name
decl_stmt|;
name|char
modifier|*
name|new_name
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|current_hash
decl_stmt|;
name|unsigned
name|long
name|new_symndx
decl_stmt|;
block|}
name|symbol_rename
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|symbol_rename
modifier|*
name|rename_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Accumulate a list of symbols to be renamed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sh_symbian_import_as
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|current_name
parameter_list|,
name|char
modifier|*
name|new_name
parameter_list|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|new_hash
decl_stmt|;
name|symbol_rename
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|SYMBIAN_DEBUG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IMPORT '%s' AS '%s'\n"
argument_list|,
name|current_name
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|rename_list
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|node
operator|->
name|current_name
argument_list|,
name|current_name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|node
operator|->
name|new_name
argument_list|,
name|new_name
argument_list|)
operator|==
literal|0
condition|)
comment|/* Already added to rename list.  */
return|return
name|TRUE
return|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"%B: IMPORT AS directive for %s conceals previous IMPORT AS"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|current_name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|node
operator|=
name|bfd_malloc
argument_list|(
sizeof|sizeof
expr|*
name|node
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|SYMBIAN_DEBUG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IMPORT AS: No mem for new rename node\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|node
operator|->
name|current_name
operator|=
name|bfd_malloc
argument_list|(
name|strlen
argument_list|(
name|current_name
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|SYMBIAN_DEBUG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IMPORT AS: No mem for current name field in rename node\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
name|strcpy
argument_list|(
name|node
operator|->
name|current_name
argument_list|,
name|current_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|node
operator|->
name|new_name
operator|=
name|bfd_malloc
argument_list|(
name|strlen
argument_list|(
name|new_name
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|SYMBIAN_DEBUG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IMPORT AS: No mem for new name field in rename node\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
operator|->
name|current_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
name|strcpy
argument_list|(
name|node
operator|->
name|new_name
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
name|node
operator|->
name|next
operator|=
name|rename_list
expr_stmt|;
name|node
operator|->
name|current_hash
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|new_symndx
operator|=
literal|0
expr_stmt|;
name|rename_list
operator|=
name|node
expr_stmt|;
name|new_hash
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|node
operator|->
name|new_name
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|new_hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_new
condition|)
name|new_hash
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|sh_symbian_import
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|SYMBIAN_DEBUG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IMPORT '%s'\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* XXX: Generate an import somehow ?  */
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|sh_symbian_export
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|SYMBIAN_DEBUG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"EXPORT '%s'\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* XXX: Generate an export somehow ?  */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Process any magic embedded commands in the .directive. section.    Returns TRUE upon sucecss, but if it fails it sets bfd_error and    returns FALSE.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sh_symbian_process_embedded_commands
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
name|bfd_boolean
name|result
init|=
name|TRUE
decl_stmt|;
name|bfd_size_type
name|sz
init|=
name|sec
operator|->
name|rawsize
condition|?
name|sec
operator|->
name|rawsize
else|:
name|sec
operator|->
name|size
decl_stmt|;
for|for
control|(
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|contents
operator|,
name|e
operator|=
name|s
operator|+
name|sz
init|;
name|s
operator|<
name|e
condition|;
control|)
block|{
name|char
modifier|*
name|directive
init|=
name|s
decl_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
comment|/* I want to use "case DIRECTIVE_HEADER [0]:" here but gcc won't let me :-(  */
case|case
literal|'#'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|DIRECTIVE_HEADER
argument_list|)
condition|)
name|result
operator|=
name|FALSE
expr_stmt|;
else|else
comment|/* Just ignore the header. 	       XXX: Strictly speaking we ought to check that the header 	       is present and that it is the first thing in the file.  */
name|s
operator|+=
name|strlen
argument_list|(
name|DIRECTIVE_HEADER
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
operator|!
name|CONST_STRNEQ
argument_list|(
name|s
argument_list|,
name|DIRECTIVE_IMPORT
argument_list|)
condition|)
name|result
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|new_name
decl_stmt|;
name|char
modifier|*
name|new_name_end
decl_stmt|;
name|char
name|name_end_char
decl_stmt|;
comment|/* Skip the IMPORT directive.  */
name|s
operator|+=
name|strlen
argument_list|(
name|DIRECTIVE_IMPORT
argument_list|)
expr_stmt|;
name|new_name
operator|=
name|s
expr_stmt|;
comment|/* Find the end of the new name.  */
while|while
condition|(
name|s
operator|<
name|e
operator|&&
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|>=
name|e
condition|)
block|{
comment|/* We have reached the end of the .directive section 		     without encountering a string terminator.  This is 		     allowed for IMPORT directives.  */
name|new_name_end
operator|=
name|e
operator|-
literal|1
expr_stmt|;
name|name_end_char
operator|=
operator|*
name|new_name_end
expr_stmt|;
operator|*
name|new_name_end
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|sh_symbian_import
argument_list|(
name|abfd
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
operator|*
name|new_name_end
operator|=
name|name_end_char
expr_stmt|;
break|break;
block|}
comment|/* Remember where the name ends.  */
name|new_name_end
operator|=
name|s
expr_stmt|;
comment|/* Skip any whitespace before the 'AS'.  */
name|SKIP_WHILE
argument_list|(
name|s
argument_list|,
name|e
argument_list|,
literal|' '
argument_list|,
literal|"IMPORT: Name just followed by spaces"
argument_list|)
expr_stmt|;
comment|/* Terminate the new name.  (Do this after skiping...)  */
name|name_end_char
operator|=
operator|*
name|new_name_end
expr_stmt|;
operator|*
name|new_name_end
operator|=
literal|0
expr_stmt|;
comment|/* Check to see if 'AS '... is present.  If so we have an 		 IMPORT AS directive, otherwise we have an IMPORT directive.  */
if|if
condition|(
operator|!
name|CONST_STRNEQ
argument_list|(
name|s
argument_list|,
name|DIRECTIVE_AS
argument_list|)
condition|)
block|{
comment|/* Skip the new-line at the end of the name.  */
if|if
condition|(
name|SYMBIAN_DEBUG
operator|&&
name|name_end_char
operator|!=
literal|'\n'
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IMPORT: No newline at end of directive\n"
argument_list|)
expr_stmt|;
else|else
name|s
operator|++
expr_stmt|;
name|result
operator|=
name|sh_symbian_import
argument_list|(
name|abfd
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
comment|/* Skip past the NUL character.  */
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|SYMBIAN_DEBUG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IMPORT: No NUL at end of directive\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|current_name
decl_stmt|;
name|char
modifier|*
name|current_name_end
decl_stmt|;
name|char
name|current_name_end_char
decl_stmt|;
comment|/* Skip the 'AS '.  */
name|s
operator|+=
name|strlen
argument_list|(
name|DIRECTIVE_AS
argument_list|)
expr_stmt|;
comment|/* Skip any white space after the 'AS '.  */
name|SKIP_WHILE
argument_list|(
name|s
argument_list|,
name|e
argument_list|,
literal|' '
argument_list|,
literal|"IMPORT AS: Nothing after AS"
argument_list|)
expr_stmt|;
name|current_name
operator|=
name|s
expr_stmt|;
comment|/* Find the end of the current name.  */
name|SKIP_UNTIL2
argument_list|(
name|s
argument_list|,
name|e
argument_list|,
literal|' '
argument_list|,
literal|'\n'
argument_list|,
literal|"IMPORT AS: No newline at the end of the current name"
argument_list|)
expr_stmt|;
comment|/* Skip (backwards) over spaces at the end of the current name.  */
name|current_name_end
operator|=
name|s
expr_stmt|;
name|current_name_end_char
operator|=
operator|*
name|current_name_end
expr_stmt|;
name|SKIP_WHILE
argument_list|(
name|s
argument_list|,
name|e
argument_list|,
literal|' '
argument_list|,
literal|"IMPORT AS: Current name just followed by spaces"
argument_list|)
expr_stmt|;
comment|/* Skip past the newline character.  */
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|SYMBIAN_DEBUG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IMPORT AS: No newline at end of directive\n"
argument_list|)
expr_stmt|;
comment|/* Terminate the current name after having performed the skips.  */
operator|*
name|current_name_end
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|sh_symbian_import_as
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|current_name
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
comment|/* The next character should be a NUL.  */
if|if
condition|(
operator|*
name|s
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|SYMBIAN_DEBUG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IMPORT AS: Junk at end of directive\n"
argument_list|)
expr_stmt|;
name|result
operator|=
name|FALSE
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
operator|*
name|current_name_end
operator|=
name|current_name_end_char
expr_stmt|;
block|}
comment|/* Restore the characters we overwrote, since 		 the .directive section will be emitted.  */
operator|*
name|new_name_end
operator|=
name|name_end_char
expr_stmt|;
block|}
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
operator|!
name|CONST_STRNEQ
argument_list|(
name|s
argument_list|,
name|DIRECTIVE_EXPORT
argument_list|)
condition|)
name|result
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|name_end
decl_stmt|;
name|char
name|name_end_char
decl_stmt|;
comment|/* Skip the directive.  */
name|s
operator|+=
name|strlen
argument_list|(
name|DIRECTIVE_EXPORT
argument_list|)
expr_stmt|;
name|name
operator|=
name|s
expr_stmt|;
comment|/* Find the end of the name to be exported.  */
name|SKIP_UNTIL
argument_list|(
name|s
argument_list|,
name|e
argument_list|,
literal|'\n'
argument_list|,
literal|"EXPORT: no newline at end of directive"
argument_list|)
expr_stmt|;
comment|/* Skip (backwards) over spaces at end of exported name.  */
for|for
control|(
name|name_end
operator|=
name|s
init|;
name|name_end
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|;
name|name_end
operator|--
control|)
empty_stmt|;
comment|/* name_end now points at the first character after the 		 end of the exported name, so we can termiante it  */
name|name_end_char
operator|=
operator|*
name|name_end
expr_stmt|;
operator|*
name|name_end
operator|=
literal|0
expr_stmt|;
comment|/* Skip passed the newline character.  */
name|s
operator|++
expr_stmt|;
name|result
operator|=
name|sh_symbian_export
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* The next character should be a NUL.  */
if|if
condition|(
operator|*
name|s
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|SYMBIAN_DEBUG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"EXPORT: Junk at end of directive\n"
argument_list|)
expr_stmt|;
name|result
operator|=
name|FALSE
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
comment|/* Restore the character we deleted.  */
operator|*
name|name_end
operator|=
name|name_end_char
expr_stmt|;
block|}
break|break;
default|default:
name|result
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|result
condition|)
block|{
if|if
condition|(
name|SYMBIAN_DEBUG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"offset into .directive section: %ld\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|directive
operator|-
operator|(
name|char
operator|*
operator|)
name|contents
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"%B: Unrecognised .directive command: %s"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|directive
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Scan a bfd for a .directive section, and if found process it.    Returns TRUE upon success, FALSE otherwise.  */
end_comment

begin_function_decl
name|bfd_boolean
name|bfd_elf32_sh_symbian_process_directives
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|bfd_boolean
name|bfd_elf32_sh_symbian_process_directives
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|bfd_boolean
name|result
init|=
name|FALSE
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|asection
modifier|*
name|sec
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".directive"
argument_list|)
decl_stmt|;
name|bfd_size_type
name|sz
decl_stmt|;
if|if
condition|(
operator|!
name|sec
condition|)
return|return
name|TRUE
return|;
name|sz
operator|=
name|sec
operator|->
name|rawsize
condition|?
name|sec
operator|->
name|rawsize
else|:
name|sec
operator|->
name|size
expr_stmt|;
name|contents
operator|=
name|bfd_malloc
argument_list|(
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|contents
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_no_memory
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
literal|0
argument_list|,
name|sz
argument_list|)
condition|)
name|result
operator|=
name|sh_symbian_process_embedded_commands
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Intercept the normal sh_relocate_section() function    and magle the relocs to allow for symbol renaming.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sh_symbian_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
comment|/* When performing a final link we implement the IMPORT AS directives.  */
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
condition|)
block|{
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes_end
decl_stmt|;
name|struct
name|elf_link_hash_table
modifier|*
name|hash_table
decl_stmt|;
name|symbol_rename
modifier|*
name|ptr
decl_stmt|;
name|bfd_size_type
name|num_global_syms
decl_stmt|;
name|unsigned
name|long
name|num_local_syms
decl_stmt|;
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_bad_symtab
argument_list|(
name|input_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|hash_table
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|num_local_syms
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|num_global_syms
operator|=
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
expr_stmt|;
name|num_global_syms
operator|-=
name|num_local_syms
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|sym_hashes_end
operator|=
name|sym_hashes
operator|+
name|num_global_syms
expr_stmt|;
comment|/* First scan the rename table, caching the hash entry and the new index.  */
for|for
control|(
name|ptr
operator|=
name|rename_list
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|new_hash
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|h
decl_stmt|;
name|ptr
operator|->
name|current_hash
operator|=
name|elf_link_hash_lookup
argument_list|(
name|hash_table
argument_list|,
name|ptr
operator|->
name|current_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|current_hash
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|SYMBIAN_DEBUG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IMPORT AS: current symbol '%s' does not exist\n"
argument_list|,
name|ptr
operator|->
name|current_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|new_hash
operator|=
name|elf_link_hash_lookup
argument_list|(
name|hash_table
argument_list|,
name|ptr
operator|->
name|new_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* If we could not find the symbol then it is a new, undefined symbol. 	     Symbian want this behaviour - ie they want to be able to rename the 	     reference in a reloc from one undefined symbol to another, new and 	     undefined symbol.  So we create that symbol here.  */
if|if
condition|(
name|new_hash
operator|==
name|NULL
condition|)
block|{
name|asection
modifier|*
name|psec
init|=
name|bfd_und_section_ptr
decl_stmt|;
name|Elf_Internal_Sym
name|new_sym
decl_stmt|;
name|bfd_vma
name|new_value
init|=
literal|0
decl_stmt|;
name|bfd_boolean
name|skip
decl_stmt|;
name|bfd_boolean
name|override
decl_stmt|;
name|bfd_boolean
name|type_change_ok
decl_stmt|;
name|bfd_boolean
name|size_change_ok
decl_stmt|;
name|new_sym
operator|.
name|st_value
operator|=
literal|0
expr_stmt|;
name|new_sym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|new_sym
operator|.
name|st_name
operator|=
operator|-
literal|1
expr_stmt|;
name|new_sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|STT_FUNC
argument_list|)
expr_stmt|;
name|new_sym
operator|.
name|st_other
operator|=
name|ELF_ST_VISIBILITY
argument_list|(
name|STV_DEFAULT
argument_list|)
expr_stmt|;
name|new_sym
operator|.
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_merge_symbol
argument_list|(
name|input_bfd
argument_list|,
name|info
argument_list|,
name|ptr
operator|->
name|new_name
argument_list|,
operator|&
name|new_sym
argument_list|,
operator|&
name|psec
argument_list|,
operator|&
name|new_value
argument_list|,
name|NULL
argument_list|,
operator|&
name|new_hash
argument_list|,
operator|&
name|skip
argument_list|,
operator|&
name|override
argument_list|,
operator|&
name|type_change_ok
argument_list|,
operator|&
name|size_change_ok
argument_list|)
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"%B: Failed to add renamed symbol %s"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|ptr
operator|->
name|new_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* XXX - should we check psec, skip, override etc ?  */
name|new_hash
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_undefined
expr_stmt|;
comment|/* Allow the symbol to become local if necessary.  */
if|if
condition|(
name|new_hash
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
name|new_hash
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SYMBIAN_DEBUG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Created new symbol %s\n"
argument_list|,
name|ptr
operator|->
name|new_name
argument_list|)
expr_stmt|;
block|}
comment|/* Convert the new_hash value into a index into the table of symbol hashes.  */
for|for
control|(
name|h
operator|=
name|sym_hashes
init|;
name|h
operator|<
name|sym_hashes_end
condition|;
name|h
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|h
operator|==
name|new_hash
condition|)
block|{
name|ptr
operator|->
name|new_symndx
operator|=
name|h
operator|-
name|sym_hashes
operator|+
name|num_local_syms
expr_stmt|;
if|if
condition|(
name|SYMBIAN_DEBUG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Converted new hash to index of %ld\n"
argument_list|,
name|ptr
operator|->
name|new_symndx
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* If the new symbol is not in the hash table then it must be 	     because it is one of the newly created undefined symbols 	     manufactured above.  So we extend the sym has table here to 	     include this extra symbol.  */
if|if
condition|(
name|h
operator|==
name|sym_hashes_end
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|new_sym_hashes
decl_stmt|;
comment|/* This is not very efficient, but it works.  */
operator|++
name|num_global_syms
expr_stmt|;
name|new_sym_hashes
operator|=
name|bfd_alloc
argument_list|(
name|input_bfd
argument_list|,
name|num_global_syms
operator|*
sizeof|sizeof
expr|*
name|sym_hashes
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_sym_hashes
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|SYMBIAN_DEBUG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Out of memory extending hash table\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|memcpy
argument_list|(
name|new_sym_hashes
argument_list|,
name|sym_hashes
argument_list|,
operator|(
name|num_global_syms
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|sym_hashes
argument_list|)
expr_stmt|;
name|new_sym_hashes
index|[
name|num_global_syms
operator|-
literal|1
index|]
operator|=
name|new_hash
expr_stmt|;
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
operator|=
name|sym_hashes
operator|=
name|new_sym_hashes
expr_stmt|;
name|sym_hashes_end
operator|=
name|sym_hashes
operator|+
name|num_global_syms
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_size
operator|=
operator|(
name|num_global_syms
operator|+
name|num_local_syms
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|new_symndx
operator|=
name|num_global_syms
operator|-
literal|1
operator|+
name|num_local_syms
expr_stmt|;
if|if
condition|(
name|SYMBIAN_DEBUG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Extended symbol hash table to insert new symbol as index %ld\n"
argument_list|,
name|ptr
operator|->
name|new_symndx
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Walk the reloc list looking for references to renamed symbols. 	 When we find one, we alter the index in the reloc to point to the new symbol.  */
for|for
control|(
name|rel
operator|=
name|relocs
operator|,
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
comment|/* Ignore unused relocs.  */
if|if
condition|(
operator|(
name|r_type
operator|>=
operator|(
name|int
operator|)
name|R_SH_GNU_VTINHERIT
operator|&&
name|r_type
operator|<=
operator|(
name|int
operator|)
name|R_SH_LABEL
operator|)
operator|||
name|r_type
operator|==
operator|(
name|int
operator|)
name|R_SH_NONE
operator|||
name|r_type
operator|<
literal|0
operator|||
name|r_type
operator|>=
name|R_SH_max
condition|)
continue|continue;
comment|/* Ignore relocs against local symbols.  */
if|if
condition|(
name|r_symndx
operator|<
name|num_local_syms
condition|)
continue|continue;
name|BFD_ASSERT
argument_list|(
name|r_symndx
operator|<
operator|(
name|num_global_syms
operator|+
name|num_local_syms
operator|)
argument_list|)
expr_stmt|;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|num_local_syms
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* If the symbol is defined there is no need to rename it. 	     XXX - is this true ?  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
continue|continue;
for|for
control|(
name|ptr
operator|=
name|rename_list
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
if|if
condition|(
name|h
operator|==
name|ptr
operator|->
name|current_hash
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|ptr
operator|->
name|new_symndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBIAN_DEBUG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"convert reloc %lx from using index %ld to using index %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_info
argument_list|,
operator|(
name|long
operator|)
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
argument_list|,
name|ptr
operator|->
name|new_symndx
argument_list|)
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ptr
operator|->
name|new_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|sh_elf_relocate_section
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|relocs
argument_list|,
name|local_syms
argument_list|,
name|local_sections
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|sh_symbian_check_directives
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
return|return
name|bfd_elf32_sh_symbian_process_directives
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_shl_symbian_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-shl-symbian"
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_relocate_section
end_undef

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|sh_symbian_relocate_section
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_check_directives
end_undef

begin_define
define|#
directive|define
name|elf_backend_check_directives
value|sh_symbian_check_directives
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

