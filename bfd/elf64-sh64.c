begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* SuperH SH64-specific support for 64-bit ELF    Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_define
define|#
directive|define
name|SH64_ELF64
end_define

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/sh.h"
end_include

begin_comment
comment|/* Add a suffix for datalabel indirection symbols.  It must not match any    other symbols; user symbols with or without version or other    decoration.  It must only be used internally and not emitted by any    means.  */
end_comment

begin_define
define|#
directive|define
name|DATALABEL_SUFFIX
value|" DL"
end_define

begin_define
define|#
directive|define
name|GOT_BIAS
value|(-((long)-32768))
end_define

begin_define
define|#
directive|define
name|PLT_ENTRY_SIZE
value|64
end_define

begin_comment
comment|/* Return size of a PLT entry.  */
end_comment

begin_define
define|#
directive|define
name|elf_sh64_sizeof_plt
parameter_list|(
name|info
parameter_list|)
value|PLT_ENTRY_SIZE
end_define

begin_comment
comment|/* Return offset of the PLT0 address in an absolute PLT entry.  */
end_comment

begin_define
define|#
directive|define
name|elf_sh64_plt_plt0_offset
parameter_list|(
name|info
parameter_list|)
value|32
end_define

begin_comment
comment|/* Return offset of the linker in PLT0 entry.  */
end_comment

begin_define
define|#
directive|define
name|elf_sh64_plt0_gotplt_offset
parameter_list|(
name|info
parameter_list|)
value|0
end_define

begin_comment
comment|/* Return offset of the trampoline in PLT entry */
end_comment

begin_define
define|#
directive|define
name|elf_sh64_plt_temp_offset
parameter_list|(
name|info
parameter_list|)
value|33
end_define

begin_comment
comment|/* Add one because it's SHmedia.  */
end_comment

begin_comment
comment|/* Return offset of the symbol in PLT entry.  */
end_comment

begin_define
define|#
directive|define
name|elf_sh64_plt_symbol_offset
parameter_list|(
name|info
parameter_list|)
value|0
end_define

begin_comment
comment|/* Return offset of the relocation in PLT entry.  */
end_comment

begin_define
define|#
directive|define
name|elf_sh64_plt_reloc_offset
parameter_list|(
name|info
parameter_list|)
value|(info->shared ? 52 : 44)
end_define

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/usr/lib/libc.so.1"
end_define

begin_comment
comment|/* The sh linker needs to keep track of the number of relocs that it    decides to copy in check_relocs for each symbol.  This is so that    it can discard PC relative relocs if it doesn't need them when    linking with -Bsymbolic.  We store the information in a field    extending the regular ELF linker hash table.  */
end_comment

begin_comment
comment|/* This structure keeps track of the number of PC relative relocs we    have copied for a given symbol.  */
end_comment

begin_struct
struct|struct
name|elf_sh64_pcrel_relocs_copied
block|{
comment|/* Next section.  */
name|struct
name|elf_sh64_pcrel_relocs_copied
modifier|*
name|next
decl_stmt|;
comment|/* A section in dynobj.  */
name|asection
modifier|*
name|section
decl_stmt|;
comment|/* Number of relocs copied in this section.  */
name|bfd_size_type
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* sh ELF linker hash entry.  */
end_comment

begin_struct
struct|struct
name|elf_sh64_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|root
decl_stmt|;
name|bfd_vma
name|datalabel_got_offset
decl_stmt|;
comment|/* Number of PC relative relocs copied for this symbol.  */
name|struct
name|elf_sh64_pcrel_relocs_copied
modifier|*
name|pcrel_relocs_copied
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* sh ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|elf_sh64_link_hash_table
block|{
name|struct
name|elf_link_hash_table
name|root
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Traverse an sh ELF linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|sh64_elf64_link_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
define|\
value|(elf_link_hash_traverse						\    (&(table)->root,							\     (bfd_boolean (*) (struct elf_link_hash_entry *, void *)) (func), \     (info)))
end_define

begin_comment
comment|/* Get the sh ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|sh64_elf64_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct elf_sh64_link_hash_table *) ((p)->hash))
end_define

begin_function_decl
specifier|static
name|bfd_boolean
name|sh_elf64_copy_private_data
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sh_elf64_copy_private_data_internal
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sh_elf64_merge_private_data
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|sh_elf64_ignore_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|sh_elf64_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|reloc_howto_type
modifier|*
name|sh_elf64_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd_reloc_code_real_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sh_elf64_info_to_howto
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sh_elf64_relocate_section
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|Elf_Internal_Sym
modifier|*
parameter_list|,
name|asection
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_byte
modifier|*
name|sh_elf64_get_relocated_section_contents
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|struct
name|bfd_link_order
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|,
name|asymbol
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sh_elf64_set_mach_from_flags
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sh_elf64_set_private_flags
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|flagword
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|asection
modifier|*
name|sh_elf64_gc_mark_hook
parameter_list|(
name|asection
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
parameter_list|,
name|Elf_Internal_Sym
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sh_elf64_gc_sweep_hook
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sh_elf64_check_relocs
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sh64_elf64_get_symbol_type
parameter_list|(
name|Elf_Internal_Sym
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sh64_elf64_add_symbol_hook
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|Elf_Internal_Sym
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|flagword
modifier|*
parameter_list|,
name|asection
modifier|*
modifier|*
parameter_list|,
name|bfd_vma
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sh64_elf64_link_output_symbol_hook
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|Elf_Internal_Sym
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sh64_elf64_fake_sections
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sh64_elf64_final_write_processing
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|sh64_elf64_link_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|sh64_elf64_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|inline
specifier|static
name|void
name|movi_shori_putval
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|inline
specifier|static
name|void
name|movi_3shori_putval
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sh64_elf64_create_dynamic_sections
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sh64_elf64_adjust_dynamic_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sh64_elf64_discard_copies
parameter_list|(
name|struct
name|elf_sh64_link_hash_entry
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sh64_elf64_size_dynamic_sections
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sh64_elf64_finish_dynamic_symbol
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
parameter_list|,
name|Elf_Internal_Sym
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|sh64_elf64_finish_dynamic_sections
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|sh_elf64_howto_table
index|[]
init|=
block|{
comment|/* No relocation.  */
name|HOWTO
argument_list|(
name|R_SH_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf64_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_NONE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit absolute relocation.  Setting partial_inplace to TRUE and      src_mask to a non-zero value is similar to the COFF toolchain.  */
name|HOWTO
argument_list|(
name|R_SH_DIR32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf64_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR32"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* 32 bit PC relative relocation.  */
name|HOWTO
argument_list|(
name|R_SH_REL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf64_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_REL32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* For 32-bit sh, this is R_SH_DIR8WPN.  */
name|EMPTY_HOWTO
argument_list|(
literal|3
argument_list|)
block|,
comment|/* For 32-bit sh, this is R_SH_IND12W.  */
name|EMPTY_HOWTO
argument_list|(
literal|4
argument_list|)
block|,
comment|/* For 32-bit sh, this is R_SH_DIR8WPL.  */
name|EMPTY_HOWTO
argument_list|(
literal|5
argument_list|)
block|,
comment|/* For 32-bit sh, this is R_SH_DIR8WPZ.  */
name|EMPTY_HOWTO
argument_list|(
literal|6
argument_list|)
block|,
comment|/* For 32-bit sh, this is R_SH_DIR8BP.  */
name|EMPTY_HOWTO
argument_list|(
literal|7
argument_list|)
block|,
comment|/* For 32-bit sh, this is R_SH_DIR8W.  */
name|EMPTY_HOWTO
argument_list|(
literal|8
argument_list|)
block|,
comment|/* For 32-bit sh, this is R_SH_DIR8L.  */
name|EMPTY_HOWTO
argument_list|(
literal|9
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|10
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|11
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|12
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|13
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|14
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|15
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|16
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|17
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|18
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|19
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|20
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|21
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|22
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|23
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|24
argument_list|)
block|,
comment|/* The remaining relocs are a GNU extension used for relaxing.  The      final pass of the linker never needs to do anything with any of      these relocs.  Any required operations are handled by the      relaxation code.  */
comment|/* A 16 bit switch table entry.  This is generated for an expression      such as ``.word L1 - L2''.  The offset holds the difference      between the reloc address and L2.  */
name|HOWTO
argument_list|(
name|R_SH_SWITCH16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf64_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_SWITCH16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32 bit switch table entry.  This is generated for an expression      such as ``.long L1 - L2''.  The offset holds the difference      between the reloc address and L2.  */
name|HOWTO
argument_list|(
name|R_SH_SWITCH32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf64_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_SWITCH32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* For 32-bit sh, this is R_SH_USES.  */
name|EMPTY_HOWTO
argument_list|(
literal|27
argument_list|)
block|,
comment|/* For 32-bit sh, this is R_SH_COUNT.  */
name|EMPTY_HOWTO
argument_list|(
literal|28
argument_list|)
block|,
comment|/* For 32-bit sh, this is R_SH_ALIGN.  FIXME: For linker relaxation,      this might be emitted.  When linker relaxation is implemented, we      might want to use it.  */
name|EMPTY_HOWTO
argument_list|(
literal|29
argument_list|)
block|,
comment|/* For 32-bit sh, this is R_SH_CODE.  FIXME: For linker relaxation,      this might be emitted.  When linker relaxation is implemented, we      might want to use it.  */
name|EMPTY_HOWTO
argument_list|(
literal|30
argument_list|)
block|,
comment|/* For 32-bit sh, this is R_SH_DATA.  FIXME: For linker relaxation,      this might be emitted.  When linker relaxation is implemented, we      might want to use it.  */
name|EMPTY_HOWTO
argument_list|(
literal|31
argument_list|)
block|,
comment|/* For 32-bit sh, this is R_SH_LABEL.  FIXME: For linker relaxation,      this might be emitted.  When linker relaxation is implemented, we      might want to use it.  */
name|EMPTY_HOWTO
argument_list|(
literal|32
argument_list|)
block|,
comment|/* An 8 bit switch table entry.  This is generated for an expression      such as ``.word L1 - L2''.  The offset holds the difference      between the reloc address and L2.  */
name|HOWTO
argument_list|(
name|R_SH_SWITCH8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf64_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_SWITCH8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable hierarchy */
name|HOWTO
argument_list|(
name|R_SH_GNU_VTINHERIT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_SH_GNU_VTINHERIT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable member usage */
name|HOWTO
argument_list|(
name|R_SH_GNU_VTENTRY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_elf_rel_vtable_reloc_fn
argument_list|,
comment|/* special_function */
literal|"R_SH_GNU_VTENTRY"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* For 32-bit sh, this is R_SH_LOOP_START.  */
name|EMPTY_HOWTO
argument_list|(
literal|36
argument_list|)
block|,
comment|/* For 32-bit sh, this is R_SH_LOOP_END.  */
name|EMPTY_HOWTO
argument_list|(
literal|37
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|38
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|39
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|40
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|41
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|42
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|43
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|44
argument_list|)
block|,
comment|/* Used in SHLLI.L and SHLRI.L.  */
name|HOWTO
argument_list|(
name|R_SH_DIR5U
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|5
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR5U"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in SHARI, SHLLI et al.  */
name|HOWTO
argument_list|(
name|R_SH_DIR6U
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|6
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR6U"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in BxxI, LDHI.L et al.  */
name|HOWTO
argument_list|(
name|R_SH_DIR6S
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|6
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR6S"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xfc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in ADDI, ANDI et al.  */
name|HOWTO
argument_list|(
name|R_SH_DIR10S
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|10
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR10S"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in LD.UW, ST.W et al.  */
name|HOWTO
argument_list|(
name|R_SH_DIR10SW
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|11
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR10SW"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in LD.L, FLD.S et al.  */
name|HOWTO
argument_list|(
name|R_SH_DIR10SL
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR10SL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in FLD.D, FST.P et al.  */
name|HOWTO
argument_list|(
name|R_SH_DIR10SQ
argument_list|,
comment|/* type */
literal|3
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|13
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_DIR10SQ"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|52
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|53
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|54
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|55
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|56
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|57
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|58
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|59
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|60
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|61
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|62
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|63
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|64
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|65
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|66
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|67
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|68
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|69
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|70
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|71
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|72
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|73
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|74
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|75
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|76
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|77
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|78
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|79
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|80
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|81
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|82
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|83
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|84
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|85
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|86
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|87
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|88
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|89
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|90
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|91
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|92
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|93
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|94
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|95
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|96
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|97
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|98
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|99
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|100
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|101
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|102
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|103
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|104
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|105
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|106
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|107
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|108
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|109
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|110
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|111
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|112
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|113
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|114
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|115
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|116
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|117
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|118
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|119
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|120
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|121
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|122
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|123
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|124
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|125
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|126
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|127
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|128
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|129
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|130
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|131
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|132
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|133
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|134
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|135
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|136
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|137
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|138
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|139
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|140
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|141
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|142
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|143
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|144
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|145
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|146
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|147
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|148
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|149
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|150
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|151
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|152
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|153
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|154
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|155
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|156
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|157
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|158
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|159
argument_list|)
block|,
comment|/* Relocs for dynamic linking for 32-bit SH would follow.  We don't have      any dynamic linking support for 64-bit SH at present.  */
name|EMPTY_HOWTO
argument_list|(
literal|160
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|161
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|162
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|163
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|164
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|165
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|166
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|167
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|168
argument_list|)
block|,
comment|/* Back to SH5 relocations.  */
comment|/* Used in MOVI and SHORI (x& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOT_LOW16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOT_LOW16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 16)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOT_MEDLOW16
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOT_MEDLOW16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 32)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOT_MEDHI16
argument_list|,
comment|/* type */
literal|32
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOT_MEDHI16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 48)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOT_HI16
argument_list|,
comment|/* type */
literal|48
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOT_HI16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI (x& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOTPLT_LOW16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTPLT_LOW16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 16)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOTPLT_MEDLOW16
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTPLT_MEDLOW16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 32)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOTPLT_MEDHI16
argument_list|,
comment|/* type */
literal|32
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTPLT_MEDHI16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 48)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOTPLT_HI16
argument_list|,
comment|/* type */
literal|48
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTPLT_HI16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI (x& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_PLT_LOW16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_PLT_LOW16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 16)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_PLT_MEDLOW16
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_PLT_MEDLOW16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 32)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_PLT_MEDHI16
argument_list|,
comment|/* type */
literal|32
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_PLT_MEDHI16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 48)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_PLT_HI16
argument_list|,
comment|/* type */
literal|48
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_PLT_HI16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI (x& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOTOFF_LOW16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTOFF_LOW16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 16)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOTOFF_MEDLOW16
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTOFF_MEDLOW16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 32)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOTOFF_MEDHI16
argument_list|,
comment|/* type */
literal|32
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTOFF_MEDHI16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 48)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOTOFF_HI16
argument_list|,
comment|/* type */
literal|48
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTOFF_HI16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI (x& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOTPC_LOW16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTPC_LOW16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 16)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOTPC_MEDLOW16
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTPC_MEDLOW16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 32)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOTPC_MEDHI16
argument_list|,
comment|/* type */
literal|32
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTPC_MEDHI16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 48)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_GOTPC_HI16
argument_list|,
comment|/* type */
literal|48
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTPC_HI16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in LD.L, FLD.S et al.  */
name|HOWTO
argument_list|(
name|R_SH_GOT10BY4
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOT10BY4"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in LD.L, FLD.S et al.  */
name|HOWTO
argument_list|(
name|R_SH_GOTPLT10BY4
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTPLT10BY4"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in FLD.D, FST.P et al.  */
name|HOWTO
argument_list|(
name|R_SH_GOT10BY8
argument_list|,
comment|/* type */
literal|3
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|13
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOT10BY8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in FLD.D, FST.P et al.  */
name|HOWTO
argument_list|(
name|R_SH_GOTPLT10BY8
argument_list|,
comment|/* type */
literal|3
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|13
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GOTPLT10BY8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_COPY64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_COPY64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
operator|(
operator|(
name|bfd_vma
operator|)
literal|0
operator|)
operator|-
literal|1
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_GLOB_DAT64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_GLOB_DAT64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
operator|(
operator|(
name|bfd_vma
operator|)
literal|0
operator|)
operator|-
literal|1
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_JMP_SLOT64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_JMP_SLOT64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
operator|(
operator|(
name|bfd_vma
operator|)
literal|0
operator|)
operator|-
literal|1
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_RELATIVE64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_RELATIVE64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
operator|(
operator|(
name|bfd_vma
operator|)
literal|0
operator|)
operator|-
literal|1
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|197
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|198
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|199
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|200
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|201
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|202
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|203
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|204
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|205
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|206
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|207
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|208
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|209
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|210
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|211
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|212
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|213
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|214
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|215
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|216
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|217
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|218
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|219
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|220
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|221
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|222
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|223
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|224
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|225
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|226
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|227
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|228
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|229
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|230
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|231
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|232
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|233
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|234
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|235
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|236
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|237
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|238
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|239
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|240
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|241
argument_list|)
block|,
comment|/* Relocations for SHmedia code.  None of these are partial_inplace or      use the field being relocated.  */
comment|/* The assembler will generate this reloc before a block of SHmedia      instructions.  A section should be processed as assuming it contains      data, unless this reloc is seen.  Note that a block of SHcompact      instructions are instead preceded by R_SH_CODE.      This is currently not implemented, but should be used for SHmedia      linker relaxation.  */
name|HOWTO
argument_list|(
name|R_SH_SHMEDIA_CODE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_elf64_ignore_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_SHMEDIA_CODE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The assembler will generate this reloc at a PTA or PTB instruction,      and the linker checks the right type of target, or changes a PTA to a      PTB, if the original insn was PT.  */
name|HOWTO
argument_list|(
name|R_SH_PT_16
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|18
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_PT_16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in unexpanded MOVI.  */
name|HOWTO
argument_list|(
name|R_SH_IMMS16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_IMMS16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in SHORI.  */
name|HOWTO
argument_list|(
name|R_SH_IMMU16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_IMMU16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI (x& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_IMM_LOW16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_IMM_LOW16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x - $)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_IMM_LOW16_PCREL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_IMM_LOW16_PCREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 16)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_IMM_MEDLOW16
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_IMM_MEDLOW16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI (((x - $)>> 16)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_IMM_MEDLOW16_PCREL
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_IMM_MEDLOW16_PCREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 32)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_IMM_MEDHI16
argument_list|,
comment|/* type */
literal|32
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_IMM_MEDHI16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI (((x - $)>> 32)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_IMM_MEDHI16_PCREL
argument_list|,
comment|/* type */
literal|32
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_IMM_MEDHI16_PCREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI ((x>> 48)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_IMM_HI16
argument_list|,
comment|/* type */
literal|48
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_IMM_HI16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used in MOVI and SHORI (((x - $)>> 48)& 65536).  */
name|HOWTO
argument_list|(
name|R_SH_IMM_HI16_PCREL
argument_list|,
comment|/* type */
literal|48
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_IMM_HI16_PCREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x3fffc00
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* For the .uaquad pseudo.  */
name|HOWTO
argument_list|(
name|R_SH_64
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|4
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_64"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
operator|(
operator|(
name|bfd_vma
operator|)
literal|0
operator|)
operator|-
literal|1
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* For the .uaquad pseudo, (x - $).  */
name|HOWTO
argument_list|(
name|R_SH_64_PCREL
argument_list|,
comment|/* type */
literal|48
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|10
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_SH_64_PCREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
operator|(
operator|(
name|bfd_vma
operator|)
literal|0
operator|)
operator|-
literal|1
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function is used for relocs which are only used for relaxing,    which the linker should otherwise ignore.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|sh_elf64_ignore_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* This function is used for normal relocs.  This used to be like the COFF    function, and is almost certainly incorrect for other ELF targets.     See sh_elf_reloc in elf32-sh.c for the original.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|sh_elf64_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol_in
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
name|bfd_vma
name|sym_value
decl_stmt|;
name|enum
name|elf_sh_reloc_type
name|r_type
decl_stmt|;
name|bfd_vma
name|addr
init|=
name|reloc_entry
operator|->
name|address
decl_stmt|;
name|bfd_byte
modifier|*
name|hit_data
init|=
name|addr
operator|+
operator|(
name|bfd_byte
operator|*
operator|)
name|data
decl_stmt|;
name|r_type
operator|=
operator|(
expr|enum
name|elf_sh_reloc_type
operator|)
name|reloc_entry
operator|->
name|howto
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
block|{
comment|/* Partial linking--do nothing.  */
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|symbol_in
operator|!=
name|NULL
operator|&&
name|bfd_is_und_section
argument_list|(
name|symbol_in
operator|->
name|section
argument_list|)
condition|)
return|return
name|bfd_reloc_undefined
return|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol_in
operator|->
name|section
argument_list|)
condition|)
name|sym_value
operator|=
literal|0
expr_stmt|;
else|else
name|sym_value
operator|=
operator|(
name|symbol_in
operator|->
name|value
operator|+
name|symbol_in
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|symbol_in
operator|->
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_SH_DIR32
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|insn
operator|+=
name|sym_value
operator|+
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* This structure is used to map BFD reloc codes to SH ELF relocs.  */
end_comment

begin_struct
struct|struct
name|elf_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_val
decl_stmt|;
name|unsigned
name|char
name|elf_reloc_val
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* An array mapping BFD reloc codes to SH ELF relocs.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elf_reloc_map
name|sh64_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_SH_NONE
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_SH_DIR32
block|}
block|,
block|{
name|BFD_RELOC_CTOR
block|,
name|R_SH_DIR32
block|}
block|,
block|{
name|BFD_RELOC_32_PCREL
block|,
name|R_SH_REL32
block|}
block|,
block|{
name|BFD_RELOC_8_PCREL
block|,
name|R_SH_SWITCH8
block|}
block|,
block|{
name|BFD_RELOC_SH_SWITCH16
block|,
name|R_SH_SWITCH16
block|}
block|,
block|{
name|BFD_RELOC_SH_SWITCH32
block|,
name|R_SH_SWITCH32
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_INHERIT
block|,
name|R_SH_GNU_VTINHERIT
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_ENTRY
block|,
name|R_SH_GNU_VTENTRY
block|}
block|,
block|{
name|BFD_RELOC_SH_GOT_LOW16
block|,
name|R_SH_GOT_LOW16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOT_MEDLOW16
block|,
name|R_SH_GOT_MEDLOW16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOT_MEDHI16
block|,
name|R_SH_GOT_MEDHI16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOT_HI16
block|,
name|R_SH_GOT_HI16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTPLT_LOW16
block|,
name|R_SH_GOTPLT_LOW16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTPLT_MEDLOW16
block|,
name|R_SH_GOTPLT_MEDLOW16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTPLT_MEDHI16
block|,
name|R_SH_GOTPLT_MEDHI16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTPLT_HI16
block|,
name|R_SH_GOTPLT_HI16
block|}
block|,
block|{
name|BFD_RELOC_SH_PLT_LOW16
block|,
name|R_SH_PLT_LOW16
block|}
block|,
block|{
name|BFD_RELOC_SH_PLT_MEDLOW16
block|,
name|R_SH_PLT_MEDLOW16
block|}
block|,
block|{
name|BFD_RELOC_SH_PLT_MEDHI16
block|,
name|R_SH_PLT_MEDHI16
block|}
block|,
block|{
name|BFD_RELOC_SH_PLT_HI16
block|,
name|R_SH_PLT_HI16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTOFF_LOW16
block|,
name|R_SH_GOTOFF_LOW16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTOFF_MEDLOW16
block|,
name|R_SH_GOTOFF_MEDLOW16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTOFF_MEDHI16
block|,
name|R_SH_GOTOFF_MEDHI16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTOFF_HI16
block|,
name|R_SH_GOTOFF_HI16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTPC_LOW16
block|,
name|R_SH_GOTPC_LOW16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTPC_MEDLOW16
block|,
name|R_SH_GOTPC_MEDLOW16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTPC_MEDHI16
block|,
name|R_SH_GOTPC_MEDHI16
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTPC_HI16
block|,
name|R_SH_GOTPC_HI16
block|}
block|,
block|{
name|BFD_RELOC_SH_COPY64
block|,
name|R_SH_COPY64
block|}
block|,
block|{
name|BFD_RELOC_SH_GLOB_DAT64
block|,
name|R_SH_GLOB_DAT64
block|}
block|,
block|{
name|BFD_RELOC_SH_JMP_SLOT64
block|,
name|R_SH_JMP_SLOT64
block|}
block|,
block|{
name|BFD_RELOC_SH_RELATIVE64
block|,
name|R_SH_RELATIVE64
block|}
block|,
block|{
name|BFD_RELOC_SH_GOT10BY4
block|,
name|R_SH_GOT10BY4
block|}
block|,
block|{
name|BFD_RELOC_SH_GOT10BY8
block|,
name|R_SH_GOT10BY8
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTPLT10BY4
block|,
name|R_SH_GOTPLT10BY4
block|}
block|,
block|{
name|BFD_RELOC_SH_GOTPLT10BY8
block|,
name|R_SH_GOTPLT10BY8
block|}
block|,
block|{
name|BFD_RELOC_SH_PT_16
block|,
name|R_SH_PT_16
block|}
block|,
block|{
name|BFD_RELOC_SH_SHMEDIA_CODE
block|,
name|R_SH_SHMEDIA_CODE
block|}
block|,
block|{
name|BFD_RELOC_SH_IMMU5
block|,
name|R_SH_DIR5U
block|}
block|,
block|{
name|BFD_RELOC_SH_IMMS6
block|,
name|R_SH_DIR6S
block|}
block|,
block|{
name|BFD_RELOC_SH_IMMU6
block|,
name|R_SH_DIR6U
block|}
block|,
block|{
name|BFD_RELOC_SH_IMMS10
block|,
name|R_SH_DIR10S
block|}
block|,
block|{
name|BFD_RELOC_SH_IMMS10BY2
block|,
name|R_SH_DIR10SW
block|}
block|,
block|{
name|BFD_RELOC_SH_IMMS10BY4
block|,
name|R_SH_DIR10SL
block|}
block|,
block|{
name|BFD_RELOC_SH_IMMS10BY8
block|,
name|R_SH_DIR10SQ
block|}
block|,
block|{
name|BFD_RELOC_SH_IMMS16
block|,
name|R_SH_IMMS16
block|}
block|,
block|{
name|BFD_RELOC_SH_IMMU16
block|,
name|R_SH_IMMU16
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM_LOW16
block|,
name|R_SH_IMM_LOW16
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM_LOW16_PCREL
block|,
name|R_SH_IMM_LOW16_PCREL
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM_MEDLOW16
block|,
name|R_SH_IMM_MEDLOW16
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM_MEDLOW16_PCREL
block|,
name|R_SH_IMM_MEDLOW16_PCREL
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM_MEDHI16
block|,
name|R_SH_IMM_MEDHI16
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM_MEDHI16_PCREL
block|,
name|R_SH_IMM_MEDHI16_PCREL
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM_HI16
block|,
name|R_SH_IMM_HI16
block|}
block|,
block|{
name|BFD_RELOC_SH_IMM_HI16_PCREL
block|,
name|R_SH_IMM_HI16_PCREL
block|}
block|,
block|{
name|BFD_RELOC_64
block|,
name|R_SH_64
block|}
block|,
block|{
name|BFD_RELOC_64_PCREL
block|,
name|R_SH_64_PCREL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a BFD reloc code, return the howto structure for the    corresponding SH ELf reloc.  */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|sh_elf64_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|sh64_reloc_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|elf_reloc_map
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sh64_reloc_map
index|[
name|i
index|]
operator|.
name|bfd_reloc_val
operator|==
name|code
condition|)
return|return
operator|&
name|sh_elf64_howto_table
index|[
operator|(
name|int
operator|)
name|sh64_reloc_map
index|[
name|i
index|]
operator|.
name|elf_reloc_val
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Given an ELF reloc, fill in the howto field of a relent.     See sh_elf_info_to_howto in elf32-sh.c for the original.  */
end_comment

begin_function
specifier|static
name|void
name|sh_elf64_info_to_howto
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|cache_ptr
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|dst
parameter_list|)
block|{
name|unsigned
name|int
name|r
decl_stmt|;
name|r
operator|=
name|ELF64_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r
operator|<=
operator|(
name|unsigned
name|int
operator|)
name|R_SH_64_PCREL
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r
operator|<
name|R_SH_FIRST_INVALID_RELOC
operator|||
name|r
operator|>
name|R_SH_LAST_INVALID_RELOC
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r
operator|<
name|R_SH_DIR8WPN
operator|||
name|r
operator|>
name|R_SH_LAST_INVALID_RELOC_2
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r
operator|<
name|R_SH_FIRST_INVALID_RELOC_3
operator|||
name|r
operator|>
name|R_SH_GOTPLT32
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r
operator|<
name|R_SH_FIRST_INVALID_RELOC_4
operator|||
name|r
operator|>
name|R_SH_LAST_INVALID_RELOC_4
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|sh_elf64_howto_table
index|[
name|r
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Relocate an SH ELF section.     See sh_elf_info_to_howto in elf32-sh.c for the original.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sh_elf64_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|sgotplt
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|bfd_vma
name|disp
decl_stmt|,
name|dropped
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|NULL
expr_stmt|;
name|sgotplt
operator|=
name|NULL
expr_stmt|;
name|splt
operator|=
name|NULL
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_vma
name|addend
init|=
operator|(
name|bfd_vma
operator|)
literal|0
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|int
name|seen_stt_datalabel
init|=
literal|0
decl_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
operator|(
name|int
operator|)
name|R_SH_NONE
condition|)
continue|continue;
if|if
condition|(
name|r_type
operator|<
literal|0
operator|||
name|r_type
operator|>
name|R_SH_64_PCREL
operator|||
operator|(
name|r_type
operator|>=
operator|(
name|int
operator|)
name|R_SH_FIRST_INVALID_RELOC
operator|&&
name|r_type
operator|<=
operator|(
name|int
operator|)
name|R_SH_LAST_INVALID_RELOC
operator|)
operator|||
operator|(
name|r_type
operator|>=
operator|(
name|int
operator|)
name|R_SH_DIR8WPN
operator|&&
name|r_type
operator|<=
operator|(
name|int
operator|)
name|R_SH_LAST_INVALID_RELOC
operator|)
operator|||
operator|(
name|r_type
operator|>=
operator|(
name|int
operator|)
name|R_SH_GNU_VTINHERIT
operator|&&
name|r_type
operator|<=
operator|(
name|int
operator|)
name|R_SH_PSHL
operator|)
operator|||
operator|(
name|r_type
operator|>=
operator|(
name|int
operator|)
name|R_SH_FIRST_INVALID_RELOC_2
operator|&&
name|r_type
operator|<=
name|R_SH_GOTPLT32
operator|)
operator|||
operator|(
name|r_type
operator|>=
operator|(
name|int
operator|)
name|R_SH_FIRST_INVALID_RELOC_4
operator|&&
name|r_type
operator|<=
operator|(
name|int
operator|)
name|R_SH_LAST_INVALID_RELOC_4
operator|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|howto
operator|=
name|sh_elf64_howto_table
operator|+
name|r_type
expr_stmt|;
comment|/* This is a final link.  */
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
operator|(
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
operator|)
operator||
operator|(
operator|(
name|sym
operator|->
name|st_other
operator|&
name|STO_SH5_ISA32
operator|)
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
comment|/* A local symbol never has STO_SH5_ISA32, so we don't need 	     datalabel processing here.  Make sure this does not change 	     without notice.  */
if|if
condition|(
operator|(
name|sym
operator|->
name|st_other
operator|&
name|STO_SH5_ISA32
operator|)
operator|!=
literal|0
condition|)
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"Unexpected STO_SH5_ISA32 on local symbol is not handled"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
block|{
comment|/* This is a relocatable link.  We don't have to change 		 anything, unless the reloc is against a section symbol, 		 in which case we have to adjust according to where the 		 section symbol winds up in the output section.  */
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
goto|goto
name|final_link_relocate
goto|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|howto
operator|->
name|partial_inplace
condition|)
block|{
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|relocation
operator||=
operator|(
operator|(
name|sym
operator|->
name|st_other
operator|&
name|STO_SH5_ISA32
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_MERGE
operator|)
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
name|asection
modifier|*
name|msec
decl_stmt|;
if|if
condition|(
name|howto
operator|->
name|rightshift
operator|||
name|howto
operator|->
name|src_mask
operator|!=
literal|0xffffffff
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s(%s+0x%lx): %s relocation against SEC_MERGE section"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|addend
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|msec
operator|=
name|sec
expr_stmt|;
name|addend
operator|=
name|_bfd_elf_rel_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|msec
argument_list|,
name|addend
argument_list|)
operator|-
name|relocation
expr_stmt|;
name|addend
operator|+=
name|msec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|msec
operator|->
name|output_offset
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|addend
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|addend
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* ??? Could we use the RELOC_FOR_GLOBAL_SYMBOL macro here ?  */
comment|/* Section symbols are never (?) placed in the hash table, so 	     we can just ignore hash relocations when creating a 	     relocatable object file.  */
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
continue|continue;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
block|{
comment|/* If the reference passes a symbol marked with 		 STT_DATALABEL, then any STO_SH5_ISA32 on the final value 		 doesn't count.  */
name|seen_stt_datalabel
operator||=
name|h
operator|->
name|type
operator|==
name|STT_DATALABEL
expr_stmt|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
comment|/* In these cases, we don't need the relocation value. 		 We check specially because in some obscure cases 		 sec->output_section will be NULL.  */
if|if
condition|(
name|r_type
operator|==
name|R_SH_GOTPC_LOW16
operator|||
name|r_type
operator|==
name|R_SH_GOTPC_MEDLOW16
operator|||
name|r_type
operator|==
name|R_SH_GOTPC_MEDHI16
operator|||
name|r_type
operator|==
name|R_SH_GOTPC_HI16
operator|||
operator|(
operator|(
name|r_type
operator|==
name|R_SH_PLT_LOW16
operator|||
name|r_type
operator|==
name|R_SH_PLT_MEDLOW16
operator|||
name|r_type
operator|==
name|R_SH_PLT_MEDHI16
operator|||
name|r_type
operator|==
name|R_SH_PLT_HI16
operator|)
operator|&&
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|)
operator|||
operator|(
operator|(
name|r_type
operator|==
name|R_SH_GOT_LOW16
operator|||
name|r_type
operator|==
name|R_SH_GOT_MEDLOW16
operator|||
name|r_type
operator|==
name|R_SH_GOT_MEDHI16
operator|||
name|r_type
operator|==
name|R_SH_GOT_HI16
operator|)
operator|&&
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|&&
operator|(
operator|!
name|info
operator|->
name|shared
operator|||
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|)
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
comment|/* The cases above are those in which relocation is 		     overwritten in the switch block below.  The cases 		     below are those in which we must defer relocation 		     to run-time, because we can't resolve absolute 		     addresses when creating a shared library.  */
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|)
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|r_type
operator|==
name|R_SH_64
operator|&&
operator|!
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_INTERNAL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_HIDDEN
operator|)
operator|)
operator|||
name|r_type
operator|==
name|R_SH_64_PCREL
operator|)
operator|&&
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
comment|/* DWARF will emit R_SH_DIR32 relocations in its 			     sections against symbols defined externally 			     in shared libraries.  We can't do anything 			     with them here.  */
operator|||
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|)
operator|)
comment|/* Dynamic relocs are not propagated for SEC_DEBUGGING 		     sections because such sections are not SEC_ALLOC and 		     thus ld.so will not process them.  */
operator|||
operator|(
name|sec
operator|->
name|output_section
operator|==
name|NULL
operator|&&
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
operator|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|->
name|output_section
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: warning: unresolvable relocation against symbol `%s' from %s section"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|)
expr_stmt|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|relocation
operator|=
operator|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
comment|/* A STO_SH5_ISA32 causes a "bitor 1" to the 				 symbol value, unless we've seen 				 STT_DATALABEL on the way to it.  */
operator||
operator|(
operator|(
name|h
operator|->
name|other
operator|&
name|STO_SH5_ISA32
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|seen_stt_datalabel
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|unresolved_syms_in_objects
operator|==
name|RM_IGNORE
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
operator|(
name|info
operator|->
name|unresolved_syms_in_objects
operator|==
name|RM_GENERATE_ERROR
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|)
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|disp
operator|=
operator|(
name|relocation
operator|-
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|-
name|input_section
operator|->
name|output_offset
operator|-
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
name|dropped
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|r_type
condition|)
block|{
case|case
name|R_SH_PT_16
case|:
name|dropped
operator|=
name|disp
operator|&
literal|2
expr_stmt|;
break|break;
case|case
name|R_SH_DIR10SW
case|:
name|dropped
operator|=
name|disp
operator|&
literal|1
expr_stmt|;
break|break;
case|case
name|R_SH_DIR10SL
case|:
name|dropped
operator|=
name|disp
operator|&
literal|3
expr_stmt|;
break|break;
case|case
name|R_SH_DIR10SQ
case|:
name|dropped
operator|=
name|disp
operator|&
literal|7
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dropped
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: error: unaligned relocation type %d at %08x reloc %08x\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|r_type
argument_list|,
operator|(
name|unsigned
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
operator|(
name|unsigned
operator|)
name|relocation
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
switch|switch
condition|(
operator|(
name|int
operator|)
name|r_type
condition|)
block|{
case|case
name|R_SH_64
case|:
case|case
name|R_SH_64_PCREL
case|:
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|r_type
operator|!=
name|R_SH_64_PCREL
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_boolean
name|skip
decl_stmt|,
name|relocate
decl_stmt|;
comment|/* When generating a shared object, these relocations 		 are copied into the output file to be resolved at run 		 time.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|elf_elfheader
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|BFD_ASSERT
argument_list|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|skip
operator|=
name|FALSE
expr_stmt|;
name|relocate
operator|=
name|FALSE
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|skip
operator|=
name|TRUE
operator|,
name|relocate
operator|=
name|TRUE
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|outrel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_SH_64_PCREL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_SH_64_PCREL
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
else|else
block|{
comment|/* h->dynindx may be -1 if this symbol was marked to 		     become local.  */
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
operator|(
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|relocate
operator|=
name|TRUE
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_SH_RELATIVE64
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_SH_64
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
block|}
name|loc
operator|=
name|sreloc
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|sreloc
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
comment|/* If this reloc is against an external symbol, we do 		 not want to fiddle with the addend.  Otherwise, we 		 need to include the symbol value so that it becomes 		 an addend for the dynamic reloc.  */
if|if
condition|(
operator|!
name|relocate
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_SH_64
condition|)
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
goto|goto
name|final_link_relocate
goto|;
case|case
name|R_SH_GOTPLT_LOW16
case|:
case|case
name|R_SH_GOTPLT_MEDLOW16
case|:
case|case
name|R_SH_GOTPLT_MEDHI16
case|:
case|case
name|R_SH_GOTPLT_HI16
case|:
case|case
name|R_SH_GOTPLT10BY4
case|:
case|case
name|R_SH_GOTPLT10BY8
case|:
comment|/* Relocation is to the entry for this symbol in the 	     procedure linkage table.  */
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_INTERNAL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_HIDDEN
operator|||
operator|!
name|info
operator|->
name|shared
operator|||
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
name|h
operator|->
name|plt
operator|.
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|||
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
goto|goto
name|force_got
goto|;
comment|/* Relocation is to the entry for this symbol in the global 	     offset table extension for the procedure linkage table.  */
if|if
condition|(
name|sgotplt
operator|==
name|NULL
condition|)
block|{
name|sgotplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgotplt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|relocation
operator|=
operator|(
name|sgotplt
operator|->
name|output_offset
operator|+
operator|(
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|/
name|elf_sh64_sizeof_plt
argument_list|(
name|info
argument_list|)
operator|-
literal|1
operator|+
literal|3
operator|)
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
name|relocation
operator|-=
name|GOT_BIAS
expr_stmt|;
goto|goto
name|final_link_relocate
goto|;
name|force_got
label|:
case|case
name|R_SH_GOT_LOW16
case|:
case|case
name|R_SH_GOT_MEDLOW16
case|:
case|case
name|R_SH_GOT_MEDHI16
case|:
case|case
name|R_SH_GOT_HI16
case|:
case|case
name|R_SH_GOT10BY4
case|:
case|case
name|R_SH_GOT10BY8
case|:
comment|/* Relocation is to the entry for this symbol in the global 	     offset table.  */
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
block|{
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|bfd_vma
name|off
decl_stmt|;
name|off
operator|=
name|h
operator|->
name|got
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|seen_stt_datalabel
condition|)
block|{
name|struct
name|elf_sh64_link_hash_entry
modifier|*
name|hsh
decl_stmt|;
name|hsh
operator|=
operator|(
expr|struct
name|elf_sh64_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|off
operator|=
name|hsh
operator|->
name|datalabel_got_offset
expr_stmt|;
block|}
name|BFD_ASSERT
argument_list|(
name|off
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_INTERNAL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_HIDDEN
operator|)
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|)
condition|)
block|{
comment|/* This is actually a static link, or it is a 		     -Bsymbolic link and the symbol is defined 		     locally, or the symbol was forced to be local 		     because of a version file.  We must initialize 		     this entry in the global offset table.  Since the 		     offset must always be a multiple of 4, we use the 		     least significant bit to record whether we have 		     initialized it already.  		     When doing a dynamic link, we create a .rela.got 		     relocation entry to initialize the value.  This 		     is done in the finish_dynamic_symbol routine.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|seen_stt_datalabel
condition|)
block|{
name|struct
name|elf_sh64_link_hash_entry
modifier|*
name|hsh
decl_stmt|;
name|hsh
operator|=
operator|(
expr|struct
name|elf_sh64_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|hsh
operator|->
name|datalabel_got_offset
operator||=
literal|1
expr_stmt|;
block|}
else|else
name|h
operator|->
name|got
operator|.
name|offset
operator||=
literal|1
expr_stmt|;
block|}
block|}
name|relocation
operator|=
name|sgot
operator|->
name|output_offset
operator|+
name|off
expr_stmt|;
block|}
else|else
block|{
name|bfd_vma
name|off
decl_stmt|;
if|if
condition|(
name|rel
operator|->
name|r_addend
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|local_got_offsets
operator|!=
name|NULL
operator|&&
operator|(
name|local_got_offsets
index|[
name|symtab_hdr
operator|->
name|sh_info
operator|+
name|r_symndx
index|]
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|off
operator|=
name|local_got_offsets
index|[
name|symtab_hdr
operator|->
name|sh_info
operator|+
name|r_symndx
index|]
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|local_got_offsets
operator|!=
name|NULL
operator|&&
name|local_got_offsets
index|[
name|r_symndx
index|]
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|off
operator|=
name|local_got_offsets
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
comment|/* The offset must always be a multiple of 8.  We use 		 the least significant bit to record whether we have 		 already generated the necessary reloc.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_SH_RELATIVE64
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
expr_stmt|;
name|loc
operator|=
name|s
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|s
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rel
operator|->
name|r_addend
condition|)
name|local_got_offsets
index|[
name|symtab_hdr
operator|->
name|sh_info
operator|+
name|r_symndx
index|]
operator||=
literal|1
expr_stmt|;
else|else
name|local_got_offsets
index|[
name|r_symndx
index|]
operator||=
literal|1
expr_stmt|;
block|}
name|relocation
operator|=
name|sgot
operator|->
name|output_offset
operator|+
name|off
expr_stmt|;
block|}
name|relocation
operator|-=
name|GOT_BIAS
expr_stmt|;
goto|goto
name|final_link_relocate
goto|;
case|case
name|R_SH_GOTOFF_LOW16
case|:
case|case
name|R_SH_GOTOFF_MEDLOW16
case|:
case|case
name|R_SH_GOTOFF_MEDHI16
case|:
case|case
name|R_SH_GOTOFF_HI16
case|:
comment|/* Relocation is relative to the start of the global offset 	     table.  */
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
block|{
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Note that sgot->output_offset is not involved in this 	     calculation.  We always want the start of .got.  If we 	     defined _GLOBAL_OFFSET_TABLE in a different way, as is 	     permitted by the ABI, we might have to change this 	     calculation.  */
name|relocation
operator|-=
name|sgot
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|-=
name|GOT_BIAS
expr_stmt|;
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
goto|goto
name|final_link_relocate
goto|;
case|case
name|R_SH_GOTPC_LOW16
case|:
case|case
name|R_SH_GOTPC_MEDLOW16
case|:
case|case
name|R_SH_GOTPC_MEDHI16
case|:
case|case
name|R_SH_GOTPC_HI16
case|:
comment|/* Use global offset table as symbol value.  */
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
block|{
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|relocation
operator|=
name|sgot
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|GOT_BIAS
expr_stmt|;
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
goto|goto
name|final_link_relocate
goto|;
case|case
name|R_SH_PLT_LOW16
case|:
case|case
name|R_SH_PLT_MEDLOW16
case|:
case|case
name|R_SH_PLT_MEDHI16
case|:
case|case
name|R_SH_PLT_HI16
case|:
comment|/* Relocation is to the entry for this symbol in the 	     procedure linkage table.  */
comment|/* Resolve a PLT reloc against a local symbol directly, 	     without using the procedure linkage table.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
goto|goto
name|final_link_relocate
goto|;
if|if
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_INTERNAL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_HIDDEN
condition|)
goto|goto
name|final_link_relocate
goto|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* We didn't make a PLT entry for this symbol.  This 		 happens when statically linking PIC code, or when 		 using -Bsymbolic.  */
goto|goto
name|final_link_relocate
goto|;
block|}
if|if
condition|(
name|splt
operator|==
name|NULL
condition|)
block|{
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|relocation
operator|=
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
name|relocation
operator|++
expr_stmt|;
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
goto|goto
name|final_link_relocate
goto|;
case|case
name|R_SH_DIR32
case|:
case|case
name|R_SH_SHMEDIA_CODE
case|:
case|case
name|R_SH_PT_16
case|:
case|case
name|R_SH_DIR5U
case|:
case|case
name|R_SH_DIR6S
case|:
case|case
name|R_SH_DIR6U
case|:
case|case
name|R_SH_DIR10S
case|:
case|case
name|R_SH_DIR10SW
case|:
case|case
name|R_SH_DIR10SL
case|:
case|case
name|R_SH_DIR10SQ
case|:
case|case
name|R_SH_IMMS16
case|:
case|case
name|R_SH_IMMU16
case|:
case|case
name|R_SH_IMM_LOW16
case|:
case|case
name|R_SH_IMM_LOW16_PCREL
case|:
case|case
name|R_SH_IMM_MEDLOW16
case|:
case|case
name|R_SH_IMM_MEDLOW16_PCREL
case|:
case|case
name|R_SH_IMM_MEDHI16
case|:
case|case
name|R_SH_IMM_MEDHI16_PCREL
case|:
case|case
name|R_SH_IMM_HI16
case|:
case|case
name|R_SH_IMM_HI16_PCREL
case|:
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
comment|/* Fall through.  */
case|case
name|R_SH_REL32
case|:
name|final_link_relocate
label|:
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|addend
argument_list|)
expr_stmt|;
break|break;
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
switch|switch
condition|(
name|r
condition|)
block|{
default|default:
case|case
name|bfd_reloc_outofrange
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_overflow
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
break|break;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This is a version of bfd_generic_get_relocated_section_contents    that uses sh_elf64_relocate_section.     See sh_elf_relocate_section in elf32-sh.c for the original.  */
end_comment

begin_function
specifier|static
name|bfd_byte
modifier|*
name|sh_elf64_get_relocated_section_contents
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|struct
name|bfd_link_order
modifier|*
name|link_order
parameter_list|,
name|bfd_byte
modifier|*
name|data
parameter_list|,
name|bfd_boolean
name|relocatable
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|input_section
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
init|=
name|input_section
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sections
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
comment|/* We only need to handle the case of relaxing, or of having a      particular set of section contents, specially.  */
if|if
condition|(
name|relocatable
operator|||
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|==
name|NULL
condition|)
return|return
name|bfd_generic_get_relocated_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|link_info
argument_list|,
name|link_order
argument_list|,
name|data
argument_list|,
name|relocatable
argument_list|,
name|symbols
argument_list|)
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
argument_list|,
name|input_section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|input_section
operator|->
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|Elf_Internal_Sym
modifier|*
name|isymp
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymend
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secpp
decl_stmt|;
comment|/* Read this BFD's local symbols.  */
if|if
condition|(
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
name|internal_relocs
operator|=
operator|(
name|_bfd_elf_link_read_relocs
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|sections
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|symtab_hdr
operator|->
name|sh_info
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sections
operator|==
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|sh_info
operator|>
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|secpp
operator|=
name|sections
expr_stmt|;
name|isymend
operator|=
name|isymbuf
operator|+
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
name|isymp
operator|=
name|isymbuf
init|;
name|isymp
operator|<
name|isymend
condition|;
operator|++
name|isymp
operator|,
operator|++
name|secpp
control|)
block|{
name|asection
modifier|*
name|isec
decl_stmt|;
if|if
condition|(
name|isymp
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|isec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isymp
operator|->
name|st_shndx
operator|>
literal|0
operator|&&
name|isymp
operator|->
name|st_shndx
operator|<
name|SHN_LORESERVE
condition|)
name|isec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|input_bfd
argument_list|,
name|isymp
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isymp
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|isec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isymp
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|isec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
block|{
comment|/* Who knows?  */
name|isec
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|secpp
operator|=
name|isec
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sh_elf64_relocate_section
argument_list|(
name|output_bfd
argument_list|,
name|link_info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|data
argument_list|,
name|internal_relocs
argument_list|,
name|isymbuf
argument_list|,
name|sections
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
operator|!=
name|symtab_hdr
operator|->
name|contents
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
block|}
return|return
name|data
return|;
name|error_return
label|:
if|if
condition|(
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|internal_relocs
operator|!=
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
operator|!=
name|symtab_hdr
operator|->
name|contents
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set the SHF_SH5_ISA32 flag for ISA SHmedia code sections.  */
end_comment

begin_function
name|bfd_boolean
name|sh64_elf64_fake_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|elf_section_hdr
parameter_list|,
name|asection
modifier|*
name|asect
parameter_list|)
block|{
comment|/* Code sections can only contain SH64 code, so mark them as such.  */
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|output_bfd
argument_list|,
name|asect
argument_list|)
operator|&
name|SEC_CODE
condition|)
name|elf_section_hdr
operator|->
name|sh_flags
operator||=
name|SHF_SH5_ISA32
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|sh_elf64_set_mach_from_flags
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|flagword
name|flags
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
decl_stmt|;
switch|switch
condition|(
name|flags
operator|&
name|EF_SH_MACH_MASK
condition|)
block|{
case|case
name|EF_SH5
case|:
comment|/* Just one, but keep the switch construct to make additions easy.  */
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_sh
argument_list|,
name|bfd_mach_sh5
argument_list|)
expr_stmt|;
break|break;
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Function to keep SH64 specific file flags.     See sh64_elf_set_private_flags in elf32-sh64.c for the original.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sh_elf64_set_private_flags
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|flagword
name|flags
parameter_list|)
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|||
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|==
name|flags
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
return|return
name|sh_elf64_set_mach_from_flags
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Copy the SHF_SH5_ISA32 attribute that we keep on all sections with    code, to keep attributes the same as for SHmedia in 32-bit ELF.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sh_elf64_copy_private_data_internal
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|o_shdrp
decl_stmt|;
name|asection
modifier|*
name|isec
decl_stmt|;
name|asection
modifier|*
name|osec
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
name|o_shdrp
operator|=
name|elf_elfsections
argument_list|(
name|obfd
argument_list|)
expr_stmt|;
for|for
control|(
name|osec
operator|=
name|obfd
operator|->
name|sections
init|;
name|osec
condition|;
name|osec
operator|=
name|osec
operator|->
name|next
control|)
block|{
name|int
name|oIndex
init|=
operator|(
operator|(
expr|struct
name|bfd_elf_section_data
operator|*
operator|)
name|elf_section_data
argument_list|(
name|osec
argument_list|)
operator|)
operator|->
name|this_idx
decl_stmt|;
for|for
control|(
name|isec
operator|=
name|ibfd
operator|->
name|sections
init|;
name|isec
condition|;
name|isec
operator|=
name|isec
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|osec
operator|->
name|name
argument_list|,
name|isec
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Note that we're not disallowing mixing data and code.  */
if|if
condition|(
operator|(
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_flags
operator|&
name|SHF_SH5_ISA32
operator|)
operator|!=
literal|0
condition|)
name|o_shdrp
index|[
name|oIndex
index|]
operator|->
name|sh_flags
operator||=
name|SHF_SH5_ISA32
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|sh_elf64_set_private_flags
argument_list|(
name|obfd
argument_list|,
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|sh_elf64_copy_private_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
return|return
name|sh_elf64_copy_private_data_internal
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|sh_elf64_merge_private_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|flagword
name|old_flags
decl_stmt|,
name|new_flags
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_generic_verify_endian_match
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|bfd_get_arch_size
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_get_arch_size
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
name|bfd_get_arch_size
argument_list|(
name|ibfd
argument_list|)
operator|==
literal|32
operator|&&
name|bfd_get_arch_size
argument_list|(
name|obfd
argument_list|)
operator|==
literal|64
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"%s: compiled as 32-bit object and %s is 64-bit"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_get_arch_size
argument_list|(
name|ibfd
argument_list|)
operator|==
literal|64
operator|&&
name|bfd_get_arch_size
argument_list|(
name|obfd
argument_list|)
operator|==
literal|32
condition|)
name|msg
operator|=
name|_
argument_list|(
literal|"%s: compiled as 64-bit object and %s is 32-bit"
argument_list|)
expr_stmt|;
else|else
name|msg
operator|=
name|_
argument_list|(
literal|"%s: object size does not match that of target %s"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|msg
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|old_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|new_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
comment|/* This happens when ld starts out with a 'blank' output file.  */
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|old_flags
operator|=
name|new_flags
expr_stmt|;
block|}
comment|/* We don't allow linking in anything else than SH64 code, and since      this is a 64-bit ELF, we assume the 64-bit ABI is used.  Add code      here as things change.  */
elseif|else
if|if
condition|(
operator|(
name|new_flags
operator|&
name|EF_SH_MACH_MASK
operator|)
operator|!=
name|EF_SH5
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: does not use the SH64 64-bit ABI as previous modules do"
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|sh_elf64_copy_private_data_internal
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
comment|/* I can't think of anything sane other than old_flags being EF_SH5 and      that we need to preserve that.  */
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|old_flags
expr_stmt|;
return|return
name|sh_elf64_set_mach_from_flags
argument_list|(
name|obfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the section that should be marked against GC for a given    relocation.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|sh_elf64_gc_mark_hook
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_SH_GNU_VTINHERIT
case|:
case|case
name|R_SH_GNU_VTENTRY
case|:
break|break;
default|default:
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|&&
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
default|default:
break|break;
block|}
block|}
block|}
else|else
return|return
name|bfd_section_from_elf_index
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Update the got entry reference counts for the section being removed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sh_elf64_gc_sweep_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* No got and plt entries for 64-bit SH at present.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase.    Since we don't do .gots or .plts, we just need to consider the    virtual table relocs for gc.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sh_elf64_check_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|,
modifier|*
modifier|*
name|sym_hashes_end
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|sgot
operator|=
name|NULL
expr_stmt|;
name|srelgot
operator|=
name|NULL
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_hashes_end
operator|=
name|sym_hashes
operator|+
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf64_External_Sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|sym_hashes_end
operator|-=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|r_symndx
operator|=
name|ELF64_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
comment|/* Some relocs require a global offset table.  */
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_SH_GOTPLT_LOW16
case|:
case|case
name|R_SH_GOTPLT_MEDLOW16
case|:
case|case
name|R_SH_GOTPLT_MEDHI16
case|:
case|case
name|R_SH_GOTPLT_HI16
case|:
case|case
name|R_SH_GOTPLT10BY4
case|:
case|case
name|R_SH_GOTPLT10BY8
case|:
case|case
name|R_SH_GOT_LOW16
case|:
case|case
name|R_SH_GOT_MEDLOW16
case|:
case|case
name|R_SH_GOT_MEDHI16
case|:
case|case
name|R_SH_GOT_HI16
case|:
case|case
name|R_SH_GOT10BY4
case|:
case|case
name|R_SH_GOT10BY8
case|:
case|case
name|R_SH_GOTOFF_LOW16
case|:
case|case
name|R_SH_GOTOFF_MEDLOW16
case|:
case|case
name|R_SH_GOTOFF_MEDHI16
case|:
case|case
name|R_SH_GOTOFF_HI16
case|:
case|case
name|R_SH_GOTPC_LOW16
case|:
case|case
name|R_SH_GOTPC_MEDLOW16
case|:
case|case
name|R_SH_GOTPC_MEDHI16
case|:
case|case
name|R_SH_GOTPC_HI16
case|:
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
default|default:
break|break;
block|}
block|}
switch|switch
condition|(
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
comment|/* This relocation describes the C++ object vtable hierarchy. 	     Reconstruct it for later use during GC.  */
case|case
name|R_SH_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually 	     used.  Record for later use during GC.  */
case|case
name|R_SH_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
name|force_got
label|:
case|case
name|R_SH_GOT_LOW16
case|:
case|case
name|R_SH_GOT_MEDLOW16
case|:
case|case
name|R_SH_GOT_MEDHI16
case|:
case|case
name|R_SH_GOT_HI16
case|:
case|case
name|R_SH_GOT10BY4
case|:
case|case
name|R_SH_GOT10BY8
case|:
comment|/* This symbol requires a global offset table entry.  */
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
block|{
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|srelgot
operator|==
name|NULL
operator|&&
operator|(
name|h
operator|!=
name|NULL
operator|||
name|info
operator|->
name|shared
operator|)
condition|)
block|{
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srelgot
operator|==
name|NULL
condition|)
block|{
name|srelgot
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srelgot
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|srelgot
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|srelgot
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_DATALABEL
condition|)
block|{
name|struct
name|elf_sh64_link_hash_entry
modifier|*
name|hsh
decl_stmt|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|hsh
operator|=
operator|(
expr|struct
name|elf_sh64_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|hsh
operator|->
name|datalabel_got_offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
break|break;
name|hsh
operator|->
name|datalabel_got_offset
operator|=
name|sgot
operator|->
name|_raw_size
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* We have already allocated space in the .got.  */
break|break;
block|}
name|h
operator|->
name|got
operator|.
name|offset
operator|=
name|sgot
operator|->
name|_raw_size
expr_stmt|;
block|}
comment|/* Make sure this symbol is output as a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|srelgot
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a global offset table entry for a local 		 symbol.  */
if|if
condition|(
name|local_got_offsets
operator|==
name|NULL
condition|)
block|{
name|size_t
name|size
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
name|size
operator|=
name|symtab_hdr
operator|->
name|sh_info
operator|*
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
expr_stmt|;
comment|/* Reserve space for both the datalabel and 		     codelabel local GOT offsets.  */
name|size
operator|*=
literal|2
expr_stmt|;
name|local_got_offsets
operator|=
operator|(
name|bfd_vma
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_offsets
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_local_got_offsets
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_got_offsets
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|;
name|i
operator|++
control|)
name|local_got_offsets
index|[
name|i
index|]
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
literal|2
operator|*
name|symtab_hdr
operator|->
name|sh_info
condition|;
name|i
operator|++
control|)
name|local_got_offsets
index|[
name|i
index|]
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rel
operator|->
name|r_addend
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|local_got_offsets
index|[
name|symtab_hdr
operator|->
name|sh_info
operator|+
name|r_symndx
index|]
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* We have already allocated space in the .got.  */
break|break;
block|}
name|local_got_offsets
index|[
name|symtab_hdr
operator|->
name|sh_info
operator|+
name|r_symndx
index|]
operator|=
name|sgot
operator|->
name|_raw_size
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|local_got_offsets
index|[
name|r_symndx
index|]
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* We have already allocated space in the .got.  */
break|break;
block|}
name|local_got_offsets
index|[
name|r_symndx
index|]
operator|=
name|sgot
operator|->
name|_raw_size
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* If we are generating a shared object, we need to 		     output a R_SH_RELATIVE reloc so that the dynamic 		     linker can adjust this GOT entry.  */
name|srelgot
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
block|}
block|}
name|sgot
operator|->
name|_raw_size
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|R_SH_GOTPLT_LOW16
case|:
case|case
name|R_SH_GOTPLT_MEDLOW16
case|:
case|case
name|R_SH_GOTPLT_MEDHI16
case|:
case|case
name|R_SH_GOTPLT_HI16
case|:
case|case
name|R_SH_GOTPLT10BY4
case|:
case|case
name|R_SH_GOTPLT10BY8
case|:
comment|/* If this is a local symbol, we resolve it directly without 	     creating a procedure linkage table entry.  */
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_INTERNAL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_HIDDEN
operator|||
operator|!
name|info
operator|->
name|shared
operator|||
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
goto|goto
name|force_got
goto|;
comment|/* Make sure this symbol is output as a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
break|break;
case|case
name|R_SH_PLT_LOW16
case|:
case|case
name|R_SH_PLT_MEDLOW16
case|:
case|case
name|R_SH_PLT_MEDHI16
case|:
case|case
name|R_SH_PLT_HI16
case|:
comment|/* This symbol requires a procedure linkage table entry.  We 	     actually build the entry in adjust_dynamic_symbol, 	     because this might be a case of linking PIC code which is 	     never referenced by a dynamic object, in which case we 	     don't need to generate a procedure linkage table entry 	     after all.  */
comment|/* If this is a local symbol, we resolve it directly without 	     creating a procedure linkage table entry.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_INTERNAL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_HIDDEN
condition|)
break|break;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
break|break;
case|case
name|R_SH_64
case|:
case|case
name|R_SH_64_PCREL
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_NON_GOT_REF
expr_stmt|;
comment|/* If we are creating a shared library, and this is a reloc 	     against a global symbol, or a non PC relative reloc 	     against a local symbol, then we need to copy the reloc 	     into the shared library.  However, if we are linking with 	     -Bsymbolic, we do not need to copy a reloc against a 	     global symbol which is defined in an object we are 	     including in the link (i.e., DEF_REGULAR is set).  At 	     this point we have not seen all the input files, so it is 	     possible that DEF_REGULAR is not set now but will be set 	     later (it is never cleared).  We account for that 	     possibility below by storing information in the 	     pcrel_relocs_copied field of the hash table entry.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_SH_64_PCREL
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* When creating a shared object, we must copy these 		 reloc types into the output file.  We create a reloc 		 section in dynobj and make room for this reloc.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|BFD_ASSERT
argument_list|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
name|sreloc
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
name|sreloc
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
comment|/* If we are linking with -Bsymbolic, and this is a 		 global symbol, we count the number of PC relative 		 relocations we have entered for this symbol, so that 		 we can discard them again if the symbol is later 		 defined by a regular object.  Note that this function 		 is only called if we are using an elf_sh linker 		 hash table, which means that h is really a pointer to 		 an elf_sh_link_hash_entry.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|info
operator|->
name|symbolic
operator|&&
name|ELF64_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_SH_64_PCREL
condition|)
block|{
name|struct
name|elf_sh64_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf_sh64_pcrel_relocs_copied
modifier|*
name|p
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf_sh64_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|pcrel_relocs_copied
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|section
operator|==
name|sreloc
condition|)
break|break;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
operator|(
operator|(
expr|struct
name|elf_sh64_pcrel_relocs_copied
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|dynobj
argument_list|,
sizeof|sizeof
expr|*
name|p
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|p
operator|->
name|next
operator|=
name|eh
operator|->
name|pcrel_relocs_copied
expr_stmt|;
name|eh
operator|->
name|pcrel_relocs_copied
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|section
operator|=
name|sreloc
expr_stmt|;
name|p
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
operator|++
name|p
operator|->
name|count
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sh64_elf64_get_symbol_type
parameter_list|(
name|Elf_Internal_Sym
modifier|*
name|elf_sym
parameter_list|,
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|elf_sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_DATALABEL
condition|)
return|return
name|STT_DATALABEL
return|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* FIXME: This is a copy of sh64_elf_add_symbol_hook in elf32-sh64.c.    Either file can presumably exist without the other, but do not differ    in elf-size-ness.  How to share?     Hook called by the linker routine which adds symbols from an object    file.  We must make indirect symbols for undefined symbols marked with    STT_DATALABEL, so relocations passing them will pick up that attribute    and neutralize STO_SH5_ISA32 found on the symbol definition.     There is a problem, though: We want to fill in the hash-table entry for    this symbol and signal to the caller that no further processing is    needed.  But we don't have the index for this hash-table entry.  We    rely here on that the current entry is the first hash-entry with NULL,    which seems brittle.  Also, iterating over the hash-table to find that    entry is a linear operation on the number of symbols in this input    file, and this function should take constant time, so that's not good    too.  Only comfort is that DataLabel references should only be found in    hand-written assembly code and thus be rare.  FIXME: Talk maintainers    into adding an option to elf_add_symbol_hook (preferably) for the index    or the hash entry, alternatively adding the index to Elf_Internal_Sym    (not so good).  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sh64_elf64_add_symbol_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|namep
parameter_list|,
name|flagword
modifier|*
name|flagsp
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
modifier|*
name|secp
parameter_list|,
name|bfd_vma
modifier|*
name|valp
parameter_list|)
block|{
comment|/* We want to do this for relocatable as well as final linking.  */
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_DATALABEL
operator|&&
name|is_elf_hash_table
argument_list|(
name|info
operator|->
name|hash
argument_list|)
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* For relocatable links, we register the DataLabel sym in its own 	 right, and tweak the name when it's output.  Otherwise, we make 	 an indirect symbol of it.  */
name|flagword
name|flags
init|=
name|info
operator|->
name|relocatable
operator|||
name|info
operator|->
name|emitrelocations
condition|?
name|BSF_GLOBAL
else|:
name|BSF_GLOBAL
operator||
name|BSF_INDIRECT
decl_stmt|;
name|char
modifier|*
name|dl_name
init|=
name|bfd_malloc
argument_list|(
name|strlen
argument_list|(
operator|*
name|namep
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|DATALABEL_SUFFIX
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hash
init|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sym_hash
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Allocation may fail.  */
if|if
condition|(
name|dl_name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|strcpy
argument_list|(
name|dl_name
argument_list|,
operator|*
name|namep
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dl_name
argument_list|,
name|DATALABEL_SUFFIX
argument_list|)
expr_stmt|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|dl_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
comment|/* No previous datalabel symbol.  Make one.  */
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|dl_name
argument_list|,
name|flags
argument_list|,
operator|*
name|secp
argument_list|,
operator|*
name|valp
argument_list|,
operator|*
name|namep
argument_list|,
name|FALSE
argument_list|,
name|bed
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|dl_name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_ELF
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_DATALABEL
expr_stmt|;
block|}
else|else
comment|/* If a new symbol was created, it holds the allocated name. 	   Otherwise, we don't need it anymore and should deallocate it.  */
name|free
argument_list|(
name|dl_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|type
operator|!=
name|STT_DATALABEL
operator|||
operator|(
operator|(
name|info
operator|->
name|relocatable
operator|||
name|info
operator|->
name|emitrelocations
operator|)
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefined
operator|)
operator|||
operator|(
operator|!
name|info
operator|->
name|relocatable
operator|&&
operator|!
name|info
operator|->
name|emitrelocations
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_indirect
operator|)
condition|)
block|{
comment|/* Make sure we don't get confused on invalid input.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: encountered datalabel symbol in input"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Now find the hash-table slot for this entry and fill it in.  */
while|while
condition|(
operator|*
name|sym_hash
operator|!=
name|NULL
condition|)
name|sym_hash
operator|++
expr_stmt|;
operator|*
name|sym_hash
operator|=
name|h
expr_stmt|;
comment|/* Signal to caller to skip this symbol - we've handled it.  */
operator|*
name|namep
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This hook function is called before the linker writes out a global    symbol.  For relocatable links, DataLabel symbols will be present in    linker output.  We cut off the special suffix on those symbols, so the    right name appears in the output.     When linking and emitting relocations, there can appear global symbols    that are not referenced by relocs, but rather only implicitly through    DataLabel references, a relation that is not visible to the linker.    Since no stripping of global symbols in done when doing such linking,    we don't need to look up and make sure to emit the main symbol for each    DataLabel symbol.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sh64_elf64_link_output_symbol_hook
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|cname
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|,
name|asection
modifier|*
name|input_sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
name|cname
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
operator|||
name|info
operator|->
name|emitrelocations
condition|)
block|{
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_DATALABEL
condition|)
name|name
index|[
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
name|strlen
argument_list|(
name|DATALABEL_SUFFIX
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set bit 0 on the entry address; it always points to SHmedia code.  This    is mostly for symmetry with the 32-bit format, where code can be    SHcompact and we need to make a distinction to make sure execution    starts in the right ISA mode.  It is also convenient for a loader,    which would otherwise have to set this bit when loading a TR register    before jumping to the program entry.  */
end_comment

begin_function
specifier|static
name|void
name|sh64_elf64_final_write_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|linker
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* FIXME: Perhaps we shouldn't do this if the entry address was supplied      numerically, but we currently lack the infrastructure to recognize      that: The entry symbol, and info whether it is numeric or a symbol      name is kept private in the linker.  */
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_type
operator|==
name|ET_EXEC
condition|)
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_entry
operator||=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* First entry in an absolute procedure linkage table look like this.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_sh64_plt0_entry_be
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0xcc
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x10
block|,
comment|/* movi  .got.plt>> 48, r17 */
literal|0xc8
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x10
block|,
comment|/* shori (.got.plt>> 32)& 65535, r17 */
literal|0xc8
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x10
block|,
comment|/* shori (.got.plt>> 16)& 65535, r17 */
literal|0xc8
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x10
block|,
comment|/* shori .got.plt& 65535, r17 */
literal|0x8d
block|,
literal|0x10
block|,
literal|0x09
block|,
literal|0x90
block|,
comment|/* ld.q  r17, 16, r25 */
literal|0x6b
block|,
literal|0xf1
block|,
literal|0x66
block|,
literal|0x00
block|,
comment|/* ptabs r25, tr0 */
literal|0x8d
block|,
literal|0x10
block|,
literal|0x05
block|,
literal|0x10
block|,
comment|/* ld.q  r17, 8, r17 */
literal|0x44
block|,
literal|0x01
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* blink tr0, r63 */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_sh64_plt0_entry_le
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0x10
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xcc
block|,
comment|/* movi  .got.plt>> 16, r17 */
literal|0x10
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xc8
block|,
comment|/* shori (.got.plt>> 32)& 65535, r17 */
literal|0x10
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xc8
block|,
comment|/* shori (.got.plt>> 16)& 65535, r17 */
literal|0x10
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xc8
block|,
comment|/* shori .got.plt& 65535, r17 */
literal|0x90
block|,
literal|0x09
block|,
literal|0x10
block|,
literal|0x8d
block|,
comment|/* ld.q  r17, 16, r25 */
literal|0x00
block|,
literal|0x66
block|,
literal|0xf1
block|,
literal|0x6b
block|,
comment|/* ptabs r25, tr0 */
literal|0x10
block|,
literal|0x05
block|,
literal|0x10
block|,
literal|0x8d
block|,
comment|/* ld.q  r17, 8, r17 */
literal|0xf0
block|,
literal|0xff
block|,
literal|0x01
block|,
literal|0x44
block|,
comment|/* blink tr0, r63 */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sebsequent entries in an absolute procedure linkage table look like    this.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_sh64_plt_entry_be
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0xcc
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x90
block|,
comment|/* movi  nameN-in-GOT>> 48, r25 */
literal|0xc8
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x90
block|,
comment|/* shori (nameN-in-GOT>> 32)& 65535, r25 */
literal|0xc8
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x90
block|,
comment|/* shori (nameN-in-GOT>> 16)& 65535, r25 */
literal|0xc8
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x90
block|,
comment|/* shori nameN-in-GOT& 65535, r25 */
literal|0x8d
block|,
literal|0x90
block|,
literal|0x01
block|,
literal|0x90
block|,
comment|/* ld.q  r25, 0, r25 */
literal|0x6b
block|,
literal|0xf1
block|,
literal|0x66
block|,
literal|0x00
block|,
comment|/* ptabs r25, tr0 */
literal|0x44
block|,
literal|0x01
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* blink tr0, r63 */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0xcc
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x90
block|,
comment|/* movi  (.+8-.PLT0)>> 16, r25 */
literal|0xc8
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x90
block|,
comment|/* shori (.+4-.PLT0)& 65535, r25 */
literal|0x6b
block|,
literal|0xf5
block|,
literal|0x66
block|,
literal|0x00
block|,
comment|/* ptrel r25, tr0 */
literal|0xcc
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x50
block|,
comment|/* movi  reloc-offset>> 16, r21 */
literal|0xc8
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x50
block|,
comment|/* shori reloc-offset& 65535, r21 */
literal|0x44
block|,
literal|0x01
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* blink tr0, r63 */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_sh64_plt_entry_le
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0x90
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xcc
block|,
comment|/* movi  nameN-in-GOT>> 16, r25 */
literal|0x90
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xc8
block|,
comment|/* shori nameN-in-GOT& 65535, r25 */
literal|0x90
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xc8
block|,
comment|/* shori nameN-in-GOT& 65535, r25 */
literal|0x90
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xc8
block|,
comment|/* shori nameN-in-GOT& 65535, r25 */
literal|0x90
block|,
literal|0x01
block|,
literal|0x90
block|,
literal|0x8d
block|,
comment|/* ld.q  r25, 0, r25 */
literal|0x00
block|,
literal|0x66
block|,
literal|0xf1
block|,
literal|0x6b
block|,
comment|/* ptabs r25, tr0 */
literal|0xf0
block|,
literal|0xff
block|,
literal|0x01
block|,
literal|0x44
block|,
comment|/* blink tr0, r63 */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0x90
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xcc
block|,
comment|/* movi  (.+8-.PLT0)>> 16, r25 */
literal|0x90
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xc8
block|,
comment|/* shori (.+4-.PLT0)& 65535, r25 */
literal|0x00
block|,
literal|0x66
block|,
literal|0xf5
block|,
literal|0x6b
block|,
comment|/* ptrel r25, tr0 */
literal|0x50
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xcc
block|,
comment|/* movi  reloc-offset>> 16, r21 */
literal|0x50
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xc8
block|,
comment|/* shori reloc-offset& 65535, r21 */
literal|0xf0
block|,
literal|0xff
block|,
literal|0x01
block|,
literal|0x44
block|,
comment|/* blink tr0, r63 */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Entries in a PIC procedure linkage table look like this.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_sh64_pic_plt_entry_be
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0xcc
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x90
block|,
comment|/* movi  nameN@GOT>> 16, r25 */
literal|0xc8
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x90
block|,
comment|/* shori nameN@GOT& 65535, r25 */
literal|0x40
block|,
literal|0xc3
block|,
literal|0x65
block|,
literal|0x90
block|,
comment|/* ldx.q r12, r25, r25 */
literal|0x6b
block|,
literal|0xf1
block|,
literal|0x66
block|,
literal|0x00
block|,
comment|/* ptabs r25, tr0 */
literal|0x44
block|,
literal|0x01
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* blink tr0, r63 */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0x6f
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* nop */
literal|0xce
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x10
block|,
comment|/* movi  -GOT_BIAS, r17 */
literal|0x00
block|,
literal|0xc9
block|,
literal|0x45
block|,
literal|0x10
block|,
comment|/* add   r12, r17, r17 */
literal|0x8d
block|,
literal|0x10
block|,
literal|0x09
block|,
literal|0x90
block|,
comment|/* ld.q  r17, 16, r25 */
literal|0x6b
block|,
literal|0xf1
block|,
literal|0x66
block|,
literal|0x00
block|,
comment|/* ptabs r25, tr0 */
literal|0x8d
block|,
literal|0x10
block|,
literal|0x05
block|,
literal|0x10
block|,
comment|/* ld.q  r17, 8, r17 */
literal|0xcc
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x50
block|,
comment|/* movi  reloc-offset>> 16, r21 */
literal|0xc8
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x50
block|,
comment|/* shori reloc-offset& 65535, r21 */
literal|0x44
block|,
literal|0x01
block|,
literal|0xff
block|,
literal|0xf0
block|,
comment|/* blink tr0, r63 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_sh64_pic_plt_entry_le
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0x90
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xcc
block|,
comment|/* movi  nameN@GOT>> 16, r25 */
literal|0x90
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xc8
block|,
comment|/* shori nameN@GOT& 65535, r25 */
literal|0x90
block|,
literal|0x65
block|,
literal|0xc3
block|,
literal|0x40
block|,
comment|/* ldx.q r12, r25, r25 */
literal|0x00
block|,
literal|0x66
block|,
literal|0xf1
block|,
literal|0x6b
block|,
comment|/* ptabs r25, tr0 */
literal|0xf0
block|,
literal|0xff
block|,
literal|0x01
block|,
literal|0x44
block|,
comment|/* blink tr0, r63 */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0xf0
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0x6f
block|,
comment|/* nop */
literal|0x10
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xce
block|,
comment|/* movi  -GOT_BIAS, r17 */
literal|0x10
block|,
literal|0x45
block|,
literal|0xc9
block|,
literal|0x00
block|,
comment|/* add   r12, r17, r17 */
literal|0x90
block|,
literal|0x09
block|,
literal|0x10
block|,
literal|0x8d
block|,
comment|/* ld.q  r17, 16, r25 */
literal|0x00
block|,
literal|0x66
block|,
literal|0xf1
block|,
literal|0x6b
block|,
comment|/* ptabs r25, tr0 */
literal|0x10
block|,
literal|0x05
block|,
literal|0x10
block|,
literal|0x8d
block|,
comment|/* ld.q  r17, 8, r17 */
literal|0x50
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xcc
block|,
comment|/* movi  reloc-offset>> 16, r21 */
literal|0x50
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0xc8
block|,
comment|/* shori reloc-offset& 65535, r21 */
literal|0xf0
block|,
literal|0xff
block|,
literal|0x01
block|,
literal|0x44
block|,
comment|/* blink tr0, r63 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
modifier|*
name|elf_sh64_plt0_entry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
modifier|*
name|elf_sh64_plt_entry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
modifier|*
name|elf_sh64_pic_plt_entry
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create an entry in an sh ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|sh64_elf64_link_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|struct
name|elf_sh64_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|elf_sh64_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|elf_sh64_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elf_sh64_link_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_sh64_link_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|elf_sh64_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elf_sh64_link_hash_entry
operator|*
operator|)
name|_bfd_elf_link_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|(
expr|struct
name|elf_sh64_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
block|{
name|ret
operator|->
name|pcrel_relocs_copied
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|datalabel_got_offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Create an sh64 ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|sh64_elf64_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|elf_sh64_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elf_sh64_link_hash_table
operator|*
operator|)
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|elf_sh64_link_hash_table
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|elf_sh64_link_hash_table
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|sh64_elf64_link_hash_newfunc
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_function
specifier|inline
specifier|static
name|void
name|movi_shori_putval
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|unsigned
name|long
name|value
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|addr
argument_list|)
operator||
operator|(
operator|(
name|value
operator|>>
literal|6
operator|)
operator|&
literal|0x3fffc00
operator|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|addr
operator|+
literal|4
argument_list|)
operator||
operator|(
operator|(
name|value
operator|<<
literal|10
operator|)
operator|&
literal|0x3fffc00
operator|)
argument_list|,
name|addr
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
specifier|static
name|void
name|movi_3shori_putval
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|bfd_vma
name|value
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|addr
argument_list|)
operator||
operator|(
operator|(
name|value
operator|>>
literal|38
operator|)
operator|&
literal|0x3fffc00
operator|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|addr
operator|+
literal|4
argument_list|)
operator||
operator|(
operator|(
name|value
operator|>>
literal|22
operator|)
operator|&
literal|0x3fffc00
operator|)
argument_list|,
name|addr
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|addr
operator|+
literal|8
argument_list|)
operator||
operator|(
operator|(
name|value
operator|>>
literal|6
operator|)
operator|&
literal|0x3fffc00
operator|)
argument_list|,
name|addr
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|bfd_get_32
argument_list|(
name|output_bfd
argument_list|,
name|addr
operator|+
literal|12
argument_list|)
operator||
operator|(
operator|(
name|value
operator|<<
literal|10
operator|)
operator|&
literal|0x3fffc00
operator|)
argument_list|,
name|addr
operator|+
literal|12
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create dynamic sections when linking against a dynamic object.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sh64_elf64_create_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|flagword
name|flags
decl_stmt|,
name|pltflags
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|int
name|ptralign
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|bed
operator|->
name|s
operator|->
name|arch_size
condition|)
block|{
case|case
literal|32
case|:
name|ptralign
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|ptralign
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* We need to create .plt, .rel[a].plt, .got, .got.plt, .dynbss, and      .rel[a].bss sections.  */
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|pltflags
operator|=
name|flags
expr_stmt|;
name|pltflags
operator||=
name|SEC_CODE
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|plt_not_loaded
condition|)
name|pltflags
operator|&=
operator|~
operator|(
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator|)
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|plt_readonly
condition|)
name|pltflags
operator||=
name|SEC_READONLY
expr_stmt|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|pltflags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|bed
operator|->
name|plt_alignment
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bed
operator|->
name|want_plt_sym
condition|)
block|{
comment|/* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the 	 .plt section.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"_PROCEDURE_LINKAGE_TABLE_"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|bed
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_DEF_REGULAR
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|bed
operator|->
name|default_use_rela_p
condition|?
literal|".rela.plt"
else|:
literal|".rel.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|ptralign
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|_bfd_elf_create_got_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|{
specifier|const
name|char
modifier|*
name|secname
decl_stmt|;
name|char
modifier|*
name|relname
decl_stmt|;
name|flagword
name|secflags
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|secflags
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|secflags
operator|&
operator|(
name|SEC_DATA
operator||
name|SEC_LINKER_CREATED
operator|)
operator|)
operator|||
operator|(
operator|(
name|secflags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
name|SEC_HAS_CONTENTS
operator|)
condition|)
continue|continue;
name|secname
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|relname
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|strlen
argument_list|(
name|secname
argument_list|)
operator|+
literal|6
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|relname
argument_list|,
literal|".rela"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|relname
argument_list|,
name|secname
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|relname
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|ptralign
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|bed
operator|->
name|want_dynbss
condition|)
block|{
comment|/* The .dynbss section is a place to put symbols which are defined 	 by dynamic objects, are referenced by regular objects, and are 	 not functions.  We must allocate space for them in the process 	 image and use a R_*_COPY reloc to tell the dynamic linker to 	 initialize them at run time.  The linker script puts the .dynbss 	 section into the .bss section of the final image.  */
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|SEC_ALLOC
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* The .rel[a].bss section holds copy relocs.  This section is not 	 normally needed.  We need to create it here, though, so that the 	 linker will map it to an output section.  We can't just create it 	 only if we need it, because we will not know whether we need it 	 until we have seen all the input files, and the first time the 	 main linker code calls BFD after examining all the input files 	 (size_dynamic_sections) the input sections have already been 	 mapped to the output sections.  If the section turns out not to 	 be needed, we can discard it later.  We will never need this 	 section when generating a shared object, since they do not use 	 copy relocs.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
operator|(
name|bed
operator|->
name|default_use_rela_p
condition|?
literal|".rela.bss"
else|:
literal|".rel.bss"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|ptralign
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sh64_elf64_adjust_dynamic_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|power_of_two
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* Make sure we know what is going on here.  */
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|||
name|h
operator|->
name|weakdef
operator|!=
name|NULL
operator|||
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_REGULAR
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If this is a function, put it in the procedure linkage table.  We      will fill in the contents of the procedure linkage table later,      when we know the address of the .got section.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* This case can occur if we saw a PLT reloc in an input 	     file, but the symbol was never referred to by a dynamic 	     object.  In such a case, we don't actually need to build 	     a procedure linkage table, and we can just do a REL64 	     reloc instead.  */
name|BFD_ASSERT
argument_list|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Make sure this symbol is output as a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* If this is the first .plt entry, make room for the special 	 first entry.  */
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* If this symbol is not defined in a regular file, and we are 	 not generating a shared library, then set the symbol to this 	 location in the .plt.  This is required to make function 	 pointers compare as equal between the normal executable and 	 the shared library.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
block|}
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* Make room for this entry.  */
name|s
operator|->
name|_raw_size
operator|+=
name|elf_sh64_sizeof_plt
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* We also need to make an entry in the .got.plt section, which 	 will be placed in the .got section by the linker script.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
literal|8
expr_stmt|;
comment|/* We also need to make an entry in the .rela.plt section.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
comment|/* If we are creating a shared library, we must presume that the      only references to the symbol are via the global offset table.      For such cases we need not do anything here; the relocations will      be handled correctly by relocate_section.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
return|return
name|TRUE
return|;
comment|/* If there are no references to this symbol that do not use the      GOT, we don't need to generate a copy reloc.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_GOT_REF
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* We must allocate the symbol in our .dynbss section, which will      become part of the .bss section of the executable.  There will be      an entry for this symbol in the .dynsym section.  The dynamic      object will contain position independent code, so all references      from the dynamic object to this symbol will go through the global      offset table.  The dynamic linker will use the .dynsym entry to      determine the address it must put in the global offset table, so      both the dynamic object and the regular object will refer to the      same memory location for the variable.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* We must generate a R_SH_COPY reloc to tell the dynamic linker to      copy the initial value out of the dynamic object and into the      runtime process image.  We need to remember the offset into the      .rela.bss section we are going to use.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|srel
decl_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.bss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|srel
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_COPY
expr_stmt|;
block|}
comment|/* We need to figure out the alignment required for this symbol.  I      have no idea how ELF linkers handle this.  */
name|power_of_two
operator|=
name|bfd_log2
argument_list|(
name|h
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
literal|3
condition|)
name|power_of_two
operator|=
literal|3
expr_stmt|;
comment|/* Apply the required alignment.  */
name|s
operator|->
name|_raw_size
operator|=
name|BFD_ALIGN
argument_list|(
name|s
operator|->
name|_raw_size
argument_list|,
call|(
name|bfd_size_type
call|)
argument_list|(
literal|1
operator|<<
name|power_of_two
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
name|bfd_get_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
name|power_of_two
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Define the symbol as being at this point in the section.  */
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* Increment the section size to make room for the symbol.  */
name|s
operator|->
name|_raw_size
operator|+=
name|h
operator|->
name|size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This function is called via sh_elf_link_hash_traverse if we are    creating a shared object with -Bsymbolic.  It discards the space    allocated to copy PC relative relocs against symbols which are    defined in regular objects.  We allocated space for them in the    check_relocs routine, but we won't fill them in in the    relocate_section routine.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sh64_elf64_discard_copies
parameter_list|(
name|struct
name|elf_sh64_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|elf_sh64_pcrel_relocs_copied
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_sh64_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
comment|/* We only discard relocs for symbols defined in a regular object.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
for|for
control|(
name|s
operator|=
name|h
operator|->
name|pcrel_relocs_copied
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
name|s
operator|->
name|section
operator|->
name|_raw_size
operator|-=
name|s
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sh64_elf64_size_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_boolean
name|plt
decl_stmt|;
name|bfd_boolean
name|relocs
decl_stmt|;
name|bfd_boolean
name|reltext
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We may have created entries in the .rela.got section. 	 However, if we are not creating the dynamic sections, we will 	 not actually use these entries.  Reset the size of .rela.got, 	 which will cause it to get stripped from the output file 	 below.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|s
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this is a -Bsymbolic shared link, then we need to discard all      PC relative relocs against symbols defined in a regular object.      We allocated space for them in the check_relocs routine, but we      will not fill them in in the relocate_section routine.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
name|info
operator|->
name|symbolic
condition|)
name|sh64_elf64_link_hash_traverse
argument_list|(
name|sh64_elf64_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|sh64_elf64_discard_copies
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* The check_relocs and adjust_dynamic_symbol entry points have      determined the sizes of the various dynamic sections.  Allocate      memory for them.  */
name|plt
operator|=
name|FALSE
expr_stmt|;
name|relocs
operator|=
name|FALSE
expr_stmt|;
name|reltext
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_boolean
name|strip
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* It's OK to base decisions on the section name, because none 	 of the dynobj section names depend upon the input files.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|strip
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".plt"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
comment|/* Strip this section if we don't need it; see the 		 comment below.  */
name|strip
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Remember whether there is a PLT.  */
name|plt
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
comment|/* If we don't need this section, strip it from the 		 output file.  This is mostly to handle .rela.bss and 		 .rela.plt.  We must create both sections in 		 create_dynamic_sections, because they must be created 		 before the linker maps input sections to output 		 sections.  The linker does that before 		 adjust_dynamic_symbol is called, and it is that 		 function which decides whether anything needs to go 		 into these sections.  */
name|strip
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|asection
modifier|*
name|target
decl_stmt|;
comment|/* Remember whether there are any reloc sections other 		 than .rela.plt.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".rela.plt"
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|outname
decl_stmt|;
name|relocs
operator|=
name|TRUE
expr_stmt|;
comment|/* If this relocation section applies to a read only 		     section, then we probably need a DT_TEXTREL 		     entry.  The entries in the .rela.plt section 		     really apply to the .got section, which we 		     created ourselves and so know is not readonly.  */
name|outname
operator|=
name|bfd_get_section_name
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|output_section
argument_list|)
expr_stmt|;
name|target
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|outname
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|NULL
operator|&&
operator|(
name|target
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|target
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|reltext
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* We use the reloc_count field as a counter if we need 		 to copy relocs into the output file.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".got"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|strip
condition|)
block|{
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Allocate memory for the section contents.  */
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|s
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in sh64_elf64_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|plt
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PLTREL
argument_list|,
name|DT_RELA
argument_list|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|relocs
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RELA
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RELAENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|reltext
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sh64_elf64_finish_dynamic_symbol
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
name|bfd_vma
name|plt_index
decl_stmt|;
name|bfd_vma
name|got_offset
decl_stmt|;
name|Elf_Internal_Rela
name|rel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
comment|/* This symbol has an entry in the procedure linkage table.  Set 	 it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|sgot
operator|!=
name|NULL
operator|&&
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Get the index in the procedure linkage table which 	 corresponds to this symbol.  This is the index of this symbol 	 in all the symbols for which we are making plt entries.  The 	 first entry in the procedure linkage table is reserved.  */
name|plt_index
operator|=
name|h
operator|->
name|plt
operator|.
name|offset
operator|/
name|elf_sh64_sizeof_plt
argument_list|(
name|info
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Get the offset into the .got table of the entry that 	 corresponds to this function.  Each .got entry is 8 bytes. 	 The first three are reserved.  */
name|got_offset
operator|=
operator|(
name|plt_index
operator|+
literal|3
operator|)
operator|*
literal|8
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|got_offset
operator|-=
name|GOT_BIAS
expr_stmt|;
comment|/* Fill in the entry in the procedure linkage table.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
name|elf_sh64_plt_entry
operator|==
name|NULL
condition|)
block|{
name|elf_sh64_plt_entry
operator|=
operator|(
name|bfd_big_endian
argument_list|(
name|output_bfd
argument_list|)
condition|?
name|elf_sh64_plt_entry_be
else|:
name|elf_sh64_plt_entry_le
operator|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|,
name|elf_sh64_plt_entry
argument_list|,
name|elf_sh64_sizeof_plt
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|movi_3shori_putval
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|got_offset
operator|)
argument_list|,
operator|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|elf_sh64_plt_symbol_offset
argument_list|(
name|info
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Set bottom bit because its for a branch to SHmedia */
name|movi_shori_putval
argument_list|(
name|output_bfd
argument_list|,
operator|-
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|elf_sh64_plt_plt0_offset
argument_list|(
name|info
argument_list|)
operator|+
literal|8
operator|)
operator||
literal|1
argument_list|,
operator|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|elf_sh64_plt_plt0_offset
argument_list|(
name|info
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|elf_sh64_pic_plt_entry
operator|==
name|NULL
condition|)
block|{
name|elf_sh64_pic_plt_entry
operator|=
operator|(
name|bfd_big_endian
argument_list|(
name|output_bfd
argument_list|)
condition|?
name|elf_sh64_pic_plt_entry_be
else|:
name|elf_sh64_pic_plt_entry_le
operator|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|,
name|elf_sh64_pic_plt_entry
argument_list|,
name|elf_sh64_sizeof_plt
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|movi_shori_putval
argument_list|(
name|output_bfd
argument_list|,
name|got_offset
argument_list|,
operator|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|elf_sh64_plt_symbol_offset
argument_list|(
name|info
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|got_offset
operator|+=
name|GOT_BIAS
expr_stmt|;
name|movi_shori_putval
argument_list|(
name|output_bfd
argument_list|,
name|plt_index
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
argument_list|,
operator|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|elf_sh64_plt_reloc_offset
argument_list|(
name|info
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Fill in the entry in the global offset table.  */
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|elf_sh64_plt_temp_offset
argument_list|(
name|info
argument_list|)
operator|)
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|got_offset
argument_list|)
expr_stmt|;
comment|/* Fill in the entry in the .rela.plt section.  */
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|got_offset
operator|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_SH_JMP_SLOT64
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
name|GOT_BIAS
expr_stmt|;
name|loc
operator|=
name|srel
operator|->
name|contents
operator|+
name|plt_index
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Mark the symbol as undefined, rather than as defined in 	     the .plt section.  Leave the value alone.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
block|}
block|}
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
name|Elf_Internal_Rela
name|rel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
comment|/* This symbol has an entry in the global offset table.  Set it 	 up.  */
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
operator|&&
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
operator|~
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* If this is a -Bsymbolic link, and the symbol is defined 	 locally, we just want to emit a RELATIVE reloc.  Likewise if 	 the symbol was forced to be local because of a version file. 	 The entry in the global offset table will already have been 	 initialized in the relocate_section function.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
condition|)
block|{
name|rel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_SH_RELATIVE64
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|h
operator|->
name|got
operator|.
name|offset
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_SH_GLOB_DAT64
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
name|loc
operator|=
name|srel
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|srel
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_COPY
operator|)
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|Elf_Internal_Rela
name|rel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
comment|/* This symbol needs a copy reloc.  Set it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|,
literal|".rela.bss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_offset
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|rel
operator|.
name|r_info
operator|=
name|ELF64_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_SH_COPY64
argument_list|)
expr_stmt|;
name|rel
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
name|s
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|s
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf64_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf64_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
comment|/* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sh64_elf64_finish_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|Elf64_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf64_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf64_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|_raw_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_elf64_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
default|default:
break|break;
case|case
name|DT_INIT
case|:
name|name
operator|=
name|info
operator|->
name|init_function
expr_stmt|;
goto|goto
name|get_sym
goto|;
case|case
name|DT_FINI
case|:
name|name
operator|=
name|info
operator|->
name|fini_function
expr_stmt|;
name|get_sym
label|:
if|if
condition|(
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|!=
literal|0
condition|)
block|{
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|other
operator|&
name|STO_SH5_ISA32
operator|)
condition|)
block|{
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator||=
literal|1
expr_stmt|;
name|bfd_elf64_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DT_PLTGOT
case|:
name|name
operator|=
literal|".got"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_JMPREL
case|:
name|name
operator|=
literal|".rela.plt"
expr_stmt|;
name|get_vma
label|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|bfd_elf64_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_cooked_size
expr_stmt|;
else|else
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|bfd_elf64_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_RELASZ
case|:
comment|/* My reading of the SVR4 ABI indicates that the 		 procedure linkage table relocs (DT_JMPREL) should be 		 included in the overall relocs (DT_RELA).  This is 		 what Solaris does.  However, UnixWare can not handle 		 that case.  Therefore, we override the DT_RELASZ entry 		 here to make it not include the JMPREL relocs.  Since 		 the linker script arranges for .rela.plt to follow all 		 other relocation sections, we don't have to worry 		 about changing the DT_RELA entry.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|-=
name|s
operator|->
name|_cooked_size
expr_stmt|;
else|else
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|-=
name|s
operator|->
name|_raw_size
expr_stmt|;
block|}
name|bfd_elf64_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Fill in the first entry in the procedure linkage table.  */
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|splt
operator|&&
name|splt
operator|->
name|_raw_size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
name|elf_sh64_pic_plt_entry
operator|==
name|NULL
condition|)
block|{
name|elf_sh64_pic_plt_entry
operator|=
operator|(
name|bfd_big_endian
argument_list|(
name|output_bfd
argument_list|)
condition|?
name|elf_sh64_pic_plt_entry_be
else|:
name|elf_sh64_pic_plt_entry_le
operator|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
argument_list|,
name|elf_sh64_pic_plt_entry
argument_list|,
name|elf_sh64_sizeof_plt
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|elf_sh64_plt0_entry
operator|==
name|NULL
condition|)
block|{
name|elf_sh64_plt0_entry
operator|=
operator|(
name|bfd_big_endian
argument_list|(
name|output_bfd
argument_list|)
condition|?
name|elf_sh64_plt0_entry_be
else|:
name|elf_sh64_plt0_entry_le
operator|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
argument_list|,
name|elf_sh64_plt0_entry
argument_list|,
name|PLT_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|movi_3shori_putval
argument_list|(
name|output_bfd
argument_list|,
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|elf_sh64_plt0_gotplt_offset
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* UnixWare sets the entsize of .plt to 8, although that doesn't 	     really seem like the right value.  */
name|elf_section_data
argument_list|(
name|splt
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|8
expr_stmt|;
block|}
block|}
comment|/* Fill in the first three entries in the global offset table.  */
if|if
condition|(
name|sgot
operator|->
name|_raw_size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sdyn
operator|==
name|NULL
condition|)
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
else|else
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
name|sdyn
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sdyn
operator|->
name|output_offset
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
literal|16
argument_list|)
expr_stmt|;
block|}
name|elf_section_data
argument_list|(
name|sgot
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|8
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Merge non visibility st_other attribute when the symbol comes from    a dynamic object.  */
end_comment

begin_function
specifier|static
name|void
name|sh64_elf64_merge_symbol_attribute
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
specifier|const
name|Elf_Internal_Sym
modifier|*
name|isym
parameter_list|,
name|bfd_boolean
name|definition
parameter_list|,
name|bfd_boolean
name|dynamic
parameter_list|)
block|{
if|if
condition|(
name|isym
operator|->
name|st_other
operator|!=
literal|0
operator|&&
name|dynamic
condition|)
block|{
name|unsigned
name|char
name|other
decl_stmt|;
comment|/* Take the balance of OTHER from the definition.  */
name|other
operator|=
operator|(
name|definition
condition|?
name|isym
operator|->
name|st_other
else|:
name|h
operator|->
name|other
operator|)
expr_stmt|;
name|other
operator|&=
operator|~
name|ELF_ST_VISIBILITY
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|h
operator|->
name|other
operator|=
name|other
operator||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|bfd_elf_special_section
specifier|const
name|sh64_elf64_special_sections
index|[]
init|=
block|{
block|{
literal|".cranges"
block|,
literal|8
block|,
literal|0
block|,
name|SHT_PROGBITS
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf64_sh64_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf64-sh64"
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf64_sh64l_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf64-sh64l"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_sh
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_SH
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|128
end_define

begin_define
define|#
directive|define
name|elf_symbol_leading_char
value|'_'
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_reloc_type_lookup
value|sh_elf64_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|sh_elf64_info_to_howto
end_define

begin_comment
comment|/* Note: there's no relaxation at present.  */
end_comment

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|sh_elf64_relocate_section
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_get_relocated_section_contents
define|\
value|sh_elf64_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|sh_elf64_set_mach_from_flags
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_set_private_flags
define|\
value|sh_elf64_set_private_flags
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_copy_private_bfd_data
define|\
value|sh_elf64_copy_private_data
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_merge_private_bfd_data
define|\
value|sh_elf64_merge_private_data
end_define

begin_define
define|#
directive|define
name|elf_backend_fake_sections
value|sh64_elf64_fake_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|sh_elf64_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|sh_elf64_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|sh_elf64_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_get_symbol_type
value|sh64_elf64_get_symbol_type
end_define

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
value|sh64_elf64_add_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_link_output_symbol_hook
define|\
value|sh64_elf64_link_output_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_merge_symbol_attribute
define|\
value|sh64_elf64_merge_symbol_attribute
end_define

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
define|\
value|sh64_elf64_final_write_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
define|\
value|sh64_elf64_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|bfd_elf64_bfd_link_hash_table_create
define|\
value|sh64_elf64_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
define|\
value|sh64_elf64_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
define|\
value|sh64_elf64_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
define|\
value|sh64_elf64_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
define|\
value|sh64_elf64_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_special_sections
value|sh64_elf64_special_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_want_got_plt
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_readonly
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|24
end_define

begin_include
include|#
directive|include
file|"elf64-target.h"
end_include

begin_comment
comment|/* NetBSD support.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_BIG_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf64_sh64nbsd_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BIG_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf64-sh64-nbsd"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf64_sh64lnbsd_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf64-sh64l-nbsd"
end_define

begin_undef
undef|#
directive|undef
name|ELF_MAXPAGESIZE
end_undef

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x10000
end_define

begin_undef
undef|#
directive|undef
name|elf_symbol_leading_char
end_undef

begin_define
define|#
directive|define
name|elf_symbol_leading_char
value|0
end_define

begin_define
define|#
directive|define
name|elf64_bed
value|elf64_sh64_nbsd_bed
end_define

begin_include
include|#
directive|include
file|"elf64-target.h"
end_include

begin_comment
comment|/* Linux support.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_BIG_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf64_sh64blin_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BIG_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf64-sh64big-linux"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf64_sh64lin_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf64-sh64-linux"
end_define

begin_define
define|#
directive|define
name|INCLUDED_TARGET_FILE
end_define

begin_include
include|#
directive|include
file|"elf64-target.h"
end_include

end_unit

