begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Motorola 68HC11/HC12-specific support for 32-bit ELF    Copyright 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.    Contributed by Stephane Carrez (stcarrez@nerim.fr)  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf32-m68hc1x.h"
end_include

begin_include
include|#
directive|include
file|"elf/m68hc11.h"
end_include

begin_include
include|#
directive|include
file|"opcode/m68hc11.h"
end_include

begin_define
define|#
directive|define
name|m68hc12_stub_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|)
define|\
value|((struct elf32_m68hc11_stub_hash_entry *) \    bfd_hash_lookup ((table), (string), (create), (copy)))
end_define

begin_function_decl
specifier|static
name|struct
name|elf32_m68hc11_stub_hash_entry
modifier|*
name|m68hc12_add_stub
parameter_list|(
specifier|const
name|char
modifier|*
name|stub_name
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|struct
name|m68hc11_elf_link_hash_table
modifier|*
name|htab
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|stub_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|m68hc11_elf_set_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bfd_vma
name|value
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|m68hc11_elf_export_one_stub
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|gen_entry
parameter_list|,
name|void
modifier|*
name|in_arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scan_sections_for_abi
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|PTR
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|m68hc11_scan_param
block|{
name|struct
name|m68hc11_page_info
modifier|*
name|pinfo
decl_stmt|;
name|bfd_boolean
name|use_memory_banks
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Create a 68HC11/68HC12 ELF linker hash table.  */
end_comment

begin_function
name|struct
name|m68hc11_elf_link_hash_table
modifier|*
name|m68hc11_elf_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|m68hc11_elf_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|m68hc11_elf_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|m68hc11_elf_link_hash_table
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|m68hc11_elf_link_hash_table
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|_bfd_elf_link_hash_newfunc
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Init the stub hash table too.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_hash_table
argument_list|)
expr_stmt|;
name|ret
operator|->
name|stub_hash_table
operator|=
operator|(
expr|struct
name|bfd_hash_table
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|->
name|stub_hash_table
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|bfd_hash_table_init
argument_list|(
name|ret
operator|->
name|stub_hash_table
argument_list|,
name|stub_hash_newfunc
argument_list|)
condition|)
return|return
name|NULL
return|;
name|ret
operator|->
name|stub_bfd
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|stub_section
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|add_stub_section
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|sym_sec
operator|.
name|abfd
operator|=
name|NULL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Free the derived linker hash table.  */
end_comment

begin_function
name|void
name|m68hc11_elf_bfd_link_hash_table_free
parameter_list|(
name|struct
name|bfd_link_hash_table
modifier|*
name|hash
parameter_list|)
block|{
name|struct
name|m68hc11_elf_link_hash_table
modifier|*
name|ret
init|=
operator|(
expr|struct
name|m68hc11_elf_link_hash_table
operator|*
operator|)
name|hash
decl_stmt|;
name|bfd_hash_table_free
argument_list|(
name|ret
operator|->
name|stub_hash_table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ret
operator|->
name|stub_hash_table
argument_list|)
expr_stmt|;
name|_bfd_generic_link_hash_table_free
argument_list|(
name|hash
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assorted hash table functions.  */
end_comment

begin_comment
comment|/* Initialize an entry in the stub hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|stub_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|entry
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf32_m68hc11_stub_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|entry
return|;
block|}
comment|/* Call the allocation method of the superclass.  */
name|entry
operator|=
name|bfd_hash_newfunc
argument_list|(
name|entry
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf32_m68hc11_stub_hash_entry
modifier|*
name|eh
decl_stmt|;
comment|/* Initialize the local fields.  */
name|eh
operator|=
operator|(
expr|struct
name|elf32_m68hc11_stub_hash_entry
operator|*
operator|)
name|entry
expr_stmt|;
name|eh
operator|->
name|stub_sec
operator|=
name|NULL
expr_stmt|;
name|eh
operator|->
name|stub_offset
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|target_value
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|target_section
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Add a new stub entry to the stub hash.  Not all fields of the new    stub entry are initialised.  */
end_comment

begin_function
specifier|static
name|struct
name|elf32_m68hc11_stub_hash_entry
modifier|*
name|m68hc12_add_stub
parameter_list|(
specifier|const
name|char
modifier|*
name|stub_name
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
name|struct
name|m68hc11_elf_link_hash_table
modifier|*
name|htab
parameter_list|)
block|{
name|struct
name|elf32_m68hc11_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
comment|/* Enter this entry into the linker stub hash table.  */
name|stub_entry
operator|=
name|m68hc12_stub_hash_lookup
argument_list|(
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|stub_name
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: cannot create stub entry %s"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|section
operator|->
name|owner
argument_list|)
argument_list|,
name|stub_name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|stub_section
operator|==
literal|0
condition|)
block|{
name|htab
operator|->
name|stub_section
operator|=
call|(
modifier|*
name|htab
operator|->
name|add_stub_section
call|)
argument_list|(
literal|".tramp"
argument_list|,
name|htab
operator|->
name|tramp_section
argument_list|)
expr_stmt|;
block|}
name|stub_entry
operator|->
name|stub_sec
operator|=
name|htab
operator|->
name|stub_section
expr_stmt|;
name|stub_entry
operator|->
name|stub_offset
operator|=
literal|0
expr_stmt|;
return|return
name|stub_entry
return|;
block|}
end_function

begin_comment
comment|/* Hook called by the linker routine which adds symbols from an object    file.  We use it for identify far symbols and force a loading of    the trampoline handler.  */
end_comment

begin_function
name|bfd_boolean
name|elf32_m68hc11_add_symbol_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|namep
name|ATTRIBUTE_UNUSED
parameter_list|,
name|flagword
modifier|*
name|flagsp
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
modifier|*
name|secp
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_vma
modifier|*
name|valp
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|sym
operator|->
name|st_other
operator|&
name|STO_M68HC12_FAR
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
literal|"__far_trampoline"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|entry
init|=
name|NULL
decl_stmt|;
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"__far_trampoline"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|bfd_und_section_ptr
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
operator|&
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* External entry points for sizing and building linker stubs.  */
end_comment

begin_comment
comment|/* Set up various things so that we can make a list of input sections    for each output section included in the link.  Returns -1 on error,    0 when no stubs will be needed, and 1 on success.  */
end_comment

begin_function
name|int
name|elf32_m68hc11_setup_section_lists
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|unsigned
name|int
name|bfd_count
decl_stmt|;
name|int
name|top_id
decl_stmt|,
name|top_index
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asection
modifier|*
modifier|*
name|input_list
decl_stmt|,
modifier|*
modifier|*
name|list
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|asection
modifier|*
name|text_section
decl_stmt|;
name|struct
name|m68hc11_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|m68hc11_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|root
operator|.
name|root
operator|.
name|creator
operator|->
name|flavour
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
literal|0
return|;
comment|/* Count the number of input BFDs and find the top input section id.      Also search for an existing ".tramp" section so that we know      where generated trampolines must go.  Default to ".text" if we      can't find it.  */
name|htab
operator|->
name|tramp_section
operator|=
literal|0
expr_stmt|;
name|text_section
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|input_bfd
operator|=
name|info
operator|->
name|input_bfds
operator|,
name|bfd_count
operator|=
literal|0
operator|,
name|top_id
operator|=
literal|0
init|;
name|input_bfd
operator|!=
name|NULL
condition|;
name|input_bfd
operator|=
name|input_bfd
operator|->
name|link_next
control|)
block|{
name|bfd_count
operator|+=
literal|1
expr_stmt|;
for|for
control|(
name|section
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|section
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".tramp"
argument_list|)
condition|)
name|htab
operator|->
name|tramp_section
operator|=
name|section
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".text"
argument_list|)
condition|)
name|text_section
operator|=
name|section
expr_stmt|;
if|if
condition|(
name|top_id
operator|<
name|section
operator|->
name|id
condition|)
name|top_id
operator|=
name|section
operator|->
name|id
expr_stmt|;
block|}
block|}
name|htab
operator|->
name|bfd_count
operator|=
name|bfd_count
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|tramp_section
operator|==
literal|0
condition|)
name|htab
operator|->
name|tramp_section
operator|=
name|text_section
expr_stmt|;
comment|/* We can't use output_bfd->section_count here to find the top output      section index as some sections may have been removed, and      _bfd_strip_section_from_output doesn't renumber the indices.  */
for|for
control|(
name|section
operator|=
name|output_bfd
operator|->
name|sections
operator|,
name|top_index
operator|=
literal|0
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
if|if
condition|(
name|top_index
operator|<
name|section
operator|->
name|index
condition|)
name|top_index
operator|=
name|section
operator|->
name|index
expr_stmt|;
block|}
name|htab
operator|->
name|top_index
operator|=
name|top_index
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
operator|*
operator|(
name|top_index
operator|+
literal|1
operator|)
expr_stmt|;
name|input_list
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
name|htab
operator|->
name|input_list
operator|=
name|input_list
expr_stmt|;
if|if
condition|(
name|input_list
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* For sections we aren't interested in, mark their entries with a      value we can check later.  */
name|list
operator|=
name|input_list
operator|+
name|top_index
expr_stmt|;
do|do
operator|*
name|list
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
do|while
condition|(
name|list
operator|--
operator|!=
name|input_list
condition|)
do|;
for|for
control|(
name|section
operator|=
name|output_bfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
name|input_list
index|[
name|section
operator|->
name|index
index|]
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Determine and set the size of the stub section for a final link.     The basic idea here is to examine all the relocations looking for    PC-relative calls to a target that is unreachable with a "bl"    instruction.  */
end_comment

begin_function
name|bfd_boolean
name|elf32_m68hc11_size_stubs
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|bfd
modifier|*
name|stub_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
function_decl|(
modifier|*
name|add_stub_section
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|)
parameter_list|)
block|{
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|,
modifier|*
modifier|*
name|all_local_syms
decl_stmt|;
name|unsigned
name|int
name|bfd_indx
decl_stmt|,
name|bfd_count
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|asection
modifier|*
name|stub_sec
decl_stmt|;
name|struct
name|m68hc11_elf_link_hash_table
modifier|*
name|htab
init|=
name|m68hc11_elf_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
comment|/* Stash our params away.  */
name|htab
operator|->
name|stub_bfd
operator|=
name|stub_bfd
expr_stmt|;
name|htab
operator|->
name|add_stub_section
operator|=
name|add_stub_section
expr_stmt|;
comment|/* Count the number of input BFDs and find the top input section id.  */
for|for
control|(
name|input_bfd
operator|=
name|info
operator|->
name|input_bfds
operator|,
name|bfd_count
operator|=
literal|0
init|;
name|input_bfd
operator|!=
name|NULL
condition|;
name|input_bfd
operator|=
name|input_bfd
operator|->
name|link_next
control|)
block|{
name|bfd_count
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* We want to read in symbol extension records only once.  To do this      we need to read in the local symbols in parallel and save them for      later use; so hold pointers to the local symbols in an array.  */
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Internal_Sym
operator|*
argument_list|)
operator|*
name|bfd_count
expr_stmt|;
name|all_local_syms
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|all_local_syms
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Walk over all the input BFDs, swapping in local symbols.  */
for|for
control|(
name|input_bfd
operator|=
name|info
operator|->
name|input_bfds
operator|,
name|bfd_indx
operator|=
literal|0
init|;
name|input_bfd
operator|!=
name|NULL
condition|;
name|input_bfd
operator|=
name|input_bfd
operator|->
name|link_next
operator|,
name|bfd_indx
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
comment|/* We'll need the symbol table in a second.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|symtab_hdr
operator|->
name|sh_info
operator|==
literal|0
condition|)
continue|continue;
comment|/* We need an array of the local symbols attached to the input bfd.  */
name|local_syms
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|local_syms
operator|==
name|NULL
condition|)
block|{
name|local_syms
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Cache them for elf_link_input_bfd.  */
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
expr_stmt|;
block|}
if|if
condition|(
name|local_syms
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|all_local_syms
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|all_local_syms
index|[
name|bfd_indx
index|]
operator|=
name|local_syms
expr_stmt|;
block|}
for|for
control|(
name|input_bfd
operator|=
name|info
operator|->
name|input_bfds
operator|,
name|bfd_indx
operator|=
literal|0
init|;
name|input_bfd
operator|!=
name|NULL
condition|;
name|input_bfd
operator|=
name|input_bfd
operator|->
name|link_next
operator|,
name|bfd_indx
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
comment|/* We'll need the symbol table in a second.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|symtab_hdr
operator|->
name|sh_info
operator|==
literal|0
condition|)
continue|continue;
name|local_syms
operator|=
name|all_local_syms
index|[
name|bfd_indx
index|]
expr_stmt|;
comment|/* Walk over each section attached to the input bfd.  */
for|for
control|(
name|section
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|,
modifier|*
name|irelaend
decl_stmt|,
modifier|*
name|irela
decl_stmt|;
comment|/* If there aren't any relocs, then there's nothing more              to do.  */
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|section
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
comment|/* If this section is a link-once section that will be              discarded, then don't create any stubs.  */
if|if
condition|(
name|section
operator|->
name|output_section
operator|==
name|NULL
operator|||
name|section
operator|->
name|output_section
operator|->
name|owner
operator|!=
name|output_bfd
condition|)
continue|continue;
comment|/* Get the relocs.  */
name|internal_relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|input_bfd
argument_list|,
name|section
argument_list|,
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_ret_free_local
goto|;
comment|/* Now examine each relocation.  */
name|irela
operator|=
name|internal_relocs
expr_stmt|;
name|irelaend
operator|=
name|irela
operator|+
name|section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|irela
operator|<
name|irelaend
condition|;
name|irela
operator|++
control|)
block|{
name|unsigned
name|int
name|r_type
decl_stmt|,
name|r_indx
decl_stmt|;
name|struct
name|elf32_m68hc11_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|bfd_vma
name|sym_value
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|hash
decl_stmt|;
specifier|const
name|char
modifier|*
name|stub_name
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|irela
operator|->
name|r_info
argument_list|)
expr_stmt|;
comment|/* Only look at 16-bit relocs.  */
if|if
condition|(
name|r_type
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|R_M68HC11_16
condition|)
continue|continue;
comment|/* Now determine the call target, its name, value,                  section.  */
name|r_indx
operator|=
name|ELF32_R_SYM
argument_list|(
name|irela
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_indx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* It's a local symbol.  */
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|bfd_boolean
name|is_far
decl_stmt|;
name|sym
operator|=
name|local_syms
operator|+
name|r_indx
expr_stmt|;
name|is_far
operator|=
operator|(
name|sym
operator|&&
operator|(
name|sym
operator|->
name|st_other
operator|&
name|STO_M68HC12_FAR
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_far
condition|)
continue|continue;
name|hdr
operator|=
name|elf_elfsections
argument_list|(
name|input_bfd
argument_list|)
index|[
name|sym
operator|->
name|st_shndx
index|]
expr_stmt|;
name|sym_sec
operator|=
name|hdr
operator|->
name|bfd_section
expr_stmt|;
name|stub_name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
operator|)
expr_stmt|;
name|sym_value
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
name|hash
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* It's an external symbol.  */
name|int
name|e_indx
decl_stmt|;
name|e_indx
operator|=
name|r_indx
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|hash
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
operator|(
name|sym_hashes
index|[
name|e_indx
index|]
operator|)
expr_stmt|;
while|while
condition|(
name|hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|hash
operator|=
operator|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|hash
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
operator|)
expr_stmt|;
if|if
condition|(
name|hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|hash
operator|->
name|other
operator|&
name|STO_M68HC12_FAR
operator|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
continue|continue;
block|}
else|else
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_ret_free_internal
goto|;
block|}
name|sym_sec
operator|=
name|hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|sym_value
operator|=
name|hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
name|stub_name
operator|=
name|hash
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|stub_name
condition|)
goto|goto
name|error_ret_free_internal
goto|;
name|stub_entry
operator|=
name|m68hc12_stub_hash_lookup
argument_list|(
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|stub_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|add_stub_section
operator|==
literal|0
condition|)
continue|continue;
name|stub_entry
operator|=
name|m68hc12_add_stub
argument_list|(
name|stub_name
argument_list|,
name|section
argument_list|,
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_entry
operator|==
name|NULL
condition|)
block|{
name|error_ret_free_internal
label|:
if|if
condition|(
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|relocs
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
goto|goto
name|error_ret_free_local
goto|;
block|}
block|}
name|stub_entry
operator|->
name|target_value
operator|=
name|sym_value
expr_stmt|;
name|stub_entry
operator|->
name|target_section
operator|=
name|sym_sec
expr_stmt|;
block|}
comment|/* We're done with the internal relocs, free them.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|relocs
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|add_stub_section
condition|)
block|{
comment|/* OK, we've added some stubs.  Find out the new size of the          stub sections.  */
for|for
control|(
name|stub_sec
operator|=
name|htab
operator|->
name|stub_bfd
operator|->
name|sections
init|;
name|stub_sec
operator|!=
name|NULL
condition|;
name|stub_sec
operator|=
name|stub_sec
operator|->
name|next
control|)
block|{
name|stub_sec
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|stub_sec
operator|->
name|_cooked_size
operator|=
literal|0
expr_stmt|;
block|}
name|bfd_hash_traverse
argument_list|(
name|htab
operator|->
name|stub_hash_table
argument_list|,
name|htab
operator|->
name|size_one_stub
argument_list|,
name|htab
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|all_local_syms
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_ret_free_local
label|:
name|free
argument_list|(
name|all_local_syms
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Export the trampoline addresses in the symbol table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m68hc11_elf_export_one_stub
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|gen_entry
parameter_list|,
name|void
modifier|*
name|in_arg
parameter_list|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|m68hc11_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|elf32_m68hc11_stub_hash_entry
modifier|*
name|stub_entry
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_boolean
name|result
decl_stmt|;
name|info
operator|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|in_arg
expr_stmt|;
name|htab
operator|=
name|m68hc11_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* Massage our args to the form they really have.  */
name|stub_entry
operator|=
operator|(
expr|struct
name|elf32_m68hc11_stub_hash_entry
operator|*
operator|)
name|gen_entry
expr_stmt|;
comment|/* Generate the trampoline according to HC11 or HC12.  */
name|result
operator|=
call|(
modifier|*
name|htab
operator|->
name|build_one_stub
call|)
argument_list|(
name|gen_entry
argument_list|,
name|in_arg
argument_list|)
expr_stmt|;
comment|/* Make a printable name that does not conflict with the real function.  */
name|name
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|stub_entry
operator|->
name|root
operator|.
name|string
argument_list|)
operator|+
literal|16
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"tramp.%s"
argument_list|,
name|stub_entry
operator|->
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
comment|/* Export the symbol for debugging/disassembling.  */
name|m68hc11_elf_set_symbol
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|info
argument_list|,
name|name
argument_list|,
name|stub_entry
operator|->
name|stub_offset
argument_list|,
name|stub_entry
operator|->
name|stub_sec
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Export a symbol or set its value and section.  */
end_comment

begin_function
specifier|static
name|void
name|m68hc11_elf_set_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bfd_vma
name|value
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|sec
argument_list|,
name|value
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|h
operator|->
name|root
operator|.
name|type
operator|=
name|bfd_link_hash_defined
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|sec
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build all the stubs associated with the current output file.  The    stubs are kept in a hash table attached to the main linker hash    table.  This function is called via m68hc12elf_finish in the    linker.  */
end_comment

begin_function
name|bfd_boolean
name|elf32_m68hc11_build_stubs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|asection
modifier|*
name|stub_sec
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
name|struct
name|m68hc11_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|m68hc11_scan_param
name|param
decl_stmt|;
name|m68hc11_elf_get_bank_parameters
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|htab
operator|=
name|m68hc11_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
for|for
control|(
name|stub_sec
operator|=
name|htab
operator|->
name|stub_bfd
operator|->
name|sections
init|;
name|stub_sec
operator|!=
name|NULL
condition|;
name|stub_sec
operator|=
name|stub_sec
operator|->
name|next
control|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
comment|/* Allocate memory to hold the linker stubs.  */
name|size
operator|=
name|stub_sec
operator|->
name|_raw_size
expr_stmt|;
name|stub_sec
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_sec
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|size
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|stub_sec
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Build the stubs as directed by the stub hash table.  */
name|table
operator|=
name|htab
operator|->
name|stub_hash_table
expr_stmt|;
name|bfd_hash_traverse
argument_list|(
name|table
argument_list|,
name|m68hc11_elf_export_one_stub
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* Scan the output sections to see if we use the memory banks.      If so, export the symbols that define how the memory banks      are mapped.  This is used by gdb and the simulator to obtain      the information.  It can be used by programs to burn the eprom      at the good addresses.  */
name|param
operator|.
name|use_memory_banks
operator|=
name|FALSE
expr_stmt|;
name|param
operator|.
name|pinfo
operator|=
operator|&
name|htab
operator|->
name|pinfo
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|scan_sections_for_abi
argument_list|,
operator|&
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|param
operator|.
name|use_memory_banks
condition|)
block|{
name|m68hc11_elf_set_symbol
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|BFD_M68HC11_BANK_START_NAME
argument_list|,
name|htab
operator|->
name|pinfo
operator|.
name|bank_physical
argument_list|,
name|bfd_abs_section_ptr
argument_list|)
expr_stmt|;
name|m68hc11_elf_set_symbol
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|BFD_M68HC11_BANK_VIRTUAL_NAME
argument_list|,
name|htab
operator|->
name|pinfo
operator|.
name|bank_virtual
argument_list|,
name|bfd_abs_section_ptr
argument_list|)
expr_stmt|;
name|m68hc11_elf_set_symbol
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|BFD_M68HC11_BANK_SIZE_NAME
argument_list|,
name|htab
operator|->
name|pinfo
operator|.
name|bank_size
argument_list|,
name|bfd_abs_section_ptr
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
name|m68hc11_elf_get_bank_parameters
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|struct
name|m68hc11_page_info
modifier|*
name|pinfo
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|pinfo
operator|=
operator|&
name|m68hc11_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|pinfo
expr_stmt|;
if|if
condition|(
name|pinfo
operator|->
name|bank_param_initialized
condition|)
return|return;
name|pinfo
operator|->
name|bank_virtual
operator|=
name|M68HC12_BANK_VIRT
expr_stmt|;
name|pinfo
operator|->
name|bank_mask
operator|=
name|M68HC12_BANK_MASK
expr_stmt|;
name|pinfo
operator|->
name|bank_physical
operator|=
name|M68HC12_BANK_BASE
expr_stmt|;
name|pinfo
operator|->
name|bank_shift
operator|=
name|M68HC12_BANK_SHIFT
expr_stmt|;
name|pinfo
operator|->
name|bank_size
operator|=
literal|1
operator|<<
name|M68HC12_BANK_SHIFT
expr_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|BFD_M68HC11_BANK_START_NAME
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
condition|)
name|pinfo
operator|->
name|bank_physical
operator|=
operator|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|BFD_M68HC11_BANK_VIRTUAL_NAME
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
condition|)
name|pinfo
operator|->
name|bank_virtual
operator|=
operator|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
name|BFD_M68HC11_BANK_SIZE_NAME
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
condition|)
name|pinfo
operator|->
name|bank_size
operator|=
operator|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|pinfo
operator|->
name|bank_shift
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|pinfo
operator|->
name|bank_size
init|;
name|i
operator|!=
literal|0
condition|;
name|i
operator|>>=
literal|1
control|)
name|pinfo
operator|->
name|bank_shift
operator|++
expr_stmt|;
name|pinfo
operator|->
name|bank_shift
operator|--
expr_stmt|;
name|pinfo
operator|->
name|bank_mask
operator|=
operator|(
literal|1
operator|<<
name|pinfo
operator|->
name|bank_shift
operator|)
operator|-
literal|1
expr_stmt|;
name|pinfo
operator|->
name|bank_physical_end
operator|=
name|pinfo
operator|->
name|bank_physical
operator|+
name|pinfo
operator|->
name|bank_size
expr_stmt|;
name|pinfo
operator|->
name|bank_param_initialized
operator|=
literal|1
expr_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
literal|"__far_trampoline"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
condition|)
name|pinfo
operator|->
name|trampoline_addr
operator|=
operator|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if the address is in banked memory.    This can be applied to a virtual address and to a physical address.  */
end_comment

begin_function
name|int
name|m68hc11_addr_is_banked
parameter_list|(
name|struct
name|m68hc11_page_info
modifier|*
name|pinfo
parameter_list|,
name|bfd_vma
name|addr
parameter_list|)
block|{
if|if
condition|(
name|addr
operator|>=
name|pinfo
operator|->
name|bank_virtual
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|addr
operator|>=
name|pinfo
operator|->
name|bank_physical
operator|&&
name|addr
operator|<=
name|pinfo
operator|->
name|bank_physical_end
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the physical address seen by the processor, taking    into account banked memory.  */
end_comment

begin_function
name|bfd_vma
name|m68hc11_phys_addr
parameter_list|(
name|struct
name|m68hc11_page_info
modifier|*
name|pinfo
parameter_list|,
name|bfd_vma
name|addr
parameter_list|)
block|{
if|if
condition|(
name|addr
operator|<
name|pinfo
operator|->
name|bank_virtual
condition|)
return|return
name|addr
return|;
comment|/* Map the address to the memory bank.  */
name|addr
operator|-=
name|pinfo
operator|->
name|bank_virtual
expr_stmt|;
name|addr
operator|&=
name|pinfo
operator|->
name|bank_mask
expr_stmt|;
name|addr
operator|+=
name|pinfo
operator|->
name|bank_physical
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Return the page number corresponding to an address in banked memory.  */
end_comment

begin_function
name|bfd_vma
name|m68hc11_phys_page
parameter_list|(
name|struct
name|m68hc11_page_info
modifier|*
name|pinfo
parameter_list|,
name|bfd_vma
name|addr
parameter_list|)
block|{
if|if
condition|(
name|addr
operator|<
name|pinfo
operator|->
name|bank_virtual
condition|)
return|return
literal|0
return|;
comment|/* Map the address to the memory bank.  */
name|addr
operator|-=
name|pinfo
operator|->
name|bank_virtual
expr_stmt|;
name|addr
operator|>>=
name|pinfo
operator|->
name|bank_shift
expr_stmt|;
name|addr
operator|&=
literal|0x0ff
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* This function is used for relocs which are only used for relaxing,    which the linker should otherwise ignore.  */
end_comment

begin_function
name|bfd_reloc_status_type
name|m68hc11_elf_ignore_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function
name|bfd_reloc_status_type
name|m68hc11_elf_special_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|reloc_entry
operator|->
name|howto
operator|->
name|partial_inplace
operator|||
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
operator|)
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_reloc_continue
return|;
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|input_section
operator|->
name|_cooked_size
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|asection
modifier|*
name|elf32_m68hc11_gc_mark_hook
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
default|default:
break|break;
block|}
block|}
block|}
else|else
return|return
name|bfd_section_from_elf_index
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|elf32_m68hc11_gc_sweep_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* We don't use got and plt entries for 68hc11/68hc12.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase.    Since we don't do .gots or .plts, we just need to consider the    virtual table relocs for gc.  */
end_comment

begin_function
name|bfd_boolean
name|elf32_m68hc11_check_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes_end
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_hashes_end
operator|=
name|sym_hashes
operator|+
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|sym_hashes_end
operator|-=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
comment|/* This relocation describes the C++ object vtable hierarchy.            Reconstruct it for later use during GC.  */
case|case
name|R_M68HC11_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually            used.  Record for later use during GC.  */
case|case
name|R_M68HC11_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|m68hc11_get_relocation_value
parameter_list|(
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|name
parameter_list|,
name|bfd_vma
modifier|*
name|relocation
parameter_list|,
name|bfd_boolean
modifier|*
name|is_far
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
name|stub_name
init|=
literal|0
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
comment|/* This is a final link.  */
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
operator|*
name|relocation
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
operator|)
expr_stmt|;
operator|*
name|is_far
operator|=
operator|(
name|sym
operator|&&
operator|(
name|sym
operator|->
name|st_other
operator|&
name|STO_M68HC12_FAR
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|is_far
condition|)
name|stub_name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_boolean
name|unresolved_reloc
decl_stmt|,
name|warned
decl_stmt|;
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
operator|*
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
operator|*
name|is_far
operator|=
operator|(
name|h
operator|&&
operator|(
name|h
operator|->
name|other
operator|&
name|STO_M68HC12_FAR
operator|)
operator|)
expr_stmt|;
name|stub_name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
operator|*
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
operator|*
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
name|NULL
operator|||
operator|*
operator|*
name|name
operator|==
literal|'\0'
condition|)
operator|*
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|is_far
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_M68HC11_16
condition|)
block|{
name|struct
name|elf32_m68hc11_stub_hash_entry
modifier|*
name|stub
decl_stmt|;
name|struct
name|m68hc11_elf_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|m68hc11_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|stub
operator|=
name|m68hc12_stub_hash_lookup
argument_list|(
name|htab
operator|->
name|stub_hash_table
argument_list|,
operator|*
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub
condition|)
block|{
operator|*
name|relocation
operator|=
name|stub
operator|->
name|stub_offset
operator|+
name|stub
operator|->
name|stub_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|stub
operator|->
name|stub_sec
operator|->
name|output_offset
expr_stmt|;
operator|*
name|is_far
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Relocate a 68hc11/68hc12 ELF section.  */
end_comment

begin_function
name|bfd_boolean
name|elf32_m68hc11_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|m68hc11_page_info
modifier|*
name|pinfo
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
specifier|const
name|ebd
init|=
name|get_elf_backend_data
argument_list|(
name|input_bfd
argument_list|)
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
comment|/* Get memory bank parameters.  */
name|m68hc11_elf_get_bank_parameters
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|pinfo
operator|=
operator|&
name|m68hc11_elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|pinfo
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|arelent
name|arel
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
init|=
name|bfd_reloc_undefined
decl_stmt|;
name|bfd_vma
name|phys_page
decl_stmt|;
name|bfd_vma
name|phys_addr
decl_stmt|;
name|bfd_vma
name|insn_addr
decl_stmt|;
name|bfd_vma
name|insn_page
decl_stmt|;
name|bfd_boolean
name|is_far
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_M68HC11_GNU_VTENTRY
operator|||
name|r_type
operator|==
name|R_M68HC11_GNU_VTINHERIT
condition|)
continue|continue;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
block|{
comment|/* This is a relocatable link.  We don't have to change 	     anything, unless the reloc is against a section symbol, 	     in which case we have to adjust according to where the 	     section symbol winds up in the output section.  */
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|+=
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
expr_stmt|;
block|}
block|}
continue|continue;
block|}
call|(
modifier|*
name|ebd
operator|->
name|elf_info_to_howto_rel
call|)
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|arel
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|howto
operator|=
name|arel
operator|.
name|howto
expr_stmt|;
name|m68hc11_get_relocation_value
argument_list|(
name|input_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|local_sections
argument_list|,
name|local_syms
argument_list|,
name|rel
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|relocation
argument_list|,
operator|&
name|is_far
argument_list|)
expr_stmt|;
comment|/* Do the memory bank mapping.  */
name|phys_addr
operator|=
name|m68hc11_phys_addr
argument_list|(
name|pinfo
argument_list|,
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
name|phys_page
operator|=
name|m68hc11_phys_page
argument_list|(
name|pinfo
argument_list|,
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_M68HC11_24
case|:
comment|/* Reloc used by 68HC12 call instruction.  */
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|phys_addr
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|input_bfd
argument_list|,
name|phys_page
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|2
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
name|r_type
operator|=
name|R_M68HC11_NONE
expr_stmt|;
break|break;
case|case
name|R_M68HC11_NONE
case|:
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
break|break;
case|case
name|R_M68HC11_LO16
case|:
comment|/* Reloc generated by %addr(expr) gas to obtain the              address as mapped in the memory bank window.  */
name|relocation
operator|=
name|phys_addr
expr_stmt|;
break|break;
case|case
name|R_M68HC11_PAGE
case|:
comment|/* Reloc generated by %page(expr) gas to obtain the              page number associated with the address.  */
name|relocation
operator|=
name|phys_page
expr_stmt|;
break|break;
case|case
name|R_M68HC11_16
case|:
comment|/* Get virtual address of instruction having the relocation.  */
if|if
condition|(
name|is_far
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|msg
operator|=
name|_
argument_list|(
literal|"Reference to the far symbol `%s' using a wrong "
literal|"relocation may result in incorrect execution"
argument_list|)
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|msg
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|msg
argument_list|,
name|name
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|buf
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|NULL
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
comment|/* Get virtual address of instruction having the relocation.  */
name|insn_addr
operator|=
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
expr_stmt|;
name|insn_page
operator|=
name|m68hc11_phys_page
argument_list|(
name|pinfo
argument_list|,
name|insn_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|m68hc11_addr_is_banked
argument_list|(
name|pinfo
argument_list|,
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|)
operator|&&
name|m68hc11_addr_is_banked
argument_list|(
name|pinfo
argument_list|,
name|insn_addr
argument_list|)
operator|&&
name|phys_page
operator|!=
name|insn_page
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|msg
operator|=
name|_
argument_list|(
literal|"banked address [%lx:%04lx] (%lx) is not in the same bank "
literal|"as current banked address [%lx:%04lx] (%lx)"
argument_list|)
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|msg
argument_list|)
operator|+
literal|128
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|msg
argument_list|,
name|phys_page
argument_list|,
name|phys_addr
argument_list|,
call|(
name|long
call|)
argument_list|(
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|)
argument_list|,
name|insn_page
argument_list|,
name|m68hc11_phys_addr
argument_list|(
name|pinfo
argument_list|,
name|insn_addr
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|insn_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|buf
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
if|if
condition|(
name|phys_page
operator|!=
literal|0
operator|&&
name|insn_page
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|msg
operator|=
name|_
argument_list|(
literal|"reference to a banked address [%lx:%04lx] in the "
literal|"normal address space at %04lx"
argument_list|)
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|msg
argument_list|)
operator|+
literal|128
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|msg
argument_list|,
name|phys_page
argument_list|,
name|phys_addr
argument_list|,
name|insn_addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|buf
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|insn_addr
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|relocation
operator|=
name|phys_addr
expr_stmt|;
break|break;
block|}
comment|/* If this is a banked address use the phys_addr so that              we stay in the banked window.  */
if|if
condition|(
name|m68hc11_addr_is_banked
argument_list|(
name|pinfo
argument_list|,
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
name|relocation
operator|=
name|phys_addr
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|r_type
operator|!=
name|R_M68HC11_NONE
condition|)
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
decl_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|bfd_reloc_undefined
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: out of range error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
name|bfd_reloc_notsupported
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unsupported relocation error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
name|bfd_reloc_dangerous
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: dangerous error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
default|default:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unknown error"
argument_list|)
expr_stmt|;
comment|/* fall through */
name|common_error
label|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set and control ELF flags in ELF header.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_m68hc11_elf_set_private_flags
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|flagword
name|flags
parameter_list|)
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|||
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|==
name|flags
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
name|bfd_boolean
name|_bfd_m68hc11_elf_merge_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|flagword
name|old_flags
decl_stmt|;
name|flagword
name|new_flags
decl_stmt|;
name|bfd_boolean
name|ok
init|=
name|TRUE
decl_stmt|;
comment|/* Check if we have the same endianess */
if|if
condition|(
operator|!
name|_bfd_generic_verify_endian_match
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
name|new_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator||=
name|new_flags
operator|&
name|EF_M68HC11_ABI
expr_stmt|;
name|old_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|new_flags
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
expr_stmt|;
if|if
condition|(
name|bfd_get_arch
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
operator|&&
name|bfd_get_arch_info
argument_list|(
name|obfd
argument_list|)
operator|->
name|the_default
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
comment|/* Check ABI compatibility.  */
if|if
condition|(
operator|(
name|new_flags
operator|&
name|E_M68HC11_I32
operator|)
operator|!=
operator|(
name|old_flags
operator|&
name|E_M68HC11_I32
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: linking files compiled for 16-bit integers (-mshort) "
literal|"and others for 32-bit integers"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|new_flags
operator|&
name|E_M68HC11_F64
operator|)
operator|!=
operator|(
name|old_flags
operator|&
name|E_M68HC11_F64
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: linking files compiled for 32-bit double (-fshort-double) "
literal|"and others for 64-bit double"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Processor compatibility.  */
if|if
condition|(
operator|!
name|EF_M68HC11_CAN_MERGE_MACH
argument_list|(
name|new_flags
argument_list|,
name|old_flags
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: linking files compiled for HCS12 with "
literal|"others compiled for HC12"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
name|new_flags
operator|=
operator|(
operator|(
name|new_flags
operator|&
operator|~
name|EF_M68HC11_MACH_MASK
operator|)
operator||
operator|(
name|EF_M68HC11_MERGE_MACH
argument_list|(
name|new_flags
argument_list|,
name|old_flags
argument_list|)
operator|)
operator|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|new_flags
expr_stmt|;
name|new_flags
operator|&=
operator|~
operator|(
name|EF_M68HC11_ABI
operator||
name|EF_M68HC11_MACH_MASK
operator|)
expr_stmt|;
name|old_flags
operator|&=
operator|~
operator|(
name|EF_M68HC11_ABI
operator||
name|EF_M68HC11_MACH_MASK
operator|)
expr_stmt|;
comment|/* Warn about any other mismatches */
if|if
condition|(
name|new_flags
operator|!=
name|old_flags
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|new_flags
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|old_flags
argument_list|)
expr_stmt|;
name|ok
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bfd_boolean
name|_bfd_m68hc11_elf_print_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|ptr
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|abfd
operator|!=
name|NULL
operator|&&
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Print normal ELF private data.  */
name|_bfd_elf_print_private_bfd_data
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* xgettext:c-format */
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"private flags = %lx:"
argument_list|)
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|E_M68HC11_I32
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"[abi=32-bit int, "
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"[abi=16-bit int, "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|E_M68HC11_F64
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"64-bit double, "
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"32-bit double, "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_target
argument_list|(
name|abfd
argument_list|)
argument_list|,
literal|"elf32-m68hc11"
argument_list|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"cpu=HC11]"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_M68HCS12_MACH
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"cpu=HCS12]"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"cpu=HC12]"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|E_M68HC12_BANKS
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [memory=bank-model]"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|" [memory=flat]"
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|scan_sections_for_abi
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|asect
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|m68hc11_scan_param
modifier|*
name|p
init|=
operator|(
expr|struct
name|m68hc11_scan_param
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|asect
operator|->
name|vma
operator|>=
name|p
operator|->
name|pinfo
operator|->
name|bank_virtual
condition|)
name|p
operator|->
name|use_memory_banks
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tweak the OSABI field of the elf header.  */
end_comment

begin_function
name|void
name|elf32_m68hc11_post_process_headers
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|)
block|{
name|struct
name|m68hc11_scan_param
name|param
decl_stmt|;
if|if
condition|(
name|link_info
operator|==
literal|0
condition|)
return|return;
name|m68hc11_elf_get_bank_parameters
argument_list|(
name|link_info
argument_list|)
expr_stmt|;
name|param
operator|.
name|use_memory_banks
operator|=
name|FALSE
expr_stmt|;
name|param
operator|.
name|pinfo
operator|=
operator|&
name|m68hc11_elf_hash_table
argument_list|(
name|link_info
argument_list|)
operator|->
name|pinfo
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|scan_sections_for_abi
argument_list|,
operator|&
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|param
operator|.
name|use_memory_banks
condition|)
block|{
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|i_ehdrp
operator|->
name|e_flags
operator||=
name|E_M68HC12_BANKS
expr_stmt|;
block|}
block|}
end_function

end_unit

