begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* M32R-specific support for 32-bit ELF.    Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,    2006 Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/m32r.h"
end_include

begin_define
define|#
directive|define
name|NOP_INSN
value|0x7000
end_define

begin_define
define|#
directive|define
name|MAKE_PARALLEL
parameter_list|(
name|insn
parameter_list|)
value|((insn) | 0x8000)
end_define

begin_comment
comment|/* Use REL instead of RELA to save space.    This only saves space in libraries and object files, but perhaps    relocs will be put in ROM?  All in all though, REL relocs are a pain    to work with.  */
end_comment

begin_comment
comment|/* #define USE_REL	1  #ifndef USE_REL #define USE_REL	0 #endif */
end_comment

begin_comment
comment|/* Use RELA. But use REL to link old objects for backwords compatibility.  */
end_comment

begin_comment
comment|/* Functions for the M32R ELF linker.  */
end_comment

begin_comment
comment|/* The name of the dynamic interpreter.  This is put in the .interp    section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/usr/lib/libc.so.1"
end_define

begin_comment
comment|/* The nop opcode we use.  */
end_comment

begin_define
define|#
directive|define
name|M32R_NOP
value|0x7000f000
end_define

begin_define
define|#
directive|define
name|PLT_EMPTY
value|0x10101010
end_define

begin_comment
comment|/* RIE  -> RIE */
end_comment

begin_comment
comment|/* The size in bytes of an entry in the procedure linkage table.  */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_SIZE
value|20
end_define

begin_define
define|#
directive|define
name|PLT_HEADER_SIZE
value|20
end_define

begin_comment
comment|/* The first one entries in a procedure linkage table are reserved,    and the initial contents are unimportant (we zero them out).    Subsequent entries look like this. */
end_comment

begin_define
define|#
directive|define
name|PLT0_ENTRY_WORD0
value|0xd6c00000
end_define

begin_comment
comment|/* seth r6, #high(.got+4)          */
end_comment

begin_define
define|#
directive|define
name|PLT0_ENTRY_WORD1
value|0x86e60000
end_define

begin_comment
comment|/* or3  r6, r6, #low(.got)+4)      */
end_comment

begin_define
define|#
directive|define
name|PLT0_ENTRY_WORD2
value|0x24e626c6
end_define

begin_comment
comment|/* ld   r4, @r6+    -> ld r6, @r6  */
end_comment

begin_define
define|#
directive|define
name|PLT0_ENTRY_WORD3
value|0x1fc6f000
end_define

begin_comment
comment|/* jmp  r6          || pnop        */
end_comment

begin_define
define|#
directive|define
name|PLT0_ENTRY_WORD4
value|PLT_EMPTY
end_define

begin_comment
comment|/* RIE             -> RIE          */
end_comment

begin_define
define|#
directive|define
name|PLT0_PIC_ENTRY_WORD0
value|0xa4cc0004
end_define

begin_comment
comment|/* ld   r4, @(4,r12)              */
end_comment

begin_define
define|#
directive|define
name|PLT0_PIC_ENTRY_WORD1
value|0xa6cc0008
end_define

begin_comment
comment|/* ld   r6, @(8,r12)              */
end_comment

begin_define
define|#
directive|define
name|PLT0_PIC_ENTRY_WORD2
value|0x1fc6f000
end_define

begin_comment
comment|/* jmp  r6         || nop         */
end_comment

begin_define
define|#
directive|define
name|PLT0_PIC_ENTRY_WORD3
value|PLT_EMPTY
end_define

begin_comment
comment|/* RIE             -> RIE         */
end_comment

begin_define
define|#
directive|define
name|PLT0_PIC_ENTRY_WORD4
value|PLT_EMPTY
end_define

begin_comment
comment|/* RIE             -> RIE         */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_WORD0
value|0xe6000000
end_define

begin_comment
comment|/* ld24 r6, .name_in_GOT                */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_WORD1
value|0x06acf000
end_define

begin_comment
comment|/* add  r6, r12          || nop         */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_WORD0b
value|0xd6c00000
end_define

begin_comment
comment|/* seth r6, #high(.name_in_GOT)         */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_WORD1b
value|0x86e60000
end_define

begin_comment
comment|/* or3  r6, r6, #low(.name_in_GOT)      */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_WORD2
value|0x26c61fc6
end_define

begin_comment
comment|/* ld  r6, @r6           -> jmp r6      */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_WORD3
value|0xe5000000
end_define

begin_comment
comment|/* ld24 r5, $offset                     */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_WORD4
value|0xff000000
end_define

begin_comment
comment|/* bra  .plt0.                          */
end_comment

begin_comment
comment|/* Utility to actually perform an R_M32R_10_PCREL reloc.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|m32r_elf_do_10_pcrel_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|reloc_howto_type
modifier|*
name|howto
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|data
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|asection
modifier|*
name|symbol_section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_vma
name|symbol_value
parameter_list|,
name|bfd_vma
name|addend
parameter_list|)
block|{
name|bfd_signed_vma
name|relocation
decl_stmt|;
name|unsigned
name|long
name|x
decl_stmt|;
name|bfd_reloc_status_type
name|status
decl_stmt|;
comment|/* Sanity check the address (offset in section).  */
if|if
condition|(
name|offset
operator|>
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|input_section
argument_list|)
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|relocation
operator|=
name|symbol_value
operator|+
name|addend
expr_stmt|;
comment|/* Make it pc relative.  */
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
comment|/* These jumps mask off the lower two bits of the current address      before doing pcrel calculations.  */
name|relocation
operator|-=
operator|(
name|offset
operator|&
operator|-
operator|(
name|bfd_vma
operator|)
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|relocation
operator|<
operator|-
literal|0x200
operator|||
name|relocation
operator|>
literal|0x1ff
condition|)
name|status
operator|=
name|bfd_reloc_overflow
expr_stmt|;
else|else
name|status
operator|=
name|bfd_reloc_ok
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|data
operator|+
name|offset
argument_list|)
expr_stmt|;
name|relocation
operator|>>=
name|howto
operator|->
name|rightshift
expr_stmt|;
name|relocation
operator|<<=
name|howto
operator|->
name|bitpos
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
operator|~
name|howto
operator|->
name|dst_mask
operator|)
operator||
operator|(
operator|(
operator|(
name|x
operator|&
name|howto
operator|->
name|src_mask
operator|)
operator|+
name|relocation
operator|)
operator|&
name|howto
operator|->
name|dst_mask
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|x
argument_list|,
name|data
operator|+
name|offset
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* Handle the R_M32R_10_PCREL reloc.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|m32r_elf_10_pcrel_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* This part is from bfd_elf_generic_reloc.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|reloc_entry
operator|->
name|howto
operator|->
name|partial_inplace
operator|||
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
operator|)
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
comment|/* FIXME: See bfd_perform_relocation.  Is this right?  */
return|return
name|bfd_reloc_continue
return|;
return|return
name|m32r_elf_do_10_pcrel_reloc
argument_list|(
name|abfd
argument_list|,
name|reloc_entry
operator|->
name|howto
argument_list|,
name|input_section
argument_list|,
name|data
argument_list|,
name|reloc_entry
operator|->
name|address
argument_list|,
name|symbol
operator|->
name|section
argument_list|,
operator|(
name|symbol
operator|->
name|value
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
operator|)
argument_list|,
name|reloc_entry
operator|->
name|addend
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Do generic partial_inplace relocation.    This is a local replacement for bfd_elf_generic_reloc.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|m32r_elf_generic_reloc
parameter_list|(
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_reloc_status_type
name|ret
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_byte
modifier|*
name|inplace_address
decl_stmt|;
comment|/* This part is from bfd_elf_generic_reloc.      If we're relocating, and this an external symbol, we don't want      to change anything.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* Now do the reloc in the usual way.      ??? It would be nice to call bfd_elf_generic_reloc here,      but we have partial_inplace set.  bfd_elf_generic_reloc will      pass the handling back to bfd_install_relocation which will install      a section relative addend which is wrong.  */
comment|/* Sanity check the address (offset in section).  */
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|bfd_get_section_limit
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|ret
operator|=
name|bfd_reloc_ok
expr_stmt|;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|&&
name|output_bfd
operator|==
name|NULL
condition|)
name|ret
operator|=
name|bfd_reloc_undefined
expr_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|||
name|output_bfd
operator|!=
name|NULL
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
comment|/* Only do this for a final link.  */
if|if
condition|(
name|output_bfd
operator|==
name|NULL
condition|)
block|{
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
block|}
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|inplace_address
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
expr_stmt|;
define|#
directive|define
name|DOIT
parameter_list|(
name|x
parameter_list|)
define|\
value|x = ( (x& ~reloc_entry->howto->dst_mask) | 		\   (((x& reloc_entry->howto->src_mask) +  relocation)&	\   reloc_entry->howto->dst_mask))
switch|switch
condition|(
name|reloc_entry
operator|->
name|howto
operator|->
name|size
condition|)
block|{
case|case
literal|1
case|:
block|{
name|short
name|x
init|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|inplace_address
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|x
argument_list|,
name|inplace_address
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
block|{
name|unsigned
name|long
name|x
init|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|inplace_address
argument_list|)
decl_stmt|;
name|DOIT
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|x
argument_list|,
name|inplace_address
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|BFD_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Handle the R_M32R_SDA16 reloc.    This reloc is used to compute the address of objects in the small data area    and to perform loads and stores from that area.    The lower 16 bits are sign extended and added to the register specified    in the instruction, which is assumed to point to _SDA_BASE_.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|m32r_elf_sda16_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* This part is from bfd_elf_generic_reloc.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|reloc_entry
operator|->
name|howto
operator|->
name|partial_inplace
operator|||
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
operator|)
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
comment|/* FIXME: See bfd_perform_relocation.  Is this right?  */
return|return
name|bfd_reloc_continue
return|;
comment|/* FIXME: not sure what to do here yet.  But then again, the linker      may never call us.  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle the R_M32R_HI16_[SU]LO relocs.    HI16_SLO is for the add3 and load/store with displacement instructions.    HI16_ULO is for the or3 instruction.    For R_M32R_HI16_SLO, the lower 16 bits are sign extended when added to    the high 16 bytes so if the lower 16 bits are negative (bit 15 == 1) then    we must add one to the high 16 bytes (which will get subtracted off when    the low 16 bits are added).    These relocs have to be done in combination with an R_M32R_LO16 reloc    because there is a carry from the LO16 to the HI16.  Here we just save    the information we need; we do the actual relocation when we see the LO16.    This code is copied from the elf32-mips.c.  We also support an arbitrary    number of HI16 relocs to be associated with a single LO16 reloc.  The    assembler sorts the relocs to ensure each HI16 immediately precedes its    LO16.  However if there are multiple copies, the assembler may not find    the real LO16 so it picks the first one it finds.  */
end_comment

begin_struct
struct|struct
name|m32r_hi16
block|{
name|struct
name|m32r_hi16
modifier|*
name|next
decl_stmt|;
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* FIXME: This should not be a static variable.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|m32r_hi16
modifier|*
name|m32r_hi16_list
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_reloc_status_type
name|m32r_elf_hi16_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_reloc_status_type
name|ret
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|struct
name|m32r_hi16
modifier|*
name|n
decl_stmt|;
comment|/* This part is from bfd_elf_generic_reloc.      If we're relocating, and this an external symbol, we don't want      to change anything.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* Sanity check the address (offset in section).  */
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|input_section
argument_list|)
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|ret
operator|=
name|bfd_reloc_ok
expr_stmt|;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|&&
name|output_bfd
operator|==
name|NULL
condition|)
name|ret
operator|=
name|bfd_reloc_undefined
expr_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
comment|/* Save the information, and let LO16 do the actual relocation.  */
name|n
operator|=
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|n
operator|->
name|addr
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
expr_stmt|;
name|n
operator|->
name|addend
operator|=
name|relocation
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|m32r_hi16_list
expr_stmt|;
name|m32r_hi16_list
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Handle an M32R ELF HI16 reloc.  */
end_comment

begin_function
specifier|static
name|void
name|m32r_elf_relocate_hi16
parameter_list|(
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|int
name|type
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relhi
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rello
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|bfd_vma
name|addend
parameter_list|)
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
name|bfd_vma
name|addlo
decl_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|relhi
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|addlo
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rello
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|R_M32R_HI16_SLO
condition|)
name|addlo
operator|=
operator|(
operator|(
name|addlo
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
else|else
name|addlo
operator|&=
literal|0xffff
expr_stmt|;
name|addend
operator|+=
operator|(
operator|(
name|insn
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator|+
name|addlo
expr_stmt|;
comment|/* Reaccount for sign extension of low part.  */
if|if
condition|(
name|type
operator|==
name|R_M32R_HI16_SLO
operator|&&
operator|(
name|addend
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
condition|)
name|addend
operator|+=
literal|0x10000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|insn
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
operator|(
name|addend
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
argument_list|,
name|contents
operator|+
name|relhi
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do an R_M32R_LO16 relocation.  This is a straightforward 16 bit    inplace relocation; this function exists in order to do the    R_M32R_HI16_[SU]LO relocation described above.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|m32r_elf_lo16_reloc
parameter_list|(
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
parameter_list|)
block|{
comment|/* This part is from bfd_elf_generic_reloc.      If we're relocating, and this an external symbol, we don't want      to change anything.  */
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|m32r_hi16_list
operator|!=
name|NULL
condition|)
block|{
name|struct
name|m32r_hi16
modifier|*
name|l
decl_stmt|;
name|l
operator|=
name|m32r_hi16_list
expr_stmt|;
while|while
condition|(
name|l
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|unsigned
name|long
name|vallo
decl_stmt|;
name|struct
name|m32r_hi16
modifier|*
name|next
decl_stmt|;
comment|/* Do the HI16 relocation.  Note that we actually don't need 	     to know anything about the LO16 itself, except where to 	     find the low 16 bits of the addend needed by the LO16.  */
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|l
operator|->
name|addr
argument_list|)
expr_stmt|;
name|vallo
operator|=
operator|(
operator|(
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
operator|&
literal|0xffff
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|insn
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator|+
name|vallo
expr_stmt|;
name|val
operator|+=
name|l
operator|->
name|addend
expr_stmt|;
comment|/* Reaccount for sign extension of low part.  */
if|if
condition|(
operator|(
name|val
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
condition|)
name|val
operator|+=
literal|0x10000
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0xffff
operator|)
operator||
operator|(
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|insn
argument_list|,
name|l
operator|->
name|addr
argument_list|)
expr_stmt|;
name|next
operator|=
name|l
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
name|next
expr_stmt|;
block|}
name|m32r_hi16_list
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now do the LO16 reloc in the usual way.      ??? It would be nice to call bfd_elf_generic_reloc here,      but we have partial_inplace set.  bfd_elf_generic_reloc will      pass the handling back to bfd_install_relocation which will install      a section relative addend which is wrong.  */
return|return
name|m32r_elf_generic_reloc
argument_list|(
name|input_bfd
argument_list|,
name|reloc_entry
argument_list|,
name|symbol
argument_list|,
name|data
argument_list|,
name|input_section
argument_list|,
name|output_bfd
argument_list|,
name|error_message
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|m32r_elf_howto_table
index|[]
init|=
block|{
comment|/* This reloc does nothing.  */
name|HOWTO
argument_list|(
name|R_M32R_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_NONE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit absolute relocation.  */
name|HOWTO
argument_list|(
name|R_M32R_16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|m32r_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_16"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32 bit absolute relocation.  */
name|HOWTO
argument_list|(
name|R_M32R_32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|m32r_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_32"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 24 bit address.  */
name|HOWTO
argument_list|(
name|R_M32R_24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|24
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|m32r_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_24"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffff
argument_list|,
comment|/* src_mask */
literal|0xffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An PC Relative 10-bit relocation, shifted by 2.      This reloc is complicated because relocations are relative to pc& -4.      i.e. branches in the right insn slot use the address of the left insn      slot for pc.  */
comment|/* ??? It's not clear whether this should have partial_inplace set or not.      Branch relaxing in the assembler can store the addend in the insn,      and if bfd_install_relocation gets called the addend may get added      again.  */
name|HOWTO
argument_list|(
name|R_M32R_10_PCREL
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|10
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|m32r_elf_10_pcrel_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_10_PCREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xff
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 18 bit relocation, right shifted by 2.  */
name|HOWTO
argument_list|(
name|R_M32R_18_PCREL
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_18_PCREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 26 bit relocation, right shifted by 2.  */
comment|/* ??? It's not clear whether this should have partial_inplace set or not.      Branch relaxing in the assembler can store the addend in the insn,      and if bfd_install_relocation gets called the addend may get added      again.  */
name|HOWTO
argument_list|(
name|R_M32R_26_PCREL
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_26_PCREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffff
argument_list|,
comment|/* src_mask */
literal|0xffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* High 16 bits of address when lower 16 is or'd in.  */
name|HOWTO
argument_list|(
name|R_M32R_HI16_ULO
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|m32r_elf_hi16_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_HI16_ULO"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* High 16 bits of address when lower 16 is added in.  */
name|HOWTO
argument_list|(
name|R_M32R_HI16_SLO
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|m32r_elf_hi16_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_HI16_SLO"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Lower 16 bits of address.  */
name|HOWTO
argument_list|(
name|R_M32R_LO16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|m32r_elf_lo16_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_LO16"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Small data area 16 bits offset.  */
name|HOWTO
argument_list|(
name|R_M32R_SDA16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|m32r_elf_sda16_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_SDA16"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
comment|/* FIXME: correct? */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable hierarchy.  */
name|HOWTO
argument_list|(
name|R_M32R_GNU_VTINHERIT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_M32R_GNU_VTINHERIT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable member usage.  */
name|HOWTO
argument_list|(
name|R_M32R_GNU_VTENTRY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_elf_rel_vtable_reloc_fn
argument_list|,
comment|/* special_function */
literal|"R_M32R_GNU_VTENTRY"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|13
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|14
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|15
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|16
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|17
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|18
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|19
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|20
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|21
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|22
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|23
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|24
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|25
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|26
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|27
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|28
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|29
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|30
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|31
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|32
argument_list|)
block|,
comment|/* A 16 bit absolute relocation.  */
name|HOWTO
argument_list|(
name|R_M32R_16_RELA
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_16_RELA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32 bit absolute relocation.  */
name|HOWTO
argument_list|(
name|R_M32R_32_RELA
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_32_RELA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 24 bit address.  */
name|HOWTO
argument_list|(
name|R_M32R_24_RELA
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|24
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_24_RELA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffff
argument_list|,
comment|/* src_mask */
literal|0xffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_M32R_10_PCREL_RELA
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|10
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|m32r_elf_10_pcrel_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_10_PCREL_RELA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xff
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 18 bit relocation, right shifted by 2.  */
name|HOWTO
argument_list|(
name|R_M32R_18_PCREL_RELA
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_18_PCREL_RELA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A relative 26 bit relocation, right shifted by 2.  */
name|HOWTO
argument_list|(
name|R_M32R_26_PCREL_RELA
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_26_PCREL_RELA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffff
argument_list|,
comment|/* src_mask */
literal|0xffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* High 16 bits of address when lower 16 is or'd in.  */
name|HOWTO
argument_list|(
name|R_M32R_HI16_ULO_RELA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_HI16_ULO_RELA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* High 16 bits of address when lower 16 is added in.  */
name|HOWTO
argument_list|(
name|R_M32R_HI16_SLO_RELA
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_HI16_SLO_RELA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Lower 16 bits of address.  */
name|HOWTO
argument_list|(
name|R_M32R_LO16_RELA
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_LO16_RELA"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Small data area 16 bits offset.  */
name|HOWTO
argument_list|(
name|R_M32R_SDA16_RELA
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_SDA16_RELA"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
comment|/* FIXME: correct? */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable hierarchy.  */
name|HOWTO
argument_list|(
name|R_M32R_RELA_GNU_VTINHERIT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_M32R_RELA_GNU_VTINHERIT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable member usage.  */
name|HOWTO
argument_list|(
name|R_M32R_RELA_GNU_VTENTRY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_elf_rel_vtable_reloc_fn
argument_list|,
comment|/* special_function */
literal|"R_M32R_RELA_GNU_VTENTRY"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32 bit PC relative relocation.  */
name|HOWTO
argument_list|(
name|R_M32R_REL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_REL32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|EMPTY_HOWTO
argument_list|(
literal|46
argument_list|)
block|,
name|EMPTY_HOWTO
argument_list|(
literal|47
argument_list|)
block|,
comment|/* Like R_M32R_24, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_M32R_GOT24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|24
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_GOT24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffff
argument_list|,
comment|/* src_mask */
literal|0xffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_M32R_PCREL, but referring to the procedure linkage table      entry for the symbol.  */
name|HOWTO
argument_list|(
name|R_M32R_26_PLTREL
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|24
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_26_PLTREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffff
argument_list|,
comment|/* src_mask */
literal|0xffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* This is used only by the dynamic linker.  The symbol should exist      both in the object being run and in some shared library.  The      dynamic linker copies the data addressed by the symbol from the      shared library into the object, because the object being      run has to have the data at some particular address.  */
name|HOWTO
argument_list|(
name|R_M32R_COPY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_COPY"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_M32R_24, but used when setting global offset table      entries.  */
name|HOWTO
argument_list|(
name|R_M32R_GLOB_DAT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_GLOB_DAT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Marks a procedure linkage table entry for a symbol.  */
name|HOWTO
argument_list|(
name|R_M32R_JMP_SLOT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_JMP_SLOT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Used only by the dynamic linker.  When the object is run, this      longword is set to the load address of the object, plus the      addend.  */
name|HOWTO
argument_list|(
name|R_M32R_RELATIVE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_RELATIVE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_M32R_GOTOFF
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|24
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_GOTOFF"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffff
argument_list|,
comment|/* src_mask */
literal|0xffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An PC Relative 24-bit relocation used when setting PIC offset      table register. */
name|HOWTO
argument_list|(
name|R_M32R_GOTPC24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|24
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_GOTPC24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffff
argument_list|,
comment|/* src_mask */
literal|0xffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_M32R_HI16_ULO, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_M32R_GOT16_HI_ULO
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_GOT16_HI_ULO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_M32R_HI16_SLO, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_M32R_GOT16_HI_SLO
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_GOT16_HI_SLO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Like R_M32R_LO16, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_M32R_GOT16_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_GOT16_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An PC Relative relocation used when setting PIC offset table register.      Like R_M32R_HI16_ULO, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_M32R_GOTPC_HI_ULO
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_GOTPC_HI_ULO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An PC Relative relocation used when setting PIC offset table register.      Like R_M32R_HI16_SLO, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_M32R_GOTPC_HI_SLO
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_GOTPC_HI_SLO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An PC Relative relocation used when setting PIC offset table register.      Like R_M32R_LO16, but referring to the GOT table entry for      the symbol.  */
name|HOWTO
argument_list|(
name|R_M32R_GOTPC_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_GOTPC_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_M32R_GOTOFF_HI_ULO
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_GOTOFF_HI_ULO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_M32R_GOTOFF_HI_SLO
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_GOTOFF_HI_SLO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_M32R_GOTOFF_LO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32R_GOTOFF_LO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000ffff
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map BFD reloc types to M32R ELF reloc types.  */
end_comment

begin_struct
struct|struct
name|m32r_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_val
decl_stmt|;
name|unsigned
name|char
name|elf_reloc_val
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|USE_M32R_OLD_RELOC
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|m32r_reloc_map
name|m32r_reloc_map_old
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_M32R_NONE
block|}
block|,
block|{
name|BFD_RELOC_16
block|,
name|R_M32R_16
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_M32R_32
block|}
block|,
block|{
name|BFD_RELOC_M32R_24
block|,
name|R_M32R_24
block|}
block|,
block|{
name|BFD_RELOC_M32R_10_PCREL
block|,
name|R_M32R_10_PCREL
block|}
block|,
block|{
name|BFD_RELOC_M32R_18_PCREL
block|,
name|R_M32R_18_PCREL
block|}
block|,
block|{
name|BFD_RELOC_M32R_26_PCREL
block|,
name|R_M32R_26_PCREL
block|}
block|,
block|{
name|BFD_RELOC_M32R_HI16_ULO
block|,
name|R_M32R_HI16_ULO
block|}
block|,
block|{
name|BFD_RELOC_M32R_HI16_SLO
block|,
name|R_M32R_HI16_SLO
block|}
block|,
block|{
name|BFD_RELOC_M32R_LO16
block|,
name|R_M32R_LO16
block|}
block|,
block|{
name|BFD_RELOC_M32R_SDA16
block|,
name|R_M32R_SDA16
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_INHERIT
block|,
name|R_M32R_GNU_VTINHERIT
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_ENTRY
block|,
name|R_M32R_GNU_VTENTRY
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|m32r_reloc_map
name|m32r_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_M32R_NONE
block|}
block|,
block|{
name|BFD_RELOC_16
block|,
name|R_M32R_16_RELA
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_M32R_32_RELA
block|}
block|,
block|{
name|BFD_RELOC_M32R_24
block|,
name|R_M32R_24_RELA
block|}
block|,
block|{
name|BFD_RELOC_M32R_10_PCREL
block|,
name|R_M32R_10_PCREL_RELA
block|}
block|,
block|{
name|BFD_RELOC_M32R_18_PCREL
block|,
name|R_M32R_18_PCREL_RELA
block|}
block|,
block|{
name|BFD_RELOC_M32R_26_PCREL
block|,
name|R_M32R_26_PCREL_RELA
block|}
block|,
block|{
name|BFD_RELOC_M32R_HI16_ULO
block|,
name|R_M32R_HI16_ULO_RELA
block|}
block|,
block|{
name|BFD_RELOC_M32R_HI16_SLO
block|,
name|R_M32R_HI16_SLO_RELA
block|}
block|,
block|{
name|BFD_RELOC_M32R_LO16
block|,
name|R_M32R_LO16_RELA
block|}
block|,
block|{
name|BFD_RELOC_M32R_SDA16
block|,
name|R_M32R_SDA16_RELA
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_INHERIT
block|,
name|R_M32R_RELA_GNU_VTINHERIT
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_ENTRY
block|,
name|R_M32R_RELA_GNU_VTENTRY
block|}
block|,
block|{
name|BFD_RELOC_32_PCREL
block|,
name|R_M32R_REL32
block|}
block|,
block|{
name|BFD_RELOC_M32R_GOT24
block|,
name|R_M32R_GOT24
block|}
block|,
block|{
name|BFD_RELOC_M32R_26_PLTREL
block|,
name|R_M32R_26_PLTREL
block|}
block|,
block|{
name|BFD_RELOC_M32R_COPY
block|,
name|R_M32R_COPY
block|}
block|,
block|{
name|BFD_RELOC_M32R_GLOB_DAT
block|,
name|R_M32R_GLOB_DAT
block|}
block|,
block|{
name|BFD_RELOC_M32R_JMP_SLOT
block|,
name|R_M32R_JMP_SLOT
block|}
block|,
block|{
name|BFD_RELOC_M32R_RELATIVE
block|,
name|R_M32R_RELATIVE
block|}
block|,
block|{
name|BFD_RELOC_M32R_GOTOFF
block|,
name|R_M32R_GOTOFF
block|}
block|,
block|{
name|BFD_RELOC_M32R_GOTPC24
block|,
name|R_M32R_GOTPC24
block|}
block|,
block|{
name|BFD_RELOC_M32R_GOT16_HI_ULO
block|,
name|R_M32R_GOT16_HI_ULO
block|}
block|,
block|{
name|BFD_RELOC_M32R_GOT16_HI_SLO
block|,
name|R_M32R_GOT16_HI_SLO
block|}
block|,
block|{
name|BFD_RELOC_M32R_GOT16_LO
block|,
name|R_M32R_GOT16_LO
block|}
block|,
block|{
name|BFD_RELOC_M32R_GOTPC_HI_ULO
block|,
name|R_M32R_GOTPC_HI_ULO
block|}
block|,
block|{
name|BFD_RELOC_M32R_GOTPC_HI_SLO
block|,
name|R_M32R_GOTPC_HI_SLO
block|}
block|,
block|{
name|BFD_RELOC_M32R_GOTPC_LO
block|,
name|R_M32R_GOTPC_LO
block|}
block|,
block|{
name|BFD_RELOC_M32R_GOTOFF_HI_ULO
block|,
name|R_M32R_GOTOFF_HI_ULO
block|}
block|,
block|{
name|BFD_RELOC_M32R_GOTOFF_HI_SLO
block|,
name|R_M32R_GOTOFF_HI_SLO
block|}
block|,
block|{
name|BFD_RELOC_M32R_GOTOFF_LO
block|,
name|R_M32R_GOTOFF_LO
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|bfd_elf32_bfd_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_M32R_OLD_RELOC
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|m32r_reloc_map_old
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|m32r_reloc_map
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|m32r_reloc_map_old
index|[
name|i
index|]
operator|.
name|bfd_reloc_val
operator|==
name|code
condition|)
return|return
operator|&
name|m32r_elf_howto_table
index|[
name|m32r_reloc_map_old
index|[
name|i
index|]
operator|.
name|elf_reloc_val
index|]
return|;
else|#
directive|else
comment|/* ! USE_M32R_OLD_RELOC */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|m32r_reloc_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|m32r_reloc_map
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|m32r_reloc_map
index|[
name|i
index|]
operator|.
name|bfd_reloc_val
operator|==
name|code
condition|)
return|return
operator|&
name|m32r_elf_howto_table
index|[
name|m32r_reloc_map
index|[
name|i
index|]
operator|.
name|elf_reloc_val
index|]
return|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set the howto pointer for an M32R ELF reloc.  */
end_comment

begin_function
specifier|static
name|void
name|m32r_info_to_howto_rel
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|cache_ptr
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|dst
parameter_list|)
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
operator|<=
operator|(
name|unsigned
name|int
operator|)
name|R_M32R_GNU_VTENTRY
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|m32r_elf_howto_table
index|[
name|r_type
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|m32r_info_to_howto
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|cache_ptr
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|dst
parameter_list|)
block|{
name|BFD_ASSERT
argument_list|(
operator|(
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|unsigned
name|int
operator|)
name|R_M32R_NONE
operator|)
operator|||
operator|(
operator|(
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
operator|>
operator|(
name|unsigned
name|int
operator|)
name|R_M32R_GNU_VTENTRY
operator|)
operator|&&
operator|(
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_M32R_max
operator|)
operator|)
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|m32r_elf_howto_table
index|[
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
index|]
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a BFD section, try to locate the corresponding ELF section    index.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|_bfd_m32r_elf_section_from_bfd_section
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
literal|".scommon"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|retval
operator|=
name|SHN_M32R_SCOMMON
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* M32R ELF uses two common sections.  One is the usual one, and the other    is for small objects.  All the small objects are kept together, and then    referenced via one register, which yields faster assembler code.  It is    up to the compiler to emit an instruction to load the register with    _SDA_BASE.  This is what we use for the small common section.  This    approach is copied from elf32-mips.c.  */
end_comment

begin_decl_stmt
specifier|static
name|asection
name|m32r_elf_scom_section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
name|m32r_elf_scom_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|m32r_elf_scom_symbol_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle the special M32R section numbers that a symbol may use.  */
end_comment

begin_function
specifier|static
name|void
name|_bfd_m32r_elf_symbol_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
name|asym
parameter_list|)
block|{
name|elf_symbol_type
modifier|*
name|elfsym
init|=
operator|(
name|elf_symbol_type
operator|*
operator|)
name|asym
decl_stmt|;
switch|switch
condition|(
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_shndx
condition|)
block|{
case|case
name|SHN_M32R_SCOMMON
case|:
if|if
condition|(
name|m32r_elf_scom_section
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* Initialize the small common section.  */
name|m32r_elf_scom_section
operator|.
name|name
operator|=
literal|".scommon"
expr_stmt|;
name|m32r_elf_scom_section
operator|.
name|flags
operator|=
name|SEC_IS_COMMON
expr_stmt|;
name|m32r_elf_scom_section
operator|.
name|output_section
operator|=
operator|&
name|m32r_elf_scom_section
expr_stmt|;
name|m32r_elf_scom_section
operator|.
name|symbol
operator|=
operator|&
name|m32r_elf_scom_symbol
expr_stmt|;
name|m32r_elf_scom_section
operator|.
name|symbol_ptr_ptr
operator|=
operator|&
name|m32r_elf_scom_symbol_ptr
expr_stmt|;
name|m32r_elf_scom_symbol
operator|.
name|name
operator|=
literal|".scommon"
expr_stmt|;
name|m32r_elf_scom_symbol
operator|.
name|flags
operator|=
name|BSF_SECTION_SYM
expr_stmt|;
name|m32r_elf_scom_symbol
operator|.
name|section
operator|=
operator|&
name|m32r_elf_scom_section
expr_stmt|;
name|m32r_elf_scom_symbol_ptr
operator|=
operator|&
name|m32r_elf_scom_symbol
expr_stmt|;
block|}
name|asym
operator|->
name|section
operator|=
operator|&
name|m32r_elf_scom_section
expr_stmt|;
name|asym
operator|->
name|value
operator|=
name|elfsym
operator|->
name|internal_elf_sym
operator|.
name|st_size
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Hook called by the linker routine which adds symbols from an object    file.  We must handle the special M32R section numbers here.    We also keep watching for whether we need to create the sdata special    linker sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m32r_elf_add_symbol_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|namep
parameter_list|,
name|flagword
modifier|*
name|flagsp
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
modifier|*
name|secp
parameter_list|,
name|bfd_vma
modifier|*
name|valp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
operator|&&
operator|(
operator|*
name|namep
operator|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
operator|(
operator|*
name|namep
operator|)
index|[
literal|1
index|]
operator|==
literal|'S'
operator|&&
name|strcmp
argument_list|(
operator|*
name|namep
argument_list|,
literal|"_SDA_BASE_"
argument_list|)
operator|==
literal|0
operator|&&
name|is_elf_hash_table
argument_list|(
name|info
operator|->
name|hash
argument_list|)
condition|)
block|{
comment|/* This is simpler than using _bfd_elf_create_linker_section 	 (our needs are simpler than ppc's needs).  Also 	 _bfd_elf_create_linker_section currently has a bug where if a .sdata 	 section already exists a new one is created that follows it which 	 screws of _SDA_BASE_ address calcs because output_offset != 0.  */
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
decl_stmt|;
name|asection
modifier|*
name|s
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".sdata"
argument_list|)
decl_stmt|;
comment|/* The following code was cobbled from elf32-ppc.c and elflink.c.  */
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
init|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
decl_stmt|;
name|s
operator|=
name|bfd_make_section_anyway_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".sdata"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|bh
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
literal|"_SDA_BASE_"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bh
operator|==
name|NULL
operator|||
name|bh
operator|->
name|type
operator|==
name|bfd_link_hash_undefined
operator|)
operator|&&
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"_SDA_BASE_"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|32768
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
block|}
switch|switch
condition|(
name|sym
operator|->
name|st_shndx
condition|)
block|{
case|case
name|SHN_M32R_SCOMMON
case|:
operator|*
name|secp
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
literal|".scommon"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|secp
operator|)
operator|->
name|flags
operator||=
name|SEC_IS_COMMON
expr_stmt|;
operator|*
name|valp
operator|=
name|sym
operator|->
name|st_size
expr_stmt|;
break|break;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* We have to figure out the SDA_BASE value, so that we can adjust the    symbol value correctly.  We look up the symbol _SDA_BASE_ in the output    BFD.  If we can't find it, we're stuck.  We cache it in the ELF    target data.  We don't need to adjust the symbol value for an    external symbol if we are producing relocatable output.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|m32r_elf_final_sda_base
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|error_message
parameter_list|,
name|bfd_vma
modifier|*
name|psb
parameter_list|)
block|{
if|if
condition|(
name|elf_gp
argument_list|(
name|output_bfd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
literal|"_SDA_BASE_"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
condition|)
name|elf_gp
argument_list|(
name|output_bfd
argument_list|)
operator|=
operator|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
else|else
block|{
comment|/* Only get the error once.  */
operator|*
name|psb
operator|=
name|elf_gp
argument_list|(
name|output_bfd
argument_list|)
operator|=
literal|4
expr_stmt|;
operator|*
name|error_message
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|_
argument_list|(
literal|"SDA relocation when _SDA_BASE_ not defined"
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_dangerous
return|;
block|}
block|}
operator|*
name|psb
operator|=
name|elf_gp
argument_list|(
name|output_bfd
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return size of a PLT entry.  */
end_comment

begin_define
define|#
directive|define
name|elf_m32r_sizeof_plt
parameter_list|(
name|info
parameter_list|)
value|PLT_ENTRY_SIZE
end_define

begin_comment
comment|/* The m32r linker needs to keep track of the number of relocs that it    decides to copy in check_relocs for each symbol.  This is so that    it can discard PC relative relocs if it doesn't need them when    linking with -Bsymbolic.  We store the information in a field    extending the regular ELF linker hash table.  */
end_comment

begin_comment
comment|/* This structure keeps track of the number of PC relative relocs we    have copied for a given symbol.  */
end_comment

begin_struct
struct|struct
name|elf_m32r_pcrel_relocs_copied
block|{
comment|/* Next section.  */
name|struct
name|elf_m32r_pcrel_relocs_copied
modifier|*
name|next
decl_stmt|;
comment|/* A section in dynobj.  */
name|asection
modifier|*
name|section
decl_stmt|;
comment|/* Number of relocs copied in this section.  */
name|bfd_size_type
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The sh linker needs to keep track of the number of relocs that it    decides to copy as dynamic relocs in check_relocs for each symbol.    This is so that it can later discard them if they are found to be    unnecessary.  We store the information in a field extending the    regular ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|elf_m32r_dyn_relocs
block|{
name|struct
name|elf_m32r_dyn_relocs
modifier|*
name|next
decl_stmt|;
comment|/* The input section of the reloc.  */
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* Total number of relocs copied for the input section.  */
name|bfd_size_type
name|count
decl_stmt|;
comment|/* Number of pc-relative relocs copied for the input section.  */
name|bfd_size_type
name|pc_count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* m32r ELF linker hash entry.  */
end_comment

begin_struct
struct|struct
name|elf_m32r_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|root
decl_stmt|;
comment|/* Track dynamic relocs copied for this symbol.  */
name|struct
name|elf_m32r_dyn_relocs
modifier|*
name|dyn_relocs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* m32r ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|elf_m32r_link_hash_table
block|{
name|struct
name|elf_link_hash_table
name|root
decl_stmt|;
comment|/* Short-cuts to get to dynamic linker sections.  */
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|sgotplt
decl_stmt|;
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|srelplt
decl_stmt|;
name|asection
modifier|*
name|sdynbss
decl_stmt|;
name|asection
modifier|*
name|srelbss
decl_stmt|;
comment|/* Small local sym to section mapping cache.  */
name|struct
name|sym_sec_cache
name|sym_sec
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Traverse an m32r ELF linker hash table.  */
end_comment

begin_define
define|#
directive|define
name|m32r_elf_link_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
define|\
value|(elf_link_hash_traverse						\    (&(table)->root,							\     (bfd_boolean (*) (struct elf_link_hash_entry *, void *)) (func),	\     (info)))
end_define

begin_comment
comment|/* Get the m32r ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|m32r_elf_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct elf_m32r_link_hash_table *) ((p)->hash))
end_define

begin_comment
comment|/* Create an entry in an m32r ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|m32r_elf_link_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|struct
name|elf_m32r_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|elf_m32r_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_m32r_link_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elf_m32r_link_hash_entry
operator|*
operator|)
name|_bfd_elf_link_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_m32r_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf_m32r_link_hash_entry
operator|*
operator|)
name|ret
expr_stmt|;
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Create an m32r ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|m32r_elf_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|elf_m32r_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf_m32r_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|m32r_elf_link_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_m32r_link_hash_entry
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|->
name|sgot
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|sgotplt
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|srelgot
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|splt
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|srelplt
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|sdynbss
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|srelbss
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|sym_sec
operator|.
name|abfd
operator|=
name|NULL
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Create .got, .gotplt, and .rela.got sections in DYNOBJ, and set up    shortcuts to them in our hash table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|create_got_section
parameter_list|(
name|bfd
modifier|*
name|dynobj
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf_m32r_link_hash_table
modifier|*
name|htab
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|htab
operator|=
name|m32r_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sgotplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|sgot
operator|||
operator|!
name|htab
operator|->
name|sgotplt
condition|)
name|abort
argument_list|()
expr_stmt|;
name|htab
operator|->
name|srelgot
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|srelgot
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|srelgot
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create dynamic sections when linking against a dynamic object.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m32r_elf_create_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf_m32r_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|flagword
name|flags
decl_stmt|,
name|pltflags
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|int
name|ptralign
init|=
literal|2
decl_stmt|;
comment|/* 32bit */
name|htab
operator|=
name|m32r_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* We need to create .plt, .rel[a].plt, .got, .got.plt, .dynbss, and      .rel[a].bss sections.  */
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|pltflags
operator|=
name|flags
expr_stmt|;
name|pltflags
operator||=
name|SEC_CODE
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|plt_not_loaded
condition|)
name|pltflags
operator|&=
operator|~
operator|(
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator|)
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|plt_readonly
condition|)
name|pltflags
operator||=
name|SEC_READONLY
expr_stmt|;
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".plt"
argument_list|,
name|pltflags
argument_list|)
expr_stmt|;
name|htab
operator|->
name|splt
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|bed
operator|->
name|plt_alignment
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bed
operator|->
name|want_plt_sym
condition|)
block|{
comment|/* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the          .plt section.  */
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
init|=
name|NULL
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"_PROCEDURE_LINKAGE_TABLE_"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|s
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
name|htab
operator|->
name|root
operator|.
name|hplt
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
name|bed
operator|->
name|default_use_rela_p
condition|?
literal|".rela.plt"
else|:
literal|".rel.plt"
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
name|htab
operator|->
name|srelplt
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|ptralign
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|htab
operator|->
name|sgot
operator|==
name|NULL
operator|&&
operator|!
name|create_got_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|{
specifier|const
name|char
modifier|*
name|secname
decl_stmt|;
name|char
modifier|*
name|relname
decl_stmt|;
name|flagword
name|secflags
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|secflags
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|secflags
operator|&
operator|(
name|SEC_DATA
operator||
name|SEC_LINKER_CREATED
operator|)
operator|)
operator|||
operator|(
operator|(
name|secflags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
name|SEC_HAS_CONTENTS
operator|)
condition|)
continue|continue;
name|secname
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|relname
operator|=
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|strlen
argument_list|(
name|secname
argument_list|)
operator|+
literal|6
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|relname
argument_list|,
literal|".rela"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|relname
argument_list|,
name|secname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|secname
argument_list|)
condition|)
continue|continue;
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
name|relname
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|ptralign
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|bed
operator|->
name|want_dynbss
condition|)
block|{
comment|/* The .dynbss section is a place to put symbols which are defined          by dynamic objects, are referenced by regular objects, and are          not functions.  We must allocate space for them in the process          image and use a R_*_COPY reloc to tell the dynamic linker to          initialize them at run time.  The linker script puts the .dynbss          section into the .bss section of the final image.  */
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".dynbss"
argument_list|,
name|SEC_ALLOC
operator||
name|SEC_LINKER_CREATED
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sdynbss
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* The .rel[a].bss section holds copy relocs.  This section is not          normally needed.  We need to create it here, though, so that the          linker will map it to an output section.  We can't just create it          only if we need it, because we will not know whether we need it          until we have seen all the input files, and the first time the          main linker code calls BFD after examining all the input files          (size_dynamic_sections) the input sections have already been          mapped to the output sections.  If the section turns out not to          be needed, we can discard it later.  We will never need this          section when generating a shared object, since they do not use          copy relocs.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
operator|(
name|bed
operator|->
name|default_use_rela_p
condition|?
literal|".rela.bss"
else|:
literal|".rel.bss"
operator|)
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
name|htab
operator|->
name|srelbss
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|ptralign
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Copy the extra info we tack onto an elf_link_hash_entry.  */
end_comment

begin_function
specifier|static
name|void
name|m32r_elf_copy_indirect_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|dir
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|ind
parameter_list|)
block|{
name|struct
name|elf_m32r_link_hash_entry
modifier|*
name|edir
decl_stmt|;
name|struct
name|elf_m32r_link_hash_entry
modifier|*
name|eind
decl_stmt|;
name|edir
operator|=
operator|(
expr|struct
name|elf_m32r_link_hash_entry
operator|*
operator|)
name|dir
expr_stmt|;
name|eind
operator|=
operator|(
expr|struct
name|elf_m32r_link_hash_entry
operator|*
operator|)
name|ind
expr_stmt|;
if|if
condition|(
name|eind
operator|->
name|dyn_relocs
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|edir
operator|->
name|dyn_relocs
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_m32r_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|elf_m32r_dyn_relocs
modifier|*
name|p
decl_stmt|;
comment|/* Add reloc counts against the indirect sym to the direct sym              list.  Merge any entries against the same section.  */
for|for
control|(
name|pp
operator|=
operator|&
name|eind
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|struct
name|elf_m32r_dyn_relocs
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|edir
operator|->
name|dyn_relocs
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
if|if
condition|(
name|q
operator|->
name|sec
operator|==
name|p
operator|->
name|sec
condition|)
block|{
name|q
operator|->
name|pc_count
operator|+=
name|p
operator|->
name|pc_count
expr_stmt|;
name|q
operator|->
name|count
operator|+=
name|p
operator|->
name|count
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|edir
operator|->
name|dyn_relocs
expr_stmt|;
block|}
name|edir
operator|->
name|dyn_relocs
operator|=
name|eind
operator|->
name|dyn_relocs
expr_stmt|;
name|eind
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
block|}
name|_bfd_elf_link_hash_copy_indirect
argument_list|(
name|info
argument_list|,
name|dir
argument_list|,
name|ind
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m32r_elf_adjust_dynamic_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|)
block|{
name|struct
name|elf_m32r_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|elf_m32r_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf_m32r_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|power_of_two
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PIC
name|printf
argument_list|(
literal|"m32r_elf_adjust_dynamic_symbol()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* Make sure we know what is going on here.  */
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|needs_plt
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
operator|||
operator|(
name|h
operator|->
name|def_dynamic
operator|&&
name|h
operator|->
name|ref_regular
operator|&&
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If this is a function, put it in the procedure linkage table.  We      will fill in the contents of the procedure linkage table later,      when we know the address of the .got section.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|||
name|h
operator|->
name|needs_plt
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|h
operator|->
name|def_dynamic
operator|&&
operator|!
name|h
operator|->
name|ref_dynamic
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefined
condition|)
block|{
comment|/* This case can occur if we saw a PLT reloc in an input              file, but the symbol was never referred to by a dynamic              object.  In such a case, we don't actually need to build              a procedure linkage table, and we can just do a PCREL              reloc instead.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|needs_plt
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
else|else
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
comment|/* If we are creating a shared library, we must presume that the      only references to the symbol are via the global offset table.      For such cases we need not do anything here; the relocations will      be handled correctly by relocate_section.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
return|return
name|TRUE
return|;
comment|/* If there are no references to this symbol that do not use the      GOT, we don't need to generate a copy reloc.  */
if|if
condition|(
operator|!
name|h
operator|->
name|non_got_ref
condition|)
return|return
name|TRUE
return|;
comment|/* If -z nocopyreloc was given, we won't generate them either.  */
if|if
condition|(
name|info
operator|->
name|nocopyreloc
condition|)
block|{
name|h
operator|->
name|non_got_ref
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|eh
operator|=
operator|(
expr|struct
name|elf_m32r_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|s
operator|=
name|p
operator|->
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
operator|(
name|SEC_READONLY
operator||
name|SEC_HAS_CONTENTS
operator|)
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* If we didn't find any dynamic relocs in sections which needs the      copy reloc, then we'll be keeping the dynamic relocs and avoiding      the copy reloc.  */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|h
operator|->
name|non_got_ref
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|h
operator|->
name|size
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"dynamic variable `%s' is zero size"
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* We must allocate the symbol in our .dynbss section, which will      become part of the .bss section of the executable.  There will be      an entry for this symbol in the .dynsym section.  The dynamic      object will contain position independent code, so all references      from the dynamic object to this symbol will go through the global      offset table.  The dynamic linker will use the .dynsym entry to      determine the address it must put in the global offset table, so      both the dynamic object and the regular object will refer to the      same memory location for the variable.  */
name|htab
operator|=
name|m32r_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|s
operator|=
name|htab
operator|->
name|sdynbss
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* We must generate a R_M32R_COPY reloc to tell the dynamic linker      to copy the initial value out of the dynamic object and into the      runtime process image.  We need to remember the offset into the      .rela.bss section we are going to use.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|srel
decl_stmt|;
name|srel
operator|=
name|htab
operator|->
name|srelbss
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|srel
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|h
operator|->
name|needs_copy
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We need to figure out the alignment required for this symbol.  I      have no idea how ELF linkers handle this.  */
name|power_of_two
operator|=
name|bfd_log2
argument_list|(
name|h
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
literal|3
condition|)
name|power_of_two
operator|=
literal|3
expr_stmt|;
comment|/* Apply the required alignment.  */
name|s
operator|->
name|size
operator|=
name|BFD_ALIGN
argument_list|(
name|s
operator|->
name|size
argument_list|,
call|(
name|bfd_size_type
call|)
argument_list|(
literal|1
operator|<<
name|power_of_two
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
name|bfd_get_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
name|power_of_two
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Define the symbol as being at this point in the section.  */
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|size
expr_stmt|;
comment|/* Increment the section size to make room for the symbol.  */
name|s
operator|->
name|size
operator|+=
name|h
operator|->
name|size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Allocate space in .plt, .got and associated reloc sections for    dynamic relocs.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|allocate_dynrelocs
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_m32r_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|elf_m32r_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf_m32r_dyn_relocs
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
comment|/* When warning symbols are created, they **replace** the "real"        entry in the hash table, thus we never get to see the real        symbol in a hash traversal.  So look at it now.  */
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|info
operator|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
expr_stmt|;
name|htab
operator|=
name|m32r_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf_m32r_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|root
operator|.
name|dynamic_sections_created
operator|&&
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol.          Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
literal|1
argument_list|,
name|info
operator|->
name|shared
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|asection
modifier|*
name|s
init|=
name|htab
operator|->
name|splt
decl_stmt|;
comment|/* If this is the first .plt entry, make room for the special              first entry.  */
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
name|s
operator|->
name|size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|size
expr_stmt|;
comment|/* If this symbol is not defined in a regular file, and we are              not generating a shared library, then set the symbol to this              location in the .plt.  This is required to make function              pointers compare as equal between the normal executable and              the shared library.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
block|}
comment|/* Make room for this entry.  */
name|s
operator|->
name|size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* We also need to make an entry in the .got.plt section, which              will be placed in the .got section by the linker script.  */
name|htab
operator|->
name|sgotplt
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
comment|/* We also need to make an entry in the .rel.plt section.  */
name|htab
operator|->
name|srelplt
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|needs_plt
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|needs_plt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_boolean
name|dyn
decl_stmt|;
comment|/* Make sure this symbol is output as a dynamic symbol.          Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|s
operator|=
name|htab
operator|->
name|sgot
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|offset
operator|=
name|s
operator|->
name|size
expr_stmt|;
name|s
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
name|dyn
operator|=
name|htab
operator|->
name|root
operator|.
name|dynamic_sections_created
expr_stmt|;
if|if
condition|(
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
operator|->
name|shared
argument_list|,
name|h
argument_list|)
condition|)
name|htab
operator|->
name|srelgot
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
name|h
operator|->
name|got
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|dyn_relocs
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
comment|/* In the shared -Bsymbolic case, discard space allocated for      dynamic pc-relative relocs against symbols which turn out to be      defined in regular objects.  For the normal shared case, discard      space for pc-relative relocs that have become local due to symbol      visibility changes.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|def_regular
operator|&&
operator|(
name|h
operator|->
name|forced_local
operator|||
name|info
operator|->
name|symbolic
operator|)
condition|)
block|{
name|struct
name|elf_m32r_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|p
operator|->
name|count
operator|-=
name|p
operator|->
name|pc_count
expr_stmt|;
name|p
operator|->
name|pc_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
else|else
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Also discard relocs on undefined weak syms with non-default 	 visibility.  */
if|if
condition|(
name|eh
operator|->
name|dyn_relocs
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
if|if
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_DEFAULT
condition|)
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
comment|/* Make sure undefined weak symbols are output as a dynamic 	     symbol in PIEs.  */
elseif|else
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* For the non-shared case, discard space for relocs against          symbols which turn out to need copy relocs or are not          dynamic.  */
if|if
condition|(
operator|!
name|h
operator|->
name|non_got_ref
operator|&&
operator|(
operator|(
name|h
operator|->
name|def_dynamic
operator|&&
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|||
operator|(
name|htab
operator|->
name|root
operator|.
name|dynamic_sections_created
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol.              Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* If that succeeded, we know we'll be keeping all the              relocs.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
goto|goto
name|keep
goto|;
block|}
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
name|keep
label|:
empty_stmt|;
block|}
comment|/* Finally, allocate space.  */
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|sreloc
init|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|->
name|sreloc
decl_stmt|;
name|sreloc
operator|->
name|size
operator|+=
name|p
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Find any dynamic relocs that apply to read-only sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|readonly_dynrelocs
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|inf
parameter_list|)
block|{
name|struct
name|elf_m32r_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf_m32r_dyn_relocs
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf_m32r_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|s
init|=
name|p
operator|->
name|sec
operator|->
name|output_section
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
decl_stmt|;
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
comment|/* Not an error, just cut short the traversal.  */
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m32r_elf_size_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf_m32r_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_boolean
name|relocs
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PIC
name|printf
argument_list|(
literal|"m32r_elf_size_dynamic_sections()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|htab
operator|=
name|m32r_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|root
operator|.
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|root
operator|.
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
block|}
comment|/* Set up .got offsets for local syms, and space for local dynamic      relocs.  */
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|bfd_signed_vma
modifier|*
name|local_got
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|end_local_got
decl_stmt|;
name|bfd_size_type
name|locsymcount
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|srel
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
for|for
control|(
name|s
operator|=
name|ibfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|struct
name|elf_m32r_dyn_relocs
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|(
operator|(
expr|struct
name|elf_m32r_dyn_relocs
operator|*
operator|)
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
operator|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|&&
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|sec
operator|->
name|output_section
argument_list|)
condition|)
block|{
comment|/* Input section has been discarded, either because                      it is a copy of a linkonce section or due to                      linker script /DISCARD/, so we'll be discarding                      the relocs too.  */
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|count
operator|!=
literal|0
condition|)
block|{
name|srel
operator|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|->
name|sreloc
expr_stmt|;
name|srel
operator|->
name|size
operator|+=
name|p
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|sec
operator|->
name|output_section
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
block|}
block|}
name|local_got
operator|=
name|elf_local_got_refcounts
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_got
condition|)
continue|continue;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|end_local_got
operator|=
name|local_got
operator|+
name|locsymcount
expr_stmt|;
name|s
operator|=
name|htab
operator|->
name|sgot
expr_stmt|;
name|srel
operator|=
name|htab
operator|->
name|srelgot
expr_stmt|;
for|for
control|(
init|;
name|local_got
operator|<
name|end_local_got
condition|;
operator|++
name|local_got
control|)
block|{
if|if
condition|(
operator|*
name|local_got
operator|>
literal|0
condition|)
block|{
operator|*
name|local_got
operator|=
name|s
operator|->
name|size
expr_stmt|;
name|s
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|srel
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|local_got
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* Allocate global sym .plt and .got entries, and space for global      sym dynamic relocs.  */
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|root
argument_list|,
name|allocate_dynrelocs
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* We now have determined the sizes of the various dynamic sections.      Allocate memory for them.  */
name|relocs
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|s
operator|==
name|htab
operator|->
name|splt
operator|||
name|s
operator|==
name|htab
operator|->
name|sgot
operator|||
name|s
operator|==
name|htab
operator|->
name|sgotplt
operator|||
name|s
operator|==
name|htab
operator|->
name|sdynbss
condition|)
block|{
comment|/* Strip this section if we don't need it; see the              comment below.  */
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|size
operator|!=
literal|0
operator|&&
name|s
operator|!=
name|htab
operator|->
name|srelplt
condition|)
name|relocs
operator|=
name|TRUE
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need              to copy relocs into the output file.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
block|{
comment|/* If we don't need this section, strip it from the              output file.  This is mostly to handle .rela.bss and              .rela.plt.  We must create both sections in              create_dynamic_sections, because they must be created              before the linker maps input sections to output              sections.  The linker does that before              adjust_dynamic_symbol is called, and it is that              function which decides whether anything needs to go              into these sections.  */
name|s
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Allocate memory for the section contents.  We use bfd_zalloc          here in case unused entries are not reclaimed before the          section's contents are written out.  This should not happen,          but this way if it does, we get a R_M32R_NONE reloc instead          of garbage.  */
name|s
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|root
operator|.
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in m32r_elf_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
define|#
directive|define
name|add_dynamic_entry
parameter_list|(
name|TAG
parameter_list|,
name|VAL
parameter_list|)
define|\
value|_bfd_elf_add_dynamic_entry (info, TAG, VAL)
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|splt
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTREL
argument_list|,
name|DT_RELA
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|relocs
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELA
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELAENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* If any dynamic relocs apply to a read-only section,              then we need a DT_TEXTREL entry.  */
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|==
literal|0
condition|)
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|root
argument_list|,
name|readonly_dynrelocs
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
block|}
undef|#
directive|undef
name|add_dynamic_entry
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Relocate an M32R/D ELF section.    There is some attempt to make this function usable for many architectures,    both for RELA and REL type relocs, if only to serve as a learning tool.     The RELOCATE_SECTION function is called by the new ELF backend linker    to handle the relocations for a section.     The relocs are always passed as Rela structures; if the section    actually uses Rel structures, the r_addend field will always be    zero.     This function is responsible for adjust the section contents as    necessary, and (if using Rela relocs and generating a    relocatable output file) adjusting the reloc addend as    necessary.     This function does not have to worry about setting the reloc    address or the reloc symbol index.     LOCAL_SYMS is a pointer to the swapped in local symbols.     LOCAL_SECTIONS is an array giving the section in the input file    corresponding to the st_shndx field of each local symbol.     The global hash table entry for the global symbols can be found    via elf_sym_hashes (input_bfd).     When generating relocatable output, this function must handle    STB_LOCAL/STT_SECTION symbols specially.  The output symbol is    going to be the section symbol corresponding to the output    section, which means that the addend must be adjusted    accordingly.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m32r_elf_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
init|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
init|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
comment|/* Assume success.  */
name|bfd_boolean
name|ret
init|=
name|TRUE
decl_stmt|;
name|struct
name|elf_m32r_link_hash_table
modifier|*
name|htab
init|=
name|m32r_elf_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|,
modifier|*
name|splt
decl_stmt|,
modifier|*
name|sreloc
decl_stmt|;
name|bfd_vma
name|high_address
init|=
name|bfd_get_section_limit
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
decl_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|root
operator|.
name|dynobj
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|htab
operator|->
name|sgot
expr_stmt|;
name|splt
operator|=
name|htab
operator|->
name|splt
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* We can't modify r_addend here as elf_link_input_bfd has an assert to          ensure it's zero (we use REL relocs, not RELA).  Therefore this          should be assigning zero to `addend', but for clarity we use          `r_addend'.  */
name|bfd_vma
name|addend
init|=
name|rel
operator|->
name|r_addend
decl_stmt|;
name|bfd_vma
name|offset
init|=
name|rel
operator|->
name|r_offset
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|errmsg
init|=
name|NULL
decl_stmt|;
name|bfd_boolean
name|use_rel
init|=
name|FALSE
decl_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|<
literal|0
operator|||
name|r_type
operator|>=
operator|(
name|int
operator|)
name|R_M32R_max
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: unknown relocation type %d"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
operator|(
name|int
operator|)
name|r_type
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|ret
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_M32R_GNU_VTENTRY
operator|||
name|r_type
operator|==
name|R_M32R_GNU_VTINHERIT
operator|||
name|r_type
operator|==
name|R_M32R_NONE
operator|||
name|r_type
operator|==
name|R_M32R_RELA_GNU_VTENTRY
operator|||
name|r_type
operator|==
name|R_M32R_RELA_GNU_VTINHERIT
condition|)
continue|continue;
if|if
condition|(
name|r_type
operator|<=
name|R_M32R_GNU_VTENTRY
condition|)
name|use_rel
operator|=
name|TRUE
expr_stmt|;
name|howto
operator|=
name|m32r_elf_howto_table
operator|+
name|r_type
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
operator|&&
name|use_rel
condition|)
block|{
comment|/* This is a relocatable link.  We don't have to change 	     anything, unless the reloc is against a section symbol, 	     in which case we have to adjust according to where the 	     section symbol winds up in the output section.  */
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
comment|/* External symbol.  */
continue|continue;
comment|/* Local symbol.  */
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sym_name
operator|=
literal|"<local symbol>"
expr_stmt|;
comment|/* STT_SECTION: symbol is associated with a section.  */
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_SECTION
condition|)
comment|/* Symbol isn't associated with a section.  Nothing to do.  */
continue|continue;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|addend
operator|+=
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
expr_stmt|;
comment|/* If partial_inplace, we need to store any additional addend 	     back in the section.  */
if|if
condition|(
operator|!
name|howto
operator|->
name|partial_inplace
condition|)
continue|continue;
comment|/* ??? Here is a nice place to call a special_function 	     like handler.  */
if|if
condition|(
name|r_type
operator|!=
name|R_M32R_HI16_SLO
operator|&&
name|r_type
operator|!=
name|R_M32R_HI16_ULO
condition|)
name|r
operator|=
name|_bfd_relocate_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|addend
argument_list|,
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
else|else
block|{
name|Elf_Internal_Rela
modifier|*
name|lorel
decl_stmt|;
comment|/* We allow an arbitrary number of HI16 relocs before the 		 LO16 reloc.  This permits gcc to emit the HI and LO relocs 		 itself.  */
for|for
control|(
name|lorel
operator|=
name|rel
operator|+
literal|1
init|;
operator|(
name|lorel
operator|<
name|relend
operator|&&
operator|(
name|ELF32_R_TYPE
argument_list|(
name|lorel
operator|->
name|r_info
argument_list|)
operator|==
name|R_M32R_HI16_SLO
operator|||
name|ELF32_R_TYPE
argument_list|(
name|lorel
operator|->
name|r_info
argument_list|)
operator|==
name|R_M32R_HI16_ULO
operator|)
operator|)
condition|;
name|lorel
operator|++
control|)
continue|continue;
if|if
condition|(
name|lorel
operator|<
name|relend
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|lorel
operator|->
name|r_info
argument_list|)
operator|==
name|R_M32R_LO16
condition|)
block|{
name|m32r_elf_relocate_hi16
argument_list|(
name|input_bfd
argument_list|,
name|r_type
argument_list|,
name|rel
argument_list|,
name|lorel
argument_list|,
name|contents
argument_list|,
name|addend
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
block|}
else|else
name|r
operator|=
name|_bfd_relocate_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|addend
argument_list|,
name|contents
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|bfd_vma
name|relocation
decl_stmt|;
comment|/* This is a final link.  */
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* Local symbol.  */
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|sym_name
operator|=
literal|"<local symbol>"
expr_stmt|;
if|if
condition|(
operator|!
name|use_rel
condition|)
block|{
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
block|{
comment|/* This is a relocatable link.  We don't have to change                          anything, unless the reloc is against a section symbol,                          in which case we have to adjust according to where the                          section symbol winds up in the output section.  */
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
name|rel
operator|->
name|r_addend
operator|+=
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|relocation
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* External symbol.  */
if|if
condition|(
name|info
operator|->
name|relocatable
operator|&&
operator|!
name|use_rel
condition|)
continue|continue;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|sym_name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|bfd_boolean
name|dyn
decl_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|dyn
operator|=
name|htab
operator|->
name|root
operator|.
name|dynamic_sections_created
expr_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_M32R_GOTPC24
operator|||
operator|(
name|r_type
operator|==
name|R_M32R_GOTPC_HI_ULO
operator|||
name|r_type
operator|==
name|R_M32R_GOTPC_HI_SLO
operator|||
name|r_type
operator|==
name|R_M32R_GOTPC_LO
operator|)
operator|||
operator|(
name|r_type
operator|==
name|R_M32R_26_PLTREL
operator|&&
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|)
operator|||
operator|(
operator|(
name|r_type
operator|==
name|R_M32R_GOT24
operator|||
name|r_type
operator|==
name|R_M32R_GOT16_HI_ULO
operator|||
name|r_type
operator|==
name|R_M32R_GOT16_HI_SLO
operator|||
name|r_type
operator|==
name|R_M32R_GOT16_LO
operator|)
operator|&&
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
operator|->
name|shared
argument_list|,
name|h
argument_list|)
operator|&&
operator|(
operator|!
name|info
operator|->
name|shared
operator|||
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|)
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|)
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|&&
operator|(
operator|(
operator|(
name|r_type
operator|==
name|R_M32R_16_RELA
operator|||
name|r_type
operator|==
name|R_M32R_32_RELA
operator|||
name|r_type
operator|==
name|R_M32R_24_RELA
operator|||
name|r_type
operator|==
name|R_M32R_HI16_ULO_RELA
operator|||
name|r_type
operator|==
name|R_M32R_HI16_SLO_RELA
operator|||
name|r_type
operator|==
name|R_M32R_LO16_RELA
operator|)
operator|&&
operator|!
name|h
operator|->
name|forced_local
operator|)
operator|||
name|r_type
operator|==
name|R_M32R_REL32
operator|||
name|r_type
operator|==
name|R_M32R_10_PCREL_RELA
operator|||
name|r_type
operator|==
name|R_M32R_18_PCREL_RELA
operator|||
name|r_type
operator|==
name|R_M32R_26_PCREL_RELA
operator|)
operator|&&
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
comment|/* DWARF will emit R_M32R_16(24,32) relocations                                  in its sections against symbols defined                                  externally in shared libraries.  We can't do                                  anything with them here.  */
operator|||
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|->
name|def_dynamic
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* In these cases, we don't need the relocation                          value.  We check specially because in some                          obscure cases sec->output_section will be NULL.  */
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sec
operator|->
name|output_section
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|unresolved_syms_in_objects
operator|==
name|RM_IGNORE
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|offset
argument_list|,
operator|(
name|info
operator|->
name|unresolved_syms_in_objects
operator|==
name|RM_GENERATE_ERROR
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|)
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Sanity check the address.  */
if|if
condition|(
name|offset
operator|>
name|high_address
condition|)
block|{
name|r
operator|=
name|bfd_reloc_outofrange
expr_stmt|;
goto|goto
name|check_reloc
goto|;
block|}
switch|switch
condition|(
operator|(
name|int
operator|)
name|r_type
condition|)
block|{
case|case
name|R_M32R_GOTOFF
case|:
comment|/* Relocation is relative to the start of the global offset                  table (for ld24 rx, #uimm24). eg access at label+addend                   ld24 rx. #label@GOTOFF + addend                  sub  rx, r12.  */
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|relocation
operator|=
operator|-
operator|(
name|relocation
operator|-
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|=
operator|-
name|rel
operator|->
name|r_addend
expr_stmt|;
break|break;
case|case
name|R_M32R_GOTOFF_HI_ULO
case|:
case|case
name|R_M32R_GOTOFF_HI_SLO
case|:
case|case
name|R_M32R_GOTOFF_LO
case|:
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|relocation
operator|-=
name|sgot
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
operator|(
name|r_type
operator|==
name|R_M32R_GOTOFF_HI_SLO
operator|)
operator|&&
operator|(
operator|(
name|relocation
operator|+
name|rel
operator|->
name|r_addend
operator|)
operator|&
literal|0x8000
operator|)
condition|)
name|rel
operator|->
name|r_addend
operator|+=
literal|0x10000
expr_stmt|;
break|break;
case|case
name|R_M32R_GOTPC24
case|:
comment|/* .got(_GLOBAL_OFFSET_TABLE_) - pc relocation                  ld24 rx,#_GLOBAL_OFFSET_TABLE_                */
name|relocation
operator|=
name|sgot
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|R_M32R_GOTPC_HI_ULO
case|:
case|case
name|R_M32R_GOTPC_HI_SLO
case|:
case|case
name|R_M32R_GOTPC_LO
case|:
block|{
comment|/* .got(_GLOBAL_OFFSET_TABLE_) - pc relocation                    bl .+4                    seth rx,#high(_GLOBAL_OFFSET_TABLE_)                    or3 rx,rx,#low(_GLOBAL_OFFSET_TABLE_ +4)                    or                    bl .+4                    seth rx,#shigh(_GLOBAL_OFFSET_TABLE_)                    add3 rx,rx,#low(_GLOBAL_OFFSET_TABLE_ +4)                  */
name|relocation
operator|=
name|sgot
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|r_type
operator|==
name|R_M32R_GOTPC_HI_SLO
operator|)
operator|&&
operator|(
operator|(
name|relocation
operator|+
name|rel
operator|->
name|r_addend
operator|)
operator|&
literal|0x8000
operator|)
condition|)
name|rel
operator|->
name|r_addend
operator|+=
literal|0x10000
expr_stmt|;
break|break;
block|}
case|case
name|R_M32R_GOT16_HI_ULO
case|:
case|case
name|R_M32R_GOT16_HI_SLO
case|:
case|case
name|R_M32R_GOT16_LO
case|:
comment|/* Fall through.  */
case|case
name|R_M32R_GOT24
case|:
comment|/* Relocation is to the entry for this symbol in the global                  offset table.  */
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|bfd_boolean
name|dyn
decl_stmt|;
name|bfd_vma
name|off
decl_stmt|;
name|off
operator|=
name|h
operator|->
name|got
operator|.
name|offset
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|off
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dyn
operator|=
name|htab
operator|->
name|root
operator|.
name|dynamic_sections_created
expr_stmt|;
if|if
condition|(
operator|!
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
operator|->
name|shared
argument_list|,
name|h
argument_list|)
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
name|h
operator|->
name|forced_local
operator|)
operator|&&
name|h
operator|->
name|def_regular
operator|)
condition|)
block|{
comment|/* This is actually a static link, or it is a                          -Bsymbolic link and the symbol is defined                          locally, or the symbol was forced to be local                          because of a version file.  We must initialize                          this entry in the global offset table.  Since the                          offset must always be a multiple of 4, we use the                          least significant bit to record whether we have                          initialized it already.                           When doing a dynamic link, we create a .rela.got                          relocation entry to initialize the value.  This                          is done in the finish_dynamic_symbol routine.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|offset
operator||=
literal|1
expr_stmt|;
block|}
block|}
name|relocation
operator|=
name|sgot
operator|->
name|output_offset
operator|+
name|off
expr_stmt|;
block|}
else|else
block|{
name|bfd_vma
name|off
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|local_got_offsets
operator|!=
name|NULL
operator|&&
name|local_got_offsets
index|[
name|r_symndx
index|]
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|off
operator|=
name|local_got_offsets
index|[
name|r_symndx
index|]
expr_stmt|;
comment|/* The offset must always be a multiple of 4.  We use                      the least significant bit to record whether we have                      already processed this entry.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
comment|/* We need to generate a R_M32R_RELATIVE reloc                              for the dynamic linker.  */
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srelgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_M32R_RELATIVE
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
expr_stmt|;
name|loc
operator|=
name|srelgot
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|srelgot
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
operator|++
name|srelgot
operator|->
name|reloc_count
expr_stmt|;
block|}
name|local_got_offsets
index|[
name|r_symndx
index|]
operator||=
literal|1
expr_stmt|;
block|}
name|relocation
operator|=
name|sgot
operator|->
name|output_offset
operator|+
name|off
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|r_type
operator|==
name|R_M32R_GOT16_HI_SLO
operator|)
operator|&&
operator|(
operator|(
name|relocation
operator|+
name|rel
operator|->
name|r_addend
operator|)
operator|&
literal|0x8000
operator|)
condition|)
name|rel
operator|->
name|r_addend
operator|+=
literal|0x10000
expr_stmt|;
break|break;
case|case
name|R_M32R_26_PLTREL
case|:
comment|/* Relocation is to the entry for this symbol in the                  procedure linkage table.  */
comment|/* The native assembler will generate a 26_PLTREL reloc                  for a local symbol if you assemble a call from one                  section to another when using -K pic. */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|h
operator|->
name|forced_local
condition|)
break|break;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
comment|/* We didn't make a PLT entry for this symbol.  This 		   happens when statically linking PIC code, or when 		   using -Bsymbolic.  */
break|break;
name|relocation
operator|=
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
break|break;
case|case
name|R_M32R_HI16_SLO_RELA
case|:
if|if
condition|(
operator|(
name|relocation
operator|+
name|rel
operator|->
name|r_addend
operator|)
operator|&
literal|0x8000
condition|)
name|rel
operator|->
name|r_addend
operator|+=
literal|0x10000
expr_stmt|;
comment|/* Fall through.  */
case|case
name|R_M32R_16_RELA
case|:
case|case
name|R_M32R_24_RELA
case|:
case|case
name|R_M32R_32_RELA
case|:
case|case
name|R_M32R_REL32
case|:
case|case
name|R_M32R_10_PCREL_RELA
case|:
case|case
name|R_M32R_18_PCREL_RELA
case|:
case|case
name|R_M32R_26_PCREL_RELA
case|:
case|case
name|R_M32R_HI16_ULO_RELA
case|:
case|case
name|R_M32R_LO16_RELA
case|:
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
name|r_symndx
operator|!=
literal|0
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|r_type
operator|!=
name|R_M32R_10_PCREL_RELA
operator|&&
name|r_type
operator|!=
name|R_M32R_18_PCREL_RELA
operator|&&
name|r_type
operator|!=
name|R_M32R_26_PCREL_RELA
operator|&&
name|r_type
operator|!=
name|R_M32R_REL32
operator|)
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
operator|)
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_boolean
name|skip
decl_stmt|,
name|relocate
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
comment|/* When generating a shared object, these relocations                      are copied into the output file to be resolved at run                      time.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|elf_elfheader
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|BFD_ASSERT
argument_list|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sreloc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|skip
operator|=
name|FALSE
expr_stmt|;
name|relocate
operator|=
name|FALSE
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|skip
operator|=
name|relocate
operator|=
name|TRUE
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|outrel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_M32R_10_PCREL_RELA
operator|||
name|r_type
operator|==
name|R_M32R_18_PCREL_RELA
operator|||
name|r_type
operator|==
name|R_M32R_26_PCREL_RELA
operator|||
name|r_type
operator|==
name|R_M32R_REL32
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
else|else
block|{
comment|/* h->dynindx may be -1 if this symbol was marked to                        become local.  */
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
operator|(
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|)
operator|&&
name|h
operator|->
name|def_regular
operator|)
condition|)
block|{
name|relocate
operator|=
name|TRUE
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_M32R_RELATIVE
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
block|}
name|loc
operator|=
name|sreloc
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|sreloc
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
operator|++
name|sreloc
operator|->
name|reloc_count
expr_stmt|;
comment|/* If this reloc is against an external symbol, we do                      not want to fiddle with the addend.  Otherwise, we                      need to include the symbol value so that it becomes                      an addend for the dynamic reloc.  */
if|if
condition|(
operator|!
name|relocate
condition|)
continue|continue;
break|break;
block|}
elseif|else
if|if
condition|(
name|r_type
operator|!=
name|R_M32R_10_PCREL_RELA
condition|)
break|break;
comment|/* Fall through.  */
case|case
operator|(
name|int
operator|)
name|R_M32R_10_PCREL
case|:
name|r
operator|=
name|m32r_elf_do_10_pcrel_reloc
argument_list|(
name|input_bfd
argument_list|,
name|howto
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|offset
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|addend
argument_list|)
expr_stmt|;
goto|goto
name|check_reloc
goto|;
case|case
operator|(
name|int
operator|)
name|R_M32R_HI16_SLO
case|:
case|case
operator|(
name|int
operator|)
name|R_M32R_HI16_ULO
case|:
block|{
name|Elf_Internal_Rela
modifier|*
name|lorel
decl_stmt|;
comment|/* We allow an arbitrary number of HI16 relocs before the 		   LO16 reloc.  This permits gcc to emit the HI and LO relocs 		   itself.  */
for|for
control|(
name|lorel
operator|=
name|rel
operator|+
literal|1
init|;
operator|(
name|lorel
operator|<
name|relend
operator|&&
operator|(
name|ELF32_R_TYPE
argument_list|(
name|lorel
operator|->
name|r_info
argument_list|)
operator|==
name|R_M32R_HI16_SLO
operator|||
name|ELF32_R_TYPE
argument_list|(
name|lorel
operator|->
name|r_info
argument_list|)
operator|==
name|R_M32R_HI16_ULO
operator|)
operator|)
condition|;
name|lorel
operator|++
control|)
continue|continue;
if|if
condition|(
name|lorel
operator|<
name|relend
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|lorel
operator|->
name|r_info
argument_list|)
operator|==
name|R_M32R_LO16
condition|)
block|{
name|m32r_elf_relocate_hi16
argument_list|(
name|input_bfd
argument_list|,
name|r_type
argument_list|,
name|rel
argument_list|,
name|lorel
argument_list|,
name|contents
argument_list|,
name|relocation
operator|+
name|addend
argument_list|)
expr_stmt|;
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
block|}
else|else
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|offset
argument_list|,
name|relocation
argument_list|,
name|addend
argument_list|)
expr_stmt|;
block|}
goto|goto
name|check_reloc
goto|;
case|case
operator|(
name|int
operator|)
name|R_M32R_SDA16_RELA
case|:
case|case
operator|(
name|int
operator|)
name|R_M32R_SDA16
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".scommon"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_vma
name|sda_base
decl_stmt|;
name|bfd
modifier|*
name|out_bfd
init|=
name|sec
operator|->
name|output_section
operator|->
name|owner
decl_stmt|;
name|r
operator|=
name|m32r_elf_final_sda_base
argument_list|(
name|out_bfd
argument_list|,
name|info
argument_list|,
operator|&
name|errmsg
argument_list|,
operator|&
name|sda_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
name|ret
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|check_reloc
goto|;
block|}
comment|/* At this point `relocation' contains the object's 		       address.  */
name|relocation
operator|-=
name|sda_base
expr_stmt|;
comment|/* Now it contains the offset from _SDA_BASE_.  */
block|}
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: The target (%s) of an %s relocation is in the wrong section (%A)"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|sec
argument_list|,
name|sym_name
argument_list|,
name|m32r_elf_howto_table
index|[
operator|(
name|int
operator|)
name|r_type
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/*bfd_set_error (bfd_error_bad_value); ??? why? */
name|ret
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Fall through.  */
default|default :
comment|/* OLD_M32R_RELOC */
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|offset
argument_list|,
name|relocation
argument_list|,
name|addend
argument_list|)
expr_stmt|;
goto|goto
name|check_reloc
goto|;
block|}
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
name|check_reloc
label|:
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
comment|/* FIXME: This should be generic enough to go in a utility.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errmsg
operator|!=
name|NULL
condition|)
goto|goto
name|common_error
goto|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
operator|(
name|h
condition|?
operator|&
name|h
operator|->
name|root
else|:
name|NULL
operator|)
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|bfd_reloc_undefined
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|offset
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
name|errmsg
operator|=
name|_
argument_list|(
literal|"internal error: out of range error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
name|bfd_reloc_notsupported
case|:
name|errmsg
operator|=
name|_
argument_list|(
literal|"internal error: unsupported relocation error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
name|bfd_reloc_dangerous
case|:
name|errmsg
operator|=
name|_
argument_list|(
literal|"internal error: dangerous error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
default|default:
name|errmsg
operator|=
name|_
argument_list|(
literal|"internal error: unknown error"
argument_list|)
expr_stmt|;
comment|/* fall through */
name|common_error
label|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|errmsg
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m32r_elf_finish_dynamic_symbol
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
name|struct
name|elf_m32r_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PIC
name|printf
argument_list|(
literal|"m32r_elf_finish_dynamic_symbol()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|htab
operator|=
name|m32r_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|root
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srela
decl_stmt|;
name|bfd_vma
name|plt_index
decl_stmt|;
name|bfd_vma
name|got_offset
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
comment|/* This symbol has an entry in the procedure linkage table.  Set          it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|splt
operator|=
name|htab
operator|->
name|splt
expr_stmt|;
name|sgot
operator|=
name|htab
operator|->
name|sgotplt
expr_stmt|;
name|srela
operator|=
name|htab
operator|->
name|srelplt
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|sgot
operator|!=
name|NULL
operator|&&
name|srela
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Get the index in the procedure linkage table which          corresponds to this symbol.  This is the index of this symbol          in all the symbols for which we are making plt entries.  The          first entry in the procedure linkage table is reserved.  */
name|plt_index
operator|=
name|h
operator|->
name|plt
operator|.
name|offset
operator|/
name|PLT_ENTRY_SIZE
operator|-
literal|1
expr_stmt|;
comment|/* Get the offset into the .got table of the entry that         corresponds to this function.  Each .got entry is 4 bytes.         The first three are reserved.  */
name|got_offset
operator|=
operator|(
name|plt_index
operator|+
literal|3
operator|)
operator|*
literal|4
expr_stmt|;
comment|/* Fill in the entry in the procedure linkage table.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PLT_ENTRY_WORD0b
operator|+
operator|(
operator|(
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|got_offset
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PLT_ENTRY_WORD1b
operator|+
operator|(
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|got_offset
operator|)
operator|&
literal|0xffff
operator|)
operator|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|PLT_ENTRY_WORD2
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PLT_ENTRY_WORD3
operator|+
name|plt_index
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|12
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PLT_ENTRY_WORD4
operator|+
operator|(
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
operator|-
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|16
operator|)
operator|)
operator|>>
literal|2
argument_list|)
operator|)
operator|&
literal|0xffffff
operator|)
operator|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|PLT_ENTRY_WORD0
operator|+
name|got_offset
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|PLT_ENTRY_WORD1
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|PLT_ENTRY_WORD2
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PLT_ENTRY_WORD3
operator|+
name|plt_index
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
operator|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|12
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|PLT_ENTRY_WORD4
operator|+
operator|(
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
operator|-
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|16
operator|)
operator|)
operator|>>
literal|2
argument_list|)
operator|)
operator|&
literal|0xffffff
operator|)
operator|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|16
argument_list|)
expr_stmt|;
block|}
comment|/* Fill in the entry in the global offset table.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|12
operator|)
argument_list|,
comment|/* same offset */
name|sgot
operator|->
name|contents
operator|+
name|got_offset
argument_list|)
expr_stmt|;
comment|/* Fill in the entry in the .rela.plt section.  */
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|got_offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_M32R_JMP_SLOT
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
name|srela
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|plt_index
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
comment|/* Mark the symbol as undefined, rather than as defined in              the .plt section.  Leave the value alone.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
block|}
block|}
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srela
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
comment|/* This symbol has an entry in the global offset table.  Set it          up.  */
name|sgot
operator|=
name|htab
operator|->
name|sgot
expr_stmt|;
name|srela
operator|=
name|htab
operator|->
name|srelgot
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
operator|&&
name|srela
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
operator|~
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* If this is a -Bsymbolic link, and the symbol is defined          locally, we just want to emit a RELATIVE reloc.  Likewise if          the symbol was forced to be local because of a version file.          The entry in the global offset table will already have been          initialized in the relocate_section function.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
name|h
operator|->
name|forced_local
operator|)
operator|&&
name|h
operator|->
name|def_regular
condition|)
block|{
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_M32R_RELATIVE
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
literal|1
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|h
operator|->
name|got
operator|.
name|offset
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_M32R_GLOB_DAT
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
name|loc
operator|=
name|srela
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|srela
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
operator|++
name|srela
operator|->
name|reloc_count
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|needs_copy
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
comment|/* This symbols needs a copy reloc.  Set it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|,
literal|".rela.bss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_M32R_COPY
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
name|s
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|s
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
operator|++
name|s
operator|->
name|reloc_count
expr_stmt|;
block|}
comment|/* Mark some specially defined symbols as absolute.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
name|h
operator|==
name|htab
operator|->
name|root
operator|.
name|hgot
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m32r_elf_finish_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf_m32r_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PIC
name|printf
argument_list|(
literal|"m32r_elf_finish_dynamic_sections()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|htab
operator|=
name|m32r_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|root
operator|.
name|dynobj
expr_stmt|;
name|sgot
operator|=
name|htab
operator|->
name|sgotplt
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|root
operator|.
name|dynamic_sections_created
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|Elf32_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
operator|&&
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_elf32_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
default|default:
break|break;
case|case
name|DT_PLTGOT
case|:
name|name
operator|=
literal|".got"
expr_stmt|;
name|s
operator|=
name|htab
operator|->
name|sgot
operator|->
name|output_section
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_JMPREL
case|:
name|name
operator|=
literal|".rela.plt"
expr_stmt|;
name|s
operator|=
name|htab
operator|->
name|srelplt
operator|->
name|output_section
expr_stmt|;
name|get_vma
label|:
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|s
operator|=
name|htab
operator|->
name|srelplt
operator|->
name|output_section
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|size
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_RELASZ
case|:
comment|/* My reading of the SVR4 ABI indicates that the                  procedure linkage table relocs (DT_JMPREL) should be                  included in the overall relocs (DT_RELA).  This is                  what Solaris does.  However, UnixWare can not handle                  that case.  Therefore, we override the DT_RELASZ entry                  here to make it not include the JMPREL relocs.  Since                  the linker script arranges for .rela.plt to follow all                  other relocation sections, we don't have to worry                  about changing the DT_RELA entry.  */
if|if
condition|(
name|htab
operator|->
name|srelplt
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|htab
operator|->
name|srelplt
operator|->
name|output_section
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|-=
name|s
operator|->
name|size
expr_stmt|;
block|}
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Fill in the first entry in the procedure linkage table.  */
name|splt
operator|=
name|htab
operator|->
name|splt
expr_stmt|;
if|if
condition|(
name|splt
operator|&&
name|splt
operator|->
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|PLT0_PIC_ENTRY_WORD0
argument_list|,
name|splt
operator|->
name|contents
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|PLT0_PIC_ENTRY_WORD1
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|PLT0_PIC_ENTRY_WORD2
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|PLT0_PIC_ENTRY_WORD3
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|12
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|PLT0_PIC_ENTRY_WORD4
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|addr
decl_stmt|;
comment|/* addr = .got + 4 */
name|addr
operator|=
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|PLT0_ENTRY_WORD0
operator||
operator|(
operator|(
name|addr
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
argument_list|,
name|splt
operator|->
name|contents
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|PLT0_ENTRY_WORD1
operator||
operator|(
name|addr
operator|&
literal|0xffff
operator|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|PLT0_ENTRY_WORD2
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|PLT0_ENTRY_WORD3
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|12
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|PLT0_ENTRY_WORD4
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|16
argument_list|)
expr_stmt|;
block|}
name|elf_section_data
argument_list|(
name|splt
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
name|PLT_ENTRY_SIZE
expr_stmt|;
block|}
block|}
comment|/* Fill in the first three entries in the global offset table.  */
if|if
condition|(
name|sgot
operator|&&
name|sgot
operator|->
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sdyn
operator|==
name|NULL
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
else|else
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sdyn
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sdyn
operator|->
name|output_offset
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
name|elf_section_data
argument_list|(
name|sgot
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|4
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the right machine number.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m32r_elf_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
switch|switch
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_M32R_ARCH
condition|)
block|{
default|default:
case|case
name|E_M32R_ARCH
case|:
operator|(
name|void
operator|)
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_m32r
argument_list|,
name|bfd_mach_m32r
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_M32RX_ARCH
case|:
operator|(
name|void
operator|)
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_m32r
argument_list|,
name|bfd_mach_m32rx
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_M32R2_ARCH
case|:
operator|(
name|void
operator|)
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_m32r
argument_list|,
name|bfd_mach_m32r2
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Store the machine number in the flags field.  */
end_comment

begin_function
specifier|static
name|void
name|m32r_elf_final_write_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|linker
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|long
name|val
decl_stmt|;
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
default|default:
case|case
name|bfd_mach_m32r
case|:
name|val
operator|=
name|E_M32R_ARCH
expr_stmt|;
break|break;
case|case
name|bfd_mach_m32rx
case|:
name|val
operator|=
name|E_M32RX_ARCH
expr_stmt|;
break|break;
case|case
name|bfd_mach_m32r2
case|:
name|val
operator|=
name|E_M32R2_ARCH
expr_stmt|;
break|break;
block|}
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
name|EF_M32R_ARCH
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator||=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function to keep M32R specific file flags.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m32r_elf_set_private_flags
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|flagword
name|flags
parameter_list|)
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|||
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|==
name|flags
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m32r_elf_merge_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|flagword
name|out_flags
decl_stmt|;
name|flagword
name|in_flags
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
name|in_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|out_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
comment|/* If the input is the default architecture then do not 	 bother setting the flags for the output architecture, 	 instead allow future merges to do this.  If no future 	 merges ever set these flags then they will retain their 	 unitialised values, which surprise surprise, correspond 	 to the default values.  */
if|if
condition|(
name|bfd_get_arch_info
argument_list|(
name|ibfd
argument_list|)
operator|->
name|the_default
condition|)
return|return
name|TRUE
return|;
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|in_flags
expr_stmt|;
if|if
condition|(
name|bfd_get_arch
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
operator|&&
name|bfd_get_arch_info
argument_list|(
name|obfd
argument_list|)
operator|->
name|the_default
condition|)
return|return
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
return|;
return|return
name|TRUE
return|;
block|}
comment|/* Check flag compatibility.  */
if|if
condition|(
name|in_flags
operator|==
name|out_flags
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|(
name|in_flags
operator|&
name|EF_M32R_ARCH
operator|)
operator|!=
operator|(
name|out_flags
operator|&
name|EF_M32R_ARCH
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|in_flags
operator|&
name|EF_M32R_ARCH
operator|)
operator|!=
name|E_M32R_ARCH
operator|)
operator|||
operator|(
operator|(
name|out_flags
operator|&
name|EF_M32R_ARCH
operator|)
operator|==
name|E_M32R_ARCH
operator|)
operator|||
operator|(
operator|(
name|in_flags
operator|&
name|EF_M32R_ARCH
operator|)
operator|==
name|E_M32R2_ARCH
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: Instruction set mismatch with previous modules"
argument_list|)
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Display the flags field.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m32r_elf_print_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|ptr
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|abfd
operator|!=
name|NULL
operator|&&
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|_bfd_elf_print_private_bfd_data
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"private flags = %lx"
argument_list|)
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_M32R_ARCH
condition|)
block|{
default|default:
case|case
name|E_M32R_ARCH
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|": m32r instructions"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_M32RX_ARCH
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|": m32rx instructions"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|E_M32R2_ARCH
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|": m32r2 instructions"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|m32r_elf_gc_mark_hook
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_M32R_GNU_VTINHERIT
case|:
case|case
name|R_M32R_GNU_VTENTRY
case|:
case|case
name|R_M32R_RELA_GNU_VTINHERIT
case|:
case|case
name|R_M32R_RELA_GNU_VTENTRY
case|:
break|break;
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
default|default:
break|break;
block|}
block|}
block|}
else|else
return|return
name|bfd_section_from_elf_index
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|m32r_elf_gc_sweep_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Update the got entry reference counts for the section being removed.  */
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|local_dynrel
operator|=
name|NULL
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_M32R_GOT16_HI_ULO
case|:
case|case
name|R_M32R_GOT16_HI_SLO
case|:
case|case
name|R_M32R_GOT16_LO
case|:
case|case
name|R_M32R_GOTOFF
case|:
case|case
name|R_M32R_GOTOFF_HI_ULO
case|:
case|case
name|R_M32R_GOTOFF_HI_SLO
case|:
case|case
name|R_M32R_GOTOFF_LO
case|:
case|case
name|R_M32R_GOT24
case|:
case|case
name|R_M32R_GOTPC_HI_ULO
case|:
case|case
name|R_M32R_GOTPC_HI_SLO
case|:
case|case
name|R_M32R_GOTPC_LO
case|:
case|case
name|R_M32R_GOTPC24
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|got
operator|.
name|refcount
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|local_got_refcounts
operator|&&
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|>
literal|0
condition|)
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|--
expr_stmt|;
block|}
break|break;
case|case
name|R_M32R_16_RELA
case|:
case|case
name|R_M32R_24_RELA
case|:
case|case
name|R_M32R_32_RELA
case|:
case|case
name|R_M32R_REL32
case|:
case|case
name|R_M32R_HI16_ULO_RELA
case|:
case|case
name|R_M32R_HI16_SLO_RELA
case|:
case|case
name|R_M32R_LO16_RELA
case|:
case|case
name|R_M32R_SDA16_RELA
case|:
case|case
name|R_M32R_10_PCREL_RELA
case|:
case|case
name|R_M32R_18_PCREL_RELA
case|:
case|case
name|R_M32R_26_PCREL_RELA
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_m32r_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf_m32r_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|elf_m32r_dyn_relocs
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|plt
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf_m32r_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|sec
operator|==
name|sec
condition|)
block|{
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_M32R_26_PCREL_RELA
operator|||
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_M32R_18_PCREL_RELA
operator|||
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_M32R_10_PCREL_RELA
operator|||
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_M32R_REL32
condition|)
name|p
operator|->
name|pc_count
operator|-=
literal|1
expr_stmt|;
name|p
operator|->
name|count
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|R_M32R_26_PLTREL
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|plt
operator|.
name|refcount
operator|--
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase.    Since we don't do .gots or .plts, we just need to consider the    virtual table relocs for gc.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m32r_elf_check_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|,
modifier|*
modifier|*
name|sym_hashes_end
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|struct
name|elf_m32r_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|,
modifier|*
name|srelgot
decl_stmt|,
modifier|*
name|sreloc
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|sgot
operator|=
name|srelgot
operator|=
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_hashes_end
operator|=
name|sym_hashes
operator|+
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|sym_hashes_end
operator|-=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|htab
operator|=
name|m32r_elf_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|root
operator|.
name|dynobj
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
comment|/* Some relocs require a global offset table.  */
if|if
condition|(
name|htab
operator|->
name|sgot
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_M32R_GOT16_HI_ULO
case|:
case|case
name|R_M32R_GOT16_HI_SLO
case|:
case|case
name|R_M32R_GOTOFF
case|:
case|case
name|R_M32R_GOTOFF_HI_ULO
case|:
case|case
name|R_M32R_GOTOFF_HI_SLO
case|:
case|case
name|R_M32R_GOTOFF_LO
case|:
case|case
name|R_M32R_GOT16_LO
case|:
case|case
name|R_M32R_GOTPC24
case|:
case|case
name|R_M32R_GOTPC_HI_ULO
case|:
case|case
name|R_M32R_GOTPC_HI_SLO
case|:
case|case
name|R_M32R_GOTPC_LO
case|:
case|case
name|R_M32R_GOT24
case|:
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|htab
operator|->
name|root
operator|.
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
default|default:
break|break;
block|}
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_M32R_GOT16_HI_ULO
case|:
case|case
name|R_M32R_GOT16_HI_SLO
case|:
case|case
name|R_M32R_GOT16_LO
case|:
case|case
name|R_M32R_GOT24
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|h
operator|->
name|got
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
else|else
block|{
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
comment|/* This is a global offset table entry for a local                  symbol.  */
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|size
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|size
operator|*=
sizeof|sizeof
argument_list|(
name|bfd_signed_vma
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_got_refcounts
expr_stmt|;
block|}
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|R_M32R_26_PLTREL
case|:
comment|/* This symbol requires a procedure linkage table entry.  We              actually build the entry in adjust_dynamic_symbol,              because this might be a case of linking PIC code without              linking in any dynamic objects, in which case we don't              need to generate a procedure linkage table after all.  */
comment|/* If this is a local symbol, we resolve it directly without 	     creating a procedure linkage table entry.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|h
operator|->
name|forced_local
condition|)
break|break;
name|h
operator|->
name|needs_plt
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|R_M32R_16_RELA
case|:
case|case
name|R_M32R_24_RELA
case|:
case|case
name|R_M32R_32_RELA
case|:
case|case
name|R_M32R_REL32
case|:
case|case
name|R_M32R_HI16_ULO_RELA
case|:
case|case
name|R_M32R_HI16_SLO_RELA
case|:
case|case
name|R_M32R_LO16_RELA
case|:
case|case
name|R_M32R_SDA16_RELA
case|:
case|case
name|R_M32R_10_PCREL_RELA
case|:
case|case
name|R_M32R_18_PCREL_RELA
case|:
case|case
name|R_M32R_26_PCREL_RELA
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|h
operator|->
name|non_got_ref
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* If we are creating a shared library, and this is a reloc              against a global symbol, or a non PC relative reloc              against a local symbol, then we need to copy the reloc              into the shared library.  However, if we are linking with              -Bsymbolic, we do not need to copy a reloc against a              global symbol which is defined in an object we are              including in the link (i.e., DEF_REGULAR is set).  At              this point we have not seen all the input files, so it is              possible that DEF_REGULAR is not set now but will be set              later (it is never cleared).  We account for that              possibility below by storing information in the              dyn_relocs field of the hash table entry. A similar              situation occurs when creating shared libraries and symbol              visibility changes render the symbol local.               If on the other hand, we are creating an executable, we              may need to keep relocations for symbols satisfied by a              dynamic library if we manage to avoid copy relocs for the              symbol.  */
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|r_type
operator|!=
name|R_M32R_26_PCREL_RELA
operator|&&
name|r_type
operator|!=
name|R_M32R_18_PCREL_RELA
operator|&&
name|r_type
operator|!=
name|R_M32R_10_PCREL_RELA
operator|&&
name|r_type
operator|!=
name|R_M32R_REL32
operator|)
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
condition|)
block|{
name|struct
name|elf_m32r_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|struct
name|elf_m32r_dyn_relocs
modifier|*
modifier|*
name|head
decl_stmt|;
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|htab
operator|->
name|root
operator|.
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
comment|/* When creating a shared object, we must copy these                  relocs into the output file.  We create a reloc                  section in dynobj and make room for the reloc.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|BFD_ASSERT
argument_list|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
name|flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
name|sreloc
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sreloc
operator|=
name|sreloc
expr_stmt|;
block|}
comment|/* If this is a global symbol, we count the number of                  relocations we need for this symbol.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|head
operator|=
operator|&
operator|(
operator|(
expr|struct
name|elf_m32r_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|dyn_relocs
expr_stmt|;
else|else
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|void
modifier|*
name|vpp
decl_stmt|;
comment|/* Track dynamic relocs needed for local syms too.  */
name|s
operator|=
name|bfd_section_from_r_symndx
argument_list|(
name|abfd
argument_list|,
operator|&
name|htab
operator|->
name|sym_sec
argument_list|,
name|sec
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|vpp
operator|=
operator|&
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
expr_stmt|;
name|head
operator|=
operator|(
expr|struct
name|elf_m32r_dyn_relocs
operator|*
operator|*
operator|)
name|vpp
expr_stmt|;
block|}
name|p
operator|=
operator|*
name|head
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
operator|->
name|sec
operator|!=
name|sec
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
decl_stmt|;
name|p
operator|=
name|bfd_alloc
argument_list|(
name|dynobj
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|p
operator|->
name|next
operator|=
operator|*
name|head
expr_stmt|;
operator|*
name|head
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
name|p
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pc_count
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|->
name|count
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_M32R_26_PCREL_RELA
operator|||
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_M32R_18_PCREL_RELA
operator|||
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_M32R_10_PCREL_RELA
operator|||
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_M32R_REL32
condition|)
name|p
operator|->
name|pc_count
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
comment|/* This relocation describes the C++ object vtable hierarchy.            Reconstruct it for later use during GC.  */
case|case
name|R_M32R_RELA_GNU_VTINHERIT
case|:
case|case
name|R_M32R_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually            used.  Record for later use during GC.  */
case|case
name|R_M32R_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|R_M32R_RELA_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|bfd_elf_special_section
name|m32r_elf_special_sections
index|[]
init|=
block|{
block|{
literal|".sbss"
block|,
literal|5
block|,
operator|-
literal|2
block|,
name|SHT_NOBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
literal|".sdata"
block|,
literal|6
block|,
operator|-
literal|2
block|,
name|SHT_PROGBITS
block|,
name|SHF_ALLOC
operator|+
name|SHF_WRITE
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_boolean
name|m32r_elf_fake_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|hdr
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
comment|/* The generic elf_fake_sections will set up REL_HDR using the      default kind of relocations.  But, we may actually need both      kinds of relocations, so we set up the second header here.       This is not necessary for the O32 ABI since that only uses Elf32_Rel      relocations (cf. System V ABI, MIPS RISC Processor Supplement,      3rd Edition, p. 4-17).  It breaks the IRIX 5/6 32-bit ld, since one      of the resulting empty .rela.<section> sections starts with      sh_offset == object size, and ld doesn't allow that.  While the check      is arguably bogus for empty or SHT_NOBITS sections, it can easily be      avoided by not emitting those useless sections in the first place.  */
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|bfd_elf_section_data
modifier|*
name|esd
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|Elf_Internal_Shdr
argument_list|)
decl_stmt|;
name|esd
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|esd
operator|->
name|rel_hdr2
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|esd
operator|->
name|rel_hdr2
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|esd
operator|->
name|rel_hdr2
condition|)
return|return
name|FALSE
return|;
name|_bfd_elf_init_reloc_shdr
argument_list|(
name|abfd
argument_list|,
name|esd
operator|->
name|rel_hdr2
argument_list|,
name|sec
argument_list|,
operator|!
name|sec
operator|->
name|use_rela_p
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|elf_reloc_type_class
name|m32r_elf_reloc_type_class
parameter_list|(
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rela
parameter_list|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|ELF32_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_M32R_RELATIVE
case|:
return|return
name|reloc_class_relative
return|;
case|case
name|R_M32R_JMP_SLOT
case|:
return|return
name|reloc_class_plt
return|;
case|case
name|R_M32R_COPY
case|:
return|return
name|reloc_class_copy
return|;
default|default:
return|return
name|reloc_class_normal
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_m32r
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_M32R
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT1
value|EM_CYGNUS_M32R
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1
end_define

begin_comment
comment|/* Explicitly requested by Mitsubishi.  */
end_comment

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_m32r_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-m32r"
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_m32rle_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-m32rle"
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|m32r_info_to_howto
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|m32r_info_to_howto_rel
end_define

begin_define
define|#
directive|define
name|elf_backend_section_from_bfd_section
value|_bfd_m32r_elf_section_from_bfd_section
end_define

begin_define
define|#
directive|define
name|elf_backend_symbol_processing
value|_bfd_m32r_elf_symbol_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
value|m32r_elf_add_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|m32r_elf_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|m32r_elf_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|m32r_elf_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|m32r_elf_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
value|m32r_elf_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
value|m32r_elf_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
value|m32r_elf_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
value|m32r_elf_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
value|m32r_elf_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
value|m32r_elf_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_reloc_type_class
value|m32r_elf_reloc_type_class
end_define

begin_define
define|#
directive|define
name|elf_backend_copy_indirect_symbol
value|m32r_elf_copy_indirect_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_comment
comment|/*#if !USE_REL #define elf_backend_rela_normal			1 #endif*/
end_comment

begin_define
define|#
directive|define
name|elf_backend_can_refcount
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_want_got_plt
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_readonly
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|12
end_define

begin_define
define|#
directive|define
name|elf_backend_may_use_rel_p
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|USE_M32R_OLD_RELOC
end_ifdef

begin_define
define|#
directive|define
name|elf_backend_default_use_rela_p
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_may_use_rela_p
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|elf_backend_default_use_rela_p
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_may_use_rela_p
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_fake_sections
value|m32r_elf_fake_sections
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|elf_backend_object_p
value|m32r_elf_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
value|m32r_elf_final_write_processing
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_merge_private_bfd_data
value|m32r_elf_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_set_private_flags
value|m32r_elf_set_private_flags
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_print_private_bfd_data
value|m32r_elf_print_private_bfd_data
end_define

begin_define
define|#
directive|define
name|elf_backend_special_sections
value|m32r_elf_special_sections
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

begin_undef
undef|#
directive|undef
name|ELF_MAXPAGESIZE
end_undef

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1000
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BIG_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_m32rlin_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BIG_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-m32r-linux"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_m32rlelin_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_LITTLE_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-m32rle-linux"
end_define

begin_undef
undef|#
directive|undef
name|elf32_bed
end_undef

begin_define
define|#
directive|define
name|elf32_bed
value|elf32_m32r_lin_bed
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

