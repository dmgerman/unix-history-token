begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  MSP430-specific support for 32-bit ELF     Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007     Free Software Foundation, Inc.     Contributed by Dmitry Diky<diwil@mail.ru>      This file is part of BFD, the Binary File Descriptor library.      This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 2 of the License, or     (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License     along with this program; if not, write to the Free Software     Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/msp430.h"
end_include

begin_comment
comment|/* Use RELA instead of REL.  */
end_comment

begin_undef
undef|#
directive|undef
name|USE_REL
end_undef

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_msp430_howto_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|R_MSP430_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MSP430_NONE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_MSP430_32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MSP430_32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 13 bit PC relative relocation.  */
name|HOWTO
argument_list|(
name|R_MSP430_10_PCREL
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|10
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MSP430_13_PCREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xfff
argument_list|,
comment|/* src_mask */
literal|0xfff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit absolute relocation.  */
name|HOWTO
argument_list|(
name|R_MSP430_16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MSP430_16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit absolute relocation for command address.  */
name|HOWTO
argument_list|(
name|R_MSP430_16_PCREL
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MSP430_16_PCREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit absolute relocation, byte operations.  */
name|HOWTO
argument_list|(
name|R_MSP430_16_BYTE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MSP430_16_BYTE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit absolute relocation for command address.  */
name|HOWTO
argument_list|(
name|R_MSP430_16_PCREL_BYTE
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MSP430_16_PCREL_BYTE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 13 bit PC relative relocation for complicated polymorphs.  */
name|HOWTO
argument_list|(
name|R_MSP430_2X_PCREL
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|10
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MSP430_2X_PCREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xfff
argument_list|,
comment|/* src_mask */
literal|0xfff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit relaxable relocation for command address.  */
name|HOWTO
argument_list|(
argument|R_MSP430_RL_PCREL
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
argument|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
argument|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
argument|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_MSP430_RL_PCREL"
argument_list|,
comment|/* name */
argument|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
argument|TRUE
argument_list|)
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map BFD reloc types to MSP430 ELF reloc types.  */
end_comment

begin_struct
struct|struct
name|msp430_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_val
decl_stmt|;
name|unsigned
name|int
name|elf_reloc_val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|msp430_reloc_map
name|msp430_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_MSP430_NONE
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_MSP430_32
block|}
block|,
block|{
name|BFD_RELOC_MSP430_10_PCREL
block|,
name|R_MSP430_10_PCREL
block|}
block|,
block|{
name|BFD_RELOC_16
block|,
name|R_MSP430_16_BYTE
block|}
block|,
block|{
name|BFD_RELOC_MSP430_16_PCREL
block|,
name|R_MSP430_16_PCREL
block|}
block|,
block|{
name|BFD_RELOC_MSP430_16
block|,
name|R_MSP430_16
block|}
block|,
block|{
name|BFD_RELOC_MSP430_16_PCREL_BYTE
block|,
name|R_MSP430_16_PCREL_BYTE
block|}
block|,
block|{
name|BFD_RELOC_MSP430_16_BYTE
block|,
name|R_MSP430_16_BYTE
block|}
block|,
block|{
name|BFD_RELOC_MSP430_2X_PCREL
block|,
name|R_MSP430_2X_PCREL
block|}
block|,
block|{
name|BFD_RELOC_MSP430_RL_PCREL
block|,
name|R_MSP430_RL_PCREL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|bfd_elf32_bfd_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|msp430_reloc_map
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|msp430_reloc_map
index|[
name|i
index|]
operator|.
name|bfd_reloc_val
operator|==
name|code
condition|)
return|return
operator|&
name|elf_msp430_howto_table
index|[
name|msp430_reloc_map
index|[
name|i
index|]
operator|.
name|elf_reloc_val
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|bfd_elf32_bfd_reloc_name_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|r_name
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|elf_msp430_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|elf_msp430_howto_table
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|elf_msp430_howto_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcasecmp
argument_list|(
name|elf_msp430_howto_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|elf_msp430_howto_table
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set the howto pointer for an MSP430 ELF reloc.  */
end_comment

begin_function
specifier|static
name|void
name|msp430_info_to_howto_rela
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|cache_ptr
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|dst
parameter_list|)
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r_type
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_MSP430_max
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf_msp430_howto_table
index|[
name|r_type
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase.    Since we don't do .gots or .plts, we just need to consider the    virtual table relocs for gc.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_msp430_check_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|,
modifier|*
modifier|*
name|sym_hashes_end
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_hashes_end
operator|=
name|sym_hashes
operator|+
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|sym_hashes_end
operator|-=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Perform a single relocation.  By default we use the standard BFD    routines, but a few relocs, we have to do them ourselves.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|msp430_final_link_relocate
parameter_list|(
name|reloc_howto_type
modifier|*
name|howto
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|bfd_vma
name|relocation
parameter_list|)
block|{
name|bfd_reloc_status_type
name|r
init|=
name|bfd_reloc_ok
decl_stmt|;
name|bfd_vma
name|x
decl_stmt|;
name|bfd_signed_vma
name|srel
decl_stmt|;
switch|switch
condition|(
name|howto
operator|->
name|type
condition|)
block|{
case|case
name|R_MSP430_10_PCREL
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
expr_stmt|;
name|srel
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|-=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|-=
literal|2
expr_stmt|;
comment|/* Branch instructions add 2 to the PC...  */
name|srel
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|srel
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* MSP430 addresses commands as words.  */
name|srel
operator|>>=
literal|1
expr_stmt|;
comment|/* Check for an overflow.  */
if|if
condition|(
name|srel
operator|<
operator|-
literal|512
operator|||
name|srel
operator|>
literal|511
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xfc00
operator|)
operator||
operator|(
name|srel
operator|&
literal|0x3ff
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MSP430_2X_PCREL
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
expr_stmt|;
name|srel
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|-=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|-=
literal|2
expr_stmt|;
comment|/* Branch instructions add 2 to the PC...  */
name|srel
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|srel
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
comment|/* MSP430 addresses commands as words.  */
name|srel
operator|>>=
literal|1
expr_stmt|;
comment|/* Check for an overflow.  */
if|if
condition|(
name|srel
operator|<
operator|-
literal|512
operator|||
name|srel
operator|>
literal|511
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xfc00
operator|)
operator||
operator|(
name|srel
operator|&
literal|0x3ff
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
comment|/* Handle second jump instruction.  */
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|-
literal|2
argument_list|)
expr_stmt|;
name|srel
operator|+=
literal|1
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xfc00
operator|)
operator||
operator|(
name|srel
operator|&
literal|0x3ff
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MSP430_16_PCREL
case|:
case|case
name|R_MSP430_RL_PCREL
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
expr_stmt|;
name|srel
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|-=
name|rel
operator|->
name|r_offset
expr_stmt|;
comment|/* Only branch instructions add 2 to the PC...  */
name|srel
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|srel
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|srel
operator|&
literal|0xffff
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MSP430_16_PCREL_BYTE
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
expr_stmt|;
name|srel
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|-=
name|rel
operator|->
name|r_offset
expr_stmt|;
comment|/* Only branch instructions add 2 to the PC...  */
name|srel
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|srel
operator|&
literal|0xffff
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MSP430_16_BYTE
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
expr_stmt|;
name|srel
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|srel
operator|&
literal|0xffff
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_MSP430_16
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
expr_stmt|;
name|srel
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|srel
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_notsupported
return|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|srel
operator|&
literal|0xffff
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
default|default:
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Relocate an MSP430 ELF section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_msp430_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|howto
operator|=
name|elf_msp430_howto_table
operator|+
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|name
operator|==
name|NULL
operator|)
condition|?
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
else|:
name|name
expr_stmt|;
block|}
else|else
block|{
name|bfd_boolean
name|unresolved_reloc
decl_stmt|,
name|warned
decl_stmt|;
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|elf_discarded_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
comment|/* For relocs against symbols from removed linkonce sections, 	     or sections discarded by a linker script, we just want the 	     section contents zeroed.  Avoid any special processing.  */
name|_bfd_clear_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
continue|continue;
name|r
operator|=
name|msp430_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_overflow
case|:
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
argument_list|(
name|info
argument_list|,
operator|(
name|h
condition|?
operator|&
name|h
operator|->
name|root
else|:
name|NULL
operator|)
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_undefined
case|:
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: out of range error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_notsupported
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unsupported relocation error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_dangerous
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: dangerous relocation"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unknown error"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|msg
condition|)
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The final processing done just before writing out a MSP430 ELF object    file.  This gets the MSP430 architecture right based on the machine    number.  */
end_comment

begin_function
specifier|static
name|void
name|bfd_elf_msp430_final_write_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|linker
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|long
name|val
decl_stmt|;
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
default|default:
case|case
name|bfd_mach_msp110
case|:
name|val
operator|=
name|E_MSP430_MACH_MSP430x11x1
expr_stmt|;
break|break;
case|case
name|bfd_mach_msp11
case|:
name|val
operator|=
name|E_MSP430_MACH_MSP430x11
expr_stmt|;
break|break;
case|case
name|bfd_mach_msp12
case|:
name|val
operator|=
name|E_MSP430_MACH_MSP430x12
expr_stmt|;
break|break;
case|case
name|bfd_mach_msp13
case|:
name|val
operator|=
name|E_MSP430_MACH_MSP430x13
expr_stmt|;
break|break;
case|case
name|bfd_mach_msp14
case|:
name|val
operator|=
name|E_MSP430_MACH_MSP430x14
expr_stmt|;
break|break;
case|case
name|bfd_mach_msp15
case|:
name|val
operator|=
name|E_MSP430_MACH_MSP430x15
expr_stmt|;
break|break;
case|case
name|bfd_mach_msp16
case|:
name|val
operator|=
name|E_MSP430_MACH_MSP430x16
expr_stmt|;
break|break;
case|case
name|bfd_mach_msp31
case|:
name|val
operator|=
name|E_MSP430_MACH_MSP430x31
expr_stmt|;
break|break;
case|case
name|bfd_mach_msp32
case|:
name|val
operator|=
name|E_MSP430_MACH_MSP430x32
expr_stmt|;
break|break;
case|case
name|bfd_mach_msp33
case|:
name|val
operator|=
name|E_MSP430_MACH_MSP430x33
expr_stmt|;
break|break;
case|case
name|bfd_mach_msp41
case|:
name|val
operator|=
name|E_MSP430_MACH_MSP430x41
expr_stmt|;
break|break;
case|case
name|bfd_mach_msp42
case|:
name|val
operator|=
name|E_MSP430_MACH_MSP430x42
expr_stmt|;
break|break;
case|case
name|bfd_mach_msp43
case|:
name|val
operator|=
name|E_MSP430_MACH_MSP430x43
expr_stmt|;
break|break;
case|case
name|bfd_mach_msp44
case|:
name|val
operator|=
name|E_MSP430_MACH_MSP430x44
expr_stmt|;
break|break;
block|}
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_machine
operator|=
name|EM_MSP430
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
name|EF_MSP430_MACH
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator||=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the right machine number.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_msp430_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|int
name|e_set
init|=
name|bfd_mach_msp14
decl_stmt|;
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_machine
operator|==
name|EM_MSP430
operator|||
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_machine
operator|==
name|EM_MSP430_OLD
condition|)
block|{
name|int
name|e_mach
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MSP430_MACH
decl_stmt|;
switch|switch
condition|(
name|e_mach
condition|)
block|{
default|default:
case|case
name|E_MSP430_MACH_MSP430x11
case|:
name|e_set
operator|=
name|bfd_mach_msp11
expr_stmt|;
break|break;
case|case
name|E_MSP430_MACH_MSP430x11x1
case|:
name|e_set
operator|=
name|bfd_mach_msp110
expr_stmt|;
break|break;
case|case
name|E_MSP430_MACH_MSP430x12
case|:
name|e_set
operator|=
name|bfd_mach_msp12
expr_stmt|;
break|break;
case|case
name|E_MSP430_MACH_MSP430x13
case|:
name|e_set
operator|=
name|bfd_mach_msp13
expr_stmt|;
break|break;
case|case
name|E_MSP430_MACH_MSP430x14
case|:
name|e_set
operator|=
name|bfd_mach_msp14
expr_stmt|;
break|break;
case|case
name|E_MSP430_MACH_MSP430x15
case|:
name|e_set
operator|=
name|bfd_mach_msp15
expr_stmt|;
break|break;
case|case
name|E_MSP430_MACH_MSP430x16
case|:
name|e_set
operator|=
name|bfd_mach_msp16
expr_stmt|;
break|break;
case|case
name|E_MSP430_MACH_MSP430x31
case|:
name|e_set
operator|=
name|bfd_mach_msp31
expr_stmt|;
break|break;
case|case
name|E_MSP430_MACH_MSP430x32
case|:
name|e_set
operator|=
name|bfd_mach_msp32
expr_stmt|;
break|break;
case|case
name|E_MSP430_MACH_MSP430x33
case|:
name|e_set
operator|=
name|bfd_mach_msp33
expr_stmt|;
break|break;
case|case
name|E_MSP430_MACH_MSP430x41
case|:
name|e_set
operator|=
name|bfd_mach_msp41
expr_stmt|;
break|break;
case|case
name|E_MSP430_MACH_MSP430x42
case|:
name|e_set
operator|=
name|bfd_mach_msp42
expr_stmt|;
break|break;
case|case
name|E_MSP430_MACH_MSP430x43
case|:
name|e_set
operator|=
name|bfd_mach_msp43
expr_stmt|;
break|break;
case|case
name|E_MSP430_MACH_MSP430x44
case|:
name|e_set
operator|=
name|bfd_mach_msp44
expr_stmt|;
break|break;
block|}
block|}
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_msp430
argument_list|,
name|e_set
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* These functions handle relaxing for the msp430.    Relaxation required only in two cases:     - Bad hand coding like jumps from one section to another or       from file to file.     - Sibling calls. This will affect onlu 'jump label' polymorph. Without       relaxing this enlarges code by 2 bytes. Sibcalls implemented but       do not work in gcc's port by the reason I do not know.    Anyway, if a relaxation required, user should pass -relax option to the    linker.     There are quite a few relaxing opportunities available on the msp430:     ================================================================     1. 3 words -> 1 word     eq      ==      jeq label    		jne +4; br lab    ne      !=      jne label    		jeq +4; br lab    lt<       jl  label    		jge +4; br lab    ltu<       jlo label    		lhs +4; br lab    ge>=      jge label    		jl  +4; br lab    geu>=      jhs label    		jlo +4; br lab     2. 4 words -> 1 word     ltn<       jn                      jn  +2; jmp +4; br lab     3. 4 words -> 2 words     gt>       jeq +2; jge label       jeq +6; jl  +4; br label    gtu>       jeq +2; jhs label       jeq +6; jlo +4; br label     4. 4 words -> 2 words and 2 labels     leu<=      jeq label; jlo label    jeq +2; jhs +4; br label    le<=      jeq label; jl  label    jeq +2; jge +4; br label    =================================================================     codemap for first cases is (labels masked ): 	      eq:	0x2002,0x4010,0x0000 -> 0x2400 	      ne:	0x2402,0x4010,0x0000 -> 0x2000 	      lt:	0x3402,0x4010,0x0000 -> 0x3800 	      ltu:	0x2c02,0x4010,0x0000 -> 0x2800 	      ge:	0x3802,0x4010,0x0000 -> 0x3400 	      geu:	0x2802,0x4010,0x0000 -> 0x2c00    second case: 	      ltn:	0x3001,0x3c02,0x4010,0x0000 -> 0x3000    third case: 	      gt:	0x2403,0x3802,0x4010,0x0000 -> 0x2401,0x3400 	      gtu:	0x2403,0x2802,0x4010,0x0000 -> 0x2401,0x2c00    fourth case: 	      leu:	0x2401,0x2c02,0x4010,0x0000 -> 0x2400,0x2800 	      le:	0x2401,0x3402,0x4010,0x0000 -> 0x2400,0x3800    Unspecified case :) 	      jump:	0x4010,0x0000 -> 0x3c00.  */
end_comment

begin_define
define|#
directive|define
name|NUMB_RELAX_CODES
value|12
end_define

begin_struct
specifier|static
struct|struct
name|rcodes_s
block|{
name|int
name|f0
decl_stmt|,
name|f1
decl_stmt|;
comment|/* From code.  */
name|int
name|t0
decl_stmt|,
name|t1
decl_stmt|;
comment|/* To code.  */
name|int
name|labels
decl_stmt|;
comment|/* Position of labels: 1 - one label at first 				   word, 2 - one at second word, 3 - two 				   labels at both.  */
name|int
name|cdx
decl_stmt|;
comment|/* Words to match.  */
name|int
name|bs
decl_stmt|;
comment|/* Shrink bytes.  */
name|int
name|off
decl_stmt|;
comment|/* Offset from old label for new code.  */
name|int
name|ncl
decl_stmt|;
comment|/* New code length.  */
block|}
name|rcode
index|[]
init|=
block|{
comment|/*                               lab,cdx,bs,off,ncl */
block|{
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x3c00
block|,
literal|0x0000
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
comment|/* jump */
block|{
literal|0x0000
block|,
literal|0x2002
block|,
literal|0x2400
block|,
literal|0x0000
block|,
literal|1
block|,
literal|1
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|}
block|,
comment|/* eq */
block|{
literal|0x0000
block|,
literal|0x2402
block|,
literal|0x2000
block|,
literal|0x0000
block|,
literal|1
block|,
literal|1
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|}
block|,
comment|/* ne */
block|{
literal|0x0000
block|,
literal|0x3402
block|,
literal|0x3800
block|,
literal|0x0000
block|,
literal|1
block|,
literal|1
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|}
block|,
comment|/* lt */
block|{
literal|0x0000
block|,
literal|0x2c02
block|,
literal|0x2800
block|,
literal|0x0000
block|,
literal|1
block|,
literal|1
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|}
block|,
comment|/* ltu */
block|{
literal|0x0000
block|,
literal|0x3802
block|,
literal|0x3400
block|,
literal|0x0000
block|,
literal|1
block|,
literal|1
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|}
block|,
comment|/* ge */
block|{
literal|0x0000
block|,
literal|0x2802
block|,
literal|0x2c00
block|,
literal|0x0000
block|,
literal|1
block|,
literal|1
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|}
block|,
comment|/* geu */
block|{
literal|0x3001
block|,
literal|0x3c02
block|,
literal|0x3000
block|,
literal|0x0000
block|,
literal|1
block|,
literal|2
block|,
literal|6
block|,
literal|6
block|,
literal|2
block|}
block|,
comment|/* ltn */
block|{
literal|0x2403
block|,
literal|0x3802
block|,
literal|0x2401
block|,
literal|0x3400
block|,
literal|2
block|,
literal|2
block|,
literal|4
block|,
literal|6
block|,
literal|4
block|}
block|,
comment|/* gt */
block|{
literal|0x2403
block|,
literal|0x2802
block|,
literal|0x2401
block|,
literal|0x2c00
block|,
literal|2
block|,
literal|2
block|,
literal|4
block|,
literal|6
block|,
literal|4
block|}
block|,
comment|/* gtu */
block|{
literal|0x2401
block|,
literal|0x2c02
block|,
literal|0x2400
block|,
literal|0x2800
block|,
literal|3
block|,
literal|2
block|,
literal|4
block|,
literal|6
block|,
literal|4
block|}
block|,
comment|/* leu , 2 labels */
block|{
literal|0x2401
block|,
literal|0x2c02
block|,
literal|0x2400
block|,
literal|0x2800
block|,
literal|3
block|,
literal|2
block|,
literal|4
block|,
literal|6
block|,
literal|4
block|}
block|,
comment|/* le  , 2 labels */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Return TRUE if a symbol exists at the given address.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|msp430_elf_symbol_address_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|isym
parameter_list|,
name|bfd_vma
name|addr
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|unsigned
name|int
name|sec_shndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymend
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|end_hashes
decl_stmt|;
name|unsigned
name|int
name|symcount
decl_stmt|;
name|sec_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
comment|/* Examine all the local symbols.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
for|for
control|(
name|isymend
operator|=
name|isym
operator|+
name|symtab_hdr
operator|->
name|sh_info
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
control|)
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|sec_shndx
operator|&&
name|isym
operator|->
name|st_value
operator|==
name|addr
condition|)
return|return
name|TRUE
return|;
name|symcount
operator|=
operator|(
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|end_hashes
operator|=
name|sym_hashes
operator|+
name|symcount
expr_stmt|;
for|for
control|(
init|;
name|sym_hashes
operator|<
name|end_hashes
condition|;
name|sym_hashes
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|sym_hash
init|=
operator|*
name|sym_hashes
decl_stmt|;
if|if
condition|(
operator|(
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|sec
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|==
name|addr
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Adjust all local symbols defined as '.section + 0xXXXX' (.section has sec_shndx)     referenced from current and other sections */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|msp430_elf_relax_adjust_locals
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
name|int
name|count
parameter_list|,
name|unsigned
name|int
name|sec_shndx
parameter_list|,
name|bfd_vma
name|toaddr
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelend
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
expr_stmt|;
name|irelend
operator|=
name|irel
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|isym
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|int
name|sidx
init|=
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|lsym
init|=
name|isym
operator|+
name|sidx
decl_stmt|;
comment|/* Adjust symbols referenced by .sec+0xXX */
if|if
condition|(
name|irel
operator|->
name|r_addend
operator|>
name|addr
operator|&&
name|irel
operator|->
name|r_addend
operator|<
name|toaddr
operator|&&
name|lsym
operator|->
name|st_shndx
operator|==
name|sec_shndx
condition|)
name|irel
operator|->
name|r_addend
operator|-=
name|count
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Delete some bytes from a section while relaxing.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|msp430_elf_relax_delete_bytes
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|unsigned
name|int
name|sec_shndx
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelend
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelalign
decl_stmt|;
name|bfd_vma
name|toaddr
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymend
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|end_hashes
decl_stmt|;
name|unsigned
name|int
name|symcount
decl_stmt|;
name|asection
modifier|*
name|p
decl_stmt|;
name|sec_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
comment|/* The deletion must stop at the next ALIGN reloc for an aligment      power larger than the number of bytes we are deleting.  */
name|irelalign
operator|=
name|NULL
expr_stmt|;
name|toaddr
operator|=
name|sec
operator|->
name|size
expr_stmt|;
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
expr_stmt|;
name|irelend
operator|=
name|irel
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
comment|/* Actually delete the bytes.  */
name|memmove
argument_list|(
name|contents
operator|+
name|addr
argument_list|,
name|contents
operator|+
name|addr
operator|+
name|count
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|toaddr
operator|-
name|addr
operator|-
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|sec
operator|->
name|size
operator|-=
name|count
expr_stmt|;
comment|/* Adjust all the relocs.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|isym
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
comment|/* Get the new reloc address.  */
if|if
condition|(
operator|(
name|irel
operator|->
name|r_offset
operator|>
name|addr
operator|&&
name|irel
operator|->
name|r_offset
operator|<
name|toaddr
operator|)
condition|)
name|irel
operator|->
name|r_offset
operator|-=
name|count
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|abfd
operator|->
name|sections
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|msp430_elf_relax_adjust_locals
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|,
name|addr
argument_list|,
name|count
argument_list|,
name|sec_shndx
argument_list|,
name|toaddr
argument_list|)
expr_stmt|;
comment|/* Adjust the local symbols defined in this section.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|isym
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
for|for
control|(
name|isymend
operator|=
name|isym
operator|+
name|symtab_hdr
operator|->
name|sh_info
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
control|)
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|sec_shndx
operator|&&
name|isym
operator|->
name|st_value
operator|>
name|addr
operator|&&
name|isym
operator|->
name|st_value
operator|<
name|toaddr
condition|)
name|isym
operator|->
name|st_value
operator|-=
name|count
expr_stmt|;
comment|/* Now adjust the global symbols defined in this section.  */
name|symcount
operator|=
operator|(
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|end_hashes
operator|=
name|sym_hashes
operator|+
name|symcount
expr_stmt|;
for|for
control|(
init|;
name|sym_hashes
operator|<
name|end_hashes
condition|;
name|sym_hashes
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|sym_hash
init|=
operator|*
name|sym_hashes
decl_stmt|;
if|if
condition|(
operator|(
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|sec
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|>
name|addr
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|<
name|toaddr
condition|)
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|-=
name|count
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|msp430_elf_relax_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|bfd_boolean
modifier|*
name|again
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelend
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
comment|/* Assume nothing changes.  */
operator|*
name|again
operator|=
name|FALSE
expr_stmt|;
comment|/* We don't have to do anything for a relocatable link, if      this section does not have relocs, or if this is not a      code section.  */
if|if
condition|(
name|link_info
operator|->
name|relocatable
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|sec
operator|->
name|reloc_count
operator|==
literal|0
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
comment|/* Get a copy of the native relocations.  */
name|internal_relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* Walk through them looking for relaxing opportunities.  */
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|symval
decl_stmt|;
comment|/* If this isn't something that can be relaxed, then ignore          this reloc.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_MSP430_RL_PCREL
condition|)
continue|continue;
comment|/* Get the section contents if we haven't done so already.  */
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
block|{
comment|/* Get cached copy if it exists.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|&
name|contents
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Read this BFD's local symbols if we haven't done so already.  */
if|if
condition|(
name|isymbuf
operator|==
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Get the value of the symbol referred to by the reloc.  */
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* A local symbol.  */
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|isym
operator|=
name|isymbuf
operator|+
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|sym_sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|sym_sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|sym_sec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
name|sym_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|symval
operator|=
operator|(
name|isym
operator|->
name|st_value
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sym_sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|indx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* An external symbol.  */
name|indx
operator|=
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
comment|/* This appears to be a reference to an undefined 	       symbol.  Just ignore it--it will be caught by the 	       regular reloc processing.  */
continue|continue;
name|symval
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
comment|/* For simplicity of coding, we are going to modify the section          contents, the section relocs, and the BFD symbol table.  We          must tell the rest of the code not to free up this          information.  It would be possible to instead create a table          of changes which have to be made, as is done in coff-mips.c;          that would be more work, but would require less memory when          the linker is run.  */
comment|/* Try to turn a 16bit pc-relative branch into a 10bit pc-relative          branch.  */
comment|/* Paranoia? paranoia...  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_MSP430_RL_PCREL
condition|)
block|{
name|bfd_vma
name|value
init|=
name|symval
decl_stmt|;
comment|/* Deal with pc-relative gunk.  */
name|value
operator|-=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|irel
operator|->
name|r_offset
expr_stmt|;
name|value
operator|+=
name|irel
operator|->
name|r_addend
expr_stmt|;
comment|/* See if the value will fit in 10 bits, note the high value is 	     1016 as the target will be two bytes closer if we are 	     able to relax. */
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|<
literal|1016
operator|&&
operator|(
name|long
operator|)
name|value
operator|>
operator|-
literal|1016
condition|)
block|{
name|int
name|code0
init|=
literal|0
decl_stmt|,
name|code1
init|=
literal|0
decl_stmt|,
name|code2
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|rcodes_s
modifier|*
name|rx
decl_stmt|;
comment|/* Get the opcode.  */
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|>=
literal|6
condition|)
name|code0
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|>=
literal|4
condition|)
name|code1
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|4
argument_list|)
expr_stmt|;
name|code2
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|code2
operator|!=
literal|0x4010
condition|)
continue|continue;
comment|/* Check r4 and r3.  */
for|for
control|(
name|i
operator|=
name|NUMB_RELAX_CODES
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rx
operator|=
operator|&
name|rcode
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rx
operator|->
name|cdx
operator|==
literal|2
operator|&&
name|rx
operator|->
name|f0
operator|==
name|code0
operator|&&
name|rx
operator|->
name|f1
operator|==
name|code1
condition|)
break|break;
elseif|else
if|if
condition|(
name|rx
operator|->
name|cdx
operator|==
literal|1
operator|&&
name|rx
operator|->
name|f1
operator|==
name|code1
condition|)
break|break;
elseif|else
if|if
condition|(
name|rx
operator|->
name|cdx
operator|==
literal|0
condition|)
comment|/* This is an unconditional jump.  */
break|break;
block|}
comment|/* Check labels: 		   .Label0:       ; we do not care about this label 		      jeq    +6 		   .Label1:       ; make sure there is no label here 		      jl     +4 		   .Label2:       ; make sure there is no label here 		      br .Label_dst  	         So, if there is .Label1 or .Label2 we cannot relax this code. 	         This actually should not happen, cause for relaxable 		 instructions we use RL_PCREL reloc instead of 16_PCREL. 		 Will change this in the future. */
if|if
condition|(
name|rx
operator|->
name|cdx
operator|>
literal|0
operator|&&
name|msp430_elf_symbol_address_p
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|isymbuf
argument_list|,
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|rx
operator|->
name|cdx
operator|>
literal|1
operator|&&
name|msp430_elf_symbol_address_p
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|isymbuf
argument_list|,
name|irel
operator|->
name|r_offset
operator|-
literal|4
argument_list|)
condition|)
continue|continue;
comment|/* Note that we've changed the relocs, section contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Fix the relocation's type.  */
if|if
condition|(
name|rx
operator|->
name|labels
operator|==
literal|3
condition|)
comment|/* Handle special cases.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_MSP430_2X_PCREL
argument_list|)
expr_stmt|;
else|else
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_MSP430_10_PCREL
argument_list|)
expr_stmt|;
comment|/* Fix the opcode right way.  */
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|rx
operator|->
name|t0
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
name|rx
operator|->
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx
operator|->
name|t1
condition|)
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|rx
operator|->
name|t1
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
name|rx
operator|->
name|off
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Delete bytes. */
if|if
condition|(
operator|!
name|msp430_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|-
name|rx
operator|->
name|off
operator|+
name|rx
operator|->
name|ncl
argument_list|,
name|rx
operator|->
name|bs
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Handle unconditional jumps.  */
if|if
condition|(
name|rx
operator|->
name|cdx
operator|==
literal|0
condition|)
name|irel
operator|->
name|r_offset
operator|-=
literal|2
expr_stmt|;
comment|/* That will change things, so, we should relax again. 	         Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the symbols for elf_link_input_bfd.  */
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
block|}
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the section contents for elf_link_input_bfd.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
block|}
block|}
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_msp430
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_MSP430
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT1
value|EM_MSP430_OLD
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|1
end_define

begin_define
define|#
directive|define
name|ELF_OSABI
value|ELFOSABI_STANDALONE
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_msp430_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-msp430"
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|msp430_info_to_howto_rela
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|NULL
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|elf32_msp430_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|elf32_msp430_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
value|bfd_elf_msp430_final_write_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|elf32_msp430_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_post_process_headers
value|_bfd_elf_set_osabi
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_relax_section
value|msp430_elf_relax_section
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

