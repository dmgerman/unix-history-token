begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* SuperH SH64-specific support for 32-bit ELF    Copyright 2000, 2001, 2002, 2003, 2004, 2007    Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_define
define|#
directive|define
name|SH64_ELF
end_define

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/sh.h"
end_include

begin_include
include|#
directive|include
file|"elf32-sh64.h"
end_include

begin_include
include|#
directive|include
file|"../opcodes/sh64-opc.h"
end_include

begin_function_decl
specifier|static
name|bfd_boolean
name|sh64_address_in_cranges
parameter_list|(
name|asection
modifier|*
name|cranges
parameter_list|,
name|bfd_vma
parameter_list|,
name|sh64_elf_crange
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Ordering functions of a crange, for the qsort and bsearch calls and for    different endianness.  */
end_comment

begin_function
name|int
name|_bfd_sh64_crange_qsort_cmpb
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
name|bfd_vma
name|a1
init|=
name|bfd_getb32
argument_list|(
name|p1
argument_list|)
decl_stmt|;
name|bfd_vma
name|a2
init|=
name|bfd_getb32
argument_list|(
name|p2
argument_list|)
decl_stmt|;
comment|/* Preserve order if there's ambiguous contents.  */
if|if
condition|(
name|a1
operator|==
name|a2
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|p1
operator|-
operator|(
name|char
operator|*
operator|)
name|p2
return|;
return|return
name|a1
operator|-
name|a2
return|;
block|}
end_function

begin_function
name|int
name|_bfd_sh64_crange_qsort_cmpl
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
name|bfd_vma
name|a1
init|=
operator|(
name|bfd_vma
operator|)
name|bfd_getl32
argument_list|(
name|p1
argument_list|)
decl_stmt|;
name|bfd_vma
name|a2
init|=
operator|(
name|bfd_vma
operator|)
name|bfd_getl32
argument_list|(
name|p2
argument_list|)
decl_stmt|;
comment|/* Preserve order if there's ambiguous contents.  */
if|if
condition|(
name|a1
operator|==
name|a2
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|p1
operator|-
operator|(
name|char
operator|*
operator|)
name|p2
return|;
return|return
name|a1
operator|-
name|a2
return|;
block|}
end_function

begin_function
name|int
name|_bfd_sh64_crange_bsearch_cmpb
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
name|bfd_vma
name|a1
init|=
operator|*
operator|(
name|bfd_vma
operator|*
operator|)
name|p1
decl_stmt|;
name|bfd_vma
name|a2
init|=
operator|(
name|bfd_vma
operator|)
name|bfd_getb32
argument_list|(
name|p2
argument_list|)
decl_stmt|;
name|bfd_size_type
name|size
init|=
operator|(
name|bfd_size_type
operator|)
name|bfd_getb32
argument_list|(
name|SH64_CRANGE_CR_SIZE_OFFSET
operator|+
operator|(
name|char
operator|*
operator|)
name|p2
argument_list|)
decl_stmt|;
if|if
condition|(
name|a1
operator|>=
name|a2
operator|+
name|size
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a1
operator|<
name|a2
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|_bfd_sh64_crange_bsearch_cmpl
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
name|bfd_vma
name|a1
init|=
operator|*
operator|(
name|bfd_vma
operator|*
operator|)
name|p1
decl_stmt|;
name|bfd_vma
name|a2
init|=
operator|(
name|bfd_vma
operator|)
name|bfd_getl32
argument_list|(
name|p2
argument_list|)
decl_stmt|;
name|bfd_size_type
name|size
init|=
operator|(
name|bfd_size_type
operator|)
name|bfd_getl32
argument_list|(
name|SH64_CRANGE_CR_SIZE_OFFSET
operator|+
operator|(
name|char
operator|*
operator|)
name|p2
argument_list|)
decl_stmt|;
if|if
condition|(
name|a1
operator|>=
name|a2
operator|+
name|size
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a1
operator|<
name|a2
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Check whether a specific address is specified within a .cranges    section.  Return FALSE if not found, and TRUE if found, and the region    filled into RANGEP if non-NULL.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|sh64_address_in_cranges
parameter_list|(
name|asection
modifier|*
name|cranges
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
name|sh64_elf_crange
modifier|*
name|rangep
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|cranges_contents
decl_stmt|;
name|bfd_byte
modifier|*
name|found_rangep
decl_stmt|;
name|bfd_size_type
name|cranges_size
init|=
name|cranges
operator|->
name|size
decl_stmt|;
comment|/* If the size is not a multiple of the cranges entry size, then      something is badly wrong.  */
if|if
condition|(
operator|(
name|cranges_size
operator|%
name|SH64_CRANGE_SIZE
operator|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* If this section has relocations, then we can't do anything sane.  */
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|cranges
operator|->
name|owner
argument_list|,
name|cranges
argument_list|)
operator|&
name|SEC_RELOC
condition|)
return|return
name|FALSE
return|;
comment|/* Has some kind soul (or previous call) left processed, sorted contents      for us?  */
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|cranges
operator|->
name|owner
argument_list|,
name|cranges
argument_list|)
operator|&
name|SEC_IN_MEMORY
operator|)
operator|&&
name|elf_section_data
argument_list|(
name|cranges
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|==
name|SHT_SH5_CR_SORTED
condition|)
name|cranges_contents
operator|=
name|cranges
operator|->
name|contents
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|cranges
operator|->
name|owner
argument_list|,
name|cranges
argument_list|,
operator|&
name|cranges_contents
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Is it sorted?  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|cranges
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|!=
name|SHT_SH5_CR_SORTED
condition|)
comment|/* Nope.  Lets sort it.  */
name|qsort
argument_list|(
name|cranges_contents
argument_list|,
name|cranges_size
operator|/
name|SH64_CRANGE_SIZE
argument_list|,
name|SH64_CRANGE_SIZE
argument_list|,
name|bfd_big_endian
argument_list|(
name|cranges
operator|->
name|owner
argument_list|)
condition|?
name|_bfd_sh64_crange_qsort_cmpb
else|:
name|_bfd_sh64_crange_qsort_cmpl
argument_list|)
expr_stmt|;
comment|/* Let's keep it around.  */
name|cranges
operator|->
name|contents
operator|=
name|cranges_contents
expr_stmt|;
name|bfd_set_section_flags
argument_list|(
name|cranges
operator|->
name|owner
argument_list|,
name|cranges
argument_list|,
name|bfd_get_section_flags
argument_list|(
name|cranges
operator|->
name|owner
argument_list|,
name|cranges
argument_list|)
operator||
name|SEC_IN_MEMORY
argument_list|)
expr_stmt|;
comment|/* It's sorted now.  */
name|elf_section_data
argument_list|(
name|cranges
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|=
name|SHT_SH5_CR_SORTED
expr_stmt|;
block|}
comment|/* Try and find a matching range.  */
name|found_rangep
operator|=
name|bsearch
argument_list|(
operator|&
name|addr
argument_list|,
name|cranges_contents
argument_list|,
name|cranges_size
operator|/
name|SH64_CRANGE_SIZE
argument_list|,
name|SH64_CRANGE_SIZE
argument_list|,
name|bfd_big_endian
argument_list|(
name|cranges
operator|->
name|owner
argument_list|)
condition|?
name|_bfd_sh64_crange_bsearch_cmpb
else|:
name|_bfd_sh64_crange_bsearch_cmpl
argument_list|)
expr_stmt|;
comment|/* Fill in a few return values if we found a matching range.  */
if|if
condition|(
name|found_rangep
condition|)
block|{
name|enum
name|sh64_elf_cr_type
name|cr_type
init|=
name|bfd_get_16
argument_list|(
name|cranges
operator|->
name|owner
argument_list|,
name|SH64_CRANGE_CR_TYPE_OFFSET
operator|+
name|found_rangep
argument_list|)
decl_stmt|;
name|bfd_vma
name|cr_addr
init|=
name|bfd_get_32
argument_list|(
name|cranges
operator|->
name|owner
argument_list|,
name|SH64_CRANGE_CR_ADDR_OFFSET
operator|+
operator|(
name|char
operator|*
operator|)
name|found_rangep
argument_list|)
decl_stmt|;
name|bfd_size_type
name|cr_size
init|=
name|bfd_get_32
argument_list|(
name|cranges
operator|->
name|owner
argument_list|,
name|SH64_CRANGE_CR_SIZE_OFFSET
operator|+
operator|(
name|char
operator|*
operator|)
name|found_rangep
argument_list|)
decl_stmt|;
name|rangep
operator|->
name|cr_addr
operator|=
name|cr_addr
expr_stmt|;
name|rangep
operator|->
name|cr_size
operator|=
name|cr_size
expr_stmt|;
name|rangep
operator|->
name|cr_type
operator|=
name|cr_type
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* There is a .cranges section, but it does not have a descriptor      matching this address.  */
return|return
name|FALSE
return|;
name|error_return
label|:
if|if
condition|(
name|cranges_contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cranges_contents
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Determine what ADDR points to in SEC, and fill in a range descriptor in    *RANGEP if it's non-NULL.  */
end_comment

begin_function
name|enum
name|sh64_elf_cr_type
name|sh64_get_contents_type
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
name|sh64_elf_crange
modifier|*
name|rangep
parameter_list|)
block|{
name|asection
modifier|*
name|cranges
decl_stmt|;
comment|/* Fill in the range with the boundaries of the section as a default.  */
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|&&
name|elf_elfheader
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|->
name|e_type
operator|==
name|ET_EXEC
condition|)
block|{
name|rangep
operator|->
name|cr_addr
operator|=
name|bfd_get_section_vma
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|rangep
operator|->
name|cr_size
operator|=
name|sec
operator|->
name|size
expr_stmt|;
name|rangep
operator|->
name|cr_type
operator|=
name|CRT_NONE
expr_stmt|;
block|}
else|else
return|return
name|FALSE
return|;
comment|/* If none of the pertinent bits are set, then it's a SHcompact (or at      least not SHmedia).  */
if|if
condition|(
operator|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_flags
operator|&
operator|(
name|SHF_SH5_ISA32
operator||
name|SHF_SH5_ISA32_MIXED
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|enum
name|sh64_elf_cr_type
name|cr_type
init|=
operator|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|?
name|CRT_SH5_ISA16
else|:
name|CRT_DATA
operator|)
decl_stmt|;
name|rangep
operator|->
name|cr_type
operator|=
name|cr_type
expr_stmt|;
return|return
name|cr_type
return|;
block|}
comment|/* If only the SHF_SH5_ISA32 bit is set, then we have SHmedia.  */
if|if
condition|(
operator|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_flags
operator|&
operator|(
name|SHF_SH5_ISA32
operator||
name|SHF_SH5_ISA32_MIXED
operator|)
operator|)
operator|==
name|SHF_SH5_ISA32
condition|)
block|{
name|rangep
operator|->
name|cr_type
operator|=
name|CRT_SH5_ISA32
expr_stmt|;
return|return
name|CRT_SH5_ISA32
return|;
block|}
comment|/* Otherwise, we have to look up the .cranges section.  */
name|cranges
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|SH64_CRANGES_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|cranges
operator|==
name|NULL
condition|)
comment|/* A mixed section but there's no .cranges section.  This is probably        bad input; it does not comply to specs.  */
return|return
name|CRT_NONE
return|;
comment|/* If this call fails, we will still have CRT_NONE in rangep->cr_type      and that will be suitable to return.  */
name|sh64_address_in_cranges
argument_list|(
name|cranges
argument_list|,
name|addr
argument_list|,
name|rangep
argument_list|)
expr_stmt|;
return|return
name|rangep
operator|->
name|cr_type
return|;
block|}
end_function

begin_comment
comment|/* This is a simpler exported interface for the benefit of gdb et al.  */
end_comment

begin_function
name|bfd_boolean
name|sh64_address_is_shmedia
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|addr
parameter_list|)
block|{
name|sh64_elf_crange
name|dummy
decl_stmt|;
return|return
name|sh64_get_contents_type
argument_list|(
name|sec
argument_list|,
name|addr
argument_list|,
operator|&
name|dummy
argument_list|)
operator|==
name|CRT_SH5_ISA32
return|;
block|}
end_function

end_unit

