begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* MeP-specific support for 32-bit ELF.    Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/mep.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_comment
comment|/* Private relocation functions.  */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|MEPREL
parameter_list|(
name|type
parameter_list|,
name|size
parameter_list|,
name|bits
parameter_list|,
name|right
parameter_list|,
name|left
parameter_list|,
name|pcrel
parameter_list|,
name|overflow
parameter_list|,
name|mask
parameter_list|)
define|\
value|{(unsigned)type, right, size, bits, pcrel, left, overflow, mep_reloc, #type, FALSE, 0, mask, 0 }
end_define

begin_define
define|#
directive|define
name|N
value|complain_overflow_dont
end_define

begin_define
define|#
directive|define
name|S
value|complain_overflow_signed
end_define

begin_define
define|#
directive|define
name|U
value|complain_overflow_unsigned
end_define

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|mep_reloc
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|struct
name|bfd_symbol
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|mep_elf_howto_table
index|[]
init|=
block|{
comment|/* type, size, bits, leftshift, rightshift, pcrel, OD/OS/OU, mask.  */
name|MEPREL
argument_list|(
name|R_MEP_NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|N
argument_list|,
literal|0
argument_list|)
block|,
name|MEPREL
argument_list|(
name|R_RELC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|N
argument_list|,
literal|0
argument_list|)
block|,
comment|/* MEPRELOC:HOWTO */
comment|/* This section generated from bfd/mep-relocs.pl from include/elf/mep.h.  */
name|MEPREL
argument_list|(
name|R_MEP_8
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|U
argument_list|,
literal|0xff
argument_list|)
block|,
name|MEPREL
argument_list|(
name|R_MEP_16
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|U
argument_list|,
literal|0xffff
argument_list|)
block|,
name|MEPREL
argument_list|(
name|R_MEP_32
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|U
argument_list|,
literal|0xffffffff
argument_list|)
block|,
name|MEPREL
argument_list|(
name|R_MEP_PCREL8A2
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|S
argument_list|,
literal|0x00fe
argument_list|)
block|,
name|MEPREL
argument_list|(
name|R_MEP_PCREL12A2
argument_list|,
literal|1
argument_list|,
literal|12
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|S
argument_list|,
literal|0x0ffe
argument_list|)
block|,
name|MEPREL
argument_list|(
name|R_MEP_PCREL17A2
argument_list|,
literal|2
argument_list|,
literal|17
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|S
argument_list|,
literal|0x0000ffff
argument_list|)
block|,
name|MEPREL
argument_list|(
name|R_MEP_PCREL24A2
argument_list|,
literal|2
argument_list|,
literal|24
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|S
argument_list|,
literal|0x07f0ffff
argument_list|)
block|,
name|MEPREL
argument_list|(
name|R_MEP_PCABS24A2
argument_list|,
literal|2
argument_list|,
literal|24
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|U
argument_list|,
literal|0x07f0ffff
argument_list|)
block|,
name|MEPREL
argument_list|(
name|R_MEP_LOW16
argument_list|,
literal|2
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|N
argument_list|,
literal|0x0000ffff
argument_list|)
block|,
name|MEPREL
argument_list|(
name|R_MEP_HI16U
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|,
name|N
argument_list|,
literal|0x0000ffff
argument_list|)
block|,
name|MEPREL
argument_list|(
name|R_MEP_HI16S
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|,
name|N
argument_list|,
literal|0x0000ffff
argument_list|)
block|,
name|MEPREL
argument_list|(
name|R_MEP_GPREL
argument_list|,
literal|2
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|S
argument_list|,
literal|0x0000ffff
argument_list|)
block|,
name|MEPREL
argument_list|(
name|R_MEP_TPREL
argument_list|,
literal|2
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|S
argument_list|,
literal|0x0000ffff
argument_list|)
block|,
name|MEPREL
argument_list|(
name|R_MEP_TPREL7
argument_list|,
literal|1
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|U
argument_list|,
literal|0x007f
argument_list|)
block|,
name|MEPREL
argument_list|(
name|R_MEP_TPREL7A2
argument_list|,
literal|1
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|U
argument_list|,
literal|0x007e
argument_list|)
block|,
name|MEPREL
argument_list|(
name|R_MEP_TPREL7A4
argument_list|,
literal|1
argument_list|,
literal|7
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|U
argument_list|,
literal|0x007c
argument_list|)
block|,
name|MEPREL
argument_list|(
name|R_MEP_UIMM24
argument_list|,
literal|2
argument_list|,
literal|24
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|U
argument_list|,
literal|0x00ffffff
argument_list|)
block|,
name|MEPREL
argument_list|(
name|R_MEP_ADDR24A4
argument_list|,
literal|2
argument_list|,
literal|24
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|U
argument_list|,
literal|0x00fcffff
argument_list|)
block|,
name|MEPREL
argument_list|(
name|R_MEP_GNU_VTINHERIT
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|,
literal|32
argument_list|,
literal|0
argument_list|,
name|N
argument_list|,
literal|0x0000
argument_list|)
block|,
name|MEPREL
argument_list|(
name|R_MEP_GNU_VTENTRY
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|,
literal|32
argument_list|,
literal|0
argument_list|,
name|N
argument_list|,
literal|0x0000
argument_list|)
block|,
comment|/* MEPRELOC:END */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VALID_MEP_RELOC
parameter_list|(
name|N
parameter_list|)
value|((N)>= 0 \&& (N)< ARRAY_SIZE (mep_elf_howto_table)
end_define

begin_undef
undef|#
directive|undef
name|N
end_undef

begin_undef
undef|#
directive|undef
name|S
end_undef

begin_undef
undef|#
directive|undef
name|U
end_undef

begin_function
specifier|static
name|bfd_reloc_status_type
name|mep_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_symbol
modifier|*
name|symbol
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|input_section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|BFD_RELOC_MEP_NONE
value|BFD_RELOC_NONE
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|ALMOST_STDC
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_STRINGIZE
argument_list|)
end_if

begin_define
define|#
directive|define
name|MAP
parameter_list|(
name|n
parameter_list|)
value|case BFD_RELOC_MEP_##n: type = R_MEP_##n; break
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAP
parameter_list|(
name|n
parameter_list|)
value|case BFD_RELOC_MEP_
comment|/**/
value|n: type = R_MEP_
comment|/**/
value|n; break
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|mep_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
name|unsigned
name|int
name|type
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
name|MAP
argument_list|(
name|NONE
argument_list|)
expr_stmt|;
case|case
name|BFD_RELOC_8
case|:
name|type
operator|=
name|R_MEP_8
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16
case|:
name|type
operator|=
name|R_MEP_16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
name|type
operator|=
name|R_MEP_32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
name|type
operator|=
name|R_MEP_GNU_VTENTRY
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
name|type
operator|=
name|R_MEP_GNU_VTINHERIT
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_RELC
case|:
name|type
operator|=
name|R_RELC
expr_stmt|;
break|break;
comment|/* MEPRELOC:MAP */
comment|/* This section generated from bfd/mep-relocs.pl from include/elf/mep.h.  */
name|MAP
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
name|PCREL8A2
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
name|PCREL12A2
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
name|PCREL17A2
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
name|PCREL24A2
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
name|PCABS24A2
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
name|LOW16
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
name|HI16U
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
name|HI16S
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
name|GPREL
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
name|TPREL
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
name|TPREL7
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
name|TPREL7A2
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
name|TPREL7A4
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
name|UIMM24
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
name|ADDR24A4
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
name|GNU_VTINHERIT
argument_list|)
expr_stmt|;
name|MAP
argument_list|(
name|GNU_VTENTRY
argument_list|)
expr_stmt|;
comment|/* MEPRELOC:END */
default|default:
comment|/* Pacify gcc -Wall.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mep: no reloc for code %d\n"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|mep_elf_howto_table
index|[
name|type
index|]
operator|.
name|type
operator|!=
name|type
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"MeP: howto %d has type %d\n"
argument_list|,
name|type
argument_list|,
name|mep_elf_howto_table
index|[
name|type
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|mep_elf_howto_table
operator|+
name|type
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|MAP
end_undef

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|mep_reloc_name_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|r_name
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|mep_elf_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mep_elf_howto_table
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mep_elf_howto_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcasecmp
argument_list|(
name|mep_elf_howto_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|mep_elf_howto_table
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform a single relocation.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bfd_link_info
modifier|*
name|mep_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|warn_tp
init|=
literal|0
decl_stmt|,
name|warn_sda
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_vma
name|mep_lookup_global
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|bfd_vma
name|ofs
parameter_list|,
name|bfd_vma
modifier|*
name|cache
parameter_list|,
name|int
modifier|*
name|warn
parameter_list|)
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
if|if
condition|(
operator|*
name|cache
operator|||
operator|*
name|warn
condition|)
return|return
operator|*
name|cache
return|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|mep_info
operator|->
name|hash
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
literal|0
operator|||
name|h
operator|->
name|type
operator|!=
name|bfd_link_hash_defined
condition|)
block|{
operator|*
name|warn
operator|=
name|ofs
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|cache
operator|=
operator|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
return|return
operator|*
name|cache
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|mep_tpoff_base
parameter_list|(
name|bfd_vma
name|ofs
parameter_list|)
block|{
specifier|static
name|bfd_vma
name|cache
init|=
literal|0
decl_stmt|;
return|return
name|mep_lookup_global
argument_list|(
literal|"__tpbase"
argument_list|,
name|ofs
argument_list|,
operator|&
name|cache
argument_list|,
operator|&
name|warn_tp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_vma
name|mep_sdaoff_base
parameter_list|(
name|bfd_vma
name|ofs
parameter_list|)
block|{
specifier|static
name|bfd_vma
name|cache
init|=
literal|0
decl_stmt|;
return|return
name|mep_lookup_global
argument_list|(
literal|"__sdabase"
argument_list|,
name|ofs
argument_list|,
operator|&
name|cache
argument_list|,
operator|&
name|warn_sda
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|mep_final_link_relocate
parameter_list|(
name|reloc_howto_type
modifier|*
name|howto
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|bfd_vma
name|relocation
parameter_list|)
block|{
name|unsigned
name|long
name|u
decl_stmt|;
name|long
name|s
decl_stmt|;
name|unsigned
name|char
modifier|*
name|byte
decl_stmt|;
name|bfd_vma
name|pc
decl_stmt|;
name|bfd_reloc_status_type
name|r
init|=
name|bfd_reloc_ok
decl_stmt|;
name|int
name|e2
decl_stmt|,
name|e4
decl_stmt|;
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
name|e2
operator|=
literal|0
expr_stmt|;
name|e4
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|e2
operator|=
literal|1
expr_stmt|;
name|e4
operator|=
literal|3
expr_stmt|;
block|}
name|pc
operator|=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|rel
operator|->
name|r_offset
operator|)
expr_stmt|;
name|s
operator|=
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
name|byte
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|contents
operator|+
name|rel
operator|->
name|r_offset
expr_stmt|;
if|if
condition|(
name|howto
operator|->
name|type
operator|==
name|R_MEP_PCREL24A2
operator|&&
name|s
operator|==
literal|0
operator|&&
name|pc
operator|>=
literal|0x800000
condition|)
block|{
comment|/* This is an unreachable branch to an undefined weak function. 	 Silently ignore it, since the opcode can't do that but should 	 never be executed anyway.  */
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|howto
operator|->
name|pc_relative
condition|)
name|s
operator|-=
name|pc
expr_stmt|;
name|u
operator|=
operator|(
name|unsigned
name|long
operator|)
name|s
expr_stmt|;
switch|switch
condition|(
name|howto
operator|->
name|type
condition|)
block|{
comment|/* MEPRELOC:APPLY */
comment|/* This section generated from bfd/mep-relocs.pl from include/elf/mep.h.  */
case|case
name|R_MEP_8
case|:
comment|/* 76543210 */
if|if
condition|(
name|u
operator|>
literal|255
condition|)
name|r
operator|=
name|bfd_reloc_overflow
expr_stmt|;
name|byte
index|[
literal|0
index|]
operator|=
operator|(
name|u
operator|&
literal|0xff
operator|)
expr_stmt|;
break|break;
case|case
name|R_MEP_16
case|:
comment|/* fedcba9876543210 */
if|if
condition|(
name|u
operator|>
literal|65535
condition|)
name|r
operator|=
name|bfd_reloc_overflow
expr_stmt|;
name|byte
index|[
literal|0
operator|^
name|e2
index|]
operator|=
operator|(
operator|(
name|u
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|byte
index|[
literal|1
operator|^
name|e2
index|]
operator|=
operator|(
name|u
operator|&
literal|0xff
operator|)
expr_stmt|;
break|break;
case|case
name|R_MEP_32
case|:
comment|/* vutsrqponmlkjihgfedcba9876543210 */
name|byte
index|[
literal|0
operator|^
name|e4
index|]
operator|=
operator|(
operator|(
name|u
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|byte
index|[
literal|1
operator|^
name|e4
index|]
operator|=
operator|(
operator|(
name|u
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|byte
index|[
literal|2
operator|^
name|e4
index|]
operator|=
operator|(
operator|(
name|u
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|byte
index|[
literal|3
operator|^
name|e4
index|]
operator|=
operator|(
name|u
operator|&
literal|0xff
operator|)
expr_stmt|;
break|break;
case|case
name|R_MEP_PCREL8A2
case|:
comment|/* --------7654321- */
if|if
condition|(
operator|-
literal|128
operator|>
name|s
operator|||
name|s
operator|>
literal|127
condition|)
name|r
operator|=
name|bfd_reloc_overflow
expr_stmt|;
name|byte
index|[
literal|1
operator|^
name|e2
index|]
operator|=
operator|(
name|byte
index|[
literal|1
operator|^
name|e2
index|]
operator|&
literal|0x01
operator|)
operator||
operator|(
name|s
operator|&
literal|0xfe
operator|)
expr_stmt|;
break|break;
case|case
name|R_MEP_PCREL12A2
case|:
comment|/* ----ba987654321- */
if|if
condition|(
operator|-
literal|2048
operator|>
name|s
operator|||
name|s
operator|>
literal|2047
condition|)
name|r
operator|=
name|bfd_reloc_overflow
expr_stmt|;
name|byte
index|[
literal|0
operator|^
name|e2
index|]
operator|=
operator|(
name|byte
index|[
literal|0
operator|^
name|e2
index|]
operator|&
literal|0xf0
operator|)
operator||
operator|(
operator|(
name|s
operator|>>
literal|8
operator|)
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|byte
index|[
literal|1
operator|^
name|e2
index|]
operator|=
operator|(
name|byte
index|[
literal|1
operator|^
name|e2
index|]
operator|&
literal|0x01
operator|)
operator||
operator|(
name|s
operator|&
literal|0xfe
operator|)
expr_stmt|;
break|break;
case|case
name|R_MEP_PCREL17A2
case|:
comment|/* ----------------gfedcba987654321 */
if|if
condition|(
operator|-
literal|65536
operator|>
name|s
operator|||
name|s
operator|>
literal|65535
condition|)
name|r
operator|=
name|bfd_reloc_overflow
expr_stmt|;
name|byte
index|[
literal|2
operator|^
name|e2
index|]
operator|=
operator|(
operator|(
name|s
operator|>>
literal|9
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|byte
index|[
literal|3
operator|^
name|e2
index|]
operator|=
operator|(
operator|(
name|s
operator|>>
literal|1
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
break|break;
case|case
name|R_MEP_PCREL24A2
case|:
comment|/* -----7654321----nmlkjihgfedcba98 */
if|if
condition|(
operator|-
literal|8388608
operator|>
name|s
operator|||
name|s
operator|>
literal|8388607
condition|)
name|r
operator|=
name|bfd_reloc_overflow
expr_stmt|;
name|byte
index|[
literal|0
operator|^
name|e2
index|]
operator|=
operator|(
name|byte
index|[
literal|0
operator|^
name|e2
index|]
operator|&
literal|0xf8
operator|)
operator||
operator|(
operator|(
name|s
operator|>>
literal|5
operator|)
operator|&
literal|0x07
operator|)
expr_stmt|;
name|byte
index|[
literal|1
operator|^
name|e2
index|]
operator|=
operator|(
name|byte
index|[
literal|1
operator|^
name|e2
index|]
operator|&
literal|0x0f
operator|)
operator||
operator|(
operator|(
name|s
operator|<<
literal|3
operator|)
operator|&
literal|0xf0
operator|)
expr_stmt|;
name|byte
index|[
literal|2
operator|^
name|e2
index|]
operator|=
operator|(
operator|(
name|s
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|byte
index|[
literal|3
operator|^
name|e2
index|]
operator|=
operator|(
operator|(
name|s
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
break|break;
case|case
name|R_MEP_PCABS24A2
case|:
comment|/* -----7654321----nmlkjihgfedcba98 */
if|if
condition|(
name|u
operator|>
literal|16777215
condition|)
name|r
operator|=
name|bfd_reloc_overflow
expr_stmt|;
name|byte
index|[
literal|0
operator|^
name|e2
index|]
operator|=
operator|(
name|byte
index|[
literal|0
operator|^
name|e2
index|]
operator|&
literal|0xf8
operator|)
operator||
operator|(
operator|(
name|u
operator|>>
literal|5
operator|)
operator|&
literal|0x07
operator|)
expr_stmt|;
name|byte
index|[
literal|1
operator|^
name|e2
index|]
operator|=
operator|(
name|byte
index|[
literal|1
operator|^
name|e2
index|]
operator|&
literal|0x0f
operator|)
operator||
operator|(
operator|(
name|u
operator|<<
literal|3
operator|)
operator|&
literal|0xf0
operator|)
expr_stmt|;
name|byte
index|[
literal|2
operator|^
name|e2
index|]
operator|=
operator|(
operator|(
name|u
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|byte
index|[
literal|3
operator|^
name|e2
index|]
operator|=
operator|(
operator|(
name|u
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
break|break;
case|case
name|R_MEP_LOW16
case|:
comment|/* ----------------fedcba9876543210 */
name|byte
index|[
literal|2
operator|^
name|e2
index|]
operator|=
operator|(
operator|(
name|u
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|byte
index|[
literal|3
operator|^
name|e2
index|]
operator|=
operator|(
name|u
operator|&
literal|0xff
operator|)
expr_stmt|;
break|break;
case|case
name|R_MEP_HI16U
case|:
comment|/* ----------------vutsrqponmlkjihg */
name|byte
index|[
literal|2
operator|^
name|e2
index|]
operator|=
operator|(
operator|(
name|u
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|byte
index|[
literal|3
operator|^
name|e2
index|]
operator|=
operator|(
operator|(
name|u
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
break|break;
case|case
name|R_MEP_HI16S
case|:
comment|/* ----------------vutsrqponmlkjihg */
name|byte
index|[
literal|2
operator|^
name|e2
index|]
operator|=
operator|(
operator|(
name|s
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|byte
index|[
literal|3
operator|^
name|e2
index|]
operator|=
operator|(
operator|(
name|s
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
break|break;
case|case
name|R_MEP_GPREL
case|:
comment|/* ----------------fedcba9876543210 */
name|s
operator|-=
name|mep_sdaoff_base
argument_list|(
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|32768
operator|>
name|s
operator|||
name|s
operator|>
literal|32767
condition|)
name|r
operator|=
name|bfd_reloc_overflow
expr_stmt|;
name|byte
index|[
literal|2
operator|^
name|e2
index|]
operator|=
operator|(
operator|(
name|s
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|byte
index|[
literal|3
operator|^
name|e2
index|]
operator|=
operator|(
name|s
operator|&
literal|0xff
operator|)
expr_stmt|;
break|break;
case|case
name|R_MEP_TPREL
case|:
comment|/* ----------------fedcba9876543210 */
name|s
operator|-=
name|mep_tpoff_base
argument_list|(
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|32768
operator|>
name|s
operator|||
name|s
operator|>
literal|32767
condition|)
name|r
operator|=
name|bfd_reloc_overflow
expr_stmt|;
name|byte
index|[
literal|2
operator|^
name|e2
index|]
operator|=
operator|(
operator|(
name|s
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|byte
index|[
literal|3
operator|^
name|e2
index|]
operator|=
operator|(
name|s
operator|&
literal|0xff
operator|)
expr_stmt|;
break|break;
case|case
name|R_MEP_TPREL7
case|:
comment|/* ---------6543210 */
name|u
operator|-=
name|mep_tpoff_base
argument_list|(
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|>
literal|127
condition|)
name|r
operator|=
name|bfd_reloc_overflow
expr_stmt|;
name|byte
index|[
literal|1
operator|^
name|e2
index|]
operator|=
operator|(
name|byte
index|[
literal|1
operator|^
name|e2
index|]
operator|&
literal|0x80
operator|)
operator||
operator|(
name|u
operator|&
literal|0x7f
operator|)
expr_stmt|;
break|break;
case|case
name|R_MEP_TPREL7A2
case|:
comment|/* ---------654321- */
name|u
operator|-=
name|mep_tpoff_base
argument_list|(
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|>
literal|127
condition|)
name|r
operator|=
name|bfd_reloc_overflow
expr_stmt|;
name|byte
index|[
literal|1
operator|^
name|e2
index|]
operator|=
operator|(
name|byte
index|[
literal|1
operator|^
name|e2
index|]
operator|&
literal|0x81
operator|)
operator||
operator|(
name|u
operator|&
literal|0x7e
operator|)
expr_stmt|;
break|break;
case|case
name|R_MEP_TPREL7A4
case|:
comment|/* ---------65432-- */
name|u
operator|-=
name|mep_tpoff_base
argument_list|(
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|>
literal|127
condition|)
name|r
operator|=
name|bfd_reloc_overflow
expr_stmt|;
name|byte
index|[
literal|1
operator|^
name|e2
index|]
operator|=
operator|(
name|byte
index|[
literal|1
operator|^
name|e2
index|]
operator|&
literal|0x83
operator|)
operator||
operator|(
name|u
operator|&
literal|0x7c
operator|)
expr_stmt|;
break|break;
case|case
name|R_MEP_UIMM24
case|:
comment|/* --------76543210nmlkjihgfedcba98 */
if|if
condition|(
name|u
operator|>
literal|16777215
condition|)
name|r
operator|=
name|bfd_reloc_overflow
expr_stmt|;
name|byte
index|[
literal|1
operator|^
name|e2
index|]
operator|=
operator|(
name|u
operator|&
literal|0xff
operator|)
expr_stmt|;
name|byte
index|[
literal|2
operator|^
name|e2
index|]
operator|=
operator|(
operator|(
name|u
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|byte
index|[
literal|3
operator|^
name|e2
index|]
operator|=
operator|(
operator|(
name|u
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
break|break;
case|case
name|R_MEP_ADDR24A4
case|:
comment|/* --------765432--nmlkjihgfedcba98 */
if|if
condition|(
name|u
operator|>
literal|16777215
condition|)
name|r
operator|=
name|bfd_reloc_overflow
expr_stmt|;
name|byte
index|[
literal|1
operator|^
name|e2
index|]
operator|=
operator|(
name|byte
index|[
literal|1
operator|^
name|e2
index|]
operator|&
literal|0x03
operator|)
operator||
operator|(
name|u
operator|&
literal|0xfc
operator|)
expr_stmt|;
name|byte
index|[
literal|2
operator|^
name|e2
index|]
operator|=
operator|(
operator|(
name|u
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|byte
index|[
literal|3
operator|^
name|e2
index|]
operator|=
operator|(
operator|(
name|u
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
break|break;
case|case
name|R_MEP_GNU_VTINHERIT
case|:
comment|/* ---------------- */
break|break;
case|case
name|R_MEP_GNU_VTENTRY
case|:
comment|/* ---------------- */
break|break;
comment|/* MEPRELOC:END */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the howto pointer for a MEP ELF reloc.  */
end_comment

begin_function
specifier|static
name|void
name|mep_info_to_howto_rela
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|cache_ptr
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|dst
parameter_list|)
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|mep_elf_howto_table
index|[
name|r_type
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase.    Since we don't do .gots or .plts, we just need to consider the    virtual table relocs for gc.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mep_elf_check_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes_end
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_hashes_end
operator|=
name|sym_hashes
operator|+
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|sym_hashes_end
operator|-=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Relocate a MEP ELF section.    There is some attempt to make this function usable for many architectures,    both USE_REL and USE_RELA ['twould be nice if such a critter existed],    if only to serve as a learning tool.     The RELOCATE_SECTION function is called by the new ELF backend linker    to handle the relocations for a section.     The relocs are always passed as Rela structures; if the section    actually uses Rel structures, the r_addend field will always be    zero.     This function is responsible for adjusting the section contents as    necessary, and (if using Rela relocs and generating a relocatable    output file) adjusting the reloc addend as necessary.     This function does not have to worry about setting the reloc    address or the reloc symbol index.     LOCAL_SYMS is a pointer to the swapped in local symbols.     LOCAL_SECTIONS is an array giving the section in the input file    corresponding to the st_shndx field of each local symbol.     The global hash table entry for the global symbols can be found    via elf_sym_hashes (input_bfd).     When generating relocatable output, this function must handle    STB_LOCAL/STT_SECTION symbols specially.  The output symbol is    going to be the section symbol corresponding to the output    section, which means that the addend must be adjusted    accordingly.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mep_elf_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
name|mep_info
operator|=
name|info
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
comment|/* Is this a complex relocation?  */
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_RELC
condition|)
block|{
name|bfd_elf_perform_complex_relocation
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
argument_list|,
name|local_syms
argument_list|,
name|local_sections
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|howto
operator|=
name|mep_elf_howto_table
operator|+
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|name
operator|==
name|NULL
operator|)
condition|?
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
else|:
name|name
expr_stmt|;
if|#
directive|if
literal|0
block|fprintf (stderr, "local: sec: %s, sym: %s (%d), value: %x + %x + %x addend %x\n", 		   sec->name, name, sym->st_name, 		   sec->output_section->vma, sec->output_offset, 		   sym->st_value, rel->r_addend);
endif|#
directive|endif
block|}
else|else
block|{
name|relocation
operator|=
literal|0
expr_stmt|;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
if|#
directive|if
literal|0
block|fprintf (stderr, 		       "defined: sec: %s, name: %s, value: %x + %x + %x gives: %x\n", 		       sec->name, name, h->root.u.def.value, 		       sec->output_section->vma, sec->output_offset, relocation);
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
if|#
directive|if
literal|0
block|fprintf (stderr, "undefined: sec: %s, name: %s\n", 		       sec->name, name);
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
name|info
operator|->
name|unresolved_syms_in_objects
operator|==
name|RM_GENERATE_ERROR
operator|)
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
if|#
directive|if
literal|0
block|fprintf (stderr, "unknown: name: %s\n", name);
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|elf_discarded_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
comment|/* For relocs against symbols from removed linkonce sections, 	     or sections discarded by a linker script, we just want the 	     section contents zeroed.  Avoid any special processing.  */
name|_bfd_clear_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
block|{
comment|/* This is a relocatable link.  We don't have to change              anything, unless the reloc is against a section symbol,              in which case we have to adjust according to where the              section symbol winds up in the output section.  */
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
name|rel
operator|->
name|r_addend
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
name|r
operator|=
name|mep_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_overflow
case|:
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
argument_list|(
name|info
argument_list|,
operator|(
name|h
condition|?
operator|&
name|h
operator|->
name|root
else|:
name|NULL
operator|)
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_undefined
case|:
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: out of range error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_notsupported
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unsupported relocation error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_dangerous
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: dangerous relocation"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unknown error"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|msg
condition|)
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|warn_tp
condition|)
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
argument_list|(
name|info
argument_list|,
literal|"__tpbase"
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|warn_tp
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_sda
condition|)
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
argument_list|(
name|info
argument_list|,
literal|"__sdabase"
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|warn_sda
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_sda
operator|||
name|warn_tp
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Update the got entry reference counts for the section being    removed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mep_elf_gc_sweep_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return the section that should be marked against GC for a given    relocation.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|mep_elf_gc_mark_hook
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
default|default:
break|break;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|elf_bad_symtab
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|&&
name|ELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STB_LOCAL
operator|)
operator|&&
operator|!
operator|(
operator|(
name|sym
operator|->
name|st_shndx
operator|<=
literal|0
operator|||
name|sym
operator|->
name|st_shndx
operator|>=
name|SHN_LORESERVE
operator|)
operator|&&
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_COMMON
operator|)
condition|)
return|return
name|bfd_section_from_elf_index
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Function to set the ELF flag bits.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mep_elf_set_private_flags
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|flagword
name|flags
parameter_list|)
block|{
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|mep_elf_copy_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
comment|/* Copy object attributes.  */
name|_bfd_elf_copy_obj_attributes
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mep_elf_merge_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
specifier|static
name|bfd
modifier|*
name|last_ibfd
init|=
literal|0
decl_stmt|;
name|flagword
name|old_flags
decl_stmt|,
name|new_flags
decl_stmt|;
name|flagword
name|old_partial
decl_stmt|,
name|new_partial
decl_stmt|;
comment|/* Check if we have the same endianess.  */
if|if
condition|(
name|_bfd_generic_verify_endian_match
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
operator|==
name|FALSE
condition|)
return|return
name|FALSE
return|;
name|new_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|old_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|_bfd_error_handler
argument_list|(
literal|"%B: old_flags = 0x%.8lx, new_flags = 0x%.8lx, init = %s"
argument_list|,
name|ibfd
argument_list|,
name|old_flags
argument_list|,
name|new_flags
argument_list|,
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* First call, no flags set.  */
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
name|old_flags
operator|=
name|new_flags
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|new_flags
operator||
name|old_flags
operator|)
operator|&
name|EF_MEP_LIBRARY
condition|)
block|{
comment|/* Non-library flags trump library flags.  The choice doesn't really 	 matter if both OLD_FLAGS and NEW_FLAGS have EF_MEP_LIBRARY set.  */
if|if
condition|(
name|old_flags
operator|&
name|EF_MEP_LIBRARY
condition|)
name|old_flags
operator|=
name|new_flags
expr_stmt|;
block|}
else|else
block|{
comment|/* Make sure they're for the same mach.  Allow upgrade from the "mep" 	 mach.  */
name|new_partial
operator|=
operator|(
name|new_flags
operator|&
name|EF_MEP_CPU_MASK
operator|)
expr_stmt|;
name|old_partial
operator|=
operator|(
name|old_flags
operator|&
name|EF_MEP_CPU_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|new_partial
operator|==
name|old_partial
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|new_partial
operator|==
name|EF_MEP_CPU_MEP
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|old_partial
operator|==
name|EF_MEP_CPU_MEP
condition|)
name|old_flags
operator|=
operator|(
name|old_flags
operator|&
operator|~
name|EF_MEP_CPU_MASK
operator|)
operator||
name|new_partial
expr_stmt|;
else|else
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"%B and %B are for different cores"
argument_list|)
argument_list|,
name|last_ibfd
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_target
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Make sure they're for the same me_module.  Allow basic config to 	 mix with any other.  */
name|new_partial
operator|=
operator|(
name|new_flags
operator|&
name|EF_MEP_INDEX_MASK
operator|)
expr_stmt|;
name|old_partial
operator|=
operator|(
name|old_flags
operator|&
name|EF_MEP_INDEX_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|new_partial
operator|==
name|old_partial
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|new_partial
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|old_partial
operator|==
literal|0
condition|)
name|old_flags
operator|=
operator|(
name|old_flags
operator|&
operator|~
name|EF_MEP_INDEX_MASK
operator|)
operator||
name|new_partial
expr_stmt|;
else|else
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"%B and %B are for different configurations"
argument_list|)
argument_list|,
name|last_ibfd
argument_list|,
name|ibfd
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_target
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|old_flags
expr_stmt|;
name|last_ibfd
operator|=
name|ibfd
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This will be edited by the MeP configration tool.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|config_names
index|[]
init|=
block|{
literal|"basic"
comment|/* start-mepcfgtool */
block|,
literal|"simple"
block|,
literal|"fmax"
comment|/* end-mepcfgtool */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|core_names
index|[]
init|=
block|{
literal|"MeP"
block|,
literal|"MeP-c2"
block|,
literal|"MeP-c3"
block|,
literal|"MeP-h1"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_boolean
name|mep_elf_print_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|ptr
decl_stmt|;
name|flagword
name|flags
decl_stmt|,
name|partial_flags
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|abfd
operator|!=
name|NULL
operator|&&
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Print normal ELF private data.  */
name|_bfd_elf_print_private_bfd_data
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|flags
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"private flags = 0x%lx"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|flags
argument_list|)
expr_stmt|;
name|partial_flags
operator|=
operator|(
name|flags
operator|&
name|EF_MEP_CPU_MASK
operator|)
operator|>>
literal|24
expr_stmt|;
if|if
condition|(
name|partial_flags
operator|<
name|ARRAY_SIZE
argument_list|(
name|core_names
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  core: %s"
argument_list|,
name|core_names
index|[
operator|(
name|long
operator|)
name|partial_flags
index|]
argument_list|)
expr_stmt|;
name|partial_flags
operator|=
name|flags
operator|&
name|EF_MEP_INDEX_MASK
expr_stmt|;
if|if
condition|(
name|partial_flags
operator|<
name|ARRAY_SIZE
argument_list|(
name|config_names
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  me_module: %s"
argument_list|,
name|config_names
index|[
operator|(
name|long
operator|)
name|partial_flags
index|]
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return the machine subcode from the ELF e_flags header.  */
end_comment

begin_function
specifier|static
name|int
name|elf32_mep_machine
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
switch|switch
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_MEP_CPU_MASK
condition|)
block|{
default|default:
break|break;
case|case
name|EF_MEP_CPU_C2
case|:
return|return
name|bfd_mach_mep
return|;
case|case
name|EF_MEP_CPU_C3
case|:
return|return
name|bfd_mach_mep
return|;
case|case
name|EF_MEP_CPU_C4
case|:
return|return
name|bfd_mach_mep
return|;
case|case
name|EF_MEP_CPU_H1
case|:
return|return
name|bfd_mach_mep_h1
return|;
block|}
return|return
name|bfd_mach_mep
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|mep_elf_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
comment|/* Irix 5 and 6 is broken.  Object file symbol tables are not always      sorted correctly such that local symbols preceed global symbols,      and the sh_info field in the symbol table is not always right.  */
comment|/* This is needed for the RELC support code.  */
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_mep
argument_list|,
name|elf32_mep_machine
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|mep_elf_section_flags
parameter_list|(
name|flagword
modifier|*
name|flags
parameter_list|,
specifier|const
name|Elf_Internal_Shdr
modifier|*
name|hdr
parameter_list|)
block|{
if|if
condition|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_MEP_VLIW
condition|)
operator|*
name|flags
operator||=
name|SEC_MEP_VLIW
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|mep_elf_fake_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|hdr
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|)
block|{
if|if
condition|(
name|sec
operator|->
name|flags
operator|&
name|SEC_MEP_VLIW
condition|)
name|hdr
operator|->
name|sh_flags
operator||=
name|SHF_MEP_VLIW
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_mep
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_CYGNUS_MEP
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1000
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_mep_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-mep"
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_mep_little_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-mep-little"
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|NULL
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|mep_info_to_howto_rela
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|mep_elf_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|mep_elf_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|mep_elf_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|mep_elf_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|mep_elf_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_section_flags
value|mep_elf_section_flags
end_define

begin_define
define|#
directive|define
name|elf_backend_fake_sections
value|mep_elf_fake_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|mep_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_name_lookup
value|mep_reloc_name_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_set_private_flags
value|mep_elf_set_private_flags
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_copy_private_bfd_data
value|mep_elf_copy_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_merge_private_bfd_data
value|mep_elf_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_print_private_bfd_data
value|mep_elf_print_private_bfd_data
end_define

begin_comment
comment|/* We use only the RELA entries.  */
end_comment

begin_define
define|#
directive|define
name|USE_RELA
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

