begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* FRV-specific support for 32-bit ELF.    Copyright 2002, 2003, 2004, 2005, 2006  Free Software Foundation, Inc.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/frv.h"
end_include

begin_include
include|#
directive|include
file|"elf/dwarf2.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|elf32_frv_relocate_lo16
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|elf32_frv_relocate_hi16
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|elf32_frv_relocate_label24
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|elf32_frv_relocate_gprel12
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|elf32_frv_relocate_gprelu12
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|elf32_frv_relocate_gprello
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|elf32_frv_relocate_gprelhi
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|frv_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|frv_info_to_howto_rela
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf32_frv_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf32_frv_add_symbol_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|flagword
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|frv_final_link_relocate
name|PARAMS
argument_list|(
operator|(
name|reloc_howto_type
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf32_frv_gc_sweep_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|elf32_frv_gc_mark_hook
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf32_frv_check_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elf32_frv_machine
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf32_frv_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|frv_elf_set_private_flags
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|flagword
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|frv_elf_copy_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|frv_elf_merge_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|frv_elf_print_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|bfd_boolean
name|elf32_frv_grok_prstatus
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|elf32_frv_grok_psinfo
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf32_frv_howto_table
index|[]
init|=
block|{
comment|/* This reloc does nothing.  */
name|HOWTO
argument_list|(
name|R_FRV_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_NONE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32 bit absolute relocation.  */
name|HOWTO
argument_list|(
name|R_FRV_32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit pc-relative relocation.  */
name|HOWTO
argument_list|(
name|R_FRV_LABEL16
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_LABEL16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 24-bit pc-relative relocation.  */
name|HOWTO
argument_list|(
name|R_FRV_LABEL24
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_LABEL24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x7e03ffff
argument_list|,
comment|/* src_mask */
literal|0x7e03ffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_FRV_LO16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_LO16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_FRV_HI16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_HI16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_FRV_GPREL12
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_GPREL12"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xfff
argument_list|,
comment|/* src_mask */
literal|0xfff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_FRV_GPRELU12
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_GPRELU12"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xfff
argument_list|,
comment|/* src_mask */
literal|0x3f03f
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_FRV_GPREL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_GPREL32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_FRV_GPRELHI
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_GPRELHI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_FRV_GPRELLO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_GPRELLO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 12-bit signed operand with the GOT offset for the address of      the symbol.  */
name|HOWTO
argument_list|(
name|R_FRV_GOT12
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_GOT12"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xfff
argument_list|,
comment|/* src_mask */
literal|0xfff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The upper 16 bits of the GOT offset for the address of the      symbol.  */
name|HOWTO
argument_list|(
name|R_FRV_GOTHI
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_GOTHI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The lower 16 bits of the GOT offset for the address of the      symbol.  */
name|HOWTO
argument_list|(
name|R_FRV_GOTLO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_GOTLO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The 32-bit address of the canonical descriptor of a function.  */
name|HOWTO
argument_list|(
name|R_FRV_FUNCDESC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_FUNCDESC"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 12-bit signed operand with the GOT offset for the address of      canonical descriptor of a function.  */
name|HOWTO
argument_list|(
name|R_FRV_FUNCDESC_GOT12
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_FUNCDESC_GOT12"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xfff
argument_list|,
comment|/* src_mask */
literal|0xfff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The upper 16 bits of the GOT offset for the address of the      canonical descriptor of a function.  */
name|HOWTO
argument_list|(
name|R_FRV_FUNCDESC_GOTHI
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_FUNCDESC_GOTHI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The lower 16 bits of the GOT offset for the address of the      canonical descriptor of a function.  */
name|HOWTO
argument_list|(
name|R_FRV_FUNCDESC_GOTLO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_FUNCDESC_GOTLO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The 64-bit descriptor of a function.  */
name|HOWTO
argument_list|(
name|R_FRV_FUNCDESC_VALUE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_FUNCDESC_VALUE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 12-bit signed operand with the GOT offset for the address of      canonical descriptor of a function.  */
name|HOWTO
argument_list|(
name|R_FRV_FUNCDESC_GOTOFF12
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_FUNCDESC_GOTOFF12"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xfff
argument_list|,
comment|/* src_mask */
literal|0xfff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The upper 16 bits of the GOT offset for the address of the      canonical descriptor of a function.  */
name|HOWTO
argument_list|(
name|R_FRV_FUNCDESC_GOTOFFHI
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_FUNCDESC_GOTOFFHI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The lower 16 bits of the GOT offset for the address of the      canonical descriptor of a function.  */
name|HOWTO
argument_list|(
name|R_FRV_FUNCDESC_GOTOFFLO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_FUNCDESC_GOTOFFLO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 12-bit signed operand with the GOT offset for the address of      the symbol.  */
name|HOWTO
argument_list|(
name|R_FRV_GOTOFF12
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_GOTOFF12"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xfff
argument_list|,
comment|/* src_mask */
literal|0xfff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The upper 16 bits of the GOT offset for the address of the      symbol.  */
name|HOWTO
argument_list|(
name|R_FRV_GOTOFFHI
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_GOTOFFHI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The lower 16 bits of the GOT offset for the address of the      symbol.  */
name|HOWTO
argument_list|(
name|R_FRV_GOTOFFLO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_GOTOFFLO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 24-bit pc-relative relocation referencing the TLS PLT entry for      a thread-local symbol.  If the symbol number is 0, it refers to      the module.  */
name|HOWTO
argument_list|(
name|R_FRV_GETTLSOFF
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|26
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_GETTLSOFF"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x7e03ffff
argument_list|,
comment|/* src_mask */
literal|0x7e03ffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 64-bit TLS descriptor for a symbol.  This relocation is only      valid as a REL, dynamic relocation.  */
name|HOWTO
argument_list|(
name|R_FRV_TLSDESC_VALUE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_TLSDESC_VALUE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 12-bit signed operand with the GOT offset for the TLS      descriptor of the symbol.  */
name|HOWTO
argument_list|(
name|R_FRV_GOTTLSDESC12
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_GOTTLSDESC12"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xfff
argument_list|,
comment|/* src_mask */
literal|0xfff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The upper 16 bits of the GOT offset for the TLS descriptor of the      symbol.  */
name|HOWTO
argument_list|(
name|R_FRV_GOTTLSDESCHI
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_GOTTLSDESCHI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The lower 16 bits of the GOT offset for the TLS descriptor of the      symbol.  */
name|HOWTO
argument_list|(
name|R_FRV_GOTTLSDESCLO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_GOTTLSDESCLO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 12-bit signed operand with the offset from the module base      address to the thread-local symbol address.  */
name|HOWTO
argument_list|(
name|R_FRV_TLSMOFF12
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_TLSMOFF12"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xfff
argument_list|,
comment|/* src_mask */
literal|0xfff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The upper 16 bits of the offset from the module base address to      the thread-local symbol address.  */
name|HOWTO
argument_list|(
name|R_FRV_TLSMOFFHI
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_TLSMOFFHI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The lower 16 bits of the offset from the module base address to      the thread-local symbol address.  */
name|HOWTO
argument_list|(
name|R_FRV_TLSMOFFLO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_TLSMOFFLO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 12-bit signed operand with the GOT offset for the TLSOFF entry      for a symbol.  */
name|HOWTO
argument_list|(
name|R_FRV_GOTTLSOFF12
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_GOTTLSOFF12"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xfff
argument_list|,
comment|/* src_mask */
literal|0xfff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The upper 16 bits of the GOT offset for the TLSOFF entry for a      symbol.  */
name|HOWTO
argument_list|(
name|R_FRV_GOTTLSOFFHI
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_GOTTLSOFFHI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The lower 16 bits of the GOT offset for the TLSOFF entry for a      symbol.  */
name|HOWTO
argument_list|(
name|R_FRV_GOTTLSOFFLO
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_GOTTLSOFFLO"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* The 32-bit offset from the thread pointer (not the module base      address) to a thread-local symbol.  */
name|HOWTO
argument_list|(
name|R_FRV_TLSOFF
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_TLSOFF"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An annotation for linker relaxation, that denotes the      symbol+addend whose TLS descriptor is referenced by the sum of      the two input registers of an ldd instruction.  */
name|HOWTO
argument_list|(
name|R_FRV_TLSDESC_RELAX
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_TLSDESC_RELAX"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An annotation for linker relaxation, that denotes the      symbol+addend whose TLS resolver entry point is given by the sum      of the two register operands of an calll instruction.  */
name|HOWTO
argument_list|(
name|R_FRV_GETTLSOFF_RELAX
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_GETTLSOFF_RELAX"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An annotation for linker relaxation, that denotes the      symbol+addend whose TLS offset GOT entry is given by the sum of      the two input registers of an ld instruction.  */
name|HOWTO
argument_list|(
name|R_FRV_TLSOFF_RELAX
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_TLSOFF_RELAX"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32-bit offset from the module base address to      the thread-local symbol address.  */
name|HOWTO
argument_list|(
name|R_FRV_TLSMOFF
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_TLSMOFF"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* GNU extension to record C++ vtable hierarchy.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf32_frv_vtinherit_howto
init|=
name|HOWTO
argument_list|(
name|R_FRV_GNU_VTINHERIT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_FRV_GNU_VTINHERIT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcrel_offset */
end_comment

begin_comment
comment|/* GNU extension to record C++ vtable member usage.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf32_frv_vtentry_howto
init|=
name|HOWTO
argument_list|(
name|R_FRV_GNU_VTENTRY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_elf_rel_vtable_reloc_fn
argument_list|,
comment|/* special_function */
literal|"R_FRV_GNU_VTENTRY"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcrel_offset */
end_comment

begin_comment
comment|/* The following 3 relocations are REL.  The only difference to the    entries in the table above are that partial_inplace is TRUE.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf32_frv_rel_32_howto
init|=
name|HOWTO
argument_list|(
name|R_FRV_32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_32"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcrel_offset */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf32_frv_rel_funcdesc_howto
init|=
name|HOWTO
argument_list|(
name|R_FRV_FUNCDESC
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_FUNCDESC"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcrel_offset */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf32_frv_rel_funcdesc_value_howto
init|=
name|HOWTO
argument_list|(
name|R_FRV_FUNCDESC_VALUE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_FUNCDESC_VALUE"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcrel_offset */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf32_frv_rel_tlsdesc_value_howto
init|=
comment|/* A 64-bit TLS descriptor for a symbol.  The first word resolves to      an entry point, and the second resolves to a special argument.      If the symbol turns out to be in static TLS, the entry point is a      return instruction, and the special argument is the TLS offset      for the symbol.  If it's in dynamic TLS, the entry point is a TLS      offset resolver, and the special argument is a pointer to a data      structure allocated by the dynamic loader, containing the GOT      address for the offset resolver, the module id, the offset within      the module, and anything else the TLS offset resolver might need      to determine the TLS offset for the symbol in the running      thread.  */
name|HOWTO
argument_list|(
name|R_FRV_TLSDESC_VALUE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|64
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_TLSDESC_VALUE"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcrel_offset */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf32_frv_rel_tlsoff_howto
init|=
comment|/* The 32-bit offset from the thread pointer (not the module base      address) to a thread-local symbol.  */
name|HOWTO
argument_list|(
name|R_FRV_TLSOFF
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_FRV_TLSOFF"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pcrel_offset */
end_comment

begin_escape
end_escape

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
name|bfd_elf32_frvfdpic_vec
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IS_FDPIC
parameter_list|(
name|bfd
parameter_list|)
value|((bfd)->xvec ==&bfd_elf32_frvfdpic_vec)
end_define

begin_comment
comment|/* An extension of the elf hash table data structure, containing some    additional FRV-specific data.  */
end_comment

begin_struct
struct|struct
name|frvfdpic_elf_link_hash_table
block|{
name|struct
name|elf_link_hash_table
name|elf
decl_stmt|;
comment|/* A pointer to the .got section.  */
name|asection
modifier|*
name|sgot
decl_stmt|;
comment|/* A pointer to the .rel.got section.  */
name|asection
modifier|*
name|sgotrel
decl_stmt|;
comment|/* A pointer to the .rofixup section.  */
name|asection
modifier|*
name|sgotfixup
decl_stmt|;
comment|/* A pointer to the .plt section.  */
name|asection
modifier|*
name|splt
decl_stmt|;
comment|/* A pointer to the .rel.plt section.  */
name|asection
modifier|*
name|spltrel
decl_stmt|;
comment|/* GOT base offset.  */
name|bfd_vma
name|got0
decl_stmt|;
comment|/* Location of the first non-lazy PLT entry, i.e., the number of      bytes taken by lazy PLT entries.  If locally-bound TLS      descriptors require a ret instruction, it will be placed at this      offset.  */
name|bfd_vma
name|plt0
decl_stmt|;
comment|/* A hash table holding information about which symbols were      referenced with which PIC-related relocations.  */
name|struct
name|htab
modifier|*
name|relocs_info
decl_stmt|;
comment|/* Summary reloc information collected by      _frvfdpic_count_got_plt_entries.  */
name|struct
name|_frvfdpic_dynamic_got_info
modifier|*
name|g
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Get the FRV ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|frvfdpic_hash_table
parameter_list|(
name|info
parameter_list|)
define|\
value|((struct frvfdpic_elf_link_hash_table *) ((info)->hash))
end_define

begin_define
define|#
directive|define
name|frvfdpic_got_section
parameter_list|(
name|info
parameter_list|)
define|\
value|(frvfdpic_hash_table (info)->sgot)
end_define

begin_define
define|#
directive|define
name|frvfdpic_gotrel_section
parameter_list|(
name|info
parameter_list|)
define|\
value|(frvfdpic_hash_table (info)->sgotrel)
end_define

begin_define
define|#
directive|define
name|frvfdpic_gotfixup_section
parameter_list|(
name|info
parameter_list|)
define|\
value|(frvfdpic_hash_table (info)->sgotfixup)
end_define

begin_define
define|#
directive|define
name|frvfdpic_plt_section
parameter_list|(
name|info
parameter_list|)
define|\
value|(frvfdpic_hash_table (info)->splt)
end_define

begin_define
define|#
directive|define
name|frvfdpic_pltrel_section
parameter_list|(
name|info
parameter_list|)
define|\
value|(frvfdpic_hash_table (info)->spltrel)
end_define

begin_define
define|#
directive|define
name|frvfdpic_relocs_info
parameter_list|(
name|info
parameter_list|)
define|\
value|(frvfdpic_hash_table (info)->relocs_info)
end_define

begin_define
define|#
directive|define
name|frvfdpic_got_initial_offset
parameter_list|(
name|info
parameter_list|)
define|\
value|(frvfdpic_hash_table (info)->got0)
end_define

begin_define
define|#
directive|define
name|frvfdpic_plt_initial_offset
parameter_list|(
name|info
parameter_list|)
define|\
value|(frvfdpic_hash_table (info)->plt0)
end_define

begin_define
define|#
directive|define
name|frvfdpic_dynamic_got_plt_info
parameter_list|(
name|info
parameter_list|)
define|\
value|(frvfdpic_hash_table (info)->g)
end_define

begin_comment
comment|/* Currently it's the same, but if some day we have a reason to change    it, we'd better be using a different macro.     FIXME: if there's any TLS PLT entry that uses local-exec or    initial-exec models, we could use the ret at the end of any of them    instead of adding one more.  */
end_comment

begin_define
define|#
directive|define
name|frvfdpic_plt_tls_ret_offset
parameter_list|(
name|info
parameter_list|)
define|\
value|(frvfdpic_plt_initial_offset (info))
end_define

begin_comment
comment|/* The name of the dynamic interpreter.  This is put in the .interp    section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/lib/ld.so.1"
end_define

begin_define
define|#
directive|define
name|DEFAULT_STACK_SIZE
value|0x20000
end_define

begin_comment
comment|/* This structure is used to collect the number of entries present in    each addressable range of the got.  */
end_comment

begin_struct
struct|struct
name|_frvfdpic_dynamic_got_info
block|{
comment|/* Several bits of information about the current link.  */
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
comment|/* Total GOT size needed for GOT entries within the 12-, 16- or 32-bit      ranges.  */
name|bfd_vma
name|got12
decl_stmt|,
name|gotlos
decl_stmt|,
name|gothilo
decl_stmt|;
comment|/* Total GOT size needed for function descriptor entries within the 12-,      16- or 32-bit ranges.  */
name|bfd_vma
name|fd12
decl_stmt|,
name|fdlos
decl_stmt|,
name|fdhilo
decl_stmt|;
comment|/* Total GOT size needed by function descriptor entries referenced      in PLT entries, that would be profitable to place in offsets      close to the PIC register.  */
name|bfd_vma
name|fdplt
decl_stmt|;
comment|/* Total PLT size needed by lazy PLT entries.  */
name|bfd_vma
name|lzplt
decl_stmt|;
comment|/* Total GOT size needed for TLS descriptor entries within the 12-,      16- or 32-bit ranges.  */
name|bfd_vma
name|tlsd12
decl_stmt|,
name|tlsdlos
decl_stmt|,
name|tlsdhilo
decl_stmt|;
comment|/* Total GOT size needed by TLS descriptors referenced in PLT      entries, that would be profitable to place in offers close to the      PIC register.  */
name|bfd_vma
name|tlsdplt
decl_stmt|;
comment|/* Total PLT size needed by TLS lazy PLT entries.  */
name|bfd_vma
name|tlslzplt
decl_stmt|;
comment|/* Number of relocations carried over from input object files.  */
name|unsigned
name|long
name|relocs
decl_stmt|;
comment|/* Number of fixups introduced by relocations in input object files.  */
name|unsigned
name|long
name|fixups
decl_stmt|;
comment|/* The number of fixups that reference the ret instruction added to      the PLT for locally-resolved TLS descriptors.  */
name|unsigned
name|long
name|tls_ret_refs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure is used to assign offsets to got entries, function    descriptors, plt entries and lazy plt entries.  */
end_comment

begin_struct
struct|struct
name|_frvfdpic_dynamic_got_plt_info
block|{
comment|/* Summary information collected with _frvfdpic_count_got_plt_entries.  */
name|struct
name|_frvfdpic_dynamic_got_info
name|g
decl_stmt|;
comment|/* For each addressable range, we record a MAX (positive) and MIN      (negative) value.  CUR is used to assign got entries, and it's      incremented from an initial positive value to MAX, then from MIN      to FDCUR (unless FDCUR wraps around first).  FDCUR is used to      assign function descriptors, and it's decreased from an initial      non-positive value to MIN, then from MAX down to CUR (unless CUR      wraps around first).  All of MIN, MAX, CUR and FDCUR always point      to even words.  ODD, if non-zero, indicates an odd word to be      used for the next got entry, otherwise CUR is used and      incremented by a pair of words, wrapping around when it reaches      MAX.  FDCUR is decremented (and wrapped) before the next function      descriptor is chosen.  FDPLT indicates the number of remaining      slots that can be used for function descriptors used only by PLT      entries.       TMAX, TMIN and TCUR are used to assign TLS descriptors.  TCUR      starts as MAX, and grows up to TMAX, then wraps around to TMIN      and grows up to MIN.  TLSDPLT indicates the number of remaining      slots that can be used for TLS descriptors used only by TLS PLT      entries.  */
struct|struct
name|_frvfdpic_dynamic_got_alloc_data
block|{
name|bfd_signed_vma
name|max
decl_stmt|,
name|cur
decl_stmt|,
name|odd
decl_stmt|,
name|fdcur
decl_stmt|,
name|min
decl_stmt|;
name|bfd_signed_vma
name|tmax
decl_stmt|,
name|tcur
decl_stmt|,
name|tmin
decl_stmt|;
name|bfd_vma
name|fdplt
decl_stmt|,
name|tlsdplt
decl_stmt|;
block|}
name|got12
struct|,
name|gotlos
struct|,
name|gothilo
struct|;
block|}
struct|;
end_struct

begin_comment
comment|/* Create an FRV ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|frvfdpic_elf_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|frvfdpic_elf_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|frvfdpic_elf_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|elf
argument_list|,
name|abfd
argument_list|,
name|_bfd_elf_link_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_hash_entry
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|&
name|ret
operator|->
name|elf
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Decide whether a reference to a symbol can be resolved locally or    not.  If the symbol is protected, we want the local address, but    its function descriptor must be assigned by the dynamic linker.  */
end_comment

begin_define
define|#
directive|define
name|FRVFDPIC_SYM_LOCAL
parameter_list|(
name|INFO
parameter_list|,
name|H
parameter_list|)
define|\
value|(_bfd_elf_symbol_refs_local_p ((H), (INFO), 1) \    || ! elf_hash_table (INFO)->dynamic_sections_created)
end_define

begin_define
define|#
directive|define
name|FRVFDPIC_FUNCDESC_LOCAL
parameter_list|(
name|INFO
parameter_list|,
name|H
parameter_list|)
define|\
value|((H)->dynindx == -1 || ! elf_hash_table (INFO)->dynamic_sections_created)
end_define

begin_comment
comment|/* This structure collects information on what kind of GOT, PLT or    function descriptors are required by relocations that reference a    certain symbol.  */
end_comment

begin_struct
struct|struct
name|frvfdpic_relocs_info
block|{
comment|/* The index of the symbol, as stored in the relocation r_info, if      we have a local symbol; -1 otherwise.  */
name|long
name|symndx
decl_stmt|;
union|union
block|{
comment|/* The input bfd in which the symbol is defined, if it's a local        symbol.  */
name|bfd
modifier|*
name|abfd
decl_stmt|;
comment|/* If symndx == -1, the hash table entry corresponding to a global        symbol (even if it turns out to bind locally, in which case it        should ideally be replaced with section's symndx + addend).  */
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|}
name|d
union|;
comment|/* The addend of the relocation that references the symbol.  */
name|bfd_vma
name|addend
decl_stmt|;
comment|/* The fields above are used to identify an entry.  The fields below      contain information on how an entry is used and, later on, which      locations it was assigned.  */
comment|/* The following 3 fields record whether the symbol+addend above was      ever referenced with a GOT relocation.  The 12 suffix indicates a      GOT12 relocation; los is used for GOTLO relocations that are not      matched by a GOTHI relocation; hilo is used for GOTLO/GOTHI      pairs.  */
name|unsigned
name|got12
range|:
literal|1
decl_stmt|;
name|unsigned
name|gotlos
range|:
literal|1
decl_stmt|;
name|unsigned
name|gothilo
range|:
literal|1
decl_stmt|;
comment|/* Whether a FUNCDESC relocation references symbol+addend.  */
name|unsigned
name|fd
range|:
literal|1
decl_stmt|;
comment|/* Whether a FUNCDESC_GOT relocation references symbol+addend.  */
name|unsigned
name|fdgot12
range|:
literal|1
decl_stmt|;
name|unsigned
name|fdgotlos
range|:
literal|1
decl_stmt|;
name|unsigned
name|fdgothilo
range|:
literal|1
decl_stmt|;
comment|/* Whether a FUNCDESC_GOTOFF relocation references symbol+addend.  */
name|unsigned
name|fdgoff12
range|:
literal|1
decl_stmt|;
name|unsigned
name|fdgofflos
range|:
literal|1
decl_stmt|;
name|unsigned
name|fdgoffhilo
range|:
literal|1
decl_stmt|;
comment|/* Whether a GETTLSOFF relocation references symbol+addend.  */
name|unsigned
name|tlsplt
range|:
literal|1
decl_stmt|;
comment|/* FIXME: we should probably add tlspltdesc, tlspltoff and      tlspltimm, to tell what kind of TLS PLT entry we're generating.      We might instead just pre-compute flags telling whether the      object is suitable for local exec, initial exec or general      dynamic addressing, and use that all over the place.  We could      also try to do a better job of merging TLSOFF and TLSDESC entries      in main executables, but perhaps we can get rid of TLSDESC      entirely in them instead.  */
comment|/* Whether a GOTTLSDESC relocation references symbol+addend.  */
name|unsigned
name|tlsdesc12
range|:
literal|1
decl_stmt|;
name|unsigned
name|tlsdesclos
range|:
literal|1
decl_stmt|;
name|unsigned
name|tlsdeschilo
range|:
literal|1
decl_stmt|;
comment|/* Whether a GOTTLSOFF relocation references symbol+addend.  */
name|unsigned
name|tlsoff12
range|:
literal|1
decl_stmt|;
name|unsigned
name|tlsofflos
range|:
literal|1
decl_stmt|;
name|unsigned
name|tlsoffhilo
range|:
literal|1
decl_stmt|;
comment|/* Whether symbol+addend is referenced with GOTOFF12, GOTOFFLO or      GOTOFFHI relocations.  The addend doesn't really matter, since we      envision that this will only be used to check whether the symbol      is mapped to the same segment as the got.  */
name|unsigned
name|gotoff
range|:
literal|1
decl_stmt|;
comment|/* Whether symbol+addend is referenced by a LABEL24 relocation.  */
name|unsigned
name|call
range|:
literal|1
decl_stmt|;
comment|/* Whether symbol+addend is referenced by a 32 or FUNCDESC_VALUE      relocation.  */
name|unsigned
name|sym
range|:
literal|1
decl_stmt|;
comment|/* Whether we need a PLT entry for a symbol.  Should be implied by      something like:      (call&& symndx == -1&& ! FRVFDPIC_SYM_LOCAL (info, d.h))  */
name|unsigned
name|plt
range|:
literal|1
decl_stmt|;
comment|/* Whether a function descriptor should be created in this link unit      for symbol+addend.  Should be implied by something like:      (plt || fdgotoff12 || fdgotofflos || fdgotofflohi       || ((fd || fdgot12 || fdgotlos || fdgothilo)&& (symndx != -1 || FRVFDPIC_FUNCDESC_LOCAL (info, d.h))))  */
name|unsigned
name|privfd
range|:
literal|1
decl_stmt|;
comment|/* Whether a lazy PLT entry is needed for this symbol+addend.      Should be implied by something like:      (privfd&& symndx == -1&& ! FRVFDPIC_SYM_LOCAL (info, d.h)&& ! (info->flags& DF_BIND_NOW))  */
name|unsigned
name|lazyplt
range|:
literal|1
decl_stmt|;
comment|/* Whether we've already emitted GOT relocations and PLT entries as      needed for this symbol.  */
name|unsigned
name|done
range|:
literal|1
decl_stmt|;
comment|/* The number of R_FRV_32, R_FRV_FUNCDESC, R_FRV_FUNCDESC_VALUE and      R_FRV_TLSDESC_VALUE, R_FRV_TLSOFF relocations referencing      symbol+addend.  */
name|unsigned
name|relocs32
decl_stmt|,
name|relocsfd
decl_stmt|,
name|relocsfdv
decl_stmt|,
name|relocstlsd
decl_stmt|,
name|relocstlsoff
decl_stmt|;
comment|/* The number of .rofixups entries and dynamic relocations allocated      for this symbol, minus any that might have already been used.  */
name|unsigned
name|fixups
decl_stmt|,
name|dynrelocs
decl_stmt|;
comment|/* The offsets of the GOT entries assigned to symbol+addend, to the      function descriptor's address, and to a function descriptor,      respectively.  Should be zero if unassigned.  The offsets are      counted from the value that will be assigned to the PIC register,      not from the beginning of the .got section.  */
name|bfd_signed_vma
name|got_entry
decl_stmt|,
name|fdgot_entry
decl_stmt|,
name|fd_entry
decl_stmt|;
comment|/* The offsets of the PLT entries assigned to symbol+addend,      non-lazy and lazy, respectively.  If unassigned, should be      (bfd_vma)-1.  */
name|bfd_vma
name|plt_entry
decl_stmt|,
name|lzplt_entry
decl_stmt|;
comment|/* The offsets of the GOT entries for TLS offset and TLS descriptor.  */
name|bfd_signed_vma
name|tlsoff_entry
decl_stmt|,
name|tlsdesc_entry
decl_stmt|;
comment|/* The offset of the TLS offset PLT entry.  */
name|bfd_vma
name|tlsplt_entry
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Compute a hash with the key fields of an frvfdpic_relocs_info entry.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|frvfdpic_relocs_info_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|entry_
parameter_list|)
block|{
specifier|const
name|struct
name|frvfdpic_relocs_info
modifier|*
name|entry
init|=
name|entry_
decl_stmt|;
return|return
operator|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
condition|?
operator|(
name|long
operator|)
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|hash
else|:
name|entry
operator|->
name|symndx
operator|+
operator|(
name|long
operator|)
name|entry
operator|->
name|d
operator|.
name|abfd
operator|->
name|id
operator|*
literal|257
operator|)
operator|+
name|entry
operator|->
name|addend
return|;
block|}
end_function

begin_comment
comment|/* Test whether the key fields of two frvfdpic_relocs_info entries are    identical.  */
end_comment

begin_function
specifier|static
name|int
name|frvfdpic_relocs_info_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|entry1
parameter_list|,
specifier|const
name|void
modifier|*
name|entry2
parameter_list|)
block|{
specifier|const
name|struct
name|frvfdpic_relocs_info
modifier|*
name|e1
init|=
name|entry1
decl_stmt|;
specifier|const
name|struct
name|frvfdpic_relocs_info
modifier|*
name|e2
init|=
name|entry2
decl_stmt|;
return|return
name|e1
operator|->
name|symndx
operator|==
name|e2
operator|->
name|symndx
operator|&&
name|e1
operator|->
name|addend
operator|==
name|e2
operator|->
name|addend
operator|&&
operator|(
name|e1
operator|->
name|symndx
operator|==
operator|-
literal|1
condition|?
name|e1
operator|->
name|d
operator|.
name|h
operator|==
name|e2
operator|->
name|d
operator|.
name|h
else|:
name|e1
operator|->
name|d
operator|.
name|abfd
operator|==
name|e2
operator|->
name|d
operator|.
name|abfd
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find or create an entry in a hash table HT that matches the key    fields of the given ENTRY.  If it's not found, memory for a new    entry is allocated in ABFD's obstack.  */
end_comment

begin_function
specifier|static
name|struct
name|frvfdpic_relocs_info
modifier|*
name|frvfdpic_relocs_info_find
parameter_list|(
name|struct
name|htab
modifier|*
name|ht
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
specifier|const
name|struct
name|frvfdpic_relocs_info
modifier|*
name|entry
parameter_list|,
name|enum
name|insert_option
name|insert
parameter_list|)
block|{
name|struct
name|frvfdpic_relocs_info
modifier|*
modifier|*
name|loc
init|=
operator|(
expr|struct
name|frvfdpic_relocs_info
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|ht
argument_list|,
name|entry
argument_list|,
name|insert
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|loc
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
name|loc
condition|)
return|return
operator|*
name|loc
return|;
operator|*
name|loc
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|loc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|loc
condition|)
return|return
operator|*
name|loc
return|;
operator|(
operator|*
name|loc
operator|)
operator|->
name|symndx
operator|=
name|entry
operator|->
name|symndx
expr_stmt|;
operator|(
operator|*
name|loc
operator|)
operator|->
name|d
operator|=
name|entry
operator|->
name|d
expr_stmt|;
operator|(
operator|*
name|loc
operator|)
operator|->
name|addend
operator|=
name|entry
operator|->
name|addend
expr_stmt|;
operator|(
operator|*
name|loc
operator|)
operator|->
name|plt_entry
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
operator|(
operator|*
name|loc
operator|)
operator|->
name|lzplt_entry
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
operator|(
operator|*
name|loc
operator|)
operator|->
name|tlsplt_entry
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
return|return
operator|*
name|loc
return|;
block|}
end_function

begin_comment
comment|/* Obtain the address of the entry in HT associated with H's symbol +    addend, creating a new entry if none existed.  ABFD is only used    for memory allocation purposes.  */
end_comment

begin_function
specifier|inline
specifier|static
name|struct
name|frvfdpic_relocs_info
modifier|*
name|frvfdpic_relocs_info_for_global
parameter_list|(
name|struct
name|htab
modifier|*
name|ht
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|bfd_vma
name|addend
parameter_list|,
name|enum
name|insert_option
name|insert
parameter_list|)
block|{
name|struct
name|frvfdpic_relocs_info
name|entry
decl_stmt|;
name|entry
operator|.
name|symndx
operator|=
operator|-
literal|1
expr_stmt|;
name|entry
operator|.
name|d
operator|.
name|h
operator|=
name|h
expr_stmt|;
name|entry
operator|.
name|addend
operator|=
name|addend
expr_stmt|;
return|return
name|frvfdpic_relocs_info_find
argument_list|(
name|ht
argument_list|,
name|abfd
argument_list|,
operator|&
name|entry
argument_list|,
name|insert
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Obtain the address of the entry in HT associated with the SYMNDXth    local symbol of the input bfd ABFD, plus the addend, creating a new    entry if none existed.  */
end_comment

begin_function
specifier|inline
specifier|static
name|struct
name|frvfdpic_relocs_info
modifier|*
name|frvfdpic_relocs_info_for_local
parameter_list|(
name|struct
name|htab
modifier|*
name|ht
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|long
name|symndx
parameter_list|,
name|bfd_vma
name|addend
parameter_list|,
name|enum
name|insert_option
name|insert
parameter_list|)
block|{
name|struct
name|frvfdpic_relocs_info
name|entry
decl_stmt|;
name|entry
operator|.
name|symndx
operator|=
name|symndx
expr_stmt|;
name|entry
operator|.
name|d
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
name|entry
operator|.
name|addend
operator|=
name|addend
expr_stmt|;
return|return
name|frvfdpic_relocs_info_find
argument_list|(
name|ht
argument_list|,
name|abfd
argument_list|,
operator|&
name|entry
argument_list|,
name|insert
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Merge fields set by check_relocs() of two entries that end up being    mapped to the same (presumably global) symbol.  */
end_comment

begin_function
specifier|inline
specifier|static
name|void
name|frvfdpic_pic_merge_early_relocs_info
parameter_list|(
name|struct
name|frvfdpic_relocs_info
modifier|*
name|e2
parameter_list|,
name|struct
name|frvfdpic_relocs_info
specifier|const
modifier|*
name|e1
parameter_list|)
block|{
name|e2
operator|->
name|got12
operator||=
name|e1
operator|->
name|got12
expr_stmt|;
name|e2
operator|->
name|gotlos
operator||=
name|e1
operator|->
name|gotlos
expr_stmt|;
name|e2
operator|->
name|gothilo
operator||=
name|e1
operator|->
name|gothilo
expr_stmt|;
name|e2
operator|->
name|fd
operator||=
name|e1
operator|->
name|fd
expr_stmt|;
name|e2
operator|->
name|fdgot12
operator||=
name|e1
operator|->
name|fdgot12
expr_stmt|;
name|e2
operator|->
name|fdgotlos
operator||=
name|e1
operator|->
name|fdgotlos
expr_stmt|;
name|e2
operator|->
name|fdgothilo
operator||=
name|e1
operator|->
name|fdgothilo
expr_stmt|;
name|e2
operator|->
name|fdgoff12
operator||=
name|e1
operator|->
name|fdgoff12
expr_stmt|;
name|e2
operator|->
name|fdgofflos
operator||=
name|e1
operator|->
name|fdgofflos
expr_stmt|;
name|e2
operator|->
name|fdgoffhilo
operator||=
name|e1
operator|->
name|fdgoffhilo
expr_stmt|;
name|e2
operator|->
name|tlsplt
operator||=
name|e1
operator|->
name|tlsplt
expr_stmt|;
name|e2
operator|->
name|tlsdesc12
operator||=
name|e1
operator|->
name|tlsdesc12
expr_stmt|;
name|e2
operator|->
name|tlsdesclos
operator||=
name|e1
operator|->
name|tlsdesclos
expr_stmt|;
name|e2
operator|->
name|tlsdeschilo
operator||=
name|e1
operator|->
name|tlsdeschilo
expr_stmt|;
name|e2
operator|->
name|tlsoff12
operator||=
name|e1
operator|->
name|tlsoff12
expr_stmt|;
name|e2
operator|->
name|tlsofflos
operator||=
name|e1
operator|->
name|tlsofflos
expr_stmt|;
name|e2
operator|->
name|tlsoffhilo
operator||=
name|e1
operator|->
name|tlsoffhilo
expr_stmt|;
name|e2
operator|->
name|gotoff
operator||=
name|e1
operator|->
name|gotoff
expr_stmt|;
name|e2
operator|->
name|call
operator||=
name|e1
operator|->
name|call
expr_stmt|;
name|e2
operator|->
name|sym
operator||=
name|e1
operator|->
name|sym
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Every block of 65535 lazy PLT entries shares a single call to the    resolver, inserted in the 32768th lazy PLT entry (i.e., entry #    32767, counting from 0).  All other lazy PLT entries branch to it    in a single instruction.  */
end_comment

begin_define
define|#
directive|define
name|FRVFDPIC_LZPLT_BLOCK_SIZE
value|((bfd_vma) 8 * 65535 + 4)
end_define

begin_define
define|#
directive|define
name|FRVFDPIC_LZPLT_RESOLV_LOC
value|(8 * 32767)
end_define

begin_comment
comment|/* Add a dynamic relocation to the SRELOC section.  */
end_comment

begin_function
specifier|inline
specifier|static
name|bfd_vma
name|_frvfdpic_add_dyn_reloc
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|asection
modifier|*
name|sreloc
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|int
name|reloc_type
parameter_list|,
name|long
name|dynindx
parameter_list|,
name|bfd_vma
name|addend
parameter_list|,
name|struct
name|frvfdpic_relocs_info
modifier|*
name|entry
parameter_list|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_vma
name|reloc_offset
decl_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|offset
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|dynindx
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|addend
expr_stmt|;
name|reloc_offset
operator|=
name|sreloc
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|reloc_offset
operator|<
name|sreloc
operator|->
name|size
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloc_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|sreloc
operator|->
name|contents
operator|+
name|reloc_offset
argument_list|)
expr_stmt|;
name|sreloc
operator|->
name|reloc_count
operator|++
expr_stmt|;
comment|/* If the entry's index is zero, this relocation was probably to a      linkonce section that got discarded.  We reserved a dynamic      relocation, but it was for another entry than the one we got at      the time of emitting the relocation.  Unfortunately there's no      simple way for us to catch this situation, since the relocation      is cleared right before calling relocate_section, at which point      we no longer know what the relocation used to point to.  */
if|if
condition|(
name|entry
operator|->
name|symndx
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|entry
operator|->
name|dynrelocs
operator|>
literal|0
argument_list|)
expr_stmt|;
name|entry
operator|->
name|dynrelocs
operator|--
expr_stmt|;
block|}
return|return
name|reloc_offset
return|;
block|}
end_function

begin_comment
comment|/* Add a fixup to the ROFIXUP section.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|_frvfdpic_add_rofixup
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|asection
modifier|*
name|rofixup
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|struct
name|frvfdpic_relocs_info
modifier|*
name|entry
parameter_list|)
block|{
name|bfd_vma
name|fixup_offset
decl_stmt|;
if|if
condition|(
name|rofixup
operator|->
name|flags
operator|&
name|SEC_EXCLUDE
condition|)
return|return
operator|-
literal|1
return|;
name|fixup_offset
operator|=
name|rofixup
operator|->
name|reloc_count
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|rofixup
operator|->
name|contents
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|fixup_offset
operator|<
name|rofixup
operator|->
name|size
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|offset
argument_list|,
name|rofixup
operator|->
name|contents
operator|+
name|fixup_offset
argument_list|)
expr_stmt|;
block|}
name|rofixup
operator|->
name|reloc_count
operator|++
expr_stmt|;
if|if
condition|(
name|entry
operator|&&
name|entry
operator|->
name|symndx
condition|)
block|{
comment|/* See discussion about symndx == 0 in _frvfdpic_add_dyn_reloc 	 above.  */
name|BFD_ASSERT
argument_list|(
name|entry
operator|->
name|fixups
operator|>
literal|0
argument_list|)
expr_stmt|;
name|entry
operator|->
name|fixups
operator|--
expr_stmt|;
block|}
return|return
name|fixup_offset
return|;
block|}
end_function

begin_comment
comment|/* Find the segment number in which OSEC, and output section, is    located.  */
end_comment

begin_function
specifier|static
name|unsigned
name|_frvfdpic_osec_to_segment
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|asection
modifier|*
name|osec
parameter_list|)
block|{
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|p
decl_stmt|;
comment|/* Find the segment that contains the output_section.  */
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|segment_map
operator|,
name|p
operator|=
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|phdr
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
operator|,
name|p
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|m
operator|->
name|count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|m
operator|->
name|sections
index|[
name|i
index|]
operator|==
name|osec
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
break|break;
block|}
return|return
name|p
operator|-
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|phdr
return|;
block|}
end_function

begin_function
specifier|inline
specifier|static
name|bfd_boolean
name|_frvfdpic_osec_readonly_p
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|asection
modifier|*
name|osec
parameter_list|)
block|{
name|unsigned
name|seg
init|=
name|_frvfdpic_osec_to_segment
argument_list|(
name|output_bfd
argument_list|,
name|osec
argument_list|)
decl_stmt|;
return|return
operator|!
operator|(
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|phdr
index|[
name|seg
index|]
operator|.
name|p_flags
operator|&
name|PF_W
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|FRVFDPIC_TLS_BIAS
value|(2048 - 16)
end_define

begin_comment
comment|/* Return the base VMA address which should be subtracted from real addresses    when resolving TLSMOFF relocation.    This is PT_TLS segment p_vaddr, plus the 2048-16 bias.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|tls_biased_base
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
comment|/* If tls_sec is NULL, we should have signalled an error already.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|==
name|NULL
condition|)
return|return
name|FRVFDPIC_TLS_BIAS
return|;
return|return
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|->
name|vma
operator|+
name|FRVFDPIC_TLS_BIAS
return|;
block|}
end_function

begin_comment
comment|/* Generate relocations for GOT entries, function descriptors, and    code for PLT and lazy PLT entries.  */
end_comment

begin_function
specifier|inline
specifier|static
name|bfd_boolean
name|_frvfdpic_emit_got_relocs_plt_entries
parameter_list|(
name|struct
name|frvfdpic_relocs_info
modifier|*
name|entry
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|,
name|bfd_vma
name|addend
parameter_list|)
block|{
name|bfd_vma
name|fd_lazy_rel_offset
init|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|dynindx
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|done
condition|)
return|return
name|TRUE
return|;
name|entry
operator|->
name|done
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|got_entry
operator|||
name|entry
operator|->
name|fdgot_entry
operator|||
name|entry
operator|->
name|fd_entry
operator|||
name|entry
operator|->
name|tlsoff_entry
operator|||
name|entry
operator|->
name|tlsdesc_entry
condition|)
block|{
comment|/* If the symbol is dynamic, consider it for dynamic 	 relocations, otherwise decay to section + offset.  */
if|if
condition|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
name|dynindx
operator|=
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|dynindx
expr_stmt|;
else|else
block|{
if|if
condition|(
name|sec
operator|->
name|output_section
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
operator|&&
operator|!
name|bfd_is_und_section
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
condition|)
name|dynindx
operator|=
name|elf_section_data
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
operator|->
name|dynindx
expr_stmt|;
else|else
name|dynindx
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Generate relocation for GOT entry pointing to the symbol.  */
if|if
condition|(
name|entry
operator|->
name|got_entry
condition|)
block|{
name|int
name|idx
init|=
name|dynindx
decl_stmt|;
name|bfd_vma
name|ad
init|=
name|addend
decl_stmt|;
comment|/* If the symbol is dynamic but binds locally, use 	 section+offset.  */
if|if
condition|(
name|sec
operator|&&
operator|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|FRVFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
condition|)
name|ad
operator|+=
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
else|else
name|ad
operator|+=
name|sym
operator|->
name|st_value
expr_stmt|;
name|ad
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|output_section
operator|&&
name|elf_section_data
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
condition|)
name|idx
operator|=
name|elf_section_data
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
operator|->
name|dynindx
expr_stmt|;
else|else
name|idx
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we're linking an executable at a fixed address, we can 	 omit the dynamic relocation as long as the symbol is local to 	 this module.  */
if|if
condition|(
name|info
operator|->
name|executable
operator|&&
operator|!
name|info
operator|->
name|pie
operator|&&
operator|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|FRVFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|sec
condition|)
name|ad
operator|+=
name|sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
condition|)
name|_frvfdpic_add_rofixup
argument_list|(
name|output_bfd
argument_list|,
name|frvfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|frvfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|got_entry
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
name|_frvfdpic_add_dyn_reloc
argument_list|(
name|output_bfd
argument_list|,
name|frvfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|frvfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|got_entry
argument_list|)
operator|+
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
argument_list|,
name|R_FRV_32
argument_list|,
name|idx
argument_list|,
name|ad
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|ad
argument_list|,
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|+
name|frvfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|got_entry
argument_list|)
expr_stmt|;
block|}
comment|/* Generate relocation for GOT entry pointing to a canonical      function descriptor.  */
if|if
condition|(
name|entry
operator|->
name|fdgot_entry
condition|)
block|{
name|int
name|reloc
decl_stmt|,
name|idx
decl_stmt|;
name|bfd_vma
name|ad
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|&&
name|FRVFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|)
condition|)
block|{
comment|/* If the symbol is dynamic and there may be dynamic symbol 	     resolution because we are, or are linked with, a shared 	     library, emit a FUNCDESC relocation such that the dynamic 	     linker will allocate the function descriptor.  If the 	     symbol needs a non-local function descriptor but binds 	     locally (e.g., its visibility is protected, emit a 	     dynamic relocation decayed to section+offset.  */
if|if
condition|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|FRVFDPIC_FUNCDESC_LOCAL
argument_list|(
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|&&
name|FRVFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|&&
operator|!
operator|(
name|info
operator|->
name|executable
operator|&&
operator|!
name|info
operator|->
name|pie
operator|)
condition|)
block|{
name|reloc
operator|=
name|R_FRV_FUNCDESC
expr_stmt|;
name|idx
operator|=
name|elf_section_data
argument_list|(
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
argument_list|)
operator|->
name|dynindx
expr_stmt|;
name|ad
operator|=
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|FRVFDPIC_FUNCDESC_LOCAL
argument_list|(
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
condition|)
block|{
name|reloc
operator|=
name|R_FRV_FUNCDESC
expr_stmt|;
name|idx
operator|=
name|dynindx
expr_stmt|;
name|ad
operator|=
name|addend
expr_stmt|;
if|if
condition|(
name|ad
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"relocation requires zero addend"
argument_list|)
argument_list|,
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|entry
operator|->
name|fdgot_entry
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
block|{
comment|/* Otherwise, we know we have a private function descriptor, 		 so reference it directly.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
name|BFD_ASSERT
argument_list|(
name|entry
operator|->
name|privfd
argument_list|)
expr_stmt|;
name|reloc
operator|=
name|R_FRV_32
expr_stmt|;
name|idx
operator|=
name|elf_section_data
argument_list|(
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
argument_list|)
operator|->
name|dynindx
expr_stmt|;
name|ad
operator|=
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|frvfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|fd_entry
expr_stmt|;
block|}
comment|/* If there is room for dynamic symbol resolution, emit the 	     dynamic relocation.  However, if we're linking an 	     executable at a fixed location, we won't have emitted a 	     dynamic symbol entry for the got section, so idx will be 	     zero, which means we can and should compute the address 	     of the private descriptor ourselves.  */
if|if
condition|(
name|info
operator|->
name|executable
operator|&&
operator|!
name|info
operator|->
name|pie
operator|&&
operator|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|FRVFDPIC_FUNCDESC_LOCAL
argument_list|(
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|)
condition|)
block|{
name|ad
operator|+=
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|_frvfdpic_add_rofixup
argument_list|(
name|output_bfd
argument_list|,
name|frvfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|frvfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|fdgot_entry
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
name|_frvfdpic_add_dyn_reloc
argument_list|(
name|output_bfd
argument_list|,
name|frvfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|frvfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|fdgot_entry
argument_list|)
operator|+
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
argument_list|,
name|reloc
argument_list|,
name|idx
argument_list|,
name|ad
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|ad
argument_list|,
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|+
name|frvfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|fdgot_entry
argument_list|)
expr_stmt|;
block|}
comment|/* Generate relocation to fill in a private function descriptor in      the GOT.  */
if|if
condition|(
name|entry
operator|->
name|fd_entry
condition|)
block|{
name|int
name|idx
init|=
name|dynindx
decl_stmt|;
name|bfd_vma
name|ad
init|=
name|addend
decl_stmt|;
name|bfd_vma
name|ofst
decl_stmt|;
name|long
name|lowword
decl_stmt|,
name|highword
decl_stmt|;
comment|/* If the symbol is dynamic but binds locally, use 	 section+offset.  */
if|if
condition|(
name|sec
operator|&&
operator|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|FRVFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
condition|)
name|ad
operator|+=
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
else|else
name|ad
operator|+=
name|sym
operator|->
name|st_value
expr_stmt|;
name|ad
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|output_section
operator|&&
name|elf_section_data
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
condition|)
name|idx
operator|=
name|elf_section_data
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
operator|->
name|dynindx
expr_stmt|;
else|else
name|idx
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we're linking an executable at a fixed address, we can 	 omit the dynamic relocation as long as the symbol is local to 	 this module.  */
if|if
condition|(
name|info
operator|->
name|executable
operator|&&
operator|!
name|info
operator|->
name|pie
operator|&&
operator|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|FRVFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|sec
condition|)
name|ad
operator|+=
name|sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|ofst
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
condition|)
block|{
name|_frvfdpic_add_rofixup
argument_list|(
name|output_bfd
argument_list|,
name|frvfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|frvfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|fd_entry
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|_frvfdpic_add_rofixup
argument_list|(
name|output_bfd
argument_list|,
name|frvfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|frvfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|fd_entry
operator|+
literal|4
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ofst
operator|=
name|_frvfdpic_add_dyn_reloc
argument_list|(
name|output_bfd
argument_list|,
name|entry
operator|->
name|lazyplt
condition|?
name|frvfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
else|:
name|frvfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|frvfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|fd_entry
argument_list|)
operator|+
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
argument_list|,
name|R_FRV_FUNCDESC_VALUE
argument_list|,
name|idx
argument_list|,
name|ad
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
comment|/* If we've omitted the dynamic relocation, just emit the fixed 	 addresses of the symbol and of the local GOT base offset.  */
if|if
condition|(
name|info
operator|->
name|executable
operator|&&
operator|!
name|info
operator|->
name|pie
operator|&&
name|sec
operator|&&
name|sec
operator|->
name|output_section
condition|)
block|{
name|lowword
operator|=
name|ad
expr_stmt|;
name|highword
operator|=
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|frvfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|lazyplt
condition|)
block|{
if|if
condition|(
name|ad
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_dangerous
call|)
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"relocation requires zero addend"
argument_list|)
argument_list|,
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|entry
operator|->
name|fd_entry
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|fd_lazy_rel_offset
operator|=
name|ofst
expr_stmt|;
comment|/* A function descriptor used for lazy or local resolving is 	     initialized such that its high word contains the output 	     section index in which the PLT entries are located, and 	     the low word contains the address of the lazy PLT entry 	     entry point, that must be within the memory region 	     assigned to that section.  */
name|lowword
operator|=
name|entry
operator|->
name|lzplt_entry
operator|+
literal|4
operator|+
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|highword
operator|=
name|_frvfdpic_osec_to_segment
argument_list|(
name|output_bfd
argument_list|,
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* A function descriptor for a local function gets the index 	     of the section.  For a non-local function, it's 	     disregarded.  */
name|lowword
operator|=
name|ad
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|dynindx
operator|==
name|idx
condition|)
name|highword
operator|=
literal|0
expr_stmt|;
else|else
name|highword
operator|=
name|_frvfdpic_osec_to_segment
argument_list|(
name|output_bfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|)
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|lowword
argument_list|,
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|+
name|frvfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|fd_entry
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|highword
argument_list|,
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|+
name|frvfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|fd_entry
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Generate code for the PLT entry.  */
if|if
condition|(
name|entry
operator|->
name|plt_entry
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|bfd_byte
modifier|*
name|plt_code
init|=
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|+
name|entry
operator|->
name|plt_entry
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|entry
operator|->
name|fd_entry
argument_list|)
expr_stmt|;
comment|/* Figure out what kind of PLT entry we need, depending on the 	 location of the function descriptor within the GOT.  */
if|if
condition|(
name|entry
operator|->
name|fd_entry
operator|>=
operator|-
operator|(
literal|1
operator|<<
operator|(
literal|12
operator|-
literal|1
operator|)
operator|)
operator|&&
name|entry
operator|->
name|fd_entry
operator|<
operator|(
literal|1
operator|<<
operator|(
literal|12
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* lddi @(gr15, fd_entry), gr14 */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x9cccf000
operator||
operator|(
name|entry
operator|->
name|fd_entry
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|12
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|plt_code
argument_list|)
expr_stmt|;
name|plt_code
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|entry
operator|->
name|fd_entry
operator|>=
operator|-
operator|(
literal|1
operator|<<
operator|(
literal|16
operator|-
literal|1
operator|)
operator|)
operator|&&
name|entry
operator|->
name|fd_entry
operator|<
operator|(
literal|1
operator|<<
operator|(
literal|16
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* setlos lo(fd_entry), gr14 */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x9cfc0000
operator||
operator|(
name|entry
operator|->
name|fd_entry
operator|&
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|plt_code
argument_list|)
expr_stmt|;
name|plt_code
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* sethi.p hi(fd_entry), gr14 		 setlo lo(fd_entry), gr14 */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x1cf80000
operator||
operator|(
operator|(
name|entry
operator|->
name|fd_entry
operator|>>
literal|16
operator|)
operator|&
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|plt_code
argument_list|)
expr_stmt|;
name|plt_code
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x9cf40000
operator||
operator|(
name|entry
operator|->
name|fd_entry
operator|&
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|plt_code
argument_list|)
expr_stmt|;
name|plt_code
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* ldd @(gr14,gr15),gr14 */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x9c08e14f
argument_list|,
name|plt_code
argument_list|)
expr_stmt|;
name|plt_code
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* jmpl @(gr14,gr0) */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x8030e000
argument_list|,
name|plt_code
argument_list|)
expr_stmt|;
block|}
comment|/* Generate code for the lazy PLT entry.  */
if|if
condition|(
name|entry
operator|->
name|lzplt_entry
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|bfd_byte
modifier|*
name|lzplt_code
init|=
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|+
name|entry
operator|->
name|lzplt_entry
decl_stmt|;
name|bfd_vma
name|resolverStub_addr
decl_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|fd_lazy_rel_offset
argument_list|,
name|lzplt_code
argument_list|)
expr_stmt|;
name|lzplt_code
operator|+=
literal|4
expr_stmt|;
name|resolverStub_addr
operator|=
name|entry
operator|->
name|lzplt_entry
operator|/
name|FRVFDPIC_LZPLT_BLOCK_SIZE
operator|*
name|FRVFDPIC_LZPLT_BLOCK_SIZE
operator|+
name|FRVFDPIC_LZPLT_RESOLV_LOC
expr_stmt|;
if|if
condition|(
name|resolverStub_addr
operator|>=
name|frvfdpic_plt_initial_offset
argument_list|(
name|info
argument_list|)
condition|)
name|resolverStub_addr
operator|=
name|frvfdpic_plt_initial_offset
argument_list|(
name|info
argument_list|)
operator|-
literal|12
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|lzplt_entry
operator|==
name|resolverStub_addr
condition|)
block|{
comment|/* This is a lazy PLT entry that includes a resolver call.  */
comment|/* ldd @(gr15,gr0), gr4 	     jmpl @(gr4,gr0)  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x8808f140
argument_list|,
name|lzplt_code
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x80304000
argument_list|,
name|lzplt_code
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* bra  resolverStub */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0xc01a0000
operator||
operator|(
operator|(
operator|(
name|resolverStub_addr
operator|-
name|entry
operator|->
name|lzplt_entry
operator|)
operator|/
literal|4
operator|)
operator|&
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|lzplt_code
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Generate relocation for GOT entry holding the TLS offset.  */
if|if
condition|(
name|entry
operator|->
name|tlsoff_entry
condition|)
block|{
name|int
name|idx
init|=
name|dynindx
decl_stmt|;
name|bfd_vma
name|ad
init|=
name|addend
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|FRVFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
condition|)
block|{
comment|/* If the symbol is dynamic but binds locally, use 	     section+offset.  */
if|if
condition|(
name|sec
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
condition|)
name|ad
operator|+=
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
else|else
name|ad
operator|+=
name|sym
operator|->
name|st_value
expr_stmt|;
name|ad
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|output_section
operator|&&
name|elf_section_data
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
condition|)
name|idx
operator|=
name|elf_section_data
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
operator|->
name|dynindx
expr_stmt|;
else|else
name|idx
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* *ABS*+addend is special for TLS relocations, use only the 	 addend.  */
if|if
condition|(
name|info
operator|->
name|executable
operator|&&
name|idx
operator|==
literal|0
operator|&&
operator|(
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
operator|||
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
operator|)
condition|)
empty_stmt|;
comment|/* If we're linking an executable, we can entirely omit the 	 dynamic relocation if the symbol is local to this module.  */
elseif|else
if|if
condition|(
name|info
operator|->
name|executable
operator|&&
operator|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|FRVFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|sec
condition|)
name|ad
operator|+=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|-
name|tls_biased_base
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|idx
operator|==
literal|0
operator|&&
operator|(
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
operator|||
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
literal|"TLS section"
argument_list|,
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|entry
operator|->
name|tlsoff_entry
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|idx
operator|=
name|elf_section_data
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
argument_list|)
operator|->
name|dynindx
expr_stmt|;
name|ad
operator|+=
name|FRVFDPIC_TLS_BIAS
expr_stmt|;
block|}
name|_frvfdpic_add_dyn_reloc
argument_list|(
name|output_bfd
argument_list|,
name|frvfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|frvfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|tlsoff_entry
argument_list|)
operator|+
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
argument_list|,
name|R_FRV_TLSOFF
argument_list|,
name|idx
argument_list|,
name|ad
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|ad
argument_list|,
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|+
name|frvfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|tlsoff_entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|tlsdesc_entry
condition|)
block|{
name|int
name|idx
init|=
name|dynindx
decl_stmt|;
name|bfd_vma
name|ad
init|=
name|addend
decl_stmt|;
comment|/* If the symbol is dynamic but binds locally, use 	 section+offset.  */
if|if
condition|(
name|sec
operator|&&
operator|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|FRVFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
condition|)
name|ad
operator|+=
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
else|else
name|ad
operator|+=
name|sym
operator|->
name|st_value
expr_stmt|;
name|ad
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|output_section
operator|&&
name|elf_section_data
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
condition|)
name|idx
operator|=
name|elf_section_data
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
operator|->
name|dynindx
expr_stmt|;
else|else
name|idx
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we didn't set up a TLS offset entry, but we're linking an 	 executable and the symbol binds locally, we can use the 	 module offset in the TLS descriptor in relaxations.  */
if|if
condition|(
name|info
operator|->
name|executable
operator|&&
operator|!
name|entry
operator|->
name|tlsoff_entry
condition|)
name|entry
operator|->
name|tlsoff_entry
operator|=
name|entry
operator|->
name|tlsdesc_entry
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|executable
operator|&&
operator|!
name|info
operator|->
name|pie
operator|&&
operator|(
operator|(
name|idx
operator|==
literal|0
operator|&&
operator|(
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
operator|||
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
operator|)
operator|)
operator|||
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|FRVFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|)
condition|)
block|{
comment|/* *ABS*+addend is special for TLS relocations, use only the 	     addend for the TLS offset, and take the module id as 	     0.  */
if|if
condition|(
name|idx
operator|==
literal|0
operator|&&
operator|(
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
operator|||
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
operator|)
condition|)
empty_stmt|;
comment|/* For other TLS symbols that bind locally, add the section 	     TLS offset to the addend.  */
elseif|else
if|if
condition|(
name|sec
condition|)
name|ad
operator|+=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|-
name|tls_biased_base
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|frvfdpic_plt_tls_ret_offset
argument_list|(
name|info
argument_list|)
argument_list|,
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|+
name|frvfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|tlsdesc_entry
argument_list|)
expr_stmt|;
name|_frvfdpic_add_rofixup
argument_list|(
name|output_bfd
argument_list|,
name|frvfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|frvfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|tlsdesc_entry
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|frvfdpic_dynamic_got_plt_info
argument_list|(
name|info
argument_list|)
operator|->
name|tls_ret_refs
argument_list|)
expr_stmt|;
comment|/* We've used one of the reserved fixups, so discount it so 	     that we can check at the end that we've used them 	     all.  */
name|frvfdpic_dynamic_got_plt_info
argument_list|(
name|info
argument_list|)
operator|->
name|tls_ret_refs
operator|--
expr_stmt|;
comment|/* While at that, make sure the ret instruction makes to the 	     right location in the PLT.  We could do it only when we 	     got to 0, but since the check at the end will only print 	     a warning, make sure we have the ret in place in case the 	     warning is missed.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0xc03a4000
argument_list|,
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|+
name|frvfdpic_plt_tls_ret_offset
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|idx
operator|==
literal|0
operator|&&
operator|(
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
operator|||
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
literal|"TLS section"
argument_list|,
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|entry
operator|->
name|tlsdesc_entry
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|idx
operator|=
name|elf_section_data
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
argument_list|)
operator|->
name|dynindx
expr_stmt|;
name|ad
operator|+=
name|FRVFDPIC_TLS_BIAS
expr_stmt|;
block|}
name|_frvfdpic_add_dyn_reloc
argument_list|(
name|output_bfd
argument_list|,
name|frvfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|frvfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|tlsdesc_entry
argument_list|)
operator|+
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
argument_list|,
name|R_FRV_TLSDESC_VALUE
argument_list|,
name|idx
argument_list|,
name|ad
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0
argument_list|,
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|+
name|frvfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|tlsdesc_entry
argument_list|)
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|ad
argument_list|,
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|+
name|frvfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|entry
operator|->
name|tlsdesc_entry
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Generate code for the get-TLS-offset PLT entry.  */
if|if
condition|(
name|entry
operator|->
name|tlsplt_entry
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|bfd_byte
modifier|*
name|plt_code
init|=
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|+
name|entry
operator|->
name|tlsplt_entry
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|executable
operator|&&
operator|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|FRVFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|)
condition|)
block|{
name|int
name|idx
init|=
name|dynindx
decl_stmt|;
name|bfd_vma
name|ad
init|=
name|addend
decl_stmt|;
comment|/* sec may be NULL when referencing an undefweak symbol 	     while linking a static executable.  */
if|if
condition|(
operator|!
name|sec
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
condition|)
name|ad
operator|+=
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
else|else
name|ad
operator|+=
name|sym
operator|->
name|st_value
expr_stmt|;
name|ad
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|output_section
operator|&&
name|elf_section_data
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
condition|)
name|idx
operator|=
name|elf_section_data
argument_list|(
name|sec
operator|->
name|output_section
argument_list|)
operator|->
name|dynindx
expr_stmt|;
else|else
name|idx
operator|=
literal|0
expr_stmt|;
block|}
comment|/* *ABS*+addend is special for TLS relocations, use only the 	     addend for the TLS offset, and take the module id as 	     0.  */
if|if
condition|(
name|idx
operator|==
literal|0
operator|&&
operator|(
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
operator|||
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
operator|)
condition|)
empty_stmt|;
comment|/* For other TLS symbols that bind locally, add the section 	     TLS offset to the addend.  */
elseif|else
if|if
condition|(
name|sec
condition|)
name|ad
operator|+=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|-
name|tls_biased_base
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_signed_vma
operator|)
name|ad
operator|>=
operator|-
operator|(
literal|1
operator|<<
operator|(
literal|16
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
name|bfd_signed_vma
operator|)
name|ad
operator|<
operator|(
literal|1
operator|<<
operator|(
literal|16
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* setlos lo(ad), gr9 */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x92fc0000
operator||
operator|(
name|ad
operator|&
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|plt_code
argument_list|)
expr_stmt|;
name|plt_code
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* sethi.p hi(ad), gr9 		 setlo lo(ad), gr9 */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x12f80000
operator||
operator|(
operator|(
name|ad
operator|>>
literal|16
operator|)
operator|&
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|plt_code
argument_list|)
expr_stmt|;
name|plt_code
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x92f40000
operator||
operator|(
name|ad
operator|&
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|plt_code
argument_list|)
expr_stmt|;
name|plt_code
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* ret */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0xc03a4000
argument_list|,
name|plt_code
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|tlsoff_entry
condition|)
block|{
comment|/* Figure out what kind of PLT entry we need, depending on the 	     location of the TLS descriptor within the GOT.  */
if|if
condition|(
name|entry
operator|->
name|tlsoff_entry
operator|>=
operator|-
operator|(
literal|1
operator|<<
operator|(
literal|12
operator|-
literal|1
operator|)
operator|)
operator|&&
name|entry
operator|->
name|tlsoff_entry
operator|<
operator|(
literal|1
operator|<<
operator|(
literal|12
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* ldi @(gr15, tlsoff_entry), gr9 */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x92c8f000
operator||
operator|(
name|entry
operator|->
name|tlsoff_entry
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|12
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|plt_code
argument_list|)
expr_stmt|;
name|plt_code
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|entry
operator|->
name|tlsoff_entry
operator|>=
operator|-
operator|(
literal|1
operator|<<
operator|(
literal|16
operator|-
literal|1
operator|)
operator|)
operator|&&
name|entry
operator|->
name|tlsoff_entry
operator|<
operator|(
literal|1
operator|<<
operator|(
literal|16
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* setlos lo(tlsoff_entry), gr8 */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x90fc0000
operator||
operator|(
name|entry
operator|->
name|tlsoff_entry
operator|&
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|plt_code
argument_list|)
expr_stmt|;
name|plt_code
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* sethi.p hi(tlsoff_entry), gr8 		     setlo lo(tlsoff_entry), gr8 */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x10f80000
operator||
operator|(
operator|(
name|entry
operator|->
name|tlsoff_entry
operator|>>
literal|16
operator|)
operator|&
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|plt_code
argument_list|)
expr_stmt|;
name|plt_code
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x90f40000
operator||
operator|(
name|entry
operator|->
name|tlsoff_entry
operator|&
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|plt_code
argument_list|)
expr_stmt|;
name|plt_code
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* ld @(gr15,gr8),gr9 */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x9008f108
argument_list|,
name|plt_code
argument_list|)
expr_stmt|;
name|plt_code
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* ret */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0xc03a4000
argument_list|,
name|plt_code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|entry
operator|->
name|tlsdesc_entry
argument_list|)
expr_stmt|;
comment|/* Figure out what kind of PLT entry we need, depending on the 	     location of the TLS descriptor within the GOT.  */
if|if
condition|(
name|entry
operator|->
name|tlsdesc_entry
operator|>=
operator|-
operator|(
literal|1
operator|<<
operator|(
literal|12
operator|-
literal|1
operator|)
operator|)
operator|&&
name|entry
operator|->
name|tlsdesc_entry
operator|<
operator|(
literal|1
operator|<<
operator|(
literal|12
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* lddi @(gr15, tlsdesc_entry), gr8 */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x90ccf000
operator||
operator|(
name|entry
operator|->
name|tlsdesc_entry
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|12
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|plt_code
argument_list|)
expr_stmt|;
name|plt_code
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|entry
operator|->
name|tlsdesc_entry
operator|>=
operator|-
operator|(
literal|1
operator|<<
operator|(
literal|16
operator|-
literal|1
operator|)
operator|)
operator|&&
name|entry
operator|->
name|tlsdesc_entry
operator|<
operator|(
literal|1
operator|<<
operator|(
literal|16
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* setlos lo(tlsdesc_entry), gr8 */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x90fc0000
operator||
operator|(
name|entry
operator|->
name|tlsdesc_entry
operator|&
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|plt_code
argument_list|)
expr_stmt|;
name|plt_code
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* sethi.p hi(tlsdesc_entry), gr8 		     setlo lo(tlsdesc_entry), gr8 */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x10f80000
operator||
operator|(
operator|(
name|entry
operator|->
name|tlsdesc_entry
operator|>>
literal|16
operator|)
operator|&
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|plt_code
argument_list|)
expr_stmt|;
name|plt_code
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x90f40000
operator||
operator|(
name|entry
operator|->
name|tlsdesc_entry
operator|&
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|16
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|plt_code
argument_list|)
expr_stmt|;
name|plt_code
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* ldd @(gr15,gr8),gr8 */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x9008f148
argument_list|,
name|plt_code
argument_list|)
expr_stmt|;
name|plt_code
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* jmpl @(gr8,gr0) */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
literal|0x80308000
argument_list|,
name|plt_code
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Handle an FRV small data reloc.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|elf32_frv_relocate_gprel12
parameter_list|(
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|relocation
parameter_list|,
name|contents
parameter_list|,
name|value
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocation
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
name|bfd_vma
name|insn
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
literal|"_gp"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gp
operator|=
operator|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|input_section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|value
operator|-=
operator|(
name|gp
operator|-
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|relocation
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|value
operator|+=
name|relocation
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0x7ff
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x800
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|insn
operator|&
literal|0xfffff000
operator|)
operator||
operator|(
name|value
operator|&
literal|0xfff
operator|)
argument_list|,
name|contents
operator|+
name|relocation
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Handle an FRV small data reloc. for the u12 field.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|elf32_frv_relocate_gprelu12
parameter_list|(
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|relocation
parameter_list|,
name|contents
parameter_list|,
name|value
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocation
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
name|bfd_vma
name|insn
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|mask
decl_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
literal|"_gp"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gp
operator|=
operator|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|input_section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|value
operator|-=
operator|(
name|gp
operator|-
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|relocation
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|value
operator|+=
name|relocation
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0x7ff
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x800
condition|)
return|return
name|bfd_reloc_overflow
return|;
comment|/* The high 6 bits go into bits 17-12. The low 6 bits go into bits 5-0.  */
name|mask
operator|=
literal|0x3f03f
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
operator|~
name|mask
operator|)
operator||
operator|(
operator|(
name|value
operator|&
literal|0xfc0
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
name|value
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|relocation
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Handle an FRV ELF HI16 reloc.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|elf32_frv_relocate_hi16
parameter_list|(
name|input_bfd
parameter_list|,
name|relhi
parameter_list|,
name|contents
parameter_list|,
name|value
parameter_list|)
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relhi
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
name|bfd_vma
name|insn
decl_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|relhi
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|value
operator|+=
name|relhi
operator|->
name|r_addend
expr_stmt|;
name|value
operator|=
operator|(
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
literal|0xffff0000
operator|)
operator||
name|value
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0xffff
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x10000
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|relhi
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|elf32_frv_relocate_lo16
parameter_list|(
name|input_bfd
parameter_list|,
name|rello
parameter_list|,
name|contents
parameter_list|,
name|value
parameter_list|)
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rello
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
name|bfd_vma
name|insn
decl_stmt|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rello
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|value
operator|+=
name|rello
operator|->
name|r_addend
expr_stmt|;
name|value
operator|=
name|value
operator|&
literal|0xffff
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
literal|0xffff0000
operator|)
operator||
name|value
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0xffff
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x10000
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rello
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Perform the relocation for the CALL label24 instruction.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|elf32_frv_relocate_label24
parameter_list|(
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|rello
parameter_list|,
name|contents
parameter_list|,
name|value
parameter_list|)
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rello
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
name|bfd_vma
name|insn
decl_stmt|;
name|bfd_vma
name|label6
decl_stmt|;
name|bfd_vma
name|label18
decl_stmt|;
comment|/* The format for the call instruction is:      0 000000 0001111 000000000000000000       label6 opcode  label18      The branch calculation is: pc + (4*label24)     where label24 is the concatenation of label6 and label18.  */
comment|/* Grab the instruction.  */
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rello
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|value
operator|-=
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
expr_stmt|;
name|value
operator|-=
name|rello
operator|->
name|r_offset
expr_stmt|;
name|value
operator|+=
name|rello
operator|->
name|r_addend
expr_stmt|;
name|value
operator|=
name|value
operator|>>
literal|2
expr_stmt|;
name|label6
operator|=
name|value
operator|&
literal|0xfc0000
expr_stmt|;
name|label6
operator|=
name|label6
operator|<<
literal|7
expr_stmt|;
name|label18
operator|=
name|value
operator|&
literal|0x3ffff
expr_stmt|;
name|insn
operator|=
name|insn
operator|&
literal|0x803c0000
expr_stmt|;
name|insn
operator|=
name|insn
operator||
name|label6
expr_stmt|;
name|insn
operator|=
name|insn
operator||
name|label18
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rello
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|elf32_frv_relocate_gprelhi
parameter_list|(
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|relocation
parameter_list|,
name|contents
parameter_list|,
name|value
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocation
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
name|bfd_vma
name|insn
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
literal|"_gp"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gp
operator|=
operator|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|input_section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|value
operator|-=
operator|(
name|gp
operator|-
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|value
operator|+=
name|relocation
operator|->
name|r_addend
expr_stmt|;
name|value
operator|=
operator|(
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0xffff
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x10000
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|relocation
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
literal|0xffff0000
operator|)
operator||
name|value
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|relocation
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_reloc_status_type
name|elf32_frv_relocate_gprello
parameter_list|(
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|relocation
parameter_list|,
name|contents
parameter_list|,
name|value
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocation
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
name|bfd_vma
name|insn
decl_stmt|;
name|bfd_vma
name|gp
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
literal|"_gp"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gp
operator|=
operator|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|input_section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|value
operator|-=
operator|(
name|gp
operator|-
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
name|value
operator|+=
name|relocation
operator|->
name|r_addend
expr_stmt|;
name|value
operator|=
name|value
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|>
literal|0xffff
operator|||
operator|(
name|long
operator|)
name|value
operator|<
operator|-
literal|0x10000
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|relocation
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
literal|0xffff0000
operator|)
operator||
name|value
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|relocation
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|frv_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
default|default:
break|break;
case|case
name|BFD_RELOC_NONE
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_NONE
index|]
return|;
case|case
name|BFD_RELOC_32
case|:
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_type
operator|==
name|ET_EXEC
operator|||
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_type
operator|==
name|ET_DYN
condition|)
return|return
operator|&
name|elf32_frv_rel_32_howto
return|;
comment|/* Fall through.  */
case|case
name|BFD_RELOC_CTOR
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_32
index|]
return|;
case|case
name|BFD_RELOC_FRV_LABEL16
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_LABEL16
index|]
return|;
case|case
name|BFD_RELOC_FRV_LABEL24
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_LABEL24
index|]
return|;
case|case
name|BFD_RELOC_FRV_LO16
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_LO16
index|]
return|;
case|case
name|BFD_RELOC_FRV_HI16
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_HI16
index|]
return|;
case|case
name|BFD_RELOC_FRV_GPREL12
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_GPREL12
index|]
return|;
case|case
name|BFD_RELOC_FRV_GPRELU12
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_GPRELU12
index|]
return|;
case|case
name|BFD_RELOC_FRV_GPREL32
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_GPREL32
index|]
return|;
case|case
name|BFD_RELOC_FRV_GPRELHI
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_GPRELHI
index|]
return|;
case|case
name|BFD_RELOC_FRV_GPRELLO
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_GPRELLO
index|]
return|;
case|case
name|BFD_RELOC_FRV_GOT12
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_GOT12
index|]
return|;
case|case
name|BFD_RELOC_FRV_GOTHI
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_GOTHI
index|]
return|;
case|case
name|BFD_RELOC_FRV_GOTLO
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_GOTLO
index|]
return|;
case|case
name|BFD_RELOC_FRV_FUNCDESC
case|:
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_type
operator|==
name|ET_EXEC
operator|||
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_type
operator|==
name|ET_DYN
condition|)
return|return
operator|&
name|elf32_frv_rel_funcdesc_howto
return|;
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_FUNCDESC
index|]
return|;
case|case
name|BFD_RELOC_FRV_FUNCDESC_GOT12
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_FUNCDESC_GOT12
index|]
return|;
case|case
name|BFD_RELOC_FRV_FUNCDESC_GOTHI
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_FUNCDESC_GOTHI
index|]
return|;
case|case
name|BFD_RELOC_FRV_FUNCDESC_GOTLO
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_FUNCDESC_GOTLO
index|]
return|;
case|case
name|BFD_RELOC_FRV_FUNCDESC_VALUE
case|:
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_type
operator|==
name|ET_EXEC
operator|||
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_type
operator|==
name|ET_DYN
condition|)
return|return
operator|&
name|elf32_frv_rel_funcdesc_value_howto
return|;
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_FUNCDESC_VALUE
index|]
return|;
case|case
name|BFD_RELOC_FRV_FUNCDESC_GOTOFF12
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_FUNCDESC_GOTOFF12
index|]
return|;
case|case
name|BFD_RELOC_FRV_FUNCDESC_GOTOFFHI
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_FUNCDESC_GOTOFFHI
index|]
return|;
case|case
name|BFD_RELOC_FRV_FUNCDESC_GOTOFFLO
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_FUNCDESC_GOTOFFLO
index|]
return|;
case|case
name|BFD_RELOC_FRV_GOTOFF12
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_GOTOFF12
index|]
return|;
case|case
name|BFD_RELOC_FRV_GOTOFFHI
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_GOTOFFHI
index|]
return|;
case|case
name|BFD_RELOC_FRV_GOTOFFLO
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_GOTOFFLO
index|]
return|;
case|case
name|BFD_RELOC_FRV_GETTLSOFF
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_GETTLSOFF
index|]
return|;
case|case
name|BFD_RELOC_FRV_TLSDESC_VALUE
case|:
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_type
operator|==
name|ET_EXEC
operator|||
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_type
operator|==
name|ET_DYN
condition|)
return|return
operator|&
name|elf32_frv_rel_tlsdesc_value_howto
return|;
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_TLSDESC_VALUE
index|]
return|;
case|case
name|BFD_RELOC_FRV_GOTTLSDESC12
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_GOTTLSDESC12
index|]
return|;
case|case
name|BFD_RELOC_FRV_GOTTLSDESCHI
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_GOTTLSDESCHI
index|]
return|;
case|case
name|BFD_RELOC_FRV_GOTTLSDESCLO
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_GOTTLSDESCLO
index|]
return|;
case|case
name|BFD_RELOC_FRV_TLSMOFF12
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_TLSMOFF12
index|]
return|;
case|case
name|BFD_RELOC_FRV_TLSMOFFHI
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_TLSMOFFHI
index|]
return|;
case|case
name|BFD_RELOC_FRV_TLSMOFFLO
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_TLSMOFFLO
index|]
return|;
case|case
name|BFD_RELOC_FRV_GOTTLSOFF12
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_GOTTLSOFF12
index|]
return|;
case|case
name|BFD_RELOC_FRV_GOTTLSOFFHI
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_GOTTLSOFFHI
index|]
return|;
case|case
name|BFD_RELOC_FRV_GOTTLSOFFLO
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_GOTTLSOFFLO
index|]
return|;
case|case
name|BFD_RELOC_FRV_TLSOFF
case|:
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_type
operator|==
name|ET_EXEC
operator|||
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_type
operator|==
name|ET_DYN
condition|)
return|return
operator|&
name|elf32_frv_rel_tlsoff_howto
return|;
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_TLSOFF
index|]
return|;
case|case
name|BFD_RELOC_FRV_TLSDESC_RELAX
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_TLSDESC_RELAX
index|]
return|;
case|case
name|BFD_RELOC_FRV_GETTLSOFF_RELAX
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_GETTLSOFF_RELAX
index|]
return|;
case|case
name|BFD_RELOC_FRV_TLSOFF_RELAX
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_TLSOFF_RELAX
index|]
return|;
case|case
name|BFD_RELOC_FRV_TLSMOFF
case|:
return|return
operator|&
name|elf32_frv_howto_table
index|[
operator|(
name|int
operator|)
name|R_FRV_TLSMOFF
index|]
return|;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
return|return
operator|&
name|elf32_frv_vtinherit_howto
return|;
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
return|return
operator|&
name|elf32_frv_vtentry_howto
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set the howto pointer for an FRV ELF reloc.  */
end_comment

begin_function
specifier|static
name|void
name|frv_info_to_howto_rela
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_FRV_GNU_VTINHERIT
case|:
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf32_frv_vtinherit_howto
expr_stmt|;
break|break;
case|case
name|R_FRV_GNU_VTENTRY
case|:
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf32_frv_vtentry_howto
expr_stmt|;
break|break;
default|default:
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf32_frv_howto_table
index|[
name|r_type
index|]
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Set the howto pointer for an FRV ELF REL reloc.  */
end_comment

begin_function
specifier|static
name|void
name|frvfdpic_info_to_howto_rel
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|cache_ptr
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|dst
parameter_list|)
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_FRV_32
case|:
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf32_frv_rel_32_howto
expr_stmt|;
break|break;
case|case
name|R_FRV_FUNCDESC
case|:
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf32_frv_rel_funcdesc_howto
expr_stmt|;
break|break;
case|case
name|R_FRV_FUNCDESC_VALUE
case|:
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf32_frv_rel_funcdesc_value_howto
expr_stmt|;
break|break;
case|case
name|R_FRV_TLSDESC_VALUE
case|:
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf32_frv_rel_tlsdesc_value_howto
expr_stmt|;
break|break;
case|case
name|R_FRV_TLSOFF
case|:
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf32_frv_rel_tlsoff_howto
expr_stmt|;
break|break;
default|default:
name|cache_ptr
operator|->
name|howto
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform a single relocation.  By default we use the standard BFD    routines, but a few relocs, we have to do them ourselves.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|frv_final_link_relocate
parameter_list|(
name|howto
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|rel
parameter_list|,
name|relocation
parameter_list|)
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
block|{
return|return
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Relocate an FRV ELF section.     The RELOCATE_SECTION function is called by the new ELF backend linker    to handle the relocations for a section.     The relocs are always passed as Rela structures; if the section    actually uses Rel structures, the r_addend field will always be    zero.     This function is responsible for adjusting the section contents as    necessary, and (if using Rela relocs and generating a relocatable    output file) adjusting the reloc addend as necessary.     This function does not have to worry about setting the reloc    address or the reloc symbol index.     LOCAL_SYMS is a pointer to the swapped in local symbols.     LOCAL_SECTIONS is an array giving the section in the input file    corresponding to the st_shndx field of each local symbol.     The global hash table entry for the global symbols can be found    via elf_sym_hashes (input_bfd).     When generating relocatable output, this function must handle    STB_LOCAL/STT_SECTION symbols specially.  The output symbol is    going to be the section symbol corresponding to the output    section, which means that the addend must be adjusted    accordingly.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_frv_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|unsigned
name|isec_segment
decl_stmt|,
name|got_segment
decl_stmt|,
name|plt_segment
decl_stmt|,
name|gprel_segment
decl_stmt|,
name|tls_segment
decl_stmt|,
name|check_segment
index|[
literal|2
index|]
decl_stmt|;
name|int
name|silence_segment_error
init|=
operator|!
operator|(
name|info
operator|->
name|shared
operator|||
name|info
operator|->
name|pie
operator|)
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
name|isec_segment
operator|=
name|_frvfdpic_osec_to_segment
argument_list|(
name|output_bfd
argument_list|,
name|input_section
operator|->
name|output_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_FDPIC
argument_list|(
name|output_bfd
argument_list|)
operator|&&
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
condition|)
name|got_segment
operator|=
name|_frvfdpic_osec_to_segment
argument_list|(
name|output_bfd
argument_list|,
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
argument_list|)
expr_stmt|;
else|else
name|got_segment
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|IS_FDPIC
argument_list|(
name|output_bfd
argument_list|)
operator|&&
name|frvfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
condition|)
name|gprel_segment
operator|=
name|_frvfdpic_osec_to_segment
argument_list|(
name|output_bfd
argument_list|,
name|frvfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
argument_list|)
expr_stmt|;
else|else
name|gprel_segment
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|IS_FDPIC
argument_list|(
name|output_bfd
argument_list|)
operator|&&
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
condition|)
name|plt_segment
operator|=
name|_frvfdpic_osec_to_segment
argument_list|(
name|output_bfd
argument_list|,
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
argument_list|)
expr_stmt|;
else|else
name|plt_segment
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
condition|)
name|tls_segment
operator|=
name|_frvfdpic_osec_to_segment
argument_list|(
name|output_bfd
argument_list|,
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
argument_list|)
expr_stmt|;
else|else
name|tls_segment
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|int
name|r_type
decl_stmt|;
name|asection
modifier|*
name|osec
decl_stmt|;
name|struct
name|frvfdpic_relocs_info
modifier|*
name|picrel
decl_stmt|;
name|bfd_vma
name|orig_addend
init|=
name|rel
operator|->
name|r_addend
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_FRV_GNU_VTINHERIT
operator|||
name|r_type
operator|==
name|R_FRV_GNU_VTENTRY
condition|)
continue|continue;
comment|/* This is a final link.  */
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|howto
operator|=
name|elf32_frv_howto_table
operator|+
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|osec
operator|=
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|name
operator|==
name|NULL
operator|)
condition|?
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
else|:
name|name
expr_stmt|;
block|}
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
if|if
condition|(
comment|/* TLSMOFF forces local binding.  */
name|r_type
operator|!=
name|R_FRV_TLSMOFF
operator|&&
operator|!
name|FRVFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|sec
operator|=
name|NULL
expr_stmt|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|unresolved_syms_in_objects
operator|==
name|RM_IGNORE
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
operator|(
name|info
operator|->
name|unresolved_syms_in_objects
operator|==
name|RM_GENERATE_ERROR
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|)
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
name|osec
operator|=
name|sec
expr_stmt|;
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_FRV_LABEL24
case|:
case|case
name|R_FRV_32
case|:
if|if
condition|(
operator|!
name|IS_FDPIC
argument_list|(
name|output_bfd
argument_list|)
condition|)
goto|goto
name|non_fdpic
goto|;
case|case
name|R_FRV_GOT12
case|:
case|case
name|R_FRV_GOTHI
case|:
case|case
name|R_FRV_GOTLO
case|:
case|case
name|R_FRV_FUNCDESC_GOT12
case|:
case|case
name|R_FRV_FUNCDESC_GOTHI
case|:
case|case
name|R_FRV_FUNCDESC_GOTLO
case|:
case|case
name|R_FRV_GOTOFF12
case|:
case|case
name|R_FRV_GOTOFFHI
case|:
case|case
name|R_FRV_GOTOFFLO
case|:
case|case
name|R_FRV_FUNCDESC_GOTOFF12
case|:
case|case
name|R_FRV_FUNCDESC_GOTOFFHI
case|:
case|case
name|R_FRV_FUNCDESC_GOTOFFLO
case|:
case|case
name|R_FRV_FUNCDESC
case|:
case|case
name|R_FRV_FUNCDESC_VALUE
case|:
case|case
name|R_FRV_GETTLSOFF
case|:
case|case
name|R_FRV_TLSDESC_VALUE
case|:
case|case
name|R_FRV_GOTTLSDESC12
case|:
case|case
name|R_FRV_GOTTLSDESCHI
case|:
case|case
name|R_FRV_GOTTLSDESCLO
case|:
case|case
name|R_FRV_TLSMOFF12
case|:
case|case
name|R_FRV_TLSMOFFHI
case|:
case|case
name|R_FRV_TLSMOFFLO
case|:
case|case
name|R_FRV_GOTTLSOFF12
case|:
case|case
name|R_FRV_GOTTLSOFFHI
case|:
case|case
name|R_FRV_GOTTLSOFFLO
case|:
case|case
name|R_FRV_TLSOFF
case|:
case|case
name|R_FRV_TLSDESC_RELAX
case|:
case|case
name|R_FRV_GETTLSOFF_RELAX
case|:
case|case
name|R_FRV_TLSOFF_RELAX
case|:
case|case
name|R_FRV_TLSMOFF
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|picrel
operator|=
name|frvfdpic_relocs_info_for_global
argument_list|(
name|frvfdpic_relocs_info
argument_list|(
name|info
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|h
argument_list|,
name|orig_addend
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
else|else
comment|/* In order to find the entry we created before, we must 	       use the original addend, not the one that may have been 	       modified by _bfd_elf_rela_local_sym().  */
name|picrel
operator|=
name|frvfdpic_relocs_info_for_local
argument_list|(
name|frvfdpic_relocs_info
argument_list|(
name|info
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|r_symndx
argument_list|,
name|orig_addend
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|picrel
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|_frvfdpic_emit_got_relocs_plt_entries
argument_list|(
name|picrel
argument_list|,
name|output_bfd
argument_list|,
name|info
argument_list|,
name|osec
argument_list|,
name|sym
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%x): relocation to `%s+%x' may have caused the error above"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|name
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
default|default:
name|non_fdpic
label|:
name|picrel
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|h
operator|&&
operator|!
name|FRVFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"relocation references symbol not defined in the module"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_FRV_GETTLSOFF
case|:
case|case
name|R_FRV_TLSDESC_VALUE
case|:
case|case
name|R_FRV_GOTTLSDESC12
case|:
case|case
name|R_FRV_GOTTLSDESCHI
case|:
case|case
name|R_FRV_GOTTLSDESCLO
case|:
case|case
name|R_FRV_TLSMOFF12
case|:
case|case
name|R_FRV_TLSMOFFHI
case|:
case|case
name|R_FRV_TLSMOFFLO
case|:
case|case
name|R_FRV_GOTTLSOFF12
case|:
case|case
name|R_FRV_GOTTLSOFFHI
case|:
case|case
name|R_FRV_GOTTLSOFFLO
case|:
case|case
name|R_FRV_TLSOFF
case|:
case|case
name|R_FRV_TLSDESC_RELAX
case|:
case|case
name|R_FRV_GETTLSOFF_RELAX
case|:
case|case
name|R_FRV_TLSOFF_RELAX
case|:
case|case
name|R_FRV_TLSMOFF
case|:
if|if
condition|(
name|sec
operator|&&
operator|(
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
operator|||
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
operator|)
condition|)
name|relocation
operator|+=
name|tls_biased_base
argument_list|(
name|info
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Try to apply TLS relaxations.  */
if|if
condition|(
literal|1
condition|)
switch|switch
condition|(
name|r_type
condition|)
block|{
define|#
directive|define
name|LOCAL_EXEC_P
parameter_list|(
name|info
parameter_list|,
name|picrel
parameter_list|)
define|\
value|((info)->executable \&& (picrel->symndx != -1 || FRVFDPIC_SYM_LOCAL ((info), (picrel)->d.h)))
define|#
directive|define
name|INITIAL_EXEC_P
parameter_list|(
name|info
parameter_list|,
name|picrel
parameter_list|)
define|\
value|(((info)->executable || (info)->flags& DF_STATIC_TLS) \&& (picrel)->tlsoff_entry)
define|#
directive|define
name|IN_RANGE_FOR_OFST12_P
parameter_list|(
name|value
parameter_list|)
define|\
value|((bfd_vma)((value) + 2048)< (bfd_vma)4096)
define|#
directive|define
name|IN_RANGE_FOR_SETLOS_P
parameter_list|(
name|value
parameter_list|)
define|\
value|((bfd_vma)((value) + 32768)< (bfd_vma)65536)
define|#
directive|define
name|TLSMOFF_IN_RANGE_FOR_SETLOS_P
parameter_list|(
name|value
parameter_list|,
name|info
parameter_list|)
define|\
value|(IN_RANGE_FOR_SETLOS_P ((value) - tls_biased_base (info)))
define|#
directive|define
name|RELAX_GETTLSOFF_LOCAL_EXEC_P
parameter_list|(
name|info
parameter_list|,
name|picrel
parameter_list|,
name|value
parameter_list|)
define|\
value|(LOCAL_EXEC_P ((info), (picrel)) \&& TLSMOFF_IN_RANGE_FOR_SETLOS_P((value), (info)))
define|#
directive|define
name|RELAX_GETTLSOFF_INITIAL_EXEC_P
parameter_list|(
name|info
parameter_list|,
name|picrel
parameter_list|)
define|\
value|(INITIAL_EXEC_P ((info), (picrel)) \&& IN_RANGE_FOR_OFST12_P ((picrel)->tlsoff_entry))
define|#
directive|define
name|RELAX_TLSDESC_LOCAL_EXEC_P
parameter_list|(
name|info
parameter_list|,
name|picrel
parameter_list|,
name|value
parameter_list|)
define|\
value|(LOCAL_EXEC_P ((info), (picrel)))
define|#
directive|define
name|RELAX_TLSDESC_INITIAL_EXEC_P
parameter_list|(
name|info
parameter_list|,
name|picrel
parameter_list|)
define|\
value|(INITIAL_EXEC_P ((info), (picrel)))
define|#
directive|define
name|RELAX_GOTTLSOFF_LOCAL_EXEC_P
parameter_list|(
name|info
parameter_list|,
name|picrel
parameter_list|,
name|value
parameter_list|)
define|\
value|(LOCAL_EXEC_P ((info), (picrel)) \&& TLSMOFF_IN_RANGE_FOR_SETLOS_P((value), (info)))
case|case
name|R_FRV_GETTLSOFF
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Is this a call instruction?  */
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x01fc0000
operator|)
operator|!=
literal|0x003c0000
condition|)
block|{
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"R_FRV_GETTLSOFF not applied to a call instruction"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|RELAX_GETTLSOFF_LOCAL_EXEC_P
argument_list|(
name|info
argument_list|,
name|picrel
argument_list|,
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
block|{
comment|/* Replace the call instruction (except the packing bit) 		   with setlos #tlsmofflo(symbol+offset), gr9.  */
name|insn
operator|&=
operator|(
name|unsigned
name|long
operator|)
literal|0x80000000
expr_stmt|;
name|insn
operator||=
operator|(
name|unsigned
name|long
operator|)
literal|0x12fc0000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|R_FRV_TLSMOFFLO
expr_stmt|;
name|howto
operator|=
name|elf32_frv_howto_table
operator|+
name|r_type
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RELAX_GETTLSOFF_INITIAL_EXEC_P
argument_list|(
name|info
argument_list|,
name|picrel
argument_list|)
condition|)
block|{
comment|/* Replace the call instruction (except the packing bit) 		   with ldi @(gr15, #gottlsoff12(symbol+addend)), gr9.  */
name|insn
operator|&=
operator|(
name|unsigned
name|long
operator|)
literal|0x80000000
expr_stmt|;
name|insn
operator||=
operator|(
name|unsigned
name|long
operator|)
literal|0x12c8f000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|R_FRV_GOTTLSOFF12
expr_stmt|;
name|howto
operator|=
name|elf32_frv_howto_table
operator|+
name|r_type
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_FRV_GOTTLSDESC12
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Is this an lddi instruction?  */
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x01fc0000
operator|)
operator|!=
literal|0x00cc0000
condition|)
block|{
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"R_FRV_GOTTLSDESC12 not applied to an lddi instruction"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|RELAX_TLSDESC_LOCAL_EXEC_P
argument_list|(
name|info
argument_list|,
name|picrel
argument_list|,
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|)
operator|&&
name|TLSMOFF_IN_RANGE_FOR_SETLOS_P
argument_list|(
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|,
name|info
argument_list|)
condition|)
block|{
comment|/* Replace lddi @(grB, #gottlsdesc12(symbol+offset), grC 		   with setlos #tlsmofflo(symbol+offset), gr<C+1>. 		   Preserve the packing bit.  */
name|insn
operator|=
operator|(
name|insn
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x80000000
operator|)
operator||
operator|(
operator|(
name|insn
operator|+
operator|(
name|unsigned
name|long
operator|)
literal|0x02000000
operator|)
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x7e000000
operator|)
expr_stmt|;
name|insn
operator||=
operator|(
name|unsigned
name|long
operator|)
literal|0x00fc0000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|R_FRV_TLSMOFFLO
expr_stmt|;
name|howto
operator|=
name|elf32_frv_howto_table
operator|+
name|r_type
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RELAX_TLSDESC_LOCAL_EXEC_P
argument_list|(
name|info
argument_list|,
name|picrel
argument_list|,
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
block|{
comment|/* Replace lddi @(grB, #gottlsdesc12(symbol+offset), grC 		   with sethi #tlsmoffhi(symbol+offset), gr<C+1>. 		   Preserve the packing bit.  */
name|insn
operator|=
operator|(
name|insn
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x80000000
operator|)
operator||
operator|(
operator|(
name|insn
operator|+
operator|(
name|unsigned
name|long
operator|)
literal|0x02000000
operator|)
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x7e000000
operator|)
expr_stmt|;
name|insn
operator||=
operator|(
name|unsigned
name|long
operator|)
literal|0x00f80000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|R_FRV_TLSMOFFHI
expr_stmt|;
name|howto
operator|=
name|elf32_frv_howto_table
operator|+
name|r_type
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RELAX_TLSDESC_INITIAL_EXEC_P
argument_list|(
name|info
argument_list|,
name|picrel
argument_list|)
condition|)
block|{
comment|/* Replace lddi @(grB, #gottlsdesc12(symbol+offset), grC 		   with ldi @(grB, #gottlsoff12(symbol+offset), 		   gr<C+1>.  Preserve the packing bit.  If gottlsoff12 		   overflows, we'll error out, but that's sort-of ok, 		   since we'd started with gottlsdesc12, that's actually 		   more demanding.  Compiling with -fPIE instead of 		   -fpie would fix it; linking with --relax should fix 		   it as well.  */
name|insn
operator|=
operator|(
name|insn
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x80cbf000
operator|)
operator||
operator|(
operator|(
name|insn
operator|+
operator|(
name|unsigned
name|long
operator|)
literal|0x02000000
operator|)
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x7e000000
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|R_FRV_GOTTLSOFF12
expr_stmt|;
name|howto
operator|=
name|elf32_frv_howto_table
operator|+
name|r_type
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_FRV_GOTTLSDESCHI
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Is this a sethi instruction?  */
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x01ff0000
operator|)
operator|!=
literal|0x00f80000
condition|)
block|{
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"R_FRV_GOTTLSDESCHI not applied to a sethi instruction"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|RELAX_TLSDESC_LOCAL_EXEC_P
argument_list|(
name|info
argument_list|,
name|picrel
argument_list|,
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|)
operator|||
operator|(
name|RELAX_TLSDESC_INITIAL_EXEC_P
argument_list|(
name|info
argument_list|,
name|picrel
argument_list|)
operator|&&
name|IN_RANGE_FOR_SETLOS_P
argument_list|(
name|picrel
operator|->
name|tlsoff_entry
argument_list|)
operator|)
condition|)
block|{
comment|/* Replace sethi with a nop.  Preserve the packing bit.  */
name|insn
operator|&=
operator|(
name|unsigned
name|long
operator|)
literal|0x80000000
expr_stmt|;
name|insn
operator||=
operator|(
name|unsigned
name|long
operator|)
literal|0x00880000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Nothing to relocate.  */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|RELAX_TLSDESC_INITIAL_EXEC_P
argument_list|(
name|info
argument_list|,
name|picrel
argument_list|)
condition|)
block|{
comment|/* Simply decay GOTTLSDESC to GOTTLSOFF.  */
name|r_type
operator|=
name|R_FRV_GOTTLSOFFHI
expr_stmt|;
name|howto
operator|=
name|elf32_frv_howto_table
operator|+
name|r_type
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_FRV_GOTTLSDESCLO
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Is this a setlo or setlos instruction?  */
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x01f70000
operator|)
operator|!=
literal|0x00f40000
condition|)
block|{
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"R_FRV_GOTTLSDESCLO"
literal|" not applied to a setlo or setlos instruction"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|RELAX_TLSDESC_LOCAL_EXEC_P
argument_list|(
name|info
argument_list|,
name|picrel
argument_list|,
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|)
operator|||
operator|(
name|RELAX_TLSDESC_INITIAL_EXEC_P
argument_list|(
name|info
argument_list|,
name|picrel
argument_list|)
operator|&&
name|IN_RANGE_FOR_OFST12_P
argument_list|(
name|picrel
operator|->
name|tlsoff_entry
argument_list|)
operator|)
condition|)
block|{
comment|/* Replace setlo/setlos with a nop.  Preserve the 		   packing bit.  */
name|insn
operator|&=
operator|(
name|unsigned
name|long
operator|)
literal|0x80000000
expr_stmt|;
name|insn
operator||=
operator|(
name|unsigned
name|long
operator|)
literal|0x00880000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Nothing to relocate.  */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|RELAX_TLSDESC_INITIAL_EXEC_P
argument_list|(
name|info
argument_list|,
name|picrel
argument_list|)
condition|)
block|{
comment|/* If the corresponding sethi (if it exists) decayed 		   to a nop, make sure this becomes (or already is) a 		   setlos, not setlo.  */
if|if
condition|(
name|IN_RANGE_FOR_SETLOS_P
argument_list|(
name|picrel
operator|->
name|tlsoff_entry
argument_list|)
condition|)
block|{
name|insn
operator||=
operator|(
name|unsigned
name|long
operator|)
literal|0x00080000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
comment|/* Simply decay GOTTLSDESC to GOTTLSOFF.  */
name|r_type
operator|=
name|R_FRV_GOTTLSOFFLO
expr_stmt|;
name|howto
operator|=
name|elf32_frv_howto_table
operator|+
name|r_type
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_FRV_TLSDESC_RELAX
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Is this an ldd instruction?  */
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x01fc0fc0
operator|)
operator|!=
literal|0x00080140
condition|)
block|{
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"R_FRV_TLSDESC_RELAX not applied to an ldd instruction"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|RELAX_TLSDESC_LOCAL_EXEC_P
argument_list|(
name|info
argument_list|,
name|picrel
argument_list|,
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|)
operator|&&
name|TLSMOFF_IN_RANGE_FOR_SETLOS_P
argument_list|(
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|,
name|info
argument_list|)
condition|)
block|{
comment|/* Replace ldd #tlsdesc(symbol+offset)@(grB, grA), grC 		   with setlos #tlsmofflo(symbol+offset), gr<C+1>. 		   Preserve the packing bit.  */
name|insn
operator|=
operator|(
name|insn
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x80000000
operator|)
operator||
operator|(
operator|(
name|insn
operator|+
operator|(
name|unsigned
name|long
operator|)
literal|0x02000000
operator|)
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x7e000000
operator|)
expr_stmt|;
name|insn
operator||=
operator|(
name|unsigned
name|long
operator|)
literal|0x00fc0000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|R_FRV_TLSMOFFLO
expr_stmt|;
name|howto
operator|=
name|elf32_frv_howto_table
operator|+
name|r_type
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RELAX_TLSDESC_LOCAL_EXEC_P
argument_list|(
name|info
argument_list|,
name|picrel
argument_list|,
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
block|{
comment|/* Replace ldd #tlsdesc(symbol+offset)@(grB, grA), grC 		   with sethi #tlsmoffhi(symbol+offset), gr<C+1>. 		   Preserve the packing bit.  */
name|insn
operator|=
operator|(
name|insn
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x80000000
operator|)
operator||
operator|(
operator|(
name|insn
operator|+
operator|(
name|unsigned
name|long
operator|)
literal|0x02000000
operator|)
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x7e000000
operator|)
expr_stmt|;
name|insn
operator||=
operator|(
name|unsigned
name|long
operator|)
literal|0x00f80000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|R_FRV_TLSMOFFHI
expr_stmt|;
name|howto
operator|=
name|elf32_frv_howto_table
operator|+
name|r_type
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RELAX_TLSDESC_INITIAL_EXEC_P
argument_list|(
name|info
argument_list|,
name|picrel
argument_list|)
operator|&&
name|IN_RANGE_FOR_OFST12_P
argument_list|(
name|picrel
operator|->
name|tlsoff_entry
argument_list|)
condition|)
block|{
comment|/* Replace ldd #tlsdesc(symbol+offset)@(grB, grA), grC 		   with ldi @(grB, #gottlsoff12(symbol+offset), gr<C+1>. 		   Preserve the packing bit.  */
name|insn
operator|=
operator|(
name|insn
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x8003f000
operator|)
operator||
operator|(
name|unsigned
name|long
operator|)
literal|0x00c80000
operator||
operator|(
operator|(
name|insn
operator|+
operator|(
name|unsigned
name|long
operator|)
literal|0x02000000
operator|)
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x7e000000
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|R_FRV_GOTTLSOFF12
expr_stmt|;
name|howto
operator|=
name|elf32_frv_howto_table
operator|+
name|r_type
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RELAX_TLSDESC_INITIAL_EXEC_P
argument_list|(
name|info
argument_list|,
name|picrel
argument_list|)
condition|)
block|{
comment|/* Replace ldd #tlsdesc(symbol+offset)@(grB, grA), grC 		   with ld #tlsoff(symbol+offset)@(grB, grA), gr<C+1>. 		   Preserve the packing bit.  */
name|insn
operator|=
operator|(
name|insn
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x81ffffbf
operator|)
operator||
operator|(
operator|(
name|insn
operator|+
operator|(
name|unsigned
name|long
operator|)
literal|0x02000000
operator|)
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x7e000000
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* #tlsoff(symbol+offset) is just a relaxation                     annotation, so there's nothing left to                     relocate.  */
continue|continue;
block|}
break|break;
case|case
name|R_FRV_GETTLSOFF_RELAX
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Is this a calll or callil instruction?  */
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x7ff80fc0
operator|)
operator|!=
literal|0x02300000
condition|)
block|{
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"R_FRV_GETTLSOFF_RELAX"
literal|" not applied to a calll instruction"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|RELAX_TLSDESC_LOCAL_EXEC_P
argument_list|(
name|info
argument_list|,
name|picrel
argument_list|,
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|)
operator|&&
name|TLSMOFF_IN_RANGE_FOR_SETLOS_P
argument_list|(
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|,
name|info
argument_list|)
condition|)
block|{
comment|/* Replace calll with a nop.  Preserve the packing bit.  */
name|insn
operator|&=
operator|(
name|unsigned
name|long
operator|)
literal|0x80000000
expr_stmt|;
name|insn
operator||=
operator|(
name|unsigned
name|long
operator|)
literal|0x00880000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Nothing to relocate.  */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|RELAX_TLSDESC_LOCAL_EXEC_P
argument_list|(
name|info
argument_list|,
name|picrel
argument_list|,
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
block|{
comment|/* Replace calll with setlo #tlsmofflo(symbol+offset), gr9. 		   Preserve the packing bit.  */
name|insn
operator|&=
operator|(
name|unsigned
name|long
operator|)
literal|0x80000000
expr_stmt|;
name|insn
operator||=
operator|(
name|unsigned
name|long
operator|)
literal|0x12f40000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|R_FRV_TLSMOFFLO
expr_stmt|;
name|howto
operator|=
name|elf32_frv_howto_table
operator|+
name|r_type
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RELAX_TLSDESC_INITIAL_EXEC_P
argument_list|(
name|info
argument_list|,
name|picrel
argument_list|)
condition|)
block|{
comment|/* Replace calll with a nop.  Preserve the packing bit.  */
name|insn
operator|&=
operator|(
name|unsigned
name|long
operator|)
literal|0x80000000
expr_stmt|;
name|insn
operator||=
operator|(
name|unsigned
name|long
operator|)
literal|0x00880000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Nothing to relocate.  */
continue|continue;
block|}
break|break;
case|case
name|R_FRV_GOTTLSOFF12
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Is this an ldi instruction?  */
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x01fc0000
operator|)
operator|!=
literal|0x00c80000
condition|)
block|{
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"R_FRV_GOTTLSOFF12 not applied to an ldi instruction"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|RELAX_GOTTLSOFF_LOCAL_EXEC_P
argument_list|(
name|info
argument_list|,
name|picrel
argument_list|,
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
block|{
comment|/* Replace ldi @(grB, #gottlsoff12(symbol+offset), grC 		   with setlos #tlsmofflo(symbol+offset), grC. 		   Preserve the packing bit.  */
name|insn
operator|&=
operator|(
name|unsigned
name|long
operator|)
literal|0xfe000000
expr_stmt|;
name|insn
operator||=
operator|(
name|unsigned
name|long
operator|)
literal|0x00fc0000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|R_FRV_TLSMOFFLO
expr_stmt|;
name|howto
operator|=
name|elf32_frv_howto_table
operator|+
name|r_type
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_FRV_GOTTLSOFFHI
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Is this a sethi instruction?  */
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x01ff0000
operator|)
operator|!=
literal|0x00f80000
condition|)
block|{
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"R_FRV_GOTTLSOFFHI not applied to a sethi instruction"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|RELAX_GOTTLSOFF_LOCAL_EXEC_P
argument_list|(
name|info
argument_list|,
name|picrel
argument_list|,
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|)
operator|||
operator|(
name|RELAX_TLSDESC_INITIAL_EXEC_P
argument_list|(
name|info
argument_list|,
name|picrel
argument_list|)
operator|&&
name|IN_RANGE_FOR_OFST12_P
argument_list|(
name|picrel
operator|->
name|tlsoff_entry
argument_list|)
operator|)
condition|)
block|{
comment|/* Replace sethi with a nop.  Preserve the packing bit.  */
name|insn
operator|&=
operator|(
name|unsigned
name|long
operator|)
literal|0x80000000
expr_stmt|;
name|insn
operator||=
operator|(
name|unsigned
name|long
operator|)
literal|0x00880000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Nothing to relocate.  */
continue|continue;
block|}
break|break;
case|case
name|R_FRV_GOTTLSOFFLO
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Is this a setlo or setlos instruction?  */
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x01f70000
operator|)
operator|!=
literal|0x00f40000
condition|)
block|{
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"R_FRV_GOTTLSOFFLO"
literal|" not applied to a setlo or setlos instruction"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|RELAX_GOTTLSOFF_LOCAL_EXEC_P
argument_list|(
name|info
argument_list|,
name|picrel
argument_list|,
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|)
operator|||
operator|(
name|RELAX_TLSDESC_INITIAL_EXEC_P
argument_list|(
name|info
argument_list|,
name|picrel
argument_list|)
operator|&&
name|IN_RANGE_FOR_OFST12_P
argument_list|(
name|picrel
operator|->
name|tlsoff_entry
argument_list|)
operator|)
condition|)
block|{
comment|/* Replace setlo/setlos with a nop.  Preserve the 		   packing bit.  */
name|insn
operator|&=
operator|(
name|unsigned
name|long
operator|)
literal|0x80000000
expr_stmt|;
name|insn
operator||=
operator|(
name|unsigned
name|long
operator|)
literal|0x00880000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Nothing to relocate.  */
continue|continue;
block|}
break|break;
case|case
name|R_FRV_TLSOFF_RELAX
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Is this an ld instruction?  */
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x01fc0fc0
operator|)
operator|!=
literal|0x00080100
condition|)
block|{
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"R_FRV_TLSOFF_RELAX not applied to an ld instruction"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|RELAX_GOTTLSOFF_LOCAL_EXEC_P
argument_list|(
name|info
argument_list|,
name|picrel
argument_list|,
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
block|{
comment|/* Replace ld #gottlsoff(symbol+offset)@(grB, grA), grC 		   with setlos #tlsmofflo(symbol+offset), grC. 		   Preserve the packing bit.  */
name|insn
operator|&=
operator|(
name|unsigned
name|long
operator|)
literal|0xfe000000
expr_stmt|;
name|insn
operator||=
operator|(
name|unsigned
name|long
operator|)
literal|0x00fc0000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|R_FRV_TLSMOFFLO
expr_stmt|;
name|howto
operator|=
name|elf32_frv_howto_table
operator|+
name|r_type
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RELAX_TLSDESC_INITIAL_EXEC_P
argument_list|(
name|info
argument_list|,
name|picrel
argument_list|)
operator|&&
name|IN_RANGE_FOR_OFST12_P
argument_list|(
name|picrel
operator|->
name|tlsoff_entry
argument_list|)
condition|)
block|{
comment|/* Replace ld #tlsoff(symbol+offset)@(grB, grA), grC 		   with ldi @(grB, #gottlsoff12(symbol+offset), grC. 		   Preserve the packing bit.  */
name|insn
operator|=
operator|(
name|insn
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0xfe03f000
operator|)
operator||
operator|(
name|unsigned
name|long
operator|)
literal|0x00c80000
expr_stmt|;
empty_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|R_FRV_GOTTLSOFF12
expr_stmt|;
name|howto
operator|=
name|elf32_frv_howto_table
operator|+
name|r_type
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|r_symndx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_FRV_TLSMOFFHI
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Is this a sethi instruction?  */
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x01ff0000
operator|)
operator|!=
literal|0x00f80000
condition|)
block|{
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"R_FRV_TLSMOFFHI not applied to a sethi instruction"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|TLSMOFF_IN_RANGE_FOR_SETLOS_P
argument_list|(
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|,
name|info
argument_list|)
condition|)
block|{
comment|/* Replace sethi with a nop.  Preserve the packing bit.  */
name|insn
operator|&=
operator|(
name|unsigned
name|long
operator|)
literal|0x80000000
expr_stmt|;
name|insn
operator||=
operator|(
name|unsigned
name|long
operator|)
literal|0x00880000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Nothing to relocate.  */
continue|continue;
block|}
break|break;
case|case
name|R_FRV_TLSMOFFLO
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Is this a setlo or setlos instruction?  */
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
name|unsigned
name|long
operator|)
literal|0x01f70000
operator|)
operator|!=
literal|0x00f40000
condition|)
block|{
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"R_FRV_TLSMOFFLO"
literal|" not applied to a setlo or setlos instruction"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|TLSMOFF_IN_RANGE_FOR_SETLOS_P
argument_list|(
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|,
name|info
argument_list|)
condition|)
comment|/* If the corresponding sethi (if it exists) decayed 		 to a nop, make sure this becomes (or already is) a 		 setlos, not setlo.  */
block|{
name|insn
operator||=
operator|(
name|unsigned
name|long
operator|)
literal|0x00080000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	      There's nothing to relax in these: 		R_FRV_TLSDESC_VALUE 		R_FRV_TLSOFF 		R_FRV_TLSMOFF12 		R_FRV_TLSMOFFHI 		R_FRV_TLSMOFFLO 		R_FRV_TLSMOFF 	    */
default|default:
break|break;
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_FRV_LABEL24
case|:
name|check_segment
index|[
literal|0
index|]
operator|=
name|isec_segment
expr_stmt|;
if|if
condition|(
operator|!
name|IS_FDPIC
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|check_segment
index|[
literal|1
index|]
operator|=
name|isec_segment
expr_stmt|;
elseif|else
if|if
condition|(
name|picrel
operator|->
name|plt
condition|)
block|{
name|relocation
operator|=
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|picrel
operator|->
name|plt_entry
expr_stmt|;
name|check_segment
index|[
literal|1
index|]
operator|=
name|plt_segment
expr_stmt|;
block|}
comment|/* We don't want to warn on calls to undefined weak symbols, 	     as calls to them must be protected by non-NULL tests 	     anyway, and unprotected calls would invoke undefined 	     behavior.  */
elseif|else
if|if
condition|(
name|picrel
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
name|picrel
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|check_segment
index|[
literal|1
index|]
operator|=
name|check_segment
index|[
literal|0
index|]
expr_stmt|;
else|else
name|check_segment
index|[
literal|1
index|]
operator|=
name|sec
condition|?
name|_frvfdpic_osec_to_segment
argument_list|(
name|output_bfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|)
else|:
operator|(
name|unsigned
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|R_FRV_GOT12
case|:
case|case
name|R_FRV_GOTHI
case|:
case|case
name|R_FRV_GOTLO
case|:
name|relocation
operator|=
name|picrel
operator|->
name|got_entry
expr_stmt|;
name|check_segment
index|[
literal|0
index|]
operator|=
name|check_segment
index|[
literal|1
index|]
operator|=
name|got_segment
expr_stmt|;
break|break;
case|case
name|R_FRV_FUNCDESC_GOT12
case|:
case|case
name|R_FRV_FUNCDESC_GOTHI
case|:
case|case
name|R_FRV_FUNCDESC_GOTLO
case|:
name|relocation
operator|=
name|picrel
operator|->
name|fdgot_entry
expr_stmt|;
name|check_segment
index|[
literal|0
index|]
operator|=
name|check_segment
index|[
literal|1
index|]
operator|=
name|got_segment
expr_stmt|;
break|break;
case|case
name|R_FRV_GOTOFFHI
case|:
case|case
name|R_FRV_GOTOFF12
case|:
case|case
name|R_FRV_GOTOFFLO
case|:
name|relocation
operator|-=
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|frvfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|check_segment
index|[
literal|0
index|]
operator|=
name|got_segment
expr_stmt|;
name|check_segment
index|[
literal|1
index|]
operator|=
name|sec
condition|?
name|_frvfdpic_osec_to_segment
argument_list|(
name|output_bfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|)
else|:
operator|(
name|unsigned
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|R_FRV_FUNCDESC_GOTOFF12
case|:
case|case
name|R_FRV_FUNCDESC_GOTOFFHI
case|:
case|case
name|R_FRV_FUNCDESC_GOTOFFLO
case|:
name|relocation
operator|=
name|picrel
operator|->
name|fd_entry
expr_stmt|;
name|check_segment
index|[
literal|0
index|]
operator|=
name|check_segment
index|[
literal|1
index|]
operator|=
name|got_segment
expr_stmt|;
break|break;
case|case
name|R_FRV_FUNCDESC
case|:
block|{
name|int
name|dynindx
decl_stmt|;
name|bfd_vma
name|addend
init|=
name|rel
operator|->
name|r_addend
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|h
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|&&
name|FRVFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|)
condition|)
block|{
comment|/* If the symbol is dynamic and there may be dynamic 		   symbol resolution because we are or are linked with a 		   shared library, emit a FUNCDESC relocation such that 		   the dynamic linker will allocate the function 		   descriptor.  If the symbol needs a non-local function 		   descriptor but binds locally (e.g., its visibility is 		   protected, emit a dynamic relocation decayed to 		   section+offset.  */
if|if
condition|(
name|h
operator|&&
operator|!
name|FRVFDPIC_FUNCDESC_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|&&
name|FRVFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|&&
operator|!
operator|(
name|info
operator|->
name|executable
operator|&&
operator|!
name|info
operator|->
name|pie
operator|)
condition|)
block|{
name|dynindx
operator|=
name|elf_section_data
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
argument_list|)
operator|->
name|dynindx
expr_stmt|;
name|addend
operator|+=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|&&
operator|!
name|FRVFDPIC_FUNCDESC_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
if|if
condition|(
name|addend
condition|)
block|{
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"R_FRV_FUNCDESC references dynamic symbol with nonzero addend"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|dynindx
operator|=
name|h
operator|->
name|dynindx
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, we know we have a private function 		       descriptor, so reference it directly.  */
name|BFD_ASSERT
argument_list|(
name|picrel
operator|->
name|privfd
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|R_FRV_32
expr_stmt|;
name|dynindx
operator|=
name|elf_section_data
argument_list|(
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
argument_list|)
operator|->
name|dynindx
expr_stmt|;
name|addend
operator|=
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|frvfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|+
name|picrel
operator|->
name|fd_entry
expr_stmt|;
block|}
comment|/* If there is room for dynamic symbol resolution, emit 		   the dynamic relocation.  However, if we're linking an 		   executable at a fixed location, we won't have emitted a 		   dynamic symbol entry for the got section, so idx will 		   be zero, which means we can and should compute the 		   address of the private descriptor ourselves.  */
if|if
condition|(
name|info
operator|->
name|executable
operator|&&
operator|!
name|info
operator|->
name|pie
operator|&&
operator|(
operator|!
name|h
operator|||
name|FRVFDPIC_FUNCDESC_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|)
condition|)
block|{
name|addend
operator|+=
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|output_bfd
argument_list|,
name|input_section
operator|->
name|output_section
argument_list|)
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
operator|)
operator|==
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
condition|)
block|{
if|if
condition|(
name|_frvfdpic_osec_readonly_p
argument_list|(
name|output_bfd
argument_list|,
name|input_section
operator|->
name|output_section
argument_list|)
condition|)
block|{
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"cannot emit fixups in read-only section"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|_frvfdpic_add_rofixup
argument_list|(
name|output_bfd
argument_list|,
name|frvfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
argument_list|,
name|picrel
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|output_bfd
argument_list|,
name|input_section
operator|->
name|output_section
argument_list|)
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
operator|)
operator|==
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
condition|)
block|{
if|if
condition|(
name|_frvfdpic_osec_readonly_p
argument_list|(
name|output_bfd
argument_list|,
name|input_section
operator|->
name|output_section
argument_list|)
condition|)
block|{
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"cannot emit dynamic relocations in read-only section"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|_frvfdpic_add_dyn_reloc
argument_list|(
name|output_bfd
argument_list|,
name|frvfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
argument_list|,
name|r_type
argument_list|,
name|dynindx
argument_list|,
name|addend
argument_list|,
name|picrel
argument_list|)
expr_stmt|;
block|}
else|else
name|addend
operator|+=
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
block|}
comment|/* We want the addend in-place because dynamic 	       relocations are REL.  Setting relocation to it should 	       arrange for it to be installed.  */
name|relocation
operator|=
name|addend
operator|-
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
name|check_segment
index|[
literal|0
index|]
operator|=
name|check_segment
index|[
literal|1
index|]
operator|=
name|got_segment
expr_stmt|;
break|break;
case|case
name|R_FRV_32
case|:
if|if
condition|(
operator|!
name|IS_FDPIC
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|check_segment
index|[
literal|0
index|]
operator|=
name|check_segment
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|R_FRV_FUNCDESC_VALUE
case|:
block|{
name|int
name|dynindx
decl_stmt|;
name|bfd_vma
name|addend
init|=
name|rel
operator|->
name|r_addend
decl_stmt|;
comment|/* If the symbol is dynamic but binds locally, use 	       section+offset.  */
if|if
condition|(
name|h
operator|&&
operator|!
name|FRVFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
if|if
condition|(
name|addend
operator|&&
name|r_type
operator|==
name|R_FRV_FUNCDESC_VALUE
condition|)
block|{
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"R_FRV_FUNCDESC_VALUE references dynamic symbol with nonzero addend"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|dynindx
operator|=
name|h
operator|->
name|dynindx
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|h
condition|)
name|addend
operator|+=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
else|else
name|addend
operator|+=
name|sym
operator|->
name|st_value
expr_stmt|;
if|if
condition|(
name|osec
condition|)
name|addend
operator|+=
name|osec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|osec
operator|&&
name|osec
operator|->
name|output_section
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|osec
operator|->
name|output_section
argument_list|)
operator|&&
operator|!
name|bfd_is_und_section
argument_list|(
name|osec
operator|->
name|output_section
argument_list|)
condition|)
name|dynindx
operator|=
name|elf_section_data
argument_list|(
name|osec
operator|->
name|output_section
argument_list|)
operator|->
name|dynindx
expr_stmt|;
else|else
name|dynindx
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we're linking an executable at a fixed address, we 	       can omit the dynamic relocation as long as the symbol 	       is defined in the current link unit (which is implied 	       by its output section not being NULL).  */
if|if
condition|(
name|info
operator|->
name|executable
operator|&&
operator|!
name|info
operator|->
name|pie
operator|&&
operator|(
operator|!
name|h
operator|||
name|FRVFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|osec
condition|)
name|addend
operator|+=
name|osec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|IS_FDPIC
argument_list|(
name|input_bfd
argument_list|)
operator|&&
operator|(
name|bfd_get_section_flags
argument_list|(
name|output_bfd
argument_list|,
name|input_section
operator|->
name|output_section
argument_list|)
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
operator|)
operator|==
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
condition|)
block|{
if|if
condition|(
name|_frvfdpic_osec_readonly_p
argument_list|(
name|output_bfd
argument_list|,
name|input_section
operator|->
name|output_section
argument_list|)
condition|)
block|{
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"cannot emit fixups in read-only section"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|h
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
condition|)
block|{
name|_frvfdpic_add_rofixup
argument_list|(
name|output_bfd
argument_list|,
name|frvfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
argument_list|,
name|picrel
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_FRV_FUNCDESC_VALUE
condition|)
name|_frvfdpic_add_rofixup
argument_list|(
name|output_bfd
argument_list|,
name|frvfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
literal|4
argument_list|,
name|picrel
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|output_bfd
argument_list|,
name|input_section
operator|->
name|output_section
argument_list|)
operator|&
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
operator|)
operator|==
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
condition|)
block|{
if|if
condition|(
name|_frvfdpic_osec_readonly_p
argument_list|(
name|output_bfd
argument_list|,
name|input_section
operator|->
name|output_section
argument_list|)
condition|)
block|{
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"cannot emit dynamic relocations in read-only section"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|_frvfdpic_add_dyn_reloc
argument_list|(
name|output_bfd
argument_list|,
name|frvfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
argument_list|,
name|r_type
argument_list|,
name|dynindx
argument_list|,
name|addend
argument_list|,
name|picrel
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osec
condition|)
name|addend
operator|+=
name|osec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
comment|/* We want the addend in-place because dynamic 		   relocations are REL.  Setting relocation to it 		   should arrange for it to be installed.  */
name|relocation
operator|=
name|addend
operator|-
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_FRV_FUNCDESC_VALUE
condition|)
block|{
comment|/* If we've omitted the dynamic relocation, just emit 		   the fixed addresses of the symbol and of the local 		   GOT base offset.  */
if|if
condition|(
name|info
operator|->
name|executable
operator|&&
operator|!
name|info
operator|->
name|pie
operator|&&
operator|(
operator|!
name|h
operator|||
name|FRVFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|)
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|frvfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
else|else
comment|/* A function descriptor used for lazy or local 		     resolving is initialized such that its high word 		     contains the output section index in which the 		     PLT entries are located, and the low word 		     contains the offset of the lazy PLT entry entry 		     point into that section.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|h
operator|&&
operator|!
name|FRVFDPIC_SYM_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|?
literal|0
else|:
name|_frvfdpic_osec_to_segment
argument_list|(
name|output_bfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|)
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
name|check_segment
index|[
literal|0
index|]
operator|=
name|check_segment
index|[
literal|1
index|]
operator|=
name|got_segment
expr_stmt|;
break|break;
case|case
name|R_FRV_GPREL12
case|:
case|case
name|R_FRV_GPRELU12
case|:
case|case
name|R_FRV_GPREL32
case|:
case|case
name|R_FRV_GPRELHI
case|:
case|case
name|R_FRV_GPRELLO
case|:
name|check_segment
index|[
literal|0
index|]
operator|=
name|gprel_segment
expr_stmt|;
name|check_segment
index|[
literal|1
index|]
operator|=
name|sec
condition|?
name|_frvfdpic_osec_to_segment
argument_list|(
name|output_bfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|)
else|:
operator|(
name|unsigned
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|R_FRV_GETTLSOFF
case|:
name|relocation
operator|=
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|picrel
operator|->
name|tlsplt_entry
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|picrel
operator|->
name|tlsplt_entry
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&&
name|picrel
operator|->
name|tlsdesc_entry
argument_list|)
expr_stmt|;
name|check_segment
index|[
literal|0
index|]
operator|=
name|isec_segment
expr_stmt|;
name|check_segment
index|[
literal|1
index|]
operator|=
name|plt_segment
expr_stmt|;
break|break;
case|case
name|R_FRV_GOTTLSDESC12
case|:
case|case
name|R_FRV_GOTTLSDESCHI
case|:
case|case
name|R_FRV_GOTTLSDESCLO
case|:
name|BFD_ASSERT
argument_list|(
name|picrel
operator|->
name|tlsdesc_entry
argument_list|)
expr_stmt|;
name|relocation
operator|=
name|picrel
operator|->
name|tlsdesc_entry
expr_stmt|;
name|check_segment
index|[
literal|0
index|]
operator|=
name|tls_segment
expr_stmt|;
name|check_segment
index|[
literal|1
index|]
operator|=
name|sec
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
operator|&&
operator|!
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
condition|?
name|_frvfdpic_osec_to_segment
argument_list|(
name|output_bfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|)
else|:
name|tls_segment
expr_stmt|;
break|break;
case|case
name|R_FRV_TLSMOFF12
case|:
case|case
name|R_FRV_TLSMOFFHI
case|:
case|case
name|R_FRV_TLSMOFFLO
case|:
case|case
name|R_FRV_TLSMOFF
case|:
name|check_segment
index|[
literal|0
index|]
operator|=
name|tls_segment
expr_stmt|;
if|if
condition|(
operator|!
name|sec
condition|)
name|check_segment
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
operator|||
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
name|relocation
operator|=
literal|0
expr_stmt|;
name|check_segment
index|[
literal|1
index|]
operator|=
name|tls_segment
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sec
operator|->
name|output_section
condition|)
block|{
name|relocation
operator|-=
name|tls_biased_base
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|check_segment
index|[
literal|1
index|]
operator|=
name|_frvfdpic_osec_to_segment
argument_list|(
name|output_bfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|)
expr_stmt|;
block|}
else|else
name|check_segment
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|R_FRV_GOTTLSOFF12
case|:
case|case
name|R_FRV_GOTTLSOFFHI
case|:
case|case
name|R_FRV_GOTTLSOFFLO
case|:
name|BFD_ASSERT
argument_list|(
name|picrel
operator|->
name|tlsoff_entry
argument_list|)
expr_stmt|;
name|relocation
operator|=
name|picrel
operator|->
name|tlsoff_entry
expr_stmt|;
name|check_segment
index|[
literal|0
index|]
operator|=
name|tls_segment
expr_stmt|;
name|check_segment
index|[
literal|1
index|]
operator|=
name|sec
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
operator|&&
operator|!
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
condition|?
name|_frvfdpic_osec_to_segment
argument_list|(
name|output_bfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|)
else|:
name|tls_segment
expr_stmt|;
break|break;
case|case
name|R_FRV_TLSDESC_VALUE
case|:
case|case
name|R_FRV_TLSOFF
case|:
comment|/* These shouldn't be present in input object files.  */
name|check_segment
index|[
literal|0
index|]
operator|=
name|check_segment
index|[
literal|1
index|]
operator|=
name|isec_segment
expr_stmt|;
break|break;
case|case
name|R_FRV_TLSDESC_RELAX
case|:
case|case
name|R_FRV_GETTLSOFF_RELAX
case|:
case|case
name|R_FRV_TLSOFF_RELAX
case|:
comment|/* These are just annotations for relaxation, nothing to do 	     here.  */
continue|continue;
default|default:
name|check_segment
index|[
literal|0
index|]
operator|=
name|isec_segment
expr_stmt|;
name|check_segment
index|[
literal|1
index|]
operator|=
name|sec
condition|?
name|_frvfdpic_osec_to_segment
argument_list|(
name|output_bfd
argument_list|,
name|sec
operator|->
name|output_section
argument_list|)
else|:
operator|(
name|unsigned
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|check_segment
index|[
literal|0
index|]
operator|!=
name|check_segment
index|[
literal|1
index|]
operator|&&
name|IS_FDPIC
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
comment|/* If you take this out, remove the #error from fdpic-static-6.d 	     in the ld testsuite.  */
comment|/* This helps catch problems in GCC while we can't do more 	     than static linking.  The idea is to test whether the 	     input file basename is crt0.o only once.  */
if|if
condition|(
name|silence_segment_error
operator|==
literal|1
condition|)
name|silence_segment_error
operator|=
operator|(
name|strlen
argument_list|(
name|input_bfd
operator|->
name|filename
argument_list|)
operator|==
literal|6
operator|&&
name|strcmp
argument_list|(
name|input_bfd
operator|->
name|filename
argument_list|,
literal|"crt0.o"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strlen
argument_list|(
name|input_bfd
operator|->
name|filename
argument_list|)
operator|>
literal|6
operator|&&
name|strcmp
argument_list|(
name|input_bfd
operator|->
name|filename
operator|+
name|strlen
argument_list|(
name|input_bfd
operator|->
name|filename
argument_list|)
operator|-
literal|7
argument_list|,
literal|"/crt0.o"
argument_list|)
operator|==
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|silence_segment_error
comment|/* We don't want duplicate errors for undefined 		 symbols.  */
operator|&&
operator|!
operator|(
name|picrel
operator|&&
name|picrel
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
name|picrel
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|)
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|shared
operator|||
name|info
operator|->
name|pie
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): reloc against `%s': %s"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|name
argument_list|,
name|_
argument_list|(
literal|"relocation references a different segment"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"relocation references a different segment"
argument_list|)
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|silence_segment_error
operator|&&
operator|(
name|info
operator|->
name|shared
operator|||
name|info
operator|->
name|pie
operator|)
condition|)
return|return
name|FALSE
return|;
name|elf_elfheader
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_FRV_PIC
expr_stmt|;
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_FRV_GOTOFFHI
case|:
case|case
name|R_FRV_TLSMOFFHI
case|:
comment|/* We need the addend to be applied before we shift the 	     value right.  */
name|relocation
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
comment|/* Fall through.  */
case|case
name|R_FRV_GOTHI
case|:
case|case
name|R_FRV_FUNCDESC_GOTHI
case|:
case|case
name|R_FRV_FUNCDESC_GOTOFFHI
case|:
case|case
name|R_FRV_GOTTLSOFFHI
case|:
case|case
name|R_FRV_GOTTLSDESCHI
case|:
name|relocation
operator|>>=
literal|16
expr_stmt|;
comment|/* Fall through.  */
case|case
name|R_FRV_GOTLO
case|:
case|case
name|R_FRV_FUNCDESC_GOTLO
case|:
case|case
name|R_FRV_GOTOFFLO
case|:
case|case
name|R_FRV_FUNCDESC_GOTOFFLO
case|:
case|case
name|R_FRV_GOTTLSOFFLO
case|:
case|case
name|R_FRV_GOTTLSDESCLO
case|:
case|case
name|R_FRV_TLSMOFFLO
case|:
name|relocation
operator|&=
literal|0xffff
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_FRV_LABEL24
case|:
if|if
condition|(
operator|!
name|IS_FDPIC
argument_list|(
name|output_bfd
argument_list|)
operator|||
operator|!
name|picrel
operator|->
name|plt
condition|)
break|break;
comment|/* Fall through.  */
comment|/* When referencing a GOT entry, a function descriptor or a 	     PLT, we don't want the addend to apply to the reference, 	     but rather to the referenced symbol.  The actual entry 	     will have already been created taking the addend into 	     account, so cancel it out here.  */
case|case
name|R_FRV_GOT12
case|:
case|case
name|R_FRV_GOTHI
case|:
case|case
name|R_FRV_GOTLO
case|:
case|case
name|R_FRV_FUNCDESC_GOT12
case|:
case|case
name|R_FRV_FUNCDESC_GOTHI
case|:
case|case
name|R_FRV_FUNCDESC_GOTLO
case|:
case|case
name|R_FRV_FUNCDESC_GOTOFF12
case|:
case|case
name|R_FRV_FUNCDESC_GOTOFFHI
case|:
case|case
name|R_FRV_FUNCDESC_GOTOFFLO
case|:
case|case
name|R_FRV_GETTLSOFF
case|:
case|case
name|R_FRV_GOTTLSDESC12
case|:
case|case
name|R_FRV_GOTTLSDESCHI
case|:
case|case
name|R_FRV_GOTTLSDESCLO
case|:
case|case
name|R_FRV_GOTTLSOFF12
case|:
case|case
name|R_FRV_GOTTLSOFFHI
case|:
case|case
name|R_FRV_GOTTLSOFFLO
case|:
comment|/* Note that we only want GOTOFFHI, not GOTOFFLO or GOTOFF12 	     here, since we do want to apply the addend to the others. 	     Note that we've applied the addend to GOTOFFHI before we 	     shifted it right.  */
case|case
name|R_FRV_GOTOFFHI
case|:
case|case
name|R_FRV_TLSMOFFHI
case|:
name|relocation
operator|-=
name|rel
operator|->
name|r_addend
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|r_type
operator|==
name|R_FRV_HI16
condition|)
name|r
operator|=
name|elf32_frv_relocate_hi16
argument_list|(
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|contents
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_FRV_LO16
condition|)
name|r
operator|=
name|elf32_frv_relocate_lo16
argument_list|(
name|input_bfd
argument_list|,
name|rel
argument_list|,
name|contents
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_FRV_LABEL24
operator|||
name|r_type
operator|==
name|R_FRV_GETTLSOFF
condition|)
name|r
operator|=
name|elf32_frv_relocate_label24
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|contents
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_FRV_GPREL12
condition|)
name|r
operator|=
name|elf32_frv_relocate_gprel12
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|contents
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_FRV_GPRELU12
condition|)
name|r
operator|=
name|elf32_frv_relocate_gprelu12
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|contents
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_FRV_GPRELLO
condition|)
name|r
operator|=
name|elf32_frv_relocate_gprello
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|contents
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_FRV_GPRELHI
condition|)
name|r
operator|=
name|elf32_frv_relocate_gprelhi
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|contents
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|==
name|R_FRV_TLSOFF
operator|||
name|r_type
operator|==
name|R_FRV_TLSDESC_VALUE
condition|)
name|r
operator|=
name|bfd_reloc_notsupported
expr_stmt|;
else|else
name|r
operator|=
name|frv_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_overflow
case|:
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
argument_list|(
name|info
argument_list|,
operator|(
name|h
condition|?
operator|&
name|h
operator|->
name|root
else|:
name|NULL
operator|)
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_undefined
case|:
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: out of range error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_notsupported
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unsupported relocation error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_dangerous
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: dangerous relocation"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unknown error"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|msg
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): reloc against `%s': %s"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|name
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|r
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the section that should be marked against GC for a given    relocation.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|elf32_frv_gc_mark_hook
parameter_list|(
name|sec
parameter_list|,
name|info
parameter_list|,
name|rel
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_FRV_GNU_VTINHERIT
case|:
case|case
name|R_FRV_GNU_VTENTRY
case|:
break|break;
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
default|default:
break|break;
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
block|}
block|}
block|}
else|else
return|return
name|bfd_section_from_elf_index
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Update the got entry reference counts for the section being removed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_frv_gc_sweep_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hook called by the linker routine which adds symbols from an object    file.  We use it to put .comm items in .scomm, and not .comm.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_frv_add_symbol_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sym
parameter_list|,
name|namep
parameter_list|,
name|flagsp
parameter_list|,
name|secp
parameter_list|,
name|valp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|namep
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|flagword
modifier|*
name|flagsp
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secp
decl_stmt|;
name|bfd_vma
modifier|*
name|valp
decl_stmt|;
block|{
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
operator|&&
operator|!
name|info
operator|->
name|relocatable
operator|&&
operator|(
name|int
operator|)
name|sym
operator|->
name|st_size
operator|<=
operator|(
name|int
operator|)
name|bfd_get_gp_size
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/* Common symbols less than or equal to -G nn bytes are 	 automatically put into .sbss.  */
name|asection
modifier|*
name|scomm
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".scommon"
argument_list|)
decl_stmt|;
if|if
condition|(
name|scomm
operator|==
name|NULL
condition|)
block|{
name|scomm
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".scommon"
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_IS_COMMON
operator||
name|SEC_LINKER_CREATED
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scomm
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
operator|*
name|secp
operator|=
name|scomm
expr_stmt|;
operator|*
name|valp
operator|=
name|sym
operator|->
name|st_size
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* We need dynamic symbols for every section, since segments can    relocate independently.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|_frvfdpic_link_omit_section_dynsym
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|p
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
switch|switch
condition|(
name|elf_section_data
argument_list|(
name|p
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
condition|)
block|{
case|case
name|SHT_PROGBITS
case|:
case|case
name|SHT_NOBITS
case|:
comment|/* If sh_type is yet undecided, assume it could be 	 SHT_PROGBITS/SHT_NOBITS.  */
case|case
name|SHT_NULL
case|:
return|return
name|FALSE
return|;
comment|/* There shouldn't be section relative relocations 	 against any other section.  */
default|default:
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Create  a .got section, as well as its additional info field.  This    is almost entirely copied from    elflink.c:_bfd_elf_create_got_section().  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|_frv_create_got_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|flagword
name|flags
decl_stmt|,
name|pltflags
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|int
name|ptralign
decl_stmt|;
name|int
name|offset
decl_stmt|;
comment|/* This function may be called more than once.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|!=
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* Machine specific: although pointers are 32-bits wide, we want the      GOT to be aligned to a 64-bit boundary, such that function      descriptors in it can be accessed with 64-bit loads and      stores.  */
name|ptralign
operator|=
literal|3
expr_stmt|;
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
name|pltflags
operator|=
name|flags
expr_stmt|;
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".got"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|ptralign
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|bed
operator|->
name|want_got_plt
condition|)
block|{
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".got.plt"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|ptralign
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|bed
operator|->
name|want_got_sym
condition|)
block|{
comment|/* Define the symbol _GLOBAL_OFFSET_TABLE_ at the start of the .got 	 (or .got.plt) section.  We don't do this in the linker script 	 because we don't want to define the symbol if we are not creating 	 a global offset table.  */
name|h
operator|=
name|_bfd_elf_define_linkage_sym
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|s
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
expr_stmt|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hgot
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Machine-specific: we want the symbol for executables as 	 well.  */
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* The first bit of the global offset table is the header.  */
name|s
operator|->
name|size
operator|+=
name|bed
operator|->
name|got_header_size
expr_stmt|;
comment|/* This is the machine-specific part.  Create and initialize section      data for the got.  */
if|if
condition|(
name|IS_FDPIC
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|=
name|s
expr_stmt|;
name|frvfdpic_relocs_info
argument_list|(
name|info
argument_list|)
operator|=
name|htab_try_create
argument_list|(
literal|1
argument_list|,
name|frvfdpic_relocs_info_hash
argument_list|,
name|frvfdpic_relocs_info_eq
argument_list|,
operator|(
name|htab_del
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|frvfdpic_relocs_info
argument_list|(
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".rel.got"
argument_list|,
operator|(
name|flags
operator||
name|SEC_READONLY
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|frvfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
operator|=
name|s
expr_stmt|;
comment|/* Machine-specific.  */
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".rofixup"
argument_list|,
operator|(
name|flags
operator||
name|SEC_READONLY
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|frvfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
operator|=
name|s
expr_stmt|;
name|offset
operator|=
operator|-
literal|2048
expr_stmt|;
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
literal|2048
expr_stmt|;
name|flags
operator|=
name|BSF_GLOBAL
operator||
name|BSF_WEAK
expr_stmt|;
block|}
comment|/* Define _gp in .rofixup, for FDPIC, or .got otherwise.  If it      turns out that we're linking with a different linker script, the      linker script will override it.  */
name|bh
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
literal|"_gp"
argument_list|,
name|flags
argument_list|,
name|s
argument_list|,
name|offset
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|bed
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
comment|/* h->other = STV_HIDDEN; */
comment|/* Should we?  */
comment|/* Machine-specific: we want the symbol for executables as well.  */
if|if
condition|(
name|IS_FDPIC
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|IS_FDPIC
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* FDPIC supports Thread Local Storage, and this may require a      procedure linkage table for TLS PLT entries.  */
comment|/* This is mostly copied from      elflink.c:_bfd_elf_create_dynamic_sections().  */
name|flags
operator|=
name|pltflags
expr_stmt|;
name|pltflags
operator||=
name|SEC_CODE
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|plt_not_loaded
condition|)
name|pltflags
operator|&=
operator|~
operator|(
name|SEC_CODE
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator|)
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|plt_readonly
condition|)
name|pltflags
operator||=
name|SEC_READONLY
expr_stmt|;
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".plt"
argument_list|,
name|pltflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|bed
operator|->
name|plt_alignment
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* FRV-specific: remember it.  */
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|=
name|s
expr_stmt|;
comment|/* Define the symbol _PROCEDURE_LINKAGE_TABLE_ at the start of the      .plt section.  */
if|if
condition|(
name|bed
operator|->
name|want_plt_sym
condition|)
block|{
name|h
operator|=
name|_bfd_elf_define_linkage_sym
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|s
argument_list|,
literal|"_PROCEDURE_LINKAGE_TABLE_"
argument_list|)
expr_stmt|;
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hplt
operator|=
name|h
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* FRV-specific: we want rel relocations for the plt.  */
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".rel.plt"
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|bed
operator|->
name|s
operator|->
name|log_file_align
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* FRV-specific: remember it.  */
name|frvfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|=
name|s
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Make sure the got and plt sections exist, and that our pointers in    the link hash table point to them.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_frvfdpic_create_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
comment|/* This is mostly copied from      elflink.c:_bfd_elf_create_dynamic_sections().  */
name|flagword
name|flags
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|flags
operator|=
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
comment|/* We need to create .plt, .rel[a].plt, .got, .got.plt, .dynbss, and      .rel[a].bss sections.  */
comment|/* FRV-specific: we want to create the GOT and the PLT in the FRV      way.  */
if|if
condition|(
operator|!
name|_frv_create_got_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* FRV-specific: make sure we created everything we wanted.  */
name|BFD_ASSERT
argument_list|(
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|&&
name|frvfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
operator|&&
name|frvfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
operator|&&
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|&&
name|frvfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bed
operator|->
name|want_dynbss
condition|)
block|{
comment|/* The .dynbss section is a place to put symbols which are defined 	 by dynamic objects, are referenced by regular objects, and are 	 not functions.  We must allocate space for them in the process 	 image and use a R_*_COPY reloc to tell the dynamic linker to 	 initialize them at run time.  The linker script puts the .dynbss 	 section into the .bss section of the final image.  */
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
literal|".dynbss"
argument_list|,
name|SEC_ALLOC
operator||
name|SEC_LINKER_CREATED
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* The .rel[a].bss section holds copy relocs.  This section is not      normally needed.  We need to create it here, though, so that the      linker will map it to an output section.  We can't just create it      only if we need it, because we will not know whether we need it      until we have seen all the input files, and the first time the      main linker code calls BFD after examining all the input files      (size_dynamic_sections) the input sections have already been      mapped to the output sections.  If the section turns out not to      be needed, we can discard it later.  We will never need this      section when generating a shared object, since they do not use      copy relocs.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|s
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|abfd
argument_list|,
operator|(
name|bed
operator|->
name|default_use_rela_p
condition|?
literal|".rela.bss"
else|:
literal|".rel.bss"
operator|)
argument_list|,
name|flags
operator||
name|SEC_READONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|bed
operator|->
name|s
operator|->
name|log_file_align
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Compute the total GOT and PLT size required by each symbol in each    range.  Symbols may require up to 4 words in the GOT: an entry    pointing to the symbol, an entry pointing to its function    descriptor, and a private function descriptors taking two    words.  */
end_comment

begin_function
specifier|static
name|void
name|_frvfdpic_count_nontls_entries
parameter_list|(
name|struct
name|frvfdpic_relocs_info
modifier|*
name|entry
parameter_list|,
name|struct
name|_frvfdpic_dynamic_got_info
modifier|*
name|dinfo
parameter_list|)
block|{
comment|/* Allocate space for a GOT entry pointing to the symbol.  */
if|if
condition|(
name|entry
operator|->
name|got12
condition|)
name|dinfo
operator|->
name|got12
operator|+=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|gotlos
condition|)
name|dinfo
operator|->
name|gotlos
operator|+=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|gothilo
condition|)
name|dinfo
operator|->
name|gothilo
operator|+=
literal|4
expr_stmt|;
else|else
name|entry
operator|->
name|relocs32
operator|--
expr_stmt|;
name|entry
operator|->
name|relocs32
operator|++
expr_stmt|;
comment|/* Allocate space for a GOT entry pointing to the function      descriptor.  */
if|if
condition|(
name|entry
operator|->
name|fdgot12
condition|)
name|dinfo
operator|->
name|got12
operator|+=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|fdgotlos
condition|)
name|dinfo
operator|->
name|gotlos
operator|+=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|fdgothilo
condition|)
name|dinfo
operator|->
name|gothilo
operator|+=
literal|4
expr_stmt|;
else|else
name|entry
operator|->
name|relocsfd
operator|--
expr_stmt|;
name|entry
operator|->
name|relocsfd
operator|++
expr_stmt|;
comment|/* Decide whether we need a PLT entry, a function descriptor in the      GOT, and a lazy PLT entry for this symbol.  */
name|entry
operator|->
name|plt
operator|=
name|entry
operator|->
name|call
operator|&&
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|FRVFDPIC_SYM_LOCAL
argument_list|(
name|dinfo
operator|->
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|&&
name|elf_hash_table
argument_list|(
name|dinfo
operator|->
name|info
argument_list|)
operator|->
name|dynamic_sections_created
expr_stmt|;
name|entry
operator|->
name|privfd
operator|=
name|entry
operator|->
name|plt
operator|||
name|entry
operator|->
name|fdgoff12
operator|||
name|entry
operator|->
name|fdgofflos
operator|||
name|entry
operator|->
name|fdgoffhilo
operator|||
operator|(
operator|(
name|entry
operator|->
name|fd
operator|||
name|entry
operator|->
name|fdgot12
operator|||
name|entry
operator|->
name|fdgotlos
operator|||
name|entry
operator|->
name|fdgothilo
operator|)
operator|&&
operator|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|FRVFDPIC_FUNCDESC_LOCAL
argument_list|(
name|dinfo
operator|->
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|)
operator|)
expr_stmt|;
name|entry
operator|->
name|lazyplt
operator|=
name|entry
operator|->
name|privfd
operator|&&
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|FRVFDPIC_SYM_LOCAL
argument_list|(
name|dinfo
operator|->
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|&&
operator|!
operator|(
name|dinfo
operator|->
name|info
operator|->
name|flags
operator|&
name|DF_BIND_NOW
operator|)
operator|&&
name|elf_hash_table
argument_list|(
name|dinfo
operator|->
name|info
argument_list|)
operator|->
name|dynamic_sections_created
expr_stmt|;
comment|/* Allocate space for a function descriptor.  */
if|if
condition|(
name|entry
operator|->
name|fdgoff12
condition|)
name|dinfo
operator|->
name|fd12
operator|+=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|fdgofflos
condition|)
name|dinfo
operator|->
name|fdlos
operator|+=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|privfd
operator|&&
name|entry
operator|->
name|plt
condition|)
name|dinfo
operator|->
name|fdplt
operator|+=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|privfd
condition|)
name|dinfo
operator|->
name|fdhilo
operator|+=
literal|8
expr_stmt|;
else|else
name|entry
operator|->
name|relocsfdv
operator|--
expr_stmt|;
name|entry
operator|->
name|relocsfdv
operator|++
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|lazyplt
condition|)
name|dinfo
operator|->
name|lzplt
operator|+=
literal|8
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the total GOT size required by each TLS symbol in each    range.  Symbols may require up to 5 words in the GOT: an entry    holding the TLS offset for the symbol, and an entry with a full TLS    descriptor taking 4 words.  */
end_comment

begin_function
specifier|static
name|void
name|_frvfdpic_count_tls_entries
parameter_list|(
name|struct
name|frvfdpic_relocs_info
modifier|*
name|entry
parameter_list|,
name|struct
name|_frvfdpic_dynamic_got_info
modifier|*
name|dinfo
parameter_list|,
name|bfd_boolean
name|subtract
parameter_list|)
block|{
specifier|const
name|int
name|l
init|=
name|subtract
condition|?
operator|-
literal|1
else|:
literal|1
decl_stmt|;
comment|/* Allocate space for a GOT entry with the TLS offset of the      symbol.  */
if|if
condition|(
name|entry
operator|->
name|tlsoff12
condition|)
name|dinfo
operator|->
name|got12
operator|+=
literal|4
operator|*
name|l
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|tlsofflos
condition|)
name|dinfo
operator|->
name|gotlos
operator|+=
literal|4
operator|*
name|l
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|tlsoffhilo
condition|)
name|dinfo
operator|->
name|gothilo
operator|+=
literal|4
operator|*
name|l
expr_stmt|;
else|else
name|entry
operator|->
name|relocstlsoff
operator|-=
name|l
expr_stmt|;
name|entry
operator|->
name|relocstlsoff
operator|+=
name|l
expr_stmt|;
comment|/* If there's any TLSOFF relocation, mark the output file as not      suitable for dlopening.  This mark will remain even if we relax      all such relocations, but this is not a problem, since we'll only      do so for executables, and we definitely don't want anyone      dlopening executables.  */
if|if
condition|(
name|entry
operator|->
name|relocstlsoff
condition|)
name|dinfo
operator|->
name|info
operator|->
name|flags
operator||=
name|DF_STATIC_TLS
expr_stmt|;
comment|/* Allocate space for a TLS descriptor.  */
if|if
condition|(
name|entry
operator|->
name|tlsdesc12
condition|)
name|dinfo
operator|->
name|tlsd12
operator|+=
literal|8
operator|*
name|l
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|tlsdesclos
condition|)
name|dinfo
operator|->
name|tlsdlos
operator|+=
literal|8
operator|*
name|l
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|tlsplt
condition|)
name|dinfo
operator|->
name|tlsdplt
operator|+=
literal|8
operator|*
name|l
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|tlsdeschilo
condition|)
name|dinfo
operator|->
name|tlsdhilo
operator|+=
literal|8
operator|*
name|l
expr_stmt|;
else|else
name|entry
operator|->
name|relocstlsd
operator|-=
name|l
expr_stmt|;
name|entry
operator|->
name|relocstlsd
operator|+=
name|l
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the number of dynamic relocations and fixups that a symbol    requires, and add (or subtract) from the grand and per-symbol    totals.  */
end_comment

begin_function
specifier|static
name|void
name|_frvfdpic_count_relocs_fixups
parameter_list|(
name|struct
name|frvfdpic_relocs_info
modifier|*
name|entry
parameter_list|,
name|struct
name|_frvfdpic_dynamic_got_info
modifier|*
name|dinfo
parameter_list|,
name|bfd_boolean
name|subtract
parameter_list|)
block|{
name|bfd_vma
name|relocs
init|=
literal|0
decl_stmt|,
name|fixups
init|=
literal|0
decl_stmt|,
name|tlsrets
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|dinfo
operator|->
name|info
operator|->
name|executable
operator|||
name|dinfo
operator|->
name|info
operator|->
name|pie
condition|)
block|{
name|relocs
operator|=
name|entry
operator|->
name|relocs32
operator|+
name|entry
operator|->
name|relocsfd
operator|+
name|entry
operator|->
name|relocsfdv
operator|+
name|entry
operator|->
name|relocstlsd
expr_stmt|;
comment|/* In the executable, TLS relocations to symbols that bind 	 locally (including those that resolve to global TLS offsets) 	 are resolved immediately, without any need for fixups or 	 dynamic relocations.  In shared libraries, however, we must 	 emit dynamic relocations even for local symbols, because we 	 don't know the module id the library is going to get at 	 run-time, nor its TLS base offset.  */
if|if
condition|(
operator|!
name|dinfo
operator|->
name|info
operator|->
name|executable
operator|||
operator|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|FRVFDPIC_SYM_LOCAL
argument_list|(
name|dinfo
operator|->
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|)
condition|)
name|relocs
operator|+=
name|entry
operator|->
name|relocstlsoff
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|FRVFDPIC_SYM_LOCAL
argument_list|(
name|dinfo
operator|->
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
condition|)
name|fixups
operator|+=
name|entry
operator|->
name|relocs32
operator|+
literal|2
operator|*
name|entry
operator|->
name|relocsfdv
expr_stmt|;
name|fixups
operator|+=
name|entry
operator|->
name|relocstlsd
expr_stmt|;
name|tlsrets
operator|+=
name|entry
operator|->
name|relocstlsd
expr_stmt|;
block|}
else|else
block|{
name|relocs
operator|+=
name|entry
operator|->
name|relocs32
operator|+
name|entry
operator|->
name|relocsfdv
operator|+
name|entry
operator|->
name|relocstlsoff
operator|+
name|entry
operator|->
name|relocstlsd
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|FRVFDPIC_FUNCDESC_LOCAL
argument_list|(
name|dinfo
operator|->
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
condition|)
name|fixups
operator|+=
name|entry
operator|->
name|relocsfd
expr_stmt|;
block|}
else|else
name|relocs
operator|+=
name|entry
operator|->
name|relocsfd
expr_stmt|;
block|}
if|if
condition|(
name|subtract
condition|)
block|{
name|relocs
operator|=
operator|-
name|relocs
expr_stmt|;
name|fixups
operator|=
operator|-
name|fixups
expr_stmt|;
name|tlsrets
operator|=
operator|-
name|tlsrets
expr_stmt|;
block|}
name|entry
operator|->
name|dynrelocs
operator|+=
name|relocs
expr_stmt|;
name|entry
operator|->
name|fixups
operator|+=
name|fixups
expr_stmt|;
name|dinfo
operator|->
name|relocs
operator|+=
name|relocs
expr_stmt|;
name|dinfo
operator|->
name|fixups
operator|+=
name|fixups
expr_stmt|;
name|dinfo
operator|->
name|tls_ret_refs
operator|+=
name|tlsrets
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look for opportunities to relax TLS relocations.  We can assume    we're linking the main executable or a static-tls library, since    otherwise we wouldn't have got here.  When relaxing, we have to    first undo any previous accounting of TLS uses of fixups, dynamic    relocations, GOT and PLT entries.  */
end_comment

begin_function
specifier|static
name|void
name|_frvfdpic_relax_tls_entries
parameter_list|(
name|struct
name|frvfdpic_relocs_info
modifier|*
name|entry
parameter_list|,
name|struct
name|_frvfdpic_dynamic_got_info
modifier|*
name|dinfo
parameter_list|,
name|bfd_boolean
name|relaxing
parameter_list|)
block|{
name|bfd_boolean
name|changed
init|=
operator|!
name|relaxing
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|dinfo
operator|->
name|info
operator|->
name|executable
operator|||
operator|(
name|dinfo
operator|->
name|info
operator|->
name|flags
operator|&
name|DF_STATIC_TLS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|tlsdesc12
operator|||
name|entry
operator|->
name|tlsdesclos
operator|||
name|entry
operator|->
name|tlsdeschilo
condition|)
block|{
if|if
condition|(
operator|!
name|changed
condition|)
block|{
name|_frvfdpic_count_relocs_fixups
argument_list|(
name|entry
argument_list|,
name|dinfo
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|_frvfdpic_count_tls_entries
argument_list|(
name|entry
argument_list|,
name|dinfo
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|changed
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* When linking an executable, we can always decay GOTTLSDESC to 	 TLSMOFF, if the symbol is local, or GOTTLSOFF, otherwise. 	 When linking a static-tls shared library, using TLSMOFF is 	 not an option, but we can still use GOTTLSOFF.  When decaying 	 to GOTTLSOFF, we must keep the GOT entry in range.  We know 	 it has to fit because we'll be trading the 4 words of hte TLS 	 descriptor for a single word in the same range.  */
if|if
condition|(
operator|!
name|dinfo
operator|->
name|info
operator|->
name|executable
operator|||
operator|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|FRVFDPIC_SYM_LOCAL
argument_list|(
name|dinfo
operator|->
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|)
condition|)
block|{
name|entry
operator|->
name|tlsoff12
operator||=
name|entry
operator|->
name|tlsdesc12
expr_stmt|;
name|entry
operator|->
name|tlsofflos
operator||=
name|entry
operator|->
name|tlsdesclos
expr_stmt|;
name|entry
operator|->
name|tlsoffhilo
operator||=
name|entry
operator|->
name|tlsdeschilo
expr_stmt|;
block|}
name|entry
operator|->
name|tlsdesc12
operator|=
name|entry
operator|->
name|tlsdesclos
operator|=
name|entry
operator|->
name|tlsdeschilo
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We can only decay TLSOFFs or call #gettlsoff to TLSMOFF in the      main executable.  We have to check whether the symbol's TLSOFF is      in range for a setlos.  For symbols with a hash entry, we can      determine exactly what to do; for others locals, we don't have      addresses handy, so we use the size of the TLS section as an      approximation.  If we get it wrong, we'll retain a GOT entry      holding the TLS offset (without dynamic relocations or fixups),      but we'll still optimize away the loads from it.  Since TLS sizes      are generally very small, it's probably not worth attempting to      do better than this.  */
if|if
condition|(
operator|(
name|entry
operator|->
name|tlsplt
operator|||
name|entry
operator|->
name|tlsoff12
operator|||
name|entry
operator|->
name|tlsofflos
operator|||
name|entry
operator|->
name|tlsoffhilo
operator|)
operator|&&
name|dinfo
operator|->
name|info
operator|->
name|executable
operator|&&
name|relaxing
operator|&&
operator|(
operator|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
operator|&&
name|FRVFDPIC_SYM_LOCAL
argument_list|(
name|dinfo
operator|->
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
comment|/* The above may hold for an undefweak TLS symbol, so make 	      sure we don't have this case before accessing def.value 	      and def.section.  */
operator|&&
operator|(
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
call|(
name|bfd_vma
call|)
argument_list|(
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
operator|(
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|)
operator|+
name|entry
operator|->
name|d
operator|.
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|entry
operator|->
name|addend
operator|-
name|tls_biased_base
argument_list|(
name|dinfo
operator|->
name|info
argument_list|)
operator|+
literal|32768
argument_list|)
operator|<
operator|(
name|bfd_vma
operator|)
literal|65536
operator|)
operator|)
operator|||
operator|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|elf_hash_table
argument_list|(
name|dinfo
operator|->
name|info
argument_list|)
operator|->
name|tls_sec
operator|->
name|size
operator|+
name|abs
argument_list|(
name|entry
operator|->
name|addend
argument_list|)
operator|<
literal|32768
operator|+
name|FRVFDPIC_TLS_BIAS
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|changed
condition|)
block|{
name|_frvfdpic_count_relocs_fixups
argument_list|(
name|entry
argument_list|,
name|dinfo
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|_frvfdpic_count_tls_entries
argument_list|(
name|entry
argument_list|,
name|dinfo
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|changed
operator|=
name|TRUE
expr_stmt|;
block|}
name|entry
operator|->
name|tlsplt
operator|=
name|entry
operator|->
name|tlsoff12
operator|=
name|entry
operator|->
name|tlsofflos
operator|=
name|entry
operator|->
name|tlsoffhilo
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We can decay `call #gettlsoff' to a ldi #tlsoff if we already      have a #gottlsoff12 relocation for this entry, or if we can fit      one more in the 12-bit (and 16-bit) ranges.  */
if|if
condition|(
name|entry
operator|->
name|tlsplt
operator|&&
operator|(
name|entry
operator|->
name|tlsoff12
operator|||
operator|(
name|relaxing
operator|&&
name|dinfo
operator|->
name|got12
operator|+
name|dinfo
operator|->
name|fd12
operator|+
name|dinfo
operator|->
name|tlsd12
operator|<=
literal|4096
operator|-
literal|12
operator|-
literal|4
operator|&&
operator|(
name|dinfo
operator|->
name|got12
operator|+
name|dinfo
operator|->
name|fd12
operator|+
name|dinfo
operator|->
name|tlsd12
operator|+
name|dinfo
operator|->
name|gotlos
operator|+
name|dinfo
operator|->
name|fdlos
operator|+
name|dinfo
operator|->
name|tlsdlos
operator|<=
literal|65536
operator|-
literal|12
operator|-
literal|4
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|changed
condition|)
block|{
name|_frvfdpic_count_relocs_fixups
argument_list|(
name|entry
argument_list|,
name|dinfo
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|_frvfdpic_count_tls_entries
argument_list|(
name|entry
argument_list|,
name|dinfo
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|changed
operator|=
name|TRUE
expr_stmt|;
block|}
name|entry
operator|->
name|tlsoff12
operator|=
literal|1
expr_stmt|;
name|entry
operator|->
name|tlsplt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|changed
condition|)
block|{
name|_frvfdpic_count_tls_entries
argument_list|(
name|entry
argument_list|,
name|dinfo
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|_frvfdpic_count_relocs_fixups
argument_list|(
name|entry
argument_list|,
name|dinfo
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Compute the total GOT and PLT size required by each symbol in each range. *    Symbols may require up to 4 words in the GOT: an entry pointing to    the symbol, an entry pointing to its function descriptor, and a    private function descriptors taking two words.  */
end_comment

begin_function
specifier|static
name|int
name|_frvfdpic_count_got_plt_entries
parameter_list|(
name|void
modifier|*
modifier|*
name|entryp
parameter_list|,
name|void
modifier|*
name|dinfo_
parameter_list|)
block|{
name|struct
name|frvfdpic_relocs_info
modifier|*
name|entry
init|=
operator|*
name|entryp
decl_stmt|;
name|struct
name|_frvfdpic_dynamic_got_info
modifier|*
name|dinfo
init|=
name|dinfo_
decl_stmt|;
name|_frvfdpic_count_nontls_entries
argument_list|(
name|entry
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|info
operator|->
name|executable
operator|||
operator|(
name|dinfo
operator|->
name|info
operator|->
name|flags
operator|&
name|DF_STATIC_TLS
operator|)
condition|)
name|_frvfdpic_relax_tls_entries
argument_list|(
name|entry
argument_list|,
name|dinfo
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
block|{
name|_frvfdpic_count_tls_entries
argument_list|(
name|entry
argument_list|,
name|dinfo
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|_frvfdpic_count_relocs_fixups
argument_list|(
name|entry
argument_list|,
name|dinfo
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Determine the positive and negative ranges to be used by each    offset range in the GOT.  FDCUR and CUR, that must be aligned to a    double-word boundary, are the minimum (negative) and maximum    (positive) GOT offsets already used by previous ranges, except for    an ODD entry that may have been left behind.  GOT and FD indicate    the size of GOT entries and function descriptors that must be    placed within the range from -WRAP to WRAP.  If there's room left,    up to FDPLT bytes should be reserved for additional function    descriptors.  */
end_comment

begin_function
specifier|inline
specifier|static
name|bfd_signed_vma
name|_frvfdpic_compute_got_alloc_data
parameter_list|(
name|struct
name|_frvfdpic_dynamic_got_alloc_data
modifier|*
name|gad
parameter_list|,
name|bfd_signed_vma
name|fdcur
parameter_list|,
name|bfd_signed_vma
name|odd
parameter_list|,
name|bfd_signed_vma
name|cur
parameter_list|,
name|bfd_vma
name|got
parameter_list|,
name|bfd_vma
name|fd
parameter_list|,
name|bfd_vma
name|fdplt
parameter_list|,
name|bfd_vma
name|tlsd
parameter_list|,
name|bfd_vma
name|tlsdplt
parameter_list|,
name|bfd_vma
name|wrap
parameter_list|)
block|{
name|bfd_signed_vma
name|wrapmin
init|=
operator|-
name|wrap
decl_stmt|;
specifier|const
name|bfd_vma
name|tdescsz
init|=
literal|8
decl_stmt|;
comment|/* Start at the given initial points.  */
name|gad
operator|->
name|fdcur
operator|=
name|fdcur
expr_stmt|;
name|gad
operator|->
name|cur
operator|=
name|cur
expr_stmt|;
comment|/* If we had an incoming odd word and we have any got entries that      are going to use it, consume it, otherwise leave gad->odd at      zero.  We might force gad->odd to zero and return the incoming      odd such that it is used by the next range, but then GOT entries      might appear to be out of order and we wouldn't be able to      shorten the GOT by one word if it turns out to end with an      unpaired GOT entry.  */
if|if
condition|(
name|odd
operator|&&
name|got
condition|)
block|{
name|gad
operator|->
name|odd
operator|=
name|odd
expr_stmt|;
name|got
operator|-=
literal|4
expr_stmt|;
name|odd
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|gad
operator|->
name|odd
operator|=
literal|0
expr_stmt|;
comment|/* If we're left with an unpaired GOT entry, compute its location      such that we can return it.  Otherwise, if got doesn't require an      odd number of words here, either odd was already zero in the      block above, or it was set to zero because got was non-zero, or      got was already zero.  In the latter case, we want the value of      odd to carry over to the return statement, so we don't want to      reset odd unless the condition below is true.  */
if|if
condition|(
name|got
operator|&
literal|4
condition|)
block|{
name|odd
operator|=
name|cur
operator|+
name|got
expr_stmt|;
name|got
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* Compute the tentative boundaries of this range.  */
name|gad
operator|->
name|max
operator|=
name|cur
operator|+
name|got
expr_stmt|;
name|gad
operator|->
name|min
operator|=
name|fdcur
operator|-
name|fd
expr_stmt|;
name|gad
operator|->
name|fdplt
operator|=
literal|0
expr_stmt|;
comment|/* If function descriptors took too much space, wrap some of them      around.  */
if|if
condition|(
name|gad
operator|->
name|min
operator|<
name|wrapmin
condition|)
block|{
name|gad
operator|->
name|max
operator|+=
name|wrapmin
operator|-
name|gad
operator|->
name|min
expr_stmt|;
name|gad
operator|->
name|tmin
operator|=
name|gad
operator|->
name|min
operator|=
name|wrapmin
expr_stmt|;
block|}
comment|/* If GOT entries took too much space, wrap some of them around.      This may well cause gad->min to become lower than wrapmin.  This      will cause a relocation overflow later on, so we don't have to      report it here . */
if|if
condition|(
operator|(
name|bfd_vma
operator|)
name|gad
operator|->
name|max
operator|>
name|wrap
condition|)
block|{
name|gad
operator|->
name|min
operator|-=
name|gad
operator|->
name|max
operator|-
name|wrap
expr_stmt|;
name|gad
operator|->
name|max
operator|=
name|wrap
expr_stmt|;
block|}
comment|/* Add TLS descriptors.  */
name|gad
operator|->
name|tmax
operator|=
name|gad
operator|->
name|max
operator|+
name|tlsd
expr_stmt|;
name|gad
operator|->
name|tmin
operator|=
name|gad
operator|->
name|min
expr_stmt|;
name|gad
operator|->
name|tlsdplt
operator|=
literal|0
expr_stmt|;
comment|/* If TLS descriptors took too much space, wrap an integral number      of them around.  */
if|if
condition|(
operator|(
name|bfd_vma
operator|)
name|gad
operator|->
name|tmax
operator|>
name|wrap
condition|)
block|{
name|bfd_vma
name|wrapsize
init|=
name|gad
operator|->
name|tmax
operator|-
name|wrap
decl_stmt|;
name|wrapsize
operator|+=
name|tdescsz
operator|/
literal|2
expr_stmt|;
name|wrapsize
operator|&=
operator|~
name|tdescsz
operator|/
literal|2
expr_stmt|;
name|gad
operator|->
name|tmin
operator|-=
name|wrapsize
expr_stmt|;
name|gad
operator|->
name|tmax
operator|-=
name|wrapsize
expr_stmt|;
block|}
comment|/* If there is space left and we have function descriptors      referenced in PLT entries that could take advantage of shorter      offsets, place them now.  */
if|if
condition|(
name|fdplt
operator|&&
name|gad
operator|->
name|tmin
operator|>
name|wrapmin
condition|)
block|{
name|bfd_vma
name|fds
decl_stmt|;
if|if
condition|(
call|(
name|bfd_vma
call|)
argument_list|(
name|gad
operator|->
name|tmin
operator|-
name|wrapmin
argument_list|)
operator|<
name|fdplt
condition|)
name|fds
operator|=
name|gad
operator|->
name|tmin
operator|-
name|wrapmin
expr_stmt|;
else|else
name|fds
operator|=
name|fdplt
expr_stmt|;
name|fdplt
operator|-=
name|fds
expr_stmt|;
name|gad
operator|->
name|min
operator|-=
name|fds
expr_stmt|;
name|gad
operator|->
name|tmin
operator|-=
name|fds
expr_stmt|;
name|gad
operator|->
name|fdplt
operator|+=
name|fds
expr_stmt|;
block|}
comment|/* If there is more space left, try to place some more function      descriptors for PLT entries.  */
if|if
condition|(
name|fdplt
operator|&&
operator|(
name|bfd_vma
operator|)
name|gad
operator|->
name|tmax
operator|<
name|wrap
condition|)
block|{
name|bfd_vma
name|fds
decl_stmt|;
if|if
condition|(
call|(
name|bfd_vma
call|)
argument_list|(
name|wrap
operator|-
name|gad
operator|->
name|tmax
argument_list|)
operator|<
name|fdplt
condition|)
name|fds
operator|=
name|wrap
operator|-
name|gad
operator|->
name|tmax
expr_stmt|;
else|else
name|fds
operator|=
name|fdplt
expr_stmt|;
name|fdplt
operator|-=
name|fds
expr_stmt|;
name|gad
operator|->
name|max
operator|+=
name|fds
expr_stmt|;
name|gad
operator|->
name|tmax
operator|+=
name|fds
expr_stmt|;
name|gad
operator|->
name|fdplt
operator|+=
name|fds
expr_stmt|;
block|}
comment|/* If there is space left and we have TLS descriptors referenced in      PLT entries that could take advantage of shorter offsets, place      them now.  */
if|if
condition|(
name|tlsdplt
operator|&&
name|gad
operator|->
name|tmin
operator|>
name|wrapmin
condition|)
block|{
name|bfd_vma
name|tlsds
decl_stmt|;
if|if
condition|(
call|(
name|bfd_vma
call|)
argument_list|(
name|gad
operator|->
name|tmin
operator|-
name|wrapmin
argument_list|)
operator|<
name|tlsdplt
condition|)
name|tlsds
operator|=
operator|(
name|gad
operator|->
name|tmin
operator|-
name|wrapmin
operator|)
operator|&
operator|~
operator|(
name|tdescsz
operator|/
literal|2
operator|)
expr_stmt|;
else|else
name|tlsds
operator|=
name|tlsdplt
expr_stmt|;
name|tlsdplt
operator|-=
name|tlsds
expr_stmt|;
name|gad
operator|->
name|tmin
operator|-=
name|tlsds
expr_stmt|;
name|gad
operator|->
name|tlsdplt
operator|+=
name|tlsds
expr_stmt|;
block|}
comment|/* If there is more space left, try to place some more TLS      descriptors for PLT entries.  Although we could try to fit an      additional TLS descriptor with half of it just before before the      wrap point and another right past the wrap point, this might      cause us to run out of space for the next region, so don't do      it.  */
if|if
condition|(
name|tlsdplt
operator|&&
operator|(
name|bfd_vma
operator|)
name|gad
operator|->
name|tmax
operator|<
name|wrap
operator|-
name|tdescsz
operator|/
literal|2
condition|)
block|{
name|bfd_vma
name|tlsds
decl_stmt|;
if|if
condition|(
call|(
name|bfd_vma
call|)
argument_list|(
name|wrap
operator|-
name|gad
operator|->
name|tmax
argument_list|)
operator|<
name|tlsdplt
condition|)
name|tlsds
operator|=
operator|(
name|wrap
operator|-
name|gad
operator|->
name|tmax
operator|)
operator|&
operator|~
operator|(
name|tdescsz
operator|/
literal|2
operator|)
expr_stmt|;
else|else
name|tlsds
operator|=
name|tlsdplt
expr_stmt|;
name|tlsdplt
operator|-=
name|tlsds
expr_stmt|;
name|gad
operator|->
name|tmax
operator|+=
name|tlsds
expr_stmt|;
name|gad
operator|->
name|tlsdplt
operator|+=
name|tlsds
expr_stmt|;
block|}
comment|/* If odd was initially computed as an offset past the wrap point,      wrap it around.  */
if|if
condition|(
name|odd
operator|>
name|gad
operator|->
name|max
condition|)
name|odd
operator|=
name|gad
operator|->
name|min
operator|+
name|odd
operator|-
name|gad
operator|->
name|max
expr_stmt|;
comment|/* _frvfdpic_get_got_entry() below will always wrap gad->cur if needed      before returning, so do it here too.  This guarantees that,      should cur and fdcur meet at the wrap point, they'll both be      equal to min.  */
if|if
condition|(
name|gad
operator|->
name|cur
operator|==
name|gad
operator|->
name|max
condition|)
name|gad
operator|->
name|cur
operator|=
name|gad
operator|->
name|min
expr_stmt|;
comment|/* Ditto for _frvfdpic_get_tlsdesc_entry().  */
name|gad
operator|->
name|tcur
operator|=
name|gad
operator|->
name|max
expr_stmt|;
if|if
condition|(
name|gad
operator|->
name|tcur
operator|==
name|gad
operator|->
name|tmax
condition|)
name|gad
operator|->
name|tcur
operator|=
name|gad
operator|->
name|tmin
expr_stmt|;
return|return
name|odd
return|;
block|}
end_function

begin_comment
comment|/* Compute the location of the next GOT entry, given the allocation    data for a range.  */
end_comment

begin_function
specifier|inline
specifier|static
name|bfd_signed_vma
name|_frvfdpic_get_got_entry
parameter_list|(
name|struct
name|_frvfdpic_dynamic_got_alloc_data
modifier|*
name|gad
parameter_list|)
block|{
name|bfd_signed_vma
name|ret
decl_stmt|;
if|if
condition|(
name|gad
operator|->
name|odd
condition|)
block|{
comment|/* If there was an odd word left behind, use it.  */
name|ret
operator|=
name|gad
operator|->
name|odd
expr_stmt|;
name|gad
operator|->
name|odd
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, use the word pointed to by cur, reserve the next 	 as an odd word, and skip to the next pair of words, possibly 	 wrapping around.  */
name|ret
operator|=
name|gad
operator|->
name|cur
expr_stmt|;
name|gad
operator|->
name|odd
operator|=
name|gad
operator|->
name|cur
operator|+
literal|4
expr_stmt|;
name|gad
operator|->
name|cur
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|gad
operator|->
name|cur
operator|==
name|gad
operator|->
name|max
condition|)
name|gad
operator|->
name|cur
operator|=
name|gad
operator|->
name|min
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Compute the location of the next function descriptor entry in the    GOT, given the allocation data for a range.  */
end_comment

begin_function
specifier|inline
specifier|static
name|bfd_signed_vma
name|_frvfdpic_get_fd_entry
parameter_list|(
name|struct
name|_frvfdpic_dynamic_got_alloc_data
modifier|*
name|gad
parameter_list|)
block|{
comment|/* If we're at the bottom, wrap around, and only then allocate the      next pair of words.  */
if|if
condition|(
name|gad
operator|->
name|fdcur
operator|==
name|gad
operator|->
name|min
condition|)
name|gad
operator|->
name|fdcur
operator|=
name|gad
operator|->
name|max
expr_stmt|;
return|return
name|gad
operator|->
name|fdcur
operator|-=
literal|8
return|;
block|}
end_function

begin_comment
comment|/* Compute the location of the next TLS descriptor entry in the GOT,    given the allocation data for a range.  */
end_comment

begin_function
specifier|inline
specifier|static
name|bfd_signed_vma
name|_frvfdpic_get_tlsdesc_entry
parameter_list|(
name|struct
name|_frvfdpic_dynamic_got_alloc_data
modifier|*
name|gad
parameter_list|)
block|{
name|bfd_signed_vma
name|ret
decl_stmt|;
name|ret
operator|=
name|gad
operator|->
name|tcur
expr_stmt|;
name|gad
operator|->
name|tcur
operator|+=
literal|8
expr_stmt|;
comment|/* If we're at the top of the region, wrap around to the bottom.  */
if|if
condition|(
name|gad
operator|->
name|tcur
operator|==
name|gad
operator|->
name|tmax
condition|)
name|gad
operator|->
name|tcur
operator|=
name|gad
operator|->
name|tmin
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Assign GOT offsets for every GOT entry and function descriptor.    Doing everything in a single pass is tricky.  */
end_comment

begin_function
specifier|static
name|int
name|_frvfdpic_assign_got_entries
parameter_list|(
name|void
modifier|*
modifier|*
name|entryp
parameter_list|,
name|void
modifier|*
name|info_
parameter_list|)
block|{
name|struct
name|frvfdpic_relocs_info
modifier|*
name|entry
init|=
operator|*
name|entryp
decl_stmt|;
name|struct
name|_frvfdpic_dynamic_got_plt_info
modifier|*
name|dinfo
init|=
name|info_
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|got12
condition|)
name|entry
operator|->
name|got_entry
operator|=
name|_frvfdpic_get_got_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|got12
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|gotlos
condition|)
name|entry
operator|->
name|got_entry
operator|=
name|_frvfdpic_get_got_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|gotlos
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|gothilo
condition|)
name|entry
operator|->
name|got_entry
operator|=
name|_frvfdpic_get_got_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|gothilo
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|fdgot12
condition|)
name|entry
operator|->
name|fdgot_entry
operator|=
name|_frvfdpic_get_got_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|got12
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|fdgotlos
condition|)
name|entry
operator|->
name|fdgot_entry
operator|=
name|_frvfdpic_get_got_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|gotlos
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|fdgothilo
condition|)
name|entry
operator|->
name|fdgot_entry
operator|=
name|_frvfdpic_get_got_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|gothilo
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|fdgoff12
condition|)
name|entry
operator|->
name|fd_entry
operator|=
name|_frvfdpic_get_fd_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|got12
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|plt
operator|&&
name|dinfo
operator|->
name|got12
operator|.
name|fdplt
condition|)
block|{
name|dinfo
operator|->
name|got12
operator|.
name|fdplt
operator|-=
literal|8
expr_stmt|;
name|entry
operator|->
name|fd_entry
operator|=
name|_frvfdpic_get_fd_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|got12
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|fdgofflos
condition|)
name|entry
operator|->
name|fd_entry
operator|=
name|_frvfdpic_get_fd_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|gotlos
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|plt
operator|&&
name|dinfo
operator|->
name|gotlos
operator|.
name|fdplt
condition|)
block|{
name|dinfo
operator|->
name|gotlos
operator|.
name|fdplt
operator|-=
literal|8
expr_stmt|;
name|entry
operator|->
name|fd_entry
operator|=
name|_frvfdpic_get_fd_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|gotlos
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|plt
condition|)
block|{
name|dinfo
operator|->
name|gothilo
operator|.
name|fdplt
operator|-=
literal|8
expr_stmt|;
name|entry
operator|->
name|fd_entry
operator|=
name|_frvfdpic_get_fd_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|gothilo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|privfd
condition|)
name|entry
operator|->
name|fd_entry
operator|=
name|_frvfdpic_get_fd_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|gothilo
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|tlsoff12
condition|)
name|entry
operator|->
name|tlsoff_entry
operator|=
name|_frvfdpic_get_got_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|got12
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|tlsofflos
condition|)
name|entry
operator|->
name|tlsoff_entry
operator|=
name|_frvfdpic_get_got_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|gotlos
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|tlsoffhilo
condition|)
name|entry
operator|->
name|tlsoff_entry
operator|=
name|_frvfdpic_get_got_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|gothilo
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|tlsdesc12
condition|)
name|entry
operator|->
name|tlsdesc_entry
operator|=
name|_frvfdpic_get_tlsdesc_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|got12
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|tlsplt
operator|&&
name|dinfo
operator|->
name|got12
operator|.
name|tlsdplt
condition|)
block|{
name|dinfo
operator|->
name|got12
operator|.
name|tlsdplt
operator|-=
literal|8
expr_stmt|;
name|entry
operator|->
name|tlsdesc_entry
operator|=
name|_frvfdpic_get_tlsdesc_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|got12
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|tlsdesclos
condition|)
name|entry
operator|->
name|tlsdesc_entry
operator|=
name|_frvfdpic_get_tlsdesc_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|gotlos
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|tlsplt
operator|&&
name|dinfo
operator|->
name|gotlos
operator|.
name|tlsdplt
condition|)
block|{
name|dinfo
operator|->
name|gotlos
operator|.
name|tlsdplt
operator|-=
literal|8
expr_stmt|;
name|entry
operator|->
name|tlsdesc_entry
operator|=
name|_frvfdpic_get_tlsdesc_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|gotlos
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|tlsplt
condition|)
block|{
name|dinfo
operator|->
name|gothilo
operator|.
name|tlsdplt
operator|-=
literal|8
expr_stmt|;
name|entry
operator|->
name|tlsdesc_entry
operator|=
name|_frvfdpic_get_tlsdesc_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|gothilo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|tlsdeschilo
condition|)
name|entry
operator|->
name|tlsdesc_entry
operator|=
name|_frvfdpic_get_tlsdesc_entry
argument_list|(
operator|&
name|dinfo
operator|->
name|gothilo
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Assign GOT offsets to private function descriptors used by PLT    entries (or referenced by 32-bit offsets), as well as PLT entries    and lazy PLT entries.  */
end_comment

begin_function
specifier|static
name|int
name|_frvfdpic_assign_plt_entries
parameter_list|(
name|void
modifier|*
modifier|*
name|entryp
parameter_list|,
name|void
modifier|*
name|info_
parameter_list|)
block|{
name|struct
name|frvfdpic_relocs_info
modifier|*
name|entry
init|=
operator|*
name|entryp
decl_stmt|;
name|struct
name|_frvfdpic_dynamic_got_plt_info
modifier|*
name|dinfo
init|=
name|info_
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|privfd
condition|)
name|BFD_ASSERT
argument_list|(
name|entry
operator|->
name|fd_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|plt
condition|)
block|{
name|int
name|size
decl_stmt|;
comment|/* We use the section's raw size to mark the location of the 	 next PLT entry.  */
name|entry
operator|->
name|plt_entry
operator|=
name|frvfdpic_plt_section
argument_list|(
name|dinfo
operator|->
name|g
operator|.
name|info
argument_list|)
operator|->
name|size
expr_stmt|;
comment|/* Figure out the length of this PLT entry based on the 	 addressing mode we need to reach the function descriptor.  */
name|BFD_ASSERT
argument_list|(
name|entry
operator|->
name|fd_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|fd_entry
operator|>=
operator|-
operator|(
literal|1
operator|<<
operator|(
literal|12
operator|-
literal|1
operator|)
operator|)
operator|&&
name|entry
operator|->
name|fd_entry
operator|<
operator|(
literal|1
operator|<<
operator|(
literal|12
operator|-
literal|1
operator|)
operator|)
condition|)
name|size
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|fd_entry
operator|>=
operator|-
operator|(
literal|1
operator|<<
operator|(
literal|16
operator|-
literal|1
operator|)
operator|)
operator|&&
name|entry
operator|->
name|fd_entry
operator|<
operator|(
literal|1
operator|<<
operator|(
literal|16
operator|-
literal|1
operator|)
operator|)
condition|)
name|size
operator|=
literal|12
expr_stmt|;
else|else
name|size
operator|=
literal|16
expr_stmt|;
name|frvfdpic_plt_section
argument_list|(
name|dinfo
operator|->
name|g
operator|.
name|info
argument_list|)
operator|->
name|size
operator|+=
name|size
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|lazyplt
condition|)
block|{
name|entry
operator|->
name|lzplt_entry
operator|=
name|dinfo
operator|->
name|g
operator|.
name|lzplt
expr_stmt|;
name|dinfo
operator|->
name|g
operator|.
name|lzplt
operator|+=
literal|8
expr_stmt|;
comment|/* If this entry is the one that gets the resolver stub, account 	 for the additional instruction.  */
if|if
condition|(
name|entry
operator|->
name|lzplt_entry
operator|%
name|FRVFDPIC_LZPLT_BLOCK_SIZE
operator|==
name|FRVFDPIC_LZPLT_RESOLV_LOC
condition|)
name|dinfo
operator|->
name|g
operator|.
name|lzplt
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|tlsplt
condition|)
block|{
name|int
name|size
decl_stmt|;
name|entry
operator|->
name|tlsplt_entry
operator|=
name|frvfdpic_plt_section
argument_list|(
name|dinfo
operator|->
name|g
operator|.
name|info
argument_list|)
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|g
operator|.
name|info
operator|->
name|executable
operator|&&
operator|(
name|entry
operator|->
name|symndx
operator|!=
operator|-
literal|1
operator|||
name|FRVFDPIC_SYM_LOCAL
argument_list|(
name|dinfo
operator|->
name|g
operator|.
name|info
argument_list|,
name|entry
operator|->
name|d
operator|.
name|h
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|bfd_signed_vma
operator|)
name|entry
operator|->
name|addend
operator|>=
operator|-
operator|(
literal|1
operator|<<
operator|(
literal|16
operator|-
literal|1
operator|)
operator|)
comment|/* FIXME: here we use the size of the TLS section 		 as an upper bound for the value of the TLS 		 symbol, because we may not know the exact value 		 yet.  If we get it wrong, we'll just waste a 		 word in the PLT, and we should never get even 		 close to 32 KiB of TLS anyway.  */
operator|&&
name|elf_hash_table
argument_list|(
name|dinfo
operator|->
name|g
operator|.
name|info
argument_list|)
operator|->
name|tls_sec
operator|&&
operator|(
name|elf_hash_table
argument_list|(
name|dinfo
operator|->
name|g
operator|.
name|info
argument_list|)
operator|->
name|tls_sec
operator|->
name|size
operator|+
call|(
name|bfd_signed_vma
call|)
argument_list|(
name|entry
operator|->
name|addend
argument_list|)
operator|<=
operator|(
literal|1
operator|<<
operator|(
literal|16
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|size
operator|=
literal|8
expr_stmt|;
else|else
name|size
operator|=
literal|12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|tlsoff_entry
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|tlsoff_entry
operator|>=
operator|-
operator|(
literal|1
operator|<<
operator|(
literal|12
operator|-
literal|1
operator|)
operator|)
operator|&&
name|entry
operator|->
name|tlsoff_entry
operator|<
operator|(
literal|1
operator|<<
operator|(
literal|12
operator|-
literal|1
operator|)
operator|)
condition|)
name|size
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|tlsoff_entry
operator|>=
operator|-
operator|(
literal|1
operator|<<
operator|(
literal|16
operator|-
literal|1
operator|)
operator|)
operator|&&
name|entry
operator|->
name|tlsoff_entry
operator|<
operator|(
literal|1
operator|<<
operator|(
literal|16
operator|-
literal|1
operator|)
operator|)
condition|)
name|size
operator|=
literal|12
expr_stmt|;
else|else
name|size
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|entry
operator|->
name|tlsdesc_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|tlsdesc_entry
operator|>=
operator|-
operator|(
literal|1
operator|<<
operator|(
literal|12
operator|-
literal|1
operator|)
operator|)
operator|&&
name|entry
operator|->
name|tlsdesc_entry
operator|<
operator|(
literal|1
operator|<<
operator|(
literal|12
operator|-
literal|1
operator|)
operator|)
condition|)
name|size
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|tlsdesc_entry
operator|>=
operator|-
operator|(
literal|1
operator|<<
operator|(
literal|16
operator|-
literal|1
operator|)
operator|)
operator|&&
name|entry
operator|->
name|tlsdesc_entry
operator|<
operator|(
literal|1
operator|<<
operator|(
literal|16
operator|-
literal|1
operator|)
operator|)
condition|)
name|size
operator|=
literal|12
expr_stmt|;
else|else
name|size
operator|=
literal|16
expr_stmt|;
block|}
name|frvfdpic_plt_section
argument_list|(
name|dinfo
operator|->
name|g
operator|.
name|info
argument_list|)
operator|->
name|size
operator|+=
name|size
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Cancel out any effects of calling _frvfdpic_assign_got_entries and    _frvfdpic_assign_plt_entries.  */
end_comment

begin_function
specifier|static
name|int
name|_frvfdpic_reset_got_plt_entries
parameter_list|(
name|void
modifier|*
modifier|*
name|entryp
parameter_list|,
name|void
modifier|*
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|frvfdpic_relocs_info
modifier|*
name|entry
init|=
operator|*
name|entryp
decl_stmt|;
name|entry
operator|->
name|got_entry
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|fdgot_entry
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|fd_entry
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|plt_entry
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|entry
operator|->
name|lzplt_entry
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|entry
operator|->
name|tlsoff_entry
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|tlsdesc_entry
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|tlsplt_entry
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Follow indirect and warning hash entries so that each got entry    points to the final symbol definition.  P must point to a pointer    to the hash table we're traversing.  Since this traversal may    modify the hash table, we set this pointer to NULL to indicate    we've made a potentially-destructive change to the hash table, so    the traversal must be restarted.  */
end_comment

begin_function
specifier|static
name|int
name|_frvfdpic_resolve_final_relocs_info
parameter_list|(
name|void
modifier|*
modifier|*
name|entryp
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|frvfdpic_relocs_info
modifier|*
name|entry
init|=
operator|*
name|entryp
decl_stmt|;
name|htab_t
modifier|*
name|htab
init|=
name|p
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|symndx
operator|==
operator|-
literal|1
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|entry
operator|->
name|d
operator|.
name|h
decl_stmt|;
name|struct
name|frvfdpic_relocs_info
modifier|*
name|oentry
decl_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|d
operator|.
name|h
operator|==
name|h
condition|)
return|return
literal|1
return|;
name|oentry
operator|=
name|frvfdpic_relocs_info_for_global
argument_list|(
operator|*
name|htab
argument_list|,
literal|0
argument_list|,
name|h
argument_list|,
name|entry
operator|->
name|addend
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|oentry
condition|)
block|{
comment|/* Merge the two entries.  */
name|frvfdpic_pic_merge_early_relocs_info
argument_list|(
name|oentry
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|htab_clear_slot
argument_list|(
operator|*
name|htab
argument_list|,
name|entryp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|entry
operator|->
name|d
operator|.
name|h
operator|=
name|h
expr_stmt|;
comment|/* If we can't find this entry with the new bfd hash, re-insert 	 it, and get the traversal restarted.  */
if|if
condition|(
operator|!
name|htab_find
argument_list|(
operator|*
name|htab
argument_list|,
name|entry
argument_list|)
condition|)
block|{
name|htab_clear_slot
argument_list|(
operator|*
name|htab
argument_list|,
name|entryp
argument_list|)
expr_stmt|;
name|entryp
operator|=
name|htab_find_slot
argument_list|(
operator|*
name|htab
argument_list|,
name|entry
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|entryp
condition|)
operator|*
name|entryp
operator|=
name|entry
expr_stmt|;
comment|/* Abort the traversal, since the whole table may have 	     moved, and leave it up to the parent to restart the 	     process.  */
operator|*
operator|(
name|htab_t
operator|*
operator|)
name|p
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Compute the total size of the GOT, the PLT, the dynamic relocations    section and the rofixup section.  Assign locations for GOT and PLT    entries.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|_frvfdpic_size_got_plt
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|_frvfdpic_dynamic_got_plt_info
modifier|*
name|gpinfop
parameter_list|)
block|{
name|bfd_signed_vma
name|odd
decl_stmt|;
name|bfd_vma
name|limit
decl_stmt|,
name|tlslimit
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
name|gpinfop
operator|->
name|g
operator|.
name|info
decl_stmt|;
name|bfd
modifier|*
name|dynobj
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
decl_stmt|;
name|memcpy
argument_list|(
name|frvfdpic_dynamic_got_plt_info
argument_list|(
name|info
argument_list|)
argument_list|,
operator|&
name|gpinfop
operator|->
name|g
argument_list|,
sizeof|sizeof
argument_list|(
name|gpinfop
operator|->
name|g
argument_list|)
argument_list|)
expr_stmt|;
name|odd
operator|=
literal|12
expr_stmt|;
comment|/* Compute the total size taken by entries in the 12-bit and 16-bit      ranges, to tell how many PLT function descriptors we can bring      into the 12-bit range without causing the 16-bit range to      overflow.  */
name|limit
operator|=
name|odd
operator|+
name|gpinfop
operator|->
name|g
operator|.
name|got12
operator|+
name|gpinfop
operator|->
name|g
operator|.
name|gotlos
operator|+
name|gpinfop
operator|->
name|g
operator|.
name|fd12
operator|+
name|gpinfop
operator|->
name|g
operator|.
name|fdlos
operator|+
name|gpinfop
operator|->
name|g
operator|.
name|tlsd12
operator|+
name|gpinfop
operator|->
name|g
operator|.
name|tlsdlos
expr_stmt|;
if|if
condition|(
name|limit
operator|<
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|16
condition|)
name|limit
operator|=
operator|(
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
literal|16
operator|)
operator|-
name|limit
expr_stmt|;
else|else
name|limit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gpinfop
operator|->
name|g
operator|.
name|fdplt
operator|<
name|limit
condition|)
block|{
name|tlslimit
operator|=
operator|(
name|limit
operator|-
name|gpinfop
operator|->
name|g
operator|.
name|fdplt
operator|)
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|8
expr_stmt|;
name|limit
operator|=
name|gpinfop
operator|->
name|g
operator|.
name|fdplt
expr_stmt|;
block|}
else|else
name|tlslimit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gpinfop
operator|->
name|g
operator|.
name|tlsdplt
operator|<
name|tlslimit
condition|)
name|tlslimit
operator|=
name|gpinfop
operator|->
name|g
operator|.
name|tlsdplt
expr_stmt|;
comment|/* Determine the ranges of GOT offsets that we can use for each      range of addressing modes.  */
name|odd
operator|=
name|_frvfdpic_compute_got_alloc_data
argument_list|(
operator|&
name|gpinfop
operator|->
name|got12
argument_list|,
literal|0
argument_list|,
name|odd
argument_list|,
literal|16
argument_list|,
name|gpinfop
operator|->
name|g
operator|.
name|got12
argument_list|,
name|gpinfop
operator|->
name|g
operator|.
name|fd12
argument_list|,
name|limit
argument_list|,
name|gpinfop
operator|->
name|g
operator|.
name|tlsd12
argument_list|,
name|tlslimit
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
operator|(
literal|12
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|odd
operator|=
name|_frvfdpic_compute_got_alloc_data
argument_list|(
operator|&
name|gpinfop
operator|->
name|gotlos
argument_list|,
name|gpinfop
operator|->
name|got12
operator|.
name|tmin
argument_list|,
name|odd
argument_list|,
name|gpinfop
operator|->
name|got12
operator|.
name|tmax
argument_list|,
name|gpinfop
operator|->
name|g
operator|.
name|gotlos
argument_list|,
name|gpinfop
operator|->
name|g
operator|.
name|fdlos
argument_list|,
name|gpinfop
operator|->
name|g
operator|.
name|fdplt
operator|-
name|gpinfop
operator|->
name|got12
operator|.
name|fdplt
argument_list|,
name|gpinfop
operator|->
name|g
operator|.
name|tlsdlos
argument_list|,
name|gpinfop
operator|->
name|g
operator|.
name|tlsdplt
operator|-
name|gpinfop
operator|->
name|got12
operator|.
name|tlsdplt
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
operator|(
literal|16
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|odd
operator|=
name|_frvfdpic_compute_got_alloc_data
argument_list|(
operator|&
name|gpinfop
operator|->
name|gothilo
argument_list|,
name|gpinfop
operator|->
name|gotlos
operator|.
name|tmin
argument_list|,
name|odd
argument_list|,
name|gpinfop
operator|->
name|gotlos
operator|.
name|tmax
argument_list|,
name|gpinfop
operator|->
name|g
operator|.
name|gothilo
argument_list|,
name|gpinfop
operator|->
name|g
operator|.
name|fdhilo
argument_list|,
name|gpinfop
operator|->
name|g
operator|.
name|fdplt
operator|-
name|gpinfop
operator|->
name|got12
operator|.
name|fdplt
operator|-
name|gpinfop
operator|->
name|gotlos
operator|.
name|fdplt
argument_list|,
name|gpinfop
operator|->
name|g
operator|.
name|tlsdhilo
argument_list|,
name|gpinfop
operator|->
name|g
operator|.
name|tlsdplt
operator|-
name|gpinfop
operator|->
name|got12
operator|.
name|tlsdplt
operator|-
name|gpinfop
operator|->
name|gotlos
operator|.
name|tlsdplt
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|1
operator|<<
operator|(
literal|32
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Now assign (most) GOT offsets.  */
name|htab_traverse
argument_list|(
name|frvfdpic_relocs_info
argument_list|(
name|info
argument_list|)
argument_list|,
name|_frvfdpic_assign_got_entries
argument_list|,
name|gpinfop
argument_list|)
expr_stmt|;
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|=
name|gpinfop
operator|->
name|gothilo
operator|.
name|tmax
operator|-
name|gpinfop
operator|->
name|gothilo
operator|.
name|tmin
comment|/* If an odd word is the last word of the GOT, we don't need this        word to be part of the GOT.  */
operator|-
operator|(
name|odd
operator|+
literal|4
operator|==
name|gpinfop
operator|->
name|gothilo
operator|.
name|tmax
condition|?
literal|4
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|==
literal|0
condition|)
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
elseif|else
if|if
condition|(
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|==
literal|12
operator|&&
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* This will be non-NULL during relaxation.  The assumption is that      the size of one of these sections will never grow, only shrink,      so we can use the larger buffer we allocated before.  */
elseif|else
if|if
condition|(
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|==
name|NULL
condition|)
block|{
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|frvfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
condition|)
comment|/* Subtract the number of lzplt entries, since those will generate        relocations in the pltrel section.  */
name|frvfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|=
operator|(
name|gpinfop
operator|->
name|g
operator|.
name|relocs
operator|-
name|gpinfop
operator|->
name|g
operator|.
name|lzplt
operator|/
literal|8
operator|)
operator|*
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|s
operator|->
name|sizeof_rel
expr_stmt|;
else|else
name|BFD_ASSERT
argument_list|(
name|gpinfop
operator|->
name|g
operator|.
name|relocs
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|frvfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|==
literal|0
condition|)
name|frvfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
elseif|else
if|if
condition|(
name|frvfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|==
name|NULL
condition|)
block|{
name|frvfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|frvfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|frvfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
name|frvfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|=
operator|(
name|gpinfop
operator|->
name|g
operator|.
name|fixups
operator|+
literal|1
operator|)
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|frvfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|==
literal|0
condition|)
name|frvfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
elseif|else
if|if
condition|(
name|frvfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|==
name|NULL
condition|)
block|{
name|frvfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|frvfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|frvfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|frvfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|frvfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|=
name|gpinfop
operator|->
name|g
operator|.
name|lzplt
operator|/
literal|8
operator|*
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|s
operator|->
name|sizeof_rel
expr_stmt|;
if|if
condition|(
name|frvfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|==
literal|0
condition|)
name|frvfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
elseif|else
if|if
condition|(
name|frvfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|==
name|NULL
condition|)
block|{
name|frvfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|frvfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|frvfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Add 4 bytes for every block of at most 65535 lazy PLT entries,      such that there's room for the additional instruction needed to      call the resolver.  Since _frvfdpic_assign_got_entries didn't      account for them, our block size is 4 bytes smaller than the real      block size.  */
if|if
condition|(
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|=
name|gpinfop
operator|->
name|g
operator|.
name|lzplt
operator|+
operator|(
operator|(
name|gpinfop
operator|->
name|g
operator|.
name|lzplt
operator|+
operator|(
name|FRVFDPIC_LZPLT_BLOCK_SIZE
operator|-
literal|4
operator|)
operator|-
literal|8
operator|)
operator|/
operator|(
name|FRVFDPIC_LZPLT_BLOCK_SIZE
operator|-
literal|4
operator|)
operator|*
literal|4
operator|)
expr_stmt|;
block|}
comment|/* Reset it, such that _frvfdpic_assign_plt_entries() can use it to      actually assign lazy PLT entries addresses.  */
name|gpinfop
operator|->
name|g
operator|.
name|lzplt
operator|=
literal|0
expr_stmt|;
comment|/* Save information that we're going to need to generate GOT and PLT      entries.  */
name|frvfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
operator|=
operator|-
name|gpinfop
operator|->
name|gothilo
operator|.
name|tmin
expr_stmt|;
if|if
condition|(
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|want_got_sym
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|frvfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
condition|)
name|frvfdpic_plt_initial_offset
argument_list|(
name|info
argument_list|)
operator|=
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
expr_stmt|;
comment|/* Allocate a ret statement at plt_initial_offset, to be used by      locally-resolved TLS descriptors.  */
if|if
condition|(
name|gpinfop
operator|->
name|g
operator|.
name|tls_ret_refs
condition|)
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
name|htab_traverse
argument_list|(
name|frvfdpic_relocs_info
argument_list|(
name|info
argument_list|)
argument_list|,
name|_frvfdpic_assign_plt_entries
argument_list|,
name|gpinfop
argument_list|)
expr_stmt|;
comment|/* Allocate the PLT section contents only after      _frvfdpic_assign_plt_entries has a chance to add the size of the      non-lazy PLT entries.  */
if|if
condition|(
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
condition|)
block|{
if|if
condition|(
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|==
literal|0
condition|)
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
elseif|else
if|if
condition|(
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|==
name|NULL
condition|)
block|{
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|frvfdpic_plt_section
argument_list|(
name|info
argument_list|)
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_frvfdpic_size_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|_frvfdpic_dynamic_got_plt_info
name|gpinfo
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
block|}
name|memset
argument_list|(
operator|&
name|gpinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gpinfo
argument_list|)
argument_list|)
expr_stmt|;
name|gpinfo
operator|.
name|g
operator|.
name|info
operator|=
name|info
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|htab_t
name|relocs
init|=
name|frvfdpic_relocs_info
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|htab_traverse
argument_list|(
name|relocs
argument_list|,
name|_frvfdpic_resolve_final_relocs_info
argument_list|,
operator|&
name|relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocs
operator|==
name|frvfdpic_relocs_info
argument_list|(
name|info
argument_list|)
condition|)
break|break;
block|}
name|htab_traverse
argument_list|(
name|frvfdpic_relocs_info
argument_list|(
name|info
argument_list|)
argument_list|,
name|_frvfdpic_count_got_plt_entries
argument_list|,
operator|&
name|gpinfo
operator|.
name|g
argument_list|)
expr_stmt|;
comment|/* Allocate space to save the summary information, we're going to      use it if we're doing relaxations.  */
name|frvfdpic_dynamic_got_plt_info
argument_list|(
name|info
argument_list|)
operator|=
name|bfd_alloc
argument_list|(
name|dynobj
argument_list|,
sizeof|sizeof
argument_list|(
name|gpinfo
operator|.
name|g
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_frvfdpic_size_got_plt
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|gpinfo
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
if|if
condition|(
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
condition|)
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|frvfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
condition|)
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_PLTREL
argument_list|,
name|DT_REL
argument_list|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|frvfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
condition|)
if|if
condition|(
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_REL
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|_bfd_elf_add_dynamic_entry
argument_list|(
name|info
argument_list|,
name|DT_RELENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf32_frvfdpic_always_size_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|relocatable
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* Force a PT_GNU_STACK segment to be created.  */
if|if
condition|(
operator|!
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|stack_flags
condition|)
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|stack_flags
operator|=
name|PF_R
operator||
name|PF_W
operator||
name|PF_X
expr_stmt|;
comment|/* Define __stacksize if it's not defined yet.  */
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
literal|"__stacksize"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|type
operator|!=
name|STT_OBJECT
operator|||
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|bh
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|output_bfd
argument_list|,
literal|"__stacksize"
argument_list|,
name|BSF_GLOBAL
argument_list|,
name|bfd_abs_section_ptr
argument_list|,
name|DEFAULT_STACK_SIZE
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|get_elf_backend_data
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|collect
argument_list|,
operator|&
name|bh
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bh
expr_stmt|;
name|h
operator|->
name|def_regular
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
comment|/* This one must NOT be hidden.  */
block|}
comment|/* Create a stack section, and set its alignment.  */
name|sec
operator|=
name|bfd_make_section
argument_list|(
name|output_bfd
argument_list|,
literal|".stack"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|output_bfd
argument_list|,
name|sec
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Look for opportunities to relax TLS relocations.  We can assume    we're linking the main executable or a static-tls library, since    otherwise we wouldn't have got here.  */
end_comment

begin_function
specifier|static
name|int
name|_frvfdpic_relax_got_plt_entries
parameter_list|(
name|void
modifier|*
modifier|*
name|entryp
parameter_list|,
name|void
modifier|*
name|dinfo_
parameter_list|)
block|{
name|struct
name|frvfdpic_relocs_info
modifier|*
name|entry
init|=
operator|*
name|entryp
decl_stmt|;
name|struct
name|_frvfdpic_dynamic_got_info
modifier|*
name|dinfo
init|=
name|dinfo_
decl_stmt|;
name|_frvfdpic_relax_tls_entries
argument_list|(
name|entry
argument_list|,
name|dinfo
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf32_frvfdpic_relax_section
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_boolean
modifier|*
name|again
parameter_list|)
block|{
name|struct
name|_frvfdpic_dynamic_got_plt_info
name|gpinfo
decl_stmt|;
comment|/* If we return early, we didn't change anything.  */
operator|*
name|again
operator|=
name|FALSE
expr_stmt|;
comment|/* We'll do our thing when requested to relax the GOT section.  */
if|if
condition|(
name|sec
operator|!=
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* We can only relax when linking the main executable or a library      that can't be dlopened.  */
if|if
condition|(
operator|!
name|info
operator|->
name|executable
operator|&&
operator|!
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_STATIC_TLS
operator|)
condition|)
return|return
name|TRUE
return|;
comment|/* If there isn't a TLS section for this binary, we can't do      anything about its TLS relocations (it probably doesn't have      any.  */
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|memset
argument_list|(
operator|&
name|gpinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gpinfo
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|gpinfo
operator|.
name|g
argument_list|,
name|frvfdpic_dynamic_got_plt_info
argument_list|(
name|info
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|gpinfo
operator|.
name|g
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now look for opportunities to relax, adjusting the GOT usage      as needed.  */
name|htab_traverse
argument_list|(
name|frvfdpic_relocs_info
argument_list|(
name|info
argument_list|)
argument_list|,
name|_frvfdpic_relax_got_plt_entries
argument_list|,
operator|&
name|gpinfo
operator|.
name|g
argument_list|)
expr_stmt|;
comment|/* If we changed anything, reset and re-assign GOT and PLT entries.  */
if|if
condition|(
name|memcmp
argument_list|(
name|frvfdpic_dynamic_got_plt_info
argument_list|(
name|info
argument_list|)
argument_list|,
operator|&
name|gpinfo
operator|.
name|g
argument_list|,
sizeof|sizeof
argument_list|(
name|gpinfo
operator|.
name|g
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Clear GOT and PLT assignments.  */
name|htab_traverse
argument_list|(
name|frvfdpic_relocs_info
argument_list|(
name|info
argument_list|)
argument_list|,
name|_frvfdpic_reset_got_plt_entries
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* The owner of the TLS section is the output bfd.  There should 	 be a better way to get to it.  */
if|if
condition|(
operator|!
name|_frvfdpic_size_got_plt
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|tls_sec
operator|->
name|owner
argument_list|,
operator|&
name|gpinfo
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Repeat until we don't make any further changes.  We could fail to 	 introduce changes in a round if, for example, the 12-bit range is 	 full, but we later release some space by getting rid of TLS 	 descriptors in it.  We have to repeat the whole process because 	 we might have changed the size of a section processed before this 	 one.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf32_frvfdpic_modify_segment_map
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|;
comment|/* objcopy and strip preserve what's already there using      elf32_frvfdpic_copy_private_bfd_data ().  */
if|if
condition|(
operator|!
name|info
condition|)
return|return
name|TRUE
return|;
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|output_bfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|p_type
operator|==
name|PT_GNU_STACK
condition|)
break|break;
if|if
condition|(
name|m
condition|)
block|{
name|asection
modifier|*
name|sec
init|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".stack"
argument_list|)
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
if|if
condition|(
name|sec
condition|)
block|{
comment|/* Obtain the pointer to the __stacksize symbol.  */
name|h
operator|=
name|elf_link_hash_lookup
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
literal|"__stacksize"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
argument_list|)
expr_stmt|;
comment|/* Set the section size from the symbol value.  We 	     intentionally ignore the symbol section.  */
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
condition|)
name|sec
operator|->
name|size
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
else|else
name|sec
operator|->
name|size
operator|=
name|DEFAULT_STACK_SIZE
expr_stmt|;
comment|/* Add the stack section to the PT_GNU_STACK segment, 	     such that its size and alignment requirements make it 	     to the segment.  */
name|m
operator|->
name|sections
index|[
name|m
operator|->
name|count
index|]
operator|=
name|sec
expr_stmt|;
name|m
operator|->
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Fill in code and data in dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_frv_finish_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Nothing to be done for non-FDPIC.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf32_frvfdpic_finish_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|frvfdpic_dynamic_got_plt_info
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|frvfdpic_dynamic_got_plt_info
argument_list|(
name|info
argument_list|)
operator|->
name|tls_ret_refs
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|frvfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|==
operator|(
name|frvfdpic_gotrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frvfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|hgot
init|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hgot
decl_stmt|;
name|bfd_vma
name|got_value
init|=
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|hgot
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
name|hend
decl_stmt|;
name|_frvfdpic_add_rofixup
argument_list|(
name|output_bfd
argument_list|,
name|frvfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
argument_list|,
name|got_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|frvfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|!=
operator|(
name|frvfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
operator|->
name|reloc_count
operator|*
literal|4
operator|)
condition|)
block|{
name|error
label|:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"LINKER BUG: .rofixup section size mismatch"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|hend
operator|=
name|bfd_link_hash_lookup
argument_list|(
name|info
operator|->
name|hash
argument_list|,
literal|"__ROFIXUP_END__"
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|hend
operator|&&
operator|(
name|hend
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|hend
operator|->
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
name|bfd_vma
name|value
init|=
name|frvfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|frvfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|frvfdpic_gotfixup_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|-
name|hend
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|-
name|hend
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|hend
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|==
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|hend
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|!=
name|value
condition|)
goto|goto
name|error
goto|;
block|}
block|}
block|}
if|if
condition|(
name|frvfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|frvfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
operator|==
operator|(
name|frvfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rel
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|Elf32_External_Dyn
modifier|*
name|dyncon
decl_stmt|;
name|Elf32_External_Dyn
modifier|*
name|dynconend
decl_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|bfd_elf32_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
default|default:
break|break;
case|case
name|DT_PLTGOT
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|frvfdpic_got_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
operator|+
name|frvfdpic_got_initial_offset
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_JMPREL
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|frvfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_section
operator|->
name|vma
operator|+
name|frvfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|output_offset
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|frvfdpic_pltrel_section
argument_list|(
name|info
argument_list|)
operator|->
name|size
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_frvfdpic_adjust_dynamic_symbol
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* Make sure we know what is going on here.  */
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
operator|||
operator|(
name|h
operator|->
name|def_dynamic
operator|&&
name|h
operator|->
name|ref_regular
operator|&&
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Perform any actions needed for dynamic symbols.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_frvfdpic_finish_dynamic_symbol
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Decide whether to attempt to turn absptr or lsda encodings in    shared libraries into pcrel within the given input section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|frvfdpic_elf_use_relative_eh_frame
parameter_list|(
name|bfd
modifier|*
name|input_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|eh_frame_section
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* We can't use PC-relative encodings in FDPIC binaries, in general.  */
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Adjust the contents of an eh_frame_hdr section before they're output.  */
end_comment

begin_function
specifier|static
name|bfd_byte
name|frvfdpic_elf_encode_eh_address
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|osec
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|asection
modifier|*
name|loc_sec
parameter_list|,
name|bfd_vma
name|loc_offset
parameter_list|,
name|bfd_vma
modifier|*
name|encoded
parameter_list|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hgot
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h
operator|||
operator|(
name|_frvfdpic_osec_to_segment
argument_list|(
name|abfd
argument_list|,
name|osec
argument_list|)
operator|==
name|_frvfdpic_osec_to_segment
argument_list|(
name|abfd
argument_list|,
name|loc_sec
operator|->
name|output_section
argument_list|)
operator|)
condition|)
return|return
name|_bfd_elf_encode_eh_address
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|osec
argument_list|,
name|offset
argument_list|,
name|loc_sec
argument_list|,
name|loc_offset
argument_list|,
name|encoded
argument_list|)
return|;
name|BFD_ASSERT
argument_list|(
name|_frvfdpic_osec_to_segment
argument_list|(
name|abfd
argument_list|,
name|osec
argument_list|)
operator|==
operator|(
name|_frvfdpic_osec_to_segment
argument_list|(
name|abfd
argument_list|,
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
argument_list|)
operator|)
argument_list|)
expr_stmt|;
operator|*
name|encoded
operator|=
name|osec
operator|->
name|vma
operator|+
name|offset
operator|-
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
return|return
name|DW_EH_PE_datarel
operator||
name|DW_EH_PE_sdata4
return|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase.     Besides handling virtual table relocs for gc, we have to deal with    all sorts of PIC-related relocations.  We describe below the    general plan on how to handle such relocations, even though we only    collect information at this point, storing them in hash tables for    perusal of later passes.     32 relocations are propagated to the linker output when creating    position-independent output.  LO16 and HI16 relocations are not    supposed to be encountered in this case.     LABEL16 should always be resolvable by the linker, since it's only    used by branches.     LABEL24, on the other hand, is used by calls.  If it turns out that    the target of a call is a dynamic symbol, a PLT entry must be    created for it, which triggers the creation of a private function    descriptor and, unless lazy binding is disabled, a lazy PLT entry.     GPREL relocations require the referenced symbol to be in the same    segment as _gp, but this can only be checked later.     All GOT, GOTOFF and FUNCDESC relocations require a .got section to    exist.  LABEL24 might as well, since it may require a PLT entry,    that will require a got.     Non-FUNCDESC GOT relocations require a GOT entry to be created    regardless of whether the symbol is dynamic.  However, since a    global symbol that turns out to not be exported may have the same    address of a non-dynamic symbol, we don't assign GOT entries at    this point, such that we can share them in this case.  A relocation    for the GOT entry always has to be created, be it to offset a    private symbol by the section load address, be it to get the symbol    resolved dynamically.     FUNCDESC GOT relocations require a GOT entry to be created, and    handled as if a FUNCDESC relocation was applied to the GOT entry in    an object file.     FUNCDESC relocations referencing a symbol that turns out to NOT be    dynamic cause a private function descriptor to be created.  The    FUNCDESC relocation then decays to a 32 relocation that points at    the private descriptor.  If the symbol is dynamic, the FUNCDESC    relocation is propagated to the linker output, such that the    dynamic linker creates the canonical descriptor, pointing to the    dynamically-resolved definition of the function.     Non-FUNCDESC GOTOFF relocations must always refer to non-dynamic    symbols that are assigned to the same segment as the GOT, but we    can only check this later, after we know the complete set of    symbols defined and/or exported.     FUNCDESC GOTOFF relocations require a function descriptor to be    created and, unless lazy binding is disabled or the symbol is not    dynamic, a lazy PLT entry.  Since we can't tell at this point    whether a symbol is going to be dynamic, we have to decide later    whether to create a lazy PLT entry or bind the descriptor directly    to the private function.     FUNCDESC_VALUE relocations are not supposed to be present in object    files, but they may very well be simply propagated to the linker    output, since they have no side effect.      A function descriptor always requires a FUNCDESC_VALUE relocation.    Whether it's in .plt.rel or not depends on whether lazy binding is    enabled and on whether the referenced symbol is dynamic.     The existence of a lazy PLT requires the resolverStub lazy PLT    entry to be present.      As for assignment of GOT, PLT and lazy PLT entries, and private    descriptors, we might do them all sequentially, but we can do    better than that.  For example, we can place GOT entries and    private function descriptors referenced using 12-bit operands    closer to the PIC register value, such that these relocations don't    overflow.  Those that are only referenced with LO16 relocations    could come next, but we may as well place PLT-required function    descriptors in the 12-bit range to make them shorter.  Symbols    referenced with LO16/HI16 may come next, but we may place    additional function descriptors in the 16-bit range if we can    reliably tell that we've already placed entries that are ever    referenced with only LO16.  PLT entries are therefore generated as    small as possible, while not introducing relocation overflows in    GOT or FUNCDESC_GOTOFF relocations.  Lazy PLT entries could be    generated before or after PLT entries, but not intermingled with    them, such that we can have more lazy PLT entries in range for a    branch to the resolverStub.  The resolverStub should be emitted at    the most distant location from the first lazy PLT entry such that    it's still in range for a branch, or closer, if there isn't a need    for so many lazy PLT entries.  Additional lazy PLT entries may be    emitted after the resolverStub, as long as branches are still in    range.  If the branch goes out of range, longer lazy PLT entries    are emitted.     We could further optimize PLT and lazy PLT entries by giving them    priority in assignment to closer-to-gr17 locations depending on the    number of occurrences of references to them (assuming a function    that's called more often is more important for performance, so its    PLT entry should be faster), or taking hints from the compiler.    Given infinite time and money... :-)  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_frv_check_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|,
modifier|*
modifier|*
name|sym_hashes_end
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|frvfdpic_relocs_info
modifier|*
name|picrel
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_hashes_end
operator|=
name|sym_hashes
operator|+
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|sym_hashes_end
operator|-=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_FRV_GETTLSOFF
case|:
case|case
name|R_FRV_TLSDESC_VALUE
case|:
case|case
name|R_FRV_GOTTLSDESC12
case|:
case|case
name|R_FRV_GOTTLSDESCHI
case|:
case|case
name|R_FRV_GOTTLSDESCLO
case|:
case|case
name|R_FRV_GOTTLSOFF12
case|:
case|case
name|R_FRV_GOTTLSOFFHI
case|:
case|case
name|R_FRV_GOTTLSOFFLO
case|:
case|case
name|R_FRV_TLSOFF
case|:
case|case
name|R_FRV_GOT12
case|:
case|case
name|R_FRV_GOTHI
case|:
case|case
name|R_FRV_GOTLO
case|:
case|case
name|R_FRV_FUNCDESC_GOT12
case|:
case|case
name|R_FRV_FUNCDESC_GOTHI
case|:
case|case
name|R_FRV_FUNCDESC_GOTLO
case|:
case|case
name|R_FRV_GOTOFF12
case|:
case|case
name|R_FRV_GOTOFFHI
case|:
case|case
name|R_FRV_GOTOFFLO
case|:
case|case
name|R_FRV_FUNCDESC_GOTOFF12
case|:
case|case
name|R_FRV_FUNCDESC_GOTOFFHI
case|:
case|case
name|R_FRV_FUNCDESC_GOTOFFLO
case|:
case|case
name|R_FRV_FUNCDESC
case|:
case|case
name|R_FRV_FUNCDESC_VALUE
case|:
case|case
name|R_FRV_TLSMOFF12
case|:
case|case
name|R_FRV_TLSMOFFHI
case|:
case|case
name|R_FRV_TLSMOFFLO
case|:
case|case
name|R_FRV_TLSMOFF
case|:
if|if
condition|(
operator|!
name|IS_FDPIC
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|bad_reloc
goto|;
comment|/* Fall through.  */
case|case
name|R_FRV_GPREL12
case|:
case|case
name|R_FRV_GPRELU12
case|:
case|case
name|R_FRV_GPRELHI
case|:
case|case
name|R_FRV_GPRELLO
case|:
case|case
name|R_FRV_LABEL24
case|:
case|case
name|R_FRV_32
case|:
if|if
condition|(
operator|!
name|dynobj
condition|)
block|{
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|_frv_create_got_section
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|IS_FDPIC
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|picrel
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
switch|switch
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
condition|)
block|{
case|case
name|STV_INTERNAL
case|:
case|case
name|STV_HIDDEN
case|:
break|break;
default|default:
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
block|}
name|picrel
operator|=
name|frvfdpic_relocs_info_for_global
argument_list|(
name|frvfdpic_relocs_info
argument_list|(
name|info
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
block|}
else|else
name|picrel
operator|=
name|frvfdpic_relocs_info_for_local
argument_list|(
name|frvfdpic_relocs_info
argument_list|(
name|info
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|r_symndx
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|picrel
condition|)
return|return
name|FALSE
return|;
break|break;
default|default:
name|picrel
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_FRV_LABEL24
case|:
if|if
condition|(
name|IS_FDPIC
argument_list|(
name|abfd
argument_list|)
condition|)
name|picrel
operator|->
name|call
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_FRV_FUNCDESC_VALUE
case|:
name|picrel
operator|->
name|relocsfdv
operator|++
expr_stmt|;
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_ALLOC
condition|)
name|picrel
operator|->
name|relocs32
operator|--
expr_stmt|;
comment|/* Fall through.  */
case|case
name|R_FRV_32
case|:
if|if
condition|(
operator|!
name|IS_FDPIC
argument_list|(
name|abfd
argument_list|)
condition|)
break|break;
name|picrel
operator|->
name|sym
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_ALLOC
condition|)
name|picrel
operator|->
name|relocs32
operator|++
expr_stmt|;
break|break;
case|case
name|R_FRV_GOT12
case|:
name|picrel
operator|->
name|got12
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_FRV_GOTHI
case|:
case|case
name|R_FRV_GOTLO
case|:
name|picrel
operator|->
name|gothilo
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_FRV_FUNCDESC_GOT12
case|:
name|picrel
operator|->
name|fdgot12
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_FRV_FUNCDESC_GOTHI
case|:
case|case
name|R_FRV_FUNCDESC_GOTLO
case|:
name|picrel
operator|->
name|fdgothilo
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_FRV_GOTOFF12
case|:
case|case
name|R_FRV_GOTOFFHI
case|:
case|case
name|R_FRV_GOTOFFLO
case|:
name|picrel
operator|->
name|gotoff
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_FRV_FUNCDESC_GOTOFF12
case|:
name|picrel
operator|->
name|fdgoff12
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_FRV_FUNCDESC_GOTOFFHI
case|:
case|case
name|R_FRV_FUNCDESC_GOTOFFLO
case|:
name|picrel
operator|->
name|fdgoffhilo
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_FRV_FUNCDESC
case|:
name|picrel
operator|->
name|fd
operator|=
literal|1
expr_stmt|;
name|picrel
operator|->
name|relocsfd
operator|++
expr_stmt|;
break|break;
case|case
name|R_FRV_GETTLSOFF
case|:
name|picrel
operator|->
name|tlsplt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_FRV_TLSDESC_VALUE
case|:
name|picrel
operator|->
name|relocstlsd
operator|++
expr_stmt|;
goto|goto
name|bad_reloc
goto|;
case|case
name|R_FRV_GOTTLSDESC12
case|:
name|picrel
operator|->
name|tlsdesc12
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_FRV_GOTTLSDESCHI
case|:
case|case
name|R_FRV_GOTTLSDESCLO
case|:
name|picrel
operator|->
name|tlsdeschilo
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|R_FRV_TLSMOFF12
case|:
case|case
name|R_FRV_TLSMOFFHI
case|:
case|case
name|R_FRV_TLSMOFFLO
case|:
case|case
name|R_FRV_TLSMOFF
case|:
break|break;
case|case
name|R_FRV_GOTTLSOFF12
case|:
name|picrel
operator|->
name|tlsoff12
operator|=
literal|1
expr_stmt|;
name|info
operator|->
name|flags
operator||=
name|DF_STATIC_TLS
expr_stmt|;
break|break;
case|case
name|R_FRV_GOTTLSOFFHI
case|:
case|case
name|R_FRV_GOTTLSOFFLO
case|:
name|picrel
operator|->
name|tlsoffhilo
operator|=
literal|1
expr_stmt|;
name|info
operator|->
name|flags
operator||=
name|DF_STATIC_TLS
expr_stmt|;
break|break;
case|case
name|R_FRV_TLSOFF
case|:
name|picrel
operator|->
name|relocstlsoff
operator|++
expr_stmt|;
name|info
operator|->
name|flags
operator||=
name|DF_STATIC_TLS
expr_stmt|;
goto|goto
name|bad_reloc
goto|;
comment|/* This relocation describes the C++ object vtable hierarchy.            Reconstruct it for later use during GC.  */
case|case
name|R_FRV_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually            used.  Record for later use during GC.  */
case|case
name|R_FRV_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|R_FRV_LABEL16
case|:
case|case
name|R_FRV_LO16
case|:
case|case
name|R_FRV_HI16
case|:
case|case
name|R_FRV_GPREL12
case|:
case|case
name|R_FRV_GPRELU12
case|:
case|case
name|R_FRV_GPREL32
case|:
case|case
name|R_FRV_GPRELHI
case|:
case|case
name|R_FRV_GPRELLO
case|:
case|case
name|R_FRV_TLSDESC_RELAX
case|:
case|case
name|R_FRV_GETTLSOFF_RELAX
case|:
case|case
name|R_FRV_TLSOFF_RELAX
case|:
break|break;
default|default:
name|bad_reloc
label|:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: unsupported relocation type %i"
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the machine subcode from the ELF e_flags header.  */
end_comment

begin_function
specifier|static
name|int
name|elf32_frv_machine
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
switch|switch
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_FRV_CPU_MASK
condition|)
block|{
default|default:
break|break;
case|case
name|EF_FRV_CPU_FR550
case|:
return|return
name|bfd_mach_fr550
return|;
case|case
name|EF_FRV_CPU_FR500
case|:
return|return
name|bfd_mach_fr500
return|;
case|case
name|EF_FRV_CPU_FR450
case|:
return|return
name|bfd_mach_fr450
return|;
case|case
name|EF_FRV_CPU_FR405
case|:
return|return
name|bfd_mach_fr400
return|;
case|case
name|EF_FRV_CPU_FR400
case|:
return|return
name|bfd_mach_fr400
return|;
case|case
name|EF_FRV_CPU_FR300
case|:
return|return
name|bfd_mach_fr300
return|;
case|case
name|EF_FRV_CPU_SIMPLE
case|:
return|return
name|bfd_mach_frvsimple
return|;
case|case
name|EF_FRV_CPU_TOMCAT
case|:
return|return
name|bfd_mach_frvtomcat
return|;
block|}
return|return
name|bfd_mach_frv
return|;
block|}
end_function

begin_comment
comment|/* Set the right machine number for a FRV ELF file.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_frv_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_frv
argument_list|,
name|elf32_frv_machine
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_FRV_FDPIC
operator|)
operator|!=
literal|0
operator|)
operator|==
operator|(
name|IS_FDPIC
argument_list|(
name|abfd
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Function to set the ELF flag bits.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|frv_elf_set_private_flags
parameter_list|(
name|abfd
parameter_list|,
name|flags
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
block|{
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Copy backend specific data from one object module to another.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|frv_elf_copy_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
name|BFD_ASSERT
argument_list|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|||
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|==
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
argument_list|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return true if the architecture described by elf header flag    EXTENSION is an extension of the architecture described by BASE.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|frv_elf_arch_extension_p
parameter_list|(
name|flagword
name|base
parameter_list|,
name|flagword
name|extension
parameter_list|)
block|{
if|if
condition|(
name|base
operator|==
name|extension
condition|)
return|return
name|TRUE
return|;
comment|/* CPU_GENERIC code can be merged with code for a specific      architecture, in which case the result is marked as being      for the specific architecture.  Everything is therefore      an extension of CPU_GENERIC.  */
if|if
condition|(
name|base
operator|==
name|EF_FRV_CPU_GENERIC
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|extension
operator|==
name|EF_FRV_CPU_FR450
condition|)
if|if
condition|(
name|base
operator|==
name|EF_FRV_CPU_FR400
operator|||
name|base
operator|==
name|EF_FRV_CPU_FR405
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|extension
operator|==
name|EF_FRV_CPU_FR405
condition|)
if|if
condition|(
name|base
operator|==
name|EF_FRV_CPU_FR400
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf32_frvfdpic_copy_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|frv_elf_copy_private_bfd_data
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|||
operator|!
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|phdr
operator|||
operator|!
name|elf_tdata
argument_list|(
name|obfd
argument_list|)
operator|||
operator|!
name|elf_tdata
argument_list|(
name|obfd
argument_list|)
operator|->
name|phdr
condition|)
return|return
name|TRUE
return|;
comment|/* Copy the stack size.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_phnum
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|phdr
index|[
name|i
index|]
operator|.
name|p_type
operator|==
name|PT_GNU_STACK
condition|)
block|{
name|Elf_Internal_Phdr
modifier|*
name|iphdr
init|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|phdr
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_phnum
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|elf_tdata
argument_list|(
name|obfd
argument_list|)
operator|->
name|phdr
index|[
name|i
index|]
operator|.
name|p_type
operator|==
name|PT_GNU_STACK
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|elf_tdata
argument_list|(
name|obfd
argument_list|)
operator|->
name|phdr
index|[
name|i
index|]
argument_list|,
name|iphdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|iphdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Rewrite the phdrs, since we're only called after they 		 were first written.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|obfd
argument_list|,
operator|(
name|bfd_signed_vma
operator|)
name|get_elf_backend_data
argument_list|(
name|obfd
argument_list|)
operator|->
name|s
operator|->
name|sizeof_ehdr
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|get_elf_backend_data
argument_list|(
name|obfd
argument_list|)
operator|->
name|s
operator|->
name|write_out_phdrs
argument_list|(
name|obfd
argument_list|,
name|elf_tdata
argument_list|(
name|obfd
argument_list|)
operator|->
name|phdr
argument_list|,
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_phnum
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
break|break;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|frv_elf_merge_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
name|flagword
name|old_flags
decl_stmt|,
name|old_partial
decl_stmt|;
name|flagword
name|new_flags
decl_stmt|,
name|new_partial
decl_stmt|;
name|bfd_boolean
name|error
init|=
name|FALSE
decl_stmt|;
name|char
name|new_opt
index|[
literal|80
index|]
decl_stmt|;
name|char
name|old_opt
index|[
literal|80
index|]
decl_stmt|;
name|new_opt
index|[
literal|0
index|]
operator|=
name|old_opt
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|new_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|old_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
name|new_flags
operator|&
name|EF_FRV_FDPIC
condition|)
name|new_flags
operator|&=
operator|~
name|EF_FRV_PIC
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"old_flags = 0x%.8lx, new_flags = 0x%.8lx, init = %s, filename = %s"
argument_list|,
name|old_flags
argument_list|,
name|new_flags
argument_list|,
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
comment|/* First call, no flags set.  */
block|{
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
name|old_flags
operator|=
name|new_flags
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new_flags
operator|==
name|old_flags
condition|)
comment|/* Compatible flags are ok.  */
empty_stmt|;
else|else
comment|/* Possibly incompatible flags.  */
block|{
comment|/* Warn if different # of gprs are used.  Note, 0 means nothing is          said about the size of gprs.  */
name|new_partial
operator|=
operator|(
name|new_flags
operator|&
name|EF_FRV_GPR_MASK
operator|)
expr_stmt|;
name|old_partial
operator|=
operator|(
name|old_flags
operator|&
name|EF_FRV_GPR_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|new_partial
operator|==
name|old_partial
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|new_partial
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|old_partial
operator|==
literal|0
condition|)
name|old_flags
operator||=
name|new_partial
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|new_partial
condition|)
block|{
default|default:
name|strcat
argument_list|(
name|new_opt
argument_list|,
literal|" -mgpr-??"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_GPR_32
case|:
name|strcat
argument_list|(
name|new_opt
argument_list|,
literal|" -mgpr-32"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_GPR_64
case|:
name|strcat
argument_list|(
name|new_opt
argument_list|,
literal|" -mgpr-64"
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|old_partial
condition|)
block|{
default|default:
name|strcat
argument_list|(
name|old_opt
argument_list|,
literal|" -mgpr-??"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_GPR_32
case|:
name|strcat
argument_list|(
name|old_opt
argument_list|,
literal|" -mgpr-32"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_GPR_64
case|:
name|strcat
argument_list|(
name|old_opt
argument_list|,
literal|" -mgpr-64"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Warn if different # of fprs are used.  Note, 0 means nothing is          said about the size of fprs.  */
name|new_partial
operator|=
operator|(
name|new_flags
operator|&
name|EF_FRV_FPR_MASK
operator|)
expr_stmt|;
name|old_partial
operator|=
operator|(
name|old_flags
operator|&
name|EF_FRV_FPR_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|new_partial
operator|==
name|old_partial
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|new_partial
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|old_partial
operator|==
literal|0
condition|)
name|old_flags
operator||=
name|new_partial
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|new_partial
condition|)
block|{
default|default:
name|strcat
argument_list|(
name|new_opt
argument_list|,
literal|" -mfpr-?"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_FPR_32
case|:
name|strcat
argument_list|(
name|new_opt
argument_list|,
literal|" -mfpr-32"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_FPR_64
case|:
name|strcat
argument_list|(
name|new_opt
argument_list|,
literal|" -mfpr-64"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_FPR_NONE
case|:
name|strcat
argument_list|(
name|new_opt
argument_list|,
literal|" -msoft-float"
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|old_partial
condition|)
block|{
default|default:
name|strcat
argument_list|(
name|old_opt
argument_list|,
literal|" -mfpr-?"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_FPR_32
case|:
name|strcat
argument_list|(
name|old_opt
argument_list|,
literal|" -mfpr-32"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_FPR_64
case|:
name|strcat
argument_list|(
name|old_opt
argument_list|,
literal|" -mfpr-64"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_FPR_NONE
case|:
name|strcat
argument_list|(
name|old_opt
argument_list|,
literal|" -msoft-float"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Warn if different dword support was used.  Note, 0 means nothing is          said about the dword support.  */
name|new_partial
operator|=
operator|(
name|new_flags
operator|&
name|EF_FRV_DWORD_MASK
operator|)
expr_stmt|;
name|old_partial
operator|=
operator|(
name|old_flags
operator|&
name|EF_FRV_DWORD_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|new_partial
operator|==
name|old_partial
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|new_partial
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|old_partial
operator|==
literal|0
condition|)
name|old_flags
operator||=
name|new_partial
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|new_partial
condition|)
block|{
default|default:
name|strcat
argument_list|(
name|new_opt
argument_list|,
literal|" -mdword-?"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_DWORD_YES
case|:
name|strcat
argument_list|(
name|new_opt
argument_list|,
literal|" -mdword"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_DWORD_NO
case|:
name|strcat
argument_list|(
name|new_opt
argument_list|,
literal|" -mno-dword"
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|old_partial
condition|)
block|{
default|default:
name|strcat
argument_list|(
name|old_opt
argument_list|,
literal|" -mdword-?"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_DWORD_YES
case|:
name|strcat
argument_list|(
name|old_opt
argument_list|,
literal|" -mdword"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_DWORD_NO
case|:
name|strcat
argument_list|(
name|old_opt
argument_list|,
literal|" -mno-dword"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Or in flags that accumulate (ie, if one module uses it, mark that the 	 feature is used.  */
name|old_flags
operator||=
name|new_flags
operator|&
operator|(
name|EF_FRV_DOUBLE
operator||
name|EF_FRV_MEDIA
operator||
name|EF_FRV_MULADD
operator||
name|EF_FRV_NON_PIC_RELOCS
operator|)
expr_stmt|;
comment|/* If any module was compiled without -G0, clear the G0 bit.  */
name|old_flags
operator|=
operator|(
operator|(
name|old_flags
operator|&
operator|~
name|EF_FRV_G0
operator|)
operator||
operator|(
name|old_flags
operator|&
name|new_flags
operator|&
name|EF_FRV_G0
operator|)
operator|)
expr_stmt|;
comment|/* If any module was compiled without -mnopack, clear the mnopack bit.  */
name|old_flags
operator|=
operator|(
operator|(
name|old_flags
operator|&
operator|~
name|EF_FRV_NOPACK
operator|)
operator||
operator|(
name|old_flags
operator|&
name|new_flags
operator|&
name|EF_FRV_NOPACK
operator|)
operator|)
expr_stmt|;
comment|/* We don't have to do anything if the pic flags are the same, or the new          module(s) were compiled with -mlibrary-pic.  */
name|new_partial
operator|=
operator|(
name|new_flags
operator|&
name|EF_FRV_PIC_FLAGS
operator|)
expr_stmt|;
name|old_partial
operator|=
operator|(
name|old_flags
operator|&
name|EF_FRV_PIC_FLAGS
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|new_partial
operator|==
name|old_partial
operator|)
operator|||
operator|(
operator|(
name|new_partial
operator|&
name|EF_FRV_LIBPIC
operator|)
operator|!=
literal|0
operator|)
condition|)
empty_stmt|;
comment|/* If the old module(s) were compiled with -mlibrary-pic, copy in the pic          flags if any from the new module.  */
elseif|else
if|if
condition|(
operator|(
name|old_partial
operator|&
name|EF_FRV_LIBPIC
operator|)
operator|!=
literal|0
condition|)
name|old_flags
operator|=
operator|(
name|old_flags
operator|&
operator|~
name|EF_FRV_PIC_FLAGS
operator|)
operator||
name|new_partial
expr_stmt|;
comment|/* If we have mixtures of -fpic and -fPIC, or in both bits.  */
elseif|else
if|if
condition|(
name|new_partial
operator|!=
literal|0
operator|&&
name|old_partial
operator|!=
literal|0
condition|)
name|old_flags
operator||=
name|new_partial
expr_stmt|;
comment|/* One module was compiled for pic and the other was not, see if we have          had any relocations that are not pic-safe.  */
else|else
block|{
if|if
condition|(
operator|(
name|old_flags
operator|&
name|EF_FRV_NON_PIC_RELOCS
operator|)
operator|==
literal|0
condition|)
name|old_flags
operator||=
name|new_partial
expr_stmt|;
else|else
block|{
name|old_flags
operator|&=
operator|~
name|EF_FRV_PIC_FLAGS
expr_stmt|;
ifndef|#
directive|ifndef
name|FRV_NO_PIC_ERROR
name|error
operator|=
name|TRUE
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: compiled with %s and linked with modules that use non-pic relocations"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
operator|(
name|new_flags
operator|&
name|EF_FRV_BIGPIC
operator|)
condition|?
literal|"-fPIC"
else|:
literal|"-fpic"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* Warn if different cpu is used (allow a specific cpu to override 	 the generic cpu).  */
name|new_partial
operator|=
operator|(
name|new_flags
operator|&
name|EF_FRV_CPU_MASK
operator|)
expr_stmt|;
name|old_partial
operator|=
operator|(
name|old_flags
operator|&
name|EF_FRV_CPU_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|frv_elf_arch_extension_p
argument_list|(
name|new_partial
argument_list|,
name|old_partial
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|frv_elf_arch_extension_p
argument_list|(
name|old_partial
argument_list|,
name|new_partial
argument_list|)
condition|)
name|old_flags
operator|=
operator|(
name|old_flags
operator|&
operator|~
name|EF_FRV_CPU_MASK
operator|)
operator||
name|new_partial
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|new_partial
condition|)
block|{
default|default:
name|strcat
argument_list|(
name|new_opt
argument_list|,
literal|" -mcpu=?"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_GENERIC
case|:
name|strcat
argument_list|(
name|new_opt
argument_list|,
literal|" -mcpu=frv"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_SIMPLE
case|:
name|strcat
argument_list|(
name|new_opt
argument_list|,
literal|" -mcpu=simple"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_FR550
case|:
name|strcat
argument_list|(
name|new_opt
argument_list|,
literal|" -mcpu=fr550"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_FR500
case|:
name|strcat
argument_list|(
name|new_opt
argument_list|,
literal|" -mcpu=fr500"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_FR450
case|:
name|strcat
argument_list|(
name|new_opt
argument_list|,
literal|" -mcpu=fr450"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_FR405
case|:
name|strcat
argument_list|(
name|new_opt
argument_list|,
literal|" -mcpu=fr405"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_FR400
case|:
name|strcat
argument_list|(
name|new_opt
argument_list|,
literal|" -mcpu=fr400"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_FR300
case|:
name|strcat
argument_list|(
name|new_opt
argument_list|,
literal|" -mcpu=fr300"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_TOMCAT
case|:
name|strcat
argument_list|(
name|new_opt
argument_list|,
literal|" -mcpu=tomcat"
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|old_partial
condition|)
block|{
default|default:
name|strcat
argument_list|(
name|old_opt
argument_list|,
literal|" -mcpu=?"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_GENERIC
case|:
name|strcat
argument_list|(
name|old_opt
argument_list|,
literal|" -mcpu=frv"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_SIMPLE
case|:
name|strcat
argument_list|(
name|old_opt
argument_list|,
literal|" -mcpu=simple"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_FR550
case|:
name|strcat
argument_list|(
name|old_opt
argument_list|,
literal|" -mcpu=fr550"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_FR500
case|:
name|strcat
argument_list|(
name|old_opt
argument_list|,
literal|" -mcpu=fr500"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_FR450
case|:
name|strcat
argument_list|(
name|old_opt
argument_list|,
literal|" -mcpu=fr450"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_FR405
case|:
name|strcat
argument_list|(
name|old_opt
argument_list|,
literal|" -mcpu=fr405"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_FR400
case|:
name|strcat
argument_list|(
name|old_opt
argument_list|,
literal|" -mcpu=fr400"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_FR300
case|:
name|strcat
argument_list|(
name|old_opt
argument_list|,
literal|" -mcpu=fr300"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_TOMCAT
case|:
name|strcat
argument_list|(
name|old_opt
argument_list|,
literal|" -mcpu=tomcat"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Print out any mismatches from above.  */
if|if
condition|(
name|new_opt
index|[
literal|0
index|]
condition|)
block|{
name|error
operator|=
name|TRUE
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: compiled with %s and linked with modules compiled with %s"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|new_opt
argument_list|,
name|old_opt
argument_list|)
expr_stmt|;
block|}
comment|/* Warn about any other mismatches */
name|new_partial
operator|=
operator|(
name|new_flags
operator|&
operator|~
name|EF_FRV_ALL_FLAGS
operator|)
expr_stmt|;
name|old_partial
operator|=
operator|(
name|old_flags
operator|&
operator|~
name|EF_FRV_ALL_FLAGS
operator|)
expr_stmt|;
if|if
condition|(
name|new_partial
operator|!=
name|old_partial
condition|)
block|{
name|old_flags
operator||=
name|new_partial
expr_stmt|;
name|error
operator|=
name|TRUE
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: uses different unknown e_flags (0x%lx) fields than previous modules (0x%lx)"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|new_partial
argument_list|,
operator|(
name|long
operator|)
name|old_partial
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the cpu is -mcpu=simple, then set the -mnopack bit.  */
if|if
condition|(
operator|(
name|old_flags
operator|&
name|EF_FRV_CPU_MASK
operator|)
operator|==
name|EF_FRV_CPU_SIMPLE
condition|)
name|old_flags
operator||=
name|EF_FRV_NOPACK
expr_stmt|;
comment|/* Update the old flags now with changes made above.  */
name|old_partial
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_FRV_CPU_MASK
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|old_flags
expr_stmt|;
if|if
condition|(
name|old_partial
operator|!=
operator|(
name|old_flags
operator|&
name|EF_FRV_CPU_MASK
operator|)
condition|)
name|bfd_default_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_arch_frv
argument_list|,
name|elf32_frv_machine
argument_list|(
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|new_flags
operator|&
name|EF_FRV_FDPIC
operator|)
operator|==
literal|0
operator|)
operator|!=
operator|(
operator|!
name|IS_FDPIC
argument_list|(
name|ibfd
argument_list|)
operator|)
condition|)
block|{
name|error
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|IS_FDPIC
argument_list|(
name|obfd
argument_list|)
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: cannot link non-fdpic object file into fdpic executable"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: cannot link fdpic object file into non-fdpic executable"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
operator|!
name|error
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|bfd_boolean
name|frv_elf_print_private_bfd_data
parameter_list|(
name|abfd
parameter_list|,
name|ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|ptr
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|ptr
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|abfd
operator|!=
name|NULL
operator|&&
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Print normal ELF private data.  */
name|_bfd_elf_print_private_bfd_data
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|flags
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"private flags = 0x%lx:"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|flags
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|flags
operator|&
name|EF_FRV_CPU_MASK
condition|)
block|{
default|default:
break|break;
case|case
name|EF_FRV_CPU_SIMPLE
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -mcpu=simple"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_FR550
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -mcpu=fr550"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_FR500
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -mcpu=fr500"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_FR450
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -mcpu=fr450"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_FR405
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -mcpu=fr405"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_FR400
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -mcpu=fr400"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_FR300
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -mcpu=fr300"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_CPU_TOMCAT
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -mcpu=tomcat"
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|flags
operator|&
name|EF_FRV_GPR_MASK
condition|)
block|{
default|default:
break|break;
case|case
name|EF_FRV_GPR_32
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -mgpr-32"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_GPR_64
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -mgpr-64"
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|flags
operator|&
name|EF_FRV_FPR_MASK
condition|)
block|{
default|default:
break|break;
case|case
name|EF_FRV_FPR_32
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -mfpr-32"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_FPR_64
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -mfpr-64"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_FPR_NONE
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -msoft-float"
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|flags
operator|&
name|EF_FRV_DWORD_MASK
condition|)
block|{
default|default:
break|break;
case|case
name|EF_FRV_DWORD_YES
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -mdword"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_FRV_DWORD_NO
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -mno-dword"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|flags
operator|&
name|EF_FRV_DOUBLE
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -mdouble"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_FRV_MEDIA
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -mmedia"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_FRV_MULADD
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -mmuladd"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_FRV_PIC
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -fpic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_FRV_BIGPIC
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -fPIC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_FRV_LIBPIC
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -mlibrary-pic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_FRV_FDPIC
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -mfdpic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_FRV_NON_PIC_RELOCS
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" non-pic relocations"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EF_FRV_G0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -G0"
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Support for core dump NOTE sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_frv_grok_prstatus
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
name|unsigned
name|int
name|raw_size
decl_stmt|;
switch|switch
condition|(
name|note
operator|->
name|descsz
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
comment|/* The Linux/FRV elf_prstatus struct is 268 bytes long.  The other          hardcoded offsets and sizes listed below (and contained within 	 this lexical block) refer to fields in the target's elf_prstatus 	 struct.  */
case|case
literal|268
case|:
comment|/* `pr_cursig' is at offset 12.  */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* `pr_pid' is at offset 24.  */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_pid
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|24
argument_list|)
expr_stmt|;
comment|/* `pr_reg' is at offset 72.  */
name|offset
operator|=
literal|72
expr_stmt|;
comment|/* Most grok_prstatus implementations set `raw_size' to the size 	   of the pr_reg field.  For Linux/FRV, we set `raw_size' to be 	   the size of `pr_reg' plus the size of `pr_exec_fdpic_loadmap' 	   and `pr_interp_fdpic_loadmap', both of which (by design) 	   immediately follow `pr_reg'.  This will allow these fields to 	   be viewed by GDB as registers. 	    	   `pr_reg' is 184 bytes long.  `pr_exec_fdpic_loadmap' and 	   `pr_interp_fdpic_loadmap' are 4 bytes each.  */
name|raw_size
operator|=
literal|184
operator|+
literal|4
operator|+
literal|4
expr_stmt|;
break|break;
block|}
comment|/* Make a ".reg/999" section.  */
return|return
name|_bfd_elfcore_make_pseudosection
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|,
name|raw_size
argument_list|,
name|note
operator|->
name|descpos
operator|+
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf32_frv_grok_psinfo
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Note
modifier|*
name|note
parameter_list|)
block|{
switch|switch
condition|(
name|note
operator|->
name|descsz
condition|)
block|{
default|default:
return|return
name|FALSE
return|;
comment|/* The Linux/FRV elf_prpsinfo struct is 124 bytes long.  */
case|case
literal|124
case|:
comment|/* `pr_fname' is found at offset 28 and is 16 bytes long.  */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_program
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|28
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* `pr_psargs' is found at offset 44 and is 80 bytes long.  */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
operator|=
name|_bfd_elfcore_strndup
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|44
argument_list|,
literal|80
argument_list|)
expr_stmt|;
block|}
comment|/* Note that for some reason, a spurious space is tacked      onto the end of the args in some (at least one anyway)      implementations, so strip it off if it exists.  */
block|{
name|char
modifier|*
name|command
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_command
decl_stmt|;
name|int
name|n
init|=
name|strlen
argument_list|(
name|command
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|n
operator|&&
name|command
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|command
index|[
name|n
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_frv
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_CYGNUS_FRV
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1000
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_frv_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-frv"
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|frv_info_to_howto_rela
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|elf32_frv_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|elf32_frv_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|elf32_frv_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|elf32_frv_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|elf32_frv_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_add_symbol_hook
value|elf32_frv_add_symbol_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_rela_normal
value|1
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|frv_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_set_private_flags
value|frv_elf_set_private_flags
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_copy_private_bfd_data
value|frv_elf_copy_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_merge_private_bfd_data
value|frv_elf_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_print_private_bfd_data
value|frv_elf_print_private_bfd_data
end_define

begin_define
define|#
directive|define
name|elf_backend_want_got_sym
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_want_got_plt
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_readonly
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_header_size
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
define|\
value|elf32_frv_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_prstatus
value|elf32_frv_grok_prstatus
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_psinfo
value|elf32_frv_grok_psinfo
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

begin_undef
undef|#
directive|undef
name|ELF_MAXPAGESIZE
end_undef

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x4000
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BIG_SYM
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_frvfdpic_vec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BIG_NAME
end_undef

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-frvfdpic"
end_define

begin_undef
undef|#
directive|undef
name|elf32_bed
end_undef

begin_define
define|#
directive|define
name|elf32_bed
value|elf32_frvfdpic_bed
end_define

begin_undef
undef|#
directive|undef
name|elf_info_to_howto_rel
end_undef

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|frvfdpic_info_to_howto_rel
end_define

begin_undef
undef|#
directive|undef
name|bfd_elf32_bfd_link_hash_table_create
end_undef

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
define|\
value|frvfdpic_elf_link_hash_table_create
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_always_size_sections
end_undef

begin_define
define|#
directive|define
name|elf_backend_always_size_sections
define|\
value|elf32_frvfdpic_always_size_sections
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_modify_segment_map
end_undef

begin_define
define|#
directive|define
name|elf_backend_modify_segment_map
define|\
value|elf32_frvfdpic_modify_segment_map
end_define

begin_undef
undef|#
directive|undef
name|bfd_elf32_bfd_copy_private_bfd_data
end_undef

begin_define
define|#
directive|define
name|bfd_elf32_bfd_copy_private_bfd_data
define|\
value|elf32_frvfdpic_copy_private_bfd_data
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_create_dynamic_sections
end_undef

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
define|\
value|elf32_frvfdpic_create_dynamic_sections
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_adjust_dynamic_symbol
end_undef

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
define|\
value|elf32_frvfdpic_adjust_dynamic_symbol
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_size_dynamic_sections
end_undef

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
define|\
value|elf32_frvfdpic_size_dynamic_sections
end_define

begin_undef
undef|#
directive|undef
name|bfd_elf32_bfd_relax_section
end_undef

begin_define
define|#
directive|define
name|bfd_elf32_bfd_relax_section
define|\
value|elf32_frvfdpic_relax_section
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_finish_dynamic_symbol
end_undef

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
define|\
value|elf32_frvfdpic_finish_dynamic_symbol
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_finish_dynamic_sections
end_undef

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
define|\
value|elf32_frvfdpic_finish_dynamic_sections
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_can_make_relative_eh_frame
end_undef

begin_define
define|#
directive|define
name|elf_backend_can_make_relative_eh_frame
define|\
value|frvfdpic_elf_use_relative_eh_frame
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_can_make_lsda_relative_eh_frame
end_undef

begin_define
define|#
directive|define
name|elf_backend_can_make_lsda_relative_eh_frame
define|\
value|frvfdpic_elf_use_relative_eh_frame
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_encode_eh_address
end_undef

begin_define
define|#
directive|define
name|elf_backend_encode_eh_address
define|\
value|frvfdpic_elf_encode_eh_address
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_may_use_rel_p
end_undef

begin_define
define|#
directive|define
name|elf_backend_may_use_rel_p
value|1
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_may_use_rela_p
end_undef

begin_define
define|#
directive|define
name|elf_backend_may_use_rela_p
value|1
end_define

begin_comment
comment|/* We use REL for dynamic relocations only.  */
end_comment

begin_undef
undef|#
directive|undef
name|elf_backend_default_use_rela_p
end_undef

begin_define
define|#
directive|define
name|elf_backend_default_use_rela_p
value|1
end_define

begin_undef
undef|#
directive|undef
name|elf_backend_omit_section_dynsym
end_undef

begin_define
define|#
directive|define
name|elf_backend_omit_section_dynsym
value|_frvfdpic_link_omit_section_dynsym
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

