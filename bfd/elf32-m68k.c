begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Motorola 68k series support for 32-bit ELF    Copyright 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,    2004, 2005, 2006 Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/m68k.h"
end_include

begin_include
include|#
directive|include
file|"opcode/m68k.h"
end_include

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rtype_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|elf_m68k_link_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elf_m68k_link_hash_table_create
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_m68k_check_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|elf_m68k_gc_mark_hook
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_m68k_gc_sweep_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_m68k_adjust_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_m68k_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_m68k_discard_copies
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_m68k_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_m68k_finish_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf_m68k_finish_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf32_m68k_set_private_flags
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|flagword
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf32_m68k_merge_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|elf32_m68k_print_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|elf_reloc_type_class
name|elf32_m68k_reloc_type_class
name|PARAMS
argument_list|(
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|howto_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|R_68K_NONE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_68K_NONE"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x00000000
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_68K_32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_68K_32"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_68K_16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_68K_16"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x0000ffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_68K_8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_68K_8"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x000000ff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_68K_PC32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_68K_PC32"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_68K_PC16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_68K_PC16"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x0000ffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_68K_PC8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_68K_PC8"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x000000ff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_68K_GOT32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_68K_GOT32"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_68K_GOT16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_68K_GOT16"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x0000ffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_68K_GOT8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_68K_GOT8"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x000000ff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_68K_GOT32O
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_68K_GOT32O"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_68K_GOT16O
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_68K_GOT16O"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x0000ffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_68K_GOT8O
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_68K_GOT8O"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x000000ff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_68K_PLT32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_68K_PLT32"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_68K_PLT16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_68K_PLT16"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x0000ffff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_68K_PLT8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_68K_PLT8"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x000000ff
argument_list|,
name|TRUE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_68K_PLT32O
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_68K_PLT32O"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_68K_PLT16O
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_68K_PLT16O"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x0000ffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_68K_PLT8O
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_signed
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_68K_PLT8O"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0x000000ff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_68K_COPY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_68K_COPY"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_68K_GLOB_DAT
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_68K_GLOB_DAT"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_68K_JMP_SLOT
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_68K_JMP_SLOT"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_68K_RELATIVE
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_68K_RELATIVE"
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|FALSE
argument_list|)
block|,
comment|/* GNU extension to record C++ vtable hierarchy.  */
name|HOWTO
argument_list|(
name|R_68K_GNU_VTINHERIT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_68K_GNU_VTINHERIT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* GNU extension to record C++ vtable member usage.  */
name|HOWTO
argument_list|(
name|R_68K_GNU_VTENTRY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_elf_rel_vtable_reloc_fn
argument_list|,
comment|/* special_function */
literal|"R_68K_GNU_VTENTRY"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|rtype_to_howto
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|BFD_ASSERT
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_68K_max
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|howto_table
index|[
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
index|]
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|elf_info_to_howto
value|rtype_to_howto
end_define

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|bfd_reloc_code_real_type
name|bfd_val
decl_stmt|;
name|int
name|elf_val
decl_stmt|;
block|}
name|reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_68K_NONE
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_68K_32
block|}
block|,
block|{
name|BFD_RELOC_16
block|,
name|R_68K_16
block|}
block|,
block|{
name|BFD_RELOC_8
block|,
name|R_68K_8
block|}
block|,
block|{
name|BFD_RELOC_32_PCREL
block|,
name|R_68K_PC32
block|}
block|,
block|{
name|BFD_RELOC_16_PCREL
block|,
name|R_68K_PC16
block|}
block|,
block|{
name|BFD_RELOC_8_PCREL
block|,
name|R_68K_PC8
block|}
block|,
block|{
name|BFD_RELOC_32_GOT_PCREL
block|,
name|R_68K_GOT32
block|}
block|,
block|{
name|BFD_RELOC_16_GOT_PCREL
block|,
name|R_68K_GOT16
block|}
block|,
block|{
name|BFD_RELOC_8_GOT_PCREL
block|,
name|R_68K_GOT8
block|}
block|,
block|{
name|BFD_RELOC_32_GOTOFF
block|,
name|R_68K_GOT32O
block|}
block|,
block|{
name|BFD_RELOC_16_GOTOFF
block|,
name|R_68K_GOT16O
block|}
block|,
block|{
name|BFD_RELOC_8_GOTOFF
block|,
name|R_68K_GOT8O
block|}
block|,
block|{
name|BFD_RELOC_32_PLT_PCREL
block|,
name|R_68K_PLT32
block|}
block|,
block|{
name|BFD_RELOC_16_PLT_PCREL
block|,
name|R_68K_PLT16
block|}
block|,
block|{
name|BFD_RELOC_8_PLT_PCREL
block|,
name|R_68K_PLT8
block|}
block|,
block|{
name|BFD_RELOC_32_PLTOFF
block|,
name|R_68K_PLT32O
block|}
block|,
block|{
name|BFD_RELOC_16_PLTOFF
block|,
name|R_68K_PLT16O
block|}
block|,
block|{
name|BFD_RELOC_8_PLTOFF
block|,
name|R_68K_PLT8O
block|}
block|,
block|{
name|BFD_RELOC_NONE
block|,
name|R_68K_COPY
block|}
block|,
block|{
name|BFD_RELOC_68K_GLOB_DAT
block|,
name|R_68K_GLOB_DAT
block|}
block|,
block|{
name|BFD_RELOC_68K_JMP_SLOT
block|,
name|R_68K_JMP_SLOT
block|}
block|,
block|{
name|BFD_RELOC_68K_RELATIVE
block|,
name|R_68K_RELATIVE
block|}
block|,
block|{
name|BFD_RELOC_CTOR
block|,
name|R_68K_32
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_INHERIT
block|,
name|R_68K_GNU_VTINHERIT
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_ENTRY
block|,
name|R_68K_GNU_VTENTRY
block|}
block|, }
struct|;
end_struct

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|reloc_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|reloc_map
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reloc_map
index|[
name|i
index|]
operator|.
name|bfd_val
operator|==
name|code
condition|)
return|return
operator|&
name|howto_table
index|[
name|reloc_map
index|[
name|i
index|]
operator|.
name|elf_val
index|]
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_m68k
end_define

begin_escape
end_escape

begin_comment
comment|/* Functions for the m68k ELF linker.  */
end_comment

begin_comment
comment|/* The name of the dynamic interpreter.  This is put in the .interp    section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/usr/lib/libc.so.1"
end_define

begin_comment
comment|/* The size in bytes of an entry in the procedure linkage table.  */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_SIZE
value|20
end_define

begin_comment
comment|/* The first entry in a procedure linkage table looks like this.  See    the SVR4 ABI m68k supplement to see how this works.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_m68k_plt0_entry
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0x2f
block|,
literal|0x3b
block|,
literal|0x01
block|,
literal|0x70
block|,
comment|/* move.l (%pc,addr),-(%sp) */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* replaced with offset to .got + 4.  */
literal|0x4e
block|,
literal|0xfb
block|,
literal|0x01
block|,
literal|0x71
block|,
comment|/* jmp ([%pc,addr]) */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* replaced with offset to .got + 8.  */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
comment|/* pad out to 20 bytes.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subsequent entries in a procedure linkage table look like this.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_m68k_plt_entry
index|[
name|PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0x4e
block|,
literal|0xfb
block|,
literal|0x01
block|,
literal|0x71
block|,
comment|/* jmp ([%pc,symbol@GOTPC]) */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* replaced with offset to symbol's .got entry.  */
literal|0x2f
block|,
literal|0x3c
block|,
comment|/* move.l #offset,-(%sp) */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* replaced with offset into relocation table.  */
literal|0x60
block|,
literal|0xff
block|,
comment|/* bra.l .plt */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
comment|/* replaced with offset to start of .plt.  */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CFV4E_PLT_ENTRY_SIZE
value|24
end_define

begin_define
define|#
directive|define
name|CFV4E_FLAG
parameter_list|(
name|abfd
parameter_list|)
value|(elf_elfheader (abfd)->e_flags& EF_M68K_CFV4E)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_cfv4e_plt0_entry
index|[
name|CFV4E_PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0x20
block|,
literal|0x3c
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* Replaced with offset to .got + 4.  */
literal|0x2f
block|,
literal|0x3b
block|,
literal|0x08
block|,
literal|0xfa
block|,
comment|/* move.l (%pc,addr),-(%sp) */
literal|0x20
block|,
literal|0x3c
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* Replaced with offset to .got + 8.  */
literal|0x20
block|,
literal|0x7b
block|,
literal|0x08
block|,
literal|0x00
block|,
comment|/* move.l (%pc,%d0:l), %a0 */
literal|0x4e
block|,
literal|0xd0
block|,
comment|/* jmp (%a0) */
literal|0x4e
block|,
literal|0x71
comment|/* nop */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subsequent entries in a procedure linkage table look like this.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_cfv4e_plt_entry
index|[
name|CFV4E_PLT_ENTRY_SIZE
index|]
init|=
block|{
literal|0x20
block|,
literal|0x3c
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* Replaced with offset to symbol's .got entry.  */
literal|0x20
block|,
literal|0x7b
block|,
literal|0x08
block|,
literal|0x00
block|,
comment|/* move.l (%pc,%d0:l), %a0 */
literal|0x4e
block|,
literal|0xd0
block|,
comment|/* jmp (%a0) */
literal|0x2f
block|,
literal|0x3c
block|,
comment|/* move.l #offset,-(%sp) */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* Replaced with offset into relocation table.  */
literal|0x60
block|,
literal|0xff
block|,
comment|/* bra.l .plt */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
comment|/* Replaced with offset to start of .plt.  */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CPU32_FLAG
parameter_list|(
name|abfd
parameter_list|)
value|(elf_elfheader (abfd)->e_flags& EF_M68K_CPU32)
end_define

begin_define
define|#
directive|define
name|PLT_CPU32_ENTRY_SIZE
value|24
end_define

begin_comment
comment|/* Procedure linkage table entries for the cpu32 */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_cpu32_plt0_entry
index|[
name|PLT_CPU32_ENTRY_SIZE
index|]
init|=
block|{
literal|0x2f
block|,
literal|0x3b
block|,
literal|0x01
block|,
literal|0x70
block|,
comment|/* move.l (%pc,addr),-(%sp) */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* replaced with offset to .got + 4.  */
literal|0x22
block|,
literal|0x7b
block|,
literal|0x01
block|,
literal|0x70
block|,
comment|/* moveal %pc@(0xc), %a1 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* replace with offset to .got +8.  */
literal|0x4e
block|,
literal|0xd1
block|,
comment|/* jmp %a1@ */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* pad out to 24 bytes.  */
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_byte
name|elf_cpu32_plt_entry
index|[
name|PLT_CPU32_ENTRY_SIZE
index|]
init|=
block|{
literal|0x22
block|,
literal|0x7b
block|,
literal|0x01
block|,
literal|0x70
block|,
comment|/* moveal %pc@(0xc), %a1 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* replaced with offset to symbol's .got entry.  */
literal|0x4e
block|,
literal|0xd1
block|,
comment|/* jmp %a1@ */
literal|0x2f
block|,
literal|0x3c
block|,
comment|/* move.l #offset,-(%sp) */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* replaced with offset into relocation table.  */
literal|0x60
block|,
literal|0xff
block|,
comment|/* bra.l .plt */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* replaced with offset to start of .plt.  */
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The m68k linker needs to keep track of the number of relocs that it    decides to copy in check_relocs for each symbol.  This is so that it    can discard PC relative relocs if it doesn't need them when linking    with -Bsymbolic.  We store the information in a field extending the    regular ELF linker hash table.  */
end_comment

begin_comment
comment|/* This structure keeps track of the number of PC relative relocs we have    copied for a given symbol.  */
end_comment

begin_struct
struct|struct
name|elf_m68k_pcrel_relocs_copied
block|{
comment|/* Next section.  */
name|struct
name|elf_m68k_pcrel_relocs_copied
modifier|*
name|next
decl_stmt|;
comment|/* A section in dynobj.  */
name|asection
modifier|*
name|section
decl_stmt|;
comment|/* Number of relocs copied in this section.  */
name|bfd_size_type
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* m68k ELF linker hash entry.  */
end_comment

begin_struct
struct|struct
name|elf_m68k_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|root
decl_stmt|;
comment|/* Number of PC relative relocs copied for this symbol.  */
name|struct
name|elf_m68k_pcrel_relocs_copied
modifier|*
name|pcrel_relocs_copied
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|elf_m68k_hash_entry
parameter_list|(
name|ent
parameter_list|)
value|((struct elf_m68k_link_hash_entry *) (ent))
end_define

begin_comment
comment|/* m68k ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|elf_m68k_link_hash_table
block|{
name|struct
name|elf_link_hash_table
name|root
decl_stmt|;
comment|/* Small local sym to section mapping cache.  */
name|struct
name|sym_sec_cache
name|sym_sec
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Get the m68k ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|elf_m68k_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct elf_m68k_link_hash_table *) (p)->hash)
end_define

begin_comment
comment|/* Create an entry in an m68k ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|elf_m68k_link_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|bfd_hash_entry
modifier|*
name|ret
init|=
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_m68k_link_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|ret
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
name|_bfd_elf_link_hash_newfunc
argument_list|(
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
name|elf_m68k_hash_entry
argument_list|(
name|ret
argument_list|)
operator|->
name|pcrel_relocs_copied
operator|=
name|NULL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Create an m68k ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elf_m68k_link_hash_table_create
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|elf_m68k_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf_m68k_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|elf_m68k_link_hash_table
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|elf_m68k_link_hash_table
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|elf_m68k_link_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_m68k_link_hash_entry
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|->
name|sym_sec
operator|.
name|abfd
operator|=
name|NULL
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Set the right machine number.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_m68k_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|unsigned
name|int
name|mach
init|=
literal|0
decl_stmt|;
name|unsigned
name|features
init|=
literal|0
decl_stmt|;
name|flagword
name|eflags
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
decl_stmt|;
if|if
condition|(
name|eflags
operator|&
name|EF_M68K_M68000
condition|)
name|features
operator||=
name|m68000
expr_stmt|;
elseif|else
if|if
condition|(
name|eflags
operator|&
name|EF_M68K_CPU32
condition|)
name|features
operator||=
name|cpu32
expr_stmt|;
elseif|else
if|if
condition|(
name|eflags
operator|&
name|EF_M68K_ISA_MASK
condition|)
block|{
switch|switch
condition|(
name|eflags
operator|&
name|EF_M68K_ISA_MASK
condition|)
block|{
case|case
name|EF_M68K_ISA_A_NODIV
case|:
name|features
operator||=
name|mcfisa_a
expr_stmt|;
break|break;
case|case
name|EF_M68K_ISA_A
case|:
name|features
operator||=
name|mcfisa_a
operator||
name|mcfhwdiv
expr_stmt|;
break|break;
case|case
name|EF_M68K_ISA_A_PLUS
case|:
name|features
operator||=
name|mcfisa_a
operator||
name|mcfisa_aa
operator||
name|mcfhwdiv
operator||
name|mcfusp
expr_stmt|;
break|break;
case|case
name|EF_M68K_ISA_B_NOUSP
case|:
name|features
operator||=
name|mcfisa_a
operator||
name|mcfisa_b
operator||
name|mcfhwdiv
expr_stmt|;
break|break;
case|case
name|EF_M68K_ISA_B
case|:
name|features
operator||=
name|mcfisa_a
operator||
name|mcfisa_b
operator||
name|mcfhwdiv
operator||
name|mcfusp
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|eflags
operator|&
name|EF_M68K_MAC_MASK
condition|)
block|{
case|case
name|EF_M68K_MAC
case|:
name|features
operator||=
name|mcfmac
expr_stmt|;
break|break;
case|case
name|EF_M68K_EMAC
case|:
name|features
operator||=
name|mcfemac
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|eflags
operator|&
name|EF_M68K_FLOAT
condition|)
name|features
operator||=
name|cfloat
expr_stmt|;
block|}
name|mach
operator|=
name|bfd_m68k_features_to_mach
argument_list|(
name|features
argument_list|)
expr_stmt|;
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_m68k
argument_list|,
name|mach
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Keep m68k-specific flags in the ELF header.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_m68k_set_private_flags
parameter_list|(
name|abfd
parameter_list|,
name|flags
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
block|{
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_m68k_merge_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
name|flagword
name|out_flags
decl_stmt|;
name|flagword
name|in_flags
decl_stmt|;
name|flagword
name|out_isa
decl_stmt|;
name|flagword
name|in_isa
decl_stmt|;
specifier|const
name|bfd_arch_info_type
modifier|*
name|arch_info
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|FALSE
return|;
comment|/* Get the merged machine.  This checks for incompatibility between      Coldfire& non-Coldfire flags, incompability between different      Coldfire ISAs, and incompability between different MAC types.  */
name|arch_info
operator|=
name|bfd_arch_get_compatible
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arch_info
condition|)
return|return
name|FALSE
return|;
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_arch_m68k
argument_list|,
name|arch_info
operator|->
name|mach
argument_list|)
expr_stmt|;
name|in_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
name|out_flags
operator|=
name|in_flags
expr_stmt|;
block|}
else|else
block|{
name|out_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|in_isa
operator|=
operator|(
name|in_flags
operator|&
name|EF_M68K_ISA_MASK
operator|)
expr_stmt|;
name|out_isa
operator|=
operator|(
name|out_flags
operator|&
name|EF_M68K_ISA_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|in_isa
operator|>
name|out_isa
condition|)
name|out_flags
operator|^=
name|in_isa
operator|^
name|out_isa
expr_stmt|;
name|out_flags
operator||=
name|in_flags
operator|^
name|in_isa
expr_stmt|;
block|}
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|out_flags
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Display the flags field.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_m68k_print_private_bfd_data
parameter_list|(
name|abfd
parameter_list|,
name|ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|ptr
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|ptr
decl_stmt|;
name|flagword
name|eflags
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|abfd
operator|!=
name|NULL
operator|&&
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Print normal ELF private data.  */
name|_bfd_elf_print_private_bfd_data
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* Ignore init flag - it may not be set, despite the flags field containing valid data.  */
comment|/* xgettext:c-format */
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"private flags = %lx:"
argument_list|)
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|eflags
operator|&
name|EF_M68K_CPU32
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [cpu32]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eflags
operator|&
name|EF_M68K_M68000
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [m68000]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eflags
operator|&
name|EF_M68K_CFV4E
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [cfv4e]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eflags
operator|&
name|EF_M68K_ISA_MASK
condition|)
block|{
name|char
specifier|const
modifier|*
name|isa
init|=
name|_
argument_list|(
literal|"unknown"
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|mac
init|=
name|_
argument_list|(
literal|"unknown"
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|additional
init|=
literal|""
decl_stmt|;
switch|switch
condition|(
name|eflags
operator|&
name|EF_M68K_ISA_MASK
condition|)
block|{
case|case
name|EF_M68K_ISA_A_NODIV
case|:
name|isa
operator|=
literal|"A"
expr_stmt|;
name|additional
operator|=
literal|" [nodiv]"
expr_stmt|;
break|break;
case|case
name|EF_M68K_ISA_A
case|:
name|isa
operator|=
literal|"A"
expr_stmt|;
break|break;
case|case
name|EF_M68K_ISA_A_PLUS
case|:
name|isa
operator|=
literal|"A+"
expr_stmt|;
break|break;
case|case
name|EF_M68K_ISA_B_NOUSP
case|:
name|isa
operator|=
literal|"B"
expr_stmt|;
name|additional
operator|=
literal|" [nousp]"
expr_stmt|;
break|break;
case|case
name|EF_M68K_ISA_B
case|:
name|isa
operator|=
literal|"B"
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [isa %s]%s"
argument_list|,
name|isa
argument_list|,
name|additional
argument_list|)
expr_stmt|;
if|if
condition|(
name|eflags
operator|&
name|EF_M68K_FLOAT
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [float]"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|eflags
operator|&
name|EF_M68K_MAC_MASK
condition|)
block|{
case|case
literal|0
case|:
name|mac
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|EF_M68K_MAC
case|:
name|mac
operator|=
literal|"mac"
expr_stmt|;
break|break;
case|case
name|EF_M68K_EMAC
case|:
name|mac
operator|=
literal|"emac"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mac
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" [%s]"
argument_list|,
name|mac
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase, and    allocate space in the global offset table or procedure linkage    table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_m68k_check_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|NULL
expr_stmt|;
name|srelgot
operator|=
name|NULL
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_68K_GOT8
case|:
case|case
name|R_68K_GOT16
case|:
case|case
name|R_68K_GOT32
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|R_68K_GOT8O
case|:
case|case
name|R_68K_GOT16O
case|:
case|case
name|R_68K_GOT32O
case|:
comment|/* This symbol requires a global offset table entry.  */
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
block|{
comment|/* Create the .got section.  */
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
block|{
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|srelgot
operator|==
name|NULL
operator|&&
operator|(
name|h
operator|!=
name|NULL
operator|||
name|info
operator|->
name|shared
operator|)
condition|)
block|{
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srelgot
operator|==
name|NULL
condition|)
block|{
name|srelgot
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|srelgot
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|srelgot
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|==
literal|0
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Allocate space in the .got section.  */
name|sgot
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
comment|/* Allocate relocation space.  */
name|srelgot
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
name|h
operator|->
name|got
operator|.
name|refcount
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a global offset table entry for a local symbol.  */
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|size
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|size
operator|*=
sizeof|sizeof
argument_list|(
name|bfd_signed_vma
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
operator|(
operator|(
name|bfd_signed_vma
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_got_refcounts
expr_stmt|;
block|}
if|if
condition|(
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|==
literal|0
condition|)
block|{
name|sgot
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
comment|/* If we are generating a shared object, we need to 			 output a R_68K_RELATIVE reloc so that the dynamic 			 linker can adjust this GOT entry.  */
name|srelgot
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
block|}
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|R_68K_PLT8
case|:
case|case
name|R_68K_PLT16
case|:
case|case
name|R_68K_PLT32
case|:
comment|/* This symbol requires a procedure linkage table entry.  We 	     actually build the entry in adjust_dynamic_symbol,              because this might be a case of linking PIC code which is              never referenced by a dynamic object, in which case we              don't need to generate a procedure linkage table entry              after all.  */
comment|/* If this is a local symbol, we resolve it directly without 	     creating a procedure linkage table entry.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
continue|continue;
name|h
operator|->
name|needs_plt
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|refcount
operator|++
expr_stmt|;
break|break;
case|case
name|R_68K_PLT8O
case|:
case|case
name|R_68K_PLT16O
case|:
case|case
name|R_68K_PLT32O
case|:
comment|/* This symbol requires a procedure linkage table entry.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
comment|/* It does not make sense to have this relocation for a 		 local symbol.  FIXME: does it?  How to handle it if 		 it does make sense?  */
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Make sure this symbol is output as a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|h
operator|->
name|needs_plt
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|refcount
operator|++
expr_stmt|;
break|break;
case|case
name|R_68K_PC8
case|:
case|case
name|R_68K_PC16
case|:
case|case
name|R_68K_PC32
case|:
comment|/* If we are creating a shared library and this is not a local 	     symbol, we need to copy the reloc into the shared library. 	     However when linking with -Bsymbolic and this is a global 	     symbol which is defined in an object we are including in the 	     link (i.e., DEF_REGULAR is set), then we can resolve the 	     reloc directly.  At this point we have not seen all the input 	     files, so it is possible that DEF_REGULAR is not set now but 	     will be set later (it is never cleared).  We account for that 	     possibility below by storing information in the 	     pcrel_relocs_copied field of the hash table entry.  */
if|if
condition|(
operator|!
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* Make sure a plt entry is created for this symbol if 		     it turns out to be a function defined by a dynamic 		     object.  */
name|h
operator|->
name|plt
operator|.
name|refcount
operator|++
expr_stmt|;
block|}
break|break;
block|}
comment|/* Fall through.  */
case|case
name|R_68K_8
case|:
case|case
name|R_68K_16
case|:
case|case
name|R_68K_32
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
comment|/* Make sure a plt entry is created for this symbol if it 		 turns out to be a function defined by a dynamic object.  */
name|h
operator|->
name|plt
operator|.
name|refcount
operator|++
expr_stmt|;
block|}
comment|/* If we are creating a shared library, we need to copy the 	     reloc into the shared library.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* When creating a shared object, we must copy these 		 reloc types into the output file.  We create a reloc 		 section in dynobj and make room for this reloc.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|BFD_ASSERT
argument_list|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|sreloc
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sreloc
operator|=
name|sreloc
expr_stmt|;
block|}
if|if
condition|(
name|sec
operator|->
name|flags
operator|&
name|SEC_READONLY
comment|/* Don't set DF_TEXTREL yet for PC relative 		     relocations, they might be discarded later.  */
operator|&&
operator|!
operator|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_68K_PC8
operator|||
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_68K_PC16
operator|||
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_68K_PC32
operator|)
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
name|sreloc
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
comment|/* We count the number of PC relative relocations we have 		 entered for this symbol, so that we can discard them 		 again if, in the -Bsymbolic case, the symbol is later 		 defined by a regular object, or, in the normal shared 		 case, the symbol is forced to be local.  Note that this 		 function is only called if we are using an m68kelf linker 		 hash table, which means that h is really a pointer to an 		 elf_m68k_link_hash_entry.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_68K_PC8
operator|||
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_68K_PC16
operator|||
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_68K_PC32
condition|)
block|{
name|struct
name|elf_m68k_pcrel_relocs_copied
modifier|*
name|p
decl_stmt|;
name|struct
name|elf_m68k_pcrel_relocs_copied
modifier|*
modifier|*
name|head
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_m68k_link_hash_entry
modifier|*
name|eh
init|=
name|elf_m68k_hash_entry
argument_list|(
name|h
argument_list|)
decl_stmt|;
name|head
operator|=
operator|&
name|eh
operator|->
name|pcrel_relocs_copied
expr_stmt|;
block|}
else|else
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|void
modifier|*
name|vpp
decl_stmt|;
name|s
operator|=
operator|(
name|bfd_section_from_r_symndx
argument_list|(
name|abfd
argument_list|,
operator|&
name|elf_m68k_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|sym_sec
argument_list|,
name|sec
argument_list|,
name|r_symndx
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|vpp
operator|=
operator|&
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
expr_stmt|;
name|head
operator|=
operator|(
expr|struct
name|elf_m68k_pcrel_relocs_copied
operator|*
operator|*
operator|)
name|vpp
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
operator|*
name|head
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|section
operator|==
name|sreloc
condition|)
break|break;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
operator|(
operator|(
expr|struct
name|elf_m68k_pcrel_relocs_copied
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|dynobj
argument_list|,
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
expr|*
name|p
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|p
operator|->
name|next
operator|=
operator|*
name|head
expr_stmt|;
operator|*
name|head
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|section
operator|=
name|sreloc
expr_stmt|;
name|p
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
operator|++
name|p
operator|->
name|count
expr_stmt|;
block|}
block|}
break|break;
comment|/* This relocation describes the C++ object vtable hierarchy. 	     Reconstruct it for later use during GC.  */
case|case
name|R_68K_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually 	     used.  Record for later use during GC.  */
case|case
name|R_68K_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return the section that should be marked against GC for a given    relocation.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|elf_m68k_gc_mark_hook
parameter_list|(
name|sec
parameter_list|,
name|info
parameter_list|,
name|rel
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_68K_GNU_VTINHERIT
case|:
case|case
name|R_68K_GNU_VTENTRY
case|:
break|break;
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
default|default:
break|break;
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
block|}
block|}
block|}
else|else
return|return
name|bfd_section_from_elf_index
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Update the got entry reference counts for the section being removed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_m68k_gc_sweep_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|srelgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_68K_GOT8
case|:
case|case
name|R_68K_GOT16
case|:
case|case
name|R_68K_GOT32
case|:
case|case
name|R_68K_GOT8O
case|:
case|case
name|R_68K_GOT16O
case|:
case|case
name|R_68K_GOT32O
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
operator|--
name|h
operator|->
name|got
operator|.
name|refcount
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|==
literal|0
condition|)
block|{
comment|/* We don't need the .got entry any more.  */
name|sgot
operator|->
name|size
operator|-=
literal|4
expr_stmt|;
name|srelgot
operator|->
name|size
operator|-=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|local_got_refcounts
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|>
literal|0
condition|)
block|{
operator|--
name|local_got_refcounts
index|[
name|r_symndx
index|]
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|==
literal|0
condition|)
block|{
comment|/* We don't need the .got entry any more.  */
name|sgot
operator|->
name|size
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|srelgot
operator|->
name|size
operator|-=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|R_68K_PLT8
case|:
case|case
name|R_68K_PLT16
case|:
case|case
name|R_68K_PLT32
case|:
case|case
name|R_68K_PLT8O
case|:
case|case
name|R_68K_PLT16O
case|:
case|case
name|R_68K_PLT32O
case|:
case|case
name|R_68K_PC8
case|:
case|case
name|R_68K_PC16
case|:
case|case
name|R_68K_PC32
case|:
case|case
name|R_68K_8
case|:
case|case
name|R_68K_16
case|:
case|case
name|R_68K_32
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
operator|--
name|h
operator|->
name|plt
operator|.
name|refcount
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_m68k_adjust_dynamic_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|power_of_two
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
comment|/* Make sure we know what is going on here.  */
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|needs_plt
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
operator|||
operator|(
name|h
operator|->
name|def_dynamic
operator|&&
name|h
operator|->
name|ref_regular
operator|&&
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If this is a function, put it in the procedure linkage table.  We      will fill in the contents of the procedure linkage table later,      when we know the address of the .got section.  */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|||
name|h
operator|->
name|needs_plt
condition|)
block|{
if|if
condition|(
operator|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|<=
literal|0
operator|||
name|SYMBOL_CALLS_LOCAL
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
operator|||
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|!=
name|STV_DEFAULT
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|)
operator|)
comment|/* We must always create the plt entry if it was referenced 	     by a PLTxxO relocation.  In this case we already recorded 	     it as a dynamic symbol.  */
operator|&&
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* This case can occur if we saw a PLTxx reloc in an input 	     file, but the symbol was never referred to by a dynamic 	     object, or if all references were garbage collected.  In 	     such a case, we don't actually need to build a procedure 	     linkage table, and we can just do a PCxx reloc instead.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|needs_plt
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Make sure this symbol is output as a dynamic symbol.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|!
name|h
operator|->
name|forced_local
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* If this is the first .plt entry, make room for the special 	 first entry.  */
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|CPU32_FLAG
argument_list|(
name|dynobj
argument_list|)
condition|)
name|s
operator|->
name|size
operator|+=
name|PLT_CPU32_ENTRY_SIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|CFV4E_FLAG
argument_list|(
name|dynobj
argument_list|)
condition|)
name|s
operator|->
name|size
operator|+=
name|CFV4E_PLT_ENTRY_SIZE
expr_stmt|;
else|else
name|s
operator|->
name|size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
block|}
comment|/* If this symbol is not defined in a regular file, and we are 	 not generating a shared library, then set the symbol to this 	 location in the .plt.  This is required to make function 	 pointers compare as equal between the normal executable and 	 the shared library.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|size
expr_stmt|;
block|}
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|size
expr_stmt|;
comment|/* Make room for this entry.  */
if|if
condition|(
name|CPU32_FLAG
argument_list|(
name|dynobj
argument_list|)
condition|)
name|s
operator|->
name|size
operator|+=
name|PLT_CPU32_ENTRY_SIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|CFV4E_FLAG
argument_list|(
name|dynobj
argument_list|)
condition|)
name|s
operator|->
name|size
operator|+=
name|CFV4E_PLT_ENTRY_SIZE
expr_stmt|;
else|else
name|s
operator|->
name|size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* We also need to make an entry in the .got.plt section, which 	 will be placed in the .got section by the linker script.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
comment|/* We also need to make an entry in the .rela.plt section.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Reinitialize the plt offset now that it is not used as a reference      count any more.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|u
operator|.
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
comment|/* If we are creating a shared library, we must presume that the      only references to the symbol are via the global offset table.      For such cases we need not do anything here; the relocations will      be handled correctly by relocate_section.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|h
operator|->
name|size
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"dynamic variable `%s' is zero size"
argument_list|)
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* We must allocate the symbol in our .dynbss section, which will      become part of the .bss section of the executable.  There will be      an entry for this symbol in the .dynsym section.  The dynamic      object will contain position independent code, so all references      from the dynamic object to this symbol will go through the global      offset table.  The dynamic linker will use the .dynsym entry to      determine the address it must put in the global offset table, so      both the dynamic object and the regular object will refer to the      same memory location for the variable.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* We must generate a R_68K_COPY reloc to tell the dynamic linker to      copy the initial value out of the dynamic object and into the      runtime process image.  We need to remember the offset into the      .rela.bss section we are going to use.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|asection
modifier|*
name|srel
decl_stmt|;
name|srel
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.bss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|srel
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|srel
operator|->
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|h
operator|->
name|needs_copy
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We need to figure out the alignment required for this symbol.  I      have no idea how ELF linkers handle this.  */
name|power_of_two
operator|=
name|bfd_log2
argument_list|(
name|h
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
literal|3
condition|)
name|power_of_two
operator|=
literal|3
expr_stmt|;
comment|/* Apply the required alignment.  */
name|s
operator|->
name|size
operator|=
name|BFD_ALIGN
argument_list|(
name|s
operator|->
name|size
argument_list|,
call|(
name|bfd_size_type
call|)
argument_list|(
literal|1
operator|<<
name|power_of_two
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
name|bfd_get_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|,
name|power_of_two
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Define the symbol as being at this point in the section.  */
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|size
expr_stmt|;
comment|/* Increment the section size to make room for the symbol.  */
name|s
operator|->
name|size
operator|+=
name|h
operator|->
name|size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_m68k_size_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_boolean
name|plt
decl_stmt|;
name|bfd_boolean
name|relocs
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|dynobj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
name|info
operator|->
name|executable
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We may have created entries in the .rela.got section. 	 However, if we are not creating the dynamic sections, we will 	 not actually use these entries.  Reset the size of .rela.got, 	 which will cause it to get stripped from the output file 	 below.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|s
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this is a -Bsymbolic shared link, then we need to discard all      PC relative relocs against symbols defined in a regular object.      For the normal shared case we discard the PC relative relocs      against symbols that have become local due to visibility changes.      We allocated space for them in the check_relocs routine, but we      will not fill them in in the relocate_section routine.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|elf_m68k_discard_copies
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
comment|/* The check_relocs and adjust_dynamic_symbol entry points have      determined the sizes of the various dynamic sections.  Allocate      memory for them.  */
name|plt
operator|=
name|FALSE
expr_stmt|;
name|relocs
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* It's OK to base decisions on the section name, because none 	 of the dynobj section names depend upon the input files.  */
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".plt"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Remember whether there is a PLT.  */
name|plt
operator|=
name|s
operator|->
name|size
operator|!=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
name|relocs
operator|=
name|TRUE
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need 		 to copy relocs into the output file.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".got"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".dynbss"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|s
operator|->
name|size
operator|==
literal|0
condition|)
block|{
comment|/* If we don't need this section, strip it from the 	     output file.  This is mostly to handle .rela.bss and 	     .rela.plt.  We must create both sections in 	     create_dynamic_sections, because they must be created 	     before the linker maps input sections to output 	     sections.  The linker does that before 	     adjust_dynamic_symbol is called, and it is that 	     function which decides whether anything needs to go 	     into these sections.  */
name|s
operator|->
name|flags
operator||=
name|SEC_EXCLUDE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Allocate memory for the section contents.  */
comment|/* FIXME: This should be a call to bfd_alloc not bfd_zalloc. 	 Unused entries should be reclaimed before the section's contents 	 are written out, but at the moment this does not happen.  Thus in 	 order to prevent writing out garbage, we initialise the section's 	 contents to zero.  */
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in elf_m68k_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
define|#
directive|define
name|add_dynamic_entry
parameter_list|(
name|TAG
parameter_list|,
name|VAL
parameter_list|)
define|\
value|_bfd_elf_add_dynamic_entry (info, TAG, VAL)
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|plt
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTREL
argument_list|,
name|DT_RELA
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|relocs
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELA
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELAENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
undef|#
directive|undef
name|add_dynamic_entry
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This function is called via elf_link_hash_traverse if we are    creating a shared object.  In the -Bsymbolic case it discards the    space allocated to copy PC relative relocs against symbols which    are defined in regular objects.  For the normal shared case, it    discards space for pc-relative relocs that have become local due to    symbol visibility changes.  We allocated space for them in the    check_relocs routine, but we won't fill them in in the    relocate_section routine.     We also check whether any of the remaining relocations apply    against a readonly section, and set the DF_TEXTREL flag in this    case.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_m68k_discard_copies
parameter_list|(
name|h
parameter_list|,
name|inf
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|inf
decl_stmt|;
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
decl_stmt|;
name|struct
name|elf_m68k_pcrel_relocs_copied
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
operator|!
name|h
operator|->
name|def_regular
operator|||
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|&&
operator|!
name|h
operator|->
name|forced_local
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Look for relocations against read-only sections.  */
for|for
control|(
name|s
operator|=
name|elf_m68k_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|pcrel_relocs_copied
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|s
operator|->
name|section
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
block|{
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
for|for
control|(
name|s
operator|=
name|elf_m68k_hash_entry
argument_list|(
name|h
argument_list|)
operator|->
name|pcrel_relocs_copied
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
name|s
operator|->
name|section
operator|->
name|size
operator|-=
name|s
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Relocate an M68K ELF section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_m68k_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|NULL
expr_stmt|;
name|splt
operator|=
name|NULL
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_boolean
name|unresolved_reloc
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|<
literal|0
operator|||
name|r_type
operator|>=
operator|(
name|int
operator|)
name|R_68K_max
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|howto
operator|=
name|howto_table
operator|+
name|r_type
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_boolean
name|warned
decl_stmt|;
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_68K_GOT8
case|:
case|case
name|R_68K_GOT16
case|:
case|case
name|R_68K_GOT32
case|:
comment|/* Relocation is to the address of the entry for this symbol 	     in the global offset table.  */
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|R_68K_GOT8O
case|:
case|case
name|R_68K_GOT16O
case|:
case|case
name|R_68K_GOT32O
case|:
comment|/* Relocation is the offset of the entry for this symbol in 	     the global offset table.  */
block|{
name|bfd_vma
name|off
decl_stmt|;
if|if
condition|(
name|sgot
operator|==
name|NULL
condition|)
block|{
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|bfd_boolean
name|dyn
decl_stmt|;
name|off
operator|=
name|h
operator|->
name|got
operator|.
name|offset
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|off
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dyn
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
expr_stmt|;
if|if
condition|(
operator|!
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
operator|->
name|shared
argument_list|,
name|h
argument_list|)
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
name|h
operator|->
name|forced_local
operator|)
operator|&&
name|h
operator|->
name|def_regular
operator|)
condition|)
block|{
comment|/* This is actually a static link, or it is a 		       -Bsymbolic link and the symbol is defined 		       locally, or the symbol was forced to be local 		       because of a version file..  We must initialize 		       this entry in the global offset table.  Since 		       the offset must always be a multiple of 4, we 		       use the least significant bit to record whether 		       we have initialized it already.  		       When doing a dynamic link, we create a .rela.got 		       relocation entry to initialize the value.  This 		       is done in the finish_dynamic_symbol routine.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|offset
operator||=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|local_got_offsets
operator|!=
name|NULL
operator|&&
name|local_got_offsets
index|[
name|r_symndx
index|]
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|off
operator|=
name|local_got_offsets
index|[
name|r_symndx
index|]
expr_stmt|;
comment|/* The offset must always be a multiple of 4.  We use 		   the least significant bit to record whether we have 		   already generated the necessary reloc.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_68K_RELATIVE
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
expr_stmt|;
name|loc
operator|=
name|s
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|s
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
name|local_got_offsets
index|[
name|r_symndx
index|]
operator||=
literal|1
expr_stmt|;
block|}
block|}
name|relocation
operator|=
name|sgot
operator|->
name|output_offset
operator|+
name|off
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_68K_GOT8O
operator|||
name|r_type
operator|==
name|R_68K_GOT16O
operator|||
name|r_type
operator|==
name|R_68K_GOT32O
condition|)
block|{
comment|/* This relocation does not use the addend.  */
name|rel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|relocation
operator|+=
name|sgot
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
block|}
break|break;
case|case
name|R_68K_PLT8
case|:
case|case
name|R_68K_PLT16
case|:
case|case
name|R_68K_PLT32
case|:
comment|/* Relocation is to the entry for this symbol in the 	     procedure linkage table.  */
comment|/* Resolve a PLTxx reloc against a local symbol directly, 	     without using the procedure linkage table.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|||
operator|!
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
comment|/* We didn't make a PLT entry for this symbol.  This 		 happens when statically linking PIC code, or when 		 using -Bsymbolic.  */
break|break;
block|}
if|if
condition|(
name|splt
operator|==
name|NULL
condition|)
block|{
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|relocation
operator|=
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|R_68K_PLT8O
case|:
case|case
name|R_68K_PLT16O
case|:
case|case
name|R_68K_PLT32O
case|:
comment|/* Relocation is the offset of the entry for this symbol in 	     the procedure linkage table.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|splt
operator|==
name|NULL
condition|)
block|{
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|relocation
operator|=
name|h
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
name|unresolved_reloc
operator|=
name|FALSE
expr_stmt|;
comment|/* This relocation does not use the addend.  */
name|rel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|R_68K_PC8
case|:
case|case
name|R_68K_PC16
case|:
case|case
name|R_68K_PC32
case|:
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
name|h
operator|->
name|forced_local
operator|)
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|R_68K_8
case|:
case|case
name|R_68K_16
case|:
case|case
name|R_68K_32
case|:
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
name|r_symndx
operator|!=
literal|0
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|==
name|NULL
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|)
operator|&&
operator|(
operator|(
name|r_type
operator|!=
name|R_68K_PC8
operator|&&
name|r_type
operator|!=
name|R_68K_PC16
operator|&&
name|r_type
operator|!=
name|R_68K_PC32
operator|)
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
operator|)
operator|)
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_boolean
name|skip
decl_stmt|,
name|relocate
decl_stmt|;
comment|/* When generating a shared object, these relocations 		 are copied into the output file to be resolved at run 		 time.  */
name|skip
operator|=
name|FALSE
expr_stmt|;
name|relocate
operator|=
name|FALSE
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|skip
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|skip
operator|=
name|TRUE
operator|,
name|relocate
operator|=
name|TRUE
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|outrel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|r_type
operator|==
name|R_68K_PC8
operator|||
name|r_type
operator|==
name|R_68K_PC16
operator|||
name|r_type
operator|==
name|R_68K_PC32
operator|||
operator|!
name|info
operator|->
name|shared
operator|||
operator|!
name|info
operator|->
name|symbolic
operator|||
operator|!
name|h
operator|->
name|def_regular
operator|)
condition|)
block|{
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
else|else
block|{
comment|/* This symbol is local, or marked to become local.  */
if|if
condition|(
name|r_type
operator|==
name|R_68K_32
condition|)
block|{
name|relocate
operator|=
name|TRUE
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_68K_RELATIVE
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
else|else
block|{
name|long
name|indx
decl_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
condition|)
name|indx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|==
name|NULL
operator|||
name|sec
operator|->
name|owner
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|asection
modifier|*
name|osec
decl_stmt|;
name|osec
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
name|indx
operator|=
name|elf_section_data
argument_list|(
name|osec
argument_list|)
operator|->
name|dynindx
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|indx
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|indx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
block|}
name|sreloc
operator|=
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|sreloc
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|loc
operator|=
name|sreloc
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|sreloc
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
comment|/* This reloc will be computed at runtime, so there's no                  need to do anything now, except for R_68K_32                  relocations that have been turned into                  R_68K_RELATIVE.  */
if|if
condition|(
operator|!
name|relocate
condition|)
continue|continue;
block|}
break|break;
case|case
name|R_68K_GNU_VTINHERIT
case|:
case|case
name|R_68K_GNU_VTENTRY
case|:
comment|/* These are no-ops in the end.  */
continue|continue;
default|default:
break|break;
block|}
comment|/* Dynamic relocs are not propagated for SEC_DEBUGGING sections 	 because such sections are not SEC_ALLOC and thus ld.so will 	 not process them.  */
if|if
condition|(
name|unresolved_reloc
operator|&&
operator|!
operator|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|->
name|def_dynamic
operator|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|howto
operator|->
name|name
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
name|bfd_reloc_overflow
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
argument_list|(
name|info
argument_list|,
operator|(
name|h
condition|?
operator|&
name|h
operator|->
name|root
else|:
name|NULL
operator|)
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B(%A+0x%lx): reloc against `%s': error %d"
argument_list|)
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|name
argument_list|,
operator|(
name|int
operator|)
name|r
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_m68k_finish_dynamic_symbol
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|int
name|plt_off1
decl_stmt|,
name|plt_off2
decl_stmt|,
name|plt_off3
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srela
decl_stmt|;
name|bfd_vma
name|plt_index
decl_stmt|;
name|bfd_vma
name|got_offset
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
comment|/* This symbol has an entry in the procedure linkage table.  Set 	 it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
name|srela
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|sgot
operator|!=
name|NULL
operator|&&
name|srela
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Get the index in the procedure linkage table which 	 corresponds to this symbol.  This is the index of this symbol 	 in all the symbols for which we are making plt entries.  The 	 first entry in the procedure linkage table is reserved.  */
if|if
condition|(
name|CPU32_FLAG
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|plt_index
operator|=
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|/
name|PLT_CPU32_ENTRY_SIZE
operator|)
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|CFV4E_FLAG
argument_list|(
name|output_bfd
argument_list|)
condition|)
name|plt_index
operator|=
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|/
name|CFV4E_PLT_ENTRY_SIZE
operator|)
operator|-
literal|1
expr_stmt|;
else|else
name|plt_index
operator|=
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|/
name|PLT_ENTRY_SIZE
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Get the offset into the .got table of the entry that 	 corresponds to this function.  Each .got entry is 4 bytes. 	 The first three are reserved.  */
name|got_offset
operator|=
operator|(
name|plt_index
operator|+
literal|3
operator|)
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|CPU32_FLAG
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
comment|/* Fill in the entry in the procedure linkage table.  */
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|,
name|elf_cpu32_plt_entry
argument_list|,
name|PLT_CPU32_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|plt_off1
operator|=
literal|4
expr_stmt|;
name|plt_off2
operator|=
literal|12
expr_stmt|;
name|plt_off3
operator|=
literal|18
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CFV4E_FLAG
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|,
name|elf_cfv4e_plt_entry
argument_list|,
name|CFV4E_PLT_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|plt_off1
operator|=
literal|2
expr_stmt|;
name|plt_off2
operator|=
literal|14
expr_stmt|;
name|plt_off3
operator|=
literal|20
expr_stmt|;
block|}
else|else
block|{
comment|/* Fill in the entry in the procedure linkage table.  */
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|,
name|elf_m68k_plt_entry
argument_list|,
name|PLT_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|plt_off1
operator|=
literal|4
expr_stmt|;
name|plt_off2
operator|=
literal|10
expr_stmt|;
name|plt_off3
operator|=
literal|16
expr_stmt|;
block|}
comment|/* The offset is relative to the first extension word.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|got_offset
operator|-
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
operator|(
name|CFV4E_FLAG
argument_list|(
name|output_bfd
argument_list|)
condition|?
literal|8
else|:
literal|2
operator|)
operator|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|plt_off1
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_index
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|plt_off2
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|-
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|plt_off3
operator|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
name|plt_off3
argument_list|)
expr_stmt|;
comment|/* Fill in the entry in the global offset table.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
operator|(
name|CFV4E_FLAG
argument_list|(
name|output_bfd
argument_list|)
condition|?
literal|12
else|:
literal|8
operator|)
operator|)
argument_list|,
name|sgot
operator|->
name|contents
operator|+
name|got_offset
argument_list|)
expr_stmt|;
comment|/* Fill in the entry in the .rela.plt section.  */
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
name|got_offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_68K_JMP_SLOT
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
name|srela
operator|->
name|contents
operator|+
name|plt_index
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h
operator|->
name|def_regular
condition|)
block|{
comment|/* Mark the symbol as undefined, rather than as defined in 	     the .plt section.  Leave the value alone.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
block|}
block|}
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|srela
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
comment|/* This symbol has an entry in the global offset table.  Set it 	 up.  */
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|srela
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
operator|&&
name|srela
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* If this is a -Bsymbolic link, and the symbol is defined 	 locally, we just want to emit a RELATIVE reloc.  Likewise if 	 the symbol was forced to be local because of a version file. 	 The entry in the global offset table will already have been 	 initialized in the relocate_section function.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
name|h
operator|->
name|forced_local
operator|)
operator|&&
name|h
operator|->
name|def_regular
condition|)
block|{
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_68K_RELATIVE
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
name|bfd_get_signed_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|sgot
operator|->
name|contents
operator|+
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
operator|)
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_68K_GLOB_DAT
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
name|loc
operator|=
name|srela
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|srela
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|needs_copy
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
comment|/* This symbol needs a copy reloc.  Set it up.  */
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|owner
argument_list|,
literal|".rela.bss"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_68K_COPY
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
name|s
operator|->
name|contents
operator|+
name|s
operator|->
name|reloc_count
operator|++
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
comment|/* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
name|h
operator|==
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|hgot
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf_m68k_finish_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sgot
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynamic_sections_created
condition|)
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|Elf32_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
operator|&&
name|sdyn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_elf32_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
default|default:
break|break;
case|case
name|DT_PLTGOT
case|:
name|name
operator|=
literal|".got"
expr_stmt|;
goto|goto
name|get_vma
goto|;
case|case
name|DT_JMPREL
case|:
name|name
operator|=
literal|".rela.plt"
expr_stmt|;
name|get_vma
label|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|s
operator|->
name|vma
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|size
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_RELASZ
case|:
comment|/* The procedure linkage table relocs (DT_JMPREL) should 		 not be included in the overall relocs (DT_RELA). 		 Therefore, we override the DT_RELASZ entry here to 		 make it not include the JMPREL relocs.  Since the 		 linker script arranges for .rela.plt to follow all 		 other relocation sections, we don't have to worry 		 about changing the DT_RELA entry.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|output_bfd
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|-=
name|s
operator|->
name|size
expr_stmt|;
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Fill in the first entry in the procedure linkage table.  */
if|if
condition|(
name|splt
operator|->
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|CFV4E_FLAG
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
argument_list|,
name|elf_cfv4e_plt0_entry
argument_list|,
name|CFV4E_PLT_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
literal|4
operator|-
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
literal|2
operator|)
operator|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
literal|8
operator|-
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
literal|10
operator|)
operator|-
literal|8
operator|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|12
argument_list|)
expr_stmt|;
name|elf_section_data
argument_list|(
name|splt
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
name|CFV4E_PLT_ENTRY_SIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CPU32_FLAG
argument_list|(
name|output_bfd
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
argument_list|,
name|elf_cpu32_plt0_entry
argument_list|,
name|PLT_CPU32_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
literal|4
operator|-
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
literal|2
operator|)
operator|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
literal|8
operator|-
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
literal|10
operator|)
operator|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|12
argument_list|)
expr_stmt|;
name|elf_section_data
argument_list|(
name|splt
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
name|PLT_CPU32_ENTRY_SIZE
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|splt
operator|->
name|contents
argument_list|,
name|elf_m68k_plt0_entry
argument_list|,
name|PLT_ENTRY_SIZE
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
literal|4
operator|-
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
literal|2
operator|)
operator|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sgot
operator|->
name|output_offset
operator|+
literal|8
operator|-
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
literal|10
operator|)
operator|)
argument_list|,
name|splt
operator|->
name|contents
operator|+
literal|12
argument_list|)
expr_stmt|;
name|elf_section_data
argument_list|(
name|splt
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
name|PLT_ENTRY_SIZE
expr_stmt|;
block|}
block|}
block|}
comment|/* Fill in the first three entries in the global offset table.  */
if|if
condition|(
name|sgot
operator|->
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sdyn
operator|==
name|NULL
condition|)
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
else|else
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|sdyn
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sdyn
operator|->
name|output_offset
argument_list|,
name|sgot
operator|->
name|contents
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|sgot
operator|->
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
name|elf_section_data
argument_list|(
name|sgot
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|4
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Given a .data section and a .emreloc in-memory section, store    relocation information into the .emreloc section which can be    used at runtime to relocate the section.  This is called by the    linker when the --embedded-relocs switch is used.  This is called    after the add_symbols entry point has been called for all the    objects, and before the final_link entry point is called.  */
end_comment

begin_function
name|bfd_boolean
name|bfd_m68k_elf32_create_embedded_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|datasec
parameter_list|,
name|relsec
parameter_list|,
name|errmsg
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|datasec
decl_stmt|;
name|asection
modifier|*
name|relsec
decl_stmt|;
name|char
modifier|*
modifier|*
name|errmsg
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|BFD_ASSERT
argument_list|(
operator|!
name|info
operator|->
name|relocatable
argument_list|)
expr_stmt|;
operator|*
name|errmsg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|datasec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
comment|/* Get a copy of the native relocations.  */
name|internal_relocs
operator|=
operator|(
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|datasec
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|amt
operator|=
operator|(
name|bfd_size_type
operator|)
name|datasec
operator|->
name|reloc_count
operator|*
literal|12
expr_stmt|;
name|relsec
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|relsec
operator|->
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|p
operator|=
name|relsec
operator|->
name|contents
expr_stmt|;
name|irelend
operator|=
name|internal_relocs
operator|+
name|datasec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
operator|,
name|p
operator|+=
literal|12
control|)
block|{
name|asection
modifier|*
name|targetsec
decl_stmt|;
comment|/* We are going to write a four byte longword into the runtime        reloc section.  The longword will be the address in the data        section which must be relocated.  It is followed by the name        of the target section NUL-padded or truncated to 8        characters.  */
comment|/* We can only relocate absolute longword relocs at run time.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_68K_32
condition|)
block|{
operator|*
name|errmsg
operator|=
name|_
argument_list|(
literal|"unsupported reloc type"
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* Get the target section referred to by the reloc.  */
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* A local symbol.  */
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
comment|/* Read this BFD's local symbols if we haven't done so already.  */
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
name|isym
operator|=
name|isymbuf
operator|+
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|targetsec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|indx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* An external symbol.  */
name|indx
operator|=
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
name|targetsec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
else|else
name|targetsec
operator|=
name|NULL
expr_stmt|;
block|}
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
name|datasec
operator|->
name|output_offset
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
operator|+
literal|4
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetsec
operator|!=
name|NULL
condition|)
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|+
literal|4
argument_list|,
name|targetsec
operator|->
name|output_section
operator|->
name|name
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|datasec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|datasec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|elf_reloc_type_class
name|elf32_m68k_reloc_type_class
parameter_list|(
name|rela
parameter_list|)
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rela
decl_stmt|;
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|ELF32_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_68K_RELATIVE
case|:
return|return
name|reloc_class_relative
return|;
case|case
name|R_68K_JMP_SLOT
case|:
return|return
name|reloc_class_plt
return|;
case|case
name|R_68K_COPY
case|:
return|return
name|reloc_class_copy
return|;
default|default:
return|return
name|reloc_class_normal
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return address for Ith PLT stub in section PLT, for relocation REL    or (bfd_vma) -1 if it should not be included.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|elf_m68k_plt_sym_val
parameter_list|(
name|bfd_vma
name|i
parameter_list|,
specifier|const
name|asection
modifier|*
name|plt
parameter_list|,
specifier|const
name|arelent
modifier|*
name|rel
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|CPU32_FLAG
argument_list|(
name|plt
operator|->
name|owner
argument_list|)
condition|)
return|return
name|plt
operator|->
name|vma
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|PLT_CPU32_ENTRY_SIZE
return|;
return|return
name|plt
operator|->
name|vma
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|PLT_ENTRY_SIZE
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_m68k_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-m68k"
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_68K
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x2000
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
define|\
value|_bfd_elf_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
define|\
value|elf_m68k_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_final_link
value|bfd_elf_gc_common_final_link
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|elf_m68k_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
define|\
value|elf_m68k_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
define|\
value|elf_m68k_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|elf_m68k_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
define|\
value|elf_m68k_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
define|\
value|elf_m68k_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|elf_m68k_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|elf_m68k_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_merge_private_bfd_data
define|\
value|elf32_m68k_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_set_private_flags
define|\
value|elf32_m68k_set_private_flags
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_print_private_bfd_data
define|\
value|elf32_m68k_print_private_bfd_data
end_define

begin_define
define|#
directive|define
name|elf_backend_reloc_type_class
value|elf32_m68k_reloc_type_class
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_sym_val
value|elf_m68k_plt_sym_val
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|elf32_m68k_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_can_refcount
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_want_got_plt
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_readonly
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|12
end_define

begin_define
define|#
directive|define
name|elf_backend_rela_normal
value|1
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

