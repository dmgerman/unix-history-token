begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for mmo objects (MMIX-specific object-format).    Copyright 2001, 2002, 2003    Free Software Foundation, Inc.    Written by Hans-Peter Nilsson (hp@bitrange.com).    Infrastructure and other bits originally copied from srec.c and    binary.c.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* SECTION 	mmo backend  	The mmo object format is used exclusively together with Professor 	Donald E.@: Knuth's educational 64-bit processor MMIX.  The simulator 	@command{mmix} which is available at 	@url{http://www-cs-faculty.stanford.edu/~knuth/programs/mmix.tar.gz} 	understands this format.  That package also includes a combined 	assembler and linker called @command{mmixal}.  The mmo format has 	no advantages feature-wise compared to e.g. ELF.  It is a simple 	non-relocatable object format with no support for archives or 	debugging information, except for symbol value information and 	line numbers (which is not yet implemented in BFD).  See 	@url{http://www-cs-faculty.stanford.edu/~knuth/mmix.html} for more 	information about MMIX.  The ELF format is used for intermediate 	object files in the BFD implementation.  @c We want to xref the symbol table node.  A feature in "chew" @c requires that "commands" do not contain spaces in the @c arguments.  Hence the hyphen in "Symbol-table". @menu @* File layout:: @* Symbol-table:: @* mmo section mapping:: @end menu  INODE File layout, Symbol-table, mmo, mmo SUBSECTION 	File layout  	The mmo file contents is not partitioned into named sections as 	with e.g.@: ELF.  Memory areas is formed by specifying the 	location of the data that follows.  Only the memory area 	@samp{0x0000@dots{}00} to @samp{0x01ff@dots{}ff} is executable, so 	it is used for code (and constants) and the area 	@samp{0x2000@dots{}00} to @samp{0x20ff@dots{}ff} is used for 	writable data.  @xref{mmo section mapping}.  	Contents is entered as 32-bit words, xor:ed over previous 	contents, always zero-initialized.  A word that starts with the 	byte @samp{0x98} forms a command called a @samp{lopcode}, where 	the next byte distinguished between the thirteen lopcodes.  The 	two remaining bytes, called the @samp{Y} and @samp{Z} fields, or 	the @samp{YZ} field (a 16-bit big-endian number), are used for 	various purposes different for each lopcode.  As documented in 	@url{http://www-cs-faculty.stanford.edu/~knuth/mmixal-intro.ps.gz}, 	the lopcodes are:  	There is provision for specifying ``special data'' of 65536 	different types.  We use type 80 (decimal), arbitrarily chosen the 	same as the ELF<<e_machine>> number for MMIX, filling it with 	section information normally found in ELF objects. @xref{mmo 	section mapping}.  	@table @code 	@item lop_quote 	0x98000001.  The next word is contents, regardless of whether it 	starts with 0x98 or not.  	@item lop_loc 	0x9801YYZZ, where @samp{Z} is 1 or 2.  This is a location 	directive, setting the location for the next data to the next 	32-bit word (for @math{Z = 1}) or 64-bit word (for @math{Z = 2}), 	plus @math{Y * 2^56}.  Normally @samp{Y} is 0 for the text segment 	and 2 for the data segment.  	@item lop_skip 	0x9802YYZZ.  Increase the current location by @samp{YZ} bytes.  	@item lop_fixo 	0x9803YYZZ, where @samp{Z} is 1 or 2.  Store the current location 	as 64 bits into the location pointed to by the next 32-bit 	(@math{Z = 1}) or 64-bit (@math{Z = 2}) word, plus @math{Y * 	2^56}.  	@item lop_fixr 	0x9804YYZZ.  @samp{YZ} is stored into the current location plus 	@math{2 - 4 * YZ}.  	@item lop_fixrx 	0x980500ZZ.  @samp{Z} is 16 or 24.  A value @samp{L} derived from 	the following 32-bit word are used in a manner similar to 	@samp{YZ} in lop_fixr: it is xor:ed into the current location 	minus @math{4 * L}.  The first byte of the word is 0 or 1.  If it 	is 1, then @math{L = (@var{lowest 24 bits of word}) - 2^Z}, if 0,  	then @math{L = (@var{lowest 24 bits of word})}.  	@item lop_file 	0x9806YYZZ.  @samp{Y} is the file number, @samp{Z} is count of 	32-bit words.  Set the file number to @samp{Y} and the line 	counter to 0.  The next @math{Z * 4} bytes contain the file name, 	padded with zeros if the count is not a multiple of four.  The 	same @samp{Y} may occur multiple times, but @samp{Z} must be 0 for 	all but the first occurrence.  	@item lop_line 	0x9807YYZZ.  @samp{YZ} is the line number.  Together with 	lop_file, it forms the source location for the next 32-bit word. 	Note that for each non-lopcode 32-bit word, line numbers are 	assumed incremented by one.  	@item lop_spec 	0x9808YYZZ.  @samp{YZ} is the type number.  Data until the next 	lopcode other than lop_quote forms special data of type @samp{YZ}. 	@xref{mmo section mapping}.  	Other types than 80, (or type 80 with a content that does not 	parse) is stored in sections named<<.MMIX.spec_data.@var{n}>> 	where @var{n} is the @samp{YZ}-type.  The flags for such a 	sections say not to allocate or load the data.  The vma is 0. 	Contents of multiple occurrences of special data @var{n} is 	concatenated to the data of the previous lop_spec @var{n}s.  The 	location in data or code at which the lop_spec occurred is lost.  	@item lop_pre 	0x980901ZZ.  The first lopcode in a file.  The @samp{Z} field forms the 	length of header information in 32-bit words, where the first word 	tells the time in seconds since @samp{00:00:00 GMT Jan 1 1970}.  	@item lop_post 	0x980a00ZZ.  @math{Z> 32}.  This lopcode follows after all 	content-generating lopcodes in a program.  The @samp{Z} field 	denotes the value of @samp{rG} at the beginning of the program. 	The following @math{256 - Z} big-endian 64-bit words are loaded 	into global registers @samp{$G} @dots{} @samp{$255}.  	@item lop_stab 	0x980b0000.  The next-to-last lopcode in a program.  Must follow 	immediately after the lop_post lopcode and its data.  After this 	lopcode follows all symbols in a compressed format 	(@pxref{Symbol-table}).  	@item lop_end 	0x980cYYZZ.  The last lopcode in a program.  It must follow the 	lop_stab lopcode and its data.  The @samp{YZ} field contains the 	number of 32-bit words of symbol table information after the 	preceding lop_stab lopcode. 	@end table  	Note that the lopcode "fixups";<<lop_fixr>>,<<lop_fixrx>> and<<lop_fixo>> are not generated by BFD, but are handled.  They are 	generated by<<mmixal>>.  EXAMPLE 	This trivial one-label, one-instruction file:  | :Main TRAP 1,2,3  	can be represented this way in mmo:  | 0x98090101 - lop_pre, one 32-bit word with timestamp. |<timestamp> | 0x98010002 - lop_loc, text segment, using a 64-bit address. |              Note that mmixal does not emit this for the file above. | 0x00000000 - Address, high 32 bits. | 0x00000000 - Address, low 32 bits. | 0x98060002 - lop_file, 2 32-bit words for file-name. | 0x74657374 - "test" | 0x2e730000 - ".s\0\0" | 0x98070001 - lop_line, line 1. | 0x00010203 - TRAP 1,2,3 | 0x980a00ff - lop_post, setting $255 to 0. | 0x00000000 | 0x00000000 | 0x980b0000 - lop_stab for ":Main" = 0, serial 1. | 0x203a4040   @xref{Symbol-table}. | 0x10404020 | 0x4d206120 | 0x69016e00 | 0x81000000 | 0x980c0005 - lop_end; symbol table contained five 32-bit words.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"elf/mmix.h"
end_include

begin_include
include|#
directive|include
file|"opcode/mmix.h"
end_include

begin_define
define|#
directive|define
name|LOP
value|0x98
end_define

begin_define
define|#
directive|define
name|LOP_QUOTE
value|0
end_define

begin_define
define|#
directive|define
name|LOP_LOC
value|1
end_define

begin_define
define|#
directive|define
name|LOP_SKIP
value|2
end_define

begin_define
define|#
directive|define
name|LOP_FIXO
value|3
end_define

begin_define
define|#
directive|define
name|LOP_FIXR
value|4
end_define

begin_define
define|#
directive|define
name|LOP_FIXRX
value|5
end_define

begin_define
define|#
directive|define
name|LOP_FILE
value|6
end_define

begin_define
define|#
directive|define
name|LOP_LINE
value|7
end_define

begin_define
define|#
directive|define
name|LOP_SPEC
value|8
end_define

begin_define
define|#
directive|define
name|LOP_PRE
value|9
end_define

begin_define
define|#
directive|define
name|LOP_POST
value|10
end_define

begin_define
define|#
directive|define
name|LOP_STAB
value|11
end_define

begin_define
define|#
directive|define
name|LOP_END
value|12
end_define

begin_define
define|#
directive|define
name|LOP_QUOTE_NEXT
value|((LOP<< 24) | (LOP_QUOTE<< 16) | 1)
end_define

begin_define
define|#
directive|define
name|SPEC_DATA_SECTION
value|80
end_define

begin_define
define|#
directive|define
name|LOP_SPEC_SECTION
define|\
value|((LOP<< 24) | (LOP_SPEC<< 16) | SPEC_DATA_SECTION)
end_define

begin_comment
comment|/* Must be a power of two.  If you change this to be>= 64k, you need a    new test-case; the ld test b-loc64k.d touches chunk-size problem areas.  */
end_comment

begin_define
define|#
directive|define
name|MMO_SEC_CONTENTS_CHUNK_SIZE
value|(1<< 15)
end_define

begin_comment
comment|/* An arbitrary number for the maximum length section name size.  */
end_comment

begin_define
define|#
directive|define
name|MAX_SECTION_NAME_SIZE
value|(1024 * 1024)
end_define

begin_comment
comment|/* A quite arbitrary number for the maximum length section size.  */
end_comment

begin_define
define|#
directive|define
name|MAX_ARTIFICIAL_SECTION_SIZE
value|(1024 * 1024 * 1024)
end_define

begin_define
define|#
directive|define
name|MMO3_WCHAR
value|0x80
end_define

begin_define
define|#
directive|define
name|MMO3_LEFT
value|0x40
end_define

begin_define
define|#
directive|define
name|MMO3_MIDDLE
value|0x20
end_define

begin_define
define|#
directive|define
name|MMO3_RIGHT
value|0x10
end_define

begin_define
define|#
directive|define
name|MMO3_TYPEBITS
value|0xf
end_define

begin_define
define|#
directive|define
name|MMO3_REGQUAL_BITS
value|0xf
end_define

begin_define
define|#
directive|define
name|MMO3_UNDEF
value|2
end_define

begin_define
define|#
directive|define
name|MMO3_DATA
value|8
end_define

begin_define
define|#
directive|define
name|MMO3_SYMBITS
value|0x2f
end_define

begin_comment
comment|/* Put these everywhere in new code.  */
end_comment

begin_define
define|#
directive|define
name|FATAL_DEBUG
define|\
value|_bfd_abort (__FILE__, __LINE__,				\ 	     "Internal: Non-debugged code (test-case missing)")
end_define

begin_define
define|#
directive|define
name|BAD_CASE
parameter_list|(
name|x
parameter_list|)
define|\
value|_bfd_abort (__FILE__, __LINE__,		\ 	     "bad case for " #x)
end_define

begin_enum
enum|enum
name|mmo_sym_type
block|{
name|mmo_reg_sym
block|,
name|mmo_undef_sym
block|,
name|mmo_data_sym
block|,
name|mmo_abs_sym
block|}
enum|;
end_enum

begin_comment
comment|/* When scanning the mmo file, a linked list of mmo_symbol    structures is built to represent the symbol table (if there is    one).  */
end_comment

begin_struct
struct|struct
name|mmo_symbol
block|{
name|struct
name|mmo_symbol
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|enum
name|mmo_sym_type
name|sym_type
decl_stmt|;
name|unsigned
name|int
name|serno
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mmo_data_list_struct
block|{
name|struct
name|mmo_data_list_struct
modifier|*
name|next
decl_stmt|;
name|bfd_vma
name|where
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_size_type
name|allocated_size
decl_stmt|;
name|bfd_byte
name|data
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|mmo_data_list_struct
name|mmo_data_list_type
typedef|;
end_typedef

begin_struct
struct|struct
name|mmo_symbol_trie
block|{
name|struct
name|mmo_symbol_trie
modifier|*
name|left
decl_stmt|;
name|struct
name|mmo_symbol_trie
modifier|*
name|right
decl_stmt|;
name|struct
name|mmo_symbol_trie
modifier|*
name|middle
decl_stmt|;
name|bfd_byte
name|symchar
decl_stmt|;
comment|/* A zero name means there's nothing here.  */
name|struct
name|mmo_symbol
name|sym
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The mmo tdata information.  */
end_comment

begin_struct
struct|struct
name|mmo_data_struct
block|{
name|struct
name|mmo_symbol
modifier|*
name|symbols
decl_stmt|;
name|struct
name|mmo_symbol
modifier|*
name|symtail
decl_stmt|;
name|asymbol
modifier|*
name|csymbols
decl_stmt|;
comment|/* File representation of time (NULL) when this file was created.  */
name|bfd_byte
name|created
index|[
literal|4
index|]
decl_stmt|;
comment|/* When we're reading bytes recursively, check this occasionally.        Also holds write errors.  */
name|bfd_boolean
name|have_error
decl_stmt|;
comment|/* Max symbol length that may appear in the lop_stab table.  Note that        this table might just hold a subset of symbols for not-really large        programs, as it can only be 65536 * 4 bytes large.  */
name|int
name|max_symbol_length
decl_stmt|;
comment|/* Here's the symbol we build in lop_stab.  */
name|char
modifier|*
name|lop_stab_symbol
decl_stmt|;
comment|/* Index into lop_stab_symbol for the next character when parsing the        symbol information.  */
name|int
name|symbol_position
decl_stmt|;
comment|/* When creating arbitrary sections, we need to count section numbers.  */
name|int
name|sec_no
decl_stmt|;
comment|/* When writing or reading byte-wise, we need to count the bytes        within a 32-bit word.  */
name|int
name|byte_no
decl_stmt|;
comment|/* We also need a buffer to hold the bytes we count reading or writing.  */
name|bfd_byte
name|buf
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|mmo_data_struct
name|tdata_type
typedef|;
end_typedef

begin_struct
struct|struct
name|mmo_section_data_struct
block|{
name|mmo_data_list_type
modifier|*
name|head
decl_stmt|;
name|mmo_data_list_type
modifier|*
name|tail
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|mmo_section_data
parameter_list|(
name|sec
parameter_list|)
define|\
value|((struct mmo_section_data_struct *) (sec)->used_by_bfd)
end_define

begin_comment
comment|/* These structures are used in bfd_map_over_sections constructs.  */
end_comment

begin_comment
comment|/* Used when writing out sections; all but the register contents section    which is stored in reg_section.  */
end_comment

begin_struct
struct|struct
name|mmo_write_sec_info
block|{
name|asection
modifier|*
name|reg_section
decl_stmt|;
name|bfd_boolean
name|retval
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Used when trying to find a section corresponding to addr.  */
end_comment

begin_struct
struct|struct
name|mmo_find_sec_info
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmo_bfd_copy_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmo_write_section_unless_reg_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmo_find_sec_w_addr
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmo_find_sec_w_addr_grow
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|mmo_make_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmo_get_symbol_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|symbol_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmo_print_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|asymbol
operator|*
operator|,
name|bfd_print_symbol_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmo_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmo_mkobject
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmo_scan
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|mmo_decide_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|mmo_get_generic_spec_data_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|mmo_get_spec_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|bfd_byte
modifier|*
name|mmo_get_loc
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmo_xore_64
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
name|bfd_vma
name|vma
operator|,
name|bfd_vma
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmo_xore_32
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
name|bfd_vma
name|vma
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmo_xore_16
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
name|bfd_vma
name|vma
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_target
modifier|*
name|mmo_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmo_map_set_sizes
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmo_get_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmo_create_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|bfd_vma
operator|,
expr|enum
name|mmo_sym_type
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmo_get_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|mmo_get_symtab_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|mmo_canonicalize_symtab
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmo_get_symbol_info
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|symbol_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmo_print_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|PTR
operator|,
name|asymbol
operator|*
operator|,
name|bfd_print_symbol_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmo_set_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
specifier|const
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mmo_sizeof_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|mmo_get_reloc_upper_bound
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmo_internal_write_header
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmo_internal_write_post
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|int
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmo_internal_add_3_sym
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|mmo_symbol_trie
operator|*
operator|,
specifier|const
expr|struct
name|mmo_symbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|mmo_internal_3_length
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|mmo_symbol_trie
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmo_internal_3_dump
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|mmo_symbol_trie
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmo_beb128_out
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmo_internal_write_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmo_write_tetra
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmo_write_tetra_raw
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmo_write_octa
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmo_write_octa_raw
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmo_write_chunk
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|bfd_byte
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmo_flush_chunk
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmo_write_loc_chunk
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_vma
operator|,
specifier|const
name|bfd_byte
operator|*
operator|,
name|unsigned
name|int
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmo_write_chunk_list
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|mmo_data_list_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmo_write_loc_chunk_list
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|mmo_data_list_type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmo_write_symbols_and_terminator
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flagword
name|mmo_sec_flags_from_bfd_flags
name|PARAMS
argument_list|(
operator|(
name|flagword
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|flagword
name|bfd_sec_flags_from_mmo_flags
name|PARAMS
argument_list|(
operator|(
name|flagword
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_byte
name|mmo_get_byte
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mmo_write_byte
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_byte
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmo_new_section_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mmo_sort_mmo_symbols
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|mmo_write_object_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|mmo_canonicalize_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
name|arelent
operator|*
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global "const" variables initialized once.  Must not depend on    particular input or caller; put such things into the bfd or elsewhere.    Look ma, no static per-invocation data!  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|valid_mmo_symbol_character_set
index|[
comment|/* A-Z a-z (we assume consecutive 				       codes; sorry EBCDIC:ers!).  */
operator|+
literal|'Z'
operator|-
literal|'A'
operator|+
literal|1
operator|+
literal|'z'
operator|-
literal|'a'
operator|+
literal|1
comment|/* Digits.  */
operator|+
literal|10
comment|/* ':' and '_'.  */
operator|+
literal|1
operator|+
literal|1
comment|/* Codes higher than 126.  */
operator|+
literal|256
operator|-
literal|126
comment|/* Ending zero.  */
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get section SECNAME or create one if it doesn't exist.  When creating    one, new memory for the name is allocated.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|mmo_make_section
parameter_list|(
name|abfd
parameter_list|,
name|secname
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|secname
decl_stmt|;
block|{
name|asection
modifier|*
name|sec
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|secname
argument_list|)
decl_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|newsecname
init|=
name|strdup
argument_list|(
name|secname
argument_list|)
decl_stmt|;
if|if
condition|(
name|newsecname
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: No core to allocate section name %s\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|secname
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sec
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|newsecname
argument_list|)
expr_stmt|;
block|}
return|return
name|sec
return|;
block|}
end_function

begin_comment
comment|/* Nothing to do, but keep as a placeholder if we need it.    Note that state that might differ between bfd:s must not be initialized    here, nor must it be static.  Add it to tdata information instead.  */
end_comment

begin_function
specifier|static
name|void
name|mmo_init
parameter_list|()
block|{
specifier|static
name|bfd_boolean
name|inited
init|=
name|FALSE
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|char
name|letters
index|[]
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789:_"
decl_stmt|;
if|if
condition|(
name|inited
condition|)
return|return;
name|inited
operator|=
name|TRUE
expr_stmt|;
comment|/* Fill in the set of valid symbol characters.  */
name|strcpy
argument_list|(
name|valid_mmo_symbol_character_set
argument_list|,
name|letters
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|letters
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|126
init|;
name|j
operator|<
literal|256
condition|;
name|j
operator|++
control|)
name|valid_mmo_symbol_character_set
index|[
name|i
operator|++
index|]
operator|=
name|j
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check whether an existing file is an mmo file.  */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|mmo_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|bfd_byte
name|b
index|[
literal|4
index|]
decl_stmt|;
name|mmo_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|bfd_stat
argument_list|(
name|abfd
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
operator|||
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|b
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
goto|goto
name|bad_final
goto|;
comment|/* All mmo files are a multiple of four bytes long.      Only recognize version one.  */
if|if
condition|(
operator|(
name|statbuf
operator|.
name|st_size
operator|%
literal|4
operator|)
operator|!=
literal|0
operator|||
name|b
index|[
literal|0
index|]
operator|!=
name|LOP
operator|||
name|b
index|[
literal|1
index|]
operator|!=
name|LOP_PRE
operator|||
name|b
index|[
literal|2
index|]
operator|!=
literal|1
condition|)
goto|goto
name|bad_format
goto|;
comment|/* Get the last 32-bit word.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
name|statbuf
operator|.
name|st_size
operator|-
literal|4
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
name|b
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
goto|goto
name|bad_final
goto|;
comment|/* Check if the file ends in a lop_end lopcode. */
if|if
condition|(
name|b
index|[
literal|0
index|]
operator|!=
name|LOP
operator|||
name|b
index|[
literal|1
index|]
operator|!=
name|LOP_END
operator|||
operator|!
name|mmo_mkobject
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|bad_format
goto|;
comment|/* Compute an upper bound on the max symbol length.  Not really      important as all of the symbol information can only be 256k.  */
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|max_symbol_length
operator|=
operator|(
name|b
index|[
literal|2
index|]
operator|*
literal|256
operator|+
name|b
index|[
literal|3
index|]
operator|)
operator|*
literal|4
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|lop_stab_symbol
operator|=
name|bfd_malloc
argument_list|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|max_symbol_length
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|lop_stab_symbol
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: No core to allocate a symbol %d bytes long\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|max_symbol_length
argument_list|)
expr_stmt|;
goto|goto
name|bad_final
goto|;
block|}
comment|/* Read in everything.  */
if|if
condition|(
operator|!
name|mmo_scan
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|bad_format_free
goto|;
if|if
condition|(
name|abfd
operator|->
name|symcount
operator|>
literal|0
condition|)
name|abfd
operator|->
name|flags
operator||=
name|HAS_SYMS
expr_stmt|;
comment|/* You'll have to tweak this if you want to use this format for other      arches (not recommended due to its small-size limitations).  Look at      the ELF format for how to make it target-generic.  */
if|if
condition|(
operator|!
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_mmix
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|bad_format_free
goto|;
return|return
name|abfd
operator|->
name|xvec
return|;
name|bad_format_free
label|:
name|free
argument_list|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|lop_stab_symbol
argument_list|)
expr_stmt|;
name|bad_format
label|:
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
name|bad_final
label|:
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set up the mmo tdata information.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mmo_mkobject
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|mmo_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|==
name|NULL
condition|)
block|{
name|time_t
name|created
decl_stmt|;
comment|/* All fields are zero-initialized, so we don't have to explicitly 	 initialize most.  */
name|tdata_type
modifier|*
name|tdata
init|=
operator|(
name|tdata_type
operator|*
operator|)
name|bfd_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tdata_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tdata
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|created
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|created
argument_list|,
name|tdata
operator|->
name|created
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|=
name|tdata
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|mmo_bfd_copy_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_mmo_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_mmo_flavour
condition|)
return|return
name|TRUE
return|;
comment|/* Copy the time the copied-from file was created.  If people want the      time the file was last *modified*, they have that in the normal file      information.  */
name|memcpy
argument_list|(
name|obfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|created
argument_list|,
name|ibfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|created
argument_list|,
sizeof|sizeof
argument_list|(
name|obfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|created
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Helper functions for mmo_decide_section, used through    bfd_map_over_sections.  */
end_comment

begin_function
specifier|static
name|void
name|mmo_find_sec_w_addr
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|p
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|mmo_find_sec_info
modifier|*
name|infop
init|=
operator|(
expr|struct
name|mmo_find_sec_info
operator|*
operator|)
name|p
decl_stmt|;
name|bfd_vma
name|vma
init|=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
decl_stmt|;
comment|/* Ignore sections that aren't loaded.  */
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
operator|(
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator|)
operator|)
operator|!=
operator|(
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator|)
condition|)
return|return;
if|if
condition|(
name|infop
operator|->
name|addr
operator|>=
name|vma
operator|&&
name|infop
operator|->
name|addr
operator|<
name|vma
operator|+
name|sec
operator|->
name|_raw_size
condition|)
name|infop
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mmo_find_sec_w_addr_grow
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|p
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|mmo_find_sec_info
modifier|*
name|infop
init|=
operator|(
expr|struct
name|mmo_find_sec_info
operator|*
operator|)
name|p
decl_stmt|;
name|bfd_vma
name|vma
init|=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
decl_stmt|;
comment|/* Ignore sections that aren't loaded.  */
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
operator|(
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator|)
operator|)
operator|!=
operator|(
name|SEC_LOAD
operator||
name|SEC_ALLOC
operator|)
condition|)
return|return;
if|if
condition|(
name|infop
operator|->
name|addr
operator|>=
name|vma
operator|&&
name|infop
operator|->
name|addr
operator|<
name|vma
operator|+
name|MAX_ARTIFICIAL_SECTION_SIZE
condition|)
name|infop
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find a section that corresponds to a VMA.  Automatically create .text    or .data and set current section to it, depending on what vma.  If we    can't deduce a section, make one up as ".MMIX.sec.N", where N is an    increasing number.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|mmo_decide_section
parameter_list|(
name|abfd
parameter_list|,
name|vma
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
block|{
name|asection
modifier|*
name|sec
init|=
name|NULL
decl_stmt|;
name|char
name|sec_name
index|[
sizeof|sizeof
argument_list|(
literal|".MMIX.sec."
argument_list|)
operator|+
literal|20
index|]
decl_stmt|;
name|struct
name|mmo_find_sec_info
name|info
decl_stmt|;
name|info
operator|.
name|addr
operator|=
name|vma
expr_stmt|;
name|info
operator|.
name|sec
operator|=
name|NULL
expr_stmt|;
comment|/* First see if there's a section that would match exactly.  */
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|mmo_find_sec_w_addr
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|sec
operator|!=
name|NULL
condition|)
return|return
name|info
operator|.
name|sec
return|;
comment|/* If there's no such section, try and expand one of the existing ones,      up to a limit.  Make sure we have .text and .data before we try that;      create them corresponding to expected addresses and set flags to make      them match the "loaded and with contents" expectation.  */
if|if
condition|(
operator|(
name|vma
operator|>>
literal|56
operator|)
operator|==
literal|0
condition|)
block|{
name|sec
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
name|MMO_TEXT_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|sec
operator|->
name|user_set_vma
condition|)
name|bfd_set_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|vma
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator||
name|SEC_CODE
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|vma
operator|>>
literal|56
operator|)
operator|==
literal|0x20
condition|)
block|{
name|sec
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
name|MMO_DATA_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|sec
operator|->
name|user_set_vma
condition|)
name|bfd_set_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|vma
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|mmo_find_sec_w_addr_grow
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|sec
operator|!=
name|NULL
condition|)
return|return
name|info
operator|.
name|sec
return|;
comment|/* If there's still no suitable section, make a new one.  */
name|sprintf
argument_list|(
name|sec_name
argument_list|,
literal|".MMIX.sec.%d"
argument_list|,
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|sec_no
operator|++
argument_list|)
expr_stmt|;
name|sec
operator|=
name|mmo_make_section
argument_list|(
name|abfd
argument_list|,
name|sec_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sec
operator|->
name|user_set_vma
condition|)
name|bfd_set_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|vma
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|sec
return|;
block|}
end_function

begin_comment
comment|/* Xor in a 64-bit value VALUE at VMA.  */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|mmo_xore_64
parameter_list|(
name|sec
parameter_list|,
name|vma
parameter_list|,
name|value
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
name|bfd_byte
modifier|*
name|loc
init|=
name|mmo_get_loc
argument_list|(
name|sec
argument_list|,
name|vma
argument_list|,
literal|8
argument_list|)
decl_stmt|;
name|bfd_vma
name|prev
init|=
name|bfd_get_64
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|loc
argument_list|)
decl_stmt|;
name|value
operator|^=
name|prev
expr_stmt|;
name|bfd_put_64
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|value
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Xor in a 32-bit value VALUE at VMA.  */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|mmo_xore_32
parameter_list|(
name|sec
parameter_list|,
name|vma
parameter_list|,
name|value
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
name|unsigned
name|int
name|value
decl_stmt|;
block|{
name|bfd_byte
modifier|*
name|loc
init|=
name|mmo_get_loc
argument_list|(
name|sec
argument_list|,
name|vma
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|prev
init|=
name|bfd_get_32
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|loc
argument_list|)
decl_stmt|;
name|value
operator|^=
name|prev
expr_stmt|;
name|bfd_put_32
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|value
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Xor in a 16-bit value VALUE at VMA.  */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|mmo_xore_16
parameter_list|(
name|sec
parameter_list|,
name|vma
parameter_list|,
name|value
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
name|unsigned
name|int
name|value
decl_stmt|;
block|{
name|bfd_byte
modifier|*
name|loc
init|=
name|mmo_get_loc
argument_list|(
name|sec
argument_list|,
name|vma
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|prev
init|=
name|bfd_get_16
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|loc
argument_list|)
decl_stmt|;
name|value
operator|^=
name|prev
expr_stmt|;
name|bfd_put_16
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|value
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write a 32-bit word to output file, no lop_quote generated.  */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|mmo_write_tetra_raw
parameter_list|(
name|abfd
parameter_list|,
name|value
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|value
decl_stmt|;
block|{
name|bfd_byte
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|have_error
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write a 32-bit word to output file; lop_quote if necessary.  */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|mmo_write_tetra
parameter_list|(
name|abfd
parameter_list|,
name|value
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|value
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|(
name|value
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
operator|==
name|LOP
condition|)
name|mmo_write_tetra_raw
argument_list|(
name|abfd
argument_list|,
name|LOP_QUOTE_NEXT
argument_list|)
expr_stmt|;
name|mmo_write_tetra_raw
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write a 64-bit word to output file, perhaps with lop_quoting.  */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|mmo_write_octa
parameter_list|(
name|abfd
parameter_list|,
name|value
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
name|mmo_write_tetra
argument_list|(
name|abfd
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|value
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|mmo_write_tetra
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write a 64-bit word to output file, without lop_quoting.  */
end_comment

begin_function
specifier|static
name|INLINE
name|void
name|mmo_write_octa_raw
parameter_list|(
name|abfd
parameter_list|,
name|value
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
name|mmo_write_tetra_raw
argument_list|(
name|abfd
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|value
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|mmo_write_tetra_raw
argument_list|(
name|abfd
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write quoted contents.  Intended to be called multiple times in    sequence, followed by a call to mmo_flush_chunk.  */
end_comment

begin_function
specifier|static
name|INLINE
name|bfd_boolean
name|mmo_write_chunk
parameter_list|(
name|abfd
parameter_list|,
name|loc
parameter_list|,
name|len
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
block|{
name|bfd_boolean
name|retval
init|=
name|TRUE
decl_stmt|;
comment|/* Fill up a tetra from bytes remaining from a previous chunk.  */
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|byte_no
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|byte_no
operator|<
literal|4
operator|&&
name|len
operator|!=
literal|0
condition|)
block|{
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|buf
index|[
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|byte_no
operator|++
index|]
operator|=
operator|*
name|loc
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|byte_no
operator|==
literal|4
condition|)
block|{
name|mmo_write_tetra
argument_list|(
name|abfd
argument_list|,
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|byte_no
operator|=
literal|0
expr_stmt|;
block|}
block|}
while|while
condition|(
name|len
operator|>=
literal|4
condition|)
block|{
if|if
condition|(
name|loc
index|[
literal|0
index|]
operator|==
name|LOP
condition|)
name|mmo_write_tetra_raw
argument_list|(
name|abfd
argument_list|,
name|LOP_QUOTE_NEXT
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|retval
operator|&&
operator|!
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|have_error
operator|&&
literal|4
operator|==
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|loc
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|)
expr_stmt|;
name|loc
operator|+=
literal|4
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
block|{
name|memcpy
argument_list|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|buf
argument_list|,
name|loc
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|byte_no
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|retval
condition|)
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|have_error
operator|=
name|TRUE
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Flush remaining bytes, from a previous mmo_write_chunk, zero-padded to    4 bytes.  */
end_comment

begin_function
specifier|static
name|INLINE
name|bfd_boolean
name|mmo_flush_chunk
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|byte_no
operator|!=
literal|0
condition|)
block|{
name|memset
argument_list|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|buf
operator|+
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|byte_no
argument_list|,
literal|0
argument_list|,
literal|4
operator|-
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|byte_no
argument_list|)
expr_stmt|;
name|mmo_write_tetra
argument_list|(
name|abfd
argument_list|,
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|byte_no
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|!
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|have_error
return|;
block|}
end_function

begin_comment
comment|/* Same, but from a list.  */
end_comment

begin_function
specifier|static
name|INLINE
name|bfd_boolean
name|mmo_write_chunk_list
parameter_list|(
name|abfd
parameter_list|,
name|datap
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|mmo_data_list_type
modifier|*
name|datap
decl_stmt|;
block|{
for|for
control|(
init|;
name|datap
operator|!=
name|NULL
condition|;
name|datap
operator|=
name|datap
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|mmo_write_chunk
argument_list|(
name|abfd
argument_list|,
name|datap
operator|->
name|data
argument_list|,
name|datap
operator|->
name|size
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|mmo_flush_chunk
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write a lop_loc and some contents.  A caller needs to call    mmo_flush_chunk after calling this function.  The location is only    output if different than *LAST_VMAP, which is updated after this call.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mmo_write_loc_chunk
parameter_list|(
name|abfd
parameter_list|,
name|vma
parameter_list|,
name|loc
parameter_list|,
name|len
parameter_list|,
name|last_vmap
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
specifier|const
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|bfd_vma
modifier|*
name|last_vmap
decl_stmt|;
block|{
comment|/* Find an initial and trailing section of zero tetras; we don't need to      write out zeros.  FIXME: When we do this, we should emit section size      and address specifiers, else objcopy can't always perform an identity      translation.  Only do this if we *don't* have left-over data from a      previous write or the vma of this chunk is *not* the next address,      because then data isn't tetrabyte-aligned and we're concatenating to      that left-over data.  */
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|byte_no
operator|==
literal|0
operator|||
name|vma
operator|!=
operator|*
name|last_vmap
condition|)
block|{
while|while
condition|(
name|len
operator|>=
literal|4
operator|&&
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|loc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vma
operator|+=
literal|4
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
name|loc
operator|+=
literal|4
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|>=
literal|4
operator|&&
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|loc
operator|+
name|len
operator|-
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|len
operator|-=
literal|4
expr_stmt|;
block|}
comment|/* Only write out the location if it's different than the one the caller      (supposedly) previously handled, accounting for omitted leading zeros.  */
if|if
condition|(
name|vma
operator|!=
operator|*
name|last_vmap
condition|)
block|{
comment|/* We might be in the middle of a sequence.  */
name|mmo_flush_chunk
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* We always write the location as 64 bits; no use saving bytes          here.  */
name|mmo_write_tetra_raw
argument_list|(
name|abfd
argument_list|,
operator|(
name|LOP
operator|<<
literal|24
operator|)
operator||
operator|(
name|LOP_LOC
operator|<<
literal|16
operator|)
operator||
literal|2
argument_list|)
expr_stmt|;
name|mmo_write_octa_raw
argument_list|(
name|abfd
argument_list|,
name|vma
argument_list|)
expr_stmt|;
block|}
comment|/* Update to reflect end of this chunk, with trailing zeros omitted.  */
operator|*
name|last_vmap
operator|=
name|vma
operator|+
name|len
expr_stmt|;
return|return
operator|(
operator|!
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|have_error
operator|&&
name|mmo_write_chunk
argument_list|(
name|abfd
argument_list|,
name|loc
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Same, but from a list.  */
end_comment

begin_function
specifier|static
name|INLINE
name|bfd_boolean
name|mmo_write_loc_chunk_list
parameter_list|(
name|abfd
parameter_list|,
name|datap
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|mmo_data_list_type
modifier|*
name|datap
decl_stmt|;
block|{
comment|/* Get an address different than the address of the first chunk.  */
name|bfd_vma
name|last_vma
init|=
name|datap
condition|?
name|datap
operator|->
name|where
operator|-
literal|1
else|:
literal|0
decl_stmt|;
for|for
control|(
init|;
name|datap
operator|!=
name|NULL
condition|;
name|datap
operator|=
name|datap
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|mmo_write_loc_chunk
argument_list|(
name|abfd
argument_list|,
name|datap
operator|->
name|where
argument_list|,
name|datap
operator|->
name|data
argument_list|,
name|datap
operator|->
name|size
argument_list|,
operator|&
name|last_vma
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|mmo_flush_chunk
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make a .MMIX.spec_data.N section.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|mmo_get_generic_spec_data_section
parameter_list|(
name|abfd
parameter_list|,
name|spec_data_number
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|spec_data_number
decl_stmt|;
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|char
name|secname
index|[
sizeof|sizeof
argument_list|(
name|MMIX_OTHER_SPEC_SECTION_PREFIX
argument_list|)
operator|+
literal|20
index|]
init|=
name|MMIX_OTHER_SPEC_SECTION_PREFIX
decl_stmt|;
name|sprintf
argument_list|(
name|secname
operator|+
name|strlen
argument_list|(
name|MMIX_OTHER_SPEC_SECTION_PREFIX
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|spec_data_number
argument_list|)
expr_stmt|;
name|sec
operator|=
name|mmo_make_section
argument_list|(
name|abfd
argument_list|,
name|secname
argument_list|)
expr_stmt|;
return|return
name|sec
return|;
block|}
end_function

begin_comment
comment|/* Make a special section for SPEC_DATA_NUMBER.  If it is the one we use    ourselves, parse some of its data to get at the section name.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|mmo_get_spec_section
parameter_list|(
name|abfd
parameter_list|,
name|spec_data_number
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|spec_data_number
decl_stmt|;
block|{
name|bfd_byte
modifier|*
name|secname
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_byte
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|int
name|secname_length
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bfd_vma
name|section_length
decl_stmt|;
name|bfd_vma
name|section_vma
decl_stmt|;
name|mmo_data_list_type
modifier|*
name|loc
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|long
name|orig_pos
decl_stmt|;
comment|/* If this isn't the "special" special data, then make a placeholder      section.  */
if|if
condition|(
name|spec_data_number
operator|!=
name|SPEC_DATA_SECTION
condition|)
return|return
name|mmo_get_generic_spec_data_section
argument_list|(
name|abfd
argument_list|,
name|spec_data_number
argument_list|)
return|;
comment|/* Seek back to this position if there was a format error.  */
name|orig_pos
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Read the length (in 32-bit words).  */
if|if
condition|(
name|bfd_bread
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
goto|goto
name|format_error
goto|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
name|LOP
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|!=
name|LOP_QUOTE
condition|)
goto|goto
name|format_error
goto|;
if|if
condition|(
name|bfd_bread
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
goto|goto
name|format_error
goto|;
block|}
comment|/* We don't care to keep the name length accurate.  It's      zero-terminated.  */
name|secname_length
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
operator|*
literal|4
expr_stmt|;
comment|/* Check section name length for sanity.  */
if|if
condition|(
name|secname_length
operator|>
name|MAX_SECTION_NAME_SIZE
condition|)
goto|goto
name|format_error
goto|;
comment|/* This should be free'd regardless if a section is created.  */
name|secname
operator|=
name|bfd_malloc
argument_list|(
name|secname_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|secname
index|[
name|secname_length
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|secname_length
operator|/
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bfd_bread
argument_list|(
name|secname
operator|+
name|i
operator|*
literal|4
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
goto|goto
name|format_error_free
goto|;
if|if
condition|(
name|secname
index|[
name|i
operator|*
literal|4
index|]
operator|==
name|LOP
condition|)
block|{
comment|/* A bit of overkill, but we handle char 0x98 in a section name, 	     and recognize misparsing.  */
if|if
condition|(
name|secname
index|[
name|i
operator|*
literal|4
operator|+
literal|1
index|]
operator|!=
name|LOP_QUOTE
operator|||
name|bfd_bread
argument_list|(
name|secname
operator|+
name|i
operator|*
literal|4
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
comment|/* Whoops.  We thought this was a name, and now we found a 	       non-lop_quote lopcode before we parsed the whole length of 	       the name.  Signal end-of-file in the same manner.  */
goto|goto
name|format_error_free
goto|;
block|}
block|}
comment|/* Get the section flags.  */
if|if
condition|(
name|bfd_bread
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
operator|||
operator|(
name|buf
index|[
literal|0
index|]
operator|==
name|LOP
operator|&&
operator|(
name|buf
index|[
literal|1
index|]
operator|!=
name|LOP_QUOTE
operator|||
name|bfd_bread
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
operator|)
operator|)
condition|)
goto|goto
name|format_error_free
goto|;
name|flags
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Get the section length.  */
if|if
condition|(
name|bfd_bread
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
operator|||
operator|(
name|buf
index|[
literal|0
index|]
operator|==
name|LOP
operator|&&
operator|(
name|buf
index|[
literal|1
index|]
operator|!=
name|LOP_QUOTE
operator|||
name|bfd_bread
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
operator|)
operator|)
condition|)
goto|goto
name|format_error_free
goto|;
name|section_length
operator|=
operator|(
name|bfd_vma
operator|)
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
operator|<<
literal|32
expr_stmt|;
comment|/* That's the first, high-part.  Now get the low part.  */
if|if
condition|(
name|bfd_bread
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
operator|||
operator|(
name|buf
index|[
literal|0
index|]
operator|==
name|LOP
operator|&&
operator|(
name|buf
index|[
literal|1
index|]
operator|!=
name|LOP_QUOTE
operator|||
name|bfd_bread
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
operator|)
operator|)
condition|)
goto|goto
name|format_error_free
goto|;
name|section_length
operator||=
operator|(
name|bfd_vma
operator|)
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Check the section length for sanity.  */
if|if
condition|(
name|section_length
operator|>
name|MAX_ARTIFICIAL_SECTION_SIZE
condition|)
goto|goto
name|format_error_free
goto|;
comment|/* Get the section VMA.  */
if|if
condition|(
name|bfd_bread
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
operator|||
operator|(
name|buf
index|[
literal|0
index|]
operator|==
name|LOP
operator|&&
operator|(
name|buf
index|[
literal|1
index|]
operator|!=
name|LOP_QUOTE
operator|||
name|bfd_bread
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
operator|)
operator|)
condition|)
goto|goto
name|format_error_free
goto|;
name|section_vma
operator|=
operator|(
name|bfd_vma
operator|)
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
operator|<<
literal|32
expr_stmt|;
comment|/* That's the first, high-part.  Now get the low part.  */
if|if
condition|(
name|bfd_bread
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
operator|||
operator|(
name|buf
index|[
literal|0
index|]
operator|==
name|LOP
operator|&&
operator|(
name|buf
index|[
literal|1
index|]
operator|!=
name|LOP_QUOTE
operator|||
name|bfd_bread
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
operator|)
operator|)
condition|)
goto|goto
name|format_error_free
goto|;
name|section_vma
operator||=
operator|(
name|bfd_vma
operator|)
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|sec
operator|=
name|mmo_make_section
argument_list|(
name|abfd
argument_list|,
name|secname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|secname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
goto|goto
name|format_error
goto|;
comment|/* We allocate a buffer here for the advertised size, with head room for      tetrabyte alignment.  */
name|loc
operator|=
name|bfd_zmalloc
argument_list|(
name|section_length
operator|+
literal|3
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mmo_data_list_struct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|==
name|NULL
condition|)
goto|goto
name|format_error
goto|;
comment|/* Use a TETRA-rounded size for the allocated buffer; we set the      "visible" section size below.  */
name|loc
operator|->
name|size
operator|=
operator|(
name|section_length
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* Add in the section flags we found to those bfd entered during this      process and set the contents.  */
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|bfd_sec_flags_from_mmo_flags
argument_list|(
name|flags
argument_list|)
operator||
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator||
operator|(
name|section_length
operator|!=
literal|0
condition|?
name|SEC_HAS_CONTENTS
else|:
literal|0
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|sec
operator|->
name|_cooked_size
operator|+
name|section_length
argument_list|)
comment|/* Set VMA only for the first occurrence.  */
operator|||
operator|(
operator|!
name|sec
operator|->
name|user_set_vma
operator|&&
operator|!
name|bfd_set_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|section_vma
argument_list|)
operator|)
condition|)
block|{
comment|/* If we get an error for any of the calls above, signal more than 	 just a format error for the spec section.  */
return|return
name|NULL
return|;
block|}
name|loc
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mmo_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|tail
operator|!=
name|NULL
condition|)
name|mmo_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|tail
operator|->
name|next
operator|=
name|loc
expr_stmt|;
else|else
name|mmo_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|head
operator|=
name|loc
expr_stmt|;
name|mmo_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|tail
operator|=
name|loc
expr_stmt|;
name|loc
operator|->
name|where
operator|=
name|section_vma
expr_stmt|;
return|return
name|sec
return|;
name|format_error_free
label|:
name|free
argument_list|(
name|secname
argument_list|)
expr_stmt|;
name|format_error
label|:
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|orig_pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|mmo_get_generic_spec_data_section
argument_list|(
name|abfd
argument_list|,
name|spec_data_number
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read a byte, but read from file in multiples of 32-bit words.  */
end_comment

begin_function
specifier|static
name|bfd_byte
name|mmo_get_byte
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|bfd_byte
name|retval
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|byte_no
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|have_error
operator|&&
name|bfd_bread
argument_list|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
block|{
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|have_error
operator|=
name|TRUE
expr_stmt|;
comment|/* A value somewhat safe against tripping on some inconsistency 	     when mopping up after this error.  */
return|return
literal|128
return|;
block|}
block|}
name|retval
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|buf
index|[
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|byte_no
index|]
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|byte_no
operator|=
operator|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|byte_no
operator|+
literal|1
operator|)
operator|%
literal|4
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Write a byte, in multiples of 32-bit words.  */
end_comment

begin_function
specifier|static
name|void
name|mmo_write_byte
parameter_list|(
name|abfd
parameter_list|,
name|value
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_byte
name|value
decl_stmt|;
block|{
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|buf
index|[
operator|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|byte_no
operator|++
operator|%
literal|4
operator|)
index|]
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|byte_no
operator|%
literal|4
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|have_error
operator|&&
name|bfd_bwrite
argument_list|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|have_error
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create a symbol.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mmo_create_symbol
parameter_list|(
name|abfd
parameter_list|,
name|symname
parameter_list|,
name|addr
parameter_list|,
name|sym_type
parameter_list|,
name|serno
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|symname
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|enum
name|mmo_sym_type
name|sym_type
decl_stmt|;
name|unsigned
name|int
name|serno
decl_stmt|;
block|{
name|struct
name|mmo_symbol
modifier|*
name|n
decl_stmt|;
name|n
operator|=
operator|(
expr|struct
name|mmo_symbol
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mmo_symbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|n
operator|->
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|strlen
argument_list|(
name|symname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|name
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|strcpy
argument_list|(
operator|(
name|PTR
operator|)
name|n
operator|->
name|name
argument_list|,
name|symname
argument_list|)
expr_stmt|;
name|n
operator|->
name|value
operator|=
name|addr
expr_stmt|;
name|n
operator|->
name|sym_type
operator|=
name|sym_type
expr_stmt|;
name|n
operator|->
name|serno
operator|=
name|serno
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|symbols
operator|==
name|NULL
condition|)
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|symbols
operator|=
name|n
expr_stmt|;
else|else
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|symtail
operator|->
name|next
operator|=
name|n
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|symtail
operator|=
name|n
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|++
name|abfd
operator|->
name|symcount
expr_stmt|;
comment|/* Check that :Main equals the last octa of the .MMIX.reg_contents      section, as it's the one place we're sure to pass when reading a mmo      object.  For written objects, we do it while setting the symbol      table.  */
if|if
condition|(
name|strcmp
argument_list|(
name|symname
argument_list|,
name|MMIX_START_SYMBOL_NAME
argument_list|)
operator|==
literal|0
operator|&&
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
operator|!=
name|addr
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: invalid mmo file: initialization value for $255 is not `Main'\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Read in symbols.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mmo_get_symbols
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
comment|/* INODE Symbol-table, mmo section mapping, File layout, mmo SUBSECTION 	Symbol table format  	From mmixal.w (or really, the generated mmixal.tex) in 	@url{http://www-cs-faculty.stanford.edu/~knuth/programs/mmix.tar.gz}): 	``Symbols are stored and retrieved by means of a @samp{ternary 	search trie}, following ideas of Bentley and Sedgewick. (See 	ACM--SIAM Symp.@: on Discrete Algorithms @samp{8} (1997), 360--369; 	R.@:Sedgewick, @samp{Algorithms in C} (Reading, Mass.@: 	Addison--Wesley, 1998), @samp{15.4}.)  Each trie node stores a 	character, and there are branches to subtries for the cases where 	a given character is less than, equal to, or greater than the 	character in the trie.  There also is a pointer to a symbol table 	entry if a symbol ends at the current node.''  	So it's a tree encoded as a stream of bytes.  The stream of bytes 	acts on a single virtual global symbol, adding and removing 	characters and signalling complete symbol points.  Here, we read 	the stream and create symbols at the completion points.  	First, there's a control byte<<m>>.  If any of the listed bits 	in<<m>> is nonzero, we execute what stands at the right, in 	the listed order:  | (MMO3_LEFT) | 0x40 - Traverse left trie. |        (Read a new command byte and recurse.) | | (MMO3_SYMBITS) | 0x2f - Read the next byte as a character and store it in the |        current character position; increment character position. |        Test the bits of<<m>>: | |        (MMO3_WCHAR) |        0x80 - The character is 16-bit (so read another byte, |               merge into current character. | |        (MMO3_TYPEBITS) |        0xf  - We have a complete symbol; parse the type, value |               and serial number and do what should be done |               with a symbol.  The type and length information |               is in j = (m& 0xf). | |               (MMO3_REGQUAL_BITS) |	        j == 0xf: A register variable.  The following |                         byte tells which register. |               j<= 8:   An absolute symbol.  Read j bytes as the |                         big-endian number the symbol equals. |                         A j = 2 with two zero bytes denotes an |                         unknown symbol. |               j> 8:    As with j<= 8, but add (0x20<< 56) |                         to the value in the following j - 8 |                         bytes. | |               Then comes the serial number, as a variant of |               uleb128, but better named ubeb128: |               Read bytes and shift the previous value left 7 |               (multiply by 128).  Add in the new byte, repeat |               until a byte has bit 7 set.  The serial number |               is the computed value minus 128. | |        (MMO3_MIDDLE) |        0x20 - Traverse middle trie.  (Read a new command byte |               and recurse.)  Decrement character position. | | (MMO3_RIGHT) | 0x10 - Traverse right trie.  (Read a new command byte and |        recurse.)  	Let's look again at the<<lop_stab>> for the trivial file 	(@pxref{File layout}).  | 0x980b0000 - lop_stab for ":Main" = 0, serial 1. | 0x203a4040 | 0x10404020 | 0x4d206120 | 0x69016e00 | 0x81000000  	This forms the trivial trie (note that the path between ``:'' and 	``M'' is redundant):  | 203a	   ":" | 40       / | 40      / | 10      \ | 40      / | 40     / | 204d  "M" | 2061  "a" | 2069  "i" | 016e  "n" is the last character in a full symbol, and |       with a value represented in one byte. | 00    The value is 0. | 81    The serial number is 1.  */
name|bfd_byte
name|m
init|=
name|mmo_get_byte
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
comment|/* Check first if we have a bad hair day.  */
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|have_error
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|m
operator|&
name|MMO3_LEFT
condition|)
comment|/* Traverse left trie. */
name|mmo_get_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|&
name|MMO3_SYMBITS
condition|)
block|{
name|bfd_byte
name|c
init|=
name|mmo_get_byte
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|bfd_byte
name|j
init|=
name|m
operator|&
name|MMO3_TYPEBITS
decl_stmt|;
name|bfd_vma
name|addr
init|=
literal|0
decl_stmt|;
name|enum
name|mmo_sym_type
name|sym_type
decl_stmt|;
name|unsigned
name|int
name|serno
init|=
literal|0
decl_stmt|;
name|bfd_byte
name|k
decl_stmt|;
if|if
condition|(
name|m
operator|&
name|MMO3_WCHAR
condition|)
block|{
name|bfd_byte
name|c2
init|=
name|mmo_get_byte
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
comment|/* A two-byte character.  We can't grok this, but neither can 	     mmotype, for other cases than the second byte being zero.  */
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
block|{
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|lop_stab_symbol
index|[
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|symbol_position
index|]
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: unsupported wide character sequence\  0x%02X 0x%02X after symbol name starting with `%s'\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|c
argument_list|,
name|c2
argument_list|,
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|lop_stab_symbol
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|have_error
operator|=
name|TRUE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
name|c
operator|=
name|c2
expr_stmt|;
block|}
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|lop_stab_symbol
index|[
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|symbol_position
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|lop_stab_symbol
index|[
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|symbol_position
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|j
operator|&
name|MMO3_REGQUAL_BITS
condition|)
block|{
if|if
condition|(
name|j
operator|==
name|MMO3_REGQUAL_BITS
condition|)
block|{
name|sym_type
operator|=
name|mmo_reg_sym
expr_stmt|;
name|addr
operator|=
name|mmo_get_byte
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j
operator|<=
literal|8
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
name|addr
operator|=
operator|(
name|addr
operator|<<
literal|8
operator|)
operator|+
name|mmo_get_byte
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
operator|&&
name|j
operator|==
name|MMO3_UNDEF
condition|)
name|sym_type
operator|=
name|mmo_undef_sym
expr_stmt|;
else|else
name|sym_type
operator|=
name|mmo_abs_sym
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|MMO3_DATA
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
name|addr
operator|=
operator|(
name|addr
operator|<<
literal|8
operator|)
operator|+
name|mmo_get_byte
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|addr
operator|+=
operator|(
name|bfd_vma
operator|)
literal|0x20
operator|<<
literal|56
expr_stmt|;
name|sym_type
operator|=
name|mmo_data_sym
expr_stmt|;
block|}
comment|/* Get the serial number.  */
do|do
block|{
name|k
operator|=
name|mmo_get_byte
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|serno
operator|=
operator|(
name|serno
operator|<<
literal|7
operator|)
operator|+
name|k
expr_stmt|;
block|}
do|while
condition|(
name|k
operator|<
literal|128
condition|)
do|;
name|serno
operator|-=
literal|128
expr_stmt|;
comment|/* Got it.  Now enter it.  Skip a leading ":".  */
if|if
condition|(
operator|!
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|have_error
operator|&&
operator|!
name|mmo_create_symbol
argument_list|(
name|abfd
argument_list|,
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|lop_stab_symbol
operator|+
literal|1
argument_list|,
name|addr
argument_list|,
name|sym_type
argument_list|,
name|serno
argument_list|)
condition|)
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|have_error
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|&
name|MMO3_MIDDLE
condition|)
comment|/* Traverse middle trie. */
name|mmo_get_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|symbol_position
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|&
name|MMO3_RIGHT
condition|)
comment|/* Traverse right trie.  */
name|mmo_get_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
operator|!
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|have_error
return|;
block|}
end_function

begin_comment
comment|/* Get the location of memory area [VMA..VMA + SIZE - 1], which we think    is in section SEC.  Adjust and reallocate zero-initialized contents.    If there's new contents, allocate to the next multiple of    MMO_SEC_CONTENTS_CHUNK_SIZE.  */
end_comment

begin_function
specifier|static
name|INLINE
name|bfd_byte
modifier|*
name|mmo_get_loc
parameter_list|(
name|sec
parameter_list|,
name|vma
parameter_list|,
name|size
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|bfd_size_type
name|allocated_size
decl_stmt|;
name|struct
name|mmo_section_data_struct
modifier|*
name|sdatap
init|=
name|mmo_section_data
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|struct
name|mmo_data_list_struct
modifier|*
name|datap
init|=
name|sdatap
operator|->
name|head
decl_stmt|;
name|struct
name|mmo_data_list_struct
modifier|*
name|entry
decl_stmt|;
comment|/* First search the list to see if we have the requested chunk in one      piece, or perhaps if we have a suitable chunk with room to fit.  */
for|for
control|(
init|;
name|datap
operator|!=
name|NULL
condition|;
name|datap
operator|=
name|datap
operator|->
name|next
control|)
block|{
if|if
condition|(
name|datap
operator|->
name|where
operator|<=
name|vma
operator|&&
name|datap
operator|->
name|where
operator|+
name|datap
operator|->
name|size
operator|>=
name|vma
operator|+
name|size
condition|)
return|return
name|datap
operator|->
name|data
operator|+
name|vma
operator|-
name|datap
operator|->
name|where
return|;
elseif|else
if|if
condition|(
name|datap
operator|->
name|where
operator|<=
name|vma
operator|&&
name|datap
operator|->
name|where
operator|+
name|datap
operator|->
name|allocated_size
operator|>=
name|vma
operator|+
name|size
comment|/* Only munch on the "allocated size" if it does not 		  overlap the next chunk.  */
operator|&&
operator|(
name|datap
operator|->
name|next
operator|==
name|NULL
operator|||
name|datap
operator|->
name|next
operator|->
name|where
operator|>=
name|vma
operator|+
name|size
operator|)
condition|)
block|{
comment|/* There was room allocated, but the size wasn't set to include 	     it.  Do that now.  */
name|datap
operator|->
name|size
operator|+=
operator|(
name|vma
operator|+
name|size
operator|)
operator|-
operator|(
name|datap
operator|->
name|where
operator|+
name|datap
operator|->
name|size
operator|)
expr_stmt|;
comment|/* Update the section size.  This happens only if we update the 	     32-bit-aligned chunk size.  Callers that have 	     non-32-bit-aligned sections should do all allocation and 	     size-setting by themselves or at least set the section size 	     after the last allocating call to this function.  */
if|if
condition|(
name|vma
operator|+
name|size
operator|>
name|sec
operator|->
name|vma
operator|+
name|sec
operator|->
name|_raw_size
condition|)
name|sec
operator|->
name|_raw_size
operator|+=
operator|(
name|vma
operator|+
name|size
operator|)
operator|-
operator|(
name|sec
operator|->
name|vma
operator|+
name|sec
operator|->
name|_raw_size
operator|)
expr_stmt|;
return|return
name|datap
operator|->
name|data
operator|+
name|vma
operator|-
name|datap
operator|->
name|where
return|;
block|}
block|}
comment|/* Not found; allocate a new block.  First check in case we get a      request for a size split up over several blocks; we'll have to return      NULL for those cases, requesting the caller to split up the request.      Requests with an address aligned on MMO_SEC_CONTENTS_CHUNK_SIZE bytes and      for no more than MMO_SEC_CONTENTS_CHUNK_SIZE will always get resolved.  */
for|for
control|(
name|datap
operator|=
name|sdatap
operator|->
name|head
init|;
name|datap
operator|!=
name|NULL
condition|;
name|datap
operator|=
name|datap
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|datap
operator|->
name|where
operator|<=
name|vma
operator|&&
name|datap
operator|->
name|where
operator|+
name|datap
operator|->
name|size
operator|>
name|vma
operator|)
operator|||
operator|(
name|datap
operator|->
name|where
operator|<
name|vma
operator|+
name|size
operator|&&
name|datap
operator|->
name|where
operator|+
name|datap
operator|->
name|size
operator|>=
name|vma
operator|+
name|size
operator|)
condition|)
return|return
name|NULL
return|;
name|allocated_size
operator|=
operator|(
name|size
operator|+
name|MMO_SEC_CONTENTS_CHUNK_SIZE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|MMO_SEC_CONTENTS_CHUNK_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|entry
operator|=
operator|(
name|mmo_data_list_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
sizeof|sizeof
argument_list|(
name|mmo_data_list_type
argument_list|)
operator|+
name|allocated_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|entry
operator|->
name|where
operator|=
name|vma
expr_stmt|;
name|entry
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|entry
operator|->
name|allocated_size
operator|=
name|allocated_size
expr_stmt|;
name|datap
operator|=
name|sdatap
operator|->
name|head
expr_stmt|;
comment|/* Sort the records by address.  Optimize for the common case of adding      a record to the end of the list.  */
if|if
condition|(
name|sdatap
operator|->
name|tail
operator|!=
name|NULL
operator|&&
name|entry
operator|->
name|where
operator|>=
name|sdatap
operator|->
name|tail
operator|->
name|where
condition|)
block|{
name|sdatap
operator|->
name|tail
operator|->
name|next
operator|=
name|entry
expr_stmt|;
name|entry
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|sdatap
operator|->
name|tail
operator|=
name|entry
expr_stmt|;
block|}
else|else
block|{
name|mmo_data_list_type
modifier|*
modifier|*
name|look
decl_stmt|;
for|for
control|(
name|look
operator|=
operator|&
name|sdatap
operator|->
name|head
init|;
operator|*
name|look
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|look
operator|)
operator|->
name|where
operator|<
name|entry
operator|->
name|where
condition|;
name|look
operator|=
operator|&
operator|(
operator|*
name|look
operator|)
operator|->
name|next
control|)
empty_stmt|;
name|entry
operator|->
name|next
operator|=
operator|*
name|look
expr_stmt|;
operator|*
name|look
operator|=
name|entry
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|sdatap
operator|->
name|tail
operator|=
name|entry
expr_stmt|;
comment|/* We get here for the first time (at other times too) for this 	     section.  Say we have contents.  */
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|,
name|bfd_get_section_flags
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sec
argument_list|)
operator||
name|SEC_HAS_CONTENTS
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
block|}
comment|/* Update the section size.  This happens only when we add contents and      re-size as we go.  The section size will then be aligned to 32 bits.  */
if|if
condition|(
name|vma
operator|+
name|size
operator|>
name|sec
operator|->
name|vma
operator|+
name|sec
operator|->
name|_raw_size
condition|)
name|sec
operator|->
name|_raw_size
operator|+=
operator|(
name|vma
operator|+
name|size
operator|)
operator|-
operator|(
name|sec
operator|->
name|vma
operator|+
name|sec
operator|->
name|_raw_size
operator|)
expr_stmt|;
return|return
name|entry
operator|->
name|data
return|;
block|}
end_function

begin_comment
comment|/* Set sizes once we've read in all sections.  */
end_comment

begin_function
specifier|static
name|void
name|mmo_map_set_sizes
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|ignored
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|ignored
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|sec
operator|->
name|_cooked_size
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
name|sec
operator|->
name|lma
operator|=
name|sec
operator|->
name|vma
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read the mmo file and turn it into sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mmo_scan
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|lineno
init|=
literal|1
decl_stmt|;
name|bfd_boolean
name|error
init|=
name|FALSE
decl_stmt|;
name|bfd_vma
name|vma
init|=
literal|0
decl_stmt|;
name|asection
modifier|*
name|sec
init|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
name|MMO_TEXT_SECTION_NAME
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|non_spec_sec
init|=
name|NULL
decl_stmt|;
name|bfd_vma
name|non_spec_vma
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|current_filename
init|=
name|NULL
decl_stmt|;
name|bfd_size_type
name|nbytes_read
init|=
literal|0
decl_stmt|;
comment|/* Buffer with room to read a 64-bit value.  */
name|bfd_byte
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|long
name|stab_loc
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|file_names
index|[
literal|256
index|]
decl_stmt|;
name|memset
argument_list|(
name|file_names
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|file_names
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
while|while
condition|(
operator|(
name|nbytes_read
operator|=
name|bfd_bread
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|)
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
name|LOP
condition|)
block|{
name|unsigned
name|int
name|y
init|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|buf
operator|+
literal|2
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|z
init|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|buf
operator|+
literal|3
argument_list|)
decl_stmt|;
comment|/* Change back to the original section for lopcodes other 	     than LOP_QUOTE that comes after a LOP_SPEC.  */
if|if
condition|(
operator|(
name|buf
index|[
literal|1
index|]
operator|!=
name|LOP_QUOTE
operator|||
name|y
operator|!=
literal|0
operator|||
name|z
operator|!=
literal|1
operator|)
operator|&&
name|non_spec_sec
operator|!=
name|NULL
condition|)
block|{
name|sec
operator|=
name|non_spec_sec
expr_stmt|;
name|vma
operator|=
name|non_spec_vma
expr_stmt|;
name|non_spec_sec
operator|=
name|NULL
expr_stmt|;
block|}
switch|switch
condition|(
name|buf
index|[
literal|1
index|]
condition|)
block|{
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: invalid mmo file: unsupported lopcode `%d'\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
case|case
name|LOP_QUOTE
case|:
comment|/* Quote the next 32-bit word.  */
if|if
condition|(
name|y
operator|!=
literal|0
operator|||
name|z
operator|!=
literal|1
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: invalid mmo file: expected YZ = 1 got YZ = %d for lop_quote\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|y
operator|*
literal|256
operator|+
name|z
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|bfd_bread
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
goto|goto
name|error_return
goto|;
name|mmo_xore_32
argument_list|(
name|sec
argument_list|,
name|vma
argument_list|,
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|vma
operator|+=
literal|4
expr_stmt|;
name|vma
operator|&=
operator|~
literal|3
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
break|break;
case|case
name|LOP_LOC
case|:
comment|/* Set vma (and section).  */
name|vma
operator|=
operator|(
name|bfd_vma
operator|)
name|y
operator|<<
literal|56
expr_stmt|;
if|if
condition|(
name|z
operator|==
literal|1
condition|)
block|{
comment|/* Get a 32-bit value.  */
if|if
condition|(
name|bfd_bread
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
goto|goto
name|error_return
goto|;
name|vma
operator|+=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|z
operator|==
literal|2
condition|)
block|{
comment|/* Get a 64-bit value.  */
if|if
condition|(
name|bfd_bread
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|8
condition|)
goto|goto
name|error_return
goto|;
name|vma
operator|+=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: invalid mmo file: expected z = 1 or z = 2, got z = %d for lop_loc\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|sec
operator|=
name|mmo_decide_section
argument_list|(
name|abfd
argument_list|,
name|vma
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
break|break;
case|case
name|LOP_SKIP
case|:
comment|/* Move forward within the same section.  */
name|vma
operator|+=
name|y
operator|*
literal|256
operator|+
name|z
expr_stmt|;
name|sec
operator|=
name|mmo_decide_section
argument_list|(
name|abfd
argument_list|,
name|vma
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
break|break;
case|case
name|LOP_FIXO
case|:
comment|/* A fixup: Store the current vma somewhere.  Position using 		 same format as LOP_LOC.  */
block|{
name|bfd_vma
name|p
init|=
operator|(
name|bfd_vma
operator|)
name|y
operator|<<
literal|56
decl_stmt|;
name|asection
modifier|*
name|fixosec
decl_stmt|;
if|if
condition|(
name|z
operator|==
literal|1
condition|)
block|{
comment|/* Get a 32-bit value.  */
if|if
condition|(
name|bfd_bread
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
goto|goto
name|error_return
goto|;
name|p
operator|+=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|z
operator|==
literal|2
condition|)
block|{
comment|/* Get a 64-bit value.  */
if|if
condition|(
name|bfd_bread
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|8
condition|)
goto|goto
name|error_return
goto|;
name|p
operator|+=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: invalid mmo file: expected z = 1 or z = 2, got z = %d for lop_fixo\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* The section where we store this address might be a 		   different one than the current section.  */
name|fixosec
operator|=
name|mmo_decide_section
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixosec
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|mmo_xore_64
argument_list|(
name|fixosec
argument_list|,
name|p
argument_list|,
name|vma
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOP_FIXR
case|:
comment|/* A fixup: Store YZ of this lopcode into YZ at vma - 4 * yz.  */
block|{
name|unsigned
name|int
name|yz
init|=
operator|(
name|y
operator|*
literal|256
operator|+
name|z
operator|)
decl_stmt|;
name|bfd_vma
name|p
init|=
name|vma
operator|+
literal|2
operator|-
literal|4
operator|*
name|yz
decl_stmt|;
name|asection
modifier|*
name|fixrsec
init|=
name|mmo_decide_section
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|fixrsec
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|mmo_xore_16
argument_list|(
name|fixrsec
argument_list|,
name|p
argument_list|,
name|yz
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOP_FIXRX
case|:
comment|/* A fixup, similar to lop_fixr, but taking larger numbers 		 and can change branches into the opposite direction 		 (gasp!).  */
block|{
name|bfd_vma
name|delta
decl_stmt|;
name|bfd_vma
name|p
decl_stmt|;
name|asection
modifier|*
name|fixrsec
decl_stmt|;
if|if
condition|(
name|y
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: invalid mmo file: expected y = 0, got y = %d for lop_fixrx\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|z
operator|!=
literal|16
operator|&&
name|z
operator|!=
literal|24
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: invalid mmo file: expected z = 16 or z = 24, got z = %d for lop_fixrx\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* Get the next 32-bit value.  */
if|if
condition|(
name|bfd_bread
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
goto|goto
name|error_return
goto|;
name|delta
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Do an, ehm, involved calculation for the location of 		   the fixup.  See mmixal documentation for a verbose 		   explanation.  We follow it verbosely here for the 		   readers delight.  */
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|p
operator|=
name|vma
operator|-
literal|4
operator|*
name|delta
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|1
condition|)
name|p
operator|=
name|vma
operator|-
literal|4
operator|*
operator|(
operator|(
name|delta
operator|&
literal|0xffffff
operator|)
operator|-
operator|(
literal|1
operator|<<
name|z
operator|)
operator|)
expr_stmt|;
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: invalid mmo file: leading byte of operand word must be 0 or 1, got %d for lop_fixrx\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|fixrsec
operator|=
name|mmo_decide_section
argument_list|(
name|abfd
argument_list|,
name|vma
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixrsec
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|mmo_xore_32
argument_list|(
name|fixrsec
argument_list|,
name|p
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOP_FILE
case|:
comment|/* Set current file and perhaps the file name.  Reset line 		 number.  */
if|if
condition|(
name|z
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|fname
init|=
name|bfd_malloc
argument_list|(
name|z
operator|*
literal|4
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: cannot allocate file name for file number %d, %d bytes\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|y
argument_list|,
name|z
operator|*
literal|4
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|fname
index|[
name|z
operator|*
literal|4
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|z
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bfd_bread
argument_list|(
name|fname
operator|+
name|i
operator|*
literal|4
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
block|{
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
block|}
if|if
condition|(
name|file_names
index|[
name|y
index|]
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: invalid mmo file: file number %d `%s',\  was already entered as `%s'\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|y
argument_list|,
name|fname
argument_list|,
name|file_names
index|[
name|y
index|]
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|file_names
index|[
name|y
index|]
operator|=
name|fname
expr_stmt|;
block|}
if|if
condition|(
name|file_names
index|[
name|y
index|]
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: invalid mmo file: file name for number %d\  was not specified before use\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|current_filename
operator|=
name|file_names
index|[
name|y
index|]
expr_stmt|;
name|lineno
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LOP_LINE
case|:
comment|/* Set line number.  */
name|lineno
operator|=
name|y
operator|*
literal|256
operator|+
name|z
expr_stmt|;
comment|/* FIXME: Create a sequence of mmo-specific line number 		 entries for each section, then translate into canonical 		 format.  */
break|break;
case|case
name|LOP_SPEC
case|:
comment|/* Special data follows until the next non-lop_quote 		 lopcode.  */
name|non_spec_sec
operator|=
name|sec
expr_stmt|;
name|non_spec_vma
operator|=
name|vma
expr_stmt|;
name|sec
operator|=
name|mmo_get_spec_section
argument_list|(
name|abfd
argument_list|,
name|y
operator|*
literal|256
operator|+
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|vma
operator|=
name|sec
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|LOP_PRE
case|:
block|{
comment|/* We ignore header information, except we read in the 		   creation time from the first 32-bit word with the time 		   in seconds since era.  */
if|if
condition|(
name|z
operator|>=
literal|1
operator|&&
name|bfd_bread
argument_list|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|created
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
goto|goto
name|error_return
goto|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|z
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bfd_bread
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
goto|goto
name|error_return
goto|;
block|}
break|break;
case|case
name|LOP_POST
case|:
comment|/* This tells of the contents of registers $Z..$255 at 		 startup.  We make a section out of it, with VMA = Z * 8, 		 but only if Z != 255 or the contents is non-zero.  */
block|{
name|asection
modifier|*
name|rsec
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_vma
name|first_octa
decl_stmt|;
name|bfd_vma
name|startaddr_octa
decl_stmt|;
comment|/* Read first octaword outside loop to simplify logic when 		   excluding the Z == 255, octa == 0 case.  */
if|if
condition|(
name|bfd_bread
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|8
condition|)
goto|goto
name|error_return
goto|;
name|first_octa
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Don't emit contents for the trivial case which is 		   always present; $255 pointing to Main.  */
if|if
condition|(
name|z
operator|!=
literal|255
condition|)
block|{
name|rsec
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
name|MMIX_REG_CONTENTS_SECTION_NAME
argument_list|)
expr_stmt|;
name|rsec
operator|->
name|vma
operator|=
name|z
operator|*
literal|8
expr_stmt|;
name|loc
operator|=
name|mmo_get_loc
argument_list|(
name|rsec
argument_list|,
name|z
operator|*
literal|8
argument_list|,
operator|(
literal|255
operator|-
name|z
operator|)
operator|*
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|first_octa
argument_list|,
name|loc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|z
operator|+
literal|1
init|;
name|i
operator|<
literal|255
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bfd_bread
argument_list|(
name|loc
operator|+
operator|(
name|i
operator|-
name|z
operator|)
operator|*
literal|8
argument_list|,
literal|8
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|8
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Read out the last octabyte, and use it to set the 		       start address.  */
if|if
condition|(
name|bfd_bread
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|8
condition|)
goto|goto
name|error_return
goto|;
name|startaddr_octa
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|startaddr_octa
operator|=
name|first_octa
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_start_address
argument_list|(
name|abfd
argument_list|,
name|startaddr_octa
argument_list|)
condition|)
block|{
comment|/* Currently this can't fail, but this should handle 		       future failures.  */
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
block|}
break|break;
case|case
name|LOP_STAB
case|:
comment|/* We read in the symbols now, not later.  */
if|if
condition|(
name|y
operator|!=
literal|0
operator|||
name|z
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: invalid mmo file: fields y and z of lop_stab\  non-zero, y: %d, z: %d\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* Save the location, so we can check that YZ in the LOP_END 		 is correct.  */
name|stab_loc
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* It's not said that an MMO can be without symbols (though 		 mmixal will refuse to assemble files without Main), but 		 it seems it would still be a valid mmo-file, so allow it. 		 We detect the absence of a symbol area in that the upper 		 limit is computed (from the lop_end YZ field) as 0. 		 Don't call mmo_get_symbols; it can only detect the end of 		 a valid symbol trie, not the absence of one.  */
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|max_symbol_length
operator|!=
literal|0
operator|&&
operator|!
name|mmo_get_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
break|break;
case|case
name|LOP_END
case|:
block|{
comment|/* This must be the last 32-bit word in an mmo file. 		   Let's find out.  */
name|struct
name|stat
name|statbuf
decl_stmt|;
name|long
name|curpos
init|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|bfd_stat
argument_list|(
name|abfd
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|statbuf
operator|.
name|st_size
operator|!=
name|curpos
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: invalid mmo file: lop_end not last item in\  file\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
comment|/* Check that the YZ field is right.  Subtract the size of 		   this LOP_END in the calculation; YZ does not include 		   it.  */
if|if
condition|(
call|(
name|long
call|)
argument_list|(
name|y
operator|*
literal|256
operator|+
name|z
argument_list|)
operator|*
literal|4
operator|!=
operator|(
name|curpos
operator|-
name|stab_loc
operator|)
operator|-
literal|4
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: invalid mmo file: YZ of lop_end (%ld)\  not equal to the number of tetras to the preceding lop_stab (%ld)\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|y
operator|*
literal|256
operator|+
name|z
argument_list|)
argument_list|,
operator|(
name|curpos
operator|-
name|stab_loc
operator|-
literal|4
operator|)
operator|/
literal|4
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|mmo_map_set_sizes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
else|else
block|{
comment|/* This wasn't a lopcode, so store it in the current section.  */
name|mmo_xore_32
argument_list|(
name|sec
argument_list|,
name|vma
operator|&
operator|~
literal|3
argument_list|,
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|vma
operator|+=
literal|4
expr_stmt|;
name|vma
operator|&=
operator|~
literal|3
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
block|}
block|}
comment|/* We know this file is a multiple of four bytes (checked in      mmo_object_p), so if we got something other than 0, this was a bad      file (although it's more likely we'll get 0 in that case too).      If we got end-of-file, then there was no lop_stab, so the file has      invalid format.  */
if|if
condition|(
name|nbytes_read
operator|!=
literal|0
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_system_call
argument_list|)
expr_stmt|;
else|else
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|error_return
label|:
name|error
operator|=
name|TRUE
expr_stmt|;
name|done
label|:
comment|/* Mark the .text and .data section with their normal attribute if they      contain anything.  This is not redundant wrt. mmo_decide_section,      since that code might never execute, and conversely the alloc+code      section flags must be set then.  */
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|MMO_TEXT_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|&&
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_CODE
argument_list|)
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|MMO_DATA_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|&&
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
argument_list|)
condition|)
name|error
operator|=
name|TRUE
expr_stmt|;
comment|/* Free whatever resources we took.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|file_names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|file_names
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|file_names
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|file_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|!
name|error
return|;
block|}
end_function

begin_comment
comment|/* A hook to set up object file dependent section information.  For mmo,    we point out the shape of allocated section contents.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mmo_new_section_hook
parameter_list|(
name|abfd
parameter_list|,
name|newsect
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|newsect
decl_stmt|;
block|{
comment|/* We zero-fill all fields and assume NULL is represented by an all      zero-bit pattern.  */
name|newsect
operator|->
name|used_by_bfd
operator|=
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mmo_section_data_struct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newsect
operator|->
name|used_by_bfd
condition|)
return|return
name|FALSE
return|;
comment|/* Always align to at least 32-bit words.  */
name|newsect
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* We already have section contents loaded for sections that have    contents.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mmo_get_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|bytes_to_do
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|PTR
name|location
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|file_ptr
name|offset
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_size_type
name|bytes_to_do
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Iterate over diminishing chunk sizes, copying contents, like      mmo_set_section_contents.  */
while|while
condition|(
name|bytes_to_do
condition|)
block|{
comment|/* A minor song-and-dance to make sure we're not bitten by the 	 distant possibility of the cast from bfd_vma to int making the 	 chunk zero-sized.  */
name|int
name|chunk_size
init|=
operator|(
name|int
operator|)
name|bytes_to_do
operator|!=
literal|0
condition|?
name|bytes_to_do
else|:
name|MMO_SEC_CONTENTS_CHUNK_SIZE
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
do|do
name|loc
operator|=
name|mmo_get_loc
argument_list|(
name|sec
argument_list|,
name|sec
operator|->
name|vma
operator|+
name|offset
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
do|while
condition|(
name|loc
operator|==
name|NULL
operator|&&
operator|(
name|chunk_size
operator|/=
literal|2
operator|)
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|chunk_size
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
name|location
argument_list|,
name|loc
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
name|location
operator|+=
name|chunk_size
expr_stmt|;
name|bytes_to_do
operator|-=
name|chunk_size
expr_stmt|;
name|offset
operator|+=
name|chunk_size
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return the amount of memory needed to read the symbol table.  */
end_comment

begin_function
specifier|static
name|long
name|mmo_get_symtab_upper_bound
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|abfd
operator|->
name|symcount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Sort mmo symbols by serial number.  */
end_comment

begin_function
specifier|static
name|int
name|mmo_sort_mmo_symbols
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
specifier|const
name|PTR
name|arg1
decl_stmt|;
specifier|const
name|PTR
name|arg2
decl_stmt|;
block|{
specifier|const
name|struct
name|mmo_symbol
modifier|*
name|sym1
init|=
operator|*
operator|(
specifier|const
expr|struct
name|mmo_symbol
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
specifier|const
name|struct
name|mmo_symbol
modifier|*
name|sym2
init|=
operator|*
operator|(
specifier|const
expr|struct
name|mmo_symbol
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
comment|/* Sort by serial number first.  */
if|if
condition|(
name|sym1
operator|->
name|serno
operator|<
name|sym2
operator|->
name|serno
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|sym1
operator|->
name|serno
operator|>
name|sym2
operator|->
name|serno
condition|)
return|return
literal|1
return|;
comment|/* Then sort by address of the table entries.  */
return|return
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|arg1
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
name|arg2
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Translate the symbol table.  */
end_comment

begin_function
specifier|static
name|long
name|mmo_canonicalize_symtab
parameter_list|(
name|abfd
parameter_list|,
name|alocation
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|alocation
decl_stmt|;
block|{
name|unsigned
name|int
name|symcount
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
name|csymbols
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|csymbols
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|csymbols
expr_stmt|;
if|if
condition|(
name|csymbols
operator|==
name|NULL
condition|)
block|{
name|asymbol
modifier|*
name|c
decl_stmt|;
name|struct
name|mmo_symbol
modifier|*
name|s
decl_stmt|;
name|struct
name|mmo_symbol
modifier|*
modifier|*
name|msp
decl_stmt|;
comment|/* First we store the symbols into the table we'll return, then we 	 qsort it on the serial number, with secondary on the address of 	 the symbol, to preserve order if there would be non-unique serial 	 numbers.  */
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|symbols
operator|,
name|msp
operator|=
operator|(
expr|struct
name|mmo_symbol
operator|*
operator|*
operator|)
name|alocation
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
operator|,
operator|++
name|msp
control|)
operator|*
name|msp
operator|=
name|s
expr_stmt|;
operator|*
name|msp
operator|=
name|NULL
expr_stmt|;
name|qsort
argument_list|(
name|alocation
argument_list|,
name|symcount
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mmo_symbol
operator|*
argument_list|)
argument_list|,
name|mmo_sort_mmo_symbols
argument_list|)
expr_stmt|;
name|csymbols
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|symcount
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|csymbols
operator|==
name|NULL
operator|&&
name|symcount
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|csymbols
operator|=
name|csymbols
expr_stmt|;
for|for
control|(
name|msp
operator|=
operator|(
expr|struct
name|mmo_symbol
operator|*
operator|*
operator|)
name|alocation
operator|,
name|c
operator|=
name|csymbols
init|;
operator|*
name|msp
operator|!=
name|NULL
condition|;
name|msp
operator|++
operator|,
operator|++
name|c
control|)
block|{
name|s
operator|=
operator|*
name|msp
expr_stmt|;
name|c
operator|->
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|c
operator|->
name|name
operator|=
name|s
operator|->
name|name
expr_stmt|;
name|c
operator|->
name|value
operator|=
name|s
operator|->
name|value
expr_stmt|;
name|c
operator|->
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|sym_type
operator|==
name|mmo_data_sym
condition|)
block|{
name|c
operator|->
name|section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|MMO_DATA_SECTION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|section
operator|==
name|NULL
condition|)
name|c
operator|->
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
else|else
name|c
operator|->
name|value
operator|-=
name|c
operator|->
name|section
operator|->
name|vma
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|sym_type
operator|==
name|mmo_undef_sym
condition|)
name|c
operator|->
name|section
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|->
name|sym_type
operator|==
name|mmo_reg_sym
condition|)
block|{
name|c
operator|->
name|section
operator|=
name|bfd_make_section_old_way
argument_list|(
name|abfd
argument_list|,
name|MMIX_REG_SECTION_NAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|asection
modifier|*
name|textsec
init|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|MMO_TEXT_SECTION_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|textsec
operator|!=
name|NULL
operator|&&
name|c
operator|->
name|value
operator|>=
name|textsec
operator|->
name|vma
operator|&&
name|c
operator|->
name|value
operator|<=
name|textsec
operator|->
name|vma
operator|+
name|textsec
operator|->
name|_cooked_size
condition|)
block|{
name|c
operator|->
name|section
operator|=
name|textsec
expr_stmt|;
name|c
operator|->
name|value
operator|-=
name|c
operator|->
name|section
operator|->
name|vma
expr_stmt|;
block|}
else|else
name|c
operator|->
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
block|}
name|c
operator|->
name|udata
operator|.
name|p
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Last, overwrite the incoming table with the right-type entries.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symcount
condition|;
name|i
operator|++
control|)
operator|*
name|alocation
operator|++
operator|=
name|csymbols
operator|++
expr_stmt|;
operator|*
name|alocation
operator|=
name|NULL
expr_stmt|;
return|return
name|symcount
return|;
block|}
end_function

begin_comment
comment|/* Get information about a symbol.  */
end_comment

begin_function
specifier|static
name|void
name|mmo_get_symbol_info
parameter_list|(
name|ignore_abfd
parameter_list|,
name|symbol
parameter_list|,
name|ret
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|symbol_info
modifier|*
name|ret
decl_stmt|;
block|{
name|bfd_symbol_info
argument_list|(
name|symbol
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mmo_print_symbol
parameter_list|(
name|abfd
parameter_list|,
name|afile
parameter_list|,
name|symbol
parameter_list|,
name|how
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|afile
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|bfd_print_symbol_type
name|how
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|afile
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|bfd_print_symbol_vandf
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %-5s %s"
argument_list|,
name|symbol
operator|->
name|section
operator|->
name|name
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* We can't map a file directly into executable code, so the    size of header information is irrelevant.  */
end_comment

begin_function
specifier|static
name|int
name|mmo_sizeof_headers
parameter_list|(
name|abfd
parameter_list|,
name|exec
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_boolean
name|exec
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Write the (section-neutral) file preamble.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mmo_internal_write_header
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
specifier|const
name|char
name|lop_pre_bfd
index|[]
init|=
block|{
name|LOP
block|,
name|LOP_PRE
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|lop_pre_bfd
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|FALSE
return|;
comment|/* Copy creation time of original file.  */
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|created
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Write the LOP_POST record, with global register initializations.    Z is the Z field of the LOP_POST, corresponding to 255 - number of    registers at DATA.  The Z = 255 field is filled in with the    start-address.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mmo_internal_write_post
parameter_list|(
name|abfd
parameter_list|,
name|z
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|z
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|bfd_byte
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|mmo_write_tetra_raw
argument_list|(
name|abfd
argument_list|,
operator|(
name|LOP
operator|<<
literal|24
operator|)
operator||
operator|(
name|LOP_POST
operator|<<
literal|16
operator|)
operator||
name|z
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|z
init|;
name|i
operator|<
literal|255
condition|;
name|i
operator|++
control|)
block|{
name|bfd_byte
modifier|*
name|data
init|=
name|mmo_get_loc
argument_list|(
name|sec
argument_list|,
name|i
operator|*
literal|8
argument_list|,
literal|8
argument_list|)
decl_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|data
argument_list|,
literal|8
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|8
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* For Z == $255, we always emit the start location; supposedly Main,      but we have it handy at bfd_get_start_address.  If we're called with      Z == 255, don't assume DATA is valid.  */
name|bfd_put_64
argument_list|(
name|abfd
argument_list|,
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|!
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|have_error
operator|&&
name|bfd_bwrite
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|,
name|abfd
argument_list|)
operator|==
literal|8
return|;
block|}
end_function

begin_comment
comment|/* Translate to and from BFD flags.  This is to make sure that we don't    get bitten by BFD flag number changes.  */
end_comment

begin_function
specifier|static
name|flagword
name|mmo_sec_flags_from_bfd_flags
parameter_list|(
name|flags
parameter_list|)
name|flagword
name|flags
decl_stmt|;
block|{
name|flagword
name|oflags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_ALLOC
condition|)
name|oflags
operator||=
name|MMO_SEC_ALLOC
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_LOAD
condition|)
name|oflags
operator||=
name|MMO_SEC_LOAD
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_RELOC
condition|)
name|oflags
operator||=
name|MMO_SEC_RELOC
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_READONLY
condition|)
name|oflags
operator||=
name|MMO_SEC_READONLY
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_CODE
condition|)
name|oflags
operator||=
name|MMO_SEC_CODE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_DATA
condition|)
name|oflags
operator||=
name|MMO_SEC_DATA
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_NEVER_LOAD
condition|)
name|oflags
operator||=
name|MMO_SEC_NEVER_LOAD
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_IS_COMMON
condition|)
name|oflags
operator||=
name|MMO_SEC_IS_COMMON
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_DEBUGGING
condition|)
name|oflags
operator||=
name|MMO_SEC_DEBUGGING
expr_stmt|;
return|return
name|oflags
return|;
block|}
end_function

begin_function
specifier|static
name|flagword
name|bfd_sec_flags_from_mmo_flags
parameter_list|(
name|flags
parameter_list|)
name|flagword
name|flags
decl_stmt|;
block|{
name|flagword
name|oflags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|MMO_SEC_ALLOC
condition|)
name|oflags
operator||=
name|SEC_ALLOC
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MMO_SEC_LOAD
condition|)
name|oflags
operator||=
name|SEC_LOAD
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MMO_SEC_RELOC
condition|)
name|oflags
operator||=
name|SEC_RELOC
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MMO_SEC_READONLY
condition|)
name|oflags
operator||=
name|SEC_READONLY
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MMO_SEC_CODE
condition|)
name|oflags
operator||=
name|SEC_CODE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MMO_SEC_DATA
condition|)
name|oflags
operator||=
name|SEC_DATA
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MMO_SEC_NEVER_LOAD
condition|)
name|oflags
operator||=
name|SEC_NEVER_LOAD
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MMO_SEC_IS_COMMON
condition|)
name|oflags
operator||=
name|SEC_IS_COMMON
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MMO_SEC_DEBUGGING
condition|)
name|oflags
operator||=
name|SEC_DEBUGGING
expr_stmt|;
return|return
name|oflags
return|;
block|}
end_function

begin_comment
comment|/* Write a section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mmo_internal_write_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
comment|/* We do it differently depending on what section this is:     ".text": Output, prepended by information about the first source file    (not yet implemented.)     ".data": Output.     (".MMIX.reg_contents": Not handled here.)     Anything else: Output inside a lop_spec 80, in the format described    above.  */
if|if
condition|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
name|MMO_TEXT_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
comment|/* FIXME: Output source file name and line number.  */
return|return
name|mmo_write_loc_chunk_list
argument_list|(
name|abfd
argument_list|,
name|mmo_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|head
argument_list|)
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
name|MMO_DATA_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
return|return
name|mmo_write_loc_chunk_list
argument_list|(
name|abfd
argument_list|,
name|mmo_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|head
argument_list|)
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
name|MMIX_REG_CONTENTS_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
comment|/* Not handled here.  */
block|{
comment|/* This would normally be an abort call since this can't happen, but          we don't do that.  */
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
name|MMIX_OTHER_SPEC_SECTION_PREFIX
argument_list|,
name|strlen
argument_list|(
name|MMIX_OTHER_SPEC_SECTION_PREFIX
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|n
init|=
name|atoi
argument_list|(
name|sec
operator|->
name|name
operator|+
name|strlen
argument_list|(
name|MMIX_OTHER_SPEC_SECTION_PREFIX
argument_list|)
argument_list|)
decl_stmt|;
name|mmo_write_tetra_raw
argument_list|(
name|abfd
argument_list|,
operator|(
name|LOP
operator|<<
literal|24
operator|)
operator||
operator|(
name|LOP_SPEC
operator|<<
literal|16
operator|)
operator||
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|have_error
operator|&&
name|mmo_write_chunk_list
argument_list|(
name|abfd
argument_list|,
name|mmo_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|head
argument_list|)
operator|)
return|;
block|}
comment|/* Ignore sections that are just allocated or empty; we write out      _contents_ here.  */
elseif|else
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
operator|&&
name|sec
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
comment|/* Keep the document-comment formatted the way it is.  */
comment|/* INODE mmo section mapping, , Symbol-table, mmo SUBSECTION 	mmo section mapping  	The implementation in BFD uses special data type 80 (decimal) to 	encapsulate and describe named sections, containing e.g.@: debug 	information.  If needed, any datum in the encapsulation will be 	quoted using lop_quote.  First comes a 32-bit word holding the 	number of 32-bit words containing the zero-terminated zero-padded 	segment name.  After the name there's a 32-bit word holding flags 	describing the section type.  Then comes a 64-bit big-endian word 	with the section length (in bytes), then another with the section 	start address.  Depending on the type of section, the contents 	might follow, zero-padded to 32-bit boundary.  For a loadable 	section (such as data or code), the contents might follow at some 	later point, not necessarily immediately, as a lop_loc with the 	same start address as in the section description, followed by the 	contents.  This in effect forms a descriptor that must be emitted 	before the actual contents.  Sections described this way must not 	overlap.  	For areas that don't have such descriptors, synthetic sections are 	formed by BFD.  Consecutive contents in the two memory areas 	@samp{0x0000@dots{}00} to @samp{0x01ff@dots{}ff} and 	@samp{0x2000@dots{}00} to @samp{0x20ff@dots{}ff} are entered in 	sections named<<.text>> and<<.data>> respectively.  If an area 	is not otherwise described, but would together with a neighboring 	lower area be less than @samp{0x40000000} bytes long, it is joined 	with the lower area and the gap is zero-filled.  For other cases, 	a new section is formed, named<<.MMIX.sec.@var{n}>>.  Here, 	@var{n} is a number, a running count through the mmo file, 	starting at 0.  EXAMPLE 	A loadable section specified as:  | .section secname,"ax" | TETRA 1,2,3,4,-1,-2009 | BYTE 80  	and linked to address @samp{0x4}, is represented by the sequence:  | 0x98080050 - lop_spec 80 | 0x00000002 - two 32-bit words for the section name | 0x7365636e - "secn" | 0x616d6500 - "ame\0" | 0x00000033 - flags CODE, READONLY, LOAD, ALLOC | 0x00000000 - high 32 bits of section length | 0x0000001c - section length is 28 bytes; 6 * 4 + 1 + alignment to 32 bits | 0x00000000 - high 32 bits of section address | 0x00000004 - section address is 4 | 0x98010002 - 64 bits with address of following data | 0x00000000 - high 32 bits of address | 0x00000004 - low 32 bits: data starts at address 4 | 0x00000001 - 1 | 0x00000002 - 2 | 0x00000003 - 3 | 0x00000004 - 4 | 0xffffffff - -1 | 0xfffff827 - -2009 | 0x50000000 - 80 as a byte, padded with zeros.  	Note that the lop_spec wrapping does not include the section 	contents.  Compare this to a non-loaded section specified as:  | .section thirdsec | TETRA 200001,100002 | BYTE 38,40  	This, when linked to address @samp{0x200000000000001c}, is 	represented by:  | 0x98080050 - lop_spec 80 | 0x00000002 - two 32-bit words for the section name | 0x7365636e - "thir" | 0x616d6500 - "dsec" | 0x00000010 - flag READONLY | 0x00000000 - high 32 bits of section length | 0x0000000c - section length is 12 bytes; 2 * 4 + 2 + alignment to 32 bits | 0x20000000 - high 32 bits of address | 0x0000001c - low 32 bits of address 0x200000000000001c | 0x00030d41 - 200001 | 0x000186a2 - 100002 | 0x26280000 - 38, 40 as bytes, padded with zeros  	For the latter example, the section contents must not be 	loaded in memory, and is therefore specified as part of the 	special data.  The address is usually unimportant but might 	provide information for e.g.@: the DWARF 2 debugging format.  */
name|mmo_write_tetra_raw
argument_list|(
name|abfd
argument_list|,
name|LOP_SPEC_SECTION
argument_list|)
expr_stmt|;
name|mmo_write_tetra
argument_list|(
name|abfd
argument_list|,
operator|(
name|strlen
argument_list|(
name|sec
operator|->
name|name
argument_list|)
operator|+
literal|3
operator|)
operator|/
literal|4
argument_list|)
expr_stmt|;
name|mmo_write_chunk
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|sec
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|mmo_flush_chunk
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* FIXME: We can get debug sections (.debug_line& Co.) with a 	 section flag still having SEC_RELOC set.  Investigate.  This 	 might be true for all alien sections; perhaps mmo.em should clear 	 that flag.  Might be related to weak references.  */
name|mmo_write_tetra
argument_list|(
name|abfd
argument_list|,
name|mmo_sec_flags_from_bfd_flags
argument_list|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mmo_write_octa
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|mmo_write_octa
argument_list|(
name|abfd
argument_list|,
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Writing a LOP_LOC ends the LOP_SPEC data, and makes data actually 	 loaded.  */
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_LOAD
condition|)
return|return
operator|(
operator|!
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|have_error
operator|&&
name|mmo_write_loc_chunk_list
argument_list|(
name|abfd
argument_list|,
name|mmo_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|head
argument_list|)
operator|)
return|;
return|return
operator|(
operator|!
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|have_error
operator|&&
name|mmo_write_chunk_list
argument_list|(
name|abfd
argument_list|,
name|mmo_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|head
argument_list|)
operator|)
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* We save up all data before output.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mmo_set_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|bytes_to_do
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|sec_ptr
name|sec
decl_stmt|;
specifier|const
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|bytes_to_do
decl_stmt|;
block|{
comment|/* Iterate over diminishing chunk sizes, copying contents.  */
while|while
condition|(
name|bytes_to_do
condition|)
block|{
comment|/* A minor song-and-dance to make sure we're not bitten by the 	 distant possibility of the cast from bfd_vma to int making the 	 chunk zero-sized.  */
name|int
name|chunk_size
init|=
operator|(
name|int
operator|)
name|bytes_to_do
operator|!=
literal|0
condition|?
name|bytes_to_do
else|:
name|MMO_SEC_CONTENTS_CHUNK_SIZE
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
do|do
name|loc
operator|=
name|mmo_get_loc
argument_list|(
name|sec
argument_list|,
name|sec
operator|->
name|vma
operator|+
name|offset
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
do|while
condition|(
name|loc
operator|==
name|NULL
operator|&&
operator|(
name|chunk_size
operator|/=
literal|2
operator|)
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|chunk_size
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
name|loc
argument_list|,
name|location
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
name|location
operator|+=
name|chunk_size
expr_stmt|;
name|bytes_to_do
operator|-=
name|chunk_size
expr_stmt|;
name|offset
operator|+=
name|chunk_size
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Add a symbol to a trie-tree.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mmo_internal_add_3_sym
parameter_list|(
name|abfd
parameter_list|,
name|rootp
parameter_list|,
name|symp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|mmo_symbol_trie
modifier|*
name|rootp
decl_stmt|;
specifier|const
name|struct
name|mmo_symbol
modifier|*
name|symp
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|symp
operator|->
name|name
decl_stmt|;
name|struct
name|mmo_symbol_trie
modifier|*
name|trie
init|=
name|rootp
decl_stmt|;
name|struct
name|mmo_symbol_trie
modifier|*
modifier|*
name|triep
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|*
name|name
operator|&&
name|trie
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|name
operator|<
name|trie
operator|->
name|symchar
condition|)
block|{
name|triep
operator|=
operator|&
name|trie
operator|->
name|left
expr_stmt|;
name|trie
operator|=
name|trie
operator|->
name|left
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|name
operator|>
name|trie
operator|->
name|symchar
condition|)
block|{
name|triep
operator|=
operator|&
name|trie
operator|->
name|right
expr_stmt|;
name|trie
operator|=
name|trie
operator|->
name|right
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
name|trie
operator|->
name|symchar
condition|)
block|{
name|triep
operator|=
operator|&
name|trie
operator|->
name|middle
expr_stmt|;
name|name
operator|++
expr_stmt|;
comment|/* Make sure "trie" points to where we should fill in the 	     current symbol whenever we've iterated through "name".  We 	     would lose the right position if we encounter "foobar" then 	     "foo".  */
if|if
condition|(
operator|*
name|name
condition|)
name|trie
operator|=
name|trie
operator|->
name|middle
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|*
name|name
operator|!=
literal|0
condition|)
block|{
comment|/* Create middle branches for the rest of the characters.  */
name|trie
operator|=
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mmo_symbol_trie
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|triep
operator|=
name|trie
expr_stmt|;
name|trie
operator|->
name|symchar
operator|=
operator|*
name|name
operator|++
expr_stmt|;
name|triep
operator|=
operator|&
name|trie
operator|->
name|middle
expr_stmt|;
block|}
comment|/* We discover a duplicate symbol rather late in the process, but still;      we discover it and bail out.  */
if|if
condition|(
name|trie
operator|->
name|sym
operator|.
name|name
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: invalid symbol table: duplicate symbol `%s'\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|trie
operator|->
name|sym
operator|.
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|trie
operator|->
name|sym
argument_list|,
name|symp
argument_list|,
sizeof|sizeof
expr|*
name|symp
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Find out the length of the serialized version of a trie in bytes.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|mmo_internal_3_length
parameter_list|(
name|abfd
parameter_list|,
name|trie
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|mmo_symbol_trie
modifier|*
name|trie
decl_stmt|;
block|{
comment|/* First, one for the control byte.  */
name|unsigned
name|int
name|length
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|trie
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Add in the recursion to the left.  */
name|length
operator|+=
name|mmo_internal_3_length
argument_list|(
name|abfd
argument_list|,
name|trie
operator|->
name|left
argument_list|)
expr_stmt|;
comment|/* Add in the middle trie and the character.  */
name|length
operator|+=
literal|1
operator|+
name|mmo_internal_3_length
argument_list|(
name|abfd
argument_list|,
name|trie
operator|->
name|middle
argument_list|)
expr_stmt|;
comment|/* Add in the recursion to the right.  */
name|length
operator|+=
name|mmo_internal_3_length
argument_list|(
name|abfd
argument_list|,
name|trie
operator|->
name|right
argument_list|)
expr_stmt|;
comment|/* Add in bytes for the symbol (if this is an endnode). */
if|if
condition|(
name|trie
operator|->
name|sym
operator|.
name|name
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|serno
init|=
name|trie
operator|->
name|sym
operator|.
name|serno
decl_stmt|;
comment|/* First what it takes to encode the value. */
if|if
condition|(
name|trie
operator|->
name|sym
operator|.
name|sym_type
operator|==
name|mmo_reg_sym
condition|)
name|length
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|trie
operator|->
name|sym
operator|.
name|sym_type
operator|==
name|mmo_undef_sym
condition|)
name|length
operator|+=
literal|2
expr_stmt|;
else|else
block|{
name|bfd_vma
name|value
init|=
name|trie
operator|->
name|sym
operator|.
name|value
decl_stmt|;
comment|/* Coded in one to eight following bytes.  */
if|if
condition|(
name|trie
operator|->
name|sym
operator|.
name|sym_type
operator|==
name|mmo_data_sym
condition|)
name|value
operator|-=
operator|(
name|bfd_vma
operator|)
literal|0x20
operator|<<
literal|56
expr_stmt|;
do|do
block|{
name|value
operator|>>=
literal|8
expr_stmt|;
name|length
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|value
operator|!=
literal|0
condition|)
do|;
block|}
comment|/* Find out what it takes to encode the serial number.  */
do|do
block|{
name|serno
operator|>>=
literal|7
expr_stmt|;
name|length
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|serno
operator|!=
literal|0
condition|)
do|;
block|}
return|return
name|length
return|;
block|}
end_function

begin_comment
comment|/* Helper function for outputting the serial number of a symbol, output as    a variant of leb128 (see dwarf2 documentation) which could be called    beb128.  Using a helper function and recursion simplifies debugging.  */
end_comment

begin_function
specifier|static
name|void
name|mmo_beb128_out
parameter_list|(
name|abfd
parameter_list|,
name|serno
parameter_list|,
name|marker
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|serno
decl_stmt|;
name|int
name|marker
decl_stmt|;
block|{
if|if
condition|(
name|serno
operator|&
operator|~
literal|0x7f
condition|)
name|mmo_beb128_out
argument_list|(
name|abfd
argument_list|,
name|serno
operator|>>
literal|7
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mmo_write_byte
argument_list|(
name|abfd
argument_list|,
name|marker
operator||
operator|(
name|serno
operator|&
literal|0x7f
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Serialize a trie.  */
end_comment

begin_function
specifier|static
name|void
name|mmo_internal_3_dump
parameter_list|(
name|abfd
parameter_list|,
name|trie
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|mmo_symbol_trie
modifier|*
name|trie
decl_stmt|;
block|{
name|bfd_byte
name|control
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|trie
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|trie
operator|->
name|left
condition|)
name|control
operator||=
name|MMO3_LEFT
expr_stmt|;
if|if
condition|(
name|trie
operator|->
name|middle
condition|)
name|control
operator||=
name|MMO3_MIDDLE
expr_stmt|;
if|if
condition|(
name|trie
operator|->
name|right
condition|)
name|control
operator||=
name|MMO3_RIGHT
expr_stmt|;
if|if
condition|(
name|trie
operator|->
name|sym
operator|.
name|name
operator|!=
name|NULL
condition|)
block|{
comment|/* Encode the symbol type and length of value bytes.  */
if|if
condition|(
name|trie
operator|->
name|sym
operator|.
name|sym_type
operator|==
name|mmo_reg_sym
condition|)
name|control
operator||=
name|MMO3_REGQUAL_BITS
expr_stmt|;
elseif|else
if|if
condition|(
name|trie
operator|->
name|sym
operator|.
name|sym_type
operator|==
name|mmo_undef_sym
condition|)
name|control
operator||=
name|MMO3_UNDEF
expr_stmt|;
else|else
block|{
name|bfd_vma
name|value
init|=
name|trie
operator|->
name|sym
operator|.
name|value
decl_stmt|;
comment|/* Coded in 1..8 following bytes.  */
if|if
condition|(
name|trie
operator|->
name|sym
operator|.
name|sym_type
operator|==
name|mmo_data_sym
condition|)
block|{
name|control
operator||=
name|MMO3_DATA
expr_stmt|;
name|value
operator|-=
operator|(
name|bfd_vma
operator|)
literal|0x20
operator|<<
literal|56
expr_stmt|;
block|}
do|do
block|{
name|value
operator|>>=
literal|8
expr_stmt|;
name|control
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|value
operator|!=
literal|0
condition|)
do|;
block|}
block|}
comment|/* The control byte is output before recursing.  */
name|mmo_write_byte
argument_list|(
name|abfd
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|mmo_internal_3_dump
argument_list|(
name|abfd
argument_list|,
name|trie
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|&
name|MMO3_SYMBITS
condition|)
block|{
name|mmo_write_byte
argument_list|(
name|abfd
argument_list|,
name|trie
operator|->
name|symchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|trie
operator|->
name|sym
operator|.
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|trie
operator|->
name|sym
operator|.
name|sym_type
operator|==
name|mmo_reg_sym
condition|)
name|mmo_write_byte
argument_list|(
name|abfd
argument_list|,
name|trie
operator|->
name|sym
operator|.
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|trie
operator|->
name|sym
operator|.
name|sym_type
operator|==
name|mmo_undef_sym
condition|)
block|{
name|mmo_write_byte
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mmo_write_byte
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_vma
name|value
init|=
name|trie
operator|->
name|sym
operator|.
name|value
decl_stmt|;
name|bfd_byte
name|byte_n
init|=
name|control
operator|&
literal|15
decl_stmt|;
comment|/* Coded in 1..8 following bytes.  Note that the value is 		 shifted out big-endian.  */
if|if
condition|(
name|trie
operator|->
name|sym
operator|.
name|sym_type
operator|==
name|mmo_data_sym
condition|)
block|{
name|value
operator|-=
operator|(
name|bfd_vma
operator|)
literal|0x20
operator|<<
literal|56
expr_stmt|;
name|byte_n
operator|-=
literal|8
expr_stmt|;
block|}
do|do
block|{
name|mmo_write_byte
argument_list|(
name|abfd
argument_list|,
operator|(
name|value
operator|>>
operator|(
operator|(
name|byte_n
operator|-
literal|1
operator|)
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|byte_n
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|byte_n
operator|!=
literal|0
condition|)
do|;
block|}
name|mmo_beb128_out
argument_list|(
name|abfd
argument_list|,
name|trie
operator|->
name|sym
operator|.
name|serno
argument_list|,
literal|128
argument_list|)
expr_stmt|;
block|}
name|mmo_internal_3_dump
argument_list|(
name|abfd
argument_list|,
name|trie
operator|->
name|middle
argument_list|)
expr_stmt|;
block|}
name|mmo_internal_3_dump
argument_list|(
name|abfd
argument_list|,
name|trie
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write symbols in mmo format.  Also write the lop_end terminator.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mmo_write_symbols_and_terminator
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|count
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
name|maintable
index|[
literal|2
index|]
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|table
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|orig_table
init|=
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|int
name|serno
decl_stmt|;
name|struct
name|mmo_symbol_trie
name|root
decl_stmt|;
name|int
name|trie_len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bfd_byte
name|buf
index|[
literal|4
index|]
decl_stmt|;
comment|/* Create a symbol for "Main".  */
name|asymbol
modifier|*
name|fakemain
init|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|fakemain
operator|->
name|flags
operator|=
name|BSF_GLOBAL
expr_stmt|;
name|fakemain
operator|->
name|value
operator|=
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|fakemain
operator|->
name|name
operator|=
name|MMIX_START_SYMBOL_NAME
expr_stmt|;
name|fakemain
operator|->
name|section
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|maintable
index|[
literal|0
index|]
operator|=
name|fakemain
expr_stmt|;
name|maintable
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|root
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|root
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make all symbols take a left turn.  */
name|root
operator|.
name|symchar
operator|=
literal|0xff
expr_stmt|;
comment|/* There must always be a ":Main", so we'll add one if there are no      symbols.  Make sure we have room for it.  */
name|table
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
name|table
argument_list|,
name|orig_table
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Move :Main (if there is one) to the first position.  This is      necessary to get the same layout of the trie-tree when linking as      when objcopying the result as in the objcopy.exp test "simple objcopy      of executable".  It also automatically takes care of assigning serial      number 1 to :Main (as is mandatory).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|table
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|table
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|MMIX_START_SYMBOL_NAME
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|table
index|[
name|i
index|]
operator|->
name|flags
operator|&
operator|(
name|BSF_DEBUGGING
operator||
name|BSF_GLOBAL
operator|)
operator|)
operator|==
name|BSF_GLOBAL
condition|)
block|{
name|asymbol
modifier|*
name|mainsym
init|=
name|table
index|[
name|i
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|table
operator|+
literal|1
argument_list|,
name|orig_table
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|table
index|[
literal|0
index|]
operator|=
name|mainsym
expr_stmt|;
comment|/* Check that the value assigned to :Main is the same as the entry 	   address.  The default linker script asserts this.  This is as 	   good a place as any to check this consistency. */
if|if
condition|(
operator|(
name|mainsym
operator|->
name|value
operator|+
name|mainsym
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|mainsym
operator|->
name|section
operator|->
name|output_offset
operator|)
operator|!=
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
comment|/* Arbitrary buffer to hold the printable representation of a 	       vma.  */
name|char
name|vmas_main
index|[
literal|40
index|]
decl_stmt|;
name|char
name|vmas_start
index|[
literal|40
index|]
decl_stmt|;
name|bfd_vma
name|vma_start
init|=
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|sprintf_vma
argument_list|(
name|vmas_main
argument_list|,
name|mainsym
operator|->
name|value
argument_list|)
expr_stmt|;
name|sprintf_vma
argument_list|(
name|vmas_start
argument_list|,
name|vma_start
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: Bad symbol definition: `Main' set to %s rather\  than the start address %s\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|vmas_main
argument_list|,
name|vmas_start
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|count
operator|&&
name|count
operator|!=
literal|0
condition|)
block|{
comment|/* When there are symbols, there must be a :Main.  There was no 	 :Main, so we need to add it manually.  */
name|memcpy
argument_list|(
name|table
operator|+
literal|1
argument_list|,
name|orig_table
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|table
index|[
literal|0
index|]
operator|=
name|fakemain
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|serno
operator|=
literal|1
init|;
name|i
operator|<
name|count
operator|&&
name|table
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|asymbol
modifier|*
name|s
init|=
name|table
index|[
name|i
index|]
decl_stmt|;
comment|/* It's not enough to consult bfd_is_local_label, since it does not 	 mean "local" in the sense of linkable-and-observable-after-link. 	 Let's just check the BSF_GLOBAL flag.  	 Also, don't export symbols with characters not in the allowed set.  */
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
operator|(
name|BSF_DEBUGGING
operator||
name|BSF_GLOBAL
operator|)
operator|)
operator|==
name|BSF_GLOBAL
operator|&&
name|strspn
argument_list|(
name|s
operator|->
name|name
argument_list|,
name|valid_mmo_symbol_character_set
argument_list|)
operator|==
name|strlen
argument_list|(
name|s
operator|->
name|name
argument_list|)
condition|)
block|{
name|struct
name|mmo_symbol
name|sym
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|.
name|name
operator|=
name|s
operator|->
name|name
expr_stmt|;
name|sym
operator|.
name|value
operator|=
name|s
operator|->
name|value
operator|+
name|s
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|s
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|s
operator|->
name|section
argument_list|)
condition|)
name|sym
operator|.
name|sym_type
operator|=
name|mmo_undef_sym
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|->
name|section
operator|->
name|name
argument_list|,
name|MMO_DATA_SECTION_NAME
argument_list|)
operator|==
literal|0
comment|/* The encoding of data symbols require that the "rest" 		      of the value fits in 6 bytes, so the upper two bytes 		      must be 0x2000.  All other symbols get to be the 		      absolute type.  */
operator|&&
operator|(
name|sym
operator|.
name|value
operator|>>
literal|48
operator|)
operator|==
literal|0x2000
condition|)
name|sym
operator|.
name|sym_type
operator|=
name|mmo_data_sym
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|->
name|section
operator|->
name|name
argument_list|,
name|MMIX_REG_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|.
name|sym_type
operator|=
name|mmo_reg_sym
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|->
name|section
operator|->
name|name
argument_list|,
name|MMIX_REG_CONTENTS_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym
operator|.
name|sym_type
operator|=
name|mmo_reg_sym
expr_stmt|;
name|sym
operator|.
name|value
operator|/=
literal|8
expr_stmt|;
block|}
else|else
name|sym
operator|.
name|sym_type
operator|=
name|mmo_abs_sym
expr_stmt|;
comment|/* FIXME: We assume the order of the received symbols is an 	     ordered mapping of the serial numbers.  This is not 	     necessarily true if we e.g. objcopy a mmo file to another and 	     there are gaps in the numbering.  Not sure if this can 	     happen.  Not sure what to do.  */
name|sym
operator|.
name|serno
operator|=
name|serno
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|mmo_internal_add_3_sym
argument_list|(
name|abfd
argument_list|,
operator|&
name|root
argument_list|,
operator|&
name|sym
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Change the root node to be a ":"-prefix.  */
name|root
operator|.
name|symchar
operator|=
literal|':'
expr_stmt|;
name|root
operator|.
name|middle
operator|=
name|root
operator|.
name|left
expr_stmt|;
name|root
operator|.
name|right
operator|=
name|NULL
expr_stmt|;
name|root
operator|.
name|left
operator|=
name|NULL
expr_stmt|;
comment|/* We have to find out if we can fit the whole symbol table in the mmo      symtab.  It would be bad to assume we can always fit it in 262144      bytes.  If we can't, just leave the Main symbol.  */
name|trie_len
operator|=
operator|(
name|mmo_internal_3_length
argument_list|(
name|abfd
argument_list|,
operator|&
name|root
argument_list|)
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|trie_len
operator|>
literal|0xffff
condition|)
block|{
comment|/* Test this code by using a lower limit in the test above and check 	 that the single "Main" symbol is emitted and handled properly. 	 There's no specific test-case.  */
name|struct
name|mmo_symbol
name|sym
decl_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: warning: symbol table too large for mmo, larger than 65535\  32-bit words: %d.  Only `Main' will be emitted.\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|trie_len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|.
name|sym_type
operator|=
name|mmo_abs_sym
expr_stmt|;
name|sym
operator|.
name|name
operator|=
name|MMIX_START_SYMBOL_NAME
expr_stmt|;
name|sym
operator|.
name|serno
operator|=
literal|1
expr_stmt|;
name|sym
operator|.
name|value
operator|=
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* Then patch up a symbol table to be just the ":Main" symbol.  */
name|memset
argument_list|(
operator|&
name|root
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|root
argument_list|)
argument_list|)
expr_stmt|;
name|root
operator|.
name|left
operator|=
name|root
operator|.
name|middle
expr_stmt|;
name|root
operator|.
name|symchar
operator|=
literal|0xff
expr_stmt|;
name|root
operator|.
name|middle
operator|=
name|NULL
expr_stmt|;
name|root
operator|.
name|right
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|mmo_internal_add_3_sym
argument_list|(
name|abfd
argument_list|,
operator|&
name|root
argument_list|,
operator|&
name|sym
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|root
operator|.
name|symchar
operator|=
literal|':'
expr_stmt|;
name|root
operator|.
name|middle
operator|=
name|root
operator|.
name|left
expr_stmt|;
name|root
operator|.
name|right
operator|=
name|NULL
expr_stmt|;
name|root
operator|.
name|left
operator|=
name|NULL
expr_stmt|;
name|trie_len
operator|=
operator|(
name|mmo_internal_3_length
argument_list|(
name|abfd
argument_list|,
operator|&
name|root
argument_list|)
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
block|}
comment|/* Reset the written-bytes counter.  */
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|byte_no
operator|=
literal|0
expr_stmt|;
comment|/* Put out the lop_stab mark.  */
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|LOP
operator|<<
literal|24
operator|)
operator||
operator|(
name|LOP_STAB
operator|<<
literal|16
operator|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|FALSE
return|;
comment|/* Dump out symbols.  */
name|mmo_internal_3_dump
argument_list|(
name|abfd
argument_list|,
operator|&
name|root
argument_list|)
expr_stmt|;
if|if
condition|(
name|trie_len
operator|!=
operator|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|byte_no
operator|+
literal|3
operator|)
operator|/
literal|4
condition|)
block|{
comment|/* I haven't seen this trig.  It seems no use claiming this case 	 isn't debugged and abort if we get here.  Instead emit a 	 diagnostic and fail "normally".  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: internal error, symbol table changed size from %d to %d\  words\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|trie_len
argument_list|,
operator|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|byte_no
operator|+
literal|3
operator|)
operator|/
literal|4
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Dump out remaining bytes in the buffer and handle I/O errors by      propagating errors.  */
if|if
condition|(
operator|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|byte_no
operator|%
literal|4
operator|)
operator|!=
literal|0
operator|||
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|have_error
condition|)
block|{
name|memset
argument_list|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|buf
operator|+
operator|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|byte_no
operator|%
literal|4
operator|)
argument_list|,
literal|0
argument_list|,
literal|4
operator|-
operator|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|byte_no
operator|%
literal|4
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|have_error
operator|||
name|bfd_bwrite
argument_list|(
name|abfd
operator|->
name|tdata
operator|.
name|mmo_data
operator|->
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|4
condition|)
return|return
name|FALSE
return|;
block|}
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|LOP
operator|<<
literal|24
operator|)
operator||
operator|(
name|LOP_END
operator|<<
literal|16
operator|)
operator||
name|trie_len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|bfd_bwrite
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|abfd
argument_list|)
operator|==
literal|4
return|;
block|}
end_function

begin_comment
comment|/* Write section unless it is the register contents section.  For that, we    instead store the section in the supplied pointer.  This function is    used through bfd_map_over_sections.  */
end_comment

begin_function
specifier|static
name|void
name|mmo_write_section_unless_reg_contents
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|p
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|p
decl_stmt|;
block|{
name|struct
name|mmo_write_sec_info
modifier|*
name|infop
init|=
operator|(
expr|struct
name|mmo_write_sec_info
operator|*
operator|)
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|infop
operator|->
name|retval
condition|)
return|return;
if|if
condition|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
name|MMIX_REG_CONTENTS_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
name|infop
operator|->
name|reg_section
operator|=
name|sec
expr_stmt|;
return|return;
block|}
comment|/* Exclude the convenience register section.  */
if|if
condition|(
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
name|MMIX_REG_SECTION_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_HAS_CONTENTS
condition|)
block|{
comment|/* Make sure it hasn't got contents.  It seems impossible to 	     make it carry contents, so we don't have a test-case for 	     this.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: internal error, internal register section %s had\  contents\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|infop
operator|->
name|retval
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
return|return;
block|}
name|infop
operator|->
name|retval
operator|=
name|mmo_internal_write_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do the actual output of a file.  Assumes mmo_set_section_contents is    already called. */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|mmo_write_object_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|mmo_write_sec_info
name|wsecinfo
decl_stmt|;
comment|/* First, there are a few words of preamble.  */
if|if
condition|(
operator|!
name|mmo_internal_write_header
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|wsecinfo
operator|.
name|reg_section
operator|=
name|NULL
expr_stmt|;
name|wsecinfo
operator|.
name|retval
operator|=
name|TRUE
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|mmo_write_section_unless_reg_contents
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|wsecinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wsecinfo
operator|.
name|retval
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|wsecinfo
operator|.
name|reg_section
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|sec
init|=
name|wsecinfo
operator|.
name|reg_section
decl_stmt|;
name|unsigned
name|int
name|z
init|=
call|(
name|unsigned
name|int
call|)
argument_list|(
name|sec
operator|->
name|vma
operator|/
literal|8
argument_list|)
decl_stmt|;
comment|/* Registers 0..31 must not be global.  Do sanity check on the "vma" 	 of the register contents section and check that it corresponds to 	 the length of the section.  */
if|if
condition|(
name|z
operator|<
literal|32
operator|||
name|z
operator|>=
literal|255
operator|||
operator|(
name|sec
operator|->
name|vma
operator|&
literal|7
operator|)
operator|!=
literal|0
operator|||
name|sec
operator|->
name|vma
operator|!=
literal|256
operator|*
literal|8
operator|-
name|sec
operator|->
name|_raw_size
operator|-
literal|8
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|_raw_size
operator|==
literal|0
condition|)
comment|/* There must always be at least one such register.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: no initialized registers; section length 0\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sec
operator|->
name|vma
operator|>
operator|(
literal|256
operator|-
literal|32
operator|)
operator|*
literal|8
condition|)
comment|/* Provide better error message for the case of too many 	       global registers.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: too many initialized registers; section length %ld\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: invalid start address for initialized registers of\  length %ld: 0x%lx%08lx\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|sec
operator|->
name|_raw_size
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|sec
operator|->
name|vma
operator|>>
literal|32
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|sec
operator|->
name|vma
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|mmo_internal_write_post
argument_list|(
name|abfd
argument_list|,
name|z
argument_list|,
name|sec
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|mmo_internal_write_post
argument_list|(
name|abfd
argument_list|,
literal|255
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|mmo_write_symbols_and_terminator
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the size of a NULL pointer, so we support linking in an mmo    object.  */
end_comment

begin_function
specifier|static
name|long
name|mmo_get_reloc_upper_bound
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
sizeof|sizeof
argument_list|(
name|PTR
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Similarly canonicalize relocs to empty, filling in the terminating NULL    pointer.  */
end_comment

begin_function
name|long
name|mmo_canonicalize_reloc
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|relptr
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|sec_ptr
name|section
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relptr
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
operator|*
name|relptr
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If there's anything in particular in a mmo bfd that we want to free,    make this a real function.  Only do this if you see major memory    thrashing; zealous free:ing will cause unwanted behavior, especially if    you "free" memory allocated with "bfd_alloc", or even "bfd_release" a    block allocated with "bfd_alloc"; they're really allocated from an    obstack, and we don't know what was allocated there since this    particular allocation.  */
end_comment

begin_define
define|#
directive|define
name|mmo_close_and_cleanup
value|_bfd_generic_close_and_cleanup
end_define

begin_define
define|#
directive|define
name|mmo_bfd_free_cached_info
value|_bfd_generic_bfd_free_cached_info
end_define

begin_comment
comment|/* Perhaps we need to adjust this one; mmo labels (originally) without a    leading ':' might more appropriately be called local.  */
end_comment

begin_define
define|#
directive|define
name|mmo_bfd_is_local_label_name
value|bfd_generic_is_local_label_name
end_define

begin_comment
comment|/* Is this one really used or defined by anyone?  */
end_comment

begin_define
define|#
directive|define
name|mmo_get_lineno
value|_bfd_nosymbols_get_lineno
end_define

begin_comment
comment|/* FIXME: We can do better on this one, if we have a dwarf2 .debug_line    section or if MMO line numbers are implemented.  */
end_comment

begin_define
define|#
directive|define
name|mmo_find_nearest_line
value|_bfd_nosymbols_find_nearest_line
end_define

begin_define
define|#
directive|define
name|mmo_make_empty_symbol
value|_bfd_generic_make_empty_symbol
end_define

begin_define
define|#
directive|define
name|mmo_bfd_make_debug_symbol
value|_bfd_nosymbols_bfd_make_debug_symbol
end_define

begin_define
define|#
directive|define
name|mmo_read_minisymbols
value|_bfd_generic_read_minisymbols
end_define

begin_define
define|#
directive|define
name|mmo_minisymbol_to_symbol
value|_bfd_generic_minisymbol_to_symbol
end_define

begin_define
define|#
directive|define
name|mmo_get_section_contents_in_window
define|\
value|_bfd_generic_get_section_contents_in_window
end_define

begin_define
define|#
directive|define
name|mmo_bfd_get_relocated_section_contents
define|\
value|bfd_generic_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|mmo_bfd_gc_sections
value|bfd_generic_gc_sections
end_define

begin_define
define|#
directive|define
name|mmo_bfd_link_hash_table_create
value|_bfd_generic_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|mmo_bfd_link_hash_table_free
value|_bfd_generic_link_hash_table_free
end_define

begin_define
define|#
directive|define
name|mmo_bfd_link_add_symbols
value|_bfd_generic_link_add_symbols
end_define

begin_define
define|#
directive|define
name|mmo_bfd_link_just_syms
value|_bfd_generic_link_just_syms
end_define

begin_define
define|#
directive|define
name|mmo_bfd_final_link
value|_bfd_generic_final_link
end_define

begin_define
define|#
directive|define
name|mmo_bfd_link_split_section
value|_bfd_generic_link_split_section
end_define

begin_comment
comment|/* Strictly speaking, only MMIX uses this restricted format, but let's not    stop anybody from shooting themselves in the foot.  */
end_comment

begin_define
define|#
directive|define
name|mmo_set_arch_mach
value|bfd_default_set_arch_mach
end_define

begin_define
define|#
directive|define
name|mmo_bfd_relax_section
value|bfd_generic_relax_section
end_define

begin_define
define|#
directive|define
name|mmo_bfd_merge_sections
value|bfd_generic_merge_sections
end_define

begin_define
define|#
directive|define
name|mmo_bfd_discard_group
value|bfd_generic_discard_group
end_define

begin_comment
comment|/* objcopy will be upset if we return -1 from bfd_get_reloc_upper_bound by    using BFD_JUMP_TABLE_RELOCS (_bfd_norelocs) rather than 0.  FIXME: Most    likely a bug in the _bfd_norelocs definition.     On the other hand, we smuggle in an mmo object (because setting up ELF    is too cumbersome) when linking (from other formats, presumably ELF) to    represent the g255 entry.  We need to link that object, so need to say    it has no relocs.  Upper bound for the size of the relocation table is    the size of a NULL pointer, and we support "canonicalization" for that    pointer.  */
end_comment

begin_define
define|#
directive|define
name|mmo_bfd_reloc_type_lookup
value|_bfd_norelocs_bfd_reloc_type_lookup
end_define

begin_comment
comment|/* We want to copy time of creation, otherwise we'd use    BFD_JUMP_TABLE_COPY (_bfd_generic).  */
end_comment

begin_define
define|#
directive|define
name|mmo_bfd_merge_private_bfd_data
value|_bfd_generic_bfd_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|mmo_bfd_copy_private_section_data
value|_bfd_generic_bfd_copy_private_section_data
end_define

begin_define
define|#
directive|define
name|mmo_bfd_copy_private_symbol_data
value|_bfd_generic_bfd_copy_private_symbol_data
end_define

begin_define
define|#
directive|define
name|mmo_bfd_set_private_flags
value|_bfd_generic_bfd_set_private_flags
end_define

begin_define
define|#
directive|define
name|mmo_bfd_print_private_bfd_data
value|_bfd_generic_bfd_print_private_bfd_data
end_define

begin_decl_stmt
specifier|const
name|bfd_target
name|bfd_mmo_vec
init|=
block|{
literal|"mmo"
block|,
comment|/* name */
name|bfd_target_mmo_flavour
block|,
name|BFD_ENDIAN_BIG
block|,
comment|/* target byte order */
name|BFD_ENDIAN_BIG
block|,
comment|/* target headers byte order */
comment|/* FIXME: Might need adjustments.  */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator|)
block|,
comment|/* FIXME: Might need adjustments.  */
operator|(
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_READONLY
operator||
name|SEC_EXCLUDE
operator||
name|SEC_DEBUGGING
operator||
name|SEC_IN_MEMORY
operator|)
block|,
comment|/* section flags */
literal|0
block|,
comment|/* leading underscore */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|mmo_object_p
block|,
comment|/* bfd_check_format */
name|_bfd_dummy_target
block|,
name|_bfd_dummy_target
block|,   }
block|,
block|{
name|bfd_false
block|,
name|mmo_mkobject
block|,
name|bfd_false
block|,
name|bfd_false
block|,   }
block|,
block|{
comment|/* bfd_write_contents */
name|bfd_false
block|,
name|mmo_write_object_contents
block|,
name|bfd_false
block|,
name|bfd_false
block|,   }
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|mmo
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|mmo
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_noarchive
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|mmo
argument_list|)
block|,
comment|/* We have to provide a valid method for getting relocs, returning zero,      so we can't say BFD_JUMP_TABLE_RELOCS (_bfd_norelocs).  */
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|mmo
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|mmo
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|mmo
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

end_unit

