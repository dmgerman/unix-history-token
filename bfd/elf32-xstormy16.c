begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Xstormy16-specific support for 32-bit ELF.    Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007    Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301,    USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/xstormy16.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_comment
comment|/* Handle the R_XSTORMY16_24 reloc, which has an odd bit arrangement.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|xstormy16_elf_24_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_vma
name|relocation
decl_stmt|,
name|x
decl_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
if|if
condition|(
name|reloc_entry
operator|->
name|address
operator|>
name|bfd_get_section_limit
argument_list|(
name|abfd
argument_list|,
name|input_section
argument_list|)
condition|)
return|return
name|bfd_reloc_outofrange
return|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
name|symbol
operator|->
name|value
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|relocation
operator|+=
name|symbol
operator|->
name|section
operator|->
name|output_offset
expr_stmt|;
name|relocation
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|x
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
name|x
operator|&=
literal|0x0000ff00
expr_stmt|;
name|x
operator||=
name|relocation
operator|&
literal|0xff
expr_stmt|;
name|x
operator||=
operator|(
name|relocation
operator|<<
literal|8
operator|)
operator|&
literal|0xffff0000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|x
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|data
operator|+
name|reloc_entry
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|relocation
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0xffffff
condition|)
return|return
name|bfd_reloc_overflow
return|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|xstormy16_elf_howto_table
index|[]
init|=
block|{
comment|/* This reloc does nothing.  */
name|HOWTO
argument_list|(
name|R_XSTORMY16_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_XSTORMY16_NONE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32 bit absolute relocation.  */
name|HOWTO
argument_list|(
name|R_XSTORMY16_32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_XSTORMY16_32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit absolute relocation.  */
name|HOWTO
argument_list|(
name|R_XSTORMY16_16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_XSTORMY16_16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An 8 bit absolute relocation.  */
name|HOWTO
argument_list|(
name|R_XSTORMY16_8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_XSTORMY16_8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32 bit pc-relative relocation.  */
name|HOWTO
argument_list|(
name|R_XSTORMY16_PC32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_XSTORMY16_PC32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit pc-relative relocation.  */
name|HOWTO
argument_list|(
name|R_XSTORMY16_PC16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_XSTORMY16_PC16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An 8 bit pc-relative relocation.  */
name|HOWTO
argument_list|(
name|R_XSTORMY16_PC8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_XSTORMY16_PC8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 12-bit pc-relative relocation suitable for the branch instructions.  */
name|HOWTO
argument_list|(
name|R_XSTORMY16_REL_12
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|11
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|1
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_XSTORMY16_REL_12"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0ffe
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 24-bit absolute relocation suitable for the jump instructions.  */
name|HOWTO
argument_list|(
name|R_XSTORMY16_24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|24
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|xstormy16_elf_24_reloc
argument_list|,
comment|/* special_function */
literal|"R_XSTORMY16_24"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff00ff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit absolute relocation to a function pointer.  */
name|HOWTO
argument_list|(
name|R_XSTORMY16_FPTR16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_XSTORMY16_FPTR16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Low order 16 bit value of a high memory address.  */
name|HOWTO
argument_list|(
name|R_XSTORMY16_LO16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_XSTORMY16_LO16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* High order 16 bit value of a high memory address.  */
name|HOWTO
argument_list|(
name|R_XSTORMY16_HI16
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_XSTORMY16_HI16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 12 bit absolute relocation.  */
name|HOWTO
argument_list|(
name|R_XSTORMY16_12
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_XSTORMY16_12"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x0000
argument_list|,
comment|/* src_mask */
literal|0x0fff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|xstormy16_elf_howto_table2
index|[]
init|=
block|{
comment|/* GNU extension to record C++ vtable hierarchy */
name|HOWTO
argument_list|(
name|R_XSTORMY16_GNU_VTINHERIT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|NULL
argument_list|,
comment|/* special_function */
literal|"R_XSTORMY16_GNU_VTINHERIT"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* GNU extension to record C++ vtable member usage */
name|HOWTO
argument_list|(
name|R_XSTORMY16_GNU_VTENTRY
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|_bfd_elf_rel_vtable_reloc_fn
argument_list|,
comment|/* special_function */
literal|"R_XSTORMY16_GNU_VTENTRY"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Map BFD reloc types to XSTORMY16 ELF reloc types.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|xstormy16_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_val
decl_stmt|;
name|unsigned
name|int
name|xstormy16_reloc_val
decl_stmt|;
name|reloc_howto_type
modifier|*
name|table
decl_stmt|;
block|}
name|reloc_map
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|reloc_map
name|xstormy16_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_XSTORMY16_NONE
block|,
name|xstormy16_elf_howto_table
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_XSTORMY16_32
block|,
name|xstormy16_elf_howto_table
block|}
block|,
block|{
name|BFD_RELOC_16
block|,
name|R_XSTORMY16_16
block|,
name|xstormy16_elf_howto_table
block|}
block|,
block|{
name|BFD_RELOC_8
block|,
name|R_XSTORMY16_8
block|,
name|xstormy16_elf_howto_table
block|}
block|,
block|{
name|BFD_RELOC_32_PCREL
block|,
name|R_XSTORMY16_PC32
block|,
name|xstormy16_elf_howto_table
block|}
block|,
block|{
name|BFD_RELOC_16_PCREL
block|,
name|R_XSTORMY16_PC16
block|,
name|xstormy16_elf_howto_table
block|}
block|,
block|{
name|BFD_RELOC_8_PCREL
block|,
name|R_XSTORMY16_PC8
block|,
name|xstormy16_elf_howto_table
block|}
block|,
block|{
name|BFD_RELOC_XSTORMY16_REL_12
block|,
name|R_XSTORMY16_REL_12
block|,
name|xstormy16_elf_howto_table
block|}
block|,
block|{
name|BFD_RELOC_XSTORMY16_24
block|,
name|R_XSTORMY16_24
block|,
name|xstormy16_elf_howto_table
block|}
block|,
block|{
name|BFD_RELOC_XSTORMY16_FPTR16
block|,
name|R_XSTORMY16_FPTR16
block|,
name|xstormy16_elf_howto_table
block|}
block|,
block|{
name|BFD_RELOC_LO16
block|,
name|R_XSTORMY16_LO16
block|,
name|xstormy16_elf_howto_table
block|}
block|,
block|{
name|BFD_RELOC_HI16
block|,
name|R_XSTORMY16_HI16
block|,
name|xstormy16_elf_howto_table
block|}
block|,
block|{
name|BFD_RELOC_XSTORMY16_12
block|,
name|R_XSTORMY16_12
block|,
name|xstormy16_elf_howto_table
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_INHERIT
block|,
name|R_XSTORMY16_GNU_VTINHERIT
block|,
name|xstormy16_elf_howto_table2
block|}
block|,
block|{
name|BFD_RELOC_VTABLE_ENTRY
block|,
name|R_XSTORMY16_GNU_VTENTRY
block|,
name|xstormy16_elf_howto_table2
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|xstormy16_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ARRAY_SIZE
argument_list|(
name|xstormy16_reloc_map
argument_list|)
init|;
operator|--
name|i
condition|;
control|)
block|{
specifier|const
name|reloc_map
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
name|xstormy16_reloc_map
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|bfd_reloc_val
operator|==
name|code
condition|)
return|return
name|entry
operator|->
name|table
operator|+
operator|(
name|entry
operator|->
name|xstormy16_reloc_val
operator|-
name|entry
operator|->
name|table
index|[
literal|0
index|]
operator|.
name|type
operator|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|xstormy16_reloc_name_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|r_name
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|xstormy16_elf_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|xstormy16_elf_howto_table
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|xstormy16_elf_howto_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcasecmp
argument_list|(
name|xstormy16_elf_howto_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|xstormy16_elf_howto_table
index|[
name|i
index|]
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|xstormy16_elf_howto_table2
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|xstormy16_elf_howto_table2
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|xstormy16_elf_howto_table2
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcasecmp
argument_list|(
name|xstormy16_elf_howto_table2
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|xstormy16_elf_howto_table2
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set the howto pointer for an XSTORMY16 ELF reloc.  */
end_comment

begin_function
specifier|static
name|void
name|xstormy16_info_to_howto_rela
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|cache_ptr
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|dst
parameter_list|)
block|{
name|unsigned
name|int
name|r_type
init|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
decl_stmt|;
if|if
condition|(
name|r_type
operator|<=
operator|(
name|unsigned
name|int
operator|)
name|R_XSTORMY16_12
condition|)
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|xstormy16_elf_howto_table
index|[
name|r_type
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|r_type
operator|-
name|R_XSTORMY16_GNU_VTINHERIT
operator|<=
operator|(
name|unsigned
name|int
operator|)
name|R_XSTORMY16_GNU_VTENTRY
condition|)
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|xstormy16_elf_howto_table2
index|[
name|r_type
operator|-
name|R_XSTORMY16_GNU_VTINHERIT
index|]
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We support 16-bit pointers to code above 64k by generating a thunk    below 64k containing a JMPF instruction to the final address.  We    cannot, unfortunately, minimize the number of thunks unless the    -relax switch is given, as otherwise we have no idea where the    sections will fall in the address space.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xstormy16_elf_check_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|bfd_vma
modifier|*
name|local_plt_offsets
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_plt_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|splt
operator|=
name|NULL
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
operator|++
name|rel
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
modifier|*
name|offset
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
comment|/* This relocation describes a 16-bit pointer to a function. 	     We may need to allocate a thunk in low memory; reserve memory 	     for it now.  */
case|case
name|R_XSTORMY16_FPTR16
case|:
if|if
condition|(
name|rel
operator|->
name|r_addend
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|_
argument_list|(
literal|"non-zero addend in @fptr reloc"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|abfd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
name|splt
operator|==
name|NULL
condition|)
block|{
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|splt
operator|==
name|NULL
condition|)
block|{
name|splt
operator|=
name|bfd_make_section_with_flags
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator||
name|SEC_CODE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|splt
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|splt
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|offset
operator|=
operator|&
name|h
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
else|else
block|{
if|if
condition|(
name|local_plt_offsets
operator|==
name|NULL
condition|)
block|{
name|size_t
name|size
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|size
operator|=
name|symtab_hdr
operator|->
name|sh_info
operator|*
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
expr_stmt|;
name|local_plt_offsets
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_plt_offsets
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_local_got_offsets
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_plt_offsets
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|;
name|i
operator|++
control|)
name|local_plt_offsets
index|[
name|i
index|]
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|offset
operator|=
operator|&
name|local_plt_offsets
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
operator|*
name|offset
operator|=
name|splt
operator|->
name|size
expr_stmt|;
name|splt
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
comment|/* This relocation describes the C++ object vtable hierarchy. 	     Reconstruct it for later use during GC.  */
case|case
name|R_XSTORMY16_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually 	     used.  Record for later use during GC.  */
case|case
name|R_XSTORMY16_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|bfd_elf_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of xstormy16_elf_relax_section.  If the global symbol H    is within the low 64k, remove any entry for it in the plt.  */
end_comment

begin_struct
struct|struct
name|relax_plt_data
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|bfd_boolean
modifier|*
name|again
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|bfd_boolean
name|xstormy16_relax_plt_check
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|xdata
parameter_list|)
block|{
name|struct
name|relax_plt_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|relax_plt_data
operator|*
operator|)
name|xdata
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|bfd_vma
name|address
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|address
operator|=
literal|0
expr_stmt|;
else|else
name|address
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|)
expr_stmt|;
if|if
condition|(
name|address
operator|<=
literal|0xffff
condition|)
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
name|data
operator|->
name|splt
operator|->
name|size
operator|-=
literal|4
expr_stmt|;
operator|*
name|data
operator|->
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of xstormy16_elf_relax_section.  If the global symbol H    previously had a plt entry, give it a new entry offset.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xstormy16_relax_plt_realloc
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|xdata
parameter_list|)
block|{
name|bfd_vma
modifier|*
name|entry
init|=
operator|(
name|bfd_vma
operator|*
operator|)
name|xdata
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|*
name|entry
expr_stmt|;
operator|*
name|entry
operator|+=
literal|4
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|xstormy16_elf_relax_section
parameter_list|(
name|bfd
modifier|*
name|dynobj
parameter_list|,
name|asection
modifier|*
name|splt
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_boolean
modifier|*
name|again
parameter_list|)
block|{
name|struct
name|relax_plt_data
name|relax_plt_data
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
comment|/* Assume nothing changes.  */
operator|*
name|again
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
comment|/* We only relax the .plt section at the moment.  */
if|if
condition|(
name|dynobj
operator|!=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|||
name|strcmp
argument_list|(
name|splt
operator|->
name|name
argument_list|,
literal|".plt"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* Quick check for an empty plt.  */
if|if
condition|(
name|splt
operator|->
name|size
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* Map across all global symbols; see which ones happen to      fall in the low 64k.  */
name|relax_plt_data
operator|.
name|splt
operator|=
name|splt
expr_stmt|;
name|relax_plt_data
operator|.
name|again
operator|=
name|again
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|xstormy16_relax_plt_check
argument_list|,
operator|&
name|relax_plt_data
argument_list|)
expr_stmt|;
comment|/* Likewise for local symbols, though that's somewhat less convenient      as we have to walk the list of input bfds and swap in symbol data.  */
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|bfd_vma
modifier|*
name|local_plt_offsets
init|=
name|elf_local_got_offsets
argument_list|(
name|ibfd
argument_list|)
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
if|if
condition|(
operator|!
name|local_plt_offsets
condition|)
continue|continue;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|ibfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|;
operator|++
name|idx
control|)
block|{
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|asection
modifier|*
name|tsec
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
if|if
condition|(
name|local_plt_offsets
index|[
name|idx
index|]
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
continue|continue;
name|isym
operator|=
operator|&
name|isymbuf
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|tsec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|tsec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
name|tsec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|ibfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|address
operator|=
operator|(
name|tsec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|tsec
operator|->
name|output_offset
operator|+
name|isym
operator|->
name|st_value
operator|)
expr_stmt|;
if|if
condition|(
name|address
operator|<=
literal|0xffff
condition|)
block|{
name|local_plt_offsets
index|[
name|idx
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|splt
operator|->
name|size
operator|-=
literal|4
expr_stmt|;
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the symbols for elf_link_input_bfd.  */
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
block|}
block|}
block|}
comment|/* If we changed anything, walk the symbols again to reallocate      .plt entry addresses.  */
if|if
condition|(
operator|*
name|again
operator|&&
name|splt
operator|->
name|size
operator|>
literal|0
condition|)
block|{
name|bfd_vma
name|entry
init|=
literal|0
decl_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|xstormy16_relax_plt_realloc
argument_list|,
operator|&
name|entry
argument_list|)
expr_stmt|;
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|bfd_vma
modifier|*
name|local_plt_offsets
init|=
name|elf_local_got_offsets
argument_list|(
name|ibfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|nlocals
init|=
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_info
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
if|if
condition|(
operator|!
name|local_plt_offsets
condition|)
continue|continue;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|nlocals
condition|;
operator|++
name|idx
control|)
if|if
condition|(
name|local_plt_offsets
index|[
name|idx
index|]
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|local_plt_offsets
index|[
name|idx
index|]
operator|=
name|entry
expr_stmt|;
name|entry
operator|+=
literal|4
expr_stmt|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|xstormy16_elf_always_size_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|splt
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|splt
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|splt
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Relocate an XSTORMY16 ELF section.     The RELOCATE_SECTION function is called by the new ELF backend linker    to handle the relocations for a section.     The relocs are always passed as Rela structures; if the section    actually uses Rel structures, the r_addend field will always be    zero.     This function is responsible for adjusting the section contents as    necessary, and (if using Rela relocs and generating a relocatable    output file) adjusting the reloc addend as necessary.     This function does not have to worry about setting the reloc    address or the reloc symbol index.     LOCAL_SYMS is a pointer to the swapped in local symbols.     LOCAL_SECTIONS is an array giving the section in the input file    corresponding to the st_shndx field of each local symbol.     The global hash table entry for the global symbols can be found    via elf_sym_hashes (input_bfd).     When generating relocatable output, this function must handle    STB_LOCAL/STT_SECTION symbols specially.  The output symbol is    going to be the section symbol corresponding to the output    section, which means that the addend must be adjusted    accordingly.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xstormy16_elf_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|splt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dynobj
operator|!=
name|NULL
condition|)
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_XSTORMY16_GNU_VTINHERIT
operator|||
name|r_type
operator|==
name|R_XSTORMY16_GNU_VTENTRY
condition|)
continue|continue;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|howto
operator|=
name|xstormy16_elf_howto_table
operator|+
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_boolean
name|unresolved_reloc
decl_stmt|,
name|warned
decl_stmt|;
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|elf_discarded_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
comment|/* For relocs against symbols from removed linkonce sections, 	     or sections discarded by a linker script, we just want the 	     section contents zeroed.  Avoid any special processing.  */
name|_bfd_clear_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
continue|continue;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_XSTORMY16_24
case|:
block|{
name|bfd_vma
name|reloc
init|=
name|relocation
operator|+
name|rel
operator|->
name|r_addend
decl_stmt|;
name|unsigned
name|int
name|x
decl_stmt|;
name|x
operator|=
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|x
operator|&=
literal|0x0000ff00
expr_stmt|;
name|x
operator||=
name|reloc
operator|&
literal|0xff
expr_stmt|;
name|x
operator||=
operator|(
name|reloc
operator|<<
literal|8
operator|)
operator|&
literal|0xffff0000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc
operator|&
operator|~
literal|0xffffff
condition|)
name|r
operator|=
name|bfd_reloc_overflow
expr_stmt|;
else|else
name|r
operator|=
name|bfd_reloc_ok
expr_stmt|;
break|break;
block|}
case|case
name|R_XSTORMY16_FPTR16
case|:
block|{
name|bfd_vma
modifier|*
name|plt_offset
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|plt_offset
operator|=
operator|&
name|h
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
else|else
name|plt_offset
operator|=
name|elf_local_got_offsets
argument_list|(
name|input_bfd
argument_list|)
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
name|relocation
operator|<=
literal|0xffff
condition|)
block|{
comment|/* If the symbol is in range for a 16-bit address, we should 		   have deallocated the plt entry in relax_section.  */
name|BFD_ASSERT
argument_list|(
operator|*
name|plt_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the symbol is out of range for a 16-bit address, 		   we must have allocated a plt entry.  */
name|BFD_ASSERT
argument_list|(
operator|*
name|plt_offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* If this is the first time we've processed this symbol, 		   fill in the plt entry with the correct symbol address.  */
if|if
condition|(
operator|(
operator|*
name|plt_offset
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|int
name|x
decl_stmt|;
name|x
operator|=
literal|0x00000200
expr_stmt|;
comment|/* jmpf */
name|x
operator||=
name|relocation
operator|&
literal|0xff
expr_stmt|;
name|x
operator||=
operator|(
name|relocation
operator|<<
literal|8
operator|)
operator|&
literal|0xffff0000
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|splt
operator|->
name|contents
operator|+
operator|*
name|plt_offset
argument_list|)
expr_stmt|;
operator|*
name|plt_offset
operator||=
literal|1
expr_stmt|;
block|}
name|relocation
operator|=
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
operator|(
operator|*
name|plt_offset
operator|&
operator|-
literal|2
operator|)
operator|)
expr_stmt|;
block|}
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_overflow
case|:
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
argument_list|(
name|info
argument_list|,
operator|(
name|h
condition|?
operator|&
name|h
operator|->
name|root
else|:
name|NULL
operator|)
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_undefined
case|:
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: out of range error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_notsupported
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unsupported relocation error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_dangerous
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: dangerous relocation"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unknown error"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|msg
condition|)
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This must exist if dynobj is ever set.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|xstormy16_elf_finish_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
comment|/* As an extra sanity check, verify that all plt entries have      been filled in.  */
if|if
condition|(
operator|(
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bfd_byte
modifier|*
name|contents
init|=
name|splt
operator|->
name|contents
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|size
init|=
name|splt
operator|->
name|size
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|unsigned
name|int
name|x
init|=
name|bfd_get_32
argument_list|(
name|dynobj
argument_list|,
name|contents
operator|+
name|i
argument_list|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|x
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the section that should be marked against GC for a given    relocation.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|xstormy16_elf_gc_mark_hook
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_XSTORMY16_GNU_VTINHERIT
case|:
case|case
name|R_XSTORMY16_GNU_VTENTRY
case|:
return|return
name|NULL
return|;
block|}
return|return
name|_bfd_elf_gc_mark_hook
argument_list|(
name|sec
argument_list|,
name|info
argument_list|,
name|rel
argument_list|,
name|h
argument_list|,
name|sym
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_xstormy16
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_XSTORMY16
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x100
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_xstormy16_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-xstormy16"
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|NULL
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|xstormy16_info_to_howto_rela
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|xstormy16_elf_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|xstormy16_elf_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|xstormy16_elf_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_always_size_sections
define|\
value|xstormy16_elf_always_size_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_omit_section_dynsym
define|\
value|((bfd_boolean (*) (bfd *, struct bfd_link_info *, asection *)) bfd_true)
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
define|\
value|xstormy16_elf_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_rela_normal
value|1
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|xstormy16_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_name_lookup
define|\
value|xstormy16_reloc_name_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_relax_section
value|xstormy16_elf_relax_section
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

