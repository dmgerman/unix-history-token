begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* vms.c -- BFD back-end for VAX (openVMS/VAX) and    EVAX (openVMS/Alpha) files.    Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,    2006 Free Software Foundation, Inc.     Written by Klaus K"ampf (kkaempf@rmi.de)     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"vms.h"
end_include

begin_define
define|#
directive|define
name|vms_bfd_is_target_special_symbol
value|((bfd_boolean (*) (bfd *, asymbol *)) bfd_false)
end_define

begin_define
define|#
directive|define
name|vms_make_empty_symbol
value|_bfd_generic_make_empty_symbol
end_define

begin_define
define|#
directive|define
name|vms_bfd_link_just_syms
value|_bfd_generic_link_just_syms
end_define

begin_define
define|#
directive|define
name|vms_bfd_is_group_section
value|bfd_generic_is_group_section
end_define

begin_define
define|#
directive|define
name|vms_bfd_discard_group
value|bfd_generic_discard_group
end_define

begin_define
define|#
directive|define
name|vms_section_already_linked
value|_bfd_generic_section_already_linked
end_define

begin_define
define|#
directive|define
name|vms_bfd_copy_private_header_data
value|_bfd_generic_bfd_copy_private_header_data
end_define

begin_define
define|#
directive|define
name|vms_get_synthetic_symtab
value|_bfd_nodynamic_get_synthetic_symtab
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|priv_section_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
name|vms_vax_vec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
name|vms_alpha_vec
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize private data.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_initialize
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|bfd_set_start_address
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|vms_private_data_struct
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
ifdef|#
directive|ifdef
name|__ALPHA
name|PRIV
argument_list|(
name|is_vax
argument_list|)
operator|=
name|FALSE
expr_stmt|;
else|#
directive|else
name|PRIV
argument_list|(
name|is_vax
argument_list|)
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
name|PRIV
argument_list|(
name|vms_buf
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|PRIV
argument_list|(
name|buf_size
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PRIV
argument_list|(
name|rec_length
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PRIV
argument_list|(
name|file_format
argument_list|)
operator|=
name|FF_UNKNOWN
expr_stmt|;
name|PRIV
argument_list|(
name|fixup_done
argument_list|)
operator|=
name|FALSE
expr_stmt|;
name|PRIV
argument_list|(
name|sections
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|stack_struct
argument_list|)
operator|*
name|STACKSIZE
expr_stmt|;
name|PRIV
argument_list|(
name|stack
argument_list|)
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|PRIV
argument_list|(
name|stack
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|error_ret1
goto|;
name|PRIV
argument_list|(
name|stackptr
argument_list|)
operator|=
literal|0
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|bfd_hash_table
argument_list|)
expr_stmt|;
name|PRIV
argument_list|(
name|vms_symbol_table
argument_list|)
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|PRIV
argument_list|(
name|vms_symbol_table
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|error_ret1
goto|;
if|if
condition|(
operator|!
name|bfd_hash_table_init
argument_list|(
name|PRIV
argument_list|(
name|vms_symbol_table
argument_list|)
argument_list|,
name|_bfd_vms_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
name|vms_symbol_entry
argument_list|)
argument_list|)
condition|)
goto|goto
name|error_ret1
goto|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|location_struct
argument_list|)
operator|*
name|LOCATION_SAVE_SIZE
expr_stmt|;
name|PRIV
argument_list|(
name|location_stack
argument_list|)
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|PRIV
argument_list|(
name|location_stack
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|error_ret2
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VMS_SECTION_COUNT
condition|;
name|i
operator|++
control|)
name|PRIV
argument_list|(
name|vms_section_table
argument_list|)
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|amt
operator|=
name|MAX_OUTREC_SIZE
expr_stmt|;
name|PRIV
argument_list|(
name|output_buf
argument_list|)
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|PRIV
argument_list|(
name|output_buf
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|error_ret2
goto|;
name|PRIV
argument_list|(
name|push_level
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PRIV
argument_list|(
name|pushed_size
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PRIV
argument_list|(
name|length_pos
argument_list|)
operator|=
literal|2
expr_stmt|;
name|PRIV
argument_list|(
name|output_size
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PRIV
argument_list|(
name|output_alignment
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
name|error_ret2
label|:
name|bfd_hash_table_free
argument_list|(
name|PRIV
argument_list|(
name|vms_symbol_table
argument_list|)
argument_list|)
expr_stmt|;
name|error_ret1
label|:
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|abfd
operator|->
name|tdata
operator|.
name|any
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|=
name|NULL
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Fill symbol->section with section ptr    symbol->section is filled with the section index for defined symbols    during reading the GSD/EGSD section. But we need the pointer to the    bfd section later.     It has the correct value for referenced (undefined section) symbols     called from bfd_hash_traverse in vms_fixup_sections.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|fill_section_ptr
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|sections
parameter_list|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
operator|(
operator|(
name|vms_symbol_entry
operator|*
operator|)
name|entry
operator|)
operator|->
name|symbol
expr_stmt|;
name|sec
operator|=
name|sym
operator|->
name|section
expr_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|6
argument_list|,
literal|"fill_section_ptr: sym %p, sec %p\n"
argument_list|,
name|sym
argument_list|,
name|sec
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Fill forward references (these contain section number, not section ptr).  */
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
operator|(
name|size_t
operator|)
name|sec
operator|<
name|priv_section_count
condition|)
name|sec
operator|=
operator|(
operator|(
name|vms_symbol_entry
operator|*
operator|)
name|entry
operator|)
operator|->
name|symbol
operator|->
name|section
operator|=
operator|(
operator|(
name|asection
operator|*
operator|*
operator|)
name|sections
operator|)
index|[
operator|(
name|unsigned
name|int
operator|)
operator|(
name|size_t
operator|)
name|sec
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sym
operator|->
name|name
argument_list|,
name|sec
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|flags
operator||=
name|BSF_SECTION_SYM
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Fixup sections    set up all pointers and arrays, counters and sizes are fixed now     we build a private sections vector for easy access since sections    are always referenced by an index number.     alloc PRIV(sections) according to abfd->section_count 	copy abfd->sections to PRIV(sections).  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_fixup_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|PRIV
argument_list|(
name|fixup_done
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* Traverse symbol table and fill in all section pointers.  */
comment|/* Can't provide section count as argument to fill_section_ptr().  */
name|priv_section_count
operator|=
name|PRIV
argument_list|(
name|section_count
argument_list|)
expr_stmt|;
name|bfd_hash_traverse
argument_list|(
name|PRIV
argument_list|(
name|vms_symbol_table
argument_list|)
argument_list|,
name|fill_section_ptr
argument_list|,
operator|(
name|PRIV
argument_list|(
name|sections
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|PRIV
argument_list|(
name|fixup_done
argument_list|)
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check the format for a file being read.    Return a (bfd_target *) if it's an object file or zero if not.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|bfd_target
modifier|*
name|vms_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|prev_type
decl_stmt|;
specifier|const
name|struct
name|bfd_target
modifier|*
name|target_vector
init|=
name|NULL
decl_stmt|;
specifier|const
name|bfd_arch_info_type
modifier|*
name|arch
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|tdata_save
init|=
name|abfd
operator|->
name|tdata
operator|.
name|any
decl_stmt|;
name|bfd_vma
name|saddr_save
init|=
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_object_p (%p)\n"
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|vms_initialize
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|error_ret
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
condition|)
goto|goto
name|err_wrong_format
goto|;
name|prev_type
operator|=
operator|-
literal|1
expr_stmt|;
do|do
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|7
argument_list|,
literal|"reading at %08lx\n"
argument_list|,
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|_bfd_vms_next_record
argument_list|(
name|abfd
argument_list|)
operator|<
literal|0
condition|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|2
argument_list|,
literal|"next_record failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|err_wrong_format
goto|;
block|}
if|if
condition|(
operator|(
name|prev_type
operator|==
name|EOBJ_S_C_EGSD
operator|)
operator|&&
operator|(
name|PRIV
argument_list|(
name|rec_type
argument_list|)
operator|!=
name|EOBJ_S_C_EGSD
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|vms_fixup_sections
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|2
argument_list|,
literal|"vms_fixup_sections failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|err_wrong_format
goto|;
block|}
block|}
name|prev_type
operator|=
name|PRIV
argument_list|(
name|rec_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_vector
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|prev_type
operator|<=
name|OBJ_S_C_MAXRECTYP
condition|)
name|target_vector
operator|=
operator|&
name|vms_vax_vec
expr_stmt|;
else|else
name|target_vector
operator|=
operator|&
name|vms_alpha_vec
expr_stmt|;
block|}
switch|switch
condition|(
name|prev_type
condition|)
block|{
case|case
name|OBJ_S_C_HDR
case|:
case|case
name|EOBJ_S_C_EMH
case|:
name|err
operator|=
name|_bfd_vms_slurp_hdr
argument_list|(
name|abfd
argument_list|,
name|prev_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJ_S_C_EOM
case|:
case|case
name|OBJ_S_C_EOMW
case|:
case|case
name|EOBJ_S_C_EEOM
case|:
name|err
operator|=
name|_bfd_vms_slurp_eom
argument_list|(
name|abfd
argument_list|,
name|prev_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJ_S_C_GSD
case|:
case|case
name|EOBJ_S_C_EGSD
case|:
name|err
operator|=
name|_bfd_vms_slurp_gsd
argument_list|(
name|abfd
argument_list|,
name|prev_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJ_S_C_TIR
case|:
case|case
name|EOBJ_S_C_ETIR
case|:
name|err
operator|=
name|_bfd_vms_slurp_tir
argument_list|(
name|abfd
argument_list|,
name|prev_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJ_S_C_DBG
case|:
case|case
name|EOBJ_S_C_EDBG
case|:
name|err
operator|=
name|_bfd_vms_slurp_dbg
argument_list|(
name|abfd
argument_list|,
name|prev_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJ_S_C_TBT
case|:
case|case
name|EOBJ_S_C_ETBT
case|:
name|err
operator|=
name|_bfd_vms_slurp_tbt
argument_list|(
name|abfd
argument_list|,
name|prev_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|OBJ_S_C_LNK
case|:
name|err
operator|=
name|_bfd_vms_slurp_lnk
argument_list|(
name|abfd
argument_list|,
name|prev_type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|2
argument_list|,
literal|"slurp type %d failed with %d\n"
argument_list|,
name|prev_type
argument_list|,
name|err
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|err_wrong_format
goto|;
block|}
block|}
do|while
condition|(
operator|(
name|prev_type
operator|!=
name|EOBJ_S_C_EEOM
operator|)
operator|&&
operator|(
name|prev_type
operator|!=
name|OBJ_S_C_EOM
operator|)
operator|&&
operator|(
name|prev_type
operator|!=
name|OBJ_S_C_EOMW
operator|)
condition|)
do|;
if|if
condition|(
name|target_vector
operator|==
operator|&
name|vms_vax_vec
condition|)
block|{
if|if
condition|(
operator|!
name|vms_fixup_sections
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|2
argument_list|,
literal|"vms_fixup_sections failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|err_wrong_format
goto|;
block|}
comment|/* Set arch_info to vax.  */
name|arch
operator|=
name|bfd_scan_arch
argument_list|(
literal|"vax"
argument_list|)
expr_stmt|;
name|PRIV
argument_list|(
name|is_vax
argument_list|)
operator|=
name|TRUE
expr_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|2
argument_list|,
literal|"arch is vax\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|target_vector
operator|==
operator|&
name|vms_alpha_vec
condition|)
block|{
comment|/* Set arch_info to alpha.   */
name|arch
operator|=
name|bfd_scan_arch
argument_list|(
literal|"alpha"
argument_list|)
expr_stmt|;
name|PRIV
argument_list|(
name|is_vax
argument_list|)
operator|=
name|FALSE
expr_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|2
argument_list|,
literal|"arch is alpha\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|arch
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|2
argument_list|,
literal|"arch not found\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|err_wrong_format
goto|;
block|}
name|abfd
operator|->
name|arch_info
operator|=
name|arch
expr_stmt|;
return|return
name|target_vector
return|;
name|err_wrong_format
label|:
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
name|error_ret
label|:
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|!=
name|tdata_save
operator|&&
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|!=
name|NULL
condition|)
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|abfd
operator|->
name|tdata
operator|.
name|any
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|=
name|tdata_save
expr_stmt|;
name|bfd_set_start_address
argument_list|(
name|abfd
argument_list|,
name|saddr_save
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Check the format for a file being read.    Return a (bfd_target *) if it's an archive file or zero.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|bfd_target
modifier|*
name|vms_archive_p
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_archive_p (%p)\n"
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set the format of a file being written.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_mkobject
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_mkobject (%p)\n"
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|vms_initialize
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|{
ifdef|#
directive|ifdef
name|__VAX
specifier|const
name|bfd_arch_info_type
modifier|*
name|arch
init|=
name|bfd_scan_arch
argument_list|(
literal|"vax"
argument_list|)
decl_stmt|;
else|#
directive|else
specifier|const
name|bfd_arch_info_type
modifier|*
name|arch
init|=
name|bfd_scan_arch
argument_list|(
literal|"alpha"
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|arch
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|abfd
operator|->
name|arch_info
operator|=
name|arch
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Write cached information into a file being written, at bfd_close.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_write_object_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_write_object_contents (%p)\n"
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|abfd
operator|->
name|section_count
operator|>
literal|0
condition|)
comment|/* we have sections */
block|{
if|if
condition|(
name|PRIV
argument_list|(
name|is_vax
argument_list|)
condition|)
block|{
if|if
condition|(
name|_bfd_vms_write_hdr
argument_list|(
name|abfd
argument_list|,
name|OBJ_S_C_HDR
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|_bfd_vms_write_gsd
argument_list|(
name|abfd
argument_list|,
name|OBJ_S_C_GSD
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|_bfd_vms_write_tir
argument_list|(
name|abfd
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|_bfd_vms_write_tbt
argument_list|(
name|abfd
argument_list|,
name|OBJ_S_C_TBT
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|_bfd_vms_write_dbg
argument_list|(
name|abfd
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|abfd
operator|->
name|section_count
operator|>
literal|255
condition|)
block|{
if|if
condition|(
name|_bfd_vms_write_eom
argument_list|(
name|abfd
argument_list|,
name|OBJ_S_C_EOMW
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
if|if
condition|(
name|_bfd_vms_write_eom
argument_list|(
name|abfd
argument_list|,
name|OBJ_S_C_EOM
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|_bfd_vms_write_hdr
argument_list|(
name|abfd
argument_list|,
name|EOBJ_S_C_EMH
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|_bfd_vms_write_gsd
argument_list|(
name|abfd
argument_list|,
name|EOBJ_S_C_EGSD
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|_bfd_vms_write_tir
argument_list|(
name|abfd
argument_list|,
name|EOBJ_S_C_ETIR
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|_bfd_vms_write_tbt
argument_list|(
name|abfd
argument_list|,
name|EOBJ_S_C_ETBT
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|_bfd_vms_write_dbg
argument_list|(
name|abfd
argument_list|,
name|EOBJ_S_C_EDBG
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|_bfd_vms_write_eom
argument_list|(
name|abfd
argument_list|,
name|EOBJ_S_C_EEOM
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* 4.1, generic.  */
end_comment

begin_comment
comment|/* Called when the BFD is being closed to do any necessary cleanup.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_close_and_cleanup
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_close_and_cleanup (%p)\n"
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|abfd
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|PRIV
argument_list|(
name|vms_buf
argument_list|)
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|PRIV
argument_list|(
name|vms_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PRIV
argument_list|(
name|sections
argument_list|)
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|PRIV
argument_list|(
name|sections
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PRIV
argument_list|(
name|vms_symbol_table
argument_list|)
condition|)
name|bfd_hash_table_free
argument_list|(
name|PRIV
argument_list|(
name|vms_symbol_table
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|abfd
operator|->
name|tdata
operator|.
name|any
argument_list|)
expr_stmt|;
name|abfd
operator|->
name|tdata
operator|.
name|any
operator|=
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Ask the BFD to free all cached information.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_bfd_free_cached_info
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_bfd_free_cached_info (%p)\n"
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Called when a new section is created.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_new_section_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|)
block|{
comment|/* Count hasn't been incremented yet.  */
name|unsigned
name|int
name|section_count
init|=
name|abfd
operator|->
name|section_count
operator|+
literal|1
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_new_section_hook (%p, [%d]%s), count %d\n"
argument_list|,
name|abfd
argument_list|,
name|section
operator|->
name|index
argument_list|,
name|section
operator|->
name|name
argument_list|,
name|section_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_count
operator|>
name|PRIV
argument_list|(
name|section_count
argument_list|)
condition|)
block|{
name|bfd_size_type
name|amt
init|=
name|section_count
decl_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|PRIV
argument_list|(
name|sections
argument_list|)
operator|=
name|bfd_realloc
argument_list|(
name|PRIV
argument_list|(
name|sections
argument_list|)
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|PRIV
argument_list|(
name|sections
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|PRIV
argument_list|(
name|section_count
argument_list|)
operator|=
name|section_count
expr_stmt|;
block|}
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|6
argument_list|,
literal|"section_count: %d\n"
argument_list|,
name|PRIV
argument_list|(
name|section_count
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PRIV
argument_list|(
name|sections
argument_list|)
index|[
name|section
operator|->
name|index
index|]
operator|=
name|section
expr_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|7
argument_list|,
literal|"%d: %s\n"
argument_list|,
name|section
operator|->
name|index
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Read the contents of a section.    buf points to a buffer of buf_size bytes to be filled with    section data (starting at offset into section)  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_get_section_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|buf
name|ATTRIBUTE_UNUSED
parameter_list|,
name|file_ptr
name|offset
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_size_type
name|buf_size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_get_section_contents (%p, %s, %p, off %ld, size %d)\n"
argument_list|,
name|abfd
argument_list|,
name|section
operator|->
name|name
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|,
operator|(
name|int
operator|)
name|buf_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Shouldn't be called, since all sections are IN_MEMORY.  */
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Read the contents of a section.    buf points to a buffer of buf_size bytes to be filled with    section data (starting at offset into section).  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_get_section_contents_in_window
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_window
modifier|*
name|w
name|ATTRIBUTE_UNUSED
parameter_list|,
name|file_ptr
name|offset
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_size_type
name|count
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_get_section_contents_in_window (%p, %s, %p, off %ld, count %d)\n"
argument_list|,
name|abfd
argument_list|,
name|section
operator|->
name|name
argument_list|,
name|w
argument_list|,
name|offset
argument_list|,
operator|(
name|int
operator|)
name|count
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Shouldn't be called, since all sections are IN_MEMORY.  */
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Part 4.2, copy private data.  */
end_comment

begin_comment
comment|/* Called to copy BFD general private data from one object file    to another.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_bfd_copy_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|src
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd
modifier|*
name|dest
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_bfd_copy_private_bfd_data (%p, %p)\n"
argument_list|,
name|src
argument_list|,
name|dest
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Merge private BFD information from the BFD @var{ibfd} to the    the output file BFD @var{obfd} when linking.  Return<<TRUE>>    on success,<<FALSE>> on error.  Possible error returns are:     o<<bfd_error_no_memory>> -      Not enough memory exists to create private data for @var{obfd}.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_bfd_merge_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd
modifier|*
name|obfd
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_bfd_merge_private_bfd_data (%p, %p)\n"
argument_list|,
name|ibfd
argument_list|,
name|obfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Set private BFD flag information in the BFD @var{abfd}.    Return<<TRUE>> on success,<<FALSE>> on error.  Possible error    returns are:     o<<bfd_error_no_memory>> -      Not enough memory exists to create private data for @var{obfd}.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_bfd_set_private_flags
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|flagword
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_bfd_set_private_flags (%p, %lx)\n"
argument_list|,
name|abfd
argument_list|,
operator|(
name|long
operator|)
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Called to copy BFD private section data from one object file    to another.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_bfd_copy_private_section_data
parameter_list|(
name|bfd
modifier|*
name|srcbfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|srcsec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd
modifier|*
name|dstbfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|dstsec
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_bfd_copy_private_section_data (%p, %s, %p, %s)\n"
argument_list|,
name|srcbfd
argument_list|,
name|srcsec
operator|->
name|name
argument_list|,
name|dstbfd
argument_list|,
name|dstsec
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Called to copy BFD private symbol data from one object file    to another.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_bfd_copy_private_symbol_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
name|isym
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd
modifier|*
name|obfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
name|osym
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_bfd_copy_private_symbol_data (%p, %s, %p, %s)\n"
argument_list|,
name|ibfd
argument_list|,
name|isym
operator|->
name|name
argument_list|,
name|obfd
argument_list|,
name|osym
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Part 4.3, core file.  */
end_comment

begin_comment
comment|/* Return a read-only string explaining which program was running    when it failed and produced the core file abfd.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|vms_core_file_failing_command
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_core_file_failing_command (%p)\n"
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Returns the signal number which caused the core dump which    generated the file the BFD abfd is attached to.  */
end_comment

begin_function
specifier|static
name|int
name|vms_core_file_failing_signal
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_core_file_failing_signal (%p)\n"
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the core file attached to core_bfd was generated    by a run of the executable file attached to exec_bfd, FALSE otherwise.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_core_file_matches_executable_p
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd
modifier|*
name|bbfd
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_core_file_matches_executable_p (%p, %p)\n"
argument_list|,
name|abfd
argument_list|,
name|bbfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Part 4.4, archive.  */
end_comment

begin_comment
comment|/* ???	do something with an archive map.    Return FALSE on error, TRUE otherwise.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_slurp_armap
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_slurp_armap (%p)\n"
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* ???	do something with an extended name table.    Return FALSE on error, TRUE otherwise.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_slurp_extended_name_table
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_slurp_extended_name_table (%p)\n"
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* ???	do something with an extended name table.    Return FALSE on error, TRUE otherwise.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_construct_extended_name_table
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
modifier|*
name|tabloc
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_size_type
modifier|*
name|tablen
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_construct_extended_name_table (%p)\n"
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Truncate the name of an archive to match system-dependent restrictions.  */
end_comment

begin_function
specifier|static
name|void
name|vms_truncate_arname
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
name|arhdr
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_truncate_arname (%p, %s, %s)\n"
argument_list|,
name|abfd
argument_list|,
name|pathname
argument_list|,
name|arhdr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_comment
comment|/* ???	write archive map.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_write_armap
parameter_list|(
name|bfd
modifier|*
name|arch
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|elength
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|orl
modifier|*
name|map
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|orl_count
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|stridx
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_write_armap (%p, %d, %p, %d %d)\n"
argument_list|,
name|arch
argument_list|,
name|elength
argument_list|,
name|map
argument_list|,
name|orl_count
argument_list|,
name|stridx
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Read archive header ???  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|vms_read_ar_hdr
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_read_ar_hdr (%p)\n"
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Provided a BFD, @var{archive}, containing an archive and NULL, open    an input BFD on the first contained element and returns that.    Subsequent calls should pass the archive and the previous return value    to return a created BFD to the next contained element.    NULL is returned when there are no more.  */
end_comment

begin_function
specifier|static
name|bfd
modifier|*
name|vms_openr_next_archived_file
parameter_list|(
name|bfd
modifier|*
name|arch
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd
modifier|*
name|prev
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_openr_next_archived_file (%p, %p)\n"
argument_list|,
name|arch
argument_list|,
name|prev
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the BFD which is referenced by the symbol in ABFD indexed by    INDEX.  INDEX should have been returned by bfd_get_next_mapent.  */
end_comment

begin_function
specifier|static
name|bfd
modifier|*
name|vms_get_elt_at_index
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|symindex
name|index
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_get_elt_at_index (%p, %p)\n"
argument_list|,
name|abfd
argument_list|,
name|index
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|_bfd_generic_get_elt_at_index
argument_list|(
name|abfd
argument_list|,
name|index
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ???    -> bfd_generic_stat_arch_elt.  */
end_comment

begin_function
specifier|static
name|int
name|vms_generic_stat_arch_elt
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_generic_stat_arch_elt (%p, %p)\n"
argument_list|,
name|abfd
argument_list|,
name|st
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|bfd_generic_stat_arch_elt
argument_list|(
name|abfd
argument_list|,
name|st
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This is a new function in bfd 2.5.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_update_armap_timestamp
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_update_armap_timestamp (%p)\n"
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Part 4.5, symbols.  */
end_comment

begin_comment
comment|/* Return the number of bytes required to store a vector of pointers    to asymbols for all the symbols in the BFD abfd, including a    terminal NULL pointer. If there are no symbols in the BFD,    then return 0.  If an error occurs, return -1.  */
end_comment

begin_function
specifier|static
name|long
name|vms_get_symtab_upper_bound
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_get_symtab_upper_bound (%p), %d symbols\n"
argument_list|,
name|abfd
argument_list|,
name|PRIV
argument_list|(
name|gsd_sym_count
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|PRIV
argument_list|(
name|gsd_sym_count
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Copy symbols from hash table to symbol vector     called from bfd_hash_traverse in vms_canonicalize_symtab    init counter to 0 if entry == 0.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|copy_symbols
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
init|=
operator|(
name|bfd
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
comment|/* Init counter.  */
name|PRIV
argument_list|(
name|symnum
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
comment|/* Fill vector, inc counter.  */
name|PRIV
argument_list|(
name|symcache
argument_list|)
index|[
name|PRIV
argument_list|(
name|symnum
argument_list|)
operator|++
index|]
operator|=
operator|(
operator|(
name|vms_symbol_entry
operator|*
operator|)
name|entry
operator|)
operator|->
name|symbol
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Read the symbols from the BFD abfd, and fills in the vector    location with pointers to the symbols and a trailing NULL.     Return number of symbols read.   */
end_comment

begin_function
specifier|static
name|long
name|vms_canonicalize_symtab
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_canonicalize_symtab (%p,<ret>)\n"
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Init counter.  */
name|copy_symbols
argument_list|(
name|NULL
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
comment|/* Traverse table and fill symbols vector.  */
name|PRIV
argument_list|(
name|symcache
argument_list|)
operator|=
name|symbols
expr_stmt|;
name|bfd_hash_traverse
argument_list|(
name|PRIV
argument_list|(
name|vms_symbol_table
argument_list|)
argument_list|,
name|copy_symbols
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|symbols
index|[
name|PRIV
argument_list|(
name|gsd_sym_count
argument_list|)
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|PRIV
argument_list|(
name|gsd_sym_count
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Print symbol to file according to how. how is one of    bfd_print_symbol_name	just print the name    bfd_print_symbol_more	print more (???)    bfd_print_symbol_all	print all we know, which is not much right now :-).  */
end_comment

begin_function
specifier|static
name|void
name|vms_print_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|void
modifier|*
name|file
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|bfd_print_symbol_type
name|how
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_print_symbol (%p, %p, %p, %d)\n"
argument_list|,
name|abfd
argument_list|,
name|file
argument_list|,
name|symbol
argument_list|,
name|how
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
case|case
name|bfd_print_symbol_more
case|:
name|fprintf
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|file
argument_list|,
literal|" %s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_all
case|:
block|{
specifier|const
name|char
modifier|*
name|section_name
init|=
name|symbol
operator|->
name|section
operator|->
name|name
decl_stmt|;
name|bfd_print_symbol_vandf
argument_list|(
name|abfd
argument_list|,
name|file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|file
argument_list|,
literal|" %-8s %s"
argument_list|,
name|section_name
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Return information about symbol in ret.     fill type, value and name    type: 	A	absolute 	B	bss segment symbol 	C	common symbol 	D	data segment symbol 	f	filename 	t	a static function symbol 	T	text segment symbol 	U	undefined 	-	debug.  */
end_comment

begin_function
specifier|static
name|void
name|vms_get_symbol_info
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
name|symbol
parameter_list|,
name|symbol_info
modifier|*
name|ret
parameter_list|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_get_symbol_info (%p, %p, %p)\n"
argument_list|,
name|abfd
argument_list|,
name|symbol
argument_list|,
name|ret
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sec
operator|=
name|symbol
operator|->
name|section
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|sec
argument_list|)
condition|)
name|ret
operator|->
name|type
operator|=
literal|'C'
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
condition|)
name|ret
operator|->
name|type
operator|=
literal|'A'
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|sec
argument_list|)
condition|)
name|ret
operator|->
name|type
operator|=
literal|'U'
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_is_ind_section
argument_list|(
name|sec
argument_list|)
condition|)
name|ret
operator|->
name|type
operator|=
literal|'I'
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_CODE
condition|)
name|ret
operator|->
name|type
operator|=
literal|'T'
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_DATA
condition|)
name|ret
operator|->
name|type
operator|=
literal|'D'
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|&
name|SEC_ALLOC
condition|)
name|ret
operator|->
name|type
operator|=
literal|'B'
expr_stmt|;
else|else
name|ret
operator|->
name|type
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|ret
operator|->
name|type
operator|!=
literal|'U'
condition|)
name|ret
operator|->
name|value
operator|=
name|symbol
operator|->
name|value
operator|+
name|symbol
operator|->
name|section
operator|->
name|vma
expr_stmt|;
else|else
name|ret
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|name
operator|=
name|symbol
operator|->
name|name
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the given symbol sym in the BFD abfd is    a compiler generated local label, else return FALSE.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_bfd_is_local_label_name
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_bfd_is_local_label_name (%p, %s)\n"
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|name
index|[
literal|0
index|]
operator|==
literal|'$'
return|;
block|}
end_function

begin_comment
comment|/* Get source line number for symbol.  */
end_comment

begin_function
specifier|static
name|alent
modifier|*
name|vms_get_lineno
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
name|symbol
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_get_lineno (%p, %p)\n"
argument_list|,
name|abfd
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Provided a BFD, a section and an offset into the section, calculate and    return the name of the source file and the line nearest to the wanted    location.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_find_nearest_line
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_vma
name|offset
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|func
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
modifier|*
name|line
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_find_nearest_line (%p, %s, %p, %ld,<ret>,<ret>,<ret>)\n"
argument_list|,
name|abfd
argument_list|,
name|section
operator|->
name|name
argument_list|,
name|symbols
argument_list|,
operator|(
name|long
name|int
operator|)
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|vms_find_inliner_info
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|func
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
modifier|*
name|line
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_find_inliner_info (%p,<ret>,<ret>,<ret>)\n"
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Back-door to allow format-aware applications to create debug symbols    while using BFD for everything else.  Currently used by the assembler    when creating COFF files.  */
end_comment

begin_function
specifier|static
name|asymbol
modifier|*
name|vms_bfd_make_debug_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|ptr
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|long
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_bfd_make_debug_symbol (%p, %p, %ld)\n"
argument_list|,
name|abfd
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Read minisymbols.  For minisymbols, we use the unmodified a.out    symbols.  The minisymbol_to_symbol function translates these into    BFD asymbol structures.  */
end_comment

begin_function
specifier|static
name|long
name|vms_read_minisymbols
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|dynamic
parameter_list|,
name|void
modifier|*
modifier|*
name|minisymsp
parameter_list|,
name|unsigned
name|int
modifier|*
name|sizep
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_read_minisymbols (%p, %d, %p, %d)\n"
argument_list|,
name|abfd
argument_list|,
name|dynamic
argument_list|,
name|minisymsp
argument_list|,
operator|*
name|sizep
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|_bfd_generic_read_minisymbols
argument_list|(
name|abfd
argument_list|,
name|dynamic
argument_list|,
name|minisymsp
argument_list|,
name|sizep
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert a minisymbol to a BFD asymbol.  A minisymbol is just an    unmodified a.out symbol.  The SYM argument is a structure returned    by bfd_make_empty_symbol, which we fill in here.  */
end_comment

begin_function
specifier|static
name|asymbol
modifier|*
name|vms_minisymbol_to_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|dynamic
parameter_list|,
specifier|const
name|void
modifier|*
name|minisym
parameter_list|,
name|asymbol
modifier|*
name|sym
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_minisymbol_to_symbol (%p, %d, %p, %p)\n"
argument_list|,
name|abfd
argument_list|,
name|dynamic
argument_list|,
name|minisym
argument_list|,
name|sym
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|_bfd_generic_minisymbol_to_symbol
argument_list|(
name|abfd
argument_list|,
name|dynamic
argument_list|,
name|minisym
argument_list|,
name|sym
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Part 4.6, relocations.  */
end_comment

begin_comment
comment|/* Return the number of bytes required to store the relocation information    associated with section sect attached to bfd abfd.    If an error occurs, return -1.  */
end_comment

begin_function
specifier|static
name|long
name|vms_get_reloc_upper_bound
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_get_reloc_upper_bound (%p, %s)\n"
argument_list|,
name|abfd
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1L
return|;
block|}
end_function

begin_comment
comment|/* Call the back end associated with the open BFD abfd and translate the    external form of the relocation information attached to sec into the    internal canonical form.  Place the table into memory at loc, which has    been preallocated, usually by a call to bfd_get_reloc_upper_bound.    Returns the number of relocs, or -1 on error.  */
end_comment

begin_function
specifier|static
name|long
name|vms_canonicalize_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
modifier|*
name|location
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_canonicalize_reloc (%p, %s,<ret>,<ret>)\n"
argument_list|,
name|abfd
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is just copied from ecoff-alpha, needs to be fixed probably.  */
end_comment

begin_comment
comment|/* How to process the various reloc types.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|reloc_nil
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|reloc
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
name|sym
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"reloc_nil (abfd %p, output_bfd %p)\n"
argument_list|,
name|abfd
argument_list|,
name|output_bfd
argument_list|)
expr_stmt|;
name|vms_debug
argument_list|(
literal|2
argument_list|,
literal|"In section %s, symbol %s\n"
argument_list|,
name|sec
operator|->
name|name
argument_list|,
name|sym
operator|->
name|name
argument_list|)
expr_stmt|;
name|vms_debug
argument_list|(
literal|2
argument_list|,
literal|"reloc sym %s, addr %08lx, addend %08lx, reloc is a %s\n"
argument_list|,
name|reloc
operator|->
name|sym_ptr_ptr
index|[
literal|0
index|]
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|reloc
operator|->
name|address
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|reloc
operator|->
name|addend
argument_list|,
name|reloc
operator|->
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
name|vms_debug
argument_list|(
literal|2
argument_list|,
literal|"data at %p\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/*  _bfd_hexdump (2, data, bfd_get_reloc_size (reloc->howto), 0); */
endif|#
directive|endif
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* In case we're on a 32-bit machine, construct a 64-bit "-1" value    from smaller values.  Start with zero, widen, *then* decrement.  */
end_comment

begin_define
define|#
directive|define
name|MINUS_ONE
value|(((bfd_vma)0) - 1)
end_define

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|alpha_howto_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|ALPHA_R_IGNORE
argument_list|,
comment|/* Type.  */
literal|0
argument_list|,
comment|/* Rightshift.  */
literal|0
argument_list|,
comment|/* Size (0 = byte, 1 = short, 2 = long).  */
literal|8
argument_list|,
comment|/* Bitsize.  */
name|TRUE
argument_list|,
comment|/* PC relative.  */
literal|0
argument_list|,
comment|/* Bitpos.  */
name|complain_overflow_dont
argument_list|,
comment|/* Complain_on_overflow.  */
name|reloc_nil
argument_list|,
comment|/* Special_function.  */
literal|"IGNORE"
argument_list|,
comment|/* Name.  */
name|TRUE
argument_list|,
comment|/* Partial_inplace.  */
literal|0
argument_list|,
comment|/* Source mask */
literal|0
argument_list|,
comment|/* Dest mask.  */
name|TRUE
argument_list|)
block|,
comment|/* PC rel offset.  */
comment|/* A 64 bit reference to a symbol.  */
name|HOWTO
argument_list|(
name|ALPHA_R_REFQUAD
argument_list|,
comment|/* Type.  */
literal|0
argument_list|,
comment|/* Rightshift.  */
literal|4
argument_list|,
comment|/* Size (0 = byte, 1 = short, 2 = long).  */
literal|64
argument_list|,
comment|/* Bitsize.  */
name|FALSE
argument_list|,
comment|/* PC relative.  */
literal|0
argument_list|,
comment|/* Bitpos.  */
name|complain_overflow_bitfield
argument_list|,
comment|/* Complain_on_overflow.  */
name|reloc_nil
argument_list|,
comment|/* Special_function.  */
literal|"REFQUAD"
argument_list|,
comment|/* Name.  */
name|TRUE
argument_list|,
comment|/* Partial_inplace.  */
name|MINUS_ONE
argument_list|,
comment|/* Source mask.  */
name|MINUS_ONE
argument_list|,
comment|/* Dest mask.  */
name|FALSE
argument_list|)
block|,
comment|/* PC rel offset.  */
comment|/* A 21 bit branch.  The native assembler generates these for      branches within the text segment, and also fills in the PC      relative offset in the instruction.  */
name|HOWTO
argument_list|(
name|ALPHA_R_BRADDR
argument_list|,
comment|/* Type.  */
literal|2
argument_list|,
comment|/* Rightshift.  */
literal|2
argument_list|,
comment|/* Size (0 = byte, 1 = short, 2 = long).  */
literal|21
argument_list|,
comment|/* Bitsize.  */
name|TRUE
argument_list|,
comment|/* PC relative.  */
literal|0
argument_list|,
comment|/* Bitpos.  */
name|complain_overflow_signed
argument_list|,
comment|/* Complain_on_overflow.  */
name|reloc_nil
argument_list|,
comment|/* Special_function.  */
literal|"BRADDR"
argument_list|,
comment|/* Name.  */
name|TRUE
argument_list|,
comment|/* Partial_inplace.  */
literal|0x1fffff
argument_list|,
comment|/* Source mask.  */
literal|0x1fffff
argument_list|,
comment|/* Dest mask.  */
name|FALSE
argument_list|)
block|,
comment|/* PC rel offset.  */
comment|/* A hint for a jump to a register.  */
name|HOWTO
argument_list|(
name|ALPHA_R_HINT
argument_list|,
comment|/* Type.  */
literal|2
argument_list|,
comment|/* Rightshift.  */
literal|1
argument_list|,
comment|/* Size (0 = byte, 1 = short, 2 = long).  */
literal|14
argument_list|,
comment|/* Bitsize.  */
name|TRUE
argument_list|,
comment|/* PC relative.  */
literal|0
argument_list|,
comment|/* Bitpos.  */
name|complain_overflow_dont
argument_list|,
comment|/* Complain_on_overflow.  */
name|reloc_nil
argument_list|,
comment|/* Special_function.  */
literal|"HINT"
argument_list|,
comment|/* Name.  */
name|TRUE
argument_list|,
comment|/* Partial_inplace.  */
literal|0x3fff
argument_list|,
comment|/* Source mask.  */
literal|0x3fff
argument_list|,
comment|/* Dest mask.  */
name|FALSE
argument_list|)
block|,
comment|/* PC rel offset.  */
comment|/* 16 bit PC relative offset.  */
name|HOWTO
argument_list|(
name|ALPHA_R_SREL16
argument_list|,
comment|/* Type.  */
literal|0
argument_list|,
comment|/* Rightshift.  */
literal|1
argument_list|,
comment|/* Size (0 = byte, 1 = short, 2 = long).  */
literal|16
argument_list|,
comment|/* Bitsize.  */
name|TRUE
argument_list|,
comment|/* PC relative.  */
literal|0
argument_list|,
comment|/* Bitpos.  */
name|complain_overflow_signed
argument_list|,
comment|/* Complain_on_overflow.  */
name|reloc_nil
argument_list|,
comment|/* Special_function.  */
literal|"SREL16"
argument_list|,
comment|/* Name.  */
name|TRUE
argument_list|,
comment|/* Partial_inplace.  */
literal|0xffff
argument_list|,
comment|/* Source mask.  */
literal|0xffff
argument_list|,
comment|/* Dest mask.  */
name|FALSE
argument_list|)
block|,
comment|/* PC rel offset.  */
comment|/* 32 bit PC relative offset.  */
name|HOWTO
argument_list|(
name|ALPHA_R_SREL32
argument_list|,
comment|/* Type.  */
literal|0
argument_list|,
comment|/* Rightshift.  */
literal|2
argument_list|,
comment|/* Size (0 = byte, 1 = short, 2 = long).  */
literal|32
argument_list|,
comment|/* Bitsize.  */
name|TRUE
argument_list|,
comment|/* PC relative.  */
literal|0
argument_list|,
comment|/* Bitpos.  */
name|complain_overflow_signed
argument_list|,
comment|/* Complain_on_overflow.  */
name|reloc_nil
argument_list|,
comment|/* Special_function.  */
literal|"SREL32"
argument_list|,
comment|/* Name.  */
name|TRUE
argument_list|,
comment|/* Partial_inplace.  */
literal|0xffffffff
argument_list|,
comment|/* Source mask.  */
literal|0xffffffff
argument_list|,
comment|/* Dest mask.  */
name|FALSE
argument_list|)
block|,
comment|/* PC rel offset.  */
comment|/* A 64 bit PC relative offset.  */
name|HOWTO
argument_list|(
name|ALPHA_R_SREL64
argument_list|,
comment|/* Type.  */
literal|0
argument_list|,
comment|/* Rightshift.  */
literal|4
argument_list|,
comment|/* Size (0 = byte, 1 = short, 2 = long).  */
literal|64
argument_list|,
comment|/* Bitsize.  */
name|TRUE
argument_list|,
comment|/* PC relative.  */
literal|0
argument_list|,
comment|/* Bitpos.  */
name|complain_overflow_signed
argument_list|,
comment|/* Complain_on_overflow.  */
name|reloc_nil
argument_list|,
comment|/* Special_function.  */
literal|"SREL64"
argument_list|,
comment|/* Name.  */
name|TRUE
argument_list|,
comment|/* Partial_inplace.  */
name|MINUS_ONE
argument_list|,
comment|/* Source mask.  */
name|MINUS_ONE
argument_list|,
comment|/* Dest mask.  */
name|FALSE
argument_list|)
block|,
comment|/* PC rel offset.  */
comment|/* Push a value on the reloc evaluation stack.  */
name|HOWTO
argument_list|(
name|ALPHA_R_OP_PUSH
argument_list|,
comment|/* Type.  */
literal|0
argument_list|,
comment|/* Rightshift.  */
literal|0
argument_list|,
comment|/* Size (0 = byte, 1 = short, 2 = long).  */
literal|0
argument_list|,
comment|/* Bitsize.  */
name|FALSE
argument_list|,
comment|/* PC relative.  */
literal|0
argument_list|,
comment|/* Bitpos.  */
name|complain_overflow_dont
argument_list|,
comment|/* Complain_on_overflow.  */
name|reloc_nil
argument_list|,
comment|/* Special_function.  */
literal|"OP_PUSH"
argument_list|,
comment|/* Name.  */
name|FALSE
argument_list|,
comment|/* Partial_inplace.  */
literal|0
argument_list|,
comment|/* Source mask.  */
literal|0
argument_list|,
comment|/* Dest mask.  */
name|FALSE
argument_list|)
block|,
comment|/* PC rel offset.  */
comment|/* Store the value from the stack at the given address.  Store it in      a bitfield of size r_size starting at bit position r_offset.  */
name|HOWTO
argument_list|(
name|ALPHA_R_OP_STORE
argument_list|,
comment|/* Type.  */
literal|0
argument_list|,
comment|/* Rightshift.  */
literal|4
argument_list|,
comment|/* Size (0 = byte, 1 = short, 2 = long).  */
literal|64
argument_list|,
comment|/* Bitsize.  */
name|FALSE
argument_list|,
comment|/* PC relative.  */
literal|0
argument_list|,
comment|/* Bitpos.  */
name|complain_overflow_dont
argument_list|,
comment|/* Complain_on_overflow.  */
name|reloc_nil
argument_list|,
comment|/* Special_function.  */
literal|"OP_STORE"
argument_list|,
comment|/* Name.  */
name|FALSE
argument_list|,
comment|/* Partial_inplace.  */
literal|0
argument_list|,
comment|/* Source mask.  */
name|MINUS_ONE
argument_list|,
comment|/* Dest mask.  */
name|FALSE
argument_list|)
block|,
comment|/* PC rel offset.  */
comment|/* Subtract the reloc address from the value on the top of the      relocation stack.  */
name|HOWTO
argument_list|(
name|ALPHA_R_OP_PSUB
argument_list|,
comment|/* Type.  */
literal|0
argument_list|,
comment|/* Rightshift.  */
literal|0
argument_list|,
comment|/* Size (0 = byte, 1 = short, 2 = long).  */
literal|0
argument_list|,
comment|/* Bitsize.  */
name|FALSE
argument_list|,
comment|/* PC relative.  */
literal|0
argument_list|,
comment|/* Bitpos.  */
name|complain_overflow_dont
argument_list|,
comment|/* Complain_on_overflow.  */
name|reloc_nil
argument_list|,
comment|/* Special_function.  */
literal|"OP_PSUB"
argument_list|,
comment|/* Name.  */
name|FALSE
argument_list|,
comment|/* Partial_inplace.  */
literal|0
argument_list|,
comment|/* Source mask.  */
literal|0
argument_list|,
comment|/* Dest mask.  */
name|FALSE
argument_list|)
block|,
comment|/* PC rel offset.  */
comment|/* Shift the value on the top of the relocation stack right by the      given value.  */
name|HOWTO
argument_list|(
name|ALPHA_R_OP_PRSHIFT
argument_list|,
comment|/* Type.  */
literal|0
argument_list|,
comment|/* Rightshift.  */
literal|0
argument_list|,
comment|/* Size (0 = byte, 1 = short, 2 = long).  */
literal|0
argument_list|,
comment|/* Bitsize.  */
name|FALSE
argument_list|,
comment|/* PC relative.  */
literal|0
argument_list|,
comment|/* Bitpos.  */
name|complain_overflow_dont
argument_list|,
comment|/* Complain_on_overflow.  */
name|reloc_nil
argument_list|,
comment|/* Special_function.  */
literal|"OP_PRSHIFT"
argument_list|,
comment|/* Name.  */
name|FALSE
argument_list|,
comment|/* Partial_inplace.  */
literal|0
argument_list|,
comment|/* Source mask.  */
literal|0
argument_list|,
comment|/* Dest mask.  */
name|FALSE
argument_list|)
block|,
comment|/* PC rel offset.  */
comment|/* Hack. Linkage is done by linker.  */
name|HOWTO
argument_list|(
name|ALPHA_R_LINKAGE
argument_list|,
comment|/* Type.  */
literal|0
argument_list|,
comment|/* Rightshift.  */
literal|8
argument_list|,
comment|/* Size (0 = byte, 1 = short, 2 = long).  */
literal|256
argument_list|,
comment|/* Bitsize.  */
name|FALSE
argument_list|,
comment|/* PC relative.  */
literal|0
argument_list|,
comment|/* Bitpos.  */
name|complain_overflow_dont
argument_list|,
comment|/* Complain_on_overflow.  */
name|reloc_nil
argument_list|,
comment|/* Special_function.  */
literal|"LINKAGE"
argument_list|,
comment|/* Name.  */
name|FALSE
argument_list|,
comment|/* Partial_inplace.  */
literal|0
argument_list|,
comment|/* Source mask.  */
literal|0
argument_list|,
comment|/* Dest mask.  */
name|FALSE
argument_list|)
block|,
comment|/* PC rel offset.  */
comment|/* A 32 bit reference to a symbol.  */
name|HOWTO
argument_list|(
name|ALPHA_R_REFLONG
argument_list|,
comment|/* Type.  */
literal|0
argument_list|,
comment|/* Rightshift.  */
literal|2
argument_list|,
comment|/* Size (0 = byte, 1 = short, 2 = long).  */
literal|32
argument_list|,
comment|/* Bitsize.  */
name|FALSE
argument_list|,
comment|/* PC relative.  */
literal|0
argument_list|,
comment|/* Bitpos.  */
name|complain_overflow_bitfield
argument_list|,
comment|/* Complain_on_overflow.  */
name|reloc_nil
argument_list|,
comment|/* Special_function.  */
literal|"REFLONG"
argument_list|,
comment|/* Name.  */
name|TRUE
argument_list|,
comment|/* Partial_inplace.  */
literal|0xffffffff
argument_list|,
comment|/* Source mask.  */
literal|0xffffffff
argument_list|,
comment|/* Dest mask.  */
name|FALSE
argument_list|)
block|,
comment|/* PC rel offset.  */
comment|/* A 64 bit reference to a procedure, written as 32 bit value.  */
name|HOWTO
argument_list|(
name|ALPHA_R_CODEADDR
argument_list|,
comment|/* Type.  */
literal|0
argument_list|,
comment|/* Rightshift.  */
literal|4
argument_list|,
comment|/* Size (0 = byte, 1 = short, 2 = long).  */
literal|64
argument_list|,
comment|/* Bitsize.  */
name|FALSE
argument_list|,
comment|/* PC relative.  */
literal|0
argument_list|,
comment|/* Bitpos.  */
name|complain_overflow_signed
argument_list|,
comment|/* Complain_on_overflow.  */
name|reloc_nil
argument_list|,
comment|/* Special_function.  */
literal|"CODEADDR"
argument_list|,
comment|/* Name.  */
name|FALSE
argument_list|,
comment|/* Partial_inplace.  */
literal|0xffffffff
argument_list|,
comment|/* Source mask.  */
literal|0xffffffff
argument_list|,
comment|/* Dest mask.  */
name|FALSE
argument_list|)
block|,
comment|/* PC rel offset.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a pointer to a howto structure which, when invoked, will perform    the relocation code on data from the architecture noted.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|reloc_howto_struct
modifier|*
name|vms_bfd_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
name|int
name|alpha_type
decl_stmt|;
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_bfd_reloc_type_lookup (%p, %d)\t"
argument_list|,
name|abfd
argument_list|,
name|code
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BFD_RELOC_16
case|:
name|alpha_type
operator|=
name|ALPHA_R_SREL16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32
case|:
name|alpha_type
operator|=
name|ALPHA_R_REFLONG
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64
case|:
name|alpha_type
operator|=
name|ALPHA_R_REFQUAD
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_CTOR
case|:
name|alpha_type
operator|=
name|ALPHA_R_REFQUAD
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_23_PCREL_S2
case|:
name|alpha_type
operator|=
name|ALPHA_R_BRADDR
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ALPHA_HINT
case|:
name|alpha_type
operator|=
name|ALPHA_R_HINT
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_16_PCREL
case|:
name|alpha_type
operator|=
name|ALPHA_R_SREL16
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_32_PCREL
case|:
name|alpha_type
operator|=
name|ALPHA_R_SREL32
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_64_PCREL
case|:
name|alpha_type
operator|=
name|ALPHA_R_SREL64
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ALPHA_LINKAGE
case|:
name|alpha_type
operator|=
name|ALPHA_R_LINKAGE
expr_stmt|;
break|break;
case|case
name|BFD_RELOC_ALPHA_CODEADDR
case|:
name|alpha_type
operator|=
name|ALPHA_R_CODEADDR
expr_stmt|;
break|break;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"reloc (%d) is *UNKNOWN*"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|2
argument_list|,
literal|"reloc is %s\n"
argument_list|,
name|alpha_howto_table
index|[
name|alpha_type
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|&
name|alpha_howto_table
index|[
name|alpha_type
index|]
return|;
block|}
end_function

begin_comment
comment|/* Part 4.7, writing an object file.  */
end_comment

begin_comment
comment|/* Set the architecture and machine type in BFD abfd to arch and mach.    Find the correct pointer to a structure and insert it into the arch_info    pointer.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_set_arch_mach
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|enum
name|bfd_architecture
name|arch
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|long
name|mach
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_set_arch_mach (%p, %d, %ld)\n"
argument_list|,
name|abfd
argument_list|,
name|arch
argument_list|,
name|mach
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|abfd
operator|->
name|arch_info
operator|=
name|bfd_scan_arch
argument_list|(
literal|"alpha"
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Sets the contents of the section section in BFD abfd to the data starting    in memory at data. The data is written to the output section starting at    offset offset for count bytes.     Normally TRUE is returned, else FALSE. Possible error returns are:    o bfd_error_no_contents - The output section does not have the 	SEC_HAS_CONTENTS attribute, so nothing can be written to it.    o and some more too  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_set_section_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|,
specifier|const
name|void
modifier|*
name|location
parameter_list|,
name|file_ptr
name|offset
parameter_list|,
name|bfd_size_type
name|count
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_set_section_contents (%p, sec %s, loc %p, off %ld, count %d)\n"
argument_list|,
name|abfd
argument_list|,
name|section
operator|->
name|name
argument_list|,
name|location
argument_list|,
operator|(
name|long
name|int
operator|)
name|offset
argument_list|,
operator|(
name|int
operator|)
name|count
argument_list|)
expr_stmt|;
name|vms_debug
argument_list|(
literal|2
argument_list|,
literal|"size %d\n"
argument_list|,
operator|(
name|int
operator|)
name|section
operator|->
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|_bfd_save_vms_section
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|location
argument_list|,
name|offset
argument_list|,
name|count
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Part 4.8, linker.  */
end_comment

begin_comment
comment|/* Get the size of the section headers.  */
end_comment

begin_function
specifier|static
name|int
name|vms_sizeof_headers
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_boolean
name|reloc
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_sizeof_headers (%p, %s)\n"
argument_list|,
name|abfd
argument_list|,
operator|(
name|reloc
operator|)
condition|?
literal|"True"
else|:
literal|"False"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Provides default handling of relocation effort for back ends    which can't be bothered to do it efficiently.  */
end_comment

begin_function
specifier|static
name|bfd_byte
modifier|*
name|vms_bfd_get_relocated_section_contents
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_order
modifier|*
name|link_order
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_byte
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_boolean
name|relocatable
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_bfd_get_relocated_section_contents (%p, %p, %p, %p, %s, %p)\n"
argument_list|,
name|abfd
argument_list|,
name|link_info
argument_list|,
name|link_order
argument_list|,
name|data
argument_list|,
operator|(
name|relocatable
operator|)
condition|?
literal|"True"
else|:
literal|"False"
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ???  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_bfd_relax_section
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_boolean
modifier|*
name|again
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_bfd_relax_section (%p, %s, %p,<ret>)\n"
argument_list|,
name|abfd
argument_list|,
name|section
operator|->
name|name
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|vms_bfd_gc_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_bfd_gc_sections (%p, %p)\n"
argument_list|,
name|abfd
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|vms_bfd_merge_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_bfd_merge_sections (%p, %p)\n"
argument_list|,
name|abfd
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Create a hash table for the linker.  Different backends store    different information in this table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|vms_bfd_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_bfd_link_hash_table_create (%p)\n"
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Free a linker hash table.  */
end_comment

begin_function
specifier|static
name|void
name|vms_bfd_link_hash_table_free
parameter_list|(
name|struct
name|bfd_link_hash_table
modifier|*
name|hash
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_bfd_link_hash_table_free (%p)\n"
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Add symbols from this object file into the hash table.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_bfd_link_add_symbols
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_bfd_link_add_symbols (%p, %p)\n"
argument_list|,
name|abfd
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Do a link based on the link_order structures attached to each    section of the BFD.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_bfd_final_link
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_bfd_final_link (%p, %p)\n"
argument_list|,
name|abfd
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Should this section be split up into smaller pieces during linking.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|vms_bfd_link_split_section
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|section
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_bfd_link_split_section (%p, %s)\n"
argument_list|,
name|abfd
argument_list|,
name|section
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Part 4.9, dynamic symbols and relocations.  */
end_comment

begin_comment
comment|/* Get the amount of memory required to hold the dynamic symbols.  */
end_comment

begin_function
specifier|static
name|long
name|vms_get_dynamic_symtab_upper_bound
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_get_dynamic_symtab_upper_bound (%p)\n"
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|vms_bfd_print_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_bfd_print_private_bfd_data (%p)\n"
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Read in the dynamic symbols.  */
end_comment

begin_function
specifier|static
name|long
name|vms_canonicalize_dynamic_symtab
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_canonicalize_dynamic_symtab (%p,<ret>)\n"
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0L
return|;
block|}
end_function

begin_comment
comment|/* Get the amount of memory required to hold the dynamic relocs.  */
end_comment

begin_function
specifier|static
name|long
name|vms_get_dynamic_reloc_upper_bound
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_get_dynamic_reloc_upper_bound (%p)\n"
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0L
return|;
block|}
end_function

begin_comment
comment|/* Read in the dynamic relocs.  */
end_comment

begin_function
specifier|static
name|long
name|vms_canonicalize_dynamic_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
modifier|*
name|arel
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|VMS_DEBUG
name|vms_debug
argument_list|(
literal|1
argument_list|,
literal|"vms_canonicalize_dynamic_reloc (%p)\n"
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0L
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|bfd_target
name|vms_alpha_vec
init|=
block|{
literal|"vms-alpha"
block|,
comment|/* Name.  */
name|bfd_target_evax_flavour
block|,
name|BFD_ENDIAN_LITTLE
block|,
comment|/* Data byte order is little.  */
name|BFD_ENDIAN_LITTLE
block|,
comment|/* Header byte order is little.  */
operator|(
name|HAS_RELOC
operator||
name|HAS_SYMS
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator|)
block|,
comment|/* Object flags.  */
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_READONLY
operator||
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator|)
block|,
comment|/* Sect flags.  */
literal|0
block|,
comment|/* Symbol_leading_char.  */
literal|' '
block|,
comment|/* AR_pad_char.  */
literal|15
block|,
comment|/* AR_max_namelen.  */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
block|{
name|_bfd_dummy_target
block|,
name|vms_object_p
block|,
comment|/* bfd_check_format.  */
name|vms_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|vms_mkobject
block|,
comment|/* bfd_set_format.  */
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|vms_write_object_contents
block|,
comment|/* bfd_write_contents.  */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|vms
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|vms
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|vms
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|vms
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|vms
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|vms
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|vms
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|vms
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|vms
argument_list|)
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|bfd_target
name|vms_vax_vec
init|=
block|{
literal|"vms-vax"
block|,
comment|/* Name.  */
name|bfd_target_ovax_flavour
block|,
name|BFD_ENDIAN_LITTLE
block|,
comment|/* Data byte order is little.  */
name|BFD_ENDIAN_LITTLE
block|,
comment|/* Header byte order is little.  */
operator|(
name|HAS_RELOC
operator||
name|HAS_SYMS
comment|/* Object flags.  */
operator||
name|WP_TEXT
operator||
name|D_PAGED
operator||
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_LOCALS
operator|)
block|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator||
name|SEC_READONLY
operator||
name|SEC_CODE
operator||
name|SEC_DATA
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator|)
block|,
comment|/* Sect flags.  */
literal|0
block|,
comment|/* Symbol_leading_char.  */
literal|' '
block|,
comment|/* AR_pad_char.  */
literal|15
block|,
comment|/* AR_max_namelen.  */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* Data.  */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* Headers.  */
block|{
name|_bfd_dummy_target
block|,
name|vms_object_p
block|,
comment|/* bfd_check_format.  */
name|vms_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|vms_mkobject
block|,
comment|/* bfd_set_format.  */
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|vms_write_object_contents
block|,
comment|/* bfd_write_contents.  */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|vms
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|vms
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|vms
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|vms
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|vms
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|vms
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|vms
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|vms
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|vms
argument_list|)
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

end_unit

