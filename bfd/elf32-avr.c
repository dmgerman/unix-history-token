begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* AVR-specific support for 32-bit ELF    Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2006    Free Software Foundation, Inc.    Contributed by Denis Chertykov<denisc@overta.ru>     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor,    Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/avr.h"
end_include

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_avr_howto_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|R_AVR_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_NONE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_AVR_32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 7 bit PC relative relocation.  */
name|HOWTO
argument_list|(
name|R_AVR_7_PCREL
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|7
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|3
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_7_PCREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 13 bit PC relative relocation.  */
name|HOWTO
argument_list|(
name|R_AVR_13_PCREL
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|13
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_13_PCREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xfff
argument_list|,
comment|/* src_mask */
literal|0xfff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit absolute relocation.  */
name|HOWTO
argument_list|(
name|R_AVR_16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit absolute relocation for command address.  */
name|HOWTO
argument_list|(
name|R_AVR_16_PM
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_16_PM"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A low 8 bit absolute relocation of 16 bit address.      For LDI command.  */
name|HOWTO
argument_list|(
name|R_AVR_LO8_LDI
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_LO8_LDI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A high 8 bit absolute relocation of 16 bit address.      For LDI command.  */
name|HOWTO
argument_list|(
name|R_AVR_HI8_LDI
argument_list|,
comment|/* type */
literal|8
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_HI8_LDI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A high 6 bit absolute relocation of 22 bit address.      For LDI command.  As well second most significant 8 bit value of      a 32 bit link-time constant.  */
name|HOWTO
argument_list|(
name|R_AVR_HH8_LDI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_HH8_LDI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A negative low 8 bit absolute relocation of 16 bit address.      For LDI command.  */
name|HOWTO
argument_list|(
name|R_AVR_LO8_LDI_NEG
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_LO8_LDI_NEG"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A negative high 8 bit absolute relocation of 16 bit address.      For LDI command.  */
name|HOWTO
argument_list|(
name|R_AVR_HI8_LDI_NEG
argument_list|,
comment|/* type */
literal|8
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_HI8_LDI_NEG"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A negative high 6 bit absolute relocation of 22 bit address.      For LDI command.  */
name|HOWTO
argument_list|(
name|R_AVR_HH8_LDI_NEG
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_HH8_LDI_NEG"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A low 8 bit absolute relocation of 24 bit program memory address.      For LDI command.  */
name|HOWTO
argument_list|(
name|R_AVR_LO8_LDI_PM
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_LO8_LDI_PM"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A high 8 bit absolute relocation of 16 bit program memory address.      For LDI command.  */
name|HOWTO
argument_list|(
name|R_AVR_HI8_LDI_PM
argument_list|,
comment|/* type */
literal|9
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_HI8_LDI_PM"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A high 8 bit absolute relocation of 24 bit program memory address.      For LDI command.  */
name|HOWTO
argument_list|(
name|R_AVR_HH8_LDI_PM
argument_list|,
comment|/* type */
literal|17
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_HH8_LDI_PM"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A low 8 bit absolute relocation of a negative 24 bit      program memory address.  For LDI command.  */
name|HOWTO
argument_list|(
name|R_AVR_LO8_LDI_PM_NEG
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_LO8_LDI_PM_NEG"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A high 8 bit absolute relocation of a negative 16 bit      program memory address.  For LDI command.  */
name|HOWTO
argument_list|(
name|R_AVR_HI8_LDI_PM_NEG
argument_list|,
comment|/* type */
literal|9
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_HI8_LDI_PM_NEG"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A high 8 bit absolute relocation of a negative 24 bit      program memory address.  For LDI command.  */
name|HOWTO
argument_list|(
name|R_AVR_HH8_LDI_PM_NEG
argument_list|,
comment|/* type */
literal|17
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_HH8_LDI_PM_NEG"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Relocation for CALL command in ATmega.  */
name|HOWTO
argument_list|(
name|R_AVR_CALL
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|23
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_CALL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit absolute relocation of 16 bit address.      For LDI command.  */
name|HOWTO
argument_list|(
name|R_AVR_LDI
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_LDI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 6 bit absolute relocation of 6 bit offset.      For ldd/sdd command.  */
name|HOWTO
argument_list|(
name|R_AVR_6
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|6
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_6"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 6 bit absolute relocation of 6 bit offset.      For sbiw/adiw command.  */
name|HOWTO
argument_list|(
name|R_AVR_6_ADIW
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|6
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_6_ADIW"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Most significant 8 bit value of a 32 bit link-time constant.  */
name|HOWTO
argument_list|(
name|R_AVR_MS8_LDI
argument_list|,
comment|/* type */
literal|24
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_MS8_LDI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Negative most significant 8 bit value of a 32 bit link-time constant.  */
name|HOWTO
argument_list|(
argument|R_AVR_MS8_LDI_NEG
argument_list|,
comment|/* type */
literal|24
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
argument|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
argument|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
argument|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_MS8_LDI_NEG"
argument_list|,
comment|/* name */
argument|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
argument|FALSE
argument_list|)
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map BFD reloc types to AVR ELF reloc types.  */
end_comment

begin_struct
struct|struct
name|avr_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_val
decl_stmt|;
name|unsigned
name|int
name|elf_reloc_val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|avr_reloc_map
name|avr_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_AVR_NONE
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_AVR_32
block|}
block|,
block|{
name|BFD_RELOC_AVR_7_PCREL
block|,
name|R_AVR_7_PCREL
block|}
block|,
block|{
name|BFD_RELOC_AVR_13_PCREL
block|,
name|R_AVR_13_PCREL
block|}
block|,
block|{
name|BFD_RELOC_16
block|,
name|R_AVR_16
block|}
block|,
block|{
name|BFD_RELOC_AVR_16_PM
block|,
name|R_AVR_16_PM
block|}
block|,
block|{
name|BFD_RELOC_AVR_LO8_LDI
block|,
name|R_AVR_LO8_LDI
block|}
block|,
block|{
name|BFD_RELOC_AVR_HI8_LDI
block|,
name|R_AVR_HI8_LDI
block|}
block|,
block|{
name|BFD_RELOC_AVR_HH8_LDI
block|,
name|R_AVR_HH8_LDI
block|}
block|,
block|{
name|BFD_RELOC_AVR_MS8_LDI
block|,
name|R_AVR_MS8_LDI
block|}
block|,
block|{
name|BFD_RELOC_AVR_LO8_LDI_NEG
block|,
name|R_AVR_LO8_LDI_NEG
block|}
block|,
block|{
name|BFD_RELOC_AVR_HI8_LDI_NEG
block|,
name|R_AVR_HI8_LDI_NEG
block|}
block|,
block|{
name|BFD_RELOC_AVR_HH8_LDI_NEG
block|,
name|R_AVR_HH8_LDI_NEG
block|}
block|,
block|{
name|BFD_RELOC_AVR_MS8_LDI_NEG
block|,
name|R_AVR_MS8_LDI_NEG
block|}
block|,
block|{
name|BFD_RELOC_AVR_LO8_LDI_PM
block|,
name|R_AVR_LO8_LDI_PM
block|}
block|,
block|{
name|BFD_RELOC_AVR_HI8_LDI_PM
block|,
name|R_AVR_HI8_LDI_PM
block|}
block|,
block|{
name|BFD_RELOC_AVR_HH8_LDI_PM
block|,
name|R_AVR_HH8_LDI_PM
block|}
block|,
block|{
name|BFD_RELOC_AVR_LO8_LDI_PM_NEG
block|,
name|R_AVR_LO8_LDI_PM_NEG
block|}
block|,
block|{
name|BFD_RELOC_AVR_HI8_LDI_PM_NEG
block|,
name|R_AVR_HI8_LDI_PM_NEG
block|}
block|,
block|{
name|BFD_RELOC_AVR_HH8_LDI_PM_NEG
block|,
name|R_AVR_HH8_LDI_PM_NEG
block|}
block|,
block|{
name|BFD_RELOC_AVR_CALL
block|,
name|R_AVR_CALL
block|}
block|,
block|{
name|BFD_RELOC_AVR_LDI
block|,
name|R_AVR_LDI
block|}
block|,
block|{
name|BFD_RELOC_AVR_6
block|,
name|R_AVR_6
block|}
block|,
block|{
name|BFD_RELOC_AVR_6_ADIW
block|,
name|R_AVR_6_ADIW
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Meant to be filled one day with the wrap around address for the    specific device.  I.e. should get the value 0x4000 for 16k devices,    0x8000 for 32k devices and so on.     We initialize it here with a value of 0x1000000 resulting in    that we will never suggest a wrap-around jump during relaxation.    The logic of the source code later on assumes that in    avr_pc_wrap_around one single bit is set.  */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|avr_pc_wrap_around
init|=
literal|0x10000000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Calculates the effective distance of a pc relative jump/call.  */
end_comment

begin_function
specifier|static
name|int
name|avr_relative_distance_considering_wrap_around
parameter_list|(
name|unsigned
name|int
name|distance
parameter_list|)
block|{
name|unsigned
name|int
name|wrap_around_mask
init|=
name|avr_pc_wrap_around
operator|-
literal|1
decl_stmt|;
name|int
name|dist_with_wrap_around
init|=
name|distance
operator|&
name|wrap_around_mask
decl_stmt|;
if|if
condition|(
name|dist_with_wrap_around
operator|>
operator|(
call|(
name|int
call|)
argument_list|(
name|avr_pc_wrap_around
operator|>>
literal|1
argument_list|)
operator|)
condition|)
name|dist_with_wrap_around
operator|-=
name|avr_pc_wrap_around
expr_stmt|;
return|return
name|dist_with_wrap_around
return|;
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|bfd_elf32_bfd_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|avr_reloc_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|avr_reloc_map
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|avr_reloc_map
index|[
name|i
index|]
operator|.
name|bfd_reloc_val
operator|==
name|code
condition|)
return|return
operator|&
name|elf_avr_howto_table
index|[
name|avr_reloc_map
index|[
name|i
index|]
operator|.
name|elf_reloc_val
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set the howto pointer for an AVR ELF reloc.  */
end_comment

begin_function
specifier|static
name|void
name|avr_info_to_howto_rela
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|cache_ptr
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|dst
parameter_list|)
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r_type
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_AVR_max
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf_avr_howto_table
index|[
name|r_type
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|elf32_avr_gc_mark_hook
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
default|default:
break|break;
block|}
block|}
block|}
else|else
return|return
name|bfd_section_from_elf_index
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf32_avr_gc_sweep_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* We don't use got and plt entries for avr.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase.    Since we don't do .gots or .plts, we just need to consider the    virtual table relocs for gc.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_avr_check_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|,
modifier|*
modifier|*
name|sym_hashes_end
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_hashes_end
operator|=
name|sym_hashes
operator|+
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|sym_hashes_end
operator|-=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Perform a single relocation.  By default we use the standard BFD    routines, but a few relocs, we have to do them ourselves.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|avr_final_link_relocate
parameter_list|(
name|reloc_howto_type
modifier|*
name|howto
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|bfd_vma
name|relocation
parameter_list|)
block|{
name|bfd_reloc_status_type
name|r
init|=
name|bfd_reloc_ok
decl_stmt|;
name|bfd_vma
name|x
decl_stmt|;
name|bfd_signed_vma
name|srel
decl_stmt|;
switch|switch
condition|(
name|howto
operator|->
name|type
condition|)
block|{
case|case
name|R_AVR_7_PCREL
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
expr_stmt|;
name|srel
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|-=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|-=
literal|2
expr_stmt|;
comment|/* Branch instructions add 2 to the PC...  */
name|srel
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|srel
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
if|if
condition|(
name|srel
operator|>
operator|(
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|-
literal|1
operator|)
operator|||
operator|(
name|srel
operator|<
operator|-
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xfc07
operator|)
operator||
operator|(
operator|(
operator|(
name|srel
operator|>>
literal|1
operator|)
operator|<<
literal|3
operator|)
operator|&
literal|0x3f8
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_13_PCREL
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
expr_stmt|;
name|srel
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|-=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|-=
literal|2
expr_stmt|;
comment|/* Branch instructions add 2 to the PC...  */
name|srel
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|srel
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|srel
operator|=
name|avr_relative_distance_considering_wrap_around
argument_list|(
name|srel
argument_list|)
expr_stmt|;
comment|/* AVR addresses commands as words.  */
name|srel
operator|>>=
literal|1
expr_stmt|;
comment|/* Check for overflow.  */
if|if
condition|(
name|srel
operator|<
operator|-
literal|2048
operator|||
name|srel
operator|>
literal|2047
condition|)
block|{
comment|/* Relative distance is too large.  */
comment|/* Always apply WRAPAROUND for avr2 and avr4.  */
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
case|case
name|bfd_mach_avr2
case|:
case|case
name|bfd_mach_avr4
case|:
break|break;
default|default:
return|return
name|bfd_reloc_overflow
return|;
block|}
block|}
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf000
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xfff
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_LO8_LDI
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_LDI
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|srel
operator|>
literal|0
operator|)
operator|&&
operator|(
name|srel
operator|&
literal|0xffff
operator|)
operator|>
literal|255
operator|)
operator|||
operator|(
operator|(
name|srel
operator|<
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|-
name|srel
operator|)
operator|&
literal|0xffff
operator|)
operator|>
literal|128
operator|)
condition|)
comment|/* Remove offset for data/eeprom section.  */
return|return
name|bfd_reloc_overflow
return|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_6
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|srel
operator|&
literal|0xffff
operator|)
operator|>
literal|63
operator|)
operator|||
operator|(
name|srel
operator|<
literal|0
operator|)
condition|)
comment|/* Remove offset for data/eeprom section.  */
return|return
name|bfd_reloc_overflow
return|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xd3f8
operator|)
operator||
operator|(
operator|(
name|srel
operator|&
literal|7
operator|)
operator||
operator|(
operator|(
name|srel
operator|&
operator|(
literal|3
operator|<<
literal|3
operator|)
operator|)
operator|<<
literal|7
operator|)
operator||
operator|(
operator|(
name|srel
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_6_ADIW
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|srel
operator|&
literal|0xffff
operator|)
operator|>
literal|63
operator|)
operator|||
operator|(
name|srel
operator|<
literal|0
operator|)
condition|)
comment|/* Remove offset for data/eeprom section.  */
return|return
name|bfd_reloc_overflow
return|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xff30
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|&
literal|0x30
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_HI8_LDI
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|=
operator|(
name|srel
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_HH8_LDI
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|=
operator|(
name|srel
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_MS8_LDI
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|=
operator|(
name|srel
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_LO8_LDI_NEG
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|=
operator|-
name|srel
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_HI8_LDI_NEG
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|=
operator|-
name|srel
expr_stmt|;
name|srel
operator|=
operator|(
name|srel
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_HH8_LDI_NEG
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|=
operator|-
name|srel
expr_stmt|;
name|srel
operator|=
operator|(
name|srel
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_MS8_LDI_NEG
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|=
operator|-
name|srel
expr_stmt|;
name|srel
operator|=
operator|(
name|srel
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_LO8_LDI_PM
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|srel
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|srel
operator|=
name|srel
operator|>>
literal|1
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_HI8_LDI_PM
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|srel
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|srel
operator|=
name|srel
operator|>>
literal|1
expr_stmt|;
name|srel
operator|=
operator|(
name|srel
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_HH8_LDI_PM
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|srel
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|srel
operator|=
name|srel
operator|>>
literal|1
expr_stmt|;
name|srel
operator|=
operator|(
name|srel
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_LO8_LDI_PM_NEG
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|=
operator|-
name|srel
expr_stmt|;
if|if
condition|(
name|srel
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|srel
operator|=
name|srel
operator|>>
literal|1
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_HI8_LDI_PM_NEG
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|=
operator|-
name|srel
expr_stmt|;
if|if
condition|(
name|srel
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|srel
operator|=
name|srel
operator|>>
literal|1
expr_stmt|;
name|srel
operator|=
operator|(
name|srel
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_HH8_LDI_PM_NEG
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|=
operator|-
name|srel
expr_stmt|;
if|if
condition|(
name|srel
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|srel
operator|=
name|srel
operator|>>
literal|1
expr_stmt|;
name|srel
operator|=
operator|(
name|srel
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_CALL
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|srel
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|srel
operator|=
name|srel
operator|>>
literal|1
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator||=
operator|(
operator|(
name|srel
operator|&
literal|0x10000
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|3
operator|)
operator|&
literal|0x1f00000
operator|)
operator|)
operator|>>
literal|16
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|srel
operator|&
literal|0xffff
argument_list|,
name|contents
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Relocate an AVR ELF section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_avr_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|r_type
decl_stmt|;
comment|/* This is a final link.  */
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|howto
operator|=
name|elf_avr_howto_table
operator|+
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|name
operator|==
name|NULL
operator|)
condition|?
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
else|:
name|name
expr_stmt|;
block|}
else|else
block|{
name|bfd_boolean
name|unresolved_reloc
decl_stmt|,
name|warned
decl_stmt|;
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
block|}
name|r
operator|=
name|avr_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_overflow
case|:
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
argument_list|(
name|info
argument_list|,
operator|(
name|h
condition|?
operator|&
name|h
operator|->
name|root
else|:
name|NULL
operator|)
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_undefined
case|:
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: out of range error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_notsupported
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unsupported relocation error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_dangerous
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: dangerous relocation"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unknown error"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|msg
condition|)
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The final processing done just before writing out a AVR ELF object    file.  This gets the AVR architecture right based on the machine    number.  */
end_comment

begin_function
specifier|static
name|void
name|bfd_elf_avr_final_write_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|linker
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|long
name|val
decl_stmt|;
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
default|default:
case|case
name|bfd_mach_avr2
case|:
name|val
operator|=
name|E_AVR_MACH_AVR2
expr_stmt|;
break|break;
case|case
name|bfd_mach_avr1
case|:
name|val
operator|=
name|E_AVR_MACH_AVR1
expr_stmt|;
break|break;
case|case
name|bfd_mach_avr3
case|:
name|val
operator|=
name|E_AVR_MACH_AVR3
expr_stmt|;
break|break;
case|case
name|bfd_mach_avr4
case|:
name|val
operator|=
name|E_AVR_MACH_AVR4
expr_stmt|;
break|break;
case|case
name|bfd_mach_avr5
case|:
name|val
operator|=
name|E_AVR_MACH_AVR5
expr_stmt|;
break|break;
block|}
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_machine
operator|=
name|EM_AVR
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
name|EF_AVR_MACH
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator||=
name|val
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_AVR_LINKRELAX_PREPARED
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the right machine number.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_avr_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|unsigned
name|int
name|e_set
init|=
name|bfd_mach_avr2
decl_stmt|;
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_machine
operator|==
name|EM_AVR
operator|||
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_machine
operator|==
name|EM_AVR_OLD
condition|)
block|{
name|int
name|e_mach
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_AVR_MACH
decl_stmt|;
switch|switch
condition|(
name|e_mach
condition|)
block|{
default|default:
case|case
name|E_AVR_MACH_AVR2
case|:
name|e_set
operator|=
name|bfd_mach_avr2
expr_stmt|;
break|break;
case|case
name|E_AVR_MACH_AVR1
case|:
name|e_set
operator|=
name|bfd_mach_avr1
expr_stmt|;
break|break;
case|case
name|E_AVR_MACH_AVR3
case|:
name|e_set
operator|=
name|bfd_mach_avr3
expr_stmt|;
break|break;
case|case
name|E_AVR_MACH_AVR4
case|:
name|e_set
operator|=
name|bfd_mach_avr4
expr_stmt|;
break|break;
case|case
name|E_AVR_MACH_AVR5
case|:
name|e_set
operator|=
name|bfd_mach_avr5
expr_stmt|;
break|break;
block|}
block|}
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_avr
argument_list|,
name|e_set
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Enable debugging printout at stdout with a value of 1.  */
end_comment

begin_define
define|#
directive|define
name|DEBUG_RELAX
value|0
end_define

begin_comment
comment|/* Delete some bytes from a section while changing the size of an instruction.    The parameter "addr" denotes the section-relative offset pointing just    behind the shrinked instruction. "addr+count" point at the first    byte just behind the original unshrinked instruction.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_avr_relax_delete_bytes
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|unsigned
name|int
name|sec_shndx
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelalign
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymend
decl_stmt|;
name|bfd_vma
name|toaddr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|end_hashes
decl_stmt|;
name|unsigned
name|int
name|symcount
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sec_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
comment|/* The deletion must stop at the next ALIGN reloc for an aligment      power larger than the number of bytes we are deleting.  */
name|irelalign
operator|=
name|NULL
expr_stmt|;
name|toaddr
operator|=
name|sec
operator|->
name|size
expr_stmt|;
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
expr_stmt|;
name|irelend
operator|=
name|irel
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
comment|/* Actually delete the bytes.  */
if|if
condition|(
name|toaddr
operator|-
name|addr
operator|-
name|count
operator|>
literal|0
condition|)
name|memmove
argument_list|(
name|contents
operator|+
name|addr
argument_list|,
name|contents
operator|+
name|addr
operator|+
name|count
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|toaddr
operator|-
name|addr
operator|-
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|sec
operator|->
name|size
operator|-=
name|count
expr_stmt|;
comment|/* Adjust all the relocs.  */
for|for
control|(
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|symval
decl_stmt|;
name|bfd_vma
name|old_reloc_address
decl_stmt|;
name|bfd_vma
name|shrinked_insn_address
decl_stmt|;
name|old_reloc_address
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|irel
operator|->
name|r_offset
operator|)
expr_stmt|;
name|shrinked_insn_address
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|addr
operator|-
name|count
operator|)
expr_stmt|;
comment|/* Get the new reloc address.  */
if|if
condition|(
operator|(
name|irel
operator|->
name|r_offset
operator|>
name|addr
operator|&&
name|irel
operator|->
name|r_offset
operator|<
name|toaddr
operator|)
condition|)
block|{
if|if
condition|(
name|DEBUG_RELAX
condition|)
name|printf
argument_list|(
literal|"Relocation at address 0x%x needs to be moved.\n"
literal|"Old section offset: 0x%x, New section offset: 0x%x \n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|old_reloc_address
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|irel
operator|->
name|r_offset
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
name|irel
operator|->
name|r_offset
operator|)
operator|-
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_offset
operator|-=
name|count
expr_stmt|;
block|}
comment|/* The reloc's own addresses are now ok. However, we need to readjust          the reloc's addend if two conditions are met:          1.) the reloc is relative to a symbol in this section that              is located in front of the shrinked instruction          2.) symbol plus addend end up behind the shrinked instruction.           This should happen only for local symbols that are progmem related.  */
comment|/* Read this BFD's local symbols if we haven't done so already.  */
if|if
condition|(
name|isymbuf
operator|==
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Get the value of the symbol referred to by the reloc.  */
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* A local symbol.  */
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|isym
operator|=
name|isymbuf
operator|+
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|sym_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|symval
operator|=
name|isym
operator|->
name|st_value
expr_stmt|;
comment|/* If the reloc is absolute, it will not have              a symbol or section associated with it.  */
if|if
condition|(
name|sym_sec
condition|)
block|{
name|symval
operator|+=
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sym_sec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|DEBUG_RELAX
condition|)
name|printf
argument_list|(
literal|"Checking if the relocation's "
literal|"addend needs corrections.\n"
literal|"Address of anchor symbol: 0x%x \n"
literal|"Address of relocation target: 0x%x \n"
literal|"Address of relaxed insn: 0x%x \n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|symval
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|symval
operator|+
name|irel
operator|->
name|r_addend
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|shrinked_insn_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|symval
operator|<=
name|shrinked_insn_address
operator|&&
operator|(
name|symval
operator|+
name|irel
operator|->
name|r_addend
operator|)
operator|>
name|shrinked_insn_address
condition|)
block|{
name|irel
operator|->
name|r_addend
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|DEBUG_RELAX
condition|)
name|printf
argument_list|(
literal|"Anchor symbol and relocation target bracket "
literal|"shrinked insn address.\n"
literal|"Need for new addend : 0x%x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|irel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* else ... Reference symbol is absolute.  No adjustment needed.  */
block|}
comment|/* else ... Reference symbol is extern. No need for adjusting the addend.  */
block|}
comment|/* Adjust the local symbols defined in this section.  */
name|isym
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
name|isymend
operator|=
name|isym
operator|+
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
control|)
block|{
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|sec_shndx
operator|&&
name|isym
operator|->
name|st_value
operator|>
name|addr
operator|&&
name|isym
operator|->
name|st_value
operator|<
name|toaddr
condition|)
name|isym
operator|->
name|st_value
operator|-=
name|count
expr_stmt|;
block|}
comment|/* Now adjust the global symbols defined in this section.  */
name|symcount
operator|=
operator|(
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|end_hashes
operator|=
name|sym_hashes
operator|+
name|symcount
expr_stmt|;
for|for
control|(
init|;
name|sym_hashes
operator|<
name|end_hashes
condition|;
name|sym_hashes
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|sym_hash
init|=
operator|*
name|sym_hashes
decl_stmt|;
if|if
condition|(
operator|(
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|sec
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|>
name|addr
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|<
name|toaddr
condition|)
block|{
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|-=
name|count
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This function handles relaxing for the avr.    Many important relaxing opportunities within functions are already    realized by the compiler itself.    Here we try to replace  call (4 bytes) ->  rcall (2 bytes)    and jump -> rjmp (safes also 2 bytes).    As well we now optimize seqences of      - call/rcall function      - ret    to yield      - jmp/rjmp function      - ret    . In case that within a sequence      - jmp/rjmp label      - ret    the ret could no longer be reached it is optimized away. In order    to check if the ret is no longer needed, it is checked that the ret's address    is not the target of a branch or jump within the same section, it is checked    that there is no skip instruction before the jmp/rjmp and that there    is no local or global label place at the address of the ret.     We refrain from relaxing within sections ".vectors" and    ".jumptables" in order to maintain the position of the instructions.    There, however, we substitute jmp/call by a sequence rjmp,nop/rcall,nop    if possible. (In future one could possibly use the space of the nop    for the first instruction of the irq service function.     The .jumptables sections is meant to be used for a future tablejump variant    for the devices with 3-byte program counter where the table itself    contains 4-byte jump instructions whose relative offset must not    be changed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_avr_relax_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|bfd_boolean
modifier|*
name|again
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
specifier|static
name|asection
modifier|*
name|last_input_section
init|=
name|NULL
decl_stmt|;
specifier|static
name|Elf_Internal_Rela
modifier|*
name|last_reloc
init|=
name|NULL
decl_stmt|;
comment|/* Assume nothing changes.  */
operator|*
name|again
operator|=
name|FALSE
expr_stmt|;
comment|/* We don't have to do anything for a relocatable link, if      this section does not have relocs, or if this is not a      code section.  */
if|if
condition|(
name|link_info
operator|->
name|relocatable
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|sec
operator|->
name|reloc_count
operator|==
literal|0
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* Check if the object file to relax uses internal symbols so that we      could fix up the relocations.  */
if|if
condition|(
operator|!
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_AVR_LINKRELAX_PREPARED
operator|)
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
comment|/* Get a copy of the native relocations.  */
name|internal_relocs
operator|=
operator|(
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|sec
operator|!=
name|last_input_section
condition|)
name|last_reloc
operator|=
name|NULL
expr_stmt|;
name|last_input_section
operator|=
name|sec
expr_stmt|;
comment|/* Walk through the relocs looking for relaxing opportunities.  */
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|symval
decl_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_AVR_13_PCREL
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_AVR_7_PCREL
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_AVR_CALL
condition|)
continue|continue;
comment|/* Get the section contents if we haven't done so already.  */
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
block|{
comment|/* Get cached copy if it exists.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
comment|/* Go get them off disk.  */
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|&
name|contents
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* Read this BFD's local symbols if we haven't done so already.  */
if|if
condition|(
name|isymbuf
operator|==
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Get the value of the symbol referred to by the reloc.  */
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* A local symbol.  */
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|isym
operator|=
name|isymbuf
operator|+
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|sym_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|symval
operator|=
name|isym
operator|->
name|st_value
expr_stmt|;
comment|/* If the reloc is absolute, it will not have              a symbol or section associated with it.  */
if|if
condition|(
name|sym_sec
condition|)
name|symval
operator|+=
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sym_sec
operator|->
name|output_offset
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|indx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* An external symbol.  */
name|indx
operator|=
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
comment|/* This appears to be a reference to an undefined 	       symbol.  Just ignore it--it will be caught by the 	       regular reloc processing.  */
continue|continue;
name|symval
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
comment|/* For simplicity of coding, we are going to modify the section          contents, the section relocs, and the BFD symbol table.  We          must tell the rest of the code not to free up this          information.  It would be possible to instead create a table          of changes which have to be made, as is done in coff-mips.c;          that would be more work, but would require less memory when          the linker is run.  */
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
condition|)
block|{
comment|/* Try to turn a 22-bit absolute call/jump into an 13-bit             pc-relative rcall/rjmp.  */
case|case
name|R_AVR_CALL
case|:
block|{
name|bfd_vma
name|value
init|=
name|symval
operator|+
name|irel
operator|->
name|r_addend
decl_stmt|;
name|bfd_vma
name|dot
decl_stmt|,
name|gap
decl_stmt|;
name|int
name|distance_short_enough
init|=
literal|0
decl_stmt|;
comment|/* Get the address of this instruction.  */
name|dot
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|irel
operator|->
name|r_offset
operator|)
expr_stmt|;
comment|/* Compute the distance from this insn to the branch target.  */
name|gap
operator|=
name|value
operator|-
name|dot
expr_stmt|;
comment|/* If the distance is within -4094..+4098 inclusive, then we can                relax this jump/call.  +4098 because the call/jump target                will be closer after the relaxation.  */
if|if
condition|(
operator|(
name|int
operator|)
name|gap
operator|>=
operator|-
literal|4094
operator|&&
operator|(
name|int
operator|)
name|gap
operator|<=
literal|4098
condition|)
name|distance_short_enough
operator|=
literal|1
expr_stmt|;
comment|/* Here we handle the wrap-around case.  E.g. for a 16k device                we could use a rjmp to jump from address 0x100 to 0x3d00!                In order to make this work properly, we need to fill the                vaiable avr_pc_wrap_around with the appropriate value.                I.e. 0x4000 for a 16k device.  */
block|{
comment|/* Shrinking the code size makes the gaps larger in the                   case of wrap-arounds.  So we use a heuristical safety                   margin to avoid that during relax the distance gets                   again too large for the short jumps.  Let's assume                   a typical code-size reduction due to relax for a                   16k device of 600 bytes.  So let's use twice the                   typical value as safety margin.  */
name|int
name|rgap
decl_stmt|;
name|int
name|safety_margin
decl_stmt|;
name|int
name|assumed_shrink
init|=
literal|600
decl_stmt|;
if|if
condition|(
name|avr_pc_wrap_around
operator|>
literal|0x4000
condition|)
name|assumed_shrink
operator|=
literal|900
expr_stmt|;
name|safety_margin
operator|=
literal|2
operator|*
name|assumed_shrink
expr_stmt|;
name|rgap
operator|=
name|avr_relative_distance_considering_wrap_around
argument_list|(
name|gap
argument_list|)
expr_stmt|;
if|if
condition|(
name|rgap
operator|>=
operator|(
operator|-
literal|4092
operator|+
name|safety_margin
operator|)
operator|&&
name|rgap
operator|<=
operator|(
literal|4094
operator|-
name|safety_margin
operator|)
condition|)
name|distance_short_enough
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|distance_short_enough
condition|)
block|{
name|unsigned
name|char
name|code_msb
decl_stmt|;
name|unsigned
name|char
name|code_lsb
decl_stmt|;
if|if
condition|(
name|DEBUG_RELAX
condition|)
name|printf
argument_list|(
literal|"shrinking jump/call instruction at address 0x%x"
literal|" in section %s\n\n"
argument_list|,
operator|(
name|int
operator|)
name|dot
argument_list|,
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Note that we've changed the relocs, section contents,                    etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Get the instruction code for relaxing.  */
name|code_lsb
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|code_msb
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Mask out the relocation bits.  */
name|code_msb
operator|&=
literal|0x94
expr_stmt|;
name|code_lsb
operator|&=
literal|0x0E
expr_stmt|;
if|if
condition|(
name|code_msb
operator|==
literal|0x94
operator|&&
name|code_lsb
operator|==
literal|0x0E
condition|)
block|{
comment|/* we are changing call -> rcall .  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x00
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xD0
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code_msb
operator|==
literal|0x94
operator|&&
name|code_lsb
operator|==
literal|0x0C
condition|)
block|{
comment|/* we are changeing jump -> rjmp.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x00
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xC0
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_AVR_13_PCREL
argument_list|)
expr_stmt|;
comment|/* Check for the vector section. There we don't want to                    modify the ordering!  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".vectors"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".jumptables"
argument_list|)
condition|)
block|{
comment|/* Let's insert a nop.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x00
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x00
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Delete two bytes of data.  */
if|if
condition|(
operator|!
name|elf32_avr_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again.                        Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
default|default:
block|{
name|unsigned
name|char
name|code_msb
decl_stmt|;
name|unsigned
name|char
name|code_lsb
decl_stmt|;
name|bfd_vma
name|dot
decl_stmt|;
name|code_msb
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|)
expr_stmt|;
name|code_lsb
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|0
argument_list|)
expr_stmt|;
comment|/* Get the address of this instruction.  */
name|dot
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|irel
operator|->
name|r_offset
operator|)
expr_stmt|;
comment|/* Here we look for rcall/ret or call/ret sequences that could be                safely replaced by rjmp/ret or jmp/ret */
if|if
condition|(
literal|0xd0
operator|==
operator|(
name|code_msb
operator|&
literal|0xf0
operator|)
condition|)
block|{
comment|/* This insn is a rcall.  */
name|unsigned
name|char
name|next_insn_msb
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|next_insn_lsb
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|+
literal|3
operator|<
name|sec
operator|->
name|size
condition|)
block|{
name|next_insn_msb
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|3
argument_list|)
expr_stmt|;
name|next_insn_lsb
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
literal|0x95
operator|==
name|next_insn_msb
operator|)
operator|&&
operator|(
literal|0x08
operator|==
name|next_insn_lsb
operator|)
condition|)
block|{
comment|/* The next insn is a ret. We now convert the rcall insn                        into a rjmp instruction.  */
name|code_msb
operator|&=
literal|0xef
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|code_msb
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_RELAX
condition|)
name|printf
argument_list|(
literal|"converted rcall/ret sequence at address 0x%x"
literal|" into rjmp/ret sequence. Section is %s\n\n"
argument_list|,
operator|(
name|int
operator|)
name|dot
argument_list|,
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
literal|0x94
operator|==
operator|(
name|code_msb
operator|&
literal|0xfe
operator|)
operator|)
operator|&&
operator|(
literal|0x0e
operator|==
operator|(
name|code_lsb
operator|&
literal|0x0e
operator|)
operator|)
condition|)
block|{
comment|/* This insn is a call.  */
name|unsigned
name|char
name|next_insn_msb
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|next_insn_lsb
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|+
literal|5
operator|<
name|sec
operator|->
name|size
condition|)
block|{
name|next_insn_msb
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|5
argument_list|)
expr_stmt|;
name|next_insn_lsb
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
literal|0x95
operator|==
name|next_insn_msb
operator|)
operator|&&
operator|(
literal|0x08
operator|==
name|next_insn_lsb
operator|)
condition|)
block|{
comment|/* The next insn is a ret. We now convert the call insn                        into a jmp instruction.  */
name|code_lsb
operator|&=
literal|0xfd
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|code_lsb
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_RELAX
condition|)
name|printf
argument_list|(
literal|"converted call/ret sequence at address 0x%x"
literal|" into jmp/ret sequence. Section is %s\n\n"
argument_list|,
operator|(
name|int
operator|)
name|dot
argument_list|,
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
literal|0xc0
operator|==
operator|(
name|code_msb
operator|&
literal|0xf0
operator|)
operator|)
operator|||
operator|(
operator|(
literal|0x94
operator|==
operator|(
name|code_msb
operator|&
literal|0xfe
operator|)
operator|)
operator|&&
operator|(
literal|0x0c
operator|==
operator|(
name|code_lsb
operator|&
literal|0x0e
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* This insn is a rjmp or a jmp.  */
name|unsigned
name|char
name|next_insn_msb
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|next_insn_lsb
init|=
literal|0
decl_stmt|;
name|int
name|insn_size
decl_stmt|;
if|if
condition|(
literal|0xc0
operator|==
operator|(
name|code_msb
operator|&
literal|0xf0
operator|)
condition|)
name|insn_size
operator|=
literal|2
expr_stmt|;
comment|/* rjmp insn */
else|else
name|insn_size
operator|=
literal|4
expr_stmt|;
comment|/* jmp insn */
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|+
name|insn_size
operator|+
literal|1
operator|<
name|sec
operator|->
name|size
condition|)
block|{
name|next_insn_msb
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
name|insn_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|next_insn_lsb
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
name|insn_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
literal|0x95
operator|==
name|next_insn_msb
operator|)
operator|&&
operator|(
literal|0x08
operator|==
name|next_insn_lsb
operator|)
condition|)
block|{
comment|/* The next insn is a ret. We possibly could delete                        this ret. First we need to check for preceeding                        sbis/sbic/sbrs or cpse "skip" instructions.  */
name|int
name|there_is_preceeding_non_skip_insn
init|=
literal|1
decl_stmt|;
name|bfd_vma
name|address_of_ret
decl_stmt|;
name|address_of_ret
operator|=
name|dot
operator|+
name|insn_size
expr_stmt|;
if|if
condition|(
name|DEBUG_RELAX
operator|&&
operator|(
name|insn_size
operator|==
literal|2
operator|)
condition|)
name|printf
argument_list|(
literal|"found rjmp / ret sequence at address 0x%x\n"
argument_list|,
operator|(
name|int
operator|)
name|dot
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_RELAX
operator|&&
operator|(
name|insn_size
operator|==
literal|4
operator|)
condition|)
name|printf
argument_list|(
literal|"found jmp / ret sequence at address 0x%x\n"
argument_list|,
operator|(
name|int
operator|)
name|dot
argument_list|)
expr_stmt|;
comment|/* We have to make sure that there is a preceeding insn.  */
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|>=
literal|2
condition|)
block|{
name|unsigned
name|char
name|preceeding_msb
decl_stmt|;
name|unsigned
name|char
name|preceeding_lsb
decl_stmt|;
name|preceeding_msb
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
name|preceeding_lsb
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* sbic.  */
if|if
condition|(
literal|0x99
operator|==
name|preceeding_msb
condition|)
name|there_is_preceeding_non_skip_insn
operator|=
literal|0
expr_stmt|;
comment|/* sbis.  */
if|if
condition|(
literal|0x9b
operator|==
name|preceeding_msb
condition|)
name|there_is_preceeding_non_skip_insn
operator|=
literal|0
expr_stmt|;
comment|/* sbrc */
if|if
condition|(
operator|(
literal|0xfc
operator|==
operator|(
name|preceeding_msb
operator|&
literal|0xfe
operator|)
operator|&&
operator|(
literal|0x00
operator|==
operator|(
name|preceeding_lsb
operator|&
literal|0x08
operator|)
operator|)
operator|)
condition|)
name|there_is_preceeding_non_skip_insn
operator|=
literal|0
expr_stmt|;
comment|/* sbrs */
if|if
condition|(
operator|(
literal|0xfe
operator|==
operator|(
name|preceeding_msb
operator|&
literal|0xfe
operator|)
operator|&&
operator|(
literal|0x00
operator|==
operator|(
name|preceeding_lsb
operator|&
literal|0x08
operator|)
operator|)
operator|)
condition|)
name|there_is_preceeding_non_skip_insn
operator|=
literal|0
expr_stmt|;
comment|/* cpse */
if|if
condition|(
literal|0x10
operator|==
operator|(
name|preceeding_msb
operator|&
literal|0xfc
operator|)
condition|)
name|there_is_preceeding_non_skip_insn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|there_is_preceeding_non_skip_insn
operator|==
literal|0
condition|)
if|if
condition|(
name|DEBUG_RELAX
condition|)
name|printf
argument_list|(
literal|"preceeding skip insn prevents deletion of"
literal|" ret insn at addr 0x%x in section %s\n"
argument_list|,
operator|(
name|int
operator|)
name|dot
operator|+
literal|2
argument_list|,
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* There is no previous instruction.  */
name|there_is_preceeding_non_skip_insn
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|there_is_preceeding_non_skip_insn
condition|)
block|{
comment|/* We now only have to make sure that there is no                            local label defined at the address of the ret                            instruction and that there is no local relocation                            in this section pointing to the ret.  */
name|int
name|deleting_ret_is_safe
init|=
literal|1
decl_stmt|;
name|unsigned
name|int
name|section_offset_of_ret_insn
init|=
name|irel
operator|->
name|r_offset
operator|+
name|insn_size
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|,
modifier|*
name|isymend
decl_stmt|;
name|unsigned
name|int
name|sec_shndx
decl_stmt|;
name|sec_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
comment|/* Check for local symbols.  */
name|isym
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
name|isymend
operator|=
name|isym
operator|+
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
control|)
block|{
if|if
condition|(
name|isym
operator|->
name|st_value
operator|==
name|section_offset_of_ret_insn
operator|&&
name|isym
operator|->
name|st_shndx
operator|==
name|sec_shndx
condition|)
block|{
name|deleting_ret_is_safe
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DEBUG_RELAX
condition|)
name|printf
argument_list|(
literal|"local label prevents deletion of ret "
literal|"insn at address 0x%x\n"
argument_list|,
operator|(
name|int
operator|)
name|dot
operator|+
name|insn_size
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now check for global symbols.  */
block|{
name|int
name|symcount
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|end_hashes
decl_stmt|;
name|symcount
operator|=
operator|(
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|end_hashes
operator|=
name|sym_hashes
operator|+
name|symcount
expr_stmt|;
for|for
control|(
init|;
name|sym_hashes
operator|<
name|end_hashes
condition|;
name|sym_hashes
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|sym_hash
init|=
operator|*
name|sym_hashes
decl_stmt|;
if|if
condition|(
operator|(
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|sec
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|==
name|section_offset_of_ret_insn
condition|)
block|{
name|deleting_ret_is_safe
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DEBUG_RELAX
condition|)
name|printf
argument_list|(
literal|"global label prevents deletion of "
literal|"ret insn at address 0x%x\n"
argument_list|,
operator|(
name|int
operator|)
name|dot
operator|+
name|insn_size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Now we check for relocations pointing to ret.  */
block|{
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|relend
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
init|;
name|irel
operator|<
name|relend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|reloc_target
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|symval
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
comment|/* Read this BFD's local symbols if we haven't                                   done so already.  */
if|if
condition|(
name|isymbuf
operator|==
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
break|break;
block|}
comment|/* Get the value of the symbol referred to                                   by the reloc.  */
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* A local symbol.  */
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|isym
operator|=
name|isymbuf
operator|+
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|sym_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|symval
operator|=
name|isym
operator|->
name|st_value
expr_stmt|;
comment|/* If the reloc is absolute, it will not                                       have a symbol or section associated                                       with it.  */
if|if
condition|(
name|sym_sec
condition|)
block|{
name|symval
operator|+=
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sym_sec
operator|->
name|output_offset
expr_stmt|;
name|reloc_target
operator|=
name|symval
operator|+
name|irel
operator|->
name|r_addend
expr_stmt|;
block|}
else|else
block|{
name|reloc_target
operator|=
name|symval
operator|+
name|irel
operator|->
name|r_addend
expr_stmt|;
comment|/* Reference symbol is absolute.  */
block|}
block|}
comment|/* else ... reference symbol is extern.  */
if|if
condition|(
name|address_of_ret
operator|==
name|reloc_target
condition|)
block|{
name|deleting_ret_is_safe
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DEBUG_RELAX
condition|)
name|printf
argument_list|(
literal|"ret from "
literal|"rjmp/jmp ret sequence at address"
literal|" 0x%x could not be deleted. ret"
literal|" is target of a relocation.\n"
argument_list|,
operator|(
name|int
operator|)
name|address_of_ret
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|deleting_ret_is_safe
condition|)
block|{
if|if
condition|(
name|DEBUG_RELAX
condition|)
name|printf
argument_list|(
literal|"unreachable ret instruction "
literal|"at address 0x%x deleted.\n"
argument_list|,
operator|(
name|int
operator|)
name|dot
operator|+
name|insn_size
argument_list|)
expr_stmt|;
comment|/* Delete two bytes of data.  */
if|if
condition|(
operator|!
name|elf32_avr_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
name|insn_size
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax                                 again. Note that this is not required, and it                                 may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the section contents for elf_link_input_bfd.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
block|}
block|}
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* This is a version of bfd_generic_get_relocated_section_contents    which uses elf32_avr_relocate_section.     For avr it's essentially a cut and paste taken from the H8300 port.    The author of the relaxation support patch for avr had absolutely no    clue what is happening here but found out that this part of the code    seems to be important.  */
end_comment

begin_function
specifier|static
name|bfd_byte
modifier|*
name|elf32_avr_get_relocated_section_contents
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|struct
name|bfd_link_order
modifier|*
name|link_order
parameter_list|,
name|bfd_byte
modifier|*
name|data
parameter_list|,
name|bfd_boolean
name|relocatable
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|input_section
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
init|=
name|input_section
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sections
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
comment|/* We only need to handle the case of relaxing, or of having a      particular set of section contents, specially.  */
if|if
condition|(
name|relocatable
operator|||
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|==
name|NULL
condition|)
return|return
name|bfd_generic_get_relocated_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|link_info
argument_list|,
name|link_order
argument_list|,
name|data
argument_list|,
name|relocatable
argument_list|,
name|symbols
argument_list|)
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
argument_list|,
operator|(
name|size_t
operator|)
name|input_section
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|input_section
operator|->
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|asection
modifier|*
modifier|*
name|secpp
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|,
modifier|*
name|isymend
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|internal_relocs
operator|=
operator|(
name|_bfd_elf_link_read_relocs
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
name|amt
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|sections
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sections
operator|==
name|NULL
operator|&&
name|amt
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|isymend
operator|=
name|isymbuf
operator|+
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
name|isym
operator|=
name|isymbuf
operator|,
name|secpp
operator|=
name|sections
init|;
name|isym
operator|<
name|isymend
condition|;
operator|++
name|isym
operator|,
operator|++
name|secpp
control|)
block|{
name|asection
modifier|*
name|isec
decl_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|isec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|isec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|isec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
name|isec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|input_bfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
operator|*
name|secpp
operator|=
name|isec
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|elf32_avr_relocate_section
argument_list|(
name|output_bfd
argument_list|,
name|link_info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|data
argument_list|,
name|internal_relocs
argument_list|,
name|isymbuf
argument_list|,
name|sections
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
return|return
name|data
return|;
name|error_return
label|:
if|if
condition|(
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_avr
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_AVR
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT1
value|EM_AVR_OLD
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|1
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_avr_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-avr"
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|avr_info_to_howto_rela
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|NULL
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|elf32_avr_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|elf32_avr_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|elf32_avr_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|elf32_avr_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_rela_normal
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
define|\
value|bfd_elf_avr_final_write_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|elf32_avr_object_p
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_relax_section
value|elf32_avr_relax_section
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_get_relocated_section_contents
define|\
value|elf32_avr_get_relocated_section_contents
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

