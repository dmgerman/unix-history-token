begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* AVR-specific support for 32-bit ELF    Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2006, 2007    Free Software Foundation, Inc.    Contributed by Denis Chertykov<denisc@overta.ru>     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor,    Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/avr.h"
end_include

begin_include
include|#
directive|include
file|"elf32-avr.h"
end_include

begin_comment
comment|/* Enable debugging printout at stdout with this variable.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|debug_relax
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Enable debugging printout at stdout with this variable.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_boolean
name|debug_stubs
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash table initialization and handling.  Code is taken from the hppa port    and adapted to the needs of AVR.  */
end_comment

begin_comment
comment|/* We use two hash tables to hold information for linking avr objects.     The first is the elf32_avr_link_hash_tablse which is derived from the    stanard ELF linker hash table.  We use this as a place to attach the other    hash table and some static information.     The second is the stub hash table which is derived from the base BFD    hash table.  The stub hash table holds the information on the linker    stubs.  */
end_comment

begin_struct
struct|struct
name|elf32_avr_stub_hash_entry
block|{
comment|/* Base hash table entry structure.  */
name|struct
name|bfd_hash_entry
name|bh_root
decl_stmt|;
comment|/* Offset within stub_sec of the beginning of this stub.  */
name|bfd_vma
name|stub_offset
decl_stmt|;
comment|/* Given the symbol's value and its section we can determine its final      value when building the stubs (so the stub knows where to jump).  */
name|bfd_vma
name|target_value
decl_stmt|;
comment|/* This way we could mark stubs to be no longer necessary.  */
name|bfd_boolean
name|is_actually_needed
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|elf32_avr_link_hash_table
block|{
comment|/* The main hash table.  */
name|struct
name|elf_link_hash_table
name|etab
decl_stmt|;
comment|/* The stub hash table.  */
name|struct
name|bfd_hash_table
name|bstab
decl_stmt|;
name|bfd_boolean
name|no_stubs
decl_stmt|;
comment|/* Linker stub bfd.  */
name|bfd
modifier|*
name|stub_bfd
decl_stmt|;
comment|/* The stub section.  */
name|asection
modifier|*
name|stub_sec
decl_stmt|;
comment|/* Usually 0, unless we are generating code for a bootloader.  Will      be initialized by elf32_avr_size_stubs to the vma offset of the      output section associated with the stub section.  */
name|bfd_vma
name|vector_base
decl_stmt|;
comment|/* Assorted information used by elf32_avr_size_stubs.  */
name|unsigned
name|int
name|bfd_count
decl_stmt|;
name|int
name|top_index
decl_stmt|;
name|asection
modifier|*
modifier|*
name|input_list
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
modifier|*
name|all_local_syms
decl_stmt|;
comment|/* Tables for mapping vma beyond the 128k boundary to the address of the      corresponding stub.  (AMT)      "amt_max_entry_cnt" reflects the number of entries that memory is allocated      for in the "amt_stub_offsets" and "amt_destination_addr" arrays.      "amt_entry_cnt" informs how many of these entries actually contain      useful data.  */
name|unsigned
name|int
name|amt_entry_cnt
decl_stmt|;
name|unsigned
name|int
name|amt_max_entry_cnt
decl_stmt|;
name|bfd_vma
modifier|*
name|amt_stub_offsets
decl_stmt|;
name|bfd_vma
modifier|*
name|amt_destination_addr
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Various hash macros and functions.  */
end_comment

begin_define
define|#
directive|define
name|avr_link_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
comment|/* PR 3874: Check that we have an AVR style hash table before using it.  */
define|\
value|((p)->hash->table.newfunc != elf32_avr_link_hash_newfunc ? NULL : \    ((struct elf32_avr_link_hash_table *) ((p)->hash)))
end_define

begin_define
define|#
directive|define
name|avr_stub_hash_entry
parameter_list|(
name|ent
parameter_list|)
define|\
value|((struct elf32_avr_stub_hash_entry *)(ent))
end_define

begin_define
define|#
directive|define
name|avr_stub_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|)
define|\
value|((struct elf32_avr_stub_hash_entry *) \    bfd_hash_lookup ((table), (string), (create), (copy)))
end_define

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_avr_howto_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|R_AVR_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_NONE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_AVR_32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 7 bit PC relative relocation.  */
name|HOWTO
argument_list|(
name|R_AVR_7_PCREL
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|7
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|3
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_7_PCREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 13 bit PC relative relocation.  */
name|HOWTO
argument_list|(
name|R_AVR_13_PCREL
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|13
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_13_PCREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xfff
argument_list|,
comment|/* src_mask */
literal|0xfff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit absolute relocation.  */
name|HOWTO
argument_list|(
name|R_AVR_16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit absolute relocation for command address      Will be changed when linker stubs are needed.  */
name|HOWTO
argument_list|(
name|R_AVR_16_PM
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_16_PM"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A low 8 bit absolute relocation of 16 bit address.      For LDI command.  */
name|HOWTO
argument_list|(
name|R_AVR_LO8_LDI
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_LO8_LDI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A high 8 bit absolute relocation of 16 bit address.      For LDI command.  */
name|HOWTO
argument_list|(
name|R_AVR_HI8_LDI
argument_list|,
comment|/* type */
literal|8
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_HI8_LDI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A high 6 bit absolute relocation of 22 bit address.      For LDI command.  As well second most significant 8 bit value of      a 32 bit link-time constant.  */
name|HOWTO
argument_list|(
name|R_AVR_HH8_LDI
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_HH8_LDI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A negative low 8 bit absolute relocation of 16 bit address.      For LDI command.  */
name|HOWTO
argument_list|(
name|R_AVR_LO8_LDI_NEG
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_LO8_LDI_NEG"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A negative high 8 bit absolute relocation of 16 bit address.      For LDI command.  */
name|HOWTO
argument_list|(
name|R_AVR_HI8_LDI_NEG
argument_list|,
comment|/* type */
literal|8
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_HI8_LDI_NEG"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A negative high 6 bit absolute relocation of 22 bit address.      For LDI command.  */
name|HOWTO
argument_list|(
name|R_AVR_HH8_LDI_NEG
argument_list|,
comment|/* type */
literal|16
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_HH8_LDI_NEG"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A low 8 bit absolute relocation of 24 bit program memory address.      For LDI command.  Will not be changed when linker stubs are needed. */
name|HOWTO
argument_list|(
name|R_AVR_LO8_LDI_PM
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_LO8_LDI_PM"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A low 8 bit absolute relocation of 24 bit program memory address.      For LDI command.  Will not be changed when linker stubs are needed. */
name|HOWTO
argument_list|(
name|R_AVR_HI8_LDI_PM
argument_list|,
comment|/* type */
literal|9
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_HI8_LDI_PM"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A low 8 bit absolute relocation of 24 bit program memory address.      For LDI command.  Will not be changed when linker stubs are needed. */
name|HOWTO
argument_list|(
name|R_AVR_HH8_LDI_PM
argument_list|,
comment|/* type */
literal|17
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_HH8_LDI_PM"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A low 8 bit absolute relocation of 24 bit program memory address.      For LDI command.  Will not be changed when linker stubs are needed. */
name|HOWTO
argument_list|(
name|R_AVR_LO8_LDI_PM_NEG
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_LO8_LDI_PM_NEG"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A low 8 bit absolute relocation of 24 bit program memory address.      For LDI command.  Will not be changed when linker stubs are needed. */
name|HOWTO
argument_list|(
name|R_AVR_HI8_LDI_PM_NEG
argument_list|,
comment|/* type */
literal|9
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_HI8_LDI_PM_NEG"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A low 8 bit absolute relocation of 24 bit program memory address.      For LDI command.  Will not be changed when linker stubs are needed. */
name|HOWTO
argument_list|(
name|R_AVR_HH8_LDI_PM_NEG
argument_list|,
comment|/* type */
literal|17
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_HH8_LDI_PM_NEG"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Relocation for CALL command in ATmega.  */
name|HOWTO
argument_list|(
name|R_AVR_CALL
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|23
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_CALL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit absolute relocation of 16 bit address.      For LDI command.  */
name|HOWTO
argument_list|(
name|R_AVR_LDI
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_LDI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 6 bit absolute relocation of 6 bit offset.      For ldd/sdd command.  */
name|HOWTO
argument_list|(
name|R_AVR_6
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|6
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_6"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 6 bit absolute relocation of 6 bit offset.      For sbiw/adiw command.  */
name|HOWTO
argument_list|(
name|R_AVR_6_ADIW
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|6
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_6_ADIW"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Most significant 8 bit value of a 32 bit link-time constant.  */
name|HOWTO
argument_list|(
name|R_AVR_MS8_LDI
argument_list|,
comment|/* type */
literal|24
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_MS8_LDI"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* Negative most significant 8 bit value of a 32 bit link-time constant.  */
name|HOWTO
argument_list|(
name|R_AVR_MS8_LDI_NEG
argument_list|,
comment|/* type */
literal|24
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_MS8_LDI_NEG"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A low 8 bit absolute relocation of 24 bit program memory address.      For LDI command.  Will be changed when linker stubs are needed. */
name|HOWTO
argument_list|(
name|R_AVR_LO8_LDI_GS
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_LO8_LDI_GS"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A low 8 bit absolute relocation of 24 bit program memory address.      For LDI command.  Will be changed when linker stubs are needed. */
name|HOWTO
argument_list|(
argument|R_AVR_HI8_LDI_GS
argument_list|,
comment|/* type */
literal|9
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
argument|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
argument|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
argument|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_AVR_HI8_LDI_GS"
argument_list|,
comment|/* name */
argument|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
argument|FALSE
argument_list|)
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map BFD reloc types to AVR ELF reloc types.  */
end_comment

begin_struct
struct|struct
name|avr_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_val
decl_stmt|;
name|unsigned
name|int
name|elf_reloc_val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|avr_reloc_map
name|avr_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_AVR_NONE
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_AVR_32
block|}
block|,
block|{
name|BFD_RELOC_AVR_7_PCREL
block|,
name|R_AVR_7_PCREL
block|}
block|,
block|{
name|BFD_RELOC_AVR_13_PCREL
block|,
name|R_AVR_13_PCREL
block|}
block|,
block|{
name|BFD_RELOC_16
block|,
name|R_AVR_16
block|}
block|,
block|{
name|BFD_RELOC_AVR_16_PM
block|,
name|R_AVR_16_PM
block|}
block|,
block|{
name|BFD_RELOC_AVR_LO8_LDI
block|,
name|R_AVR_LO8_LDI
block|}
block|,
block|{
name|BFD_RELOC_AVR_HI8_LDI
block|,
name|R_AVR_HI8_LDI
block|}
block|,
block|{
name|BFD_RELOC_AVR_HH8_LDI
block|,
name|R_AVR_HH8_LDI
block|}
block|,
block|{
name|BFD_RELOC_AVR_MS8_LDI
block|,
name|R_AVR_MS8_LDI
block|}
block|,
block|{
name|BFD_RELOC_AVR_LO8_LDI_NEG
block|,
name|R_AVR_LO8_LDI_NEG
block|}
block|,
block|{
name|BFD_RELOC_AVR_HI8_LDI_NEG
block|,
name|R_AVR_HI8_LDI_NEG
block|}
block|,
block|{
name|BFD_RELOC_AVR_HH8_LDI_NEG
block|,
name|R_AVR_HH8_LDI_NEG
block|}
block|,
block|{
name|BFD_RELOC_AVR_MS8_LDI_NEG
block|,
name|R_AVR_MS8_LDI_NEG
block|}
block|,
block|{
name|BFD_RELOC_AVR_LO8_LDI_PM
block|,
name|R_AVR_LO8_LDI_PM
block|}
block|,
block|{
name|BFD_RELOC_AVR_LO8_LDI_GS
block|,
name|R_AVR_LO8_LDI_GS
block|}
block|,
block|{
name|BFD_RELOC_AVR_HI8_LDI_PM
block|,
name|R_AVR_HI8_LDI_PM
block|}
block|,
block|{
name|BFD_RELOC_AVR_HI8_LDI_GS
block|,
name|R_AVR_HI8_LDI_GS
block|}
block|,
block|{
name|BFD_RELOC_AVR_HH8_LDI_PM
block|,
name|R_AVR_HH8_LDI_PM
block|}
block|,
block|{
name|BFD_RELOC_AVR_LO8_LDI_PM_NEG
block|,
name|R_AVR_LO8_LDI_PM_NEG
block|}
block|,
block|{
name|BFD_RELOC_AVR_HI8_LDI_PM_NEG
block|,
name|R_AVR_HI8_LDI_PM_NEG
block|}
block|,
block|{
name|BFD_RELOC_AVR_HH8_LDI_PM_NEG
block|,
name|R_AVR_HH8_LDI_PM_NEG
block|}
block|,
block|{
name|BFD_RELOC_AVR_CALL
block|,
name|R_AVR_CALL
block|}
block|,
block|{
name|BFD_RELOC_AVR_LDI
block|,
name|R_AVR_LDI
block|}
block|,
block|{
name|BFD_RELOC_AVR_6
block|,
name|R_AVR_6
block|}
block|,
block|{
name|BFD_RELOC_AVR_6_ADIW
block|,
name|R_AVR_6_ADIW
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Meant to be filled one day with the wrap around address for the    specific device.  I.e. should get the value 0x4000 for 16k devices,    0x8000 for 32k devices and so on.     We initialize it here with a value of 0x1000000 resulting in    that we will never suggest a wrap-around jump during relaxation.    The logic of the source code later on assumes that in    avr_pc_wrap_around one single bit is set.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_vma
name|avr_pc_wrap_around
init|=
literal|0x10000000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If this variable holds a value different from zero, the linker relaxation    machine will try to optimize call/ret sequences by a single jump    instruction. This option could be switched off by a linker switch.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|avr_replace_call_ret_sequences
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize an entry in the stub hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|stub_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|entry
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf32_avr_stub_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|entry
return|;
block|}
comment|/* Call the allocation method of the superclass.  */
name|entry
operator|=
name|bfd_hash_newfunc
argument_list|(
name|entry
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf32_avr_stub_hash_entry
modifier|*
name|hsh
decl_stmt|;
comment|/* Initialize the local fields.  */
name|hsh
operator|=
name|avr_stub_hash_entry
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|hsh
operator|->
name|stub_offset
operator|=
literal|0
expr_stmt|;
name|hsh
operator|->
name|target_value
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* This function is just a straight passthrough to the real    function in linker.c.  Its prupose is so that its address    can be compared inside the avr_link_hash_table macro.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|elf32_avr_link_hash_newfunc
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|bfd_hash_table
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
return|return
name|_bfd_elf_link_hash_newfunc
argument_list|(
name|entry
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create the derived linker hash table.  The AVR ELF port uses the derived    hash table to keep information specific to the AVR ELF linker (without    using static variables).  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elf32_avr_link_hash_table_create
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|elf32_avr_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
operator|*
name|htab
argument_list|)
decl_stmt|;
name|htab
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|htab
operator|->
name|etab
argument_list|,
name|abfd
argument_list|,
name|elf32_avr_link_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_hash_entry
argument_list|)
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|htab
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Init the stub hash table too.  */
if|if
condition|(
operator|!
name|bfd_hash_table_init
argument_list|(
operator|&
name|htab
operator|->
name|bstab
argument_list|,
name|stub_hash_newfunc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf32_avr_stub_hash_entry
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
name|htab
operator|->
name|stub_bfd
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|stub_sec
operator|=
name|NULL
expr_stmt|;
comment|/* Initialize the address mapping table.  */
name|htab
operator|->
name|amt_stub_offsets
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|amt_destination_addr
operator|=
name|NULL
expr_stmt|;
name|htab
operator|->
name|amt_entry_cnt
operator|=
literal|0
expr_stmt|;
name|htab
operator|->
name|amt_max_entry_cnt
operator|=
literal|0
expr_stmt|;
return|return
operator|&
name|htab
operator|->
name|etab
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Free the derived linker hash table.  */
end_comment

begin_function
specifier|static
name|void
name|elf32_avr_link_hash_table_free
parameter_list|(
name|struct
name|bfd_link_hash_table
modifier|*
name|btab
parameter_list|)
block|{
name|struct
name|elf32_avr_link_hash_table
modifier|*
name|htab
init|=
operator|(
expr|struct
name|elf32_avr_link_hash_table
operator|*
operator|)
name|btab
decl_stmt|;
comment|/* Free the address mapping table.  */
if|if
condition|(
name|htab
operator|->
name|amt_stub_offsets
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|htab
operator|->
name|amt_stub_offsets
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|amt_destination_addr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|htab
operator|->
name|amt_destination_addr
argument_list|)
expr_stmt|;
name|bfd_hash_table_free
argument_list|(
operator|&
name|htab
operator|->
name|bstab
argument_list|)
expr_stmt|;
name|_bfd_generic_link_hash_table_free
argument_list|(
name|btab
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Calculates the effective distance of a pc relative jump/call.  */
end_comment

begin_function
specifier|static
name|int
name|avr_relative_distance_considering_wrap_around
parameter_list|(
name|unsigned
name|int
name|distance
parameter_list|)
block|{
name|unsigned
name|int
name|wrap_around_mask
init|=
name|avr_pc_wrap_around
operator|-
literal|1
decl_stmt|;
name|int
name|dist_with_wrap_around
init|=
name|distance
operator|&
name|wrap_around_mask
decl_stmt|;
if|if
condition|(
name|dist_with_wrap_around
operator|>
operator|(
call|(
name|int
call|)
argument_list|(
name|avr_pc_wrap_around
operator|>>
literal|1
argument_list|)
operator|)
condition|)
name|dist_with_wrap_around
operator|-=
name|avr_pc_wrap_around
expr_stmt|;
return|return
name|dist_with_wrap_around
return|;
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|bfd_elf32_bfd_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|avr_reloc_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|avr_reloc_map
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|avr_reloc_map
index|[
name|i
index|]
operator|.
name|bfd_reloc_val
operator|==
name|code
condition|)
return|return
operator|&
name|elf_avr_howto_table
index|[
name|avr_reloc_map
index|[
name|i
index|]
operator|.
name|elf_reloc_val
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|bfd_elf32_bfd_reloc_name_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|r_name
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|elf_avr_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|elf_avr_howto_table
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|elf_avr_howto_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcasecmp
argument_list|(
name|elf_avr_howto_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|elf_avr_howto_table
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set the howto pointer for an AVR ELF reloc.  */
end_comment

begin_function
specifier|static
name|void
name|avr_info_to_howto_rela
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|cache_ptr
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|dst
parameter_list|)
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r_type
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_AVR_max
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf_avr_howto_table
index|[
name|r_type
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look through the relocs for a section during the first phase.    Since we don't do .gots or .plts, we just need to consider the    virtual table relocs for gc.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_avr_check_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|,
modifier|*
modifier|*
name|sym_hashes_end
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sym_hashes_end
operator|=
name|sym_hashes
operator|+
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|sym_hashes_end
operator|-=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|avr_stub_is_required_for_16_bit_reloc
parameter_list|(
name|bfd_vma
name|relocation
parameter_list|)
block|{
return|return
operator|(
name|relocation
operator|>=
literal|0x020000
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the address of the corresponding stub if there is one.    Returns otherwise an address above 0x020000.  This function    could also be used, if there is no knowledge on the section where    the destination is found.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|avr_get_stub_addr
parameter_list|(
name|bfd_vma
name|srel
parameter_list|,
name|struct
name|elf32_avr_link_hash_table
modifier|*
name|htab
parameter_list|)
block|{
name|unsigned
name|int
name|index
decl_stmt|;
name|bfd_vma
name|stub_sec_addr
init|=
operator|(
name|htab
operator|->
name|stub_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|stub_sec
operator|->
name|output_offset
operator|)
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|htab
operator|->
name|amt_max_entry_cnt
condition|;
name|index
operator|++
control|)
if|if
condition|(
name|htab
operator|->
name|amt_destination_addr
index|[
name|index
index|]
operator|==
name|srel
condition|)
return|return
name|htab
operator|->
name|amt_stub_offsets
index|[
name|index
index|]
operator|+
name|stub_sec_addr
return|;
comment|/* Return an address that could not be reached by 16 bit relocs.  */
return|return
literal|0x020000
return|;
block|}
end_function

begin_comment
comment|/* Perform a single relocation.  By default we use the standard BFD    routines, but a few relocs, we have to do them ourselves.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|avr_final_link_relocate
parameter_list|(
name|reloc_howto_type
modifier|*
name|howto
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|bfd_vma
name|relocation
parameter_list|,
name|struct
name|elf32_avr_link_hash_table
modifier|*
name|htab
parameter_list|)
block|{
name|bfd_reloc_status_type
name|r
init|=
name|bfd_reloc_ok
decl_stmt|;
name|bfd_vma
name|x
decl_stmt|;
name|bfd_signed_vma
name|srel
decl_stmt|;
name|bfd_signed_vma
name|reloc_addr
decl_stmt|;
name|bfd_boolean
name|use_stubs
init|=
name|FALSE
decl_stmt|;
comment|/* Usually is 0, unless we are generating code for a bootloader.  */
name|bfd_signed_vma
name|base_addr
init|=
name|htab
operator|->
name|vector_base
decl_stmt|;
comment|/* Absolute addr of the reloc in the final excecutable.  */
name|reloc_addr
operator|=
name|rel
operator|->
name|r_offset
operator|+
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
expr_stmt|;
switch|switch
condition|(
name|howto
operator|->
name|type
condition|)
block|{
case|case
name|R_AVR_7_PCREL
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
expr_stmt|;
name|srel
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|-=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|-=
literal|2
expr_stmt|;
comment|/* Branch instructions add 2 to the PC...  */
name|srel
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|srel
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
if|if
condition|(
name|srel
operator|>
operator|(
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|-
literal|1
operator|)
operator|||
operator|(
name|srel
operator|<
operator|-
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
condition|)
return|return
name|bfd_reloc_overflow
return|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xfc07
operator|)
operator||
operator|(
operator|(
operator|(
name|srel
operator|>>
literal|1
operator|)
operator|<<
literal|3
operator|)
operator|&
literal|0x3f8
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_13_PCREL
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
expr_stmt|;
name|srel
operator|+=
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|-=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|-=
literal|2
expr_stmt|;
comment|/* Branch instructions add 2 to the PC...  */
name|srel
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|srel
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|srel
operator|=
name|avr_relative_distance_considering_wrap_around
argument_list|(
name|srel
argument_list|)
expr_stmt|;
comment|/* AVR addresses commands as words.  */
name|srel
operator|>>=
literal|1
expr_stmt|;
comment|/* Check for overflow.  */
if|if
condition|(
name|srel
operator|<
operator|-
literal|2048
operator|||
name|srel
operator|>
literal|2047
condition|)
block|{
comment|/* Relative distance is too large.  */
comment|/* Always apply WRAPAROUND for avr2 and avr4.  */
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
case|case
name|bfd_mach_avr2
case|:
case|case
name|bfd_mach_avr4
case|:
break|break;
default|default:
return|return
name|bfd_reloc_overflow
return|;
block|}
block|}
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf000
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xfff
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_LO8_LDI
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_LDI
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|srel
operator|>
literal|0
operator|)
operator|&&
operator|(
name|srel
operator|&
literal|0xffff
operator|)
operator|>
literal|255
operator|)
operator|||
operator|(
operator|(
name|srel
operator|<
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|-
name|srel
operator|)
operator|&
literal|0xffff
operator|)
operator|>
literal|128
operator|)
condition|)
comment|/* Remove offset for data/eeprom section.  */
return|return
name|bfd_reloc_overflow
return|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_6
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|srel
operator|&
literal|0xffff
operator|)
operator|>
literal|63
operator|)
operator|||
operator|(
name|srel
operator|<
literal|0
operator|)
condition|)
comment|/* Remove offset for data/eeprom section.  */
return|return
name|bfd_reloc_overflow
return|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xd3f8
operator|)
operator||
operator|(
operator|(
name|srel
operator|&
literal|7
operator|)
operator||
operator|(
operator|(
name|srel
operator|&
operator|(
literal|3
operator|<<
literal|3
operator|)
operator|)
operator|<<
literal|7
operator|)
operator||
operator|(
operator|(
name|srel
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_6_ADIW
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|srel
operator|&
literal|0xffff
operator|)
operator|>
literal|63
operator|)
operator|||
operator|(
name|srel
operator|<
literal|0
operator|)
condition|)
comment|/* Remove offset for data/eeprom section.  */
return|return
name|bfd_reloc_overflow
return|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xff30
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|&
literal|0x30
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_HI8_LDI
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|=
operator|(
name|srel
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_HH8_LDI
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|=
operator|(
name|srel
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_MS8_LDI
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|=
operator|(
name|srel
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_LO8_LDI_NEG
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|=
operator|-
name|srel
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_HI8_LDI_NEG
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|=
operator|-
name|srel
expr_stmt|;
name|srel
operator|=
operator|(
name|srel
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_HH8_LDI_NEG
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|=
operator|-
name|srel
expr_stmt|;
name|srel
operator|=
operator|(
name|srel
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_MS8_LDI_NEG
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|=
operator|-
name|srel
expr_stmt|;
name|srel
operator|=
operator|(
name|srel
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_LO8_LDI_GS
case|:
name|use_stubs
operator|=
operator|(
operator|!
name|htab
operator|->
name|no_stubs
operator|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|R_AVR_LO8_LDI_PM
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|use_stubs
operator|&&
name|avr_stub_is_required_for_16_bit_reloc
argument_list|(
name|srel
operator|-
name|base_addr
argument_list|)
condition|)
block|{
name|bfd_vma
name|old_srel
init|=
name|srel
decl_stmt|;
comment|/* We need to use the address of the stub instead.  */
name|srel
operator|=
name|avr_get_stub_addr
argument_list|(
name|srel
argument_list|,
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_stubs
condition|)
name|printf
argument_list|(
literal|"LD: Using jump stub (at 0x%x) with destination 0x%x for "
literal|"reloc at address 0x%x.\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|srel
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|old_srel
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|reloc_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|avr_stub_is_required_for_16_bit_reloc
argument_list|(
name|srel
operator|-
name|base_addr
argument_list|)
condition|)
return|return
name|bfd_reloc_outofrange
return|;
block|}
if|if
condition|(
name|srel
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|srel
operator|=
name|srel
operator|>>
literal|1
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_HI8_LDI_GS
case|:
name|use_stubs
operator|=
operator|(
operator|!
name|htab
operator|->
name|no_stubs
operator|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|R_AVR_HI8_LDI_PM
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|use_stubs
operator|&&
name|avr_stub_is_required_for_16_bit_reloc
argument_list|(
name|srel
operator|-
name|base_addr
argument_list|)
condition|)
block|{
name|bfd_vma
name|old_srel
init|=
name|srel
decl_stmt|;
comment|/* We need to use the address of the stub instead.  */
name|srel
operator|=
name|avr_get_stub_addr
argument_list|(
name|srel
argument_list|,
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_stubs
condition|)
name|printf
argument_list|(
literal|"LD: Using jump stub (at 0x%x) with destination 0x%x for "
literal|"reloc at address 0x%x.\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|srel
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|old_srel
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|reloc_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|avr_stub_is_required_for_16_bit_reloc
argument_list|(
name|srel
operator|-
name|base_addr
argument_list|)
condition|)
return|return
name|bfd_reloc_outofrange
return|;
block|}
if|if
condition|(
name|srel
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|srel
operator|=
name|srel
operator|>>
literal|1
expr_stmt|;
name|srel
operator|=
operator|(
name|srel
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_HH8_LDI_PM
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|srel
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|srel
operator|=
name|srel
operator|>>
literal|1
expr_stmt|;
name|srel
operator|=
operator|(
name|srel
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_LO8_LDI_PM_NEG
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|=
operator|-
name|srel
expr_stmt|;
if|if
condition|(
name|srel
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|srel
operator|=
name|srel
operator|>>
literal|1
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_HI8_LDI_PM_NEG
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|=
operator|-
name|srel
expr_stmt|;
if|if
condition|(
name|srel
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|srel
operator|=
name|srel
operator|>>
literal|1
expr_stmt|;
name|srel
operator|=
operator|(
name|srel
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_HH8_LDI_PM_NEG
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
name|srel
operator|=
operator|-
name|srel
expr_stmt|;
if|if
condition|(
name|srel
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|srel
operator|=
name|srel
operator|>>
literal|1
expr_stmt|;
name|srel
operator|=
operator|(
name|srel
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0f0
operator|)
operator||
operator|(
name|srel
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|4
operator|)
operator|&
literal|0xf00
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_CALL
case|:
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|srel
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|srel
operator|=
name|srel
operator|>>
literal|1
expr_stmt|;
name|x
operator|=
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|x
operator||=
operator|(
operator|(
name|srel
operator|&
literal|0x10000
operator|)
operator||
operator|(
operator|(
name|srel
operator|<<
literal|3
operator|)
operator|&
literal|0x1f00000
operator|)
operator|)
operator|>>
literal|16
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|contents
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|srel
operator|&
literal|0xffff
argument_list|,
name|contents
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_AVR_16_PM
case|:
name|use_stubs
operator|=
operator|(
operator|!
name|htab
operator|->
name|no_stubs
operator|)
expr_stmt|;
name|contents
operator|+=
name|rel
operator|->
name|r_offset
expr_stmt|;
name|srel
operator|=
operator|(
name|bfd_signed_vma
operator|)
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|use_stubs
operator|&&
name|avr_stub_is_required_for_16_bit_reloc
argument_list|(
name|srel
operator|-
name|base_addr
argument_list|)
condition|)
block|{
name|bfd_vma
name|old_srel
init|=
name|srel
decl_stmt|;
comment|/* We need to use the address of the stub instead.  */
name|srel
operator|=
name|avr_get_stub_addr
argument_list|(
name|srel
argument_list|,
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_stubs
condition|)
name|printf
argument_list|(
literal|"LD: Using jump stub (at 0x%x) with destination 0x%x for "
literal|"reloc at address 0x%x.\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|srel
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|old_srel
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|reloc_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|avr_stub_is_required_for_16_bit_reloc
argument_list|(
name|srel
operator|-
name|base_addr
argument_list|)
condition|)
return|return
name|bfd_reloc_outofrange
return|;
block|}
if|if
condition|(
name|srel
operator|&
literal|1
condition|)
return|return
name|bfd_reloc_outofrange
return|;
name|srel
operator|=
name|srel
operator|>>
literal|1
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|srel
operator|&
literal|0x00ffff
argument_list|,
name|contents
argument_list|)
expr_stmt|;
break|break;
default|default:
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Relocate an AVR ELF section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_avr_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|struct
name|elf32_avr_link_hash_table
modifier|*
name|htab
init|=
name|avr_link_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|howto
operator|=
name|elf_avr_howto_table
operator|+
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|name
operator|==
name|NULL
operator|)
condition|?
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
else|:
name|name
expr_stmt|;
block|}
else|else
block|{
name|bfd_boolean
name|unresolved_reloc
decl_stmt|,
name|warned
decl_stmt|;
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
block|}
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|elf_discarded_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
comment|/* For relocs against symbols from removed linkonce sections, 	     or sections discarded by a linker script, we just want the 	     section contents zeroed.  Avoid any special processing.  */
name|_bfd_clear_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
continue|continue;
name|r
operator|=
name|avr_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
argument_list|,
name|relocation
argument_list|,
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_overflow
case|:
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
argument_list|(
name|info
argument_list|,
operator|(
name|h
condition|?
operator|&
name|h
operator|->
name|root
else|:
name|NULL
operator|)
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_undefined
case|:
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: out of range error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_notsupported
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unsupported relocation error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_dangerous
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: dangerous relocation"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unknown error"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|msg
condition|)
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The final processing done just before writing out a AVR ELF object    file.  This gets the AVR architecture right based on the machine    number.  */
end_comment

begin_function
specifier|static
name|void
name|bfd_elf_avr_final_write_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|linker
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|long
name|val
decl_stmt|;
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
default|default:
case|case
name|bfd_mach_avr2
case|:
name|val
operator|=
name|E_AVR_MACH_AVR2
expr_stmt|;
break|break;
case|case
name|bfd_mach_avr1
case|:
name|val
operator|=
name|E_AVR_MACH_AVR1
expr_stmt|;
break|break;
case|case
name|bfd_mach_avr3
case|:
name|val
operator|=
name|E_AVR_MACH_AVR3
expr_stmt|;
break|break;
case|case
name|bfd_mach_avr4
case|:
name|val
operator|=
name|E_AVR_MACH_AVR4
expr_stmt|;
break|break;
case|case
name|bfd_mach_avr5
case|:
name|val
operator|=
name|E_AVR_MACH_AVR5
expr_stmt|;
break|break;
case|case
name|bfd_mach_avr6
case|:
name|val
operator|=
name|E_AVR_MACH_AVR6
expr_stmt|;
break|break;
block|}
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_machine
operator|=
name|EM_AVR
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
name|EF_AVR_MACH
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator||=
name|val
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator||=
name|EF_AVR_LINKRELAX_PREPARED
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the right machine number.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_avr_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|unsigned
name|int
name|e_set
init|=
name|bfd_mach_avr2
decl_stmt|;
if|if
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_machine
operator|==
name|EM_AVR
operator|||
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_machine
operator|==
name|EM_AVR_OLD
condition|)
block|{
name|int
name|e_mach
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_AVR_MACH
decl_stmt|;
switch|switch
condition|(
name|e_mach
condition|)
block|{
default|default:
case|case
name|E_AVR_MACH_AVR2
case|:
name|e_set
operator|=
name|bfd_mach_avr2
expr_stmt|;
break|break;
case|case
name|E_AVR_MACH_AVR1
case|:
name|e_set
operator|=
name|bfd_mach_avr1
expr_stmt|;
break|break;
case|case
name|E_AVR_MACH_AVR3
case|:
name|e_set
operator|=
name|bfd_mach_avr3
expr_stmt|;
break|break;
case|case
name|E_AVR_MACH_AVR4
case|:
name|e_set
operator|=
name|bfd_mach_avr4
expr_stmt|;
break|break;
case|case
name|E_AVR_MACH_AVR5
case|:
name|e_set
operator|=
name|bfd_mach_avr5
expr_stmt|;
break|break;
case|case
name|E_AVR_MACH_AVR6
case|:
name|e_set
operator|=
name|bfd_mach_avr6
expr_stmt|;
break|break;
block|}
block|}
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_avr
argument_list|,
name|e_set
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Delete some bytes from a section while changing the size of an instruction.    The parameter "addr" denotes the section-relative offset pointing just    behind the shrinked instruction. "addr+count" point at the first    byte just behind the original unshrinked instruction.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_avr_relax_delete_bytes
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|unsigned
name|int
name|sec_shndx
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelalign
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymend
decl_stmt|;
name|bfd_vma
name|toaddr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|end_hashes
decl_stmt|;
name|unsigned
name|int
name|symcount
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sec_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
comment|/* The deletion must stop at the next ALIGN reloc for an aligment      power larger than the number of bytes we are deleting.  */
name|irelalign
operator|=
name|NULL
expr_stmt|;
name|toaddr
operator|=
name|sec
operator|->
name|size
expr_stmt|;
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
expr_stmt|;
name|irelend
operator|=
name|irel
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
comment|/* Actually delete the bytes.  */
if|if
condition|(
name|toaddr
operator|-
name|addr
operator|-
name|count
operator|>
literal|0
condition|)
name|memmove
argument_list|(
name|contents
operator|+
name|addr
argument_list|,
name|contents
operator|+
name|addr
operator|+
name|count
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|toaddr
operator|-
name|addr
operator|-
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|sec
operator|->
name|size
operator|-=
name|count
expr_stmt|;
comment|/* Adjust all the reloc addresses.  */
for|for
control|(
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|old_reloc_address
decl_stmt|;
name|bfd_vma
name|shrinked_insn_address
decl_stmt|;
name|old_reloc_address
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|irel
operator|->
name|r_offset
operator|)
expr_stmt|;
name|shrinked_insn_address
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|addr
operator|-
name|count
operator|)
expr_stmt|;
comment|/* Get the new reloc address.  */
if|if
condition|(
operator|(
name|irel
operator|->
name|r_offset
operator|>
name|addr
operator|&&
name|irel
operator|->
name|r_offset
operator|<
name|toaddr
operator|)
condition|)
block|{
if|if
condition|(
name|debug_relax
condition|)
name|printf
argument_list|(
literal|"Relocation at address 0x%x needs to be moved.\n"
literal|"Old section offset: 0x%x, New section offset: 0x%x \n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|old_reloc_address
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|irel
operator|->
name|r_offset
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
name|irel
operator|->
name|r_offset
operator|)
operator|-
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_offset
operator|-=
name|count
expr_stmt|;
block|}
block|}
comment|/* The reloc's own addresses are now ok. However, we need to readjust       the reloc's addend, i.e. the reloc's value if two conditions are met:       1.) the reloc is relative to a symbol in this section that           is located in front of the shrinked instruction       2.) symbol plus addend end up behind the shrinked instruction.        The most common case where this happens are relocs relative to       the section-start symbol.        This step needs to be done for all of the sections of the bfd.  */
block|{
name|struct
name|bfd_section
modifier|*
name|isec
decl_stmt|;
for|for
control|(
name|isec
operator|=
name|abfd
operator|->
name|sections
init|;
name|isec
condition|;
name|isec
operator|=
name|isec
operator|->
name|next
control|)
block|{
name|bfd_vma
name|symval
decl_stmt|;
name|bfd_vma
name|shrinked_insn_address
decl_stmt|;
name|shrinked_insn_address
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|addr
operator|-
name|count
operator|)
expr_stmt|;
name|irelend
operator|=
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|relocs
operator|+
name|isec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
comment|/* Read this BFD's local symbols if we haven't done               so already.  */
if|if
condition|(
name|isymbuf
operator|==
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Get the value of the symbol referred to by the reloc.  */
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* A local symbol.  */
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|isym
operator|=
name|isymbuf
operator|+
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|sym_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|symval
operator|=
name|isym
operator|->
name|st_value
expr_stmt|;
comment|/* If the reloc is absolute, it will not have                   a symbol or section associated with it.  */
if|if
condition|(
name|sym_sec
operator|==
name|sec
condition|)
block|{
name|symval
operator|+=
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sym_sec
operator|->
name|output_offset
expr_stmt|;
if|if
condition|(
name|debug_relax
condition|)
name|printf
argument_list|(
literal|"Checking if the relocation's "
literal|"addend needs corrections.\n"
literal|"Address of anchor symbol: 0x%x \n"
literal|"Address of relocation target: 0x%x \n"
literal|"Address of relaxed insn: 0x%x \n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|symval
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|symval
operator|+
name|irel
operator|->
name|r_addend
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|shrinked_insn_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|symval
operator|<=
name|shrinked_insn_address
operator|&&
operator|(
name|symval
operator|+
name|irel
operator|->
name|r_addend
operator|)
operator|>
name|shrinked_insn_address
condition|)
block|{
name|irel
operator|->
name|r_addend
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|debug_relax
condition|)
name|printf
argument_list|(
literal|"Relocation's addend needed to be fixed \n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* else...Reference symbol is absolute.  No adjustment needed.  */
block|}
comment|/* else...Reference symbol is extern.  No need for adjusting 	      the addend.  */
block|}
block|}
block|}
comment|/* Adjust the local symbols defined in this section.  */
name|isym
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
name|isymend
operator|=
name|isym
operator|+
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
control|)
block|{
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|sec_shndx
operator|&&
name|isym
operator|->
name|st_value
operator|>
name|addr
operator|&&
name|isym
operator|->
name|st_value
operator|<
name|toaddr
condition|)
name|isym
operator|->
name|st_value
operator|-=
name|count
expr_stmt|;
block|}
comment|/* Now adjust the global symbols defined in this section.  */
name|symcount
operator|=
operator|(
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|end_hashes
operator|=
name|sym_hashes
operator|+
name|symcount
expr_stmt|;
for|for
control|(
init|;
name|sym_hashes
operator|<
name|end_hashes
condition|;
name|sym_hashes
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|sym_hash
init|=
operator|*
name|sym_hashes
decl_stmt|;
if|if
condition|(
operator|(
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|sec
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|>
name|addr
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|<
name|toaddr
condition|)
block|{
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|-=
name|count
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This function handles relaxing for the avr.    Many important relaxing opportunities within functions are already    realized by the compiler itself.    Here we try to replace  call (4 bytes) ->  rcall (2 bytes)    and jump -> rjmp (safes also 2 bytes).    As well we now optimize seqences of      - call/rcall function      - ret    to yield      - jmp/rjmp function      - ret    . In case that within a sequence      - jmp/rjmp label      - ret    the ret could no longer be reached it is optimized away. In order    to check if the ret is no longer needed, it is checked that the ret's address    is not the target of a branch or jump within the same section, it is checked    that there is no skip instruction before the jmp/rjmp and that there    is no local or global label place at the address of the ret.     We refrain from relaxing within sections ".vectors" and    ".jumptables" in order to maintain the position of the instructions.    There, however, we substitute jmp/call by a sequence rjmp,nop/rcall,nop    if possible. (In future one could possibly use the space of the nop    for the first instruction of the irq service function.     The .jumptables sections is meant to be used for a future tablejump variant    for the devices with 3-byte program counter where the table itself    contains 4-byte jump instructions whose relative offset must not    be changed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_avr_relax_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|bfd_boolean
modifier|*
name|again
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
specifier|static
name|asection
modifier|*
name|last_input_section
init|=
name|NULL
decl_stmt|;
specifier|static
name|Elf_Internal_Rela
modifier|*
name|last_reloc
init|=
name|NULL
decl_stmt|;
name|struct
name|elf32_avr_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|avr_link_hash_table
argument_list|(
name|link_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Assume nothing changes.  */
operator|*
name|again
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|htab
operator|->
name|no_stubs
operator|)
operator|&&
operator|(
name|sec
operator|==
name|htab
operator|->
name|stub_sec
operator|)
condition|)
block|{
comment|/* We are just relaxing the stub section. 	 Let's calculate the size needed again.  */
name|bfd_size_type
name|last_estimated_stub_section_size
init|=
name|htab
operator|->
name|stub_sec
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|debug_relax
condition|)
name|printf
argument_list|(
literal|"Relaxing the stub section. Size prior to this pass: %i\n"
argument_list|,
operator|(
name|int
operator|)
name|last_estimated_stub_section_size
argument_list|)
expr_stmt|;
name|elf32_avr_size_stubs
argument_list|(
name|htab
operator|->
name|stub_sec
operator|->
name|output_section
operator|->
name|owner
argument_list|,
name|link_info
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Check if the number of trampolines changed.  */
if|if
condition|(
name|last_estimated_stub_section_size
operator|!=
name|htab
operator|->
name|stub_sec
operator|->
name|size
condition|)
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|debug_relax
condition|)
name|printf
argument_list|(
literal|"Size of stub section after this pass: %i\n"
argument_list|,
operator|(
name|int
operator|)
name|htab
operator|->
name|stub_sec
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* We don't have to do anything for a relocatable link, if      this section does not have relocs, or if this is not a      code section.  */
if|if
condition|(
name|link_info
operator|->
name|relocatable
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|sec
operator|->
name|reloc_count
operator|==
literal|0
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* Check if the object file to relax uses internal symbols so that we      could fix up the relocations.  */
if|if
condition|(
operator|!
operator|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_AVR_LINKRELAX_PREPARED
operator|)
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
comment|/* Get a copy of the native relocations.  */
name|internal_relocs
operator|=
operator|(
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|sec
operator|!=
name|last_input_section
condition|)
name|last_reloc
operator|=
name|NULL
expr_stmt|;
name|last_input_section
operator|=
name|sec
expr_stmt|;
comment|/* Walk through the relocs looking for relaxing opportunities.  */
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|symval
decl_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_AVR_13_PCREL
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_AVR_7_PCREL
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_AVR_CALL
condition|)
continue|continue;
comment|/* Get the section contents if we haven't done so already.  */
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
block|{
comment|/* Get cached copy if it exists.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
comment|/* Go get them off disk.  */
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|&
name|contents
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* Read this BFD's local symbols if we haven't done so already.  */
if|if
condition|(
name|isymbuf
operator|==
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Get the value of the symbol referred to by the reloc.  */
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* A local symbol.  */
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|isym
operator|=
name|isymbuf
operator|+
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|sym_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|symval
operator|=
name|isym
operator|->
name|st_value
expr_stmt|;
comment|/* If the reloc is absolute, it will not have              a symbol or section associated with it.  */
if|if
condition|(
name|sym_sec
condition|)
name|symval
operator|+=
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sym_sec
operator|->
name|output_offset
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|indx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* An external symbol.  */
name|indx
operator|=
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
comment|/* This appears to be a reference to an undefined 	       symbol.  Just ignore it--it will be caught by the 	       regular reloc processing.  */
continue|continue;
name|symval
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
comment|/* For simplicity of coding, we are going to modify the section          contents, the section relocs, and the BFD symbol table.  We          must tell the rest of the code not to free up this          information.  It would be possible to instead create a table          of changes which have to be made, as is done in coff-mips.c;          that would be more work, but would require less memory when          the linker is run.  */
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
condition|)
block|{
comment|/* Try to turn a 22-bit absolute call/jump into an 13-bit             pc-relative rcall/rjmp.  */
case|case
name|R_AVR_CALL
case|:
block|{
name|bfd_vma
name|value
init|=
name|symval
operator|+
name|irel
operator|->
name|r_addend
decl_stmt|;
name|bfd_vma
name|dot
decl_stmt|,
name|gap
decl_stmt|;
name|int
name|distance_short_enough
init|=
literal|0
decl_stmt|;
comment|/* Get the address of this instruction.  */
name|dot
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|irel
operator|->
name|r_offset
operator|)
expr_stmt|;
comment|/* Compute the distance from this insn to the branch target.  */
name|gap
operator|=
name|value
operator|-
name|dot
expr_stmt|;
comment|/* If the distance is within -4094..+4098 inclusive, then we can                relax this jump/call.  +4098 because the call/jump target                will be closer after the relaxation.  */
if|if
condition|(
operator|(
name|int
operator|)
name|gap
operator|>=
operator|-
literal|4094
operator|&&
operator|(
name|int
operator|)
name|gap
operator|<=
literal|4098
condition|)
name|distance_short_enough
operator|=
literal|1
expr_stmt|;
comment|/* Here we handle the wrap-around case.  E.g. for a 16k device                we could use a rjmp to jump from address 0x100 to 0x3d00!                In order to make this work properly, we need to fill the                vaiable avr_pc_wrap_around with the appropriate value.                I.e. 0x4000 for a 16k device.  */
block|{
comment|/* Shrinking the code size makes the gaps larger in the                   case of wrap-arounds.  So we use a heuristical safety                   margin to avoid that during relax the distance gets                   again too large for the short jumps.  Let's assume                   a typical code-size reduction due to relax for a                   16k device of 600 bytes.  So let's use twice the                   typical value as safety margin.  */
name|int
name|rgap
decl_stmt|;
name|int
name|safety_margin
decl_stmt|;
name|int
name|assumed_shrink
init|=
literal|600
decl_stmt|;
if|if
condition|(
name|avr_pc_wrap_around
operator|>
literal|0x4000
condition|)
name|assumed_shrink
operator|=
literal|900
expr_stmt|;
name|safety_margin
operator|=
literal|2
operator|*
name|assumed_shrink
expr_stmt|;
name|rgap
operator|=
name|avr_relative_distance_considering_wrap_around
argument_list|(
name|gap
argument_list|)
expr_stmt|;
if|if
condition|(
name|rgap
operator|>=
operator|(
operator|-
literal|4092
operator|+
name|safety_margin
operator|)
operator|&&
name|rgap
operator|<=
operator|(
literal|4094
operator|-
name|safety_margin
operator|)
condition|)
name|distance_short_enough
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|distance_short_enough
condition|)
block|{
name|unsigned
name|char
name|code_msb
decl_stmt|;
name|unsigned
name|char
name|code_lsb
decl_stmt|;
if|if
condition|(
name|debug_relax
condition|)
name|printf
argument_list|(
literal|"shrinking jump/call instruction at address 0x%x"
literal|" in section %s\n\n"
argument_list|,
operator|(
name|int
operator|)
name|dot
argument_list|,
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Note that we've changed the relocs, section contents,                    etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Get the instruction code for relaxing.  */
name|code_lsb
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|code_msb
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Mask out the relocation bits.  */
name|code_msb
operator|&=
literal|0x94
expr_stmt|;
name|code_lsb
operator|&=
literal|0x0E
expr_stmt|;
if|if
condition|(
name|code_msb
operator|==
literal|0x94
operator|&&
name|code_lsb
operator|==
literal|0x0E
condition|)
block|{
comment|/* we are changing call -> rcall .  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x00
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xD0
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code_msb
operator|==
literal|0x94
operator|&&
name|code_lsb
operator|==
literal|0x0C
condition|)
block|{
comment|/* we are changeing jump -> rjmp.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x00
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0xC0
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_AVR_13_PCREL
argument_list|)
expr_stmt|;
comment|/* Check for the vector section. There we don't want to                    modify the ordering!  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".vectors"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".jumptables"
argument_list|)
condition|)
block|{
comment|/* Let's insert a nop.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x00
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x00
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Delete two bytes of data.  */
if|if
condition|(
operator|!
name|elf32_avr_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again.                        Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
default|default:
block|{
name|unsigned
name|char
name|code_msb
decl_stmt|;
name|unsigned
name|char
name|code_lsb
decl_stmt|;
name|bfd_vma
name|dot
decl_stmt|;
name|code_msb
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|)
expr_stmt|;
name|code_lsb
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|0
argument_list|)
expr_stmt|;
comment|/* Get the address of this instruction.  */
name|dot
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|irel
operator|->
name|r_offset
operator|)
expr_stmt|;
comment|/* Here we look for rcall/ret or call/ret sequences that could be                safely replaced by rjmp/ret or jmp/ret.  */
if|if
condition|(
operator|(
operator|(
name|code_msb
operator|&
literal|0xf0
operator|)
operator|==
literal|0xd0
operator|)
operator|&&
name|avr_replace_call_ret_sequences
condition|)
block|{
comment|/* This insn is a rcall.  */
name|unsigned
name|char
name|next_insn_msb
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|next_insn_lsb
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|+
literal|3
operator|<
name|sec
operator|->
name|size
condition|)
block|{
name|next_insn_msb
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|3
argument_list|)
expr_stmt|;
name|next_insn_lsb
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
literal|0x95
operator|==
name|next_insn_msb
operator|)
operator|&&
operator|(
literal|0x08
operator|==
name|next_insn_lsb
operator|)
condition|)
block|{
comment|/* The next insn is a ret. We now convert the rcall insn                        into a rjmp instruction.  */
name|code_msb
operator|&=
literal|0xef
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|code_msb
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_relax
condition|)
name|printf
argument_list|(
literal|"converted rcall/ret sequence at address 0x%x"
literal|" into rjmp/ret sequence. Section is %s\n\n"
argument_list|,
operator|(
name|int
operator|)
name|dot
argument_list|,
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
literal|0x94
operator|==
operator|(
name|code_msb
operator|&
literal|0xfe
operator|)
operator|)
operator|&&
operator|(
literal|0x0e
operator|==
operator|(
name|code_lsb
operator|&
literal|0x0e
operator|)
operator|)
operator|&&
name|avr_replace_call_ret_sequences
condition|)
block|{
comment|/* This insn is a call.  */
name|unsigned
name|char
name|next_insn_msb
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|next_insn_lsb
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|+
literal|5
operator|<
name|sec
operator|->
name|size
condition|)
block|{
name|next_insn_msb
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|5
argument_list|)
expr_stmt|;
name|next_insn_lsb
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
literal|0x95
operator|==
name|next_insn_msb
operator|)
operator|&&
operator|(
literal|0x08
operator|==
name|next_insn_lsb
operator|)
condition|)
block|{
comment|/* The next insn is a ret. We now convert the call insn                        into a jmp instruction.  */
name|code_lsb
operator|&=
literal|0xfd
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|code_lsb
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_relax
condition|)
name|printf
argument_list|(
literal|"converted call/ret sequence at address 0x%x"
literal|" into jmp/ret sequence. Section is %s\n\n"
argument_list|,
operator|(
name|int
operator|)
name|dot
argument_list|,
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
literal|0xc0
operator|==
operator|(
name|code_msb
operator|&
literal|0xf0
operator|)
operator|)
operator|||
operator|(
operator|(
literal|0x94
operator|==
operator|(
name|code_msb
operator|&
literal|0xfe
operator|)
operator|)
operator|&&
operator|(
literal|0x0c
operator|==
operator|(
name|code_lsb
operator|&
literal|0x0e
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* This insn is a rjmp or a jmp.  */
name|unsigned
name|char
name|next_insn_msb
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|next_insn_lsb
init|=
literal|0
decl_stmt|;
name|int
name|insn_size
decl_stmt|;
if|if
condition|(
literal|0xc0
operator|==
operator|(
name|code_msb
operator|&
literal|0xf0
operator|)
condition|)
name|insn_size
operator|=
literal|2
expr_stmt|;
comment|/* rjmp insn */
else|else
name|insn_size
operator|=
literal|4
expr_stmt|;
comment|/* jmp insn */
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|+
name|insn_size
operator|+
literal|1
operator|<
name|sec
operator|->
name|size
condition|)
block|{
name|next_insn_msb
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
name|insn_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|next_insn_lsb
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
name|insn_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
literal|0x95
operator|==
name|next_insn_msb
operator|)
operator|&&
operator|(
literal|0x08
operator|==
name|next_insn_lsb
operator|)
condition|)
block|{
comment|/* The next insn is a ret. We possibly could delete                        this ret. First we need to check for preceeding                        sbis/sbic/sbrs or cpse "skip" instructions.  */
name|int
name|there_is_preceeding_non_skip_insn
init|=
literal|1
decl_stmt|;
name|bfd_vma
name|address_of_ret
decl_stmt|;
name|address_of_ret
operator|=
name|dot
operator|+
name|insn_size
expr_stmt|;
if|if
condition|(
name|debug_relax
operator|&&
operator|(
name|insn_size
operator|==
literal|2
operator|)
condition|)
name|printf
argument_list|(
literal|"found rjmp / ret sequence at address 0x%x\n"
argument_list|,
operator|(
name|int
operator|)
name|dot
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_relax
operator|&&
operator|(
name|insn_size
operator|==
literal|4
operator|)
condition|)
name|printf
argument_list|(
literal|"found jmp / ret sequence at address 0x%x\n"
argument_list|,
operator|(
name|int
operator|)
name|dot
argument_list|)
expr_stmt|;
comment|/* We have to make sure that there is a preceeding insn.  */
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|>=
literal|2
condition|)
block|{
name|unsigned
name|char
name|preceeding_msb
decl_stmt|;
name|unsigned
name|char
name|preceeding_lsb
decl_stmt|;
name|preceeding_msb
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
name|preceeding_lsb
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* sbic.  */
if|if
condition|(
literal|0x99
operator|==
name|preceeding_msb
condition|)
name|there_is_preceeding_non_skip_insn
operator|=
literal|0
expr_stmt|;
comment|/* sbis.  */
if|if
condition|(
literal|0x9b
operator|==
name|preceeding_msb
condition|)
name|there_is_preceeding_non_skip_insn
operator|=
literal|0
expr_stmt|;
comment|/* sbrc */
if|if
condition|(
operator|(
literal|0xfc
operator|==
operator|(
name|preceeding_msb
operator|&
literal|0xfe
operator|)
operator|&&
operator|(
literal|0x00
operator|==
operator|(
name|preceeding_lsb
operator|&
literal|0x08
operator|)
operator|)
operator|)
condition|)
name|there_is_preceeding_non_skip_insn
operator|=
literal|0
expr_stmt|;
comment|/* sbrs */
if|if
condition|(
operator|(
literal|0xfe
operator|==
operator|(
name|preceeding_msb
operator|&
literal|0xfe
operator|)
operator|&&
operator|(
literal|0x00
operator|==
operator|(
name|preceeding_lsb
operator|&
literal|0x08
operator|)
operator|)
operator|)
condition|)
name|there_is_preceeding_non_skip_insn
operator|=
literal|0
expr_stmt|;
comment|/* cpse */
if|if
condition|(
literal|0x10
operator|==
operator|(
name|preceeding_msb
operator|&
literal|0xfc
operator|)
condition|)
name|there_is_preceeding_non_skip_insn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|there_is_preceeding_non_skip_insn
operator|==
literal|0
condition|)
if|if
condition|(
name|debug_relax
condition|)
name|printf
argument_list|(
literal|"preceeding skip insn prevents deletion of"
literal|" ret insn at addr 0x%x in section %s\n"
argument_list|,
operator|(
name|int
operator|)
name|dot
operator|+
literal|2
argument_list|,
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* There is no previous instruction.  */
name|there_is_preceeding_non_skip_insn
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|there_is_preceeding_non_skip_insn
condition|)
block|{
comment|/* We now only have to make sure that there is no                            local label defined at the address of the ret                            instruction and that there is no local relocation                            in this section pointing to the ret.  */
name|int
name|deleting_ret_is_safe
init|=
literal|1
decl_stmt|;
name|unsigned
name|int
name|section_offset_of_ret_insn
init|=
name|irel
operator|->
name|r_offset
operator|+
name|insn_size
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|,
modifier|*
name|isymend
decl_stmt|;
name|unsigned
name|int
name|sec_shndx
decl_stmt|;
name|sec_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
comment|/* Check for local symbols.  */
name|isym
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
name|isymend
operator|=
name|isym
operator|+
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
control|)
block|{
if|if
condition|(
name|isym
operator|->
name|st_value
operator|==
name|section_offset_of_ret_insn
operator|&&
name|isym
operator|->
name|st_shndx
operator|==
name|sec_shndx
condition|)
block|{
name|deleting_ret_is_safe
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug_relax
condition|)
name|printf
argument_list|(
literal|"local label prevents deletion of ret "
literal|"insn at address 0x%x\n"
argument_list|,
operator|(
name|int
operator|)
name|dot
operator|+
name|insn_size
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now check for global symbols.  */
block|{
name|int
name|symcount
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|end_hashes
decl_stmt|;
name|symcount
operator|=
operator|(
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|end_hashes
operator|=
name|sym_hashes
operator|+
name|symcount
expr_stmt|;
for|for
control|(
init|;
name|sym_hashes
operator|<
name|end_hashes
condition|;
name|sym_hashes
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|sym_hash
init|=
operator|*
name|sym_hashes
decl_stmt|;
if|if
condition|(
operator|(
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|sec
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|==
name|section_offset_of_ret_insn
condition|)
block|{
name|deleting_ret_is_safe
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug_relax
condition|)
name|printf
argument_list|(
literal|"global label prevents deletion of "
literal|"ret insn at address 0x%x\n"
argument_list|,
operator|(
name|int
operator|)
name|dot
operator|+
name|insn_size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Now we check for relocations pointing to ret.  */
block|{
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|relend
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
init|;
name|irel
operator|<
name|relend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|reloc_target
init|=
literal|0
decl_stmt|;
name|bfd_vma
name|symval
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
comment|/* Read this BFD's local symbols if we haven't                                   done so already.  */
if|if
condition|(
name|isymbuf
operator|==
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
break|break;
block|}
comment|/* Get the value of the symbol referred to                                   by the reloc.  */
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* A local symbol.  */
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|isym
operator|=
name|isymbuf
operator|+
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|sym_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|symval
operator|=
name|isym
operator|->
name|st_value
expr_stmt|;
comment|/* If the reloc is absolute, it will not                                       have a symbol or section associated                                       with it.  */
if|if
condition|(
name|sym_sec
condition|)
block|{
name|symval
operator|+=
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sym_sec
operator|->
name|output_offset
expr_stmt|;
name|reloc_target
operator|=
name|symval
operator|+
name|irel
operator|->
name|r_addend
expr_stmt|;
block|}
else|else
block|{
name|reloc_target
operator|=
name|symval
operator|+
name|irel
operator|->
name|r_addend
expr_stmt|;
comment|/* Reference symbol is absolute.  */
block|}
block|}
comment|/* else ... reference symbol is extern.  */
if|if
condition|(
name|address_of_ret
operator|==
name|reloc_target
condition|)
block|{
name|deleting_ret_is_safe
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug_relax
condition|)
name|printf
argument_list|(
literal|"ret from "
literal|"rjmp/jmp ret sequence at address"
literal|" 0x%x could not be deleted. ret"
literal|" is target of a relocation.\n"
argument_list|,
operator|(
name|int
operator|)
name|address_of_ret
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|deleting_ret_is_safe
condition|)
block|{
if|if
condition|(
name|debug_relax
condition|)
name|printf
argument_list|(
literal|"unreachable ret instruction "
literal|"at address 0x%x deleted.\n"
argument_list|,
operator|(
name|int
operator|)
name|dot
operator|+
name|insn_size
argument_list|)
expr_stmt|;
comment|/* Delete two bytes of data.  */
if|if
condition|(
operator|!
name|elf32_avr_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
name|insn_size
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax                                 again. Note that this is not required, and it                                 may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the section contents for elf_link_input_bfd.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
block|}
block|}
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* This is a version of bfd_generic_get_relocated_section_contents    which uses elf32_avr_relocate_section.     For avr it's essentially a cut and paste taken from the H8300 port.    The author of the relaxation support patch for avr had absolutely no    clue what is happening here but found out that this part of the code    seems to be important.  */
end_comment

begin_function
specifier|static
name|bfd_byte
modifier|*
name|elf32_avr_get_relocated_section_contents
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|struct
name|bfd_link_order
modifier|*
name|link_order
parameter_list|,
name|bfd_byte
modifier|*
name|data
parameter_list|,
name|bfd_boolean
name|relocatable
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|input_section
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
init|=
name|input_section
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sections
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
comment|/* We only need to handle the case of relaxing, or of having a      particular set of section contents, specially.  */
if|if
condition|(
name|relocatable
operator|||
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|==
name|NULL
condition|)
return|return
name|bfd_generic_get_relocated_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|link_info
argument_list|,
name|link_order
argument_list|,
name|data
argument_list|,
name|relocatable
argument_list|,
name|symbols
argument_list|)
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
argument_list|,
operator|(
name|size_t
operator|)
name|input_section
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|input_section
operator|->
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|asection
modifier|*
modifier|*
name|secpp
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|,
modifier|*
name|isymend
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|internal_relocs
operator|=
operator|(
name|_bfd_elf_link_read_relocs
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
name|amt
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|sections
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sections
operator|==
name|NULL
operator|&&
name|amt
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|isymend
operator|=
name|isymbuf
operator|+
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
name|isym
operator|=
name|isymbuf
operator|,
name|secpp
operator|=
name|sections
init|;
name|isym
operator|<
name|isymend
condition|;
operator|++
name|isym
operator|,
operator|++
name|secpp
control|)
block|{
name|asection
modifier|*
name|isec
decl_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|isec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|isec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|isec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
name|isec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|input_bfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
operator|*
name|secpp
operator|=
name|isec
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|elf32_avr_relocate_section
argument_list|(
name|output_bfd
argument_list|,
name|link_info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|data
argument_list|,
name|internal_relocs
argument_list|,
name|isymbuf
argument_list|,
name|sections
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
return|return
name|data
return|;
name|error_return
label|:
if|if
condition|(
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Determines the hash entry name for a particular reloc. It consists of    the identifier of the symbol section and the added reloc addend and    symbol offset relative to the section the symbol is attached to.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|avr_stub_name
parameter_list|(
specifier|const
name|asection
modifier|*
name|symbol_section
parameter_list|,
specifier|const
name|bfd_vma
name|symbol_offset
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rela
parameter_list|)
block|{
name|char
modifier|*
name|stub_name
decl_stmt|;
name|bfd_size_type
name|len
decl_stmt|;
name|len
operator|=
literal|8
operator|+
literal|1
operator|+
literal|8
operator|+
literal|1
operator|+
literal|1
expr_stmt|;
name|stub_name
operator|=
name|bfd_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|stub_name
argument_list|,
literal|"%08x+%08x"
argument_list|,
name|symbol_section
operator|->
name|id
operator|&
literal|0xffffffff
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
name|rela
operator|->
name|r_addend
operator|&
literal|0xffffffff
operator|)
operator|+
name|symbol_offset
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|stub_name
return|;
block|}
end_function

begin_comment
comment|/* Add a new stub entry to the stub hash.  Not all fields of the new    stub entry are initialised.  */
end_comment

begin_function
specifier|static
name|struct
name|elf32_avr_stub_hash_entry
modifier|*
name|avr_add_stub
parameter_list|(
specifier|const
name|char
modifier|*
name|stub_name
parameter_list|,
name|struct
name|elf32_avr_link_hash_table
modifier|*
name|htab
parameter_list|)
block|{
name|struct
name|elf32_avr_stub_hash_entry
modifier|*
name|hsh
decl_stmt|;
comment|/* Enter this entry into the linker stub hash table.  */
name|hsh
operator|=
name|avr_stub_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|bstab
argument_list|,
name|stub_name
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|hsh
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%B: cannot create stub entry %s"
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|stub_name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|hsh
operator|->
name|stub_offset
operator|=
literal|0
expr_stmt|;
return|return
name|hsh
return|;
block|}
end_function

begin_comment
comment|/* We assume that there is already space allocated for the stub section    contents and that before building the stubs the section size is    initialized to 0.  We assume that within the stub hash table entry,    the absolute position of the jmp target has been written in the    target_value field.  We write here the offset of the generated jmp insn    relative to the trampoline section start to the stub_offset entry in    the stub hash table entry.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|avr_build_one_stub
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|bh
parameter_list|,
name|void
modifier|*
name|in_arg
parameter_list|)
block|{
name|struct
name|elf32_avr_stub_hash_entry
modifier|*
name|hsh
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf32_avr_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd
modifier|*
name|stub_bfd
decl_stmt|;
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|bfd_vma
name|target
decl_stmt|;
name|bfd_vma
name|starget
decl_stmt|;
comment|/* Basic opcode */
name|bfd_vma
name|jmp_insn
init|=
literal|0x0000940c
decl_stmt|;
comment|/* Massage our args to the form they really have.  */
name|hsh
operator|=
name|avr_stub_hash_entry
argument_list|(
name|bh
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hsh
operator|->
name|is_actually_needed
condition|)
return|return
name|TRUE
return|;
name|info
operator|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|in_arg
expr_stmt|;
name|htab
operator|=
name|avr_link_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|target
operator|=
name|hsh
operator|->
name|target_value
expr_stmt|;
comment|/* Make a note of the offset within the stubs for this entry.  */
name|hsh
operator|->
name|stub_offset
operator|=
name|htab
operator|->
name|stub_sec
operator|->
name|size
expr_stmt|;
name|loc
operator|=
name|htab
operator|->
name|stub_sec
operator|->
name|contents
operator|+
name|hsh
operator|->
name|stub_offset
expr_stmt|;
name|stub_bfd
operator|=
name|htab
operator|->
name|stub_sec
operator|->
name|owner
expr_stmt|;
if|if
condition|(
name|debug_stubs
condition|)
name|printf
argument_list|(
literal|"Building one Stub. Address: 0x%x, Offset: 0x%x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|target
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|hsh
operator|->
name|stub_offset
argument_list|)
expr_stmt|;
comment|/* We now have to add the information on the jump target to the bare      opcode bits already set in jmp_insn.  */
comment|/* Check for the alignment of the address.  */
if|if
condition|(
name|target
operator|&
literal|1
condition|)
return|return
name|FALSE
return|;
name|starget
operator|=
name|target
operator|>>
literal|1
expr_stmt|;
name|jmp_insn
operator||=
operator|(
operator|(
name|starget
operator|&
literal|0x10000
operator|)
operator||
operator|(
operator|(
name|starget
operator|<<
literal|3
operator|)
operator|&
literal|0x1f00000
operator|)
operator|)
operator|>>
literal|16
expr_stmt|;
name|bfd_put_16
argument_list|(
name|stub_bfd
argument_list|,
name|jmp_insn
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|stub_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|starget
operator|&
literal|0xffff
argument_list|,
name|loc
operator|+
literal|2
argument_list|)
expr_stmt|;
name|htab
operator|->
name|stub_sec
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
comment|/* Now add the entries in the address mapping table if there is still      space left.  */
block|{
name|unsigned
name|int
name|nr
decl_stmt|;
name|nr
operator|=
name|htab
operator|->
name|amt_entry_cnt
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nr
operator|<=
name|htab
operator|->
name|amt_max_entry_cnt
condition|)
block|{
name|htab
operator|->
name|amt_entry_cnt
operator|=
name|nr
expr_stmt|;
name|htab
operator|->
name|amt_stub_offsets
index|[
name|nr
operator|-
literal|1
index|]
operator|=
name|hsh
operator|->
name|stub_offset
expr_stmt|;
name|htab
operator|->
name|amt_destination_addr
index|[
name|nr
operator|-
literal|1
index|]
operator|=
name|target
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|avr_mark_stub_not_to_be_necessary
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|bh
parameter_list|,
name|void
modifier|*
name|in_arg
parameter_list|)
block|{
name|struct
name|elf32_avr_stub_hash_entry
modifier|*
name|hsh
decl_stmt|;
name|struct
name|elf32_avr_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|in_arg
expr_stmt|;
name|hsh
operator|=
name|avr_stub_hash_entry
argument_list|(
name|bh
argument_list|)
expr_stmt|;
name|hsh
operator|->
name|is_actually_needed
operator|=
name|FALSE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|avr_size_one_stub
parameter_list|(
name|struct
name|bfd_hash_entry
modifier|*
name|bh
parameter_list|,
name|void
modifier|*
name|in_arg
parameter_list|)
block|{
name|struct
name|elf32_avr_stub_hash_entry
modifier|*
name|hsh
decl_stmt|;
name|struct
name|elf32_avr_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* Massage our args to the form they really have.  */
name|hsh
operator|=
name|avr_stub_hash_entry
argument_list|(
name|bh
argument_list|)
expr_stmt|;
name|htab
operator|=
name|in_arg
expr_stmt|;
if|if
condition|(
name|hsh
operator|->
name|is_actually_needed
condition|)
name|size
operator|=
literal|4
expr_stmt|;
else|else
name|size
operator|=
literal|0
expr_stmt|;
name|htab
operator|->
name|stub_sec
operator|->
name|size
operator|+=
name|size
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
name|elf32_avr_setup_params
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|avr_stub_bfd
parameter_list|,
name|asection
modifier|*
name|avr_stub_section
parameter_list|,
name|bfd_boolean
name|no_stubs
parameter_list|,
name|bfd_boolean
name|deb_stubs
parameter_list|,
name|bfd_boolean
name|deb_relax
parameter_list|,
name|bfd_vma
name|pc_wrap_around
parameter_list|,
name|bfd_boolean
name|call_ret_replacement
parameter_list|)
block|{
name|struct
name|elf32_avr_link_hash_table
modifier|*
name|htab
init|=
name|avr_link_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|htab
operator|==
name|NULL
condition|)
return|return;
name|htab
operator|->
name|stub_sec
operator|=
name|avr_stub_section
expr_stmt|;
name|htab
operator|->
name|stub_bfd
operator|=
name|avr_stub_bfd
expr_stmt|;
name|htab
operator|->
name|no_stubs
operator|=
name|no_stubs
expr_stmt|;
name|debug_relax
operator|=
name|deb_relax
expr_stmt|;
name|debug_stubs
operator|=
name|deb_stubs
expr_stmt|;
name|avr_pc_wrap_around
operator|=
name|pc_wrap_around
expr_stmt|;
name|avr_replace_call_ret_sequences
operator|=
name|call_ret_replacement
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up various things so that we can make a list of input sections    for each output section included in the link.  Returns -1 on error,    0 when no stubs will be needed, and 1 on success.  It also sets    information on the stubs bfd and the stub section in the info    struct.  */
end_comment

begin_function
name|int
name|elf32_avr_setup_section_lists
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|unsigned
name|int
name|bfd_count
decl_stmt|;
name|int
name|top_id
decl_stmt|,
name|top_index
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asection
modifier|*
modifier|*
name|input_list
decl_stmt|,
modifier|*
modifier|*
name|list
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|struct
name|elf32_avr_link_hash_table
modifier|*
name|htab
init|=
name|avr_link_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|htab
operator|==
name|NULL
operator|||
name|htab
operator|->
name|no_stubs
condition|)
return|return
literal|0
return|;
comment|/* Count the number of input BFDs and find the top input section id.  */
for|for
control|(
name|input_bfd
operator|=
name|info
operator|->
name|input_bfds
operator|,
name|bfd_count
operator|=
literal|0
operator|,
name|top_id
operator|=
literal|0
init|;
name|input_bfd
operator|!=
name|NULL
condition|;
name|input_bfd
operator|=
name|input_bfd
operator|->
name|link_next
control|)
block|{
name|bfd_count
operator|+=
literal|1
expr_stmt|;
for|for
control|(
name|section
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
if|if
condition|(
name|top_id
operator|<
name|section
operator|->
name|id
condition|)
name|top_id
operator|=
name|section
operator|->
name|id
expr_stmt|;
block|}
name|htab
operator|->
name|bfd_count
operator|=
name|bfd_count
expr_stmt|;
comment|/* We can't use output_bfd->section_count here to find the top output      section index as some sections may have been removed, and      strip_excluded_output_sections doesn't renumber the indices.  */
for|for
control|(
name|section
operator|=
name|output_bfd
operator|->
name|sections
operator|,
name|top_index
operator|=
literal|0
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
if|if
condition|(
name|top_index
operator|<
name|section
operator|->
name|index
condition|)
name|top_index
operator|=
name|section
operator|->
name|index
expr_stmt|;
name|htab
operator|->
name|top_index
operator|=
name|top_index
expr_stmt|;
name|amt
operator|=
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
operator|*
operator|(
name|top_index
operator|+
literal|1
operator|)
expr_stmt|;
name|input_list
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
name|htab
operator|->
name|input_list
operator|=
name|input_list
expr_stmt|;
if|if
condition|(
name|input_list
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* For sections we aren't interested in, mark their entries with a      value we can check later.  */
name|list
operator|=
name|input_list
operator|+
name|top_index
expr_stmt|;
do|do
operator|*
name|list
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
do|while
condition|(
name|list
operator|--
operator|!=
name|input_list
condition|)
do|;
for|for
control|(
name|section
operator|=
name|output_bfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
name|input_list
index|[
name|section
operator|->
name|index
index|]
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Read in all local syms for all input bfds, and create hash entries    for export stubs if we are building a multi-subspace shared lib.    Returns -1 on error, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|get_local_syms
parameter_list|(
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|unsigned
name|int
name|bfd_indx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|,
modifier|*
modifier|*
name|all_local_syms
decl_stmt|;
name|struct
name|elf32_avr_link_hash_table
modifier|*
name|htab
init|=
name|avr_link_hash_table
argument_list|(
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|htab
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* We want to read in symbol extension records only once.  To do this      we need to read in the local symbols in parallel and save them for      later use; so hold pointers to the local symbols in an array.  */
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
name|Elf_Internal_Sym
operator|*
argument_list|)
operator|*
name|htab
operator|->
name|bfd_count
decl_stmt|;
name|all_local_syms
operator|=
name|bfd_zmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
name|htab
operator|->
name|all_local_syms
operator|=
name|all_local_syms
expr_stmt|;
if|if
condition|(
name|all_local_syms
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Walk over all the input BFDs, swapping in local symbols.      If we are creating a shared library, create hash entries for the      export stubs.  */
for|for
control|(
name|bfd_indx
operator|=
literal|0
init|;
name|input_bfd
operator|!=
name|NULL
condition|;
name|input_bfd
operator|=
name|input_bfd
operator|->
name|link_next
operator|,
name|bfd_indx
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
comment|/* We'll need the symbol table in a second.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|symtab_hdr
operator|->
name|sh_info
operator|==
literal|0
condition|)
continue|continue;
comment|/* We need an array of the local symbols attached to the input bfd.  */
name|local_syms
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|local_syms
operator|==
name|NULL
condition|)
block|{
name|local_syms
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Cache them for elf_link_input_bfd.  */
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|local_syms
expr_stmt|;
block|}
if|if
condition|(
name|local_syms
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|all_local_syms
index|[
name|bfd_indx
index|]
operator|=
name|local_syms
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ADD_DUMMY_STUBS_FOR_DEBUGGING
value|0
end_define

begin_function
name|bfd_boolean
name|elf32_avr_size_stubs
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_boolean
name|is_prealloc_run
parameter_list|)
block|{
name|struct
name|elf32_avr_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|int
name|stub_changed
init|=
literal|0
decl_stmt|;
name|htab
operator|=
name|avr_link_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* At this point we initialize htab->vector_base      To the start of the text output section.  */
name|htab
operator|->
name|vector_base
operator|=
name|htab
operator|->
name|stub_sec
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|get_local_syms
argument_list|(
name|info
operator|->
name|input_bfds
argument_list|,
name|info
argument_list|)
condition|)
block|{
if|if
condition|(
name|htab
operator|->
name|all_local_syms
condition|)
goto|goto
name|error_ret_free_local
goto|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|ADD_DUMMY_STUBS_FOR_DEBUGGING
condition|)
block|{
name|struct
name|elf32_avr_stub_hash_entry
modifier|*
name|test
decl_stmt|;
name|test
operator|=
name|avr_add_stub
argument_list|(
literal|"Hugo"
argument_list|,
name|htab
argument_list|)
expr_stmt|;
name|test
operator|->
name|target_value
operator|=
literal|0x123456
expr_stmt|;
name|test
operator|->
name|stub_offset
operator|=
literal|13
expr_stmt|;
name|test
operator|=
name|avr_add_stub
argument_list|(
literal|"Hugo2"
argument_list|,
name|htab
argument_list|)
expr_stmt|;
name|test
operator|->
name|target_value
operator|=
literal|0x84210
expr_stmt|;
name|test
operator|->
name|stub_offset
operator|=
literal|14
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|unsigned
name|int
name|bfd_indx
decl_stmt|;
comment|/* We will have to re-generate the stub hash table each time anything          in memory has changed.  */
name|bfd_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|bstab
argument_list|,
name|avr_mark_stub_not_to_be_necessary
argument_list|,
name|htab
argument_list|)
expr_stmt|;
for|for
control|(
name|input_bfd
operator|=
name|info
operator|->
name|input_bfds
operator|,
name|bfd_indx
operator|=
literal|0
init|;
name|input_bfd
operator|!=
name|NULL
condition|;
name|input_bfd
operator|=
name|input_bfd
operator|->
name|link_next
operator|,
name|bfd_indx
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
comment|/* We'll need the symbol table in a second.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|symtab_hdr
operator|->
name|sh_info
operator|==
literal|0
condition|)
continue|continue;
name|local_syms
operator|=
name|htab
operator|->
name|all_local_syms
index|[
name|bfd_indx
index|]
expr_stmt|;
comment|/* Walk over each section attached to the input bfd.  */
for|for
control|(
name|section
operator|=
name|input_bfd
operator|->
name|sections
init|;
name|section
operator|!=
name|NULL
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|,
modifier|*
name|irelaend
decl_stmt|,
modifier|*
name|irela
decl_stmt|;
comment|/* If there aren't any relocs, then there's nothing more                  to do.  */
if|if
condition|(
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|section
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
comment|/* If this section is a link-once section that will be                  discarded, then don't create any stubs.  */
if|if
condition|(
name|section
operator|->
name|output_section
operator|==
name|NULL
operator|||
name|section
operator|->
name|output_section
operator|->
name|owner
operator|!=
name|output_bfd
condition|)
continue|continue;
comment|/* Get the relocs.  */
name|internal_relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|input_bfd
argument_list|,
name|section
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_ret_free_local
goto|;
comment|/* Now examine each relocation.  */
name|irela
operator|=
name|internal_relocs
expr_stmt|;
name|irelaend
operator|=
name|irela
operator|+
name|section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|irela
operator|<
name|irelaend
condition|;
name|irela
operator|++
control|)
block|{
name|unsigned
name|int
name|r_type
decl_stmt|,
name|r_indx
decl_stmt|;
name|struct
name|elf32_avr_stub_hash_entry
modifier|*
name|hsh
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|bfd_vma
name|sym_value
decl_stmt|;
name|bfd_vma
name|destination
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|hh
decl_stmt|;
name|char
modifier|*
name|stub_name
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|irela
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_indx
operator|=
name|ELF32_R_SYM
argument_list|(
name|irela
operator|->
name|r_info
argument_list|)
expr_stmt|;
comment|/* Only look for 16 bit GS relocs. No other reloc will need a                      stub.  */
if|if
condition|(
operator|!
operator|(
operator|(
name|r_type
operator|==
name|R_AVR_16_PM
operator|)
operator|||
operator|(
name|r_type
operator|==
name|R_AVR_LO8_LDI_GS
operator|)
operator|||
operator|(
name|r_type
operator|==
name|R_AVR_HI8_LDI_GS
operator|)
operator|)
condition|)
continue|continue;
comment|/* Now determine the call target, its name, value,                      section.  */
name|sym_sec
operator|=
name|NULL
expr_stmt|;
name|sym_value
operator|=
literal|0
expr_stmt|;
name|destination
operator|=
literal|0
expr_stmt|;
name|hh
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_indx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* It's a local symbol.  */
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|sym
operator|=
name|local_syms
operator|+
name|r_indx
expr_stmt|;
name|hdr
operator|=
name|elf_elfsections
argument_list|(
name|input_bfd
argument_list|)
index|[
name|sym
operator|->
name|st_shndx
index|]
expr_stmt|;
name|sym_sec
operator|=
name|hdr
operator|->
name|bfd_section
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_SECTION
condition|)
name|sym_value
operator|=
name|sym
operator|->
name|st_value
expr_stmt|;
name|destination
operator|=
operator|(
name|sym_value
operator|+
name|irela
operator|->
name|r_addend
operator|+
name|sym_sec
operator|->
name|output_offset
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It's an external symbol.  */
name|int
name|e_indx
decl_stmt|;
name|e_indx
operator|=
name|r_indx
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|hh
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|e_indx
index|]
expr_stmt|;
while|while
condition|(
name|hh
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|hh
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|hh
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
operator|(
name|hh
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
operator|)
expr_stmt|;
if|if
condition|(
name|hh
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|hh
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sym_sec
operator|=
name|hh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|sym_value
operator|=
name|hh
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|sym_sec
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|destination
operator|=
operator|(
name|sym_value
operator|+
name|irela
operator|->
name|r_addend
operator|+
name|sym_sec
operator|->
name|output_offset
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hh
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|hh
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|info
operator|->
name|unresolved_syms_in_objects
operator|==
name|RM_IGNORE
operator|&&
operator|(
name|ELF_ST_VISIBILITY
argument_list|(
name|hh
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
operator|)
operator|)
condition|)
continue|continue;
block|}
else|else
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
name|error_ret_free_internal
label|:
if|if
condition|(
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|relocs
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
goto|goto
name|error_ret_free_local
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|avr_stub_is_required_for_16_bit_reloc
argument_list|(
name|destination
operator|-
name|htab
operator|->
name|vector_base
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|is_prealloc_run
condition|)
comment|/* We are having a reloc that does't need a stub.  */
continue|continue;
comment|/* We don't right now know if a stub will be needed. 			 Let's rather be on the safe side.  */
block|}
comment|/* Get the name of this stub.  */
name|stub_name
operator|=
name|avr_stub_name
argument_list|(
name|sym_sec
argument_list|,
name|sym_value
argument_list|,
name|irela
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stub_name
condition|)
goto|goto
name|error_ret_free_internal
goto|;
name|hsh
operator|=
name|avr_stub_hash_lookup
argument_list|(
operator|&
name|htab
operator|->
name|bstab
argument_list|,
name|stub_name
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|hsh
operator|!=
name|NULL
condition|)
block|{
comment|/* The proper stub has already been created.  Mark it                          to be used and write the possibly changed destination                          value.  */
name|hsh
operator|->
name|is_actually_needed
operator|=
name|TRUE
expr_stmt|;
name|hsh
operator|->
name|target_value
operator|=
name|destination
expr_stmt|;
name|free
argument_list|(
name|stub_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|hsh
operator|=
name|avr_add_stub
argument_list|(
name|stub_name
argument_list|,
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|hsh
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|stub_name
argument_list|)
expr_stmt|;
goto|goto
name|error_ret_free_internal
goto|;
block|}
name|hsh
operator|->
name|is_actually_needed
operator|=
name|TRUE
expr_stmt|;
name|hsh
operator|->
name|target_value
operator|=
name|destination
expr_stmt|;
if|if
condition|(
name|debug_stubs
condition|)
name|printf
argument_list|(
literal|"Adding stub with destination 0x%x to the"
literal|" hash table.\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|destination
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_stubs
condition|)
name|printf
argument_list|(
literal|"(Pre-Alloc run: %i)\n"
argument_list|,
name|is_prealloc_run
argument_list|)
expr_stmt|;
name|stub_changed
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* We're done with the internal relocs, free them.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|relocs
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Re-Calculate the number of needed stubs.  */
name|htab
operator|->
name|stub_sec
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|bfd_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|bstab
argument_list|,
name|avr_size_one_stub
argument_list|,
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stub_changed
condition|)
break|break;
name|stub_changed
operator|=
name|FALSE
expr_stmt|;
block|}
name|free
argument_list|(
name|htab
operator|->
name|all_local_syms
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_ret_free_local
label|:
name|free
argument_list|(
name|htab
operator|->
name|all_local_syms
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Build all the stubs associated with the current output file.  The    stubs are kept in a hash table attached to the main linker hash    table.  We also set up the .plt entries for statically linked PIC    functions here.  This function is called via hppaelf_finish in the    linker.  */
end_comment

begin_function
name|bfd_boolean
name|elf32_avr_build_stubs
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|asection
modifier|*
name|stub_sec
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
name|struct
name|elf32_avr_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd_size_type
name|total_size
init|=
literal|0
decl_stmt|;
name|htab
operator|=
name|avr_link_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* In case that there were several stub sections:  */
for|for
control|(
name|stub_sec
operator|=
name|htab
operator|->
name|stub_bfd
operator|->
name|sections
init|;
name|stub_sec
operator|!=
name|NULL
condition|;
name|stub_sec
operator|=
name|stub_sec
operator|->
name|next
control|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
comment|/* Allocate memory to hold the linker stubs.  */
name|size
operator|=
name|stub_sec
operator|->
name|size
expr_stmt|;
name|total_size
operator|+=
name|size
expr_stmt|;
name|stub_sec
operator|->
name|contents
operator|=
name|bfd_zalloc
argument_list|(
name|htab
operator|->
name|stub_bfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|stub_sec
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|size
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
name|stub_sec
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Allocate memory for the adress mapping table.  */
name|htab
operator|->
name|amt_entry_cnt
operator|=
literal|0
expr_stmt|;
name|htab
operator|->
name|amt_max_entry_cnt
operator|=
name|total_size
operator|/
literal|4
expr_stmt|;
name|htab
operator|->
name|amt_stub_offsets
operator|=
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
operator|*
name|htab
operator|->
name|amt_max_entry_cnt
argument_list|)
expr_stmt|;
name|htab
operator|->
name|amt_destination_addr
operator|=
name|bfd_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
operator|*
name|htab
operator|->
name|amt_max_entry_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_stubs
condition|)
name|printf
argument_list|(
literal|"Allocating %i entries in the AMT\n"
argument_list|,
name|htab
operator|->
name|amt_max_entry_cnt
argument_list|)
expr_stmt|;
comment|/* Build the stubs as directed by the stub hash table.  */
name|table
operator|=
operator|&
name|htab
operator|->
name|bstab
expr_stmt|;
name|bfd_hash_traverse
argument_list|(
name|table
argument_list|,
name|avr_build_one_stub
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_stubs
condition|)
name|printf
argument_list|(
literal|"Final Stub section Size: %i\n"
argument_list|,
operator|(
name|int
operator|)
name|htab
operator|->
name|stub_sec
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_avr
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_AVR
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT1
value|EM_AVR_OLD
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|1
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_avr_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-avr"
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
value|elf32_avr_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_free
value|elf32_avr_link_hash_table_free
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|avr_info_to_howto_rela
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|NULL
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|elf32_avr_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|elf32_avr_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_rela_normal
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
define|\
value|bfd_elf_avr_final_write_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|elf32_avr_object_p
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_relax_section
value|elf32_avr_relax_section
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_get_relocated_section_contents
define|\
value|elf32_avr_get_relocated_section_contents
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

