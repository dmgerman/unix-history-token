begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* M16C/M32C specific support for 32-bit ELF.    Copyright (C) 2005, 2006    Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/m32c.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_function_decl
specifier|static
name|reloc_howto_type
modifier|*
name|m32c_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd_reloc_code_real_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|m32c_info_to_howto_rela
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|m32c_elf_relocate_section
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|Elf_Internal_Sym
modifier|*
parameter_list|,
name|asection
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|m32c_elf_gc_sweep_hook
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|asection
modifier|*
name|m32c_elf_gc_mark_hook
parameter_list|(
name|asection
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
parameter_list|,
name|Elf_Internal_Sym
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|m32c_elf_check_relocs
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|m32c_elf_relax_delete_bytes
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
specifier|static
name|char
modifier|*
name|m32c_get_reloc
parameter_list|(
name|long
name|reloc
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|bfd_boolean
name|m32c_elf_relax_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|bfd_boolean
modifier|*
name|again
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|m32c_elf_howto_table
index|[]
init|=
block|{
comment|/* This reloc does nothing.  */
name|HOWTO
argument_list|(
name|R_M32C_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32C_NONE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_M32C_16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32C_16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_M32C_24
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|24
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32C_24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_M32C_32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32C_32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_M32C_8_PCREL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32C_8_PCREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_M32C_16_PCREL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32C_16_PCREL"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_M32C_8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32C_8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_M32C_LO16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32C_LO16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_M32C_HI8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32C_HI8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_M32C_HI16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32C_HI16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_M32C_RL_JUMP
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32C_RL_JUMP"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_M32C_RL_1ADDR
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32C_RL_1ADDR"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_M32C_RL_2ADDR
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_M32C_RL_2ADDR"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Map BFD reloc types to M32C ELF reloc types.  */
end_comment

begin_struct
struct|struct
name|m32c_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_val
decl_stmt|;
name|unsigned
name|int
name|m32c_reloc_val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|m32c_reloc_map
name|m32c_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_M32C_NONE
block|}
block|,
block|{
name|BFD_RELOC_16
block|,
name|R_M32C_16
block|}
block|,
block|{
name|BFD_RELOC_24
block|,
name|R_M32C_24
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_M32C_32
block|}
block|,
block|{
name|BFD_RELOC_8_PCREL
block|,
name|R_M32C_8_PCREL
block|}
block|,
block|{
name|BFD_RELOC_16_PCREL
block|,
name|R_M32C_16_PCREL
block|}
block|,
block|{
name|BFD_RELOC_8
block|,
name|R_M32C_8
block|}
block|,
block|{
name|BFD_RELOC_LO16
block|,
name|R_M32C_LO16
block|}
block|,
block|{
name|BFD_RELOC_HI16
block|,
name|R_M32C_HI16
block|}
block|,
block|{
name|BFD_RELOC_M32C_HI8
block|,
name|R_M32C_HI8
block|}
block|,
block|{
name|BFD_RELOC_M32C_RL_JUMP
block|,
name|R_M32C_RL_JUMP
block|}
block|,
block|{
name|BFD_RELOC_M32C_RL_1ADDR
block|,
name|R_M32C_RL_1ADDR
block|}
block|,
block|{
name|BFD_RELOC_M32C_RL_2ADDR
block|,
name|R_M32C_RL_2ADDR
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|m32c_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ARRAY_SIZE
argument_list|(
name|m32c_reloc_map
argument_list|)
init|;
operator|--
name|i
condition|;
control|)
if|if
condition|(
name|m32c_reloc_map
index|[
name|i
index|]
operator|.
name|bfd_reloc_val
operator|==
name|code
condition|)
return|return
operator|&
name|m32c_elf_howto_table
index|[
name|m32c_reloc_map
index|[
name|i
index|]
operator|.
name|m32c_reloc_val
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set the howto pointer for an M32C ELF reloc.  */
end_comment

begin_function
specifier|static
name|void
name|m32c_info_to_howto_rela
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|cache_ptr
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|dst
parameter_list|)
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|r_type
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_M32C_max
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|m32c_elf_howto_table
index|[
name|r_type
index|]
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Relocate an M32C ELF section.    There is some attempt to make this function usable for many architectures,    both USE_REL and USE_RELA ['twould be nice if such a critter existed],    if only to serve as a learning tool.     The RELOCATE_SECTION function is called by the new ELF backend linker    to handle the relocations for a section.     The relocs are always passed as Rela structures; if the section    actually uses Rel structures, the r_addend field will always be    zero.     This function is responsible for adjusting the section contents as    necessary, and (if using Rela relocs and generating a relocatable    output file) adjusting the reloc addend as necessary.     This function does not have to worry about setting the reloc    address or the reloc symbol index.     LOCAL_SYMS is a pointer to the swapped in local symbols.     LOCAL_SECTIONS is an array giving the section in the input file    corresponding to the st_shndx field of each local symbol.     The global hash table entry for the global symbols can be found    via elf_sym_hashes (input_bfd).     When generating relocatable output, this function must handle    STB_LOCAL/STT_SECTION symbols specially.  The output symbol is    going to be the section symbol corresponding to the output    section, which means that the addend must be adjusted    accordingly.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m32c_elf_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|splt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dynobj
operator|!=
name|NULL
condition|)
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
comment|/* These are only used for relaxing; we don't actually relocate 	 anything with them, so skip them.  */
if|if
condition|(
name|r_type
operator|==
name|R_M32C_RL_JUMP
operator|||
name|r_type
operator|==
name|R_M32C_RL_1ADDR
operator|||
name|r_type
operator|==
name|R_M32C_RL_2ADDR
condition|)
continue|continue;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
block|{
comment|/* This is a relocatable link.  We don't have to change              anything, unless the reloc is against a section symbol,              in which case we have to adjust according to where the              section symbol winds up in the output section.  */
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STT_SECTION
condition|)
block|{
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|+=
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
expr_stmt|;
block|}
block|}
continue|continue;
block|}
comment|/* This is a final link.  */
name|howto
operator|=
name|m32c_elf_howto_table
operator|+
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|st_value
operator|)
expr_stmt|;
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|sym
operator|->
name|st_name
operator|==
literal|0
operator|)
condition|?
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
else|:
name|name
expr_stmt|;
block|}
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
block|{
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_M32C_16
case|:
block|{
name|bfd_vma
modifier|*
name|plt_offset
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|plt_offset
operator|=
operator|&
name|h
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
else|else
name|plt_offset
operator|=
name|elf_local_got_offsets
argument_list|(
name|input_bfd
argument_list|)
operator|+
name|r_symndx
expr_stmt|;
comment|/*	    printf("%s: rel %x plt %d\n", h ? h->root.root.string : "(none)", 		    relocation, *plt_offset);*/
if|if
condition|(
name|relocation
operator|<=
literal|0xffff
condition|)
block|{
comment|/* If the symbol is in range for a 16-bit address, we should 		   have deallocated the plt entry in relax_section.  */
name|BFD_ASSERT
argument_list|(
operator|*
name|plt_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the symbol is out of range for a 16-bit address, 		   we must have allocated a plt entry.  */
name|BFD_ASSERT
argument_list|(
operator|*
name|plt_offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* If this is the first time we've processed this symbol, 		   fill in the plt entry with the correct symbol address.  */
if|if
condition|(
operator|(
operator|*
name|plt_offset
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|int
name|x
decl_stmt|;
name|x
operator|=
literal|0x000000fc
expr_stmt|;
comment|/* jmpf */
name|x
operator||=
operator|(
name|relocation
operator|<<
literal|8
operator|)
operator|&
literal|0xffffff00
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|x
argument_list|,
name|splt
operator|->
name|contents
operator|+
operator|*
name|plt_offset
argument_list|)
expr_stmt|;
operator|*
name|plt_offset
operator||=
literal|1
expr_stmt|;
block|}
name|relocation
operator|=
operator|(
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|splt
operator|->
name|output_offset
operator|+
operator|(
operator|*
name|plt_offset
operator|&
operator|-
literal|2
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|char
modifier|*
name|newname
init|=
name|bfd_malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|5
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|newname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|newname
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|newname
argument_list|,
name|BSF_FUNCTION
operator||
name|BSF_WEAK
argument_list|,
name|splt
argument_list|,
operator|(
operator|*
name|plt_offset
operator|&
operator|-
literal|2
operator|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|R_M32C_HI8
case|:
case|case
name|R_M32C_HI16
case|:
name|relocation
operator|>>=
literal|16
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
block|printf ("relocate %s at %06lx relocation %06lx addend %ld  ", 	      m32c_elf_howto_table[ELF32_R_TYPE(rel->r_info)].name, 	      rel->r_offset + input_section->output_section->vma + input_section->output_offset, 	      relocation, rel->r_addend);       { 	int i; 	for (i=0; i<4; i++) 	  printf (" %02x", contents[rel->r_offset+i]); 	printf ("\n");       }
endif|#
directive|endif
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_overflow
case|:
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
argument_list|(
name|info
argument_list|,
operator|(
name|h
condition|?
operator|&
name|h
operator|->
name|root
else|:
name|NULL
operator|)
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_undefined
case|:
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: out of range error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_notsupported
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unsupported relocation error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_dangerous
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: dangerous relocation"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unknown error"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|msg
condition|)
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the section that should be marked against GC for a given    relocation.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|m32c_elf_gc_mark_hook
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
default|default:
break|break;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|elf_bad_symtab
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|&&
name|ELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STB_LOCAL
operator|)
operator|&&
operator|!
operator|(
operator|(
name|sym
operator|->
name|st_shndx
operator|<=
literal|0
operator|||
name|sym
operator|->
name|st_shndx
operator|>=
name|SHN_LORESERVE
operator|)
operator|&&
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_COMMON
operator|)
condition|)
block|{
return|return
name|bfd_section_from_elf_index
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Update the got entry reference counts for the section being removed.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m32c_elf_gc_sweep_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* We support 16-bit pointers to code above 64k by generating a thunk    below 64k containing a JMP instruction to the final address.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m32c_elf_check_relocs
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes_end
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|bfd_vma
modifier|*
name|local_plt_offsets
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_plt_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|splt
operator|=
name|NULL
expr_stmt|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
name|sym_hashes_end
operator|=
name|sym_hashes
operator|+
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elf_bad_symtab
argument_list|(
name|abfd
argument_list|)
condition|)
name|sym_hashes_end
operator|-=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|bfd_vma
modifier|*
name|offset
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
block|}
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
comment|/* This relocation describes a 16-bit pointer to a function. 	     We may need to allocate a thunk in low memory; reserve memory 	     for it now.  */
case|case
name|R_M32C_16
case|:
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
name|splt
operator|==
name|NULL
condition|)
block|{
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|splt
operator|==
name|NULL
condition|)
block|{
name|splt
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|splt
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|splt
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator||
name|SEC_CODE
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|splt
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|offset
operator|=
operator|&
name|h
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
else|else
block|{
if|if
condition|(
name|local_plt_offsets
operator|==
name|NULL
condition|)
block|{
name|size_t
name|size
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|size
operator|=
name|symtab_hdr
operator|->
name|sh_info
operator|*
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
expr_stmt|;
name|local_plt_offsets
operator|=
operator|(
name|bfd_vma
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_plt_offsets
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|elf_local_got_offsets
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_plt_offsets
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|;
name|i
operator|++
control|)
name|local_plt_offsets
index|[
name|i
index|]
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|offset
operator|=
operator|&
name|local_plt_offsets
index|[
name|r_symndx
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
operator|*
name|offset
operator|=
name|splt
operator|->
name|size
expr_stmt|;
name|splt
operator|->
name|size
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This must exist if dynobj is ever set.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m32c_elf_finish_dynamic_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
comment|/* As an extra sanity check, verify that all plt entries have      been filled in.  */
if|if
condition|(
operator|(
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bfd_byte
modifier|*
name|contents
init|=
name|splt
operator|->
name|contents
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|size
init|=
name|splt
operator|->
name|size
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|unsigned
name|int
name|x
init|=
name|bfd_get_32
argument_list|(
name|dynobj
argument_list|,
name|contents
operator|+
name|i
argument_list|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|x
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|m32c_elf_always_size_sections
parameter_list|(
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|dynobj
operator|=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
expr_stmt|;
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|splt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|splt
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|splt
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|splt
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Function to set the ELF flag bits.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m32c_elf_set_private_flags
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|flagword
name|flags
parameter_list|)
block|{
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|elf_flags_init
argument_list|(
name|abfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m32c_elf_merge_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
name|flagword
name|old_flags
decl_stmt|,
name|old_partial
decl_stmt|;
name|flagword
name|new_flags
decl_stmt|,
name|new_partial
decl_stmt|;
name|bfd_boolean
name|error
init|=
name|FALSE
decl_stmt|;
name|char
name|new_opt
index|[
literal|80
index|]
decl_stmt|;
name|char
name|old_opt
index|[
literal|80
index|]
decl_stmt|;
name|new_opt
index|[
literal|0
index|]
operator|=
name|old_opt
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|new_flags
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|old_flags
operator|=
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"old_flags = 0x%.8lx, new_flags = 0x%.8lx, init = %s, filename = %s"
argument_list|,
name|old_flags
argument_list|,
name|new_flags
argument_list|,
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
condition|)
block|{
comment|/* First call, no flags set.  */
name|elf_flags_init
argument_list|(
name|obfd
argument_list|)
operator|=
name|TRUE
expr_stmt|;
name|elf_elfheader
argument_list|(
name|obfd
argument_list|)
operator|->
name|e_flags
operator|=
name|new_flags
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new_flags
operator|==
name|old_flags
condition|)
comment|/* Compatible flags are ok.	 */
empty_stmt|;
else|else
comment|/* Possibly incompatible flags.	 */
block|{
comment|/* Warn if different cpu is used (allow a specific cpu to override 	 the generic cpu).  */
name|new_partial
operator|=
operator|(
name|new_flags
operator|&
name|EF_M32C_CPU_MASK
operator|)
expr_stmt|;
name|old_partial
operator|=
operator|(
name|old_flags
operator|&
name|EF_M32C_CPU_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|new_partial
operator|==
name|old_partial
condition|)
empty_stmt|;
else|else
block|{
switch|switch
condition|(
name|new_partial
condition|)
block|{
default|default:
name|strcat
argument_list|(
name|new_opt
argument_list|,
literal|" -m16c"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_M32C_CPU_M16C
case|:
name|strcat
argument_list|(
name|new_opt
argument_list|,
literal|" -m16c"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_M32C_CPU_M32C
case|:
name|strcat
argument_list|(
name|new_opt
argument_list|,
literal|" -m32c"
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|old_partial
condition|)
block|{
default|default:
name|strcat
argument_list|(
name|old_opt
argument_list|,
literal|" -m16c"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_M32C_CPU_M16C
case|:
name|strcat
argument_list|(
name|old_opt
argument_list|,
literal|" -m16c"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_M32C_CPU_M32C
case|:
name|strcat
argument_list|(
name|old_opt
argument_list|,
literal|" -m32c"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Print out any mismatches from above.  */
if|if
condition|(
name|new_opt
index|[
literal|0
index|]
condition|)
block|{
name|error
operator|=
name|TRUE
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: compiled with %s and linked with modules compiled with %s"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|new_opt
argument_list|,
name|old_opt
argument_list|)
expr_stmt|;
block|}
name|new_flags
operator|&=
operator|~
name|EF_M32C_ALL_FLAGS
expr_stmt|;
name|old_flags
operator|&=
operator|~
name|EF_M32C_ALL_FLAGS
expr_stmt|;
comment|/* Warn about any other mismatches.  */
if|if
condition|(
name|new_flags
operator|!=
name|old_flags
condition|)
block|{
name|error
operator|=
name|TRUE
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|new_flags
argument_list|,
operator|(
name|long
operator|)
name|old_flags
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
operator|!
name|error
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|bfd_boolean
name|m32c_elf_print_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|PTR
name|ptr
parameter_list|)
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|ptr
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|abfd
operator|!=
name|NULL
operator|&&
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Print normal ELF private data.  */
name|_bfd_elf_print_private_bfd_data
argument_list|(
name|abfd
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|flags
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|_
argument_list|(
literal|"private flags = 0x%lx:"
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|flags
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|flags
operator|&
name|EF_M32C_CPU_MASK
condition|)
block|{
default|default:
break|break;
case|case
name|EF_M32C_CPU_M16C
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -m16c"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_M32C_CPU_M32C
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" -m32c"
argument_list|)
expr_stmt|;
break|break;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return the MACH for an e_flags value.  */
end_comment

begin_function
specifier|static
name|int
name|elf32_m32c_machine
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
switch|switch
condition|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&
name|EF_M32C_CPU_MASK
condition|)
block|{
case|case
name|EF_M32C_CPU_M16C
case|:
return|return
name|bfd_mach_m16c
return|;
case|case
name|EF_M32C_CPU_M32C
case|:
return|return
name|bfd_mach_m32c
return|;
block|}
return|return
name|bfd_mach_m16c
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|m32c_elf_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_m32c
argument_list|,
name|elf32_m32c_machine
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|dump_symtab
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|void
modifier|*
name|internal_syms
parameter_list|,
name|void
modifier|*
name|external_syms
parameter_list|)
block|{
name|size_t
name|locsymcount
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymend
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|bfd_boolean
name|free_internal
init|=
literal|0
decl_stmt|,
name|free_external
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|st_info_str
decl_stmt|;
name|char
modifier|*
name|st_info_stb_str
decl_stmt|;
name|char
modifier|*
name|st_other_str
decl_stmt|;
name|char
modifier|*
name|st_shndx_str
decl_stmt|;
if|if
condition|(
operator|!
name|internal_syms
condition|)
block|{
name|internal_syms
operator|=
name|bfd_malloc
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|free_internal
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|external_syms
condition|)
block|{
name|external_syms
operator|=
name|bfd_malloc
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|free_external
operator|=
literal|1
expr_stmt|;
block|}
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_size
operator|/
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
if|if
condition|(
name|free_internal
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|internal_syms
argument_list|,
name|external_syms
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|isymbuf
operator|=
name|internal_syms
expr_stmt|;
name|isymend
operator|=
name|isymbuf
operator|+
name|locsymcount
expr_stmt|;
for|for
control|(
name|isym
operator|=
name|isymbuf
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
control|)
block|{
switch|switch
condition|(
name|ELF_ST_TYPE
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
condition|)
block|{
case|case
name|STT_FUNC
case|:
name|st_info_str
operator|=
literal|"STT_FUNC"
expr_stmt|;
case|case
name|STT_SECTION
case|:
name|st_info_str
operator|=
literal|"STT_SECTION"
expr_stmt|;
case|case
name|STT_SRELC
case|:
name|st_info_str
operator|=
literal|"STT_SRELC"
expr_stmt|;
case|case
name|STT_FILE
case|:
name|st_info_str
operator|=
literal|"STT_FILE"
expr_stmt|;
case|case
name|STT_OBJECT
case|:
name|st_info_str
operator|=
literal|"STT_OBJECT"
expr_stmt|;
case|case
name|STT_TLS
case|:
name|st_info_str
operator|=
literal|"STT_TLS"
expr_stmt|;
default|default:
name|st_info_str
operator|=
literal|""
expr_stmt|;
block|}
switch|switch
condition|(
name|ELF_ST_BIND
argument_list|(
name|isym
operator|->
name|st_info
argument_list|)
condition|)
block|{
case|case
name|STB_LOCAL
case|:
name|st_info_stb_str
operator|=
literal|"STB_LOCAL"
expr_stmt|;
case|case
name|STB_GLOBAL
case|:
name|st_info_stb_str
operator|=
literal|"STB_GLOBAL"
expr_stmt|;
default|default:
name|st_info_stb_str
operator|=
literal|""
expr_stmt|;
block|}
switch|switch
condition|(
name|ELF_ST_VISIBILITY
argument_list|(
name|isym
operator|->
name|st_other
argument_list|)
condition|)
block|{
case|case
name|STV_DEFAULT
case|:
name|st_other_str
operator|=
literal|"STV_DEFAULT"
expr_stmt|;
case|case
name|STV_INTERNAL
case|:
name|st_other_str
operator|=
literal|"STV_INTERNAL"
expr_stmt|;
case|case
name|STV_PROTECTED
case|:
name|st_other_str
operator|=
literal|"STV_PROTECTED"
expr_stmt|;
default|default:
name|st_other_str
operator|=
literal|""
expr_stmt|;
block|}
switch|switch
condition|(
name|isym
operator|->
name|st_shndx
condition|)
block|{
case|case
name|SHN_ABS
case|:
name|st_shndx_str
operator|=
literal|"SHN_ABS"
expr_stmt|;
case|case
name|SHN_COMMON
case|:
name|st_shndx_str
operator|=
literal|"SHN_COMMON"
expr_stmt|;
case|case
name|SHN_UNDEF
case|:
name|st_shndx_str
operator|=
literal|"SHN_UNDEF"
expr_stmt|;
default|default:
name|st_shndx_str
operator|=
literal|""
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"isym = %p st_value = %lx st_size = %lx st_name = (%lu) %s "
literal|"st_info = (%d) %s %s st_other = (%d) %s st_shndx = (%d) %s\n"
argument_list|,
name|isym
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|isym
operator|->
name|st_value
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|isym
operator|->
name|st_size
argument_list|,
name|isym
operator|->
name|st_name
argument_list|,
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|isym
operator|->
name|st_name
argument_list|)
argument_list|,
name|isym
operator|->
name|st_info
argument_list|,
name|st_info_str
argument_list|,
name|st_info_stb_str
argument_list|,
name|isym
operator|->
name|st_other
argument_list|,
name|st_other_str
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|,
name|st_shndx_str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|free_internal
condition|)
name|free
argument_list|(
name|internal_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_external
condition|)
name|free
argument_list|(
name|external_syms
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|m32c_get_reloc
parameter_list|(
name|long
name|reloc
parameter_list|)
block|{
if|if
condition|(
literal|0
operator|<=
name|reloc
operator|&&
name|reloc
operator|<
name|R_M32C_max
condition|)
return|return
name|m32c_elf_howto_table
index|[
name|reloc
index|]
operator|.
name|name
return|;
else|else
return|return
literal|""
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/* Handle relaxing.  */
end_comment

begin_comment
comment|/* A subroutine of m32c_elf_relax_section.  If the global symbol H    is within the low 64k, remove any entry for it in the plt.  */
end_comment

begin_struct
struct|struct
name|relax_plt_data
block|{
name|asection
modifier|*
name|splt
decl_stmt|;
name|bfd_boolean
modifier|*
name|again
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|bfd_boolean
name|m32c_relax_plt_check
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|PTR
name|xdata
parameter_list|)
block|{
name|struct
name|relax_plt_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|relax_plt_data
operator|*
operator|)
name|xdata
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|bfd_vma
name|address
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|address
operator|=
literal|0
expr_stmt|;
else|else
name|address
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|)
expr_stmt|;
if|if
condition|(
name|address
operator|<=
literal|0xffff
condition|)
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
name|data
operator|->
name|splt
operator|->
name|size
operator|-=
literal|4
expr_stmt|;
operator|*
name|data
operator|->
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of m32c_elf_relax_section.  If the global symbol H    previously had a plt entry, give it a new entry offset.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m32c_relax_plt_realloc
parameter_list|(
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|PTR
name|xdata
parameter_list|)
block|{
name|bfd_vma
modifier|*
name|entry
init|=
operator|(
name|bfd_vma
operator|*
operator|)
name|xdata
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|*
name|entry
expr_stmt|;
operator|*
name|entry
operator|+=
literal|4
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|m32c_elf_relax_plt_section
parameter_list|(
name|bfd
modifier|*
name|dynobj
parameter_list|,
name|asection
modifier|*
name|splt
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd_boolean
modifier|*
name|again
parameter_list|)
block|{
name|struct
name|relax_plt_data
name|relax_plt_data
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
comment|/* Assume nothing changes.  */
operator|*
name|again
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
comment|/* We only relax the .plt section at the moment.  */
if|if
condition|(
name|dynobj
operator|!=
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|||
name|strcmp
argument_list|(
name|splt
operator|->
name|name
argument_list|,
literal|".plt"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* Quick check for an empty plt.  */
if|if
condition|(
name|splt
operator|->
name|size
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* Map across all global symbols; see which ones happen to      fall in the low 64k.  */
name|relax_plt_data
operator|.
name|splt
operator|=
name|splt
expr_stmt|;
name|relax_plt_data
operator|.
name|again
operator|=
name|again
expr_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|m32c_relax_plt_check
argument_list|,
operator|&
name|relax_plt_data
argument_list|)
expr_stmt|;
comment|/* Likewise for local symbols, though that's somewhat less convenient      as we have to walk the list of input bfds and swap in symbol data.  */
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|bfd_vma
modifier|*
name|local_plt_offsets
init|=
name|elf_local_got_offsets
argument_list|(
name|ibfd
argument_list|)
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
if|if
condition|(
operator|!
name|local_plt_offsets
condition|)
continue|continue;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
if|if
condition|(
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|ibfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|;
operator|++
name|idx
control|)
block|{
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|asection
modifier|*
name|tsec
decl_stmt|;
name|bfd_vma
name|address
decl_stmt|;
if|if
condition|(
name|local_plt_offsets
index|[
name|idx
index|]
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
continue|continue;
name|isym
operator|=
operator|&
name|isymbuf
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|tsec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|tsec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
name|tsec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|ibfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|address
operator|=
operator|(
name|tsec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|tsec
operator|->
name|output_offset
operator|+
name|isym
operator|->
name|st_value
operator|)
expr_stmt|;
if|if
condition|(
name|address
operator|<=
literal|0xffff
condition|)
block|{
name|local_plt_offsets
index|[
name|idx
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|splt
operator|->
name|size
operator|-=
literal|4
expr_stmt|;
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the symbols for elf_link_input_bfd.  */
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
block|}
block|}
block|}
comment|/* If we changed anything, walk the symbols again to reallocate      .plt entry addresses.  */
if|if
condition|(
operator|*
name|again
operator|&&
name|splt
operator|->
name|size
operator|>
literal|0
condition|)
block|{
name|bfd_vma
name|entry
init|=
literal|0
decl_stmt|;
name|elf_link_hash_traverse
argument_list|(
name|elf_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|m32c_relax_plt_realloc
argument_list|,
operator|&
name|entry
argument_list|)
expr_stmt|;
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|bfd_vma
modifier|*
name|local_plt_offsets
init|=
name|elf_local_got_offsets
argument_list|(
name|ibfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|nlocals
init|=
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_info
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
if|if
condition|(
operator|!
name|local_plt_offsets
condition|)
continue|continue;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|nlocals
condition|;
operator|++
name|idx
control|)
if|if
condition|(
name|local_plt_offsets
index|[
name|idx
index|]
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|local_plt_offsets
index|[
name|idx
index|]
operator|=
name|entry
expr_stmt|;
name|entry
operator|+=
literal|4
expr_stmt|;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|compare_reloc
parameter_list|(
specifier|const
name|void
modifier|*
name|e1
parameter_list|,
specifier|const
name|void
modifier|*
name|e2
parameter_list|)
block|{
specifier|const
name|Elf_Internal_Rela
modifier|*
name|i1
init|=
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
name|e1
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|i2
init|=
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
name|e2
decl_stmt|;
if|if
condition|(
name|i1
operator|->
name|r_offset
operator|==
name|i2
operator|->
name|r_offset
condition|)
return|return
literal|0
return|;
else|else
return|return
name|i1
operator|->
name|r_offset
operator|<
name|i2
operator|->
name|r_offset
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|OFFSET_FOR_RELOC
parameter_list|(
name|rel
parameter_list|)
value|m32c_offset_for_reloc (abfd, rel, symtab_hdr, shndx_buf, intsyms)
end_define

begin_function
specifier|static
name|bfd_vma
name|m32c_offset_for_reloc
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
parameter_list|,
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
parameter_list|,
name|Elf_External_Sym_Shndx
modifier|*
name|shndx_buf
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|intsyms
parameter_list|)
block|{
name|bfd_vma
name|symval
decl_stmt|;
comment|/* Get the value of the symbol referred to by the reloc.  */
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* A local symbol.  */
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|Elf_External_Sym_Shndx
modifier|*
name|shndx
decl_stmt|;
name|asection
modifier|*
name|ssec
decl_stmt|;
name|isym
operator|=
name|intsyms
operator|+
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|ssec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|shndx
operator|=
name|shndx_buf
operator|+
operator|(
name|shndx_buf
condition|?
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|symval
operator|=
name|isym
operator|->
name|st_value
expr_stmt|;
if|if
condition|(
name|ssec
condition|)
name|symval
operator|+=
name|ssec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|ssec
operator|->
name|output_offset
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|indx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* An external symbol.  */
name|indx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
comment|/* This appears to be a reference to an undefined 	   symbol.  Just ignore it--it will be caught by the 	   regular reloc processing.  */
return|return
literal|0
return|;
name|symval
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
return|return
name|symval
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|bytes_saved
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bytes_to_reloc
index|[]
init|=
block|{
name|R_M32C_NONE
block|,
name|R_M32C_8
block|,
name|R_M32C_16
block|,
name|R_M32C_24
block|,
name|R_M32C_32
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What we use the bits in a relax reloc addend (R_M32C_RL_*) for.  */
end_comment

begin_comment
comment|/* Mask for the number of relocs associated with this insn.  */
end_comment

begin_define
define|#
directive|define
name|RLA_RELOCS
value|0x0000000f
end_define

begin_comment
comment|/* Number of bytes gas emitted (before gas's relaxing) */
end_comment

begin_define
define|#
directive|define
name|RLA_NBYTES
value|0x00000ff0
end_define

begin_comment
comment|/* If the displacement is within the given range and the new encoding    differs from the old encoding (the index), then the insn can be    relaxed to the new encoding.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|bytes
decl_stmt|;
name|unsigned
name|int
name|max_disp
decl_stmt|;
name|unsigned
name|char
name|new_encoding
decl_stmt|;
block|}
name|EncodingTable
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|EncodingTable
name|m16c_addr_encodings
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* R0 */
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* R1 */
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|}
block|,
comment|/* R2 */
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|}
block|,
comment|/* R3 */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|}
block|,
comment|/* A0 */
block|{
literal|0
block|,
literal|0
block|,
literal|5
block|}
block|,
comment|/* A1 */
block|{
literal|0
block|,
literal|0
block|,
literal|6
block|}
block|,
comment|/* [A0] */
block|{
literal|0
block|,
literal|0
block|,
literal|7
block|}
block|,
comment|/* [A1] */
block|{
literal|1
block|,
literal|0
block|,
literal|6
block|}
block|,
comment|/* udsp:8[A0] */
block|{
literal|1
block|,
literal|0
block|,
literal|7
block|}
block|,
comment|/* udsp:8[A1] */
block|{
literal|1
block|,
literal|0
block|,
literal|10
block|}
block|,
comment|/* udsp:8[SB] */
block|{
literal|1
block|,
literal|0
block|,
literal|11
block|}
block|,
comment|/* sdsp:8[FB] */
block|{
literal|2
block|,
literal|255
block|,
literal|8
block|}
block|,
comment|/* udsp:16[A0] */
block|{
literal|2
block|,
literal|255
block|,
literal|9
block|}
block|,
comment|/* udsp:16[A1] */
block|{
literal|2
block|,
literal|255
block|,
literal|10
block|}
block|,
comment|/* udsp:16[SB] */
block|{
literal|2
block|,
literal|0
block|,
literal|15
block|}
block|,
comment|/* abs:16 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|EncodingTable
name|m16c_jmpaddr_encodings
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* R0 */
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* R1 */
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|}
block|,
comment|/* R2 */
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|}
block|,
comment|/* R3 */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|}
block|,
comment|/* A0 */
block|{
literal|0
block|,
literal|0
block|,
literal|5
block|}
block|,
comment|/* A1 */
block|{
literal|0
block|,
literal|0
block|,
literal|6
block|}
block|,
comment|/* [A0] */
block|{
literal|0
block|,
literal|0
block|,
literal|7
block|}
block|,
comment|/* [A1] */
block|{
literal|1
block|,
literal|0
block|,
literal|6
block|}
block|,
comment|/* udsp:8[A0] */
block|{
literal|1
block|,
literal|0
block|,
literal|7
block|}
block|,
comment|/* udsp:8[A1] */
block|{
literal|1
block|,
literal|0
block|,
literal|10
block|}
block|,
comment|/* udsp:8[SB] */
block|{
literal|1
block|,
literal|0
block|,
literal|11
block|}
block|,
comment|/* sdsp:8[FB] */
block|{
literal|3
block|,
literal|255
block|,
literal|8
block|}
block|,
comment|/* udsp:20[A0] */
block|{
literal|3
block|,
literal|255
block|,
literal|9
block|}
block|,
comment|/* udsp:20[A1] */
block|{
literal|2
block|,
literal|255
block|,
literal|10
block|}
block|,
comment|/* udsp:16[SB] */
block|{
literal|2
block|,
literal|0
block|,
literal|15
block|}
block|,
comment|/* abs:16 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|EncodingTable
name|m32c_addr_encodings
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* [A0] */
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* [A1] */
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|}
block|,
comment|/* A0 */
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|}
block|,
comment|/* A1 */
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* udsp:8[A0] */
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* udsp:8[A1] */
block|{
literal|1
block|,
literal|0
block|,
literal|6
block|}
block|,
comment|/* udsp:8[SB] */
block|{
literal|1
block|,
literal|0
block|,
literal|7
block|}
block|,
comment|/* sdsp:8[FB] */
block|{
literal|2
block|,
literal|255
block|,
literal|4
block|}
block|,
comment|/* udsp:16[A0] */
block|{
literal|2
block|,
literal|255
block|,
literal|5
block|}
block|,
comment|/* udsp:16[A1] */
block|{
literal|2
block|,
literal|255
block|,
literal|6
block|}
block|,
comment|/* udsp:16[SB] */
block|{
literal|2
block|,
literal|127
block|,
literal|7
block|}
block|,
comment|/* sdsp:16[FB] */
block|{
literal|3
block|,
literal|65535
block|,
literal|8
block|}
block|,
comment|/* udsp:24[A0] */
block|{
literal|3
block|,
literal|65535
block|,
literal|9
block|}
block|,
comment|/* udsp:24[A1] */
block|{
literal|3
block|,
literal|65535
block|,
literal|15
block|}
block|,
comment|/* abs24 */
block|{
literal|2
block|,
literal|0
block|,
literal|15
block|}
block|,
comment|/* abs16 */
block|{
literal|0
block|,
literal|0
block|,
literal|16
block|}
block|,
comment|/* R2 */
block|{
literal|0
block|,
literal|0
block|,
literal|17
block|}
block|,
comment|/* R3 */
block|{
literal|0
block|,
literal|0
block|,
literal|18
block|}
block|,
comment|/* R0 */
block|{
literal|0
block|,
literal|0
block|,
literal|19
block|}
block|,
comment|/* R1 */
block|{
literal|0
block|,
literal|0
block|,
literal|20
block|}
block|,
comment|/*  */
block|{
literal|0
block|,
literal|0
block|,
literal|21
block|}
block|,
comment|/*  */
block|{
literal|0
block|,
literal|0
block|,
literal|22
block|}
block|,
comment|/*  */
block|{
literal|0
block|,
literal|0
block|,
literal|23
block|}
block|,
comment|/*  */
block|{
literal|0
block|,
literal|0
block|,
literal|24
block|}
block|,
comment|/*  */
block|{
literal|0
block|,
literal|0
block|,
literal|25
block|}
block|,
comment|/*  */
block|{
literal|0
block|,
literal|0
block|,
literal|26
block|}
block|,
comment|/*  */
block|{
literal|0
block|,
literal|0
block|,
literal|27
block|}
block|,
comment|/*  */
block|{
literal|0
block|,
literal|0
block|,
literal|28
block|}
block|,
comment|/*  */
block|{
literal|0
block|,
literal|0
block|,
literal|29
block|}
block|,
comment|/*  */
block|{
literal|0
block|,
literal|0
block|,
literal|30
block|}
block|,
comment|/*  */
block|{
literal|0
block|,
literal|0
block|,
literal|31
block|}
block|,
comment|/*  */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|bfd_boolean
name|m32c_elf_relax_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|bfd_boolean
modifier|*
name|again
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|shndx_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|free_relocs
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|,
modifier|*
name|srel
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|bfd_byte
modifier|*
name|free_contents
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|intsyms
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|free_intsyms
init|=
name|NULL
decl_stmt|;
name|Elf_External_Sym_Shndx
modifier|*
name|shndx_buf
init|=
name|NULL
decl_stmt|;
name|int
name|machine
decl_stmt|;
if|if
condition|(
name|abfd
operator|==
name|elf_hash_table
argument_list|(
name|link_info
argument_list|)
operator|->
name|dynobj
operator|&&
name|strcmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".plt"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|m32c_elf_relax_plt_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
argument_list|,
name|again
argument_list|)
return|;
comment|/* Assume nothing changes.  */
operator|*
name|again
operator|=
name|FALSE
expr_stmt|;
name|machine
operator|=
name|elf32_m32c_machine
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* We don't have to do anything for a relocatable link, if      this section does not have relocs, or if this is not a      code section.  */
if|if
condition|(
name|link_info
operator|->
name|relocatable
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|sec
operator|->
name|reloc_count
operator|==
literal|0
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|shndx_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_shndx_hdr
expr_stmt|;
comment|/* Get the section contents.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
comment|/* Go get them off disk.  */
elseif|else
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|&
name|contents
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* Read this BFD's symbols.  */
comment|/* Get cached copy if it exists.  */
if|if
condition|(
name|symtab_hdr
operator|->
name|contents
operator|!=
name|NULL
condition|)
block|{
name|intsyms
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
block|}
else|else
block|{
name|intsyms
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|intsyms
expr_stmt|;
block|}
if|if
condition|(
name|shndx_hdr
operator|->
name|sh_size
operator|!=
literal|0
condition|)
block|{
name|bfd_size_type
name|amt
decl_stmt|;
name|amt
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|Elf_External_Sym_Shndx
argument_list|)
expr_stmt|;
name|shndx_buf
operator|=
operator|(
name|Elf_External_Sym_Shndx
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|shndx_buf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|shndx_hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_bread
argument_list|(
operator|(
name|PTR
operator|)
name|shndx_buf
argument_list|,
name|amt
argument_list|,
name|abfd
argument_list|)
operator|!=
name|amt
condition|)
goto|goto
name|error_return
goto|;
name|shndx_hdr
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|shndx_buf
expr_stmt|;
block|}
comment|/* Get a copy of the native relocations.  */
name|internal_relocs
operator|=
operator|(
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free_relocs
operator|=
name|internal_relocs
expr_stmt|;
comment|/* The RL_ relocs must be just before the operand relocs they go      with, so we must sort them to guarantee this.  */
name|qsort
argument_list|(
name|internal_relocs
argument_list|,
name|sec
operator|->
name|reloc_count
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Rela
argument_list|)
argument_list|,
name|compare_reloc
argument_list|)
expr_stmt|;
comment|/* Walk through them looking for relaxing opportunities.  */
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|symval
decl_stmt|;
name|unsigned
name|char
modifier|*
name|insn
decl_stmt|,
modifier|*
name|gap
decl_stmt|,
modifier|*
name|einsn
decl_stmt|;
name|bfd_vma
name|pc
decl_stmt|;
name|bfd_signed_vma
name|pcrel
decl_stmt|;
name|int
name|relax_relocs
decl_stmt|;
name|int
name|gap_size
decl_stmt|;
name|int
name|new_type
decl_stmt|;
name|int
name|posn
decl_stmt|;
name|int
name|enc
decl_stmt|;
name|EncodingTable
modifier|*
name|enctbl
decl_stmt|;
name|EncodingTable
modifier|*
name|e
decl_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_M32C_RL_JUMP
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_M32C_RL_1ADDR
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_M32C_RL_2ADDR
condition|)
continue|continue;
name|srel
operator|=
name|irel
expr_stmt|;
comment|/* There will always be room for the relaxed insn, since it is smaller 	 than the one it would replace.  */
name|BFD_ASSERT
argument_list|(
name|irel
operator|->
name|r_offset
operator|<
name|sec
operator|->
name|size
argument_list|)
expr_stmt|;
name|insn
operator|=
name|contents
operator|+
name|irel
operator|->
name|r_offset
expr_stmt|;
name|relax_relocs
operator|=
name|irel
operator|->
name|r_addend
operator|%
literal|16
expr_stmt|;
comment|/* Ok, we only have three relocs we care about, and they're all 	 fake.  The lower four bits of the addend is always the number 	 of following relocs (hence the qsort above) that are assigned 	 to this opcode.  The next 8 bits of the addend indicates the 	 number of bytes in the insn.  We use the rest of them 	 ourselves as flags for the more expensive operations (defines 	 above).  The three relocs are:  	 RL_JUMP: This marks all direct jump insns.  We check the 		displacement and replace them with shorter jumps if 		they're in range.  We also use this to find JMP.S 		insns and manually shorten them when we delete bytes. 		We have to decode these insns to figure out what to 		do.  	 RL_1ADDR: This is a :G or :Q insn, which has a single 		"standard" operand.  We have to extract the type 		field, see if it's a wide displacement, then figure 		out if we can replace it with a narrow displacement. 		We don't have to decode these insns.  	 RL_2ADDR: Similarly, but two "standard" operands.  Note that 		r_addend may still be 1, as standard operands don't 		always have displacements.  Gas shouldn't give us one 		with zero operands, but since we don't know which one 		has the displacement, we check them both anyway.  	 These all point to the beginning of the insn itself, not the 	 operands.  	 Note that we only relax one step at a time, relying on the 	 linker to call us repeatedly.  Thus, there is no code for 	 JMP.A->JMP.B although that will happen in two steps. 	 Likewise, for 2ADDR relaxes, we do one operand per cycle.       */
comment|/* Get the value of the symbol referred to by the reloc.  Just          in case this is the last reloc in the list, use the RL's          addend to choose between this reloc (no addend) or the next          (yes addend, which means at least one following reloc).  */
name|srel
operator|=
name|irel
operator|+
operator|(
name|relax_relocs
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|symval
operator|=
name|OFFSET_FOR_RELOC
argument_list|(
name|srel
argument_list|)
expr_stmt|;
comment|/* Setting gap_size nonzero is the flag which means "something 	 shrunk".  */
name|gap_size
operator|=
literal|0
expr_stmt|;
name|gap
operator|=
name|NULL
expr_stmt|;
name|new_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|srel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|pc
operator|=
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|srel
operator|->
name|r_offset
expr_stmt|;
name|pcrel
operator|=
name|symval
operator|-
name|pc
operator|+
name|srel
operator|->
name|r_addend
expr_stmt|;
if|if
condition|(
name|machine
operator|==
name|bfd_mach_m16c
condition|)
block|{
comment|/* R8C / M16C */
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_M32C_RL_JUMP
case|:
switch|switch
condition|(
name|insn
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0xfe
case|:
comment|/* jmp.b */
if|if
condition|(
name|pcrel
operator|>=
literal|2
operator|&&
name|pcrel
operator|<=
literal|9
condition|)
block|{
comment|/* Relax JMP.B -> JMP.S.  We need to get rid of 			 the following reloc though. */
name|insn
index|[
literal|0
index|]
operator|=
literal|0x60
operator||
operator|(
name|pcrel
operator|-
literal|2
operator|)
expr_stmt|;
name|new_type
operator|=
name|R_M32C_NONE
expr_stmt|;
name|irel
operator|->
name|r_addend
operator|=
literal|0x10
expr_stmt|;
name|gap_size
operator|=
literal|1
expr_stmt|;
name|gap
operator|=
name|insn
operator|+
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|0xf4
case|:
comment|/* jmp.w */
comment|/* 128 is allowed because it will be one byte closer 		     after relaxing.  Likewise for all other pc-rel 		     jumps.  */
if|if
condition|(
name|pcrel
operator|<=
literal|128
operator|&&
name|pcrel
operator|>=
operator|-
literal|128
condition|)
block|{
comment|/* Relax JMP.W -> JMP.B */
name|insn
index|[
literal|0
index|]
operator|=
literal|0xfe
expr_stmt|;
name|insn
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|new_type
operator|=
name|R_M32C_8_PCREL
expr_stmt|;
name|gap_size
operator|=
literal|1
expr_stmt|;
name|gap
operator|=
name|insn
operator|+
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|0xfc
case|:
comment|/* jmp.a */
if|if
condition|(
name|pcrel
operator|<=
literal|32768
operator|&&
name|pcrel
operator|>=
operator|-
literal|32768
condition|)
block|{
comment|/* Relax JMP.A -> JMP.W */
name|insn
index|[
literal|0
index|]
operator|=
literal|0xf4
expr_stmt|;
name|insn
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|insn
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|new_type
operator|=
name|R_M32C_16_PCREL
expr_stmt|;
name|gap_size
operator|=
literal|1
expr_stmt|;
name|gap
operator|=
name|insn
operator|+
literal|3
expr_stmt|;
block|}
break|break;
case|case
literal|0xfd
case|:
comment|/* jsr.a */
if|if
condition|(
name|pcrel
operator|<=
literal|32768
operator|&&
name|pcrel
operator|>=
operator|-
literal|32768
condition|)
block|{
comment|/* Relax JSR.A -> JSR.W */
name|insn
index|[
literal|0
index|]
operator|=
literal|0xf5
expr_stmt|;
name|insn
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|insn
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|new_type
operator|=
name|R_M32C_16_PCREL
expr_stmt|;
name|gap_size
operator|=
literal|1
expr_stmt|;
name|gap
operator|=
name|insn
operator|+
literal|3
expr_stmt|;
block|}
break|break;
block|}
break|break;
case|case
name|R_M32C_RL_2ADDR
case|:
comment|/* xxxx xxxx srce dest [src-disp] [dest-disp]*/
name|enctbl
operator|=
name|m16c_addr_encodings
expr_stmt|;
name|posn
operator|=
literal|2
expr_stmt|;
name|enc
operator|=
operator|(
name|insn
index|[
literal|1
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
expr_stmt|;
name|e
operator|=
operator|&
name|enctbl
index|[
name|enc
index|]
expr_stmt|;
if|if
condition|(
name|srel
operator|->
name|r_offset
operator|==
name|irel
operator|->
name|r_offset
operator|+
name|posn
operator|&&
name|e
operator|->
name|new_encoding
operator|!=
name|enc
operator|&&
name|symval
operator|<=
name|e
operator|->
name|max_disp
condition|)
block|{
name|insn
index|[
literal|1
index|]
operator|&=
literal|0x0f
expr_stmt|;
name|insn
index|[
literal|1
index|]
operator||=
name|e
operator|->
name|new_encoding
operator|<<
literal|4
expr_stmt|;
name|gap_size
operator|=
name|e
operator|->
name|bytes
operator|-
name|enctbl
index|[
name|e
operator|->
name|new_encoding
index|]
operator|.
name|bytes
expr_stmt|;
name|gap
operator|=
name|insn
operator|+
name|posn
operator|+
name|enctbl
index|[
name|e
operator|->
name|new_encoding
index|]
operator|.
name|bytes
expr_stmt|;
name|new_type
operator|=
name|bytes_to_reloc
index|[
name|enctbl
index|[
name|e
operator|->
name|new_encoding
index|]
operator|.
name|bytes
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|relax_relocs
operator|==
literal|2
condition|)
name|srel
operator|++
expr_stmt|;
name|posn
operator|+=
name|e
operator|->
name|bytes
expr_stmt|;
goto|goto
name|try_1addr_16
goto|;
case|case
name|R_M32C_RL_1ADDR
case|:
comment|/* xxxx xxxx xxxx dest [disp] */
name|enctbl
operator|=
name|m16c_addr_encodings
expr_stmt|;
name|posn
operator|=
literal|2
expr_stmt|;
comment|/* Check the opcode for jumps.  We know it's safe to 		 do this because all 2ADDR insns are at least two 		 bytes long.  */
name|enc
operator|=
name|insn
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|insn
index|[
literal|1
index|]
expr_stmt|;
name|enc
operator|&=
literal|0xfff0
expr_stmt|;
if|if
condition|(
name|enc
operator|==
literal|0x7d20
operator|||
name|enc
operator|==
literal|0x7d00
operator|||
name|enc
operator|==
literal|0x7d30
operator|||
name|enc
operator|==
literal|0x7d10
condition|)
block|{
name|enctbl
operator|=
name|m16c_jmpaddr_encodings
expr_stmt|;
block|}
name|try_1addr_16
label|:
comment|/* srel, posn, and enc must be set here.  */
name|symval
operator|=
name|OFFSET_FOR_RELOC
argument_list|(
name|srel
argument_list|)
expr_stmt|;
name|enc
operator|=
name|insn
index|[
literal|1
index|]
operator|&
literal|0x0f
expr_stmt|;
name|e
operator|=
operator|&
name|enctbl
index|[
name|enc
index|]
expr_stmt|;
if|if
condition|(
name|srel
operator|->
name|r_offset
operator|==
name|irel
operator|->
name|r_offset
operator|+
name|posn
operator|&&
name|e
operator|->
name|new_encoding
operator|!=
name|enc
operator|&&
name|symval
operator|<=
name|e
operator|->
name|max_disp
condition|)
block|{
name|insn
index|[
literal|1
index|]
operator|&=
literal|0xf0
expr_stmt|;
name|insn
index|[
literal|1
index|]
operator||=
name|e
operator|->
name|new_encoding
expr_stmt|;
name|gap_size
operator|=
name|e
operator|->
name|bytes
operator|-
name|enctbl
index|[
name|e
operator|->
name|new_encoding
index|]
operator|.
name|bytes
expr_stmt|;
name|gap
operator|=
name|insn
operator|+
name|posn
operator|+
name|enctbl
index|[
name|e
operator|->
name|new_encoding
index|]
operator|.
name|bytes
expr_stmt|;
name|new_type
operator|=
name|bytes_to_reloc
index|[
name|enctbl
index|[
name|e
operator|->
name|new_encoding
index|]
operator|.
name|bytes
index|]
expr_stmt|;
break|break;
block|}
break|break;
block|}
comment|/* Ends switch (reloc type) for m16c.  */
block|}
else|else
comment|/* machine == bfd_mach_m32c */
block|{
comment|/* M32CM / M32C */
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_M32C_RL_JUMP
case|:
switch|switch
condition|(
name|insn
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0xbb
case|:
comment|/* jmp.b */
if|if
condition|(
name|pcrel
operator|>=
literal|2
operator|&&
name|pcrel
operator|<=
literal|9
condition|)
block|{
name|int
name|p
init|=
name|pcrel
operator|-
literal|2
decl_stmt|;
comment|/* Relax JMP.B -> JMP.S.  We need to get rid of 			 the following reloc though. */
name|insn
index|[
literal|0
index|]
operator|=
literal|0x4a
operator||
operator|(
operator|(
name|p
operator|<<
literal|3
operator|)
operator|&
literal|0x30
operator|)
operator||
operator|(
name|p
operator|&
literal|1
operator|)
expr_stmt|;
name|new_type
operator|=
name|R_M32C_NONE
expr_stmt|;
name|irel
operator|->
name|r_addend
operator|=
literal|0x10
expr_stmt|;
name|gap_size
operator|=
literal|1
expr_stmt|;
name|gap
operator|=
name|insn
operator|+
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|0xce
case|:
comment|/* jmp.w */
if|if
condition|(
name|pcrel
operator|<=
literal|128
operator|&&
name|pcrel
operator|>=
operator|-
literal|128
condition|)
block|{
comment|/* Relax JMP.W -> JMP.B */
name|insn
index|[
literal|0
index|]
operator|=
literal|0xbb
expr_stmt|;
name|insn
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|new_type
operator|=
name|R_M32C_8_PCREL
expr_stmt|;
name|gap_size
operator|=
literal|1
expr_stmt|;
name|gap
operator|=
name|insn
operator|+
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|0xcc
case|:
comment|/* jmp.a */
if|if
condition|(
name|pcrel
operator|<=
literal|32768
operator|&&
name|pcrel
operator|>=
operator|-
literal|32768
condition|)
block|{
comment|/* Relax JMP.A -> JMP.W */
name|insn
index|[
literal|0
index|]
operator|=
literal|0xce
expr_stmt|;
name|insn
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|insn
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|new_type
operator|=
name|R_M32C_16_PCREL
expr_stmt|;
name|gap_size
operator|=
literal|1
expr_stmt|;
name|gap
operator|=
name|insn
operator|+
literal|3
expr_stmt|;
block|}
break|break;
case|case
literal|0xcd
case|:
comment|/* jsr.a */
if|if
condition|(
name|pcrel
operator|<=
literal|32768
operator|&&
name|pcrel
operator|>=
operator|-
literal|32768
condition|)
block|{
comment|/* Relax JSR.A -> JSR.W */
name|insn
index|[
literal|0
index|]
operator|=
literal|0xcf
expr_stmt|;
name|insn
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|insn
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|new_type
operator|=
name|R_M32C_16_PCREL
expr_stmt|;
name|gap_size
operator|=
literal|1
expr_stmt|;
name|gap
operator|=
name|insn
operator|+
literal|3
expr_stmt|;
block|}
break|break;
block|}
break|break;
case|case
name|R_M32C_RL_2ADDR
case|:
comment|/* xSSS DDDx DDSS xxxx [src-disp] [dest-disp]*/
name|einsn
operator|=
name|insn
expr_stmt|;
name|posn
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|einsn
index|[
literal|0
index|]
operator|==
literal|1
condition|)
block|{
comment|/* prefix; remove it as far as the RL reloc is concerned.  */
name|einsn
operator|++
expr_stmt|;
name|posn
operator|++
expr_stmt|;
block|}
name|enctbl
operator|=
name|m32c_addr_encodings
expr_stmt|;
name|enc
operator|=
operator|(
operator|(
name|einsn
index|[
literal|0
index|]
operator|&
literal|0x70
operator|)
operator|>>
literal|2
operator|)
operator||
operator|(
operator|(
name|einsn
index|[
literal|1
index|]
operator|&
literal|0x30
operator|)
operator|>>
literal|4
operator|)
expr_stmt|;
name|e
operator|=
operator|&
name|enctbl
index|[
name|enc
index|]
expr_stmt|;
if|if
condition|(
name|srel
operator|->
name|r_offset
operator|==
name|irel
operator|->
name|r_offset
operator|+
name|posn
operator|&&
name|e
operator|->
name|new_encoding
operator|!=
name|enc
operator|&&
name|symval
operator|<=
name|e
operator|->
name|max_disp
condition|)
block|{
name|einsn
index|[
literal|0
index|]
operator|&=
literal|0x8f
expr_stmt|;
name|einsn
index|[
literal|0
index|]
operator||=
operator|(
name|e
operator|->
name|new_encoding
operator|&
literal|0x1c
operator|)
operator|<<
literal|2
expr_stmt|;
name|einsn
index|[
literal|1
index|]
operator|&=
literal|0xcf
expr_stmt|;
name|einsn
index|[
literal|1
index|]
operator||=
operator|(
name|e
operator|->
name|new_encoding
operator|&
literal|0x03
operator|)
operator|<<
literal|4
expr_stmt|;
name|gap_size
operator|=
name|e
operator|->
name|bytes
operator|-
name|enctbl
index|[
name|e
operator|->
name|new_encoding
index|]
operator|.
name|bytes
expr_stmt|;
name|gap
operator|=
name|insn
operator|+
name|posn
operator|+
name|enctbl
index|[
name|e
operator|->
name|new_encoding
index|]
operator|.
name|bytes
expr_stmt|;
name|new_type
operator|=
name|bytes_to_reloc
index|[
name|enctbl
index|[
name|e
operator|->
name|new_encoding
index|]
operator|.
name|bytes
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|relax_relocs
operator|==
literal|2
condition|)
name|srel
operator|++
expr_stmt|;
name|posn
operator|+=
name|e
operator|->
name|bytes
expr_stmt|;
goto|goto
name|try_1addr_32
goto|;
case|case
name|R_M32C_RL_1ADDR
case|:
comment|/* xxxx DDDx DDxx xxxx [disp] */
name|einsn
operator|=
name|insn
expr_stmt|;
name|posn
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|einsn
index|[
literal|0
index|]
operator|==
literal|1
condition|)
block|{
comment|/* prefix; remove it as far as the RL reloc is concerned.  */
name|einsn
operator|++
expr_stmt|;
name|posn
operator|++
expr_stmt|;
block|}
name|enctbl
operator|=
name|m32c_addr_encodings
expr_stmt|;
name|try_1addr_32
label|:
comment|/* srel, posn, and enc must be set here.  */
name|symval
operator|=
name|OFFSET_FOR_RELOC
argument_list|(
name|srel
argument_list|)
expr_stmt|;
name|enc
operator|=
operator|(
operator|(
name|einsn
index|[
literal|0
index|]
operator|&
literal|0x0e
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|einsn
index|[
literal|1
index|]
operator|&
literal|0xc0
operator|)
operator|>>
literal|6
operator|)
expr_stmt|;
name|e
operator|=
operator|&
name|enctbl
index|[
name|enc
index|]
expr_stmt|;
if|if
condition|(
name|srel
operator|->
name|r_offset
operator|==
name|irel
operator|->
name|r_offset
operator|+
name|posn
operator|&&
name|e
operator|->
name|new_encoding
operator|!=
name|enc
operator|&&
name|symval
operator|<=
name|e
operator|->
name|max_disp
condition|)
block|{
name|einsn
index|[
literal|0
index|]
operator|&=
literal|0xf1
expr_stmt|;
name|einsn
index|[
literal|0
index|]
operator||=
operator|(
name|e
operator|->
name|new_encoding
operator|&
literal|0x1c
operator|)
operator|>>
literal|1
expr_stmt|;
name|einsn
index|[
literal|1
index|]
operator|&=
literal|0x3f
expr_stmt|;
name|einsn
index|[
literal|1
index|]
operator||=
operator|(
name|e
operator|->
name|new_encoding
operator|&
literal|0x03
operator|)
operator|<<
literal|6
expr_stmt|;
name|gap_size
operator|=
name|e
operator|->
name|bytes
operator|-
name|enctbl
index|[
name|e
operator|->
name|new_encoding
index|]
operator|.
name|bytes
expr_stmt|;
name|gap
operator|=
name|insn
operator|+
name|posn
operator|+
name|enctbl
index|[
name|e
operator|->
name|new_encoding
index|]
operator|.
name|bytes
expr_stmt|;
name|new_type
operator|=
name|bytes_to_reloc
index|[
name|enctbl
index|[
name|e
operator|->
name|new_encoding
index|]
operator|.
name|bytes
index|]
expr_stmt|;
break|break;
block|}
break|break;
block|}
comment|/* Ends switch (reloc type) for m32c.  */
block|}
if|if
condition|(
name|gap_size
operator|==
literal|0
condition|)
continue|continue;
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
name|srel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|srel
operator|->
name|r_info
argument_list|)
argument_list|,
name|new_type
argument_list|)
expr_stmt|;
comment|/* Note that we've changed the relocs, section contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|free_relocs
operator|=
name|NULL
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|free_contents
operator|=
name|NULL
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|intsyms
expr_stmt|;
name|free_intsyms
operator|=
name|NULL
expr_stmt|;
name|bytes_saved
operator|+=
name|gap_size
expr_stmt|;
if|if
condition|(
operator|!
name|m32c_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|gap
operator|-
name|contents
argument_list|,
name|gap_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* next relocation */
if|if
condition|(
name|free_relocs
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|free_relocs
argument_list|)
expr_stmt|;
name|free_relocs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|free_contents
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|free_contents
argument_list|)
expr_stmt|;
comment|/* Cache the section contents for elf_link_input_bfd.  */
else|else
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|free_contents
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|shndx_buf
operator|!=
name|NULL
condition|)
block|{
name|shndx_hdr
operator|->
name|contents
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|shndx_buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|free_intsyms
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|free_intsyms
argument_list|)
expr_stmt|;
comment|/* Cache the symbols for elf_link_input_bfd.  */
else|else
block|{
name|symtab_hdr
operator|->
name|contents
operator|=
name|NULL
comment|/* (unsigned char *) intsyms*/
expr_stmt|;
block|}
name|free_intsyms
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|free_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|shndx_buf
operator|!=
name|NULL
condition|)
block|{
name|shndx_hdr
operator|->
name|contents
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|shndx_buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|free_intsyms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_intsyms
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Delete some bytes from a section while relaxing.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|m32c_elf_relax_delete_bytes
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|shndx_hdr
decl_stmt|;
name|int
name|sec_shndx
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelend
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelalign
decl_stmt|;
name|bfd_vma
name|toaddr
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymend
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|intsyms
decl_stmt|;
name|Elf_External_Sym_Shndx
modifier|*
name|shndx_buf
decl_stmt|;
name|Elf_External_Sym_Shndx
modifier|*
name|shndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|end_hashes
decl_stmt|;
name|unsigned
name|int
name|symcount
decl_stmt|;
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
comment|/* The deletion must stop at the next ALIGN reloc for an aligment      power larger than the number of bytes we are deleting.  */
name|irelalign
operator|=
name|NULL
expr_stmt|;
name|toaddr
operator|=
name|sec
operator|->
name|size
expr_stmt|;
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
expr_stmt|;
name|irelend
operator|=
name|irel
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
comment|/* Actually delete the bytes.  */
name|memmove
argument_list|(
name|contents
operator|+
name|addr
argument_list|,
name|contents
operator|+
name|addr
operator|+
name|count
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|toaddr
operator|-
name|addr
operator|-
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|sec
operator|->
name|size
operator|-=
name|count
expr_stmt|;
comment|/* Adjust all the relocs.  */
for|for
control|(
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
comment|/* Get the new reloc address.  */
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|>
name|addr
operator|&&
name|irel
operator|->
name|r_offset
operator|<
name|toaddr
condition|)
name|irel
operator|->
name|r_offset
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
name|R_M32C_RL_JUMP
operator|&&
name|irel
operator|->
name|r_addend
operator|==
literal|0x10
comment|/* one byte insn, no relocs */
operator|&&
name|irel
operator|->
name|r_offset
operator|+
literal|1
operator|<
name|addr
operator|&&
name|irel
operator|->
name|r_offset
operator|+
literal|7
operator|>
name|addr
condition|)
block|{
name|bfd_vma
name|disp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|insn
init|=
operator|&
name|contents
index|[
name|irel
operator|->
name|r_offset
index|]
decl_stmt|;
name|disp
operator|=
operator|*
name|insn
expr_stmt|;
comment|/* This is a JMP.S, which we have to manually update. */
if|if
condition|(
name|elf32_m32c_machine
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_mach_m16c
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|insn
operator|&
literal|0xf8
operator|)
operator|!=
literal|0x60
condition|)
continue|continue;
name|disp
operator|=
operator|(
name|disp
operator|&
literal|7
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|*
name|insn
operator|&
literal|0xce
operator|)
operator|!=
literal|0x4a
condition|)
continue|continue;
name|disp
operator|=
operator|(
operator|(
name|disp
operator|&
literal|0x30
operator|)
operator|>>
literal|3
operator|)
operator||
operator|(
name|disp
operator|&
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|irel
operator|->
name|r_offset
operator|+
name|disp
operator|+
literal|2
operator|>=
name|addr
operator|+
name|count
condition|)
block|{
name|disp
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|elf32_m32c_machine
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_mach_m16c
condition|)
block|{
operator|*
name|insn
operator|=
operator|(
operator|*
name|insn
operator|&
literal|0xf8
operator|)
operator||
name|disp
expr_stmt|;
block|}
else|else
block|{
operator|*
name|insn
operator|=
operator|(
operator|*
name|insn
operator|&
literal|0xce
operator|)
operator||
operator|(
operator|(
name|disp
operator|&
literal|6
operator|)
operator|<<
literal|3
operator|)
operator||
operator|(
name|disp
operator|&
literal|1
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Adjust the local symbols defined in this section.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|intsyms
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
name|isym
operator|=
name|intsyms
expr_stmt|;
name|isymend
operator|=
name|isym
operator|+
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|sec_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|shndx_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_shndx_hdr
expr_stmt|;
name|shndx_buf
operator|=
operator|(
name|Elf_External_Sym_Shndx
operator|*
operator|)
name|shndx_hdr
operator|->
name|contents
expr_stmt|;
name|shndx
operator|=
name|shndx_buf
expr_stmt|;
for|for
control|(
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
operator|,
name|shndx
operator|=
operator|(
name|shndx
condition|?
name|shndx
operator|+
literal|1
else|:
name|NULL
operator|)
control|)
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|isym
operator|->
name|st_shndx
operator|==
name|sec_shndx
operator|&&
name|isym
operator|->
name|st_value
operator|>
name|addr
operator|&&
name|isym
operator|->
name|st_value
operator|<
name|toaddr
condition|)
block|{
name|isym
operator|->
name|st_value
operator|-=
name|count
expr_stmt|;
block|}
block|}
comment|/* Now adjust the global symbols defined in this section.  */
name|symcount
operator|=
operator|(
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|//  sym_hashes += symtab_hdr->sh_info;
name|end_hashes
operator|=
name|sym_hashes
operator|+
name|symcount
expr_stmt|;
for|for
control|(
init|;
name|sym_hashes
operator|<
name|end_hashes
condition|;
name|sym_hashes
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|sym_hash
init|=
operator|*
name|sym_hashes
decl_stmt|;
if|if
condition|(
name|sym_hash
operator|&&
operator|(
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|sec
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|>
name|addr
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|<
name|toaddr
condition|)
block|{
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|-=
name|count
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_m32c
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_M32C
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1000
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_m32c_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-m32c"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_m32c_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-m32c"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|NULL
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|m32c_info_to_howto_rela
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|m32c_elf_object_p
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|m32c_elf_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|m32c_elf_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|m32c_elf_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|m32c_elf_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|m32c_elf_object_p
end_define

begin_define
define|#
directive|define
name|elf_symbol_leading_char
value|('_')
end_define

begin_define
define|#
directive|define
name|elf_backend_always_size_sections
define|\
value|m32c_elf_always_size_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
define|\
value|m32c_elf_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|m32c_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_relax_section
value|m32c_elf_relax_section
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_set_private_flags
value|m32c_elf_set_private_flags
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_merge_private_bfd_data
value|m32c_elf_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_print_private_bfd_data
value|m32c_elf_print_private_bfd_data
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

