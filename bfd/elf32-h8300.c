begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for Renesas H8/300 ELF binaries.    Copyright 1993, 1995, 1998, 1999, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/h8.h"
end_include

begin_function_decl
specifier|static
name|reloc_howto_type
modifier|*
name|elf32_h8_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf32_h8_info_to_howto
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf32_h8_info_to_howto_rel
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|elf32_h8_mach
parameter_list|(
name|flagword
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf32_h8_final_write_processing
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|elf32_h8_object_p
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|elf32_h8_merge_private_bfd_data
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|elf32_h8_relax_section
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|bfd_boolean
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|elf32_h8_relax_delete_bytes
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|elf32_h8_symbol_address_p
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_byte
modifier|*
name|elf32_h8_get_relocated_section_contents
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|struct
name|bfd_link_order
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|,
name|asymbol
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|asection
modifier|*
name|elf32_h8_gc_mark_hook
parameter_list|(
name|asection
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
parameter_list|,
name|Elf_Internal_Sym
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|elf32_h8_gc_sweep_hook
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|elf32_h8_final_link_relocate
parameter_list|(
name|unsigned
name|long
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|bfd_vma
parameter_list|,
name|bfd_vma
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|elf32_h8_relocate_section
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|Elf_Internal_Sym
modifier|*
parameter_list|,
name|asection
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|special
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|asymbol
modifier|*
parameter_list|,
name|PTR
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This does not include any relocation information, but should be    good enough for GDB or objdump to read the file.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|h8_elf_howto_table
index|[]
init|=
block|{
define|#
directive|define
name|R_H8_NONE_X
value|0
name|HOWTO
argument_list|(
name|R_H8_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|special
argument_list|,
comment|/* special_function */
literal|"R_H8_NONE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
define|#
directive|define
name|R_H8_DIR32_X
value|(R_H8_NONE_X + 1)
name|HOWTO
argument_list|(
name|R_H8_DIR32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|special
argument_list|,
comment|/* special_function */
literal|"R_H8_DIR32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
define|#
directive|define
name|R_H8_DIR16_X
value|(R_H8_DIR32_X + 1)
name|HOWTO
argument_list|(
name|R_H8_DIR16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|special
argument_list|,
comment|/* special_function */
literal|"R_H8_DIR16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
define|#
directive|define
name|R_H8_DIR8_X
value|(R_H8_DIR16_X + 1)
name|HOWTO
argument_list|(
name|R_H8_DIR8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|special
argument_list|,
comment|/* special_function */
literal|"R_H8_DIR8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x000000ff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
define|#
directive|define
name|R_H8_DIR16A8_X
value|(R_H8_DIR8_X + 1)
name|HOWTO
argument_list|(
name|R_H8_DIR16A8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|special
argument_list|,
comment|/* special_function */
literal|"R_H8_DIR16A8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
define|#
directive|define
name|R_H8_DIR16R8_X
value|(R_H8_DIR16A8_X + 1)
name|HOWTO
argument_list|(
name|R_H8_DIR16R8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|special
argument_list|,
comment|/* special_function */
literal|"R_H8_DIR16R8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0x0000ffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
define|#
directive|define
name|R_H8_DIR24A8_X
value|(R_H8_DIR16R8_X + 1)
name|HOWTO
argument_list|(
name|R_H8_DIR24A8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|24
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|special
argument_list|,
comment|/* special_function */
literal|"R_H8_DIR24A8"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xff000000
argument_list|,
comment|/* src_mask */
literal|0x00ffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
define|#
directive|define
name|R_H8_DIR24R8_X
value|(R_H8_DIR24A8_X + 1)
name|HOWTO
argument_list|(
name|R_H8_DIR24R8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|24
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|special
argument_list|,
comment|/* special_function */
literal|"R_H8_DIR24R8"
argument_list|,
comment|/* name */
name|TRUE
argument_list|,
comment|/* partial_inplace */
literal|0xff000000
argument_list|,
comment|/* src_mask */
literal|0x00ffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
define|#
directive|define
name|R_H8_DIR32A16_X
value|(R_H8_DIR24R8_X + 1)
name|HOWTO
argument_list|(
name|R_H8_DIR32A16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|special
argument_list|,
comment|/* special_function */
literal|"R_H8_DIR32A16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
define|#
directive|define
name|R_H8_PCREL16_X
value|(R_H8_DIR32A16_X + 1)
name|HOWTO
argument_list|(
name|R_H8_PCREL16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|special
argument_list|,
comment|/* special_function */
literal|"R_H8_PCREL16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
define|#
directive|define
name|R_H8_PCREL8_X
value|(R_H8_PCREL16_X + 1)
name|HOWTO
argument_list|(
name|R_H8_PCREL8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|special
argument_list|,
comment|/* special_function */
literal|"R_H8_PCREL8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xff
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This structure is used to map BFD reloc codes to H8 ELF relocs.  */
end_comment

begin_struct
struct|struct
name|elf_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_val
decl_stmt|;
name|unsigned
name|char
name|howto_index
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* An array mapping BFD reloc codes to H8 ELF relocs.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elf_reloc_map
name|h8_reloc_map
index|[]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_H8_NONE_X
block|}
block|,
block|{
name|BFD_RELOC_32
block|,
name|R_H8_DIR32_X
block|}
block|,
block|{
name|BFD_RELOC_16
block|,
name|R_H8_DIR16_X
block|}
block|,
block|{
name|BFD_RELOC_8
block|,
name|R_H8_DIR8_X
block|}
block|,
block|{
name|BFD_RELOC_H8_DIR16A8
block|,
name|R_H8_DIR16A8_X
block|}
block|,
block|{
name|BFD_RELOC_H8_DIR16R8
block|,
name|R_H8_DIR16R8_X
block|}
block|,
block|{
name|BFD_RELOC_H8_DIR24A8
block|,
name|R_H8_DIR24A8_X
block|}
block|,
block|{
name|BFD_RELOC_H8_DIR24R8
block|,
name|R_H8_DIR24R8_X
block|}
block|,
block|{
name|BFD_RELOC_H8_DIR32A16
block|,
name|R_H8_DIR32A16_X
block|}
block|,
block|{
name|BFD_RELOC_16_PCREL
block|,
name|R_H8_PCREL16_X
block|}
block|,
block|{
name|BFD_RELOC_8_PCREL
block|,
name|R_H8_PCREL8_X
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|elf32_h8_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|h8_reloc_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|elf_reloc_map
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|h8_reloc_map
index|[
name|i
index|]
operator|.
name|bfd_reloc_val
operator|==
name|code
condition|)
return|return
operator|&
name|h8_elf_howto_table
index|[
operator|(
name|int
operator|)
name|h8_reloc_map
index|[
name|i
index|]
operator|.
name|howto_index
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf32_h8_info_to_howto
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|bfd_reloc
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|elf_reloc
parameter_list|)
block|{
name|unsigned
name|int
name|r
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|r
operator|=
name|ELF32_R_TYPE
argument_list|(
name|elf_reloc
operator|->
name|r_info
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|h8_elf_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|reloc_howto_type
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|h8_elf_howto_table
index|[
name|i
index|]
operator|.
name|type
operator|==
name|r
condition|)
block|{
name|bfd_reloc
operator|->
name|howto
operator|=
operator|&
name|h8_elf_howto_table
index|[
name|i
index|]
expr_stmt|;
return|return;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf32_h8_info_to_howto_rel
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|bfd_reloc
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|elf_reloc
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|int
name|r
decl_stmt|;
name|abort
argument_list|()
expr_stmt|;
name|r
operator|=
name|ELF32_R_TYPE
argument_list|(
name|elf_reloc
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|bfd_reloc
operator|->
name|howto
operator|=
operator|&
name|h8_elf_howto_table
index|[
name|r
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Special handling for H8/300 relocs.    We only come here for pcrel stuff and return normally if not an -r link.    When doing -r, we can't do any arithmetic for the pcrel stuff, because    we support relaxing on the H8/300 series chips.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|special
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|reloc_entry
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asymbol
modifier|*
name|symbol
name|ATTRIBUTE_UNUSED
parameter_list|,
name|PTR
name|data
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|input_section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|char
modifier|*
modifier|*
name|error_message
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|output_bfd
operator|==
operator|(
name|bfd
operator|*
operator|)
name|NULL
condition|)
return|return
name|bfd_reloc_continue
return|;
comment|/* Adjust the reloc address to that in the output section.  */
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Perform a relocation as part of a final link.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|elf32_h8_final_link_relocate
parameter_list|(
name|unsigned
name|long
name|r_type
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|input_section
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|bfd_vma
name|value
parameter_list|,
name|bfd_vma
name|addend
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sym_sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|is_local
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|hit_data
init|=
name|contents
operator|+
name|offset
decl_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_H8_NONE
case|:
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_H8_DIR32
case|:
case|case
name|R_H8_DIR32A16
case|:
case|case
name|R_H8_DIR24A8
case|:
name|value
operator|+=
name|addend
expr_stmt|;
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_H8_DIR16
case|:
case|case
name|R_H8_DIR16A8
case|:
case|case
name|R_H8_DIR16R8
case|:
name|value
operator|+=
name|addend
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
comment|/* AKA R_RELBYTE */
case|case
name|R_H8_DIR8
case|:
name|value
operator|+=
name|addend
expr_stmt|;
name|bfd_put_8
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_H8_DIR24R8
case|:
name|value
operator|+=
name|addend
expr_stmt|;
comment|/* HIT_DATA is the address for the first byte for the relocated 	 value.  Subtract 1 so that we can manipulate the data in 32-bit 	 hunks.  */
name|hit_data
operator|--
expr_stmt|;
comment|/* Clear out the top byte in value.  */
name|value
operator|&=
literal|0xffffff
expr_stmt|;
comment|/* Retrieve the type byte for value from the section contents.  */
name|value
operator||=
operator|(
name|bfd_get_32
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|&
literal|0xff000000
operator|)
expr_stmt|;
comment|/* Now scribble it out in one 32-bit hunk.  */
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_H8_PCREL16
case|:
name|value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|offset
expr_stmt|;
name|value
operator|+=
name|addend
expr_stmt|;
comment|/* The value is relative to the start of the instruction, 	 not the relocation offset.  Subtract 2 to account for 	 this minor issue.  */
name|value
operator|-=
literal|2
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
case|case
name|R_H8_PCREL8
case|:
name|value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|offset
expr_stmt|;
name|value
operator|+=
name|addend
expr_stmt|;
comment|/* The value is relative to the start of the instruction, 	 not the relocation offset.  Subtract 1 to account for 	 this minor issue.  */
name|value
operator|-=
literal|1
expr_stmt|;
name|bfd_put_8
argument_list|(
name|input_bfd
argument_list|,
name|value
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
default|default:
return|return
name|bfd_reloc_notsupported
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Relocate an H8 ELF section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_h8_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
comment|/* This is a final link.  */
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_boolean
name|unresolved_reloc
decl_stmt|,
name|warned
decl_stmt|;
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|elf32_h8_final_link_relocate
argument_list|(
name|r_type
argument_list|,
name|input_bfd
argument_list|,
name|output_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|info
argument_list|,
name|sec
argument_list|,
name|h
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
decl_stmt|;
name|arelent
name|bfd_reloc
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|elf32_h8_info_to_howto
argument_list|(
name|input_bfd
argument_list|,
operator|&
name|bfd_reloc
argument_list|,
name|rel
argument_list|)
expr_stmt|;
name|howto
operator|=
name|bfd_reloc
operator|.
name|howto
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|bfd_reloc_undefined
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: out of range error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
name|bfd_reloc_notsupported
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unsupported relocation error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
name|bfd_reloc_dangerous
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: dangerous error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
default|default:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unknown error"
argument_list|)
expr_stmt|;
comment|/* fall through */
name|common_error
label|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Object files encode the specific H8 model they were compiled    for in the ELF flags field.     Examine that field and return the proper BFD machine type for    the object file.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|elf32_h8_mach
parameter_list|(
name|flagword
name|flags
parameter_list|)
block|{
switch|switch
condition|(
name|flags
operator|&
name|EF_H8_MACH
condition|)
block|{
case|case
name|E_H8_MACH_H8300
case|:
default|default:
return|return
name|bfd_mach_h8300
return|;
case|case
name|E_H8_MACH_H8300H
case|:
return|return
name|bfd_mach_h8300h
return|;
case|case
name|E_H8_MACH_H8300S
case|:
return|return
name|bfd_mach_h8300s
return|;
case|case
name|E_H8_MACH_H8300HN
case|:
return|return
name|bfd_mach_h8300hn
return|;
case|case
name|E_H8_MACH_H8300SN
case|:
return|return
name|bfd_mach_h8300sn
return|;
case|case
name|E_H8_MACH_H8300SX
case|:
return|return
name|bfd_mach_h8300sx
return|;
case|case
name|E_H8_MACH_H8300SXN
case|:
return|return
name|bfd_mach_h8300sxn
return|;
block|}
block|}
end_function

begin_comment
comment|/* The final processing done just before writing out a H8 ELF object    file.  We use this opportunity to encode the BFD machine type    into the flags field in the object file.  */
end_comment

begin_function
specifier|static
name|void
name|elf32_h8_final_write_processing
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|bfd_boolean
name|linker
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|long
name|val
decl_stmt|;
switch|switch
condition|(
name|bfd_get_mach
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
default|default:
case|case
name|bfd_mach_h8300
case|:
name|val
operator|=
name|E_H8_MACH_H8300
expr_stmt|;
break|break;
case|case
name|bfd_mach_h8300h
case|:
name|val
operator|=
name|E_H8_MACH_H8300H
expr_stmt|;
break|break;
case|case
name|bfd_mach_h8300s
case|:
name|val
operator|=
name|E_H8_MACH_H8300S
expr_stmt|;
break|break;
case|case
name|bfd_mach_h8300hn
case|:
name|val
operator|=
name|E_H8_MACH_H8300HN
expr_stmt|;
break|break;
case|case
name|bfd_mach_h8300sn
case|:
name|val
operator|=
name|E_H8_MACH_H8300SN
expr_stmt|;
break|break;
case|case
name|bfd_mach_h8300sx
case|:
name|val
operator|=
name|E_H8_MACH_H8300SX
expr_stmt|;
break|break;
case|case
name|bfd_mach_h8300sxn
case|:
name|val
operator|=
name|E_H8_MACH_H8300SXN
expr_stmt|;
break|break;
block|}
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator|&=
operator|~
operator|(
name|EF_H8_MACH
operator|)
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
operator||=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if ABFD represents a valid H8 ELF object file; also    record the encoded machine type found in the ELF flags.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_h8_object_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_h8300
argument_list|,
name|elf32_h8_mach
argument_list|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Merge backend specific data from an object file to the output    object file when linking.  The only data we need to copy at this    time is the architecture/machine information.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_h8_merge_private_bfd_data
parameter_list|(
name|bfd
modifier|*
name|ibfd
parameter_list|,
name|bfd
modifier|*
name|obfd
parameter_list|)
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|bfd_get_arch
argument_list|(
name|obfd
argument_list|)
operator|==
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
operator|&&
name|bfd_get_mach
argument_list|(
name|obfd
argument_list|)
operator|<
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_arch_mach
argument_list|(
name|obfd
argument_list|,
name|bfd_get_arch
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_get_mach
argument_list|(
name|ibfd
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This function handles relaxing for the H8..     There are a few relaxing opportunities available on the H8:       jmp/jsr:24    ->    bra/bsr:8		2 bytes      The jmp may be completely eliminated if the previous insn is a      conditional branch to the insn after the jump.  In that case      we invert the branch and delete the jump and save 4 bytes.       bCC:16          ->    bCC:8                  2 bytes      bsr:16          ->    bsr:8                  2 bytes       bset:16	     ->    bset:8                 2 bytes      bset:24/32	     ->    bset:8                 4 bytes      (also applicable to other bit manipulation instructions)       mov.b:16	     ->    mov.b:8                2 bytes      mov.b:24/32     ->    mov.b:8                4 bytes       bset:24/32	     ->    bset:16                2 bytes      (also applicable to other bit manipulation instructions)       mov.[bwl]:24/32 ->    mov.[bwl]:16           2 bytes */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_h8_relax_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|bfd_boolean
modifier|*
name|again
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
specifier|static
name|asection
modifier|*
name|last_input_section
init|=
name|NULL
decl_stmt|;
specifier|static
name|Elf_Internal_Rela
modifier|*
name|last_reloc
init|=
name|NULL
decl_stmt|;
comment|/* Assume nothing changes.  */
operator|*
name|again
operator|=
name|FALSE
expr_stmt|;
comment|/* We don't have to do anything for a relocatable link, if      this section does not have relocs, or if this is not a      code section.  */
if|if
condition|(
name|link_info
operator|->
name|relocatable
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|sec
operator|->
name|reloc_count
operator|==
literal|0
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* If this is the first time we have been called for this section,      initialize the cooked size.  */
if|if
condition|(
name|sec
operator|->
name|_cooked_size
operator|==
literal|0
condition|)
name|sec
operator|->
name|_cooked_size
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
comment|/* Get a copy of the native relocations.  */
name|internal_relocs
operator|=
operator|(
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|sec
operator|!=
name|last_input_section
condition|)
name|last_reloc
operator|=
name|NULL
expr_stmt|;
name|last_input_section
operator|=
name|sec
expr_stmt|;
comment|/* Walk through the relocs looking for relaxing opportunities.  */
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|symval
decl_stmt|;
comment|/* Keep track of the previous reloc so that we can delete 	 some long jumps created by the compiler.  */
if|if
condition|(
name|irel
operator|!=
name|internal_relocs
condition|)
name|last_reloc
operator|=
name|irel
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_H8_DIR24R8
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_H8_PCREL16
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_H8_DIR16A8
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_H8_DIR24A8
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_H8_DIR32A16
condition|)
continue|continue;
comment|/* Get the section contents if we haven't done so already.  */
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
block|{
comment|/* Get cached copy if it exists.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
comment|/* Go get them off disk.  */
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* Read this BFD's local symbols if we haven't done so already.  */
if|if
condition|(
name|isymbuf
operator|==
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Get the value of the symbol referred to by the reloc.  */
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* A local symbol.  */
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|isym
operator|=
name|isymbuf
operator|+
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|sym_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|symval
operator|=
name|isym
operator|->
name|st_value
expr_stmt|;
comment|/* If the reloc is absolute, it will not have 	     a symbol or section associated with it.  */
if|if
condition|(
name|sym_sec
condition|)
name|symval
operator|+=
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sym_sec
operator|->
name|output_offset
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|indx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* An external symbol.  */
name|indx
operator|=
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
block|{
comment|/* This appears to be a reference to an undefined                  symbol.  Just ignore it--it will be caught by the                  regular reloc processing.  */
continue|continue;
block|}
name|symval
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
comment|/* For simplicity of coding, we are going to modify the section 	 contents, the section relocs, and the BFD symbol table.  We 	 must tell the rest of the code not to free up this 	 information.  It would be possible to instead create a table 	 of changes which have to be made, as is done in coff-mips.c; 	 that would be more work, but would require less memory when 	 the linker is run.  */
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
condition|)
block|{
comment|/* Try to turn a 24-bit absolute branch/call into an 8-bit 	   pc-relative branch/call.  */
case|case
name|R_H8_DIR24R8
case|:
block|{
name|bfd_vma
name|value
init|=
name|symval
operator|+
name|irel
operator|->
name|r_addend
decl_stmt|;
name|bfd_vma
name|dot
decl_stmt|,
name|gap
decl_stmt|;
comment|/* Get the address of this instruction.  */
name|dot
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Compute the distance from this insn to the branch target.  */
name|gap
operator|=
name|value
operator|-
name|dot
expr_stmt|;
comment|/* If the distance is within -126..+130 inclusive, then we can 	       relax this jump.  +130 is valid since the target will move 	       two bytes closer if we do relax this branch.  */
if|if
condition|(
operator|(
name|int
operator|)
name|gap
operator|>=
operator|-
literal|126
operator|&&
operator|(
name|int
operator|)
name|gap
operator|<=
literal|130
condition|)
block|{
name|unsigned
name|char
name|code
decl_stmt|;
comment|/* Note that we've changed the relocs, section contents, 		   etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Get the instruction code being relaxed.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* If the previous instruction conditionally jumped around 		   this instruction, we may be able to reverse the condition 		   and redirect the previous instruction to the target of 		   this instruction.  		   Such sequences are used by the compiler to deal with 		   long conditional branches.  		   Only perform this optimisation for jumps (code 0x5a) not 		   subroutine calls, as otherwise it could transform:  		   	             mov.w   r0,r0 		   	             beq     .L1 		         	     jsr     @_bar 		              .L1:   rts 		              _bar:  rts 		   into: 		   	             mov.w   r0,r0 			             bne     _bar 			             rts 			      _bar:  rts  		   which changes the call (jsr) into a branch (bne).  */
if|if
condition|(
name|code
operator|==
literal|0x5a
operator|&&
operator|(
name|int
operator|)
name|gap
operator|<=
literal|130
operator|&&
operator|(
name|int
operator|)
name|gap
operator|>=
operator|-
literal|128
operator|&&
name|last_reloc
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|last_reloc
operator|->
name|r_info
argument_list|)
operator|==
name|R_H8_PCREL8
operator|&&
name|ELF32_R_SYM
argument_list|(
name|last_reloc
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|bfd_vma
name|last_value
decl_stmt|;
name|asection
modifier|*
name|last_sym_sec
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|last_sym
decl_stmt|;
comment|/* We will need to examine the symbol used by the 		       previous relocation.  */
name|last_sym
operator|=
name|isymbuf
operator|+
name|ELF32_R_SYM
argument_list|(
name|last_reloc
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|last_sym_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|last_sym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|last_value
operator|=
operator|(
name|last_sym
operator|->
name|st_value
operator|+
name|last_sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|last_sym_sec
operator|->
name|output_offset
operator|)
expr_stmt|;
comment|/* Verify that the previous relocation was for a 		       branch around this instruction and that no symbol 		       exists at the current location.  */
if|if
condition|(
name|last_value
operator|==
name|dot
operator|+
literal|4
operator|&&
name|last_reloc
operator|->
name|r_offset
operator|+
literal|2
operator|==
name|irel
operator|->
name|r_offset
operator|&&
operator|!
name|elf32_h8_symbol_address_p
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|dot
argument_list|)
condition|)
block|{
comment|/* We can eliminate this jump.  Twiddle the 			   previous relocation as necessary.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|ELF32_R_TYPE
argument_list|(
name|R_H8_NONE
argument_list|)
argument_list|)
expr_stmt|;
name|last_reloc
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|ELF32_R_TYPE
argument_list|(
name|R_H8_PCREL8
argument_list|)
argument_list|)
expr_stmt|;
name|last_reloc
operator|->
name|r_addend
operator|=
name|irel
operator|->
name|r_addend
expr_stmt|;
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|last_reloc
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
name|code
operator|^=
literal|1
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|,
name|contents
operator|+
name|last_reloc
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Delete four bytes of data.  */
if|if
condition|(
operator|!
name|elf32_h8_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|,
literal|4
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|code
operator|==
literal|0x5e
condition|)
comment|/* This is jsr.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x55
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|0x5a
condition|)
comment|/* This is jmp.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x40
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_H8_PCREL8
argument_list|)
expr_stmt|;
comment|/* Delete two bytes of data.  */
if|if
condition|(
operator|!
name|elf32_h8_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 		   Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
block|}
comment|/* Try to turn a 16-bit pc-relative branch into a 8-bit pc-relative 	   branch.  */
case|case
name|R_H8_PCREL16
case|:
block|{
name|bfd_vma
name|value
init|=
name|symval
operator|+
name|irel
operator|->
name|r_addend
decl_stmt|;
name|bfd_vma
name|dot
decl_stmt|;
name|bfd_vma
name|gap
decl_stmt|;
comment|/* Get the address of this instruction.  */
name|dot
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
operator|)
expr_stmt|;
name|gap
operator|=
name|value
operator|-
name|dot
expr_stmt|;
comment|/* If the distance is within -126..+130 inclusive, then we can 	       relax this jump.  +130 is valid since the target will move 	       two bytes closer if we do relax this branch.  */
if|if
condition|(
operator|(
name|int
operator|)
name|gap
operator|>=
operator|-
literal|126
operator|&&
operator|(
name|int
operator|)
name|gap
operator|<=
literal|130
condition|)
block|{
name|unsigned
name|char
name|code
decl_stmt|;
comment|/* Note that we've changed the relocs, section contents, 		   etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Get the opcode.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|0x58
condition|)
block|{
comment|/* bCC:16 -> bCC:8 */
comment|/* Get the second byte of the original insn, which 		       contains the condition code.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Compute the fisrt byte of the relaxed 		       instruction.  The original sequence 0x58 0xX0 		       is relaxed to 0x4X, where X represents the 		       condition code.  */
name|code
operator|&=
literal|0xf0
expr_stmt|;
name|code
operator|>>=
literal|4
expr_stmt|;
name|code
operator||=
literal|0x40
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
literal|0x5c
condition|)
comment|/* This is bsr.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x55
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_H8_PCREL8
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_offset
operator|--
expr_stmt|;
comment|/* Delete two bytes of data.  */
if|if
condition|(
operator|!
name|elf32_h8_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 		   Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
block|}
comment|/* This is a 16-bit absolute address in one of the following 	   instructions:  	     "band", "bclr", "biand", "bild", "bior", "bist", "bixor", 	     "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", and 	     "mov.b"  	   We may relax this into an 8-bit absolute address if it's in 	   the right range.  */
case|case
name|R_H8_DIR16A8
case|:
block|{
name|bfd_vma
name|value
decl_stmt|;
name|value
operator|=
name|bfd_h8300_pad_address
argument_list|(
name|abfd
argument_list|,
name|symval
operator|+
name|irel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|>=
literal|0xffffff00u
condition|)
block|{
name|unsigned
name|char
name|code
decl_stmt|;
name|unsigned
name|char
name|temp_code
decl_stmt|;
comment|/* Note that we've changed the relocs, section contents, 		   etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Get the opcode.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* All instructions with R_H8_DIR16A8 start with 		   0x6a.  */
if|if
condition|(
name|code
operator|!=
literal|0x6a
condition|)
name|abort
argument_list|()
expr_stmt|;
name|temp_code
operator|=
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* If this is a mov.b instruction, clear the lower 		   nibble, which contains the source/destination 		   register number.  */
if|if
condition|(
operator|(
name|temp_code
operator|&
literal|0x10
operator|)
operator|!=
literal|0x10
condition|)
name|temp_code
operator|&=
literal|0xf0
expr_stmt|;
switch|switch
condition|(
name|temp_code
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* This is mov.b @aa:16,Rd.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|code
operator|&
literal|0xf
operator|)
operator||
literal|0x20
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x80
case|:
comment|/* This is mov.b Rs,@aa:16.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|code
operator|&
literal|0xf
operator|)
operator||
literal|0x30
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x18
case|:
comment|/* This is a bit-maniputation instruction that 		       stores one bit into memory, one of "bclr", 		       "bist", "bnot", "bset", and "bst".  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x7f
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
comment|/* This is a bit-maniputation instruction that 		       loads one bit from memory, one of "band", 		       "biand", "bild", "bior", "bixor", "bld", "bor", 		       "btst", and "bxor".  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x7e
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_H8_DIR8
argument_list|)
expr_stmt|;
comment|/* Move the relocation.  */
name|irel
operator|->
name|r_offset
operator|--
expr_stmt|;
comment|/* Delete two bytes of data.  */
if|if
condition|(
operator|!
name|elf32_h8_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 		   Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
block|}
comment|/* This is a 24-bit absolute address in one of the following 	   instructions:  	     "band", "bclr", "biand", "bild", "bior", "bist", "bixor", 	     "bld", "bnot", "bor", "bset", "bst", "btst", "bxor", and 	     "mov.b"  	   We may relax this into an 8-bit absolute address if it's in 	   the right range.  */
case|case
name|R_H8_DIR24A8
case|:
block|{
name|bfd_vma
name|value
decl_stmt|;
name|value
operator|=
name|bfd_h8300_pad_address
argument_list|(
name|abfd
argument_list|,
name|symval
operator|+
name|irel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|>=
literal|0xffffff00u
condition|)
block|{
name|unsigned
name|char
name|code
decl_stmt|;
name|unsigned
name|char
name|temp_code
decl_stmt|;
comment|/* Note that we've changed the relocs, section contents, 		   etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Get the opcode.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* All instructions with R_H8_DIR24A8 start with 		   0x6a.  */
if|if
condition|(
name|code
operator|!=
literal|0x6a
condition|)
name|abort
argument_list|()
expr_stmt|;
name|temp_code
operator|=
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* If this is a mov.b instruction, clear the lower 		   nibble, which contains the source/destination 		   register number.  */
if|if
condition|(
operator|(
name|temp_code
operator|&
literal|0x30
operator|)
operator|!=
literal|0x30
condition|)
name|temp_code
operator|&=
literal|0xf0
expr_stmt|;
switch|switch
condition|(
name|temp_code
condition|)
block|{
case|case
literal|0x20
case|:
comment|/* This is mov.b @aa:24/32,Rd.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|code
operator|&
literal|0xf
operator|)
operator||
literal|0x20
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xa0
case|:
comment|/* This is mov.b Rs,@aa:24/32.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|code
operator|&
literal|0xf
operator|)
operator||
literal|0x30
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x38
case|:
comment|/* This is a bit-maniputation instruction that 		       stores one bit into memory, one of "bclr", 		       "bist", "bnot", "bset", and "bst".  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x7f
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x30
case|:
comment|/* This is a bit-maniputation instruction that 		       loads one bit from memory, one of "band", 		       "biand", "bild", "bior", "bixor", "bld", "bor", 		       "btst", and "bxor".  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x7e
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_H8_DIR8
argument_list|)
expr_stmt|;
name|irel
operator|->
name|r_offset
operator|--
expr_stmt|;
comment|/* Delete two bytes of data.  */
if|if
condition|(
operator|!
name|elf32_h8_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|,
literal|4
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 		   Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
comment|/* Fall through.  */
comment|/* This is a 24-/32-bit absolute address in one of the 	     following instructions:  	       "band", "bclr", "biand", "bild", "bior", "bist", 	       "bixor", "bld", "bnot", "bor", "bset", "bst", "btst", 	       "bxor", "ldc.w", "stc.w" and "mov.[bwl]"  	     We may relax this into an 16-bit absolute address if it's 	     in the right range.  */
case|case
name|R_H8_DIR32A16
case|:
block|{
name|bfd_vma
name|value
decl_stmt|;
name|value
operator|=
name|bfd_h8300_pad_address
argument_list|(
name|abfd
argument_list|,
name|symval
operator|+
name|irel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|<=
literal|0x7fff
operator|||
name|value
operator|>=
literal|0xffff8000u
condition|)
block|{
name|unsigned
name|char
name|code
decl_stmt|;
comment|/* Note that we've changed the relocs, section contents, 		   etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Get the opcode.  */
name|code
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Fix the opcode.  For all the instructions that 		   belong to this relaxation, we simply need to turn 		   off bit 0x20 in the previous byte.  */
name|code
operator|&=
operator|~
literal|0x20
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_H8_DIR16
argument_list|)
expr_stmt|;
comment|/* Delete two bytes of data.  */
if|if
condition|(
operator|!
name|elf32_h8_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 		   Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
block|}
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
else|else
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the section contents for elf_link_input_bfd.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
block|}
block|}
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Delete some bytes from a section while relaxing.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_h8_relax_delete_bytes
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|unsigned
name|int
name|sec_shndx
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelalign
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymend
decl_stmt|;
name|bfd_vma
name|toaddr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|end_hashes
decl_stmt|;
name|unsigned
name|int
name|symcount
decl_stmt|;
name|sec_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
comment|/* The deletion must stop at the next ALIGN reloc for an aligment      power larger than the number of bytes we are deleting.  */
name|irelalign
operator|=
name|NULL
expr_stmt|;
name|toaddr
operator|=
name|sec
operator|->
name|_cooked_size
expr_stmt|;
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
expr_stmt|;
name|irelend
operator|=
name|irel
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
comment|/* Actually delete the bytes.  */
name|memmove
argument_list|(
name|contents
operator|+
name|addr
argument_list|,
name|contents
operator|+
name|addr
operator|+
name|count
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|toaddr
operator|-
name|addr
operator|-
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|sec
operator|->
name|_cooked_size
operator|-=
name|count
expr_stmt|;
comment|/* Adjust all the relocs.  */
for|for
control|(
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
comment|/* Get the new reloc address.  */
if|if
condition|(
operator|(
name|irel
operator|->
name|r_offset
operator|>
name|addr
operator|&&
name|irel
operator|->
name|r_offset
operator|<
name|toaddr
operator|)
condition|)
name|irel
operator|->
name|r_offset
operator|-=
name|count
expr_stmt|;
block|}
comment|/* Adjust the local symbols defined in this section.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|isym
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
name|isymend
operator|=
name|isym
operator|+
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
control|)
block|{
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|sec_shndx
operator|&&
name|isym
operator|->
name|st_value
operator|>
name|addr
operator|&&
name|isym
operator|->
name|st_value
operator|<
name|toaddr
condition|)
name|isym
operator|->
name|st_value
operator|-=
name|count
expr_stmt|;
block|}
comment|/* Now adjust the global symbols defined in this section.  */
name|symcount
operator|=
operator|(
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|end_hashes
operator|=
name|sym_hashes
operator|+
name|symcount
expr_stmt|;
for|for
control|(
init|;
name|sym_hashes
operator|<
name|end_hashes
condition|;
name|sym_hashes
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|sym_hash
init|=
operator|*
name|sym_hashes
decl_stmt|;
if|if
condition|(
operator|(
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|sec
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|>
name|addr
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|<
name|toaddr
condition|)
block|{
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|-=
name|count
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if a symbol exists at the given address, else return    FALSE.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_h8_symbol_address_p
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|addr
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|unsigned
name|int
name|sec_shndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymend
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|end_hashes
decl_stmt|;
name|unsigned
name|int
name|symcount
decl_stmt|;
name|sec_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
comment|/* Examine all the symbols.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|isym
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
name|isymend
operator|=
name|isym
operator|+
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
control|)
block|{
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|sec_shndx
operator|&&
name|isym
operator|->
name|st_value
operator|==
name|addr
condition|)
return|return
name|TRUE
return|;
block|}
name|symcount
operator|=
operator|(
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|end_hashes
operator|=
name|sym_hashes
operator|+
name|symcount
expr_stmt|;
for|for
control|(
init|;
name|sym_hashes
operator|<
name|end_hashes
condition|;
name|sym_hashes
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|sym_hash
init|=
operator|*
name|sym_hashes
decl_stmt|;
if|if
condition|(
operator|(
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|sec
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|==
name|addr
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* This is a version of bfd_generic_get_relocated_section_contents    which uses elf32_h8_relocate_section.  */
end_comment

begin_function
specifier|static
name|bfd_byte
modifier|*
name|elf32_h8_get_relocated_section_contents
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|struct
name|bfd_link_order
modifier|*
name|link_order
parameter_list|,
name|bfd_byte
modifier|*
name|data
parameter_list|,
name|bfd_boolean
name|relocatable
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|input_section
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
init|=
name|input_section
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sections
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
comment|/* We only need to handle the case of relaxing, or of having a      particular set of section contents, specially.  */
if|if
condition|(
name|relocatable
operator|||
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|==
name|NULL
condition|)
return|return
name|bfd_generic_get_relocated_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|link_info
argument_list|,
name|link_order
argument_list|,
name|data
argument_list|,
name|relocatable
argument_list|,
name|symbols
argument_list|)
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
argument_list|,
operator|(
name|size_t
operator|)
name|input_section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|input_section
operator|->
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|asection
modifier|*
modifier|*
name|secpp
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|,
modifier|*
name|isymend
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|internal_relocs
operator|=
operator|(
name|_bfd_elf_link_read_relocs
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
name|amt
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|sections
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sections
operator|==
name|NULL
operator|&&
name|amt
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|isymend
operator|=
name|isymbuf
operator|+
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
name|isym
operator|=
name|isymbuf
operator|,
name|secpp
operator|=
name|sections
init|;
name|isym
operator|<
name|isymend
condition|;
operator|++
name|isym
operator|,
operator|++
name|secpp
control|)
block|{
name|asection
modifier|*
name|isec
decl_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|isec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|isec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|isec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
name|isec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|input_bfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
operator|*
name|secpp
operator|=
name|isec
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|elf32_h8_relocate_section
argument_list|(
name|output_bfd
argument_list|,
name|link_info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|data
argument_list|,
name|internal_relocs
argument_list|,
name|isymbuf
argument_list|,
name|sections
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
return|return
name|data
return|;
name|error_return
label|:
if|if
condition|(
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|elf32_h8_gc_mark_hook
parameter_list|(
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|rel
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|elf_link_hash_entry
modifier|*
name|h
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|sym
parameter_list|)
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
default|default:
break|break;
block|}
block|}
else|else
return|return
name|bfd_section_from_elf_index
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|elf32_h8_gc_sweep_hook
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_h8300_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-h8300"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_h8300
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_H8_300
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|elf32_h8_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|elf32_h8_info_to_howto
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|elf32_h8_info_to_howto_rel
end_define

begin_comment
comment|/* So we can set/examine bits in e_flags to get the specific    H8 architecture in use.  */
end_comment

begin_define
define|#
directive|define
name|elf_backend_final_write_processing
define|\
value|elf32_h8_final_write_processing
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
define|\
value|elf32_h8_object_p
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_merge_private_bfd_data
define|\
value|elf32_h8_merge_private_bfd_data
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|elf32_h8_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|elf32_h8_gc_sweep_hook
end_define

begin_comment
comment|/* ??? when elf_backend_relocate_section is not defined, elf32-target.h    defaults to using _bfd_generic_link_hash_table_create, but    bfd_elf_size_dynamic_sections uses    dynobj = elf_hash_table (info)->dynobj;    and thus requires an elf hash table.  */
end_comment

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
value|_bfd_elf_link_hash_table_create
end_define

begin_comment
comment|/* Use an H8 specific linker, not the ELF generic linker.  */
end_comment

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|elf32_h8_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_rela_normal
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_comment
comment|/* And relaxing stuff.  */
end_comment

begin_define
define|#
directive|define
name|bfd_elf32_bfd_relax_section
value|elf32_h8_relax_section
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_get_relocated_section_contents
define|\
value|elf32_h8_get_relocated_section_contents
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

