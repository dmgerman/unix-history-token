begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Ubicom IP2xxx specific support for 32-bit ELF    Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/ip2k.h"
end_include

begin_comment
comment|/* Struct used to pass miscellaneous paramaters which    helps to avoid overly long parameter lists.  */
end_comment

begin_struct
struct|struct
name|misc
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelbase
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ip2k_opcode
block|{
name|unsigned
name|short
name|opcode
decl_stmt|;
name|unsigned
name|short
name|mask
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Prototypes.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|ip2k_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ip2k_is_opcode
name|PARAMS
argument_list|(
operator|(
name|bfd_byte
operator|*
operator|,
specifier|const
expr|struct
name|ip2k_opcode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|symbol_value
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Shdr
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ip2k_get_mem
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|int
operator|,
name|bfd_byte
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_vma
name|ip2k_nominal_page_bits
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_byte
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|ip2k_test_page_insn
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
expr|struct
name|misc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|ip2k_delete_page_insn
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_boolean
operator|*
operator|,
expr|struct
name|misc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ip2k_is_switch_table_128
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_byte
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|ip2k_relax_switch_table_128
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_boolean
operator|*
operator|,
expr|struct
name|misc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ip2k_is_switch_table_256
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_byte
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|ip2k_relax_switch_table_256
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_boolean
operator|*
operator|,
expr|struct
name|misc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|ip2k_elf_relax_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd_boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|ip2k_elf_relax_section_page
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_boolean
operator|*
operator|,
expr|struct
name|misc
operator|*
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adjust_all_relocations
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|bfd_vma
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|ip2k_elf_relax_delete_bytes
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ip2k_info_to_howto_rela
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|ip2k_final_link_relocate
name|PARAMS
argument_list|(
operator|(
name|reloc_howto_type
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|ip2k_elf_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|ip2k_elf_gc_mark_hook
name|PARAMS
argument_list|(
operator|(
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|ip2k_elf_gc_sweep_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_boolean
name|ip2k_relaxed
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ip2k_opcode
name|ip2k_page_opcode
index|[]
init|=
block|{
block|{
literal|0x0010
block|,
literal|0xFFF8
block|}
block|,
comment|/* page */
block|{
literal|0x0000
block|,
literal|0x0000
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IS_PAGE_OPCODE
parameter_list|(
name|code
parameter_list|)
define|\
value|ip2k_is_opcode (code, ip2k_page_opcode)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ip2k_opcode
name|ip2k_jmp_opcode
index|[]
init|=
block|{
block|{
literal|0xE000
block|,
literal|0xE000
block|}
block|,
comment|/* jmp */
block|{
literal|0x0000
block|,
literal|0x0000
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IS_JMP_OPCODE
parameter_list|(
name|code
parameter_list|)
define|\
value|ip2k_is_opcode (code, ip2k_jmp_opcode)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ip2k_opcode
name|ip2k_call_opcode
index|[]
init|=
block|{
block|{
literal|0xC000
block|,
literal|0xE000
block|}
block|,
comment|/* call */
block|{
literal|0x0000
block|,
literal|0x0000
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IS_CALL_OPCODE
parameter_list|(
name|code
parameter_list|)
define|\
value|ip2k_is_opcode (code, ip2k_call_opcode)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ip2k_opcode
name|ip2k_snc_opcode
index|[]
init|=
block|{
block|{
literal|0xA00B
block|,
literal|0xFFFF
block|}
block|,
comment|/* snc */
block|{
literal|0x0000
block|,
literal|0x0000
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IS_SNC_OPCODE
parameter_list|(
name|code
parameter_list|)
define|\
value|ip2k_is_opcode (code, ip2k_snc_opcode)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ip2k_opcode
name|ip2k_inc_1sp_opcode
index|[]
init|=
block|{
block|{
literal|0x2B81
block|,
literal|0xFFFF
block|}
block|,
comment|/* inc 1(SP) */
block|{
literal|0x0000
block|,
literal|0x0000
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IS_INC_1SP_OPCODE
parameter_list|(
name|code
parameter_list|)
define|\
value|ip2k_is_opcode (code, ip2k_inc_1sp_opcode)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ip2k_opcode
name|ip2k_add_2sp_w_opcode
index|[]
init|=
block|{
block|{
literal|0x1F82
block|,
literal|0xFFFF
block|}
block|,
comment|/* add 2(SP),w */
block|{
literal|0x0000
block|,
literal|0x0000
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IS_ADD_2SP_W_OPCODE
parameter_list|(
name|code
parameter_list|)
define|\
value|ip2k_is_opcode (code, ip2k_add_2sp_w_opcode)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ip2k_opcode
name|ip2k_add_w_wreg_opcode
index|[]
init|=
block|{
block|{
literal|0x1C0A
block|,
literal|0xFFFF
block|}
block|,
comment|/* add w,wreg */
block|{
literal|0x1E0A
block|,
literal|0xFFFF
block|}
block|,
comment|/* add wreg,w */
block|{
literal|0x0000
block|,
literal|0x0000
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IS_ADD_W_WREG_OPCODE
parameter_list|(
name|code
parameter_list|)
define|\
value|ip2k_is_opcode (code, ip2k_add_w_wreg_opcode)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ip2k_opcode
name|ip2k_add_pcl_w_opcode
index|[]
init|=
block|{
block|{
literal|0x1E09
block|,
literal|0xFFFF
block|}
block|,
comment|/* add pcl,w */
block|{
literal|0x0000
block|,
literal|0x0000
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IS_ADD_PCL_W_OPCODE
parameter_list|(
name|code
parameter_list|)
define|\
value|ip2k_is_opcode (code, ip2k_add_pcl_w_opcode)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ip2k_opcode
name|ip2k_skip_opcodes
index|[]
init|=
block|{
block|{
literal|0xB000
block|,
literal|0xF000
block|}
block|,
comment|/* sb */
block|{
literal|0xA000
block|,
literal|0xF000
block|}
block|,
comment|/* snb */
block|{
literal|0x7600
block|,
literal|0xFE00
block|}
block|,
comment|/* cse/csne #lit */
block|{
literal|0x5800
block|,
literal|0xFC00
block|}
block|,
comment|/* incsnz */
block|{
literal|0x4C00
block|,
literal|0xFC00
block|}
block|,
comment|/* decsnz */
block|{
literal|0x4000
block|,
literal|0xFC00
block|}
block|,
comment|/* cse/csne */
block|{
literal|0x3C00
block|,
literal|0xFC00
block|}
block|,
comment|/* incsz */
block|{
literal|0x2C00
block|,
literal|0xFC00
block|}
block|,
comment|/* decsz */
block|{
literal|0x0000
block|,
literal|0x0000
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IS_SKIP_OPCODE
parameter_list|(
name|code
parameter_list|)
define|\
value|ip2k_is_opcode (code, ip2k_skip_opcodes)
end_define

begin_comment
comment|/* Relocation tables.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|ip2k_elf_howto_table
index|[]
init|=
block|{
define|#
directive|define
name|IP2K_HOWTO
parameter_list|(
name|t
parameter_list|,
name|rs
parameter_list|,
name|s
parameter_list|,
name|bs
parameter_list|,
name|pr
parameter_list|,
name|bp
parameter_list|,
name|name
parameter_list|,
name|sm
parameter_list|,
name|dm
parameter_list|)
define|\
value|HOWTO(t,
comment|/* type */
value|\           rs,
comment|/* rightshift */
value|\           s,
comment|/* size (0 = byte, 1 = short, 2 = long) */
value|\           bs,
comment|/* bitsize */
value|\           pr,
comment|/* pc_relative */
value|\           bp,
comment|/* bitpos */
value|\           complain_overflow_dont,
comment|/* complain_on_overflow */
value|\           bfd_elf_generic_reloc,
comment|/* special_function */
value|\           name,
comment|/* name */
value|\           FALSE,
comment|/* partial_inplace */
value|\           sm,
comment|/* src_mask */
value|\           dm,
comment|/* dst_mask */
value|\           pr)
comment|/* pcrel_offset */
comment|/* This reloc does nothing.  */
name|IP2K_HOWTO
argument_list|(
name|R_IP2K_NONE
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|"R_IP2K_NONE"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* A 16 bit absolute relocation.  */
name|IP2K_HOWTO
argument_list|(
name|R_IP2K_16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|"R_IP2K_16"
argument_list|,
literal|0
argument_list|,
literal|0xffff
argument_list|)
block|,
comment|/* A 32 bit absolute relocation.  */
name|IP2K_HOWTO
argument_list|(
name|R_IP2K_32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|"R_IP2K_32"
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|)
block|,
comment|/* A 8-bit data relocation for the FR9 field.  Ninth bit is computed specially.  */
name|IP2K_HOWTO
argument_list|(
name|R_IP2K_FR9
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|9
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|"R_IP2K_FR9"
argument_list|,
literal|0
argument_list|,
literal|0x00ff
argument_list|)
block|,
comment|/* A 4-bit data relocation.  */
name|IP2K_HOWTO
argument_list|(
name|R_IP2K_BANK
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|"R_IP2K_BANK"
argument_list|,
literal|0
argument_list|,
literal|0x000f
argument_list|)
block|,
comment|/* A 13-bit insn relocation - word address => right-shift 1 bit extra.  */
name|IP2K_HOWTO
argument_list|(
name|R_IP2K_ADDR16CJP
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|13
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|"R_IP2K_ADDR16CJP"
argument_list|,
literal|0
argument_list|,
literal|0x1fff
argument_list|)
block|,
comment|/* A 3-bit insn relocation - word address => right-shift 1 bit extra.  */
name|IP2K_HOWTO
argument_list|(
name|R_IP2K_PAGE3
argument_list|,
literal|14
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|"R_IP2K_PAGE3"
argument_list|,
literal|0
argument_list|,
literal|0x0007
argument_list|)
block|,
comment|/* Two 8-bit data relocations.  */
name|IP2K_HOWTO
argument_list|(
name|R_IP2K_LO8DATA
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|"R_IP2K_LO8DATA"
argument_list|,
literal|0
argument_list|,
literal|0x00ff
argument_list|)
block|,
name|IP2K_HOWTO
argument_list|(
name|R_IP2K_HI8DATA
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|"R_IP2K_HI8DATA"
argument_list|,
literal|0
argument_list|,
literal|0x00ff
argument_list|)
block|,
comment|/* Two 8-bit insn relocations.  word address => right-shift 1 bit extra.  */
name|IP2K_HOWTO
argument_list|(
name|R_IP2K_LO8INSN
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|"R_IP2K_LO8INSN"
argument_list|,
literal|0
argument_list|,
literal|0x00ff
argument_list|)
block|,
name|IP2K_HOWTO
argument_list|(
name|R_IP2K_HI8INSN
argument_list|,
literal|9
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|"R_IP2K_HI8INSN"
argument_list|,
literal|0
argument_list|,
literal|0x00ff
argument_list|)
block|,
comment|/* Special 1 bit relocation for SKIP instructions.  */
name|IP2K_HOWTO
argument_list|(
name|R_IP2K_PC_SKIP
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|,
literal|12
argument_list|,
literal|"R_IP2K_PC_SKIP"
argument_list|,
literal|0xfffe
argument_list|,
literal|0x1000
argument_list|)
block|,
comment|/* 16 bit word address.  */
name|IP2K_HOWTO
argument_list|(
name|R_IP2K_TEXT
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|"R_IP2K_TEXT"
argument_list|,
literal|0
argument_list|,
literal|0xffff
argument_list|)
block|,
comment|/* A 7-bit offset relocation for the FR9 field.  Eigth and ninth bit comes from insn.  */
name|IP2K_HOWTO
argument_list|(
name|R_IP2K_FR_OFFSET
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|9
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|"R_IP2K_FR_OFFSET"
argument_list|,
literal|0x180
argument_list|,
literal|0x007f
argument_list|)
block|,
comment|/* Bits 23:16 of an address.  */
name|IP2K_HOWTO
argument_list|(
name|R_IP2K_EX8DATA
argument_list|,
literal|16
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
literal|"R_IP2K_EX8DATA"
argument_list|,
literal|0
argument_list|,
literal|0x00ff
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map BFD reloc types to IP2K ELF reloc types.  */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|ip2k_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
comment|/* Note that the ip2k_elf_howto_table is indxed by the R_      constants.  Thus, the order that the howto records appear in the      table *must* match the order of the relocation types defined in      include/elf/ip2k.h.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BFD_RELOC_NONE
case|:
return|return
operator|&
name|ip2k_elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_IP2K_NONE
index|]
return|;
case|case
name|BFD_RELOC_16
case|:
return|return
operator|&
name|ip2k_elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_IP2K_16
index|]
return|;
case|case
name|BFD_RELOC_32
case|:
return|return
operator|&
name|ip2k_elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_IP2K_32
index|]
return|;
case|case
name|BFD_RELOC_IP2K_FR9
case|:
return|return
operator|&
name|ip2k_elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_IP2K_FR9
index|]
return|;
case|case
name|BFD_RELOC_IP2K_BANK
case|:
return|return
operator|&
name|ip2k_elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_IP2K_BANK
index|]
return|;
case|case
name|BFD_RELOC_IP2K_ADDR16CJP
case|:
return|return
operator|&
name|ip2k_elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_IP2K_ADDR16CJP
index|]
return|;
case|case
name|BFD_RELOC_IP2K_PAGE3
case|:
return|return
operator|&
name|ip2k_elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_IP2K_PAGE3
index|]
return|;
case|case
name|BFD_RELOC_IP2K_LO8DATA
case|:
return|return
operator|&
name|ip2k_elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_IP2K_LO8DATA
index|]
return|;
case|case
name|BFD_RELOC_IP2K_HI8DATA
case|:
return|return
operator|&
name|ip2k_elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_IP2K_HI8DATA
index|]
return|;
case|case
name|BFD_RELOC_IP2K_LO8INSN
case|:
return|return
operator|&
name|ip2k_elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_IP2K_LO8INSN
index|]
return|;
case|case
name|BFD_RELOC_IP2K_HI8INSN
case|:
return|return
operator|&
name|ip2k_elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_IP2K_HI8INSN
index|]
return|;
case|case
name|BFD_RELOC_IP2K_PC_SKIP
case|:
return|return
operator|&
name|ip2k_elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_IP2K_PC_SKIP
index|]
return|;
case|case
name|BFD_RELOC_IP2K_TEXT
case|:
return|return
operator|&
name|ip2k_elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_IP2K_TEXT
index|]
return|;
case|case
name|BFD_RELOC_IP2K_FR_OFFSET
case|:
return|return
operator|&
name|ip2k_elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_IP2K_FR_OFFSET
index|]
return|;
case|case
name|BFD_RELOC_IP2K_EX8DATA
case|:
return|return
operator|&
name|ip2k_elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_IP2K_EX8DATA
index|]
return|;
default|default:
comment|/* Pacify gcc -Wall.  */
return|return
name|NULL
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ip2k_get_mem
parameter_list|(
name|abfd
parameter_list|,
name|addr
parameter_list|,
name|length
parameter_list|,
name|ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_byte
modifier|*
name|addr
decl_stmt|;
name|int
name|length
decl_stmt|;
name|bfd_byte
modifier|*
name|ptr
decl_stmt|;
block|{
while|while
condition|(
name|length
operator|--
condition|)
operator|*
name|ptr
operator|++
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|addr
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|ip2k_is_opcode
parameter_list|(
name|code
parameter_list|,
name|opcodes
parameter_list|)
name|bfd_byte
modifier|*
name|code
decl_stmt|;
specifier|const
name|struct
name|ip2k_opcode
modifier|*
name|opcodes
decl_stmt|;
block|{
name|unsigned
name|short
name|insn
init|=
operator|(
name|code
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|code
index|[
literal|1
index|]
decl_stmt|;
while|while
condition|(
name|opcodes
operator|->
name|mask
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|insn
operator|&
name|opcodes
operator|->
name|mask
operator|)
operator|==
name|opcodes
operator|->
name|opcode
condition|)
return|return
name|TRUE
return|;
name|opcodes
operator|++
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PAGENO
parameter_list|(
name|ABSADDR
parameter_list|)
value|((ABSADDR)& 0xFFFFC000)
end_define

begin_define
define|#
directive|define
name|BASEADDR
parameter_list|(
name|SEC
parameter_list|)
value|((SEC)->output_section->vma + (SEC)->output_offset)
end_define

begin_define
define|#
directive|define
name|UNDEFINED_SYMBOL
value|(~(bfd_vma)0)
end_define

begin_comment
comment|/* Return the value of the symbol associated with the relocation IREL.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|symbol_value
parameter_list|(
name|abfd
parameter_list|,
name|symtab_hdr
parameter_list|,
name|isymbuf
parameter_list|,
name|irel
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
block|{
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|isym
operator|=
name|isymbuf
operator|+
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|sym_sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|sym_sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|sym_sec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
name|sym_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
return|return
name|isym
operator|->
name|st_value
operator|+
name|BASEADDR
argument_list|(
name|sym_sec
argument_list|)
return|;
block|}
else|else
block|{
name|unsigned
name|long
name|indx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|indx
operator|=
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
return|return
name|UNDEFINED_SYMBOL
return|;
return|return
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|BASEADDR
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the expected page state for the given instruction not including    the effect of page instructions.  */
end_comment

begin_function
specifier|static
name|bfd_vma
name|ip2k_nominal_page_bits
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|addr
parameter_list|,
name|contents
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
block|{
name|bfd_vma
name|page
init|=
name|PAGENO
argument_list|(
name|BASEADDR
argument_list|(
name|sec
argument_list|)
operator|+
name|addr
argument_list|)
decl_stmt|;
comment|/* Check if section flows into this page. If not then the page      bits are assumed to match the PC. This will be true unless      the user has a page instruction without a call/jump, in which      case they are on their own.  */
if|if
condition|(
name|PAGENO
argument_list|(
name|BASEADDR
argument_list|(
name|sec
argument_list|)
argument_list|)
operator|==
name|page
condition|)
return|return
name|page
return|;
comment|/* Section flows across page boundary. The page bits should match      the PC unless there is a possible flow from the previous page,      in which case it is not possible to determine the value of the      page bits.  */
while|while
condition|(
name|PAGENO
argument_list|(
name|BASEADDR
argument_list|(
name|sec
argument_list|)
operator|+
name|addr
operator|-
literal|2
argument_list|)
operator|==
name|page
condition|)
block|{
name|bfd_byte
name|code
index|[
literal|2
index|]
decl_stmt|;
name|addr
operator|-=
literal|2
expr_stmt|;
name|ip2k_get_mem
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|addr
argument_list|,
literal|2
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_PAGE_OPCODE
argument_list|(
name|code
argument_list|)
condition|)
continue|continue;
comment|/* Found a page instruction, check if jump table.  */
if|if
condition|(
name|ip2k_is_switch_table_128
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|addr
argument_list|,
name|contents
argument_list|)
operator|!=
operator|-
literal|1
condition|)
comment|/* Jump table => page is conditional.  */
continue|continue;
if|if
condition|(
name|ip2k_is_switch_table_256
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|addr
argument_list|,
name|contents
argument_list|)
operator|!=
operator|-
literal|1
condition|)
comment|/* Jump table => page is conditional.  */
continue|continue;
comment|/* Found a page instruction, check if conditional.  */
if|if
condition|(
name|addr
operator|>=
literal|2
condition|)
block|{
name|ip2k_get_mem
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|addr
operator|-
literal|2
argument_list|,
literal|2
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SKIP_OPCODE
argument_list|(
name|code
argument_list|)
condition|)
comment|/* Page is conditional.  */
continue|continue;
block|}
comment|/* Unconditional page instruction => page bits should be correct.  */
return|return
name|page
return|;
block|}
comment|/* Flow from previous page => page bits are impossible to determine.  */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|ip2k_test_page_insn
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|irel
parameter_list|,
name|misc
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
name|struct
name|misc
modifier|*
name|misc
decl_stmt|;
block|{
name|bfd_vma
name|symval
decl_stmt|;
comment|/* Get the value of the symbol referred to by the reloc.  */
name|symval
operator|=
name|symbol_value
argument_list|(
name|abfd
argument_list|,
name|misc
operator|->
name|symtab_hdr
argument_list|,
name|misc
operator|->
name|isymbuf
argument_list|,
name|irel
argument_list|)
expr_stmt|;
if|if
condition|(
name|symval
operator|==
name|UNDEFINED_SYMBOL
condition|)
comment|/* This appears to be a reference to an undefined        symbol.  Just ignore it--it will be caught by the        regular reloc processing.  */
return|return
name|FALSE
return|;
comment|/* Test if we can delete this page instruction.  */
if|if
condition|(
name|PAGENO
argument_list|(
name|symval
operator|+
name|irel
operator|->
name|r_addend
argument_list|)
operator|!=
name|ip2k_nominal_page_bits
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
argument_list|,
name|misc
operator|->
name|contents
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|ip2k_delete_page_insn
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|irel
parameter_list|,
name|again
parameter_list|,
name|misc
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
name|bfd_boolean
modifier|*
name|again
decl_stmt|;
name|struct
name|misc
modifier|*
name|misc
decl_stmt|;
block|{
comment|/* Note that we've changed the relocs, section contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|misc
operator|->
name|irelbase
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|misc
operator|->
name|contents
expr_stmt|;
name|misc
operator|->
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|misc
operator|->
name|isymbuf
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_IP2K_NONE
argument_list|)
expr_stmt|;
comment|/* Delete the PAGE insn.  */
if|if
condition|(
operator|!
name|ip2k_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Modified => will need to iterate relaxation again.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Determine if the instruction sequence matches that for    the prologue of a switch dispatch table with fewer than    128 entries.            sc           page    $nnn0           jmp     $nnn0           add     w,wreg           add     pcl,w   addr=>           page    $nnn1           jmp     $nnn1  	   page    $nnn2  	   jmp     $nnn2  	   ...  	   page    $nnnN  	   jmp     $nnnN    After relaxation.   	   sc  	   page    $nnn0   	   jmp     $nnn0  	   add     pcl,w   addr=>   	   jmp     $nnn1  	   jmp     $nnn2  	   ...           jmp     $nnnN  */
end_comment

begin_function
specifier|static
name|int
name|ip2k_is_switch_table_128
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|addr
parameter_list|,
name|contents
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
block|{
name|bfd_byte
name|code
index|[
literal|4
index|]
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
comment|/* Check current page-jmp.  */
if|if
condition|(
name|addr
operator|+
literal|4
operator|>
name|sec
operator|->
name|_cooked_size
condition|)
return|return
operator|-
literal|1
return|;
name|ip2k_get_mem
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|addr
argument_list|,
literal|4
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|IS_PAGE_OPCODE
argument_list|(
name|code
operator|+
literal|0
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|IS_JMP_OPCODE
argument_list|(
name|code
operator|+
literal|2
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Search back.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|addr
operator|<
literal|4
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Check previous 2 instructions.  */
name|ip2k_get_mem
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|addr
operator|-
literal|4
argument_list|,
literal|4
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|IS_ADD_W_WREG_OPCODE
argument_list|(
name|code
operator|+
literal|0
argument_list|)
operator|)
operator|&&
operator|(
name|IS_ADD_PCL_W_OPCODE
argument_list|(
name|code
operator|+
literal|2
argument_list|)
operator|)
condition|)
return|return
name|index
return|;
if|if
condition|(
operator|(
operator|!
name|IS_PAGE_OPCODE
argument_list|(
name|code
operator|+
literal|0
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|IS_JMP_OPCODE
argument_list|(
name|code
operator|+
literal|2
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|index
operator|++
expr_stmt|;
name|addr
operator|-=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|ip2k_relax_switch_table_128
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|irel
parameter_list|,
name|again
parameter_list|,
name|misc
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
name|bfd_boolean
modifier|*
name|again
decl_stmt|;
name|struct
name|misc
modifier|*
name|misc
decl_stmt|;
block|{
name|Elf_Internal_Rela
modifier|*
name|irelend
init|=
name|misc
operator|->
name|irelbase
operator|+
name|sec
operator|->
name|reloc_count
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|ireltest
init|=
name|irel
decl_stmt|;
name|bfd_byte
name|code
index|[
literal|4
index|]
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
comment|/* Test all page instructions.  */
name|addr
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|addr
operator|+
literal|4
operator|>
name|sec
operator|->
name|_cooked_size
condition|)
break|break;
name|ip2k_get_mem
argument_list|(
name|abfd
argument_list|,
name|misc
operator|->
name|contents
operator|+
name|addr
argument_list|,
literal|4
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|IS_PAGE_OPCODE
argument_list|(
name|code
operator|+
literal|0
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|IS_JMP_OPCODE
argument_list|(
name|code
operator|+
literal|2
argument_list|)
operator|)
condition|)
break|break;
comment|/* Validate relocation entry (every entry should have a matching           relocation entry).  */
if|if
condition|(
name|ireltest
operator|>=
name|irelend
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ip2k relaxer: switch table without complete matching relocation information."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|ireltest
operator|->
name|r_offset
operator|!=
name|addr
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ip2k relaxer: switch table without complete matching relocation information."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|ip2k_test_page_insn
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|ireltest
argument_list|,
name|misc
argument_list|)
condition|)
comment|/* Un-removable page insn => nothing can be done.  */
return|return
name|TRUE
return|;
name|addr
operator|+=
literal|4
expr_stmt|;
name|ireltest
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Relaxable. Adjust table header.  */
name|ip2k_get_mem
argument_list|(
name|abfd
argument_list|,
name|misc
operator|->
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|4
argument_list|,
literal|4
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|IS_ADD_W_WREG_OPCODE
argument_list|(
name|code
operator|+
literal|0
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|IS_ADD_PCL_W_OPCODE
argument_list|(
name|code
operator|+
literal|2
argument_list|)
operator|)
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ip2k relaxer: switch table header corrupt."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|ip2k_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|-
literal|4
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|FALSE
return|;
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
comment|/* Delete all page instructions in table.  */
while|while
condition|(
name|irel
operator|<
name|ireltest
condition|)
block|{
if|if
condition|(
operator|!
name|ip2k_delete_page_insn
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
argument_list|,
name|again
argument_list|,
name|misc
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|irel
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Determine if the instruction sequence matches that for    the prologue switch dispatch table with fewer than    256 entries but more than 127.     Before relaxation.           push    %lo8insn(label) ; Push address of table           push    %hi8insn(label)           add     w,wreg          ; index*2 => offset           snc                     ; CARRY SET?           inc     1(sp)           ; Propagate MSB into table address           add     2(sp),w         ; Add low bits of offset to table address           snc                     ; and handle any carry-out           inc     1(sp)    addr=>           page    __indjmp        ; Do an indirect jump to that location           jmp     __indjmp    label:                         ; case dispatch table starts here  	   page    $nnn1  	   jmp	   $nnn1  	   page	   $nnn2  	   jmp     $nnn2  	   ...  	   page    $nnnN  	   jmp	   $nnnN    After relaxation.           push    %lo8insn(label) ; Push address of table           push    %hi8insn(label)           add     2(sp),w         ; Add low bits of offset to table address           snc                     ; and handle any carry-out           inc     1(sp)   addr=>           page    __indjmp        ; Do an indirect jump to that location           jmp     __indjmp    label:                         ; case dispatch table starts here           jmp     $nnn1           jmp     $nnn2           ...           jmp     $nnnN  */
end_comment

begin_function
specifier|static
name|int
name|ip2k_is_switch_table_256
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|addr
parameter_list|,
name|contents
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
block|{
name|bfd_byte
name|code
index|[
literal|16
index|]
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
comment|/* Check current page-jmp.  */
if|if
condition|(
name|addr
operator|+
literal|4
operator|>
name|sec
operator|->
name|_cooked_size
condition|)
return|return
operator|-
literal|1
return|;
name|ip2k_get_mem
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|addr
argument_list|,
literal|4
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|IS_PAGE_OPCODE
argument_list|(
name|code
operator|+
literal|0
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|IS_JMP_OPCODE
argument_list|(
name|code
operator|+
literal|2
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Search back.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|addr
operator|<
literal|16
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Check previous 8 instructions.  */
name|ip2k_get_mem
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|addr
operator|-
literal|16
argument_list|,
literal|16
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|IS_ADD_W_WREG_OPCODE
argument_list|(
name|code
operator|+
literal|0
argument_list|)
operator|)
operator|&&
operator|(
name|IS_SNC_OPCODE
argument_list|(
name|code
operator|+
literal|2
argument_list|)
operator|)
operator|&&
operator|(
name|IS_INC_1SP_OPCODE
argument_list|(
name|code
operator|+
literal|4
argument_list|)
operator|)
operator|&&
operator|(
name|IS_ADD_2SP_W_OPCODE
argument_list|(
name|code
operator|+
literal|6
argument_list|)
operator|)
operator|&&
operator|(
name|IS_SNC_OPCODE
argument_list|(
name|code
operator|+
literal|8
argument_list|)
operator|)
operator|&&
operator|(
name|IS_INC_1SP_OPCODE
argument_list|(
name|code
operator|+
literal|10
argument_list|)
operator|)
operator|&&
operator|(
name|IS_PAGE_OPCODE
argument_list|(
name|code
operator|+
literal|12
argument_list|)
operator|)
operator|&&
operator|(
name|IS_JMP_OPCODE
argument_list|(
name|code
operator|+
literal|14
argument_list|)
operator|)
condition|)
return|return
name|index
return|;
if|if
condition|(
operator|(
name|IS_ADD_W_WREG_OPCODE
argument_list|(
name|code
operator|+
literal|2
argument_list|)
operator|)
operator|&&
operator|(
name|IS_SNC_OPCODE
argument_list|(
name|code
operator|+
literal|4
argument_list|)
operator|)
operator|&&
operator|(
name|IS_INC_1SP_OPCODE
argument_list|(
name|code
operator|+
literal|6
argument_list|)
operator|)
operator|&&
operator|(
name|IS_ADD_2SP_W_OPCODE
argument_list|(
name|code
operator|+
literal|8
argument_list|)
operator|)
operator|&&
operator|(
name|IS_SNC_OPCODE
argument_list|(
name|code
operator|+
literal|10
argument_list|)
operator|)
operator|&&
operator|(
name|IS_INC_1SP_OPCODE
argument_list|(
name|code
operator|+
literal|12
argument_list|)
operator|)
operator|&&
operator|(
name|IS_JMP_OPCODE
argument_list|(
name|code
operator|+
literal|14
argument_list|)
operator|)
condition|)
return|return
name|index
return|;
if|if
condition|(
operator|(
operator|!
name|IS_PAGE_OPCODE
argument_list|(
name|code
operator|+
literal|0
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|IS_JMP_OPCODE
argument_list|(
name|code
operator|+
literal|2
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|index
operator|++
expr_stmt|;
name|addr
operator|-=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|ip2k_relax_switch_table_256
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|irel
parameter_list|,
name|again
parameter_list|,
name|misc
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
name|bfd_boolean
modifier|*
name|again
decl_stmt|;
name|struct
name|misc
modifier|*
name|misc
decl_stmt|;
block|{
name|Elf_Internal_Rela
modifier|*
name|irelend
init|=
name|misc
operator|->
name|irelbase
operator|+
name|sec
operator|->
name|reloc_count
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|ireltest
init|=
name|irel
decl_stmt|;
name|bfd_byte
name|code
index|[
literal|12
index|]
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
comment|/* Test all page instructions.  */
name|addr
operator|=
name|irel
operator|->
name|r_offset
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|addr
operator|+
literal|4
operator|>
name|sec
operator|->
name|_cooked_size
condition|)
break|break;
name|ip2k_get_mem
argument_list|(
name|abfd
argument_list|,
name|misc
operator|->
name|contents
operator|+
name|addr
argument_list|,
literal|4
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|IS_PAGE_OPCODE
argument_list|(
name|code
operator|+
literal|0
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|IS_JMP_OPCODE
argument_list|(
name|code
operator|+
literal|2
argument_list|)
operator|)
condition|)
break|break;
comment|/* Validate relocation entry (every entry should have a matching           relocation entry).  */
if|if
condition|(
name|ireltest
operator|>=
name|irelend
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ip2k relaxer: switch table without complete matching relocation information."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|ireltest
operator|->
name|r_offset
operator|!=
name|addr
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ip2k relaxer: switch table without complete matching relocation information."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|ip2k_test_page_insn
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|ireltest
argument_list|,
name|misc
argument_list|)
condition|)
comment|/* Un-removable page insn => nothing can be done.  */
return|return
name|TRUE
return|;
name|addr
operator|+=
literal|4
expr_stmt|;
name|ireltest
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Relaxable. Adjust table header.  */
name|ip2k_get_mem
argument_list|(
name|abfd
argument_list|,
name|misc
operator|->
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|4
argument_list|,
literal|2
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_PAGE_OPCODE
argument_list|(
name|code
argument_list|)
condition|)
name|addr
operator|=
name|irel
operator|->
name|r_offset
operator|-
literal|16
expr_stmt|;
else|else
name|addr
operator|=
name|irel
operator|->
name|r_offset
operator|-
literal|14
expr_stmt|;
name|ip2k_get_mem
argument_list|(
name|abfd
argument_list|,
name|misc
operator|->
name|contents
operator|+
name|addr
argument_list|,
literal|12
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|IS_ADD_W_WREG_OPCODE
argument_list|(
name|code
operator|+
literal|0
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|IS_SNC_OPCODE
argument_list|(
name|code
operator|+
literal|2
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|IS_INC_1SP_OPCODE
argument_list|(
name|code
operator|+
literal|4
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|IS_ADD_2SP_W_OPCODE
argument_list|(
name|code
operator|+
literal|6
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|IS_SNC_OPCODE
argument_list|(
name|code
operator|+
literal|8
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|IS_INC_1SP_OPCODE
argument_list|(
name|code
operator|+
literal|10
argument_list|)
operator|)
condition|)
block|{
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ip2k relaxer: switch table header corrupt."
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Delete first 3 opcodes.  */
if|if
condition|(
operator|!
name|ip2k_elf_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|addr
operator|+
literal|0
argument_list|,
literal|6
argument_list|)
condition|)
return|return
name|FALSE
return|;
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
comment|/* Delete all page instructions in table.  */
while|while
condition|(
name|irel
operator|<
name|ireltest
condition|)
block|{
if|if
condition|(
operator|!
name|ip2k_delete_page_insn
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
argument_list|,
name|again
argument_list|,
name|misc
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|irel
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This function handles relaxing for the ip2k.     Principle: Start with the first page and remove page instructions that    are not require on this first page. By removing page instructions more    code will fit into this page - repeat until nothing more can be achieved    for this page. Move on to the next page.     Processing the pages one at a time from the lowest page allows a removal    only policy to be used - pages can be removed but are never reinserted.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ip2k_elf_relax_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|link_info
parameter_list|,
name|again
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|bfd_boolean
modifier|*
name|again
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
specifier|static
name|asection
modifier|*
name|first_section
init|=
name|NULL
decl_stmt|;
specifier|static
name|unsigned
name|long
name|search_addr
decl_stmt|;
specifier|static
name|unsigned
name|long
name|page_start
init|=
literal|0
decl_stmt|;
specifier|static
name|unsigned
name|long
name|page_end
init|=
literal|0
decl_stmt|;
specifier|static
name|unsigned
name|int
name|pass
init|=
literal|0
decl_stmt|;
specifier|static
name|bfd_boolean
name|new_pass
init|=
name|FALSE
decl_stmt|;
specifier|static
name|bfd_boolean
name|changed
init|=
name|FALSE
decl_stmt|;
name|struct
name|misc
name|misc
decl_stmt|;
name|asection
modifier|*
name|stab
decl_stmt|;
comment|/* Assume nothing changes.  */
operator|*
name|again
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|first_section
operator|==
name|NULL
condition|)
block|{
name|ip2k_relaxed
operator|=
name|TRUE
expr_stmt|;
name|first_section
operator|=
name|sec
expr_stmt|;
block|}
if|if
condition|(
name|first_section
operator|==
name|sec
condition|)
block|{
name|pass
operator|++
expr_stmt|;
name|new_pass
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* We don't have to do anything for a relocatable link,      if this section does not have relocs, or if this is      not a code section.  */
if|if
condition|(
name|link_info
operator|->
name|relocatable
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|sec
operator|->
name|reloc_count
operator|==
literal|0
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* If this is the first time we have been called       for this section, initialise the cooked size.  */
if|if
condition|(
name|sec
operator|->
name|_cooked_size
operator|==
literal|0
condition|)
name|sec
operator|->
name|_cooked_size
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|internal_relocs
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* Make sure the stac.rela stuff gets read in.  */
name|stab
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".stab"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stab
condition|)
block|{
comment|/* So stab does exits.  */
name|Elf_Internal_Rela
modifier|*
name|irelbase
decl_stmt|;
name|irelbase
operator|=
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|stab
argument_list|,
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
expr_stmt|;
block|}
comment|/* Get section contents cached copy if it exists.  */
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
block|{
comment|/* Get cached copy if it exists.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
comment|/* Go get them off disk.  */
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* Read this BFD's symbols cached copy if it exists.  */
if|if
condition|(
name|isymbuf
operator|==
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
name|misc
operator|.
name|symtab_hdr
operator|=
name|symtab_hdr
expr_stmt|;
name|misc
operator|.
name|isymbuf
operator|=
name|isymbuf
expr_stmt|;
name|misc
operator|.
name|irelbase
operator|=
name|internal_relocs
expr_stmt|;
name|misc
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
comment|/* This is where all the relaxation actually get done.  */
if|if
condition|(
operator|(
name|pass
operator|==
literal|1
operator|)
operator|||
operator|(
name|new_pass
operator|&&
operator|!
name|changed
operator|)
condition|)
block|{
comment|/* On the first pass we simply search for the lowest page that          we havn't relaxed yet. Note that the pass count is reset          each time a page is complete in order to move on to the next page.          If we can't find any more pages then we are finished.  */
if|if
condition|(
name|new_pass
condition|)
block|{
name|pass
operator|=
literal|1
expr_stmt|;
name|new_pass
operator|=
name|FALSE
expr_stmt|;
name|changed
operator|=
name|TRUE
expr_stmt|;
comment|/* Pre-initialize to break out of pass 1.  */
name|search_addr
operator|=
literal|0xFFFFFFFF
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|BASEADDR
argument_list|(
name|sec
argument_list|)
operator|+
name|sec
operator|->
name|_cooked_size
operator|<
name|search_addr
operator|)
operator|&&
operator|(
name|BASEADDR
argument_list|(
name|sec
argument_list|)
operator|+
name|sec
operator|->
name|_cooked_size
operator|>
name|page_end
operator|)
condition|)
block|{
if|if
condition|(
name|BASEADDR
argument_list|(
name|sec
argument_list|)
operator|<=
name|page_end
condition|)
name|search_addr
operator|=
name|page_end
operator|+
literal|1
expr_stmt|;
else|else
name|search_addr
operator|=
name|BASEADDR
argument_list|(
name|sec
argument_list|)
expr_stmt|;
comment|/* Found a page => more work to do.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|new_pass
condition|)
block|{
name|new_pass
operator|=
name|FALSE
expr_stmt|;
name|changed
operator|=
name|FALSE
expr_stmt|;
name|page_start
operator|=
name|PAGENO
argument_list|(
name|search_addr
argument_list|)
expr_stmt|;
name|page_end
operator|=
name|page_start
operator||
literal|0x00003FFF
expr_stmt|;
block|}
comment|/* Only process sections in range.  */
if|if
condition|(
operator|(
name|BASEADDR
argument_list|(
name|sec
argument_list|)
operator|+
name|sec
operator|->
name|_cooked_size
operator|>=
name|page_start
operator|)
operator|&&
operator|(
name|BASEADDR
argument_list|(
name|sec
argument_list|)
operator|<=
name|page_end
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|ip2k_elf_relax_section_page
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|&
name|changed
argument_list|,
operator|&
name|misc
argument_list|,
name|page_start
argument_list|,
name|page_end
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Perform some house keeping after relaxing the section.  */
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
else|else
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the section contents for elf_link_input_bfd.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
block|}
block|}
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* This function handles relaxation of a section in a specific page.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ip2k_elf_relax_section_page
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|again
parameter_list|,
name|misc
parameter_list|,
name|page_start
parameter_list|,
name|page_end
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_boolean
modifier|*
name|again
decl_stmt|;
name|struct
name|misc
modifier|*
name|misc
decl_stmt|;
name|unsigned
name|long
name|page_start
decl_stmt|;
name|unsigned
name|long
name|page_end
decl_stmt|;
block|{
name|Elf_Internal_Rela
modifier|*
name|irelend
init|=
name|misc
operator|->
name|irelbase
operator|+
name|sec
operator|->
name|reloc_count
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|;
name|int
name|switch_table_128
decl_stmt|;
name|int
name|switch_table_256
decl_stmt|;
comment|/* Walk thru the section looking for relaxation opportunities.  */
for|for
control|(
name|irel
operator|=
name|misc
operator|->
name|irelbase
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_IP2K_PAGE3
condition|)
comment|/* Ignore non page instructions.  */
continue|continue;
if|if
condition|(
name|BASEADDR
argument_list|(
name|sec
argument_list|)
operator|+
name|irel
operator|->
name|r_offset
operator|<
name|page_start
condition|)
comment|/* Ignore page instructions on earlier page - they have 	   already been processed. Remember that there is code flow 	   that crosses a page boundary.  */
continue|continue;
if|if
condition|(
name|BASEADDR
argument_list|(
name|sec
argument_list|)
operator|+
name|irel
operator|->
name|r_offset
operator|>
name|page_end
condition|)
comment|/* Flow beyond end of page => nothing more to do for this page.  */
return|return
name|TRUE
return|;
comment|/* Detect switch tables.  */
name|switch_table_128
operator|=
name|ip2k_is_switch_table_128
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
argument_list|,
name|misc
operator|->
name|contents
argument_list|)
expr_stmt|;
name|switch_table_256
operator|=
name|ip2k_is_switch_table_256
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
argument_list|,
name|misc
operator|->
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|switch_table_128
operator|>
literal|0
operator|)
operator|||
operator|(
name|switch_table_256
operator|>
literal|0
operator|)
condition|)
comment|/* If the index is greater than 0 then it has already been processed.  */
continue|continue;
if|if
condition|(
name|switch_table_128
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ip2k_relax_switch_table_128
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
argument_list|,
name|again
argument_list|,
name|misc
argument_list|)
condition|)
return|return
name|FALSE
return|;
continue|continue;
block|}
if|if
condition|(
name|switch_table_256
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ip2k_relax_switch_table_256
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
argument_list|,
name|again
argument_list|,
name|misc
argument_list|)
condition|)
return|return
name|FALSE
return|;
continue|continue;
block|}
comment|/* Simple relax.  */
if|if
condition|(
name|ip2k_test_page_insn
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
argument_list|,
name|misc
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ip2k_delete_page_insn
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
argument_list|,
name|again
argument_list|,
name|misc
argument_list|)
condition|)
return|return
name|FALSE
return|;
continue|continue;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Parts of a Stabs entry.  */
end_comment

begin_define
define|#
directive|define
name|STRDXOFF
value|(0)
end_define

begin_define
define|#
directive|define
name|TYPEOFF
value|(4)
end_define

begin_define
define|#
directive|define
name|OTHEROFF
value|(5)
end_define

begin_define
define|#
directive|define
name|DESCOFF
value|(6)
end_define

begin_define
define|#
directive|define
name|VALOFF
value|(8)
end_define

begin_define
define|#
directive|define
name|STABSIZE
value|(12)
end_define

begin_comment
comment|/* Adjust all the relocations entries after adding or inserting instructions.  */
end_comment

begin_function
specifier|static
name|void
name|adjust_all_relocations
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|addr
parameter_list|,
name|endaddr
parameter_list|,
name|count
parameter_list|,
name|noadj
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|bfd_vma
name|endaddr
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|noadj
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
decl_stmt|,
modifier|*
name|isym
decl_stmt|,
modifier|*
name|isymend
decl_stmt|;
name|unsigned
name|int
name|shndx
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|,
modifier|*
name|irelbase
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|end_hashes
decl_stmt|;
name|unsigned
name|int
name|symcount
decl_stmt|;
name|asection
modifier|*
name|stab
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
name|shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
name|irelbase
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
expr_stmt|;
name|irelend
operator|=
name|irelbase
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|irelbase
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_IP2K_NONE
condition|)
block|{
comment|/* Get the value of the symbol referred to by the reloc.  */
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|asection
modifier|*
name|sym_sec
decl_stmt|;
comment|/* A local symbol.  */
name|isym
operator|=
name|isymbuf
operator|+
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|sym_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|shndx
condition|)
block|{
name|bfd_vma
name|baseaddr
init|=
name|BASEADDR
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|bfd_vma
name|symval
init|=
name|BASEADDR
argument_list|(
name|sym_sec
argument_list|)
operator|+
name|isym
operator|->
name|st_value
operator|+
name|irel
operator|->
name|r_addend
decl_stmt|;
if|if
condition|(
operator|(
name|baseaddr
operator|+
name|addr
operator|+
name|noadj
operator|)
operator|<=
name|symval
operator|&&
name|symval
operator|<
operator|(
name|baseaddr
operator|+
name|endaddr
operator|)
condition|)
name|irel
operator|->
name|r_addend
operator|+=
name|count
expr_stmt|;
block|}
block|}
block|}
comment|/* Do this only for PC space relocations.  */
if|if
condition|(
name|addr
operator|<=
name|irel
operator|->
name|r_offset
operator|&&
name|irel
operator|->
name|r_offset
operator|<
name|endaddr
condition|)
name|irel
operator|->
name|r_offset
operator|+=
name|count
expr_stmt|;
block|}
comment|/* Now fix the stab relocations.  */
name|stab
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".stab"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stab
condition|)
block|{
name|bfd_byte
modifier|*
name|stabcontents
decl_stmt|,
modifier|*
name|stabend
decl_stmt|,
modifier|*
name|stabp
decl_stmt|;
name|irelbase
operator|=
name|elf_section_data
argument_list|(
name|stab
argument_list|)
operator|->
name|relocs
expr_stmt|;
name|irelend
operator|=
name|irelbase
operator|+
name|stab
operator|->
name|reloc_count
expr_stmt|;
comment|/* Pull out the contents of the stab section.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|stab
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|stabcontents
operator|=
name|elf_section_data
argument_list|(
name|stab
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
else|else
block|{
name|stabcontents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|stab
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|stabcontents
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|stab
argument_list|,
name|stabcontents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|stab
operator|->
name|_raw_size
argument_list|)
condition|)
return|return;
comment|/* We need to remember this.  */
name|elf_section_data
argument_list|(
name|stab
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|stabcontents
expr_stmt|;
block|}
name|stabend
operator|=
name|stabcontents
operator|+
name|stab
operator|->
name|_raw_size
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|irelbase
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_IP2K_NONE
condition|)
block|{
comment|/* Get the value of the symbol referred to by the reloc.  */
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|asection
modifier|*
name|sym_sec
decl_stmt|;
comment|/* A local symbol.  */
name|isym
operator|=
name|isymbuf
operator|+
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|sym_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_sec
operator|==
name|sec
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|strx
decl_stmt|;
name|unsigned
name|char
name|type
decl_stmt|,
name|other
decl_stmt|;
name|unsigned
name|short
name|desc
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|bfd_vma
name|baseaddr
init|=
name|BASEADDR
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|bfd_vma
name|symval
init|=
name|BASEADDR
argument_list|(
name|sym_sec
argument_list|)
operator|+
name|isym
operator|->
name|st_value
operator|+
name|irel
operator|->
name|r_addend
decl_stmt|;
if|if
condition|(
operator|(
name|baseaddr
operator|+
name|addr
operator|)
operator|<=
name|symval
operator|&&
name|symval
operator|<=
operator|(
name|baseaddr
operator|+
name|endaddr
operator|)
condition|)
name|irel
operator|->
name|r_addend
operator|+=
name|count
expr_stmt|;
comment|/* Go hunt up a function and fix its line info if needed.  */
name|stabp
operator|=
name|stabcontents
operator|+
name|irel
operator|->
name|r_offset
operator|-
literal|8
expr_stmt|;
comment|/* Go pullout the stab entry.  */
name|strx
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|stabp
operator|+
name|STRDXOFF
argument_list|)
expr_stmt|;
name|type
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|stabp
operator|+
name|TYPEOFF
argument_list|)
expr_stmt|;
name|other
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|stabp
operator|+
name|OTHEROFF
argument_list|)
expr_stmt|;
name|desc
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|stabp
operator|+
name|DESCOFF
argument_list|)
expr_stmt|;
name|value
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|stabp
operator|+
name|VALOFF
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_get_stab_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"FUN"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|function_adjusted
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|symval
operator|>
operator|(
name|baseaddr
operator|+
name|addr
operator|)
condition|)
comment|/* Not in this function.  */
continue|continue;
comment|/* Hey we got a function hit.  */
name|stabp
operator|+=
name|STABSIZE
expr_stmt|;
for|for
control|(
init|;
name|stabp
operator|<
name|stabend
condition|;
name|stabp
operator|+=
name|STABSIZE
control|)
block|{
comment|/* Go pullout the stab entry.  */
name|strx
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|stabp
operator|+
name|STRDXOFF
argument_list|)
expr_stmt|;
name|type
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|stabp
operator|+
name|TYPEOFF
argument_list|)
expr_stmt|;
name|other
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
name|stabp
operator|+
name|OTHEROFF
argument_list|)
expr_stmt|;
name|desc
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|stabp
operator|+
name|DESCOFF
argument_list|)
expr_stmt|;
name|value
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|stabp
operator|+
name|VALOFF
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_get_stab_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"FUN"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Hit another function entry.  */
if|if
condition|(
name|function_adjusted
condition|)
block|{
comment|/* Adjust the value.  */
name|value
operator|+=
name|count
expr_stmt|;
comment|/* We need to put it back.  */
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|stabp
operator|+
name|VALOFF
argument_list|)
expr_stmt|;
block|}
comment|/* And then bale out.  */
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"SLINE"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Got a line entry.  */
if|if
condition|(
operator|(
name|baseaddr
operator|+
name|addr
operator|)
operator|<=
operator|(
name|symval
operator|+
name|value
operator|)
condition|)
block|{
comment|/* Adjust the line entry.  */
name|value
operator|+=
name|count
expr_stmt|;
comment|/* We need to put it back.  */
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|value
argument_list|,
name|stabp
operator|+
name|VALOFF
argument_list|)
expr_stmt|;
name|function_adjusted
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
block|}
block|}
comment|/* When adding an instruction back it is sometimes necessary to move any      global or local symbol that was referencing the first instruction of      the moved block to refer to the first instruction of the inserted block.       For example adding a PAGE instruction before a CALL or JMP requires      that any label on the CALL or JMP is moved to the PAGE insn.  */
name|addr
operator|+=
name|noadj
expr_stmt|;
comment|/* Adjust the local symbols defined in this section.  */
name|isymend
operator|=
name|isymbuf
operator|+
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
name|isym
operator|=
name|isymbuf
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
control|)
block|{
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|shndx
operator|&&
name|addr
operator|<=
name|isym
operator|->
name|st_value
operator|&&
name|isym
operator|->
name|st_value
operator|<
name|endaddr
condition|)
name|isym
operator|->
name|st_value
operator|+=
name|count
expr_stmt|;
block|}
comment|/* Now adjust the global symbols defined in this section.  */
name|symcount
operator|=
operator|(
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|end_hashes
operator|=
name|sym_hashes
operator|+
name|symcount
expr_stmt|;
for|for
control|(
init|;
name|sym_hashes
operator|<
name|end_hashes
condition|;
name|sym_hashes
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|sym_hash
init|=
operator|*
name|sym_hashes
decl_stmt|;
if|if
condition|(
operator|(
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|sec
condition|)
block|{
if|if
condition|(
name|addr
operator|<=
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|<
name|endaddr
condition|)
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+=
name|count
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Delete some bytes from a section while relaxing.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ip2k_elf_relax_delete_bytes
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|addr
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|bfd_byte
modifier|*
name|contents
init|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
decl_stmt|;
name|bfd_vma
name|endaddr
init|=
name|sec
operator|->
name|_cooked_size
decl_stmt|;
comment|/* Actually delete the bytes.  */
name|memmove
argument_list|(
name|contents
operator|+
name|addr
argument_list|,
name|contents
operator|+
name|addr
operator|+
name|count
argument_list|,
name|endaddr
operator|-
name|addr
operator|-
name|count
argument_list|)
expr_stmt|;
name|sec
operator|->
name|_cooked_size
operator|-=
name|count
expr_stmt|;
name|adjust_all_relocations
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|addr
operator|+
name|count
argument_list|,
name|endaddr
argument_list|,
operator|-
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* XXX: The following code is the result of a cut&paste.  This unfortunate    practice is very widespread in the various target back-end files.  */
end_comment

begin_comment
comment|/* Set the howto pointer for a IP2K ELF reloc.  */
end_comment

begin_function
specifier|static
name|void
name|ip2k_info_to_howto_rela
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|unsigned
name|int
name|r_type
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
default|default:
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|ip2k_elf_howto_table
index|[
name|r_type
index|]
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Perform a single relocation.    By default we use the standard BFD routines.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|ip2k_final_link_relocate
parameter_list|(
name|howto
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|rel
parameter_list|,
name|relocation
parameter_list|)
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
block|{
specifier|static
name|bfd_vma
name|page_addr
init|=
literal|0
decl_stmt|;
name|bfd_reloc_status_type
name|r
init|=
name|bfd_reloc_ok
decl_stmt|;
switch|switch
condition|(
name|howto
operator|->
name|type
condition|)
block|{
comment|/* Handle data space relocations.  */
case|case
name|R_IP2K_FR9
case|:
case|case
name|R_IP2K_BANK
case|:
if|if
condition|(
operator|(
name|relocation
operator|&
name|IP2K_DATA_MASK
operator|)
operator|==
name|IP2K_DATA_VALUE
condition|)
name|relocation
operator|&=
operator|~
name|IP2K_DATA_MASK
expr_stmt|;
else|else
name|r
operator|=
name|bfd_reloc_notsupported
expr_stmt|;
break|break;
case|case
name|R_IP2K_LO8DATA
case|:
case|case
name|R_IP2K_HI8DATA
case|:
case|case
name|R_IP2K_EX8DATA
case|:
break|break;
comment|/* Handle insn space relocations.  */
case|case
name|R_IP2K_PAGE3
case|:
name|page_addr
operator|=
name|BASEADDR
argument_list|(
name|input_section
argument_list|)
operator|+
name|rel
operator|->
name|r_offset
expr_stmt|;
if|if
condition|(
operator|(
name|relocation
operator|&
name|IP2K_INSN_MASK
operator|)
operator|==
name|IP2K_INSN_VALUE
condition|)
name|relocation
operator|&=
operator|~
name|IP2K_INSN_MASK
expr_stmt|;
else|else
name|r
operator|=
name|bfd_reloc_notsupported
expr_stmt|;
break|break;
case|case
name|R_IP2K_ADDR16CJP
case|:
if|if
condition|(
name|BASEADDR
argument_list|(
name|input_section
argument_list|)
operator|+
name|rel
operator|->
name|r_offset
operator|!=
name|page_addr
operator|+
literal|2
condition|)
block|{
comment|/* No preceding page instruction, verify that it isn't needed.  */
if|if
condition|(
name|PAGENO
argument_list|(
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|)
operator|!=
name|ip2k_nominal_page_bits
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|contents
argument_list|)
condition|)
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ip2k linker: missing page instruction at 0x%08lx (dest = 0x%08lx)."
argument_list|)
argument_list|,
name|BASEADDR
argument_list|(
name|input_section
argument_list|)
operator|+
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ip2k_relaxed
condition|)
block|{
comment|/* Preceding page instruction. Verify that the page instruction is              really needed. One reason for the relaxation to miss a page is if              the section is not marked as executable.  */
if|if
condition|(
operator|!
name|ip2k_is_switch_table_128
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
operator|-
literal|2
argument_list|,
name|contents
argument_list|)
operator|&&
operator|!
name|ip2k_is_switch_table_256
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
operator|-
literal|2
argument_list|,
name|contents
argument_list|)
operator|&&
operator|(
name|PAGENO
argument_list|(
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|)
operator|==
name|ip2k_nominal_page_bits
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
operator|-
literal|2
argument_list|,
name|contents
argument_list|)
operator|)
condition|)
name|_bfd_error_handler
argument_list|(
name|_
argument_list|(
literal|"ip2k linker: redundant page instruction at 0x%08lx (dest = 0x%08lx)."
argument_list|)
argument_list|,
name|page_addr
argument_list|,
name|relocation
operator|+
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|relocation
operator|&
name|IP2K_INSN_MASK
operator|)
operator|==
name|IP2K_INSN_VALUE
condition|)
name|relocation
operator|&=
operator|~
name|IP2K_INSN_MASK
expr_stmt|;
else|else
name|r
operator|=
name|bfd_reloc_notsupported
expr_stmt|;
break|break;
case|case
name|R_IP2K_LO8INSN
case|:
case|case
name|R_IP2K_HI8INSN
case|:
case|case
name|R_IP2K_PC_SKIP
case|:
if|if
condition|(
operator|(
name|relocation
operator|&
name|IP2K_INSN_MASK
operator|)
operator|==
name|IP2K_INSN_VALUE
condition|)
name|relocation
operator|&=
operator|~
name|IP2K_INSN_MASK
expr_stmt|;
else|else
name|r
operator|=
name|bfd_reloc_notsupported
expr_stmt|;
break|break;
case|case
name|R_IP2K_16
case|:
comment|/* If this is a relocation involving a TEXT 	 symbol, reduce it to a word address.  */
if|if
condition|(
operator|(
name|relocation
operator|&
name|IP2K_INSN_MASK
operator|)
operator|==
name|IP2K_INSN_VALUE
condition|)
name|howto
operator|=
operator|&
name|ip2k_elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_IP2K_TEXT
index|]
expr_stmt|;
break|break;
comment|/* Pass others through.  */
default|default:
break|break;
block|}
comment|/* Only install relocation if above tests did not disqualify it.  */
if|if
condition|(
name|r
operator|==
name|bfd_reloc_ok
condition|)
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Relocate a IP2K ELF section.     The RELOCATE_SECTION function is called by the new ELF backend linker    to handle the relocations for a section.     The relocs are always passed as Rela structures; if the section    actually uses Rel structures, the r_addend field will always be    zero.     This function is responsible for adjusting the section contents as    necessary, and (if using Rela relocs and generating a relocatable    output file) adjusting the reloc addend as necessary.     This function does not have to worry about setting the reloc    address or the reloc symbol index.     LOCAL_SYMS is a pointer to the swapped in local symbols.     LOCAL_SECTIONS is an array giving the section in the input file    corresponding to the st_shndx field of each local symbol.     The global hash table entry for the global symbols can be found    via elf_sym_hashes (input_bfd).     When generating relocatable output, this function must handle    STB_LOCAL/STT_SECTION symbols specially.  The output symbol is    going to be the section symbol corresponding to the output    section, which means that the addend must be adjusted    accordingly.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|ip2k_elf_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|int
name|r_type
decl_stmt|;
comment|/* This is a final link.  */
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|howto
operator|=
name|ip2k_elf_howto_table
operator|+
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
name|BASEADDR
argument_list|(
name|sec
argument_list|)
operator|+
name|sym
operator|->
name|st_value
expr_stmt|;
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|name
operator|==
name|NULL
operator|)
condition|?
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
else|:
name|name
expr_stmt|;
block|}
else|else
block|{
name|bfd_boolean
name|warned
decl_stmt|;
name|bfd_boolean
name|unresolved_reloc
decl_stmt|;
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
block|}
comment|/* Finally, the sole IP2K-specific part.  */
name|r
operator|=
name|ip2k_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
argument_list|,
name|relocation
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_overflow
case|:
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_undefined
case|:
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: out of range error"
argument_list|)
expr_stmt|;
break|break;
comment|/* This is how ip2k_final_link_relocate tells us of a non-kosher                  reference between insn& data address spaces.  */
case|case
name|bfd_reloc_notsupported
case|:
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
comment|/* Only if it's not an unresolved symbol.  */
name|msg
operator|=
name|_
argument_list|(
literal|"unsupported relocation between data/insn address spaces"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_reloc_dangerous
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: dangerous relocation"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unknown error"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|msg
condition|)
name|r
operator|=
name|info
operator|->
name|callbacks
operator|->
name|warning
argument_list|(
name|info
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|asection
modifier|*
name|ip2k_elf_gc_mark_hook
parameter_list|(
name|sec
parameter_list|,
name|info
parameter_list|,
name|rel
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|case R_IP2K_GNU_VTINHERIT:       case R_IP2K_GNU_VTENTRY:         break;
endif|#
directive|endif
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
default|default:
break|break;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|elf_bad_symtab
argument_list|(
name|sec
operator|->
name|owner
argument_list|)
operator|&&
name|ELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STB_LOCAL
operator|)
operator|&&
operator|!
operator|(
operator|(
name|sym
operator|->
name|st_shndx
operator|<=
literal|0
operator|||
name|sym
operator|->
name|st_shndx
operator|>=
name|SHN_LORESERVE
operator|)
operator|&&
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_COMMON
operator|)
condition|)
return|return
name|bfd_section_from_elf_index
argument_list|(
name|sec
operator|->
name|owner
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|bfd_boolean
name|ip2k_elf_gc_sweep_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* We don't use got and plt entries for ip2k.  */
return|return
name|TRUE
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_ip2k_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-ip2k"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_ip2k
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_IP2K
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT1
value|EM_IP2K_OLD
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|1
end_define

begin_comment
comment|/* No pages on the IP2K.  */
end_comment

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|NULL
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|ip2k_info_to_howto_rela
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_rela_normal
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|ip2k_elf_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|ip2k_elf_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|ip2k_elf_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_symbol_leading_char
value|'_'
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|ip2k_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_relax_section
value|ip2k_elf_relax_section
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

