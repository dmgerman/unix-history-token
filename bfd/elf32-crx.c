begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for National Semiconductor's CRX ELF    Copyright 2004, 2005, 2006, 2007 Free Software Foundation, Inc.    Written by Tomer Levi, NSC, Israel.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/crx.h"
end_include

begin_function_decl
specifier|static
name|reloc_howto_type
modifier|*
name|elf_crx_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|bfd_reloc_code_real_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_crx_info_to_howto
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|arelent
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|elf32_crx_relax_delete_bytes
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_reloc_status_type
name|crx_elf_final_link_relocate
parameter_list|(
name|reloc_howto_type
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|bfd_vma
parameter_list|,
name|bfd_vma
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|elf32_crx_relocate_section
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|Elf_Internal_Rela
modifier|*
parameter_list|,
name|Elf_Internal_Sym
modifier|*
parameter_list|,
name|asection
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_boolean
name|elf32_crx_relax_section
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|bfd_boolean
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bfd_byte
modifier|*
name|elf32_crx_get_relocated_section_contents
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
parameter_list|,
name|struct
name|bfd_link_order
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|bfd_boolean
parameter_list|,
name|asymbol
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* crx_reloc_map array maps BFD relocation enum into a CRGAS relocation type.  */
end_comment

begin_struct
struct|struct
name|crx_reloc_map
block|{
name|bfd_reloc_code_real_type
name|bfd_reloc_enum
decl_stmt|;
comment|/* BFD relocation enum.  */
name|unsigned
name|short
name|crx_reloc_type
decl_stmt|;
comment|/* CRX relocation type.  */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|crx_reloc_map
name|crx_reloc_map
index|[
name|R_CRX_MAX
index|]
init|=
block|{
block|{
name|BFD_RELOC_NONE
block|,
name|R_CRX_NONE
block|}
block|,
block|{
name|BFD_RELOC_CRX_REL4
block|,
name|R_CRX_REL4
block|}
block|,
block|{
name|BFD_RELOC_CRX_REL8
block|,
name|R_CRX_REL8
block|}
block|,
block|{
name|BFD_RELOC_CRX_REL8_CMP
block|,
name|R_CRX_REL8_CMP
block|}
block|,
block|{
name|BFD_RELOC_CRX_REL16
block|,
name|R_CRX_REL16
block|}
block|,
block|{
name|BFD_RELOC_CRX_REL24
block|,
name|R_CRX_REL24
block|}
block|,
block|{
name|BFD_RELOC_CRX_REL32
block|,
name|R_CRX_REL32
block|}
block|,
block|{
name|BFD_RELOC_CRX_REGREL12
block|,
name|R_CRX_REGREL12
block|}
block|,
block|{
name|BFD_RELOC_CRX_REGREL22
block|,
name|R_CRX_REGREL22
block|}
block|,
block|{
name|BFD_RELOC_CRX_REGREL28
block|,
name|R_CRX_REGREL28
block|}
block|,
block|{
name|BFD_RELOC_CRX_REGREL32
block|,
name|R_CRX_REGREL32
block|}
block|,
block|{
name|BFD_RELOC_CRX_ABS16
block|,
name|R_CRX_ABS16
block|}
block|,
block|{
name|BFD_RELOC_CRX_ABS32
block|,
name|R_CRX_ABS32
block|}
block|,
block|{
name|BFD_RELOC_CRX_NUM8
block|,
name|R_CRX_NUM8
block|}
block|,
block|{
name|BFD_RELOC_CRX_NUM16
block|,
name|R_CRX_NUM16
block|}
block|,
block|{
name|BFD_RELOC_CRX_NUM32
block|,
name|R_CRX_NUM32
block|}
block|,
block|{
name|BFD_RELOC_CRX_IMM16
block|,
name|R_CRX_IMM16
block|}
block|,
block|{
name|BFD_RELOC_CRX_IMM32
block|,
name|R_CRX_IMM32
block|}
block|,
block|{
name|BFD_RELOC_CRX_SWITCH8
block|,
name|R_CRX_SWITCH8
block|}
block|,
block|{
name|BFD_RELOC_CRX_SWITCH16
block|,
name|R_CRX_SWITCH16
block|}
block|,
block|{
name|BFD_RELOC_CRX_SWITCH32
block|,
name|R_CRX_SWITCH32
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|crx_elf_howto_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|R_CRX_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRX_NONE"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CRX_REL4
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size */
literal|4
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRX_REL4"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xf
argument_list|,
comment|/* src_mask */
literal|0xf
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CRX_REL8
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size */
literal|8
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRX_REL8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xff
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CRX_REL8_CMP
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size */
literal|8
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRX_REL8_CMP"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xff
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CRX_REL16
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size */
literal|16
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRX_REL16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CRX_REL24
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size */
literal|24
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRX_REL24"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffff
argument_list|,
comment|/* src_mask */
literal|0xffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CRX_REL32
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size */
literal|32
argument_list|,
comment|/* bitsize */
name|TRUE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRX_REL32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CRX_REGREL12
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size */
literal|12
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRX_REGREL12"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xfff
argument_list|,
comment|/* src_mask */
literal|0xfff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CRX_REGREL22
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size */
literal|22
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRX_REGREL22"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0x3fffff
argument_list|,
comment|/* src_mask */
literal|0x3fffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CRX_REGREL28
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size */
literal|28
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRX_REGREL28"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xfffffff
argument_list|,
comment|/* src_mask */
literal|0xfffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CRX_REGREL32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRX_REGREL32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CRX_ABS16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRX_ABS16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CRX_ABS32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRX_ABS32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CRX_NUM8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRX_NUM8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xff
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CRX_NUM16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRX_NUM16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CRX_NUM32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRX_NUM32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CRX_IMM16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRX_IMM16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_CRX_IMM32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size */
literal|32
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRX_IMM32"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|FALSE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* An 8 bit switch table entry.  This is generated for an expression      such as ``.byte L1 - L2''.  The offset holds the difference      between the reloc address and L2.  */
name|HOWTO
argument_list|(
name|R_CRX_SWITCH8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRX_SWITCH8"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xff
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 16 bit switch table entry.  This is generated for an expression      such as ``.word L1 - L2''.  The offset holds the difference      between the reloc address and L2.  */
name|HOWTO
argument_list|(
name|R_CRX_SWITCH16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRX_SWITCH16"
argument_list|,
comment|/* name */
name|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|TRUE
argument_list|)
block|,
comment|/* pcrel_offset */
comment|/* A 32 bit switch table entry.  This is generated for an expression      such as ``.long L1 - L2''.  The offset holds the difference      between the reloc address and L2.  */
name|HOWTO
argument_list|(
argument|R_CRX_SWITCH32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
argument|FALSE
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
argument|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
argument|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_CRX_SWITCH32"
argument_list|,
comment|/* name */
argument|FALSE
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
argument|TRUE
argument_list|)
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Retrieve a howto ptr using a BFD reloc_code.  */
end_comment

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|elf_crx_reloc_type_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_reloc_code_real_type
name|code
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|R_CRX_MAX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|code
operator|==
name|crx_reloc_map
index|[
name|i
index|]
operator|.
name|bfd_reloc_enum
condition|)
return|return
operator|&
name|crx_elf_howto_table
index|[
name|crx_reloc_map
index|[
name|i
index|]
operator|.
name|crx_reloc_type
index|]
return|;
name|printf
argument_list|(
literal|"This relocation Type is not supported -0x%x\n"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|elf_crx_reloc_name_lookup
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|r_name
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|crx_elf_howto_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|crx_elf_howto_table
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|crx_elf_howto_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcasecmp
argument_list|(
name|crx_elf_howto_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|r_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|crx_elf_howto_table
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Retrieve a howto ptr using an internal relocation entry.  */
end_comment

begin_function
specifier|static
name|void
name|elf_crx_info_to_howto
parameter_list|(
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|arelent
modifier|*
name|cache_ptr
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|dst
parameter_list|)
block|{
name|unsigned
name|int
name|r_type
init|=
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
decl_stmt|;
name|BFD_ASSERT
argument_list|(
name|r_type
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_CRX_MAX
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|crx_elf_howto_table
index|[
name|r_type
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform a relocation as part of a final link.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|crx_elf_final_link_relocate
parameter_list|(
name|reloc_howto_type
modifier|*
name|howto
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|bfd_vma
name|offset
parameter_list|,
name|bfd_vma
name|Rvalue
parameter_list|,
name|bfd_vma
name|addend
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
parameter_list|,
name|asection
modifier|*
name|sec
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|is_local
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|short
name|r_type
init|=
name|howto
operator|->
name|type
decl_stmt|;
name|bfd_byte
modifier|*
name|hit_data
init|=
name|contents
operator|+
name|offset
decl_stmt|;
name|bfd_vma
name|reloc_bits
decl_stmt|,
name|check
decl_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_CRX_IMM16
case|:
case|case
name|R_CRX_IMM32
case|:
case|case
name|R_CRX_ABS16
case|:
case|case
name|R_CRX_ABS32
case|:
case|case
name|R_CRX_REL8_CMP
case|:
case|case
name|R_CRX_REL16
case|:
case|case
name|R_CRX_REL24
case|:
case|case
name|R_CRX_REL32
case|:
case|case
name|R_CRX_REGREL12
case|:
case|case
name|R_CRX_REGREL22
case|:
case|case
name|R_CRX_REGREL28
case|:
case|case
name|R_CRX_REGREL32
case|:
comment|/* 'hit_data' is relative to the start of the instruction, not the 	  relocation offset. Advance it to account for the exact offset.  */
name|hit_data
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|R_CRX_REL4
case|:
comment|/* This relocation type is used only in 'Branch if Equal to 0' 	  instructions and requires special handling.  */
name|Rvalue
operator|-=
literal|1
expr_stmt|;
break|break;
case|case
name|R_CRX_NONE
case|:
return|return
name|bfd_reloc_ok
return|;
break|break;
case|case
name|R_CRX_SWITCH8
case|:
case|case
name|R_CRX_SWITCH16
case|:
case|case
name|R_CRX_SWITCH32
case|:
comment|/* We only care about the addend, where the difference between  	  expressions is kept.  */
name|Rvalue
operator|=
literal|0
expr_stmt|;
default|default:
break|break;
block|}
if|if
condition|(
name|howto
operator|->
name|pc_relative
condition|)
block|{
comment|/* Subtract the address of the section containing the location.  */
name|Rvalue
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
comment|/* Subtract the position of the location within the section.  */
name|Rvalue
operator|-=
name|offset
expr_stmt|;
block|}
comment|/* Add in supplied addend.  */
name|Rvalue
operator|+=
name|addend
expr_stmt|;
comment|/* Complain if the bitfield overflows, whether it is considered      as signed or unsigned.  */
name|check
operator|=
name|Rvalue
operator|>>
name|howto
operator|->
name|rightshift
expr_stmt|;
comment|/* Assumes two's complement.  This expression avoids      overflow if howto->bitsize is the number of bits in      bfd_vma.  */
name|reloc_bits
operator|=
operator|(
operator|(
operator|(
literal|1
operator|<<
operator|(
name|howto
operator|->
name|bitsize
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator||
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|bfd_vma
operator|)
name|check
operator|&
operator|~
name|reloc_bits
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
operator|(
name|bfd_vma
operator|)
name|check
operator|&
operator|~
name|reloc_bits
operator|)
operator|!=
operator|(
operator|-
operator|(
name|bfd_vma
operator|)
literal|1
operator|&
operator|~
name|reloc_bits
operator|)
operator|)
condition|)
block|{
comment|/* The above right shift is incorrect for a signed 	 value.  See if turning on the upper bits fixes the 	 overflow.  */
if|if
condition|(
name|howto
operator|->
name|rightshift
operator|&&
operator|(
name|bfd_signed_vma
operator|)
name|Rvalue
operator|<
literal|0
condition|)
block|{
name|check
operator||=
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|&
operator|~
operator|(
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|>>
name|howto
operator|->
name|rightshift
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|bfd_vma
operator|)
name|check
operator|&
operator|~
name|reloc_bits
operator|)
operator|!=
operator|(
operator|-
operator|(
name|bfd_vma
operator|)
literal|1
operator|&
operator|~
name|reloc_bits
operator|)
condition|)
return|return
name|bfd_reloc_overflow
return|;
block|}
else|else
return|return
name|bfd_reloc_overflow
return|;
block|}
comment|/* Drop unwanted bits from the value we are relocating to.  */
name|Rvalue
operator|>>=
operator|(
name|bfd_vma
operator|)
name|howto
operator|->
name|rightshift
expr_stmt|;
comment|/* Apply dst_mask to select only relocatable part of the insn.  */
name|Rvalue
operator|&=
name|howto
operator|->
name|dst_mask
expr_stmt|;
switch|switch
condition|(
name|howto
operator|->
name|size
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|r_type
operator|==
name|R_CRX_REL4
condition|)
block|{
name|Rvalue
operator|<<=
literal|4
expr_stmt|;
name|Rvalue
operator||=
operator|(
name|bfd_get_8
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|&
literal|0x0f
operator|)
expr_stmt|;
block|}
name|bfd_put_8
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|Rvalue
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|r_type
operator|==
name|R_CRX_REGREL12
condition|)
name|Rvalue
operator||=
operator|(
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|&
literal|0xf000
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|Rvalue
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|r_type
operator|==
name|R_CRX_REL24
operator|||
name|r_type
operator|==
name|R_CRX_REGREL22
operator|||
name|r_type
operator|==
name|R_CRX_REGREL28
condition|)
name|Rvalue
operator||=
operator|(
operator|(
operator|(
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
argument_list|)
operator|<<
literal|16
operator|)
operator||
name|bfd_get_16
argument_list|(
name|input_bfd
argument_list|,
name|hit_data
operator|+
literal|2
argument_list|)
operator|)
operator|&
operator|~
name|howto
operator|->
name|dst_mask
operator|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
name|R_CRX_NUM32
operator|||
name|r_type
operator|==
name|R_CRX_SWITCH32
condition|)
comment|/* Relocation on DATA is purely little-endian, that is, for a 	    multi-byte datum, the lowest address in memory contains the 	    little end of the datum, that is, the least significant byte. 	    Therefore we use BFD's byte Putting functions.  */
name|bfd_put_32
argument_list|(
name|input_bfd
argument_list|,
name|Rvalue
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
else|else
comment|/* Relocation on INSTRUCTIONS is different : Instructions are 	    word-addressable, that is, each word itself is arranged according 	    to little-endian convention, whereas the words are arranged with 	    respect to one another in BIG ENDIAN fashion. 	    When there is an immediate value that spans a word boundary, it is 	    split in a big-endian way with respect to the words.  */
block|{
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|Rvalue
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|input_bfd
argument_list|,
name|Rvalue
operator|&
literal|0xffff
argument_list|,
name|hit_data
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
return|return
name|bfd_reloc_notsupported
return|;
block|}
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* Delete some bytes from a section while relaxing.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_crx_relax_delete_bytes
parameter_list|(
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|bfd_vma
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|unsigned
name|int
name|sec_shndx
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irelalign
decl_stmt|;
name|bfd_vma
name|toaddr
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymend
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|end_hashes
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|start_hashes
decl_stmt|;
name|unsigned
name|int
name|symcount
decl_stmt|;
name|sec_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
comment|/* The deletion must stop at the next ALIGN reloc for an aligment      power larger than the number of bytes we are deleting.  */
name|irelalign
operator|=
name|NULL
expr_stmt|;
name|toaddr
operator|=
name|sec
operator|->
name|size
expr_stmt|;
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
expr_stmt|;
name|irelend
operator|=
name|irel
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
comment|/* Actually delete the bytes.  */
name|memmove
argument_list|(
name|contents
operator|+
name|addr
argument_list|,
name|contents
operator|+
name|addr
operator|+
name|count
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|toaddr
operator|-
name|addr
operator|-
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|sec
operator|->
name|size
operator|-=
name|count
expr_stmt|;
comment|/* Adjust all the relocs.  */
for|for
control|(
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
comment|/* Get the new reloc address.  */
if|if
condition|(
operator|(
name|irel
operator|->
name|r_offset
operator|>
name|addr
operator|&&
name|irel
operator|->
name|r_offset
operator|<
name|toaddr
operator|)
condition|)
name|irel
operator|->
name|r_offset
operator|-=
name|count
expr_stmt|;
block|}
comment|/* Adjust the local symbols defined in this section.  */
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|isym
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
for|for
control|(
name|isymend
operator|=
name|isym
operator|+
name|symtab_hdr
operator|->
name|sh_info
init|;
name|isym
operator|<
name|isymend
condition|;
name|isym
operator|++
control|)
block|{
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|sec_shndx
operator|&&
name|isym
operator|->
name|st_value
operator|>
name|addr
operator|&&
name|isym
operator|->
name|st_value
operator|<
name|toaddr
condition|)
block|{
comment|/* Adjust the addend of SWITCH relocations in this section,  	     which reference this local symbol.  */
for|for
control|(
name|irel
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|rsym
decl_stmt|;
name|bfd_vma
name|addsym
decl_stmt|,
name|subsym
decl_stmt|;
comment|/* Skip if not a SWITCH relocation.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_CRX_SWITCH8
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_CRX_SWITCH16
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_CRX_SWITCH32
condition|)
continue|continue;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|rsym
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
operator|+
name|r_symndx
expr_stmt|;
comment|/* Skip if not the local adjusted symbol.  */
if|if
condition|(
name|rsym
operator|!=
name|isym
condition|)
continue|continue;
name|addsym
operator|=
name|isym
operator|->
name|st_value
expr_stmt|;
name|subsym
operator|=
name|addsym
operator|-
name|irel
operator|->
name|r_addend
expr_stmt|;
comment|/* Fix the addend only when -->> (addsym> addr>= subsym).  */
if|if
condition|(
name|subsym
operator|<=
name|addr
condition|)
name|irel
operator|->
name|r_addend
operator|-=
name|count
expr_stmt|;
else|else
continue|continue;
block|}
name|isym
operator|->
name|st_value
operator|-=
name|count
expr_stmt|;
block|}
block|}
comment|/* Now adjust the global symbols defined in this section.  */
name|symcount
operator|=
operator|(
name|symtab_hdr
operator|->
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf32_External_Sym
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
operator|)
expr_stmt|;
name|sym_hashes
operator|=
name|start_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|end_hashes
operator|=
name|sym_hashes
operator|+
name|symcount
expr_stmt|;
for|for
control|(
init|;
name|sym_hashes
operator|<
name|end_hashes
condition|;
name|sym_hashes
operator|++
control|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|sym_hash
init|=
operator|*
name|sym_hashes
decl_stmt|;
comment|/* The '--wrap SYMBOL' option is causing a pain when the object file,  	 containing the definition of __wrap_SYMBOL, includes a direct  	 call to SYMBOL as well. Since both __wrap_SYMBOL and SYMBOL reference  	 the same symbol (which is __wrap_SYMBOL), but still exist as two  	 different symbols in 'sym_hashes', we don't want to adjust  	 the global symbol __wrap_SYMBOL twice.   	 This check is only relevant when symbols are being wrapped.  */
if|if
condition|(
name|link_info
operator|->
name|wrap_hash
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|cur_sym_hashes
decl_stmt|;
comment|/* Loop only over the symbols whom been already checked.  */
for|for
control|(
name|cur_sym_hashes
operator|=
name|start_hashes
init|;
name|cur_sym_hashes
operator|<
name|sym_hashes
condition|;
name|cur_sym_hashes
operator|++
control|)
block|{
comment|/* If the current symbol is identical to 'sym_hash', that means  		 the symbol was already adjusted (or at least checked).  */
if|if
condition|(
operator|*
name|cur_sym_hashes
operator|==
name|sym_hash
condition|)
break|break;
block|}
comment|/* Don't adjust the symbol again.  */
if|if
condition|(
name|cur_sym_hashes
operator|<
name|sym_hashes
condition|)
continue|continue;
block|}
if|if
condition|(
operator|(
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|sym_hash
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|==
name|sec
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|>
name|addr
operator|&&
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|<
name|toaddr
condition|)
name|sym_hash
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|-=
name|count
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This is a version of bfd_generic_get_relocated_section_contents    which uses elf32_crx_relocate_section.  */
end_comment

begin_function
specifier|static
name|bfd_byte
modifier|*
name|elf32_crx_get_relocated_section_contents
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|struct
name|bfd_link_order
modifier|*
name|link_order
parameter_list|,
name|bfd_byte
modifier|*
name|data
parameter_list|,
name|bfd_boolean
name|relocatable
parameter_list|,
name|asymbol
modifier|*
modifier|*
name|symbols
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|input_section
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
init|=
name|input_section
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sections
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
comment|/* We only need to handle the case of relaxing, or of having a      particular set of section contents, specially.  */
if|if
condition|(
name|relocatable
operator|||
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|==
name|NULL
condition|)
return|return
name|bfd_generic_get_relocated_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|link_info
argument_list|,
name|link_order
argument_list|,
name|data
argument_list|,
name|relocatable
argument_list|,
name|symbols
argument_list|)
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
argument_list|,
operator|(
name|size_t
operator|)
name|input_section
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|input_section
operator|->
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymend
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secpp
decl_stmt|;
name|bfd_size_type
name|amt
decl_stmt|;
name|internal_relocs
operator|=
operator|(
name|_bfd_elf_link_read_relocs
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
name|amt
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|amt
operator|*=
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
expr_stmt|;
name|sections
operator|=
name|bfd_malloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sections
operator|==
name|NULL
operator|&&
name|amt
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|isymend
operator|=
name|isymbuf
operator|+
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
for|for
control|(
name|isym
operator|=
name|isymbuf
operator|,
name|secpp
operator|=
name|sections
init|;
name|isym
operator|<
name|isymend
condition|;
operator|++
name|isym
operator|,
operator|++
name|secpp
control|)
block|{
name|asection
modifier|*
name|isec
decl_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|isec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|isec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|isec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
name|isec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|input_bfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
operator|*
name|secpp
operator|=
name|isec
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|elf32_crx_relocate_section
argument_list|(
name|output_bfd
argument_list|,
name|link_info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|data
argument_list|,
name|internal_relocs
argument_list|,
name|isymbuf
argument_list|,
name|sections
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
block|}
return|return
name|data
return|;
name|error_return
label|:
if|if
condition|(
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Relocate a CRX ELF section.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_crx_relocate_section
parameter_list|(
name|bfd
modifier|*
name|output_bfd
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|info
parameter_list|,
name|bfd
modifier|*
name|input_bfd
parameter_list|,
name|asection
modifier|*
name|input_section
parameter_list|,
name|bfd_byte
modifier|*
name|contents
parameter_list|,
name|Elf_Internal_Rela
modifier|*
name|relocs
parameter_list|,
name|Elf_Internal_Sym
modifier|*
name|local_syms
parameter_list|,
name|asection
modifier|*
modifier|*
name|local_sections
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|howto
operator|=
name|crx_elf_howto_table
operator|+
operator|(
name|r_type
operator|)
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
operator|&
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_boolean
name|unresolved_reloc
decl_stmt|,
name|warned
decl_stmt|;
name|RELOC_FOR_GLOBAL_SYMBOL
argument_list|(
name|info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
argument_list|,
name|r_symndx
argument_list|,
name|symtab_hdr
argument_list|,
name|sym_hashes
argument_list|,
name|h
argument_list|,
name|sec
argument_list|,
name|relocation
argument_list|,
name|unresolved_reloc
argument_list|,
name|warned
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|elf_discarded_section
argument_list|(
name|sec
argument_list|)
condition|)
block|{
comment|/* For relocs against symbols from removed linkonce sections, 	     or sections discarded by a linker script, we just want the 	     section contents zeroed.  Avoid any special processing.  */
name|_bfd_clear_contents
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|contents
operator|+
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|rel
operator|->
name|r_info
operator|=
literal|0
expr_stmt|;
name|rel
operator|->
name|r_addend
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|info
operator|->
name|relocatable
condition|)
continue|continue;
name|r
operator|=
name|crx_elf_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|output_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|,
name|info
argument_list|,
name|sec
argument_list|,
name|h
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|bfd_reloc_overflow
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
operator|(
name|h
condition|?
operator|&
name|h
operator|->
name|root
else|:
name|NULL
operator|)
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|bfd_reloc_undefined
case|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
name|bfd_reloc_outofrange
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: out of range error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
name|bfd_reloc_notsupported
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unsupported relocation error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
case|case
name|bfd_reloc_dangerous
case|:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: dangerous error"
argument_list|)
expr_stmt|;
goto|goto
name|common_error
goto|;
default|default:
name|msg
operator|=
name|_
argument_list|(
literal|"internal error: unknown error"
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
name|common_error
label|:
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|warning
call|)
argument_list|(
name|info
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
break|break;
block|}
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This function handles relaxing for the CRX.     There's quite a few relaxing opportunites available on the CRX:  	* bal/bcond:32 -> bal/bcond:16				   2 bytes 	* bcond:16 -> bcond:8					   2 bytes 	* cmpbcond:24 -> cmpbcond:8				   2 bytes 	* arithmetic imm32 -> arithmetic imm16			   2 bytes     Symbol- and reloc-reading infrastructure copied from elf-m10200.c.  */
end_comment

begin_function
specifier|static
name|bfd_boolean
name|elf32_crx_relax_section
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sec
parameter_list|,
name|struct
name|bfd_link_info
modifier|*
name|link_info
parameter_list|,
name|bfd_boolean
modifier|*
name|again
parameter_list|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|internal_relocs
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|isymbuf
init|=
name|NULL
decl_stmt|;
comment|/* Assume nothing changes.  */
operator|*
name|again
operator|=
name|FALSE
expr_stmt|;
comment|/* We don't have to do anything for a relocatable link, if      this section does not have relocs, or if this is not a      code section.  */
if|if
condition|(
name|link_info
operator|->
name|relocatable
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|sec
operator|->
name|reloc_count
operator|==
literal|0
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
comment|/* Get a copy of the native relocations.  */
name|internal_relocs
operator|=
operator|(
name|_bfd_elf_link_read_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
operator|(
name|Elf_Internal_Rela
operator|*
operator|)
name|NULL
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
comment|/* Walk through them looking for relaxing opportunities.  */
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|symval
decl_stmt|;
comment|/* If this isn't something that can be relaxed, then ignore 	 this reloc.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_CRX_REL32
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_CRX_REL16
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_CRX_REL24
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|R_CRX_IMM32
condition|)
continue|continue;
comment|/* Get the section contents if we haven't done so already.  */
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
block|{
comment|/* Get cached copy if it exists.  */
if|if
condition|(
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
expr_stmt|;
comment|/* Go get them off disk.  */
elseif|else
if|if
condition|(
operator|!
name|bfd_malloc_and_get_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
operator|&
name|contents
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Read this BFD's local symbols if we haven't done so already.  */
if|if
condition|(
name|isymbuf
operator|==
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|sh_info
operator|!=
literal|0
condition|)
block|{
name|isymbuf
operator|=
operator|(
name|Elf_Internal_Sym
operator|*
operator|)
name|symtab_hdr
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
name|isymbuf
operator|=
name|bfd_elf_get_elf_syms
argument_list|(
name|abfd
argument_list|,
name|symtab_hdr
argument_list|,
name|symtab_hdr
operator|->
name|sh_info
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* Get the value of the symbol referred to by the reloc.  */
if|if
condition|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
comment|/* A local symbol.  */
name|Elf_Internal_Sym
modifier|*
name|isym
decl_stmt|;
name|asection
modifier|*
name|sym_sec
decl_stmt|;
name|isym
operator|=
name|isymbuf
operator|+
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
name|sym_sec
operator|=
name|bfd_und_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_ABS
condition|)
name|sym_sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
elseif|else
if|if
condition|(
name|isym
operator|->
name|st_shndx
operator|==
name|SHN_COMMON
condition|)
name|sym_sec
operator|=
name|bfd_com_section_ptr
expr_stmt|;
else|else
name|sym_sec
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|isym
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|symval
operator|=
operator|(
name|isym
operator|->
name|st_value
operator|+
name|sym_sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sym_sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|long
name|indx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* An external symbol.  */
name|indx
operator|=
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|-
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|h
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
comment|/* This appears to be a reference to an undefined 	       symbol.  Just ignore it--it will be caught by the 	       regular reloc processing.  */
continue|continue;
name|symval
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
comment|/* For simplicity of coding, we are going to modify the section 	 contents, the section relocs, and the BFD symbol table.  We 	 must tell the rest of the code not to free up this 	 information.  It would be possible to instead create a table 	 of changes which have to be made, as is done in coff-mips.c; 	 that would be more work, but would require less memory when 	 the linker is run.  */
comment|/* Try to turn a 32bit pc-relative branch/call into 	 a 16bit pc-relative branch/call.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_CRX_REL32
condition|)
block|{
name|bfd_vma
name|value
init|=
name|symval
decl_stmt|;
comment|/* Deal with pc-relative gunk.  */
name|value
operator|-=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|irel
operator|->
name|r_offset
expr_stmt|;
name|value
operator|+=
name|irel
operator|->
name|r_addend
expr_stmt|;
comment|/* See if the value will fit in 16 bits, note the high value is 	     0xfffe + 2 as the target will be two bytes closer if we are 	     able to relax.  */
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|<
literal|0x10000
operator|&&
operator|(
name|long
operator|)
name|value
operator|>
operator|-
literal|0x10002
condition|)
block|{
name|unsigned
name|short
name|code
decl_stmt|;
comment|/* Get the opcode.  */
name|code
operator|=
operator|(
name|unsigned
name|short
operator|)
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Verify it's a 'bal'/'bcond' and fix the opcode.  */
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfff0
operator|)
operator|==
literal|0x3170
condition|)
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x30
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0xf0ff
operator|)
operator|==
literal|0x707f
condition|)
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x7e
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
else|else
continue|continue;
comment|/* Note that we've changed the relocs, section contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_CRX_REL16
argument_list|)
expr_stmt|;
comment|/* Delete two bytes of data.  */
if|if
condition|(
operator|!
name|elf32_crx_relax_delete_bytes
argument_list|(
name|link_info
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 		 Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Try to turn a 16bit pc-relative branch into an 	 8bit pc-relative branch.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_CRX_REL16
condition|)
block|{
name|bfd_vma
name|value
init|=
name|symval
decl_stmt|;
comment|/* Deal with pc-relative gunk.  */
name|value
operator|-=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|irel
operator|->
name|r_offset
expr_stmt|;
name|value
operator|+=
name|irel
operator|->
name|r_addend
expr_stmt|;
comment|/* See if the value will fit in 8 bits, note the high value is 	     0xfc + 2 as the target will be two bytes closer if we are 	     able to relax.  */
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|<
literal|0xfe
operator|&&
operator|(
name|long
operator|)
name|value
operator|>
operator|-
literal|0x100
condition|)
block|{
name|unsigned
name|short
name|code
decl_stmt|;
comment|/* Get the opcode.  */
name|code
operator|=
operator|(
name|unsigned
name|short
operator|)
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Verify it's a 'bcond' opcode.  */
if|if
condition|(
operator|(
name|code
operator|&
literal|0xf0ff
operator|)
operator|!=
literal|0x707e
condition|)
continue|continue;
comment|/* Note that we've changed the relocs, section contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_CRX_REL8
argument_list|)
expr_stmt|;
comment|/* Delete two bytes of data.  */
if|if
condition|(
operator|!
name|elf32_crx_relax_delete_bytes
argument_list|(
name|link_info
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 		 Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Try to turn a 24bit pc-relative cmp&branch into 	 an 8bit pc-relative cmp&branch.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_CRX_REL24
condition|)
block|{
name|bfd_vma
name|value
init|=
name|symval
decl_stmt|;
comment|/* Deal with pc-relative gunk.  */
name|value
operator|-=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
name|value
operator|-=
name|irel
operator|->
name|r_offset
expr_stmt|;
name|value
operator|+=
name|irel
operator|->
name|r_addend
expr_stmt|;
comment|/* See if the value will fit in 8 bits, note the high value is 	     0x7e + 2 as the target will be two bytes closer if we are 	     able to relax.  */
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|<
literal|0x100
operator|&&
operator|(
name|long
operator|)
name|value
operator|>
operator|-
literal|0x100
condition|)
block|{
name|unsigned
name|short
name|code
decl_stmt|;
comment|/* Get the opcode.  */
name|code
operator|=
operator|(
name|unsigned
name|short
operator|)
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Verify it's a 'cmp&branch' opcode.  */
if|if
condition|(
operator|(
name|code
operator|&
literal|0xfff0
operator|)
operator|!=
literal|0x3180
operator|&&
operator|(
name|code
operator|&
literal|0xfff0
operator|)
operator|!=
literal|0x3190
operator|&&
operator|(
name|code
operator|&
literal|0xfff0
operator|)
operator|!=
literal|0x31a0
operator|&&
operator|(
name|code
operator|&
literal|0xfff0
operator|)
operator|!=
literal|0x31c0
operator|&&
operator|(
name|code
operator|&
literal|0xfff0
operator|)
operator|!=
literal|0x31d0
operator|&&
operator|(
name|code
operator|&
literal|0xfff0
operator|)
operator|!=
literal|0x31e0
comment|/* Or a Co-processor branch ('bcop').  */
operator|&&
operator|(
name|code
operator|&
literal|0xfff0
operator|)
operator|!=
literal|0x3010
operator|&&
operator|(
name|code
operator|&
literal|0xfff0
operator|)
operator|!=
literal|0x3110
condition|)
continue|continue;
comment|/* Note that we've changed the relocs, section contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Fix the opcode.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
literal|0x30
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_CRX_REL8_CMP
argument_list|)
expr_stmt|;
comment|/* Delete two bytes of data.  */
if|if
condition|(
operator|!
name|elf32_crx_relax_delete_bytes
argument_list|(
name|link_info
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|4
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 		 Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Try to turn a 32bit immediate address into 	 a 16bit immediate address.  */
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
operator|==
operator|(
name|int
operator|)
name|R_CRX_IMM32
condition|)
block|{
name|bfd_vma
name|value
init|=
name|symval
decl_stmt|;
comment|/* See if the value will fit in 16 bits.  */
if|if
condition|(
operator|(
name|long
operator|)
name|value
operator|<
literal|0x7fff
operator|&&
operator|(
name|long
operator|)
name|value
operator|>
operator|-
literal|0x8000
condition|)
block|{
name|unsigned
name|short
name|code
decl_stmt|;
comment|/* Get the opcode.  */
name|code
operator|=
operator|(
name|unsigned
name|short
operator|)
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Verify it's a 'arithmetic double'.  */
if|if
condition|(
operator|(
name|code
operator|&
literal|0xf0f0
operator|)
operator|!=
literal|0x20f0
condition|)
continue|continue;
comment|/* Note that we've changed the relocs, section contents, etc.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
comment|/* Fix the opcode.  */
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|code
operator|&
literal|0xff
operator|)
operator|-
literal|0x10
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
comment|/* Fix the relocation's type.  */
name|irel
operator|->
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|ELF32_R_SYM
argument_list|(
name|irel
operator|->
name|r_info
argument_list|)
argument_list|,
name|R_CRX_IMM16
argument_list|)
expr_stmt|;
comment|/* Delete two bytes of data.  */
if|if
condition|(
operator|!
name|elf32_crx_relax_delete_bytes
argument_list|(
name|link_info
argument_list|,
name|abfd
argument_list|,
name|sec
argument_list|,
name|irel
operator|->
name|r_offset
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, we should relax again. 		 Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the symbols for elf_link_input_bfd.  */
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
expr_stmt|;
block|}
block|}
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the section contents for elf_link_input_bfd.  */
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|=
name|contents
expr_stmt|;
block|}
block|}
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|error_return
label|:
if|if
condition|(
name|isymbuf
operator|!=
name|NULL
operator|&&
name|symtab_hdr
operator|->
name|contents
operator|!=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|isymbuf
condition|)
name|free
argument_list|(
name|isymbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|this_hdr
operator|.
name|contents
operator|!=
name|contents
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
operator|&&
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|relocs
operator|!=
name|internal_relocs
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Definitions for setting CRX target vector.  */
end_comment

begin_define
define|#
directive|define
name|TARGET_LITTLE_SYM
value|bfd_elf32_crx_vec
end_define

begin_define
define|#
directive|define
name|TARGET_LITTLE_NAME
value|"elf32-crx"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_crx
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_CRX
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1
end_define

begin_define
define|#
directive|define
name|elf_symbol_leading_char
value|'_'
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|elf_crx_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_name_lookup
define|\
value|elf_crx_reloc_name_lookup
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|elf_crx_info_to_howto
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto_rel
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|elf32_crx_relocate_section
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_relax_section
value|elf32_crx_relax_section
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_get_relocated_section_contents
define|\
value|elf32_crx_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_rela_normal
value|1
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

