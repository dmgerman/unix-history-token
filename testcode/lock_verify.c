begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * testcode/lock_verify.c - verifier program for lock traces, checks order.  *  * Copyright (c) 2007, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED  * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This file checks the lock traces generated by checklock.c.  * Checks if locks are consistently locked in the same order.  * If not, this can lead to deadlock if threads execute the different  * ordering at the same time.  *   */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"util/log.h"
end_include

begin_include
include|#
directive|include
file|"util/rbtree.h"
end_include

begin_include
include|#
directive|include
file|"util/locks.h"
end_include

begin_include
include|#
directive|include
file|"util/fptr_wlist.h"
end_include

begin_comment
comment|/* --- data structures --- */
end_comment

begin_struct_decl
struct_decl|struct
name|lock_ref
struct_decl|;
end_struct_decl

begin_comment
comment|/** keep track of lock id in lock-verify application   * Also defined in smallapp/worker_cb.c for fptr_wlist encapsulation   * breakage (the security tests break encapsulation for this test app) */
end_comment

begin_struct
struct|struct
name|order_id
block|{
comment|/** the thread id that created it */
name|int
name|thr
decl_stmt|;
comment|/** the instance number of creation */
name|int
name|instance
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/** a lock */
end_comment

begin_struct
struct|struct
name|order_lock
block|{
comment|/** rbnode in all tree */
name|rbnode_t
name|node
decl_stmt|;
comment|/** lock id */
name|struct
name|order_id
name|id
decl_stmt|;
comment|/** the creation file */
name|char
modifier|*
name|create_file
decl_stmt|;
comment|/** creation line */
name|int
name|create_line
decl_stmt|;
comment|/** set of all locks that are smaller than this one (locked earlier) */
name|rbtree_t
modifier|*
name|smaller
decl_stmt|;
comment|/** during depthfirstsearch, this is a linked list of the stack  	 * of locks. points to the next lock bigger than this one. */
name|struct
name|lock_ref
modifier|*
name|dfs_next
decl_stmt|;
comment|/** if lock has been visited (all smaller locks have been compared to 	 * this lock), only need to compare this with all unvisited(bigger)  	 * locks */
name|int
name|visited
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/** reference to a lock in a rbtree set */
end_comment

begin_struct
struct|struct
name|lock_ref
block|{
comment|/** rbnode, key is an order_id ptr */
name|rbnode_t
name|node
decl_stmt|;
comment|/** the lock referenced */
name|struct
name|order_lock
modifier|*
name|lock
decl_stmt|;
comment|/** why is this ref */
name|char
modifier|*
name|file
decl_stmt|;
comment|/** line number */
name|int
name|line
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/** count of errors detected */
end_comment

begin_decl_stmt
specifier|static
name|int
name|errors_detected
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** verbose? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|verb
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** print program usage help */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|printf
argument_list|(
literal|"lock_verify<trace files>\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** read header entry.   * @param in: file to read header of.  * @return: False if it does not belong to the rest. */
end_comment

begin_function
specifier|static
name|int
name|read_header
parameter_list|(
name|FILE
modifier|*
name|in
parameter_list|)
block|{
name|time_t
name|t
decl_stmt|;
name|pid_t
name|p
decl_stmt|;
name|int
name|thrno
decl_stmt|;
specifier|static
name|int
name|have_values
init|=
literal|0
decl_stmt|;
specifier|static
name|time_t
name|the_time
decl_stmt|;
specifier|static
name|pid_t
name|the_pid
decl_stmt|;
specifier|static
name|int
name|threads
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|&
name|t
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|,
name|in
argument_list|)
operator|!=
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|thrno
argument_list|,
sizeof|sizeof
argument_list|(
name|thrno
argument_list|)
argument_list|,
literal|1
argument_list|,
name|in
argument_list|)
operator|!=
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|,
literal|1
argument_list|,
name|in
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fatal_exit
argument_list|(
literal|"fread failed"
argument_list|)
expr_stmt|;
block|}
comment|/* check these values are sorta OK */
if|if
condition|(
operator|!
name|have_values
condition|)
block|{
name|the_time
operator|=
name|t
expr_stmt|;
name|the_pid
operator|=
name|p
expr_stmt|;
name|memset
argument_list|(
name|threads
argument_list|,
literal|0
argument_list|,
literal|256
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|thrno
operator|>=
literal|256
condition|)
block|{
name|fatal_exit
argument_list|(
literal|"Thread number too big. %d"
argument_list|,
name|thrno
argument_list|)
expr_stmt|;
block|}
name|threads
index|[
name|thrno
index|]
operator|=
literal|1
expr_stmt|;
name|have_values
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|" trace %d from pid %u on %s"
argument_list|,
name|thrno
argument_list|,
operator|(
name|unsigned
operator|)
name|p
argument_list|,
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|the_pid
operator|!=
name|p
condition|)
block|{
name|printf
argument_list|(
literal|" has pid %u, not %u. Skipped.\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|p
argument_list|,
operator|(
name|unsigned
operator|)
name|the_pid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|threads
index|[
name|thrno
index|]
condition|)
name|fatal_exit
argument_list|(
literal|"same threadno in two files"
argument_list|)
expr_stmt|;
name|threads
index|[
name|thrno
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
call|(
name|int
call|)
argument_list|(
name|the_time
operator|-
name|t
argument_list|)
argument_list|)
operator|>
literal|3600
condition|)
name|fatal_exit
argument_list|(
literal|"input files from different times: %u %u"
argument_list|,
operator|(
name|unsigned
operator|)
name|the_time
argument_list|,
operator|(
name|unsigned
operator|)
name|t
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" trace of thread %u:%d\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|p
argument_list|,
name|thrno
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** max length of strings: filenames and function names. */
end_comment

begin_define
define|#
directive|define
name|STRMAX
value|1024
end_define

begin_comment
comment|/** read a string from file, false on error */
end_comment

begin_function
specifier|static
name|int
name|readup_str
parameter_list|(
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|FILE
modifier|*
name|in
parameter_list|)
block|{
name|char
name|buf
index|[
name|STRMAX
index|]
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* ends in zero */
while|while
condition|(
operator|(
name|c
operator|=
name|fgetc
argument_list|(
name|in
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|fatal_exit
argument_list|(
literal|"eof in readstr, file too short"
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|len
operator|==
name|STRMAX
condition|)
block|{
name|fatal_exit
argument_list|(
literal|"string too long, bad file format"
argument_list|)
expr_stmt|;
block|}
block|}
name|buf
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|str
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/** read creation entry */
end_comment

begin_function
specifier|static
name|void
name|read_create
parameter_list|(
name|rbtree_t
modifier|*
name|all
parameter_list|,
name|FILE
modifier|*
name|in
parameter_list|)
block|{
name|struct
name|order_lock
modifier|*
name|o
init|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|order_lock
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|o
condition|)
name|fatal_exit
argument_list|(
literal|"malloc failure"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|&
name|o
operator|->
name|id
operator|.
name|thr
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
name|in
argument_list|)
operator|!=
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|o
operator|->
name|id
operator|.
name|instance
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
name|in
argument_list|)
operator|!=
literal|1
operator|||
operator|!
name|readup_str
argument_list|(
operator|&
name|o
operator|->
name|create_file
argument_list|,
name|in
argument_list|)
operator|||
name|fread
argument_list|(
operator|&
name|o
operator|->
name|create_line
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
name|in
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_exit
argument_list|(
literal|"fread failed"
argument_list|)
expr_stmt|;
name|o
operator|->
name|smaller
operator|=
name|rbtree_create
argument_list|(
name|order_lock_cmp
argument_list|)
expr_stmt|;
name|o
operator|->
name|node
operator|.
name|key
operator|=
operator|&
name|o
operator|->
name|id
expr_stmt|;
if|if
condition|(
operator|!
name|rbtree_insert
argument_list|(
name|all
argument_list|,
operator|&
name|o
operator|->
name|node
argument_list|)
condition|)
block|{
comment|/* already inserted */
name|struct
name|order_lock
modifier|*
name|a
init|=
operator|(
expr|struct
name|order_lock
operator|*
operator|)
name|rbtree_search
argument_list|(
name|all
argument_list|,
operator|&
name|o
operator|->
name|id
argument_list|)
decl_stmt|;
name|log_assert
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|a
operator|->
name|create_file
operator|=
name|o
operator|->
name|create_file
expr_stmt|;
name|a
operator|->
name|create_line
operator|=
name|o
operator|->
name|create_line
expr_stmt|;
name|free
argument_list|(
name|o
operator|->
name|smaller
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|=
name|a
expr_stmt|;
block|}
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"read create %u %u %s %d\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|o
operator|->
name|id
operator|.
name|thr
argument_list|,
operator|(
name|unsigned
operator|)
name|o
operator|->
name|id
operator|.
name|instance
argument_list|,
name|o
operator|->
name|create_file
argument_list|,
name|o
operator|->
name|create_line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** insert lock entry (empty) into list */
end_comment

begin_function
specifier|static
name|struct
name|order_lock
modifier|*
name|insert_lock
parameter_list|(
name|rbtree_t
modifier|*
name|all
parameter_list|,
name|struct
name|order_id
modifier|*
name|id
parameter_list|)
block|{
name|struct
name|order_lock
modifier|*
name|o
init|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|order_lock
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|o
condition|)
name|fatal_exit
argument_list|(
literal|"malloc failure"
argument_list|)
expr_stmt|;
name|o
operator|->
name|smaller
operator|=
name|rbtree_create
argument_list|(
name|order_lock_cmp
argument_list|)
expr_stmt|;
name|o
operator|->
name|id
operator|=
operator|*
name|id
expr_stmt|;
name|o
operator|->
name|node
operator|.
name|key
operator|=
operator|&
name|o
operator|->
name|id
expr_stmt|;
if|if
condition|(
operator|!
name|rbtree_insert
argument_list|(
name|all
argument_list|,
operator|&
name|o
operator|->
name|node
argument_list|)
condition|)
name|fatal_exit
argument_list|(
literal|"insert fail should not happen"
argument_list|)
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_comment
comment|/** read lock entry */
end_comment

begin_function
specifier|static
name|void
name|read_lock
parameter_list|(
name|rbtree_t
modifier|*
name|all
parameter_list|,
name|FILE
modifier|*
name|in
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|struct
name|order_id
name|prev_id
decl_stmt|,
name|now_id
decl_stmt|;
name|struct
name|lock_ref
modifier|*
name|ref
decl_stmt|;
name|struct
name|order_lock
modifier|*
name|prev
decl_stmt|,
modifier|*
name|now
decl_stmt|;
name|ref
operator|=
operator|(
expr|struct
name|lock_ref
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lock_ref
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ref
condition|)
name|fatal_exit
argument_list|(
literal|"malloc failure"
argument_list|)
expr_stmt|;
name|prev_id
operator|.
name|thr
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|&
name|prev_id
operator|.
name|instance
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
name|in
argument_list|)
operator|!=
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|now_id
operator|.
name|thr
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
name|in
argument_list|)
operator|!=
literal|1
operator|||
name|fread
argument_list|(
operator|&
name|now_id
operator|.
name|instance
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
name|in
argument_list|)
operator|!=
literal|1
operator|||
operator|!
name|readup_str
argument_list|(
operator|&
name|ref
operator|->
name|file
argument_list|,
name|in
argument_list|)
operator|||
name|fread
argument_list|(
operator|&
name|ref
operator|->
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
name|in
argument_list|)
operator|!=
literal|1
condition|)
name|fatal_exit
argument_list|(
literal|"fread failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"read lock %u %u %u %u %s %d\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|prev_id
operator|.
name|thr
argument_list|,
operator|(
name|unsigned
operator|)
name|prev_id
operator|.
name|instance
argument_list|,
operator|(
name|unsigned
operator|)
name|now_id
operator|.
name|thr
argument_list|,
operator|(
name|unsigned
operator|)
name|now_id
operator|.
name|instance
argument_list|,
name|ref
operator|->
name|file
argument_list|,
name|ref
operator|->
name|line
argument_list|)
expr_stmt|;
comment|/* find the two locks involved */
name|prev
operator|=
operator|(
expr|struct
name|order_lock
operator|*
operator|)
name|rbtree_search
argument_list|(
name|all
argument_list|,
operator|&
name|prev_id
argument_list|)
expr_stmt|;
name|now
operator|=
operator|(
expr|struct
name|order_lock
operator|*
operator|)
name|rbtree_search
argument_list|(
name|all
argument_list|,
operator|&
name|now_id
argument_list|)
expr_stmt|;
comment|/* if not there - insert 'em */
if|if
condition|(
operator|!
name|prev
condition|)
name|prev
operator|=
name|insert_lock
argument_list|(
name|all
argument_list|,
operator|&
name|prev_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|now
condition|)
name|now
operator|=
name|insert_lock
argument_list|(
name|all
argument_list|,
operator|&
name|now_id
argument_list|)
expr_stmt|;
name|ref
operator|->
name|lock
operator|=
name|prev
expr_stmt|;
name|ref
operator|->
name|node
operator|.
name|key
operator|=
operator|&
name|prev
operator|->
name|id
expr_stmt|;
if|if
condition|(
operator|!
name|rbtree_insert
argument_list|(
name|now
operator|->
name|smaller
argument_list|,
operator|&
name|ref
operator|->
name|node
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ref
operator|->
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** read input file */
end_comment

begin_function
specifier|static
name|void
name|readinput
parameter_list|(
name|rbtree_t
modifier|*
name|all
parameter_list|,
name|char
modifier|*
name|file
parameter_list|)
block|{
name|FILE
modifier|*
name|in
init|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|int
name|fst
decl_stmt|;
if|if
condition|(
operator|!
name|in
condition|)
block|{
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"file %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|read_header
argument_list|(
name|in
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|fread
argument_list|(
operator|&
name|fst
argument_list|,
sizeof|sizeof
argument_list|(
name|fst
argument_list|)
argument_list|,
literal|1
argument_list|,
name|in
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|fst
operator|==
operator|-
literal|1
condition|)
name|read_create
argument_list|(
name|all
argument_list|,
name|in
argument_list|)
expr_stmt|;
else|else
name|read_lock
argument_list|(
name|all
argument_list|,
name|in
argument_list|,
name|fst
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** print cycle message */
end_comment

begin_function
specifier|static
name|void
name|found_cycle
parameter_list|(
name|struct
name|lock_ref
modifier|*
name|visit
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|struct
name|lock_ref
modifier|*
name|p
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|errors_detected
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"Found inconsistent locking order of length %d\n"
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"for lock %d %d created %s %d\n"
argument_list|,
name|visit
operator|->
name|lock
operator|->
name|id
operator|.
name|thr
argument_list|,
name|visit
operator|->
name|lock
operator|->
name|id
operator|.
name|instance
argument_list|,
name|visit
operator|->
name|lock
operator|->
name|create_file
argument_list|,
name|visit
operator|->
name|lock
operator|->
name|create_line
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sequence is:\n"
argument_list|)
expr_stmt|;
name|p
operator|=
name|visit
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|struct
name|order_lock
modifier|*
name|next
init|=
name|p
operator|->
name|lock
operator|->
name|dfs_next
condition|?
name|p
operator|->
name|lock
operator|->
name|dfs_next
operator|->
name|lock
else|:
name|visit
operator|->
name|lock
decl_stmt|;
name|printf
argument_list|(
literal|"[%d] is locked at line %s %d before lock %d %d\n"
argument_list|,
name|i
argument_list|,
name|p
operator|->
name|file
argument_list|,
name|p
operator|->
name|line
argument_list|,
name|next
operator|->
name|id
operator|.
name|thr
argument_list|,
name|next
operator|->
name|id
operator|.
name|instance
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[%d] lock %d %d is created at %s %d\n"
argument_list|,
name|i
argument_list|,
name|next
operator|->
name|id
operator|.
name|thr
argument_list|,
name|next
operator|->
name|id
operator|.
name|instance
argument_list|,
name|next
operator|->
name|create_file
argument_list|,
name|next
operator|->
name|create_line
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|lock
operator|->
name|dfs_next
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|lock
operator|==
name|visit
operator|->
name|lock
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/** Detect cycle by comparing visited now with all (unvisited) bigger nodes */
end_comment

begin_function
specifier|static
name|int
name|detect_cycle
parameter_list|(
name|struct
name|lock_ref
modifier|*
name|visit
parameter_list|,
name|struct
name|lock_ref
modifier|*
name|from
parameter_list|)
block|{
name|struct
name|lock_ref
modifier|*
name|p
init|=
name|from
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|lock
operator|==
name|visit
operator|->
name|lock
condition|)
return|return
literal|1
return|;
name|p
operator|=
name|p
operator|->
name|lock
operator|->
name|dfs_next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** recursive function to depth first search for cycles.  * @param visit: the lock visited at this step.  *	its dfs_next pointer gives the visited lock up in recursion.  * 	same as lookfor at level 0.  * @param level: depth of recursion. 0 is start.  * @param from: search for matches from unvisited node upwards.  */
end_comment

begin_function
specifier|static
name|void
name|search_cycle
parameter_list|(
name|struct
name|lock_ref
modifier|*
name|visit
parameter_list|,
name|int
name|level
parameter_list|,
name|struct
name|lock_ref
modifier|*
name|from
parameter_list|)
block|{
name|struct
name|lock_ref
modifier|*
name|ref
decl_stmt|;
comment|/* check for cycle */
if|if
condition|(
name|detect_cycle
argument_list|(
name|visit
argument_list|,
name|from
argument_list|)
operator|&&
name|level
operator|!=
literal|0
condition|)
block|{
name|found_cycle
argument_list|(
name|visit
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|fatal_exit
argument_list|(
literal|"found lock order cycle"
argument_list|)
expr_stmt|;
block|}
comment|/* recurse */
if|if
condition|(
operator|!
name|visit
operator|->
name|lock
operator|->
name|visited
condition|)
name|from
operator|=
name|visit
expr_stmt|;
if|if
condition|(
name|verb
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[%d] visit lock %u %u %s %d\n"
argument_list|,
name|level
argument_list|,
operator|(
name|unsigned
operator|)
name|visit
operator|->
name|lock
operator|->
name|id
operator|.
name|thr
argument_list|,
operator|(
name|unsigned
operator|)
name|visit
operator|->
name|lock
operator|->
name|id
operator|.
name|instance
argument_list|,
name|visit
operator|->
name|lock
operator|->
name|create_file
argument_list|,
name|visit
operator|->
name|lock
operator|->
name|create_line
argument_list|)
expr_stmt|;
name|RBTREE_FOR
argument_list|(
argument|ref
argument_list|,
argument|struct lock_ref*
argument_list|,
argument|visit->lock->smaller
argument_list|)
block|{
name|ref
operator|->
name|lock
operator|->
name|dfs_next
operator|=
name|visit
expr_stmt|;
name|search_cycle
argument_list|(
name|ref
argument_list|,
name|level
operator|+
literal|1
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
name|visit
operator|->
name|lock
operator|->
name|visited
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Check ordering of one lock */
end_comment

begin_function
specifier|static
name|void
name|check_order_lock
parameter_list|(
name|struct
name|order_lock
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|lock_ref
name|start
decl_stmt|;
if|if
condition|(
name|lock
operator|->
name|visited
condition|)
return|return;
name|start
operator|.
name|node
operator|.
name|key
operator|=
operator|&
name|lock
operator|->
name|id
expr_stmt|;
name|start
operator|.
name|lock
operator|=
name|lock
expr_stmt|;
name|start
operator|.
name|file
operator|=
name|lock
operator|->
name|create_file
expr_stmt|;
name|start
operator|.
name|line
operator|=
name|lock
operator|->
name|create_line
expr_stmt|;
if|if
condition|(
operator|!
name|lock
operator|->
name|create_file
condition|)
name|log_err
argument_list|(
literal|"lock %u %u does not have create info"
argument_list|,
operator|(
name|unsigned
operator|)
name|lock
operator|->
name|id
operator|.
name|thr
argument_list|,
operator|(
name|unsigned
operator|)
name|lock
operator|->
name|id
operator|.
name|instance
argument_list|)
expr_stmt|;
comment|/* depth first search to find cycle with this lock at head */
name|lock
operator|->
name|dfs_next
operator|=
name|NULL
expr_stmt|;
name|search_cycle
argument_list|(
operator|&
name|start
argument_list|,
literal|0
argument_list|,
operator|&
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** Check ordering of locks */
end_comment

begin_function
specifier|static
name|void
name|check_order
parameter_list|(
name|rbtree_t
modifier|*
name|all_locks
parameter_list|)
block|{
comment|/* check each lock */
name|struct
name|order_lock
modifier|*
name|lock
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|RBTREE_FOR
argument_list|(
argument|lock
argument_list|,
argument|struct order_lock*
argument_list|,
argument|all_locks
argument_list|)
block|{
if|if
condition|(
name|verb
condition|)
name|printf
argument_list|(
literal|"[%d/%d] Checking lock %d %d %s %d\n"
argument_list|,
name|i
argument_list|,
operator|(
name|int
operator|)
name|all_locks
operator|->
name|count
argument_list|,
name|lock
operator|->
name|id
operator|.
name|thr
argument_list|,
name|lock
operator|->
name|id
operator|.
name|instance
argument_list|,
name|lock
operator|->
name|create_file
argument_list|,
name|lock
operator|->
name|create_line
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|%
operator|(
operator|(
name|all_locks
operator|->
name|count
operator|/
literal|75
operator|)
operator|<
literal|1
condition|?
literal|1
else|:
name|all_locks
operator|->
name|count
operator|/
literal|75
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|check_order_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** main program to verify all traces passed */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|rbtree_t
modifier|*
name|all_locks
decl_stmt|;
name|int
name|i
decl_stmt|;
name|time_t
name|starttime
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_THREAD_DEBUG
comment|/* do not overwrite the ublocktrace files with the ones generated 	 * by this program (i.e. when the log code creates a lock) */
name|check_locking_order
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
name|log_init
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|log_ident_set
argument_list|(
literal|"lock-verify"
argument_list|)
expr_stmt|;
comment|/* init */
name|all_locks
operator|=
name|rbtree_create
argument_list|(
name|order_lock_cmp
argument_list|)
expr_stmt|;
name|errors_detected
operator|=
literal|0
expr_stmt|;
comment|/* read the input files */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|readinput
argument_list|(
name|all_locks
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* check ordering */
name|check_order
argument_list|(
name|all_locks
argument_list|)
expr_stmt|;
comment|/* do not free a thing, OS will do it */
name|printf
argument_list|(
literal|"checked %d locks in %d seconds with %d errors.\n"
argument_list|,
operator|(
name|int
operator|)
name|all_locks
operator|->
name|count
argument_list|,
call|(
name|int
call|)
argument_list|(
name|time
argument_list|(
name|NULL
argument_list|)
operator|-
name|starttime
argument_list|)
argument_list|,
name|errors_detected
argument_list|)
expr_stmt|;
if|if
condition|(
name|errors_detected
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

end_unit

