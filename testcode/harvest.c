begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * testcode/harvest.c - debug program to get relevant data to a set of queries.  *  * Copyright (c) 2008, NLnet Labs. All rights reserved.  *  * This software is open source.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  *   * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * Neither the name of the NLNET LABS nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * \file  *  * This program downloads relevant DNS data to a set of queries.  * This means that the queries are asked to root, TLD, SLD servers and  * the results stored per zone.  * The following data is pertinent:  *  * At each label:  *	SOA  *	NS  *	DNSKEY  *	DS  * For the whole query:  *	the result.  * For NS-records:  *	their label data  *	and the A and AAAA records for it.  *	(as if the name, with A and AAAA query type is in the list,  *	 referred to as recursion depth+1)  * Any NSEC, NSEC3, SOA records or additional data found in answers.  *  * All of this is data that would be encountered during an iterative lookup  * for the queries in the list. It is saved to enable a replay of iterative  * lookups for performance testing.  *  * A number of assumptions are made.  * 1) configuration is correct.  *    The parent has the same NS records as the child.  *    All nameservers carry the same data.  * 2) EDNS/nonEDNS responses and other behaviour is ignored.  *    Only the data is saved.  * This creates a snapshot that represents the data as this resolver saw it.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETOPT_H
end_ifdef

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ldns/ldns.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"libunbound/unbound.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_STAT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|UNBOUND_ALLOC_LITE
end_ifdef

begin_undef
undef|#
directive|undef
name|malloc
end_undef

begin_undef
undef|#
directive|undef
name|calloc
end_undef

begin_undef
undef|#
directive|undef
name|realloc
end_undef

begin_undef
undef|#
directive|undef
name|free
end_undef

begin_undef
undef|#
directive|undef
name|strdup
end_undef

begin_define
define|#
directive|define
name|unbound_lite_wrapstr
parameter_list|(
name|s
parameter_list|)
value|s
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct_decl
struct_decl|struct
name|todo_item
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|labdata
struct_decl|;
end_struct_decl

begin_comment
comment|/** this represents the data that has been collected   * as well as a todo list and some settings */
end_comment

begin_struct
struct|struct
name|harvest_data
block|{
comment|/** the unbound context */
name|struct
name|ub_ctx
modifier|*
name|ctx
decl_stmt|;
comment|/** a tree per label; thus this first one is one root entry, 	 * that has a tree of TLD labels. Those have trees of SLD labels. */
name|struct
name|labdata
modifier|*
name|root
decl_stmt|;
comment|/** the original query list */
name|struct
name|todo_item
modifier|*
name|orig_list
decl_stmt|;
comment|/** the query list todo */
name|struct
name|todo_item
modifier|*
name|todo_list
decl_stmt|;
comment|/** last item in todo list */
name|struct
name|todo_item
modifier|*
name|todo_last
decl_stmt|;
comment|/** number of todo items */
name|int
name|numtodo
decl_stmt|;
comment|/** where to store the results */
name|char
modifier|*
name|resultdir
decl_stmt|;
comment|/** maximum recursion depth */
name|int
name|maxdepth
decl_stmt|;
comment|/** current recursion depth */
name|int
name|curdepth
decl_stmt|;
comment|/** max depth of labels */
name|int
name|maxlabels
decl_stmt|;
comment|/** number of RRs stored */
name|int
name|num_rrs
decl_stmt|;
comment|/** number of zones written */
name|int
name|num_zones
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * Todo item  */
end_comment

begin_struct
struct|struct
name|todo_item
block|{
comment|/** the next item */
name|struct
name|todo_item
modifier|*
name|next
decl_stmt|;
comment|/** query as rdf */
name|ldns_rdf
modifier|*
name|qname
decl_stmt|;
comment|/** the query type */
name|int
name|qtype
decl_stmt|;
comment|/** query class */
name|int
name|qclass
decl_stmt|;
comment|/** recursion depth of todo item (orig list is 0) */
name|int
name|depth
decl_stmt|;
comment|/** the label associated with the query */
name|struct
name|labdata
modifier|*
name|lab
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**   * Every label has a sest of sublabels, that have sets of sublabels ...  * Per label is stored also a set of data items, and todo information  */
end_comment

begin_struct
struct|struct
name|labdata
block|{
comment|/** node in ldns rbtree */
name|ldns_rbnode_t
name|node
decl_stmt|;
comment|/** the name of this label */
name|ldns_rdf
modifier|*
name|label
decl_stmt|;
comment|/** full name of point in domain tree */
name|ldns_rdf
modifier|*
name|name
decl_stmt|;
comment|/** parent in label tree (NULL for root) */
name|struct
name|labdata
modifier|*
name|parent
decl_stmt|;
comment|/** tree of sublabels (if any) */
name|ldns_rbtree_t
modifier|*
name|sublabels
decl_stmt|;
comment|/** list of RRs for this label */
name|ldns_rr_list
modifier|*
name|rrlist
decl_stmt|;
comment|/** have queries for this label been queued */
name|int
name|done
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/** usage information for harvest */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|char
modifier|*
name|nm
parameter_list|)
block|{
name|printf
argument_list|(
literal|"usage: %s [options]\n"
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-f fnm	query list to read from file\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	every line has format: qname qclass qtype\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-v 	verbose (-v -v even more)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-C cfg	config file with resolver options\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** verbosity for harvest */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hverb
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** exit with error */
end_comment

begin_function
specifier|static
name|void
name|error_exit
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|printf
argument_list|(
literal|"error: %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** read a query file */
end_comment

begin_function
specifier|static
name|void
name|qlist_read_file
parameter_list|(
name|struct
name|harvest_data
modifier|*
name|data
parameter_list|,
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|nm
index|[
literal|1024
index|]
decl_stmt|,
name|cl
index|[
literal|1024
index|]
decl_stmt|,
name|tp
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|in
init|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|struct
name|todo_item
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|in
condition|)
block|{
name|perror
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|error_exit
argument_list|(
literal|"could not open file"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|in
argument_list|)
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
continue|continue;
comment|/* allow some comments */
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|';'
condition|)
continue|continue;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
name|nm
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|cl
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|tp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|" %1023s %1023s %1023s"
argument_list|,
name|nm
argument_list|,
name|cl
argument_list|,
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
continue|continue;
name|t
operator|=
operator|(
expr|struct
name|todo_item
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
name|error_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|t
operator|->
name|qname
operator|=
name|ldns_dname_new_frm_str
argument_list|(
name|nm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|qname
condition|)
block|{
name|printf
argument_list|(
literal|"parse error: %s\n"
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|error_exit
argument_list|(
literal|"bad qname"
argument_list|)
expr_stmt|;
block|}
name|t
operator|->
name|depth
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|qtype
operator|=
name|LDNS_RR_TYPE_A
expr_stmt|;
name|t
operator|->
name|qclass
operator|=
name|LDNS_RR_CLASS_IN
expr_stmt|;
if|if
condition|(
name|r
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|cl
argument_list|,
literal|"IN"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|cl
argument_list|,
literal|"CH"
argument_list|)
operator|==
literal|0
condition|)
name|t
operator|->
name|qclass
operator|=
name|ldns_get_rr_class_by_name
argument_list|(
name|cl
argument_list|)
expr_stmt|;
else|else
name|t
operator|->
name|qtype
operator|=
name|ldns_get_rr_type_by_name
argument_list|(
name|cl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|>=
literal|3
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|tp
argument_list|,
literal|"IN"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|tp
argument_list|,
literal|"CH"
argument_list|)
operator|==
literal|0
condition|)
name|t
operator|->
name|qclass
operator|=
name|ldns_get_rr_class_by_name
argument_list|(
name|tp
argument_list|)
expr_stmt|;
else|else
name|t
operator|->
name|qtype
operator|=
name|ldns_get_rr_type_by_name
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|num
operator|++
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|data
operator|->
name|orig_list
expr_stmt|;
name|data
operator|->
name|orig_list
operator|=
name|t
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"read %s: %d queries\n"
argument_list|,
name|fname
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** compare two labels */
end_comment

begin_function
specifier|static
name|int
name|lab_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|,
specifier|const
name|void
modifier|*
name|y
parameter_list|)
block|{
return|return
name|ldns_dname_compare
argument_list|(
operator|(
specifier|const
name|ldns_rdf
operator|*
operator|)
name|x
argument_list|,
operator|(
specifier|const
name|ldns_rdf
operator|*
operator|)
name|y
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** create label entry */
end_comment

begin_function
specifier|static
name|struct
name|labdata
modifier|*
name|lab_create
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|labdata
modifier|*
name|lab
init|=
operator|(
expr|struct
name|labdata
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lab
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lab
condition|)
name|error_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|lab
operator|->
name|label
operator|=
name|ldns_dname_new_frm_str
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lab
operator|->
name|label
condition|)
name|error_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|lab
operator|->
name|name
operator|=
name|ldns_dname_new_frm_str
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lab
operator|->
name|name
condition|)
name|error_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|lab
operator|->
name|node
operator|.
name|key
operator|=
name|lab
operator|->
name|label
expr_stmt|;
name|lab
operator|->
name|node
operator|.
name|data
operator|=
name|lab
expr_stmt|;
name|lab
operator|->
name|sublabels
operator|=
name|ldns_rbtree_create
argument_list|(
name|lab_cmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lab
operator|->
name|sublabels
condition|)
name|error_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|lab
operator|->
name|rrlist
operator|=
name|ldns_rr_list_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|lab
operator|->
name|rrlist
condition|)
name|error_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|lab
return|;
block|}
end_function

begin_comment
comment|/** for this name, lookup the label, create if does not exist */
end_comment

begin_function
specifier|static
name|struct
name|labdata
modifier|*
name|find_create_lab
parameter_list|(
name|struct
name|harvest_data
modifier|*
name|data
parameter_list|,
name|ldns_rdf
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|labdata
modifier|*
name|lab
init|=
name|data
operator|->
name|root
decl_stmt|;
name|struct
name|labdata
modifier|*
name|nextlab
decl_stmt|;
name|ldns_rdf
modifier|*
name|next
decl_stmt|;
name|uint8_t
name|numlab
init|=
name|ldns_dname_label_count
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|numlab
operator|>
name|data
operator|->
name|maxlabels
condition|)
name|data
operator|->
name|maxlabels
operator|=
operator|(
name|int
operator|)
name|numlab
expr_stmt|;
while|while
condition|(
name|numlab
operator|--
condition|)
block|{
name|next
operator|=
name|ldns_dname_label
argument_list|(
name|name
argument_list|,
name|numlab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|next
condition|)
name|error_exit
argument_list|(
literal|"ldns_dname_label"
argument_list|)
expr_stmt|;
name|nextlab
operator|=
operator|(
expr|struct
name|labdata
operator|*
operator|)
name|ldns_rbtree_search
argument_list|(
name|lab
operator|->
name|sublabels
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nextlab
condition|)
block|{
comment|/* create it */
name|nextlab
operator|=
operator|(
expr|struct
name|labdata
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lab
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nextlab
condition|)
name|error_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|nextlab
operator|->
name|label
operator|=
name|ldns_rdf_clone
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nextlab
operator|->
name|label
condition|)
name|error_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|nextlab
operator|->
name|node
operator|.
name|key
operator|=
name|nextlab
operator|->
name|label
expr_stmt|;
name|nextlab
operator|->
name|node
operator|.
name|data
operator|=
name|nextlab
expr_stmt|;
name|nextlab
operator|->
name|sublabels
operator|=
name|ldns_rbtree_create
argument_list|(
name|lab_cmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nextlab
operator|->
name|sublabels
condition|)
name|error_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|nextlab
operator|->
name|parent
operator|=
name|lab
expr_stmt|;
name|nextlab
operator|->
name|name
operator|=
name|ldns_rdf_clone
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nextlab
operator|->
name|name
condition|)
name|error_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldns_dname_cat
argument_list|(
name|nextlab
operator|->
name|name
argument_list|,
name|lab
operator|->
name|name
argument_list|)
operator|!=
name|LDNS_STATUS_OK
condition|)
name|error_exit
argument_list|(
literal|"outofmem"
argument_list|)
expr_stmt|;
name|nextlab
operator|->
name|rrlist
operator|=
name|ldns_rr_list_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|nextlab
operator|->
name|rrlist
condition|)
name|error_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ldns_rbtree_insert
argument_list|(
name|lab
operator|->
name|sublabels
argument_list|,
operator|&
name|nextlab
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|hverb
condition|)
block|{
name|printf
argument_list|(
literal|"new label: "
argument_list|)
expr_stmt|;
name|ldns_rdf_print
argument_list|(
name|stdout
argument_list|,
name|nextlab
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|lab
operator|=
name|nextlab
expr_stmt|;
name|ldns_rdf_deep_free
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
return|return
name|lab
return|;
block|}
end_function

begin_comment
comment|/** for given query, create todo items, and labels if needed */
end_comment

begin_function
specifier|static
name|void
name|new_todo_item
parameter_list|(
name|struct
name|harvest_data
modifier|*
name|data
parameter_list|,
name|ldns_rdf
modifier|*
name|qname
parameter_list|,
name|int
name|qtype
parameter_list|,
name|int
name|qclass
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|labdata
modifier|*
name|lab
init|=
name|find_create_lab
argument_list|(
name|data
argument_list|,
name|qname
argument_list|)
decl_stmt|;
name|struct
name|todo_item
modifier|*
name|it
decl_stmt|;
if|if
condition|(
operator|!
name|lab
condition|)
name|error_exit
argument_list|(
literal|"out of memory creating new label"
argument_list|)
expr_stmt|;
name|it
operator|=
operator|(
expr|struct
name|todo_item
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|it
argument_list|)
argument_list|)
expr_stmt|;
name|it
operator|->
name|qname
operator|=
name|ldns_rdf_clone
argument_list|(
name|qname
argument_list|)
expr_stmt|;
name|it
operator|->
name|qtype
operator|=
name|qtype
expr_stmt|;
name|it
operator|->
name|qclass
operator|=
name|qclass
expr_stmt|;
name|it
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
name|it
operator|->
name|lab
operator|=
name|lab
expr_stmt|;
name|it
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|todo_last
condition|)
name|data
operator|->
name|todo_last
operator|->
name|next
operator|=
name|it
expr_stmt|;
else|else
name|data
operator|->
name|todo_list
operator|=
name|it
expr_stmt|;
name|data
operator|->
name|todo_last
operator|=
name|it
expr_stmt|;
name|data
operator|->
name|numtodo
operator|++
expr_stmt|;
if|if
condition|(
name|hverb
operator|>=
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"new todo: "
argument_list|)
expr_stmt|;
name|ldns_rdf_print
argument_list|(
name|stdout
argument_list|,
name|it
operator|->
name|qname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldns_rr_descript
argument_list|(
operator|(
name|uint16_t
operator|)
name|it
operator|->
name|qtype
argument_list|)
operator|&&
name|ldns_rr_descript
argument_list|(
operator|(
name|uint16_t
operator|)
name|it
operator|->
name|qtype
argument_list|)
operator|->
name|_name
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|ldns_rr_descript
argument_list|(
operator|(
name|uint16_t
operator|)
name|it
operator|->
name|qtype
argument_list|)
operator|->
name|_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldns_lookup_by_id
argument_list|(
name|ldns_rr_classes
argument_list|,
name|it
operator|->
name|qclass
argument_list|)
operator|&&
name|ldns_lookup_by_id
argument_list|(
name|ldns_rr_classes
argument_list|,
name|it
operator|->
name|qclass
argument_list|)
operator|->
name|name
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|ldns_lookup_by_id
argument_list|(
name|ldns_rr_classes
argument_list|,
name|it
operator|->
name|qclass
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** add infra todo items for this query */
end_comment

begin_function
specifier|static
name|void
name|new_todo_infra
parameter_list|(
name|struct
name|harvest_data
modifier|*
name|data
parameter_list|,
name|struct
name|labdata
modifier|*
name|startlab
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|struct
name|labdata
modifier|*
name|lab
decl_stmt|;
for|for
control|(
name|lab
operator|=
name|startlab
init|;
name|lab
condition|;
name|lab
operator|=
name|lab
operator|->
name|parent
control|)
block|{
if|if
condition|(
name|lab
operator|->
name|done
condition|)
return|return;
name|new_todo_item
argument_list|(
name|data
argument_list|,
name|lab
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_NS
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|new_todo_item
argument_list|(
name|data
argument_list|,
name|lab
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_SOA
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|new_todo_item
argument_list|(
name|data
argument_list|,
name|lab
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_DNSKEY
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|new_todo_item
argument_list|(
name|data
argument_list|,
name|lab
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_DS
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|new_todo_item
argument_list|(
name|data
argument_list|,
name|lab
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_A
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|new_todo_item
argument_list|(
name|data
argument_list|,
name|lab
operator|->
name|name
argument_list|,
name|LDNS_RR_TYPE_AAAA
argument_list|,
name|LDNS_RR_CLASS_IN
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|lab
operator|->
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** make todo items for initial data */
end_comment

begin_function
specifier|static
name|void
name|make_todo
parameter_list|(
name|struct
name|harvest_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|todo_item
modifier|*
name|it
decl_stmt|;
for|for
control|(
name|it
operator|=
name|data
operator|->
name|orig_list
init|;
name|it
condition|;
name|it
operator|=
name|it
operator|->
name|next
control|)
block|{
comment|/* create todo item for this query itself */
name|new_todo_item
argument_list|(
name|data
argument_list|,
name|it
operator|->
name|qname
argument_list|,
name|it
operator|->
name|qtype
argument_list|,
name|it
operator|->
name|qclass
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* create todo items for infra queries to support it */
name|new_todo_infra
argument_list|(
name|data
argument_list|,
name|data
operator|->
name|todo_list
operator|->
name|lab
argument_list|,
name|data
operator|->
name|todo_list
operator|->
name|depth
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** store RR and make new work items for it if needed */
end_comment

begin_function
specifier|static
name|void
name|process_rr
parameter_list|(
name|struct
name|harvest_data
modifier|*
name|data
parameter_list|,
name|ldns_rr
modifier|*
name|rr
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
comment|/* must free or store rr */
name|struct
name|labdata
modifier|*
name|lab
init|=
name|find_create_lab
argument_list|(
name|data
argument_list|,
name|ldns_rr_owner
argument_list|(
name|rr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lab
condition|)
name|error_exit
argument_list|(
literal|"cannot find/create label"
argument_list|)
expr_stmt|;
comment|/* generate extra queries */
if|if
condition|(
name|ldns_rr_get_type
argument_list|(
name|rr
argument_list|)
operator|==
name|LDNS_RR_TYPE_NS
condition|)
block|{
name|new_todo_infra
argument_list|(
name|data
argument_list|,
name|find_create_lab
argument_list|(
name|data
argument_list|,
name|ldns_rr_ns_nsdname
argument_list|(
name|rr
argument_list|)
argument_list|)
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ldns_rr_get_type
argument_list|(
name|rr
argument_list|)
operator|==
name|LDNS_RR_TYPE_MX
condition|)
block|{
name|new_todo_infra
argument_list|(
name|data
argument_list|,
name|find_create_lab
argument_list|(
name|data
argument_list|,
name|ldns_rr_mx_exchange
argument_list|(
name|rr
argument_list|)
argument_list|)
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ldns_rr_get_type
argument_list|(
name|rr
argument_list|)
operator|==
name|LDNS_RR_TYPE_SOA
condition|)
block|{
name|new_todo_infra
argument_list|(
name|data
argument_list|,
name|find_create_lab
argument_list|(
name|data
argument_list|,
name|ldns_rr_rdf
argument_list|(
name|rr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ldns_rr_get_type
argument_list|(
name|rr
argument_list|)
operator|==
name|LDNS_RR_TYPE_CNAME
condition|)
block|{
name|int
name|t
init|=
name|ldns_rr_get_type
argument_list|(
name|rr
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|LDNS_RR_TYPE_A
operator|&&
name|t
operator|!=
name|LDNS_RR_TYPE_AAAA
operator|&&
name|t
operator|!=
name|LDNS_RR_TYPE_SOA
operator|&&
name|t
operator|!=
name|LDNS_RR_TYPE_NS
operator|&&
name|t
operator|!=
name|LDNS_RR_TYPE_DS
operator|&&
name|t
operator|!=
name|LDNS_RR_TYPE_DNSKEY
condition|)
name|new_todo_item
argument_list|(
name|data
argument_list|,
name|ldns_rr_rdf
argument_list|(
name|rr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|t
argument_list|,
name|ldns_rr_get_class
argument_list|(
name|rr
argument_list|)
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* can get caught in CNAME loop, but depth will 			 * catch that; unbound cache helps too(servfails on 			 * a cname loop) */
name|new_todo_infra
argument_list|(
name|data
argument_list|,
name|find_create_lab
argument_list|(
name|data
argument_list|,
name|ldns_rr_rdf
argument_list|(
name|rr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* store it */
if|if
condition|(
name|ldns_rr_get_type
argument_list|(
name|rr
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC
condition|)
block|{
comment|/* find correct zone to store NSEC in (for delegation zones) */
if|if
condition|(
name|ldns_dname_compare
argument_list|(
name|ldns_rr_rdf
argument_list|(
name|rr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ldns_rr_owner
argument_list|(
name|rr
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* store at the single name = apex */
block|}
elseif|else
if|if
condition|(
operator|!
name|ldns_dname_is_subdomain
argument_list|(
name|ldns_rr_rdf
argument_list|(
name|rr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ldns_rr_owner
argument_list|(
name|rr
argument_list|)
argument_list|)
operator|&&
name|lab
operator|->
name|parent
condition|)
block|{
comment|/* if   owner NSEC subdomain-of-owner then 		 	 * store at owner (owner is apex or empty nonterminal). 		 	 * Otherwise at owner parent. */
name|lab
operator|=
name|lab
operator|->
name|parent
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ldns_rr_get_type
argument_list|(
name|rr
argument_list|)
operator|==
name|LDNS_RR_TYPE_DS
condition|)
block|{
comment|/* store DSes in parent zone */
if|if
condition|(
name|lab
operator|->
name|parent
condition|)
name|lab
operator|=
name|lab
operator|->
name|parent
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ldns_rr_get_type
argument_list|(
name|rr
argument_list|)
operator|==
name|LDNS_RR_TYPE_NSEC3
condition|)
block|{
comment|/* store NSEC3s one label up at zone apex */
if|if
condition|(
name|lab
operator|->
name|parent
condition|)
name|lab
operator|=
name|lab
operator|->
name|parent
expr_stmt|;
block|}
comment|/* we assume NS set is equal across parent-child border. */
if|if
condition|(
operator|!
name|ldns_rr_list_contains_rr
argument_list|(
name|lab
operator|->
name|rrlist
argument_list|,
name|rr
argument_list|)
condition|)
block|{
if|if
condition|(
name|hverb
operator|>=
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"store RR "
argument_list|)
expr_stmt|;
name|ldns_rr_print
argument_list|(
name|stdout
argument_list|,
name|rr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ldns_rr_list_push_rr
argument_list|(
name|lab
operator|->
name|rrlist
argument_list|,
name|rr
argument_list|)
condition|)
name|error_exit
argument_list|(
literal|"outofmem ldns_rr_list_push_rr"
argument_list|)
expr_stmt|;
name|data
operator|->
name|num_rrs
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hverb
operator|>=
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"duplicate RR "
argument_list|)
expr_stmt|;
name|ldns_rr_print
argument_list|(
name|stdout
argument_list|,
name|rr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|ldns_rr_free
argument_list|(
name|rr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** store RRs and make new work items if needed */
end_comment

begin_function
specifier|static
name|void
name|process_pkt
parameter_list|(
name|struct
name|harvest_data
modifier|*
name|data
parameter_list|,
name|ldns_pkt
modifier|*
name|pkt
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|ldns_rr_list
modifier|*
name|list
decl_stmt|;
name|list
operator|=
name|ldns_pkt_get_section_clone
argument_list|(
name|pkt
argument_list|,
name|LDNS_SECTION_ANY_NOQUESTION
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
name|error_exit
argument_list|(
literal|"outofmemory"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|list
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|process_rr
argument_list|(
name|data
argument_list|,
name|ldns_rr_list_rr
argument_list|(
name|list
argument_list|,
name|i
argument_list|)
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
name|ldns_rr_list_free
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** process a todo item */
end_comment

begin_function
specifier|static
name|void
name|process
parameter_list|(
name|struct
name|harvest_data
modifier|*
name|data
parameter_list|,
name|struct
name|todo_item
modifier|*
name|it
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|char
modifier|*
name|nm
decl_stmt|;
name|struct
name|ub_result
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|ldns_pkt
modifier|*
name|pkt
init|=
name|NULL
decl_stmt|;
name|ldns_status
name|s
decl_stmt|;
if|if
condition|(
name|hverb
condition|)
block|{
name|printf
argument_list|(
literal|"process: "
argument_list|)
expr_stmt|;
name|ldns_rdf_print
argument_list|(
name|stdout
argument_list|,
name|it
operator|->
name|qname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldns_rr_descript
argument_list|(
operator|(
name|uint16_t
operator|)
name|it
operator|->
name|qtype
argument_list|)
operator|&&
name|ldns_rr_descript
argument_list|(
operator|(
name|uint16_t
operator|)
name|it
operator|->
name|qtype
argument_list|)
operator|->
name|_name
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|ldns_rr_descript
argument_list|(
operator|(
name|uint16_t
operator|)
name|it
operator|->
name|qtype
argument_list|)
operator|->
name|_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldns_lookup_by_id
argument_list|(
name|ldns_rr_classes
argument_list|,
name|it
operator|->
name|qclass
argument_list|)
operator|&&
name|ldns_lookup_by_id
argument_list|(
name|ldns_rr_classes
argument_list|,
name|it
operator|->
name|qclass
argument_list|)
operator|->
name|name
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|ldns_lookup_by_id
argument_list|(
name|ldns_rr_classes
argument_list|,
name|it
operator|->
name|qclass
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* do lookup */
name|nm
operator|=
name|ldns_rdf2str
argument_list|(
name|it
operator|->
name|qname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nm
condition|)
name|error_exit
argument_list|(
literal|"ldns_rdf2str"
argument_list|)
expr_stmt|;
name|r
operator|=
name|ub_resolve
argument_list|(
name|data
operator|->
name|ctx
argument_list|,
name|nm
argument_list|,
name|it
operator|->
name|qtype
argument_list|,
name|it
operator|->
name|qclass
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ub_resolve(%s, %d, %d): %s\n"
argument_list|,
name|nm
argument_list|,
name|it
operator|->
name|qtype
argument_list|,
name|it
operator|->
name|qclass
argument_list|,
name|ub_strerror
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|result
operator|->
name|rcode
operator|==
name|LDNS_RCODE_SERVFAIL
condition|)
block|{
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* even if result is a negative, try to store resulting SOA/NSEC */
comment|/* create ldns pkt */
name|s
operator|=
name|ldns_wire2pkt
argument_list|(
operator|&
name|pkt
argument_list|,
name|result
operator|->
name|answer_packet
argument_list|,
operator|(
name|size_t
operator|)
name|result
operator|->
name|answer_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|LDNS_STATUS_OK
condition|)
block|{
name|printf
argument_list|(
literal|"ldns_wire2pkt failed! %s %d %d %s %d\n"
argument_list|,
name|nm
argument_list|,
name|it
operator|->
name|qtype
argument_list|,
name|it
operator|->
name|qclass
argument_list|,
name|ldns_get_errorstr_by_id
argument_list|(
name|s
argument_list|)
argument_list|,
name|result
operator|->
name|answer_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hverb
operator|>=
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"answer: "
argument_list|)
expr_stmt|;
name|ldns_pkt_print
argument_list|(
name|stdout
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* process results */
name|process_pkt
argument_list|(
name|data
argument_list|,
name|pkt
argument_list|,
name|it
operator|->
name|depth
argument_list|)
expr_stmt|;
name|ldns_pkt_free
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nm
argument_list|)
expr_stmt|;
name|ub_resolve_free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** perform main harvesting */
end_comment

begin_function
specifier|static
name|void
name|harvest_main
parameter_list|(
name|struct
name|harvest_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|todo_item
modifier|*
name|it
decl_stmt|;
name|int
name|numdone
init|=
literal|0
decl_stmt|;
comment|/* register todo queries for all original queries */
name|make_todo
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"depth 0: done %d todo %d\n"
argument_list|,
literal|0
argument_list|,
name|data
operator|->
name|numtodo
argument_list|)
expr_stmt|;
comment|/* pick up a todo item and process it */
while|while
condition|(
name|data
operator|->
name|todo_list
condition|)
block|{
name|numdone
operator|++
expr_stmt|;
name|it
operator|=
name|data
operator|->
name|todo_list
expr_stmt|;
name|data
operator|->
name|todo_list
operator|=
name|it
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|->
name|todo_list
condition|)
name|data
operator|->
name|todo_last
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|numdone
operator|%
literal|1000
operator|==
literal|0
operator|||
name|it
operator|->
name|depth
operator|>
name|data
operator|->
name|curdepth
condition|)
block|{
name|data
operator|->
name|curdepth
operator|=
name|it
operator|->
name|depth
expr_stmt|;
name|printf
argument_list|(
literal|"depth %d: done %d todo %d, %d rrs\n"
argument_list|,
name|it
operator|->
name|depth
argument_list|,
name|numdone
argument_list|,
name|data
operator|->
name|numtodo
argument_list|,
name|data
operator|->
name|num_rrs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|it
operator|->
name|depth
operator|>=
name|data
operator|->
name|maxdepth
condition|)
block|{
name|printf
argument_list|(
literal|"obtained %d rrs to a max of %d labels.\n"
argument_list|,
name|data
operator|->
name|num_rrs
argument_list|,
name|data
operator|->
name|maxlabels
argument_list|)
expr_stmt|;
return|return;
block|}
name|data
operator|->
name|numtodo
operator|--
expr_stmt|;
name|process
argument_list|(
name|data
argument_list|,
name|it
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
literal|1000000
operator|/
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** create directory if it does not exist */
end_comment

begin_function
specifier|static
name|void
name|hv_mkdir
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MKDIR_HAS_ONE_ARG
if|if
condition|(
name|mkdir
argument_list|(
name|dir
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|mkdir
argument_list|(
name|dir
argument_list|,
literal|0755
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|errno
operator|==
name|EEXIST
condition|)
return|return;
name|perror
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|error_exit
argument_list|(
literal|"mkdir failed"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** see if rrlist contains a SOA record */
specifier|static
name|ldns_rr
modifier|*
name|has_SOA
parameter_list|(
name|ldns_rr_list
modifier|*
name|list
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|list
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ldns_rr_get_type
argument_list|(
name|ldns_rr_list_rr
argument_list|(
name|list
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|LDNS_RR_TYPE_SOA
condition|)
return|return
name|ldns_rr_list_rr
argument_list|(
name|list
argument_list|,
name|i
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
comment|/** write moredata for a zone*/
specifier|static
name|void
name|write_moredata
parameter_list|(
name|struct
name|harvest_data
modifier|*
name|data
parameter_list|,
name|struct
name|labdata
modifier|*
name|zone
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|struct
name|labdata
modifier|*
name|thislab
parameter_list|,
name|ldns_rr
modifier|*
name|nslist
parameter_list|)
block|{
name|struct
name|labdata
modifier|*
name|lab
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|ldns_rr
modifier|*
name|ns
decl_stmt|;
name|LDNS_RBTREE_FOR
argument_list|(
argument|lab
argument_list|,
argument|struct labdata*
argument_list|,
argument|thislab->sublabels
argument_list|)
block|{
if|if
condition|(
name|has_SOA
argument_list|(
name|lab
operator|->
name|rrlist
argument_list|)
condition|)
block|{
comment|/* copy only NS glue */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|lab
operator|->
name|rrlist
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ns
operator|=
name|ldns_rr_list_rr
argument_list|(
name|lab
operator|->
name|rrlist
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldns_rr_get_type
argument_list|(
name|ns
argument_list|)
operator|==
name|LDNS_RR_TYPE_NS
condition|)
block|{
name|ldns_rr_print
argument_list|(
name|f
argument_list|,
name|ns
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldns_dname_is_subdomain
argument_list|(
name|ldns_rr_ns_nsdname
argument_list|(
name|ns
argument_list|)
argument_list|,
name|lab
operator|->
name|name
argument_list|)
condition|)
block|{
name|ldns_rr_push_rdf
argument_list|(
name|nslist
argument_list|,
name|ldns_rdf_clone
argument_list|(
name|ldns_rr_ns_nsdname
argument_list|(
name|ns
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* copy all, recurse */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|lab
operator|->
name|rrlist
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ldns_rr_print
argument_list|(
name|f
argument_list|,
name|ldns_rr_list_rr
argument_list|(
name|lab
operator|->
name|rrlist
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|write_moredata
argument_list|(
name|data
argument_list|,
name|zone
argument_list|,
name|f
argument_list|,
name|lab
argument_list|,
name|nslist
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** find and write glue into zone file */
specifier|static
name|void
name|write_glue
parameter_list|(
name|struct
name|harvest_data
modifier|*
name|data
parameter_list|,
name|struct
name|labdata
modifier|*
name|thislab
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|,
name|ldns_rdf
modifier|*
name|name
parameter_list|,
name|int
name|dep
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|struct
name|labdata
modifier|*
name|lab
decl_stmt|;
name|ldns_rr
modifier|*
name|rr
decl_stmt|;
if|if
condition|(
name|ldns_dname_compare
argument_list|(
name|name
argument_list|,
name|thislab
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* this is it! Did we go outside the zone? */
if|if
condition|(
name|dep
operator|==
literal|0
condition|)
return|return;
comment|/* find A and AAAA */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|thislab
operator|->
name|rrlist
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rr
operator|=
name|ldns_rr_list_rr
argument_list|(
name|thislab
operator|->
name|rrlist
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldns_rr_get_type
argument_list|(
name|rr
argument_list|)
operator|==
name|LDNS_RR_TYPE_A
operator|||
name|ldns_rr_get_type
argument_list|(
name|rr
argument_list|)
operator|==
name|LDNS_RR_TYPE_AAAA
condition|)
block|{
name|ldns_rr_print
argument_list|(
name|f
argument_list|,
name|rr
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/* recurse deeper */
name|LDNS_RBTREE_FOR
argument_list|(
argument|lab
argument_list|,
argument|struct labdata*
argument_list|,
argument|thislab->sublabels
argument_list|)
block|{
if|if
condition|(
name|has_SOA
argument_list|(
name|lab
operator|->
name|rrlist
argument_list|)
condition|)
block|{
name|write_glue
argument_list|(
name|data
argument_list|,
name|lab
argument_list|,
name|f
argument_list|,
name|name
argument_list|,
name|dep
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|write_glue
argument_list|(
name|data
argument_list|,
name|lab
argument_list|,
name|f
argument_list|,
name|name
argument_list|,
name|dep
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** write zonefile for zone at this apex */
specifier|static
name|void
name|write_zonefile
parameter_list|(
name|struct
name|harvest_data
modifier|*
name|data
parameter_list|,
name|int
name|dep
parameter_list|,
name|FILE
modifier|*
name|zlist
parameter_list|,
name|struct
name|labdata
modifier|*
name|apex
parameter_list|,
name|ldns_rr
modifier|*
name|soa
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
name|fname
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|zname
init|=
name|ldns_rdf2str
argument_list|(
name|apex
operator|->
name|name
argument_list|)
decl_stmt|;
name|time_t
name|tm
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|ldns_rr
modifier|*
name|nslist
decl_stmt|;
if|if
condition|(
operator|!
name|zname
condition|)
name|error_exit
argument_list|(
literal|"out of mem ldns_rdf2str"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|zname
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
name|snprintf
argument_list|(
name|fname
argument_list|,
sizeof|sizeof
argument_list|(
name|fname
argument_list|)
argument_list|,
literal|"l%d/root.zone"
argument_list|,
name|dep
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|fname
argument_list|,
sizeof|sizeof
argument_list|(
name|fname
argument_list|)
argument_list|,
literal|"l%d/%szone"
argument_list|,
name|dep
argument_list|,
name|zname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|zlist
argument_list|,
literal|"zone: name: \"%s\" %s%szonefile: \"%s\"\n"
argument_list|,
name|zname
argument_list|,
name|strlen
argument_list|(
name|zname
argument_list|)
operator|/
literal|8
operator|<
literal|1
condition|?
literal|"\t"
else|:
literal|""
argument_list|,
name|strlen
argument_list|(
name|zname
argument_list|)
operator|/
literal|8
operator|<
literal|2
condition|?
literal|"\t"
else|:
literal|""
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hverb
condition|)
name|printf
argument_list|(
literal|"writing %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|perror
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|error_exit
argument_list|(
literal|"cannot open zone file"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"; %s - generated by harvest program.\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"; zone name %s - this is a partial snapshot of "
literal|"data relevant to the query list.\n"
argument_list|,
name|zname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"; created %u - date %s\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|tm
argument_list|,
name|ctime
argument_list|(
operator|&
name|tm
argument_list|)
argument_list|)
expr_stmt|;
name|ldns_rr_print
argument_list|(
name|f
argument_list|,
name|soa
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|apex
operator|->
name|rrlist
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ldns_rr_get_type
argument_list|(
name|ldns_rr_list_rr
argument_list|(
name|apex
operator|->
name|rrlist
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|LDNS_RR_TYPE_SOA
condition|)
continue|continue;
name|ldns_rr_print
argument_list|(
name|f
argument_list|,
name|ldns_rr_list_rr
argument_list|(
name|apex
operator|->
name|rrlist
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* search for more data - subdomains inside the zone, NS glue */
name|nslist
operator|=
name|ldns_rr_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|nslist
condition|)
name|error_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"; end of apex, more data follows\n"
argument_list|)
expr_stmt|;
name|write_moredata
argument_list|(
name|data
argument_list|,
name|apex
argument_list|,
name|f
argument_list|,
name|apex
argument_list|,
name|nslist
argument_list|)
expr_stmt|;
comment|/* add NS from apex that need glue too */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_list_rr_count
argument_list|(
name|apex
operator|->
name|rrlist
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ldns_rr_get_type
argument_list|(
name|ldns_rr_list_rr
argument_list|(
name|apex
operator|->
name|rrlist
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|LDNS_RR_TYPE_NS
condition|)
continue|continue;
comment|/* these are only added again if in a subzone */
if|if
condition|(
name|ldns_dname_is_subdomain
argument_list|(
name|ldns_rr_ns_nsdname
argument_list|(
name|ldns_rr_list_rr
argument_list|(
name|apex
operator|->
name|rrlist
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|apex
operator|->
name|name
argument_list|)
condition|)
block|{
name|ldns_rr_push_rdf
argument_list|(
name|nslist
argument_list|,
name|ldns_rdf_clone
argument_list|(
name|ldns_rr_ns_nsdname
argument_list|(
name|ldns_rr_list_rr
argument_list|(
name|apex
operator|->
name|rrlist
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"; glue data follows\n"
argument_list|)
expr_stmt|;
comment|/* lookup and add glue (if not already in zone) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ldns_rr_rd_count
argument_list|(
name|nslist
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|write_glue
argument_list|(
name|data
argument_list|,
name|apex
argument_list|,
name|f
argument_list|,
name|ldns_rr_rdf
argument_list|(
name|nslist
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|ldns_rr_free
argument_list|(
name|nslist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zname
argument_list|)
expr_stmt|;
block|}
comment|/** create zones at depth d in label tree */
specifier|static
name|void
name|create_zones
parameter_list|(
name|struct
name|harvest_data
modifier|*
name|data
parameter_list|,
name|int
name|dep
parameter_list|,
name|FILE
modifier|*
name|zlist
parameter_list|,
name|struct
name|labdata
modifier|*
name|labnow
parameter_list|,
name|int
name|depnow
parameter_list|)
block|{
name|struct
name|labdata
modifier|*
name|s
decl_stmt|;
name|ldns_rr
modifier|*
name|soa
decl_stmt|;
if|if
condition|(
name|depnow
operator|==
name|dep
condition|)
block|{
comment|/* see if this is a zone start - a SOA */
if|if
condition|(
operator|(
name|soa
operator|=
name|has_SOA
argument_list|(
name|labnow
operator|->
name|rrlist
argument_list|)
operator|)
condition|)
block|{
name|write_zonefile
argument_list|(
name|data
argument_list|,
name|dep
argument_list|,
name|zlist
argument_list|,
name|labnow
argument_list|,
name|soa
argument_list|)
expr_stmt|;
name|data
operator|->
name|num_zones
operator|++
expr_stmt|;
block|}
return|return;
block|}
comment|/* recurse */
name|LDNS_RBTREE_FOR
argument_list|(
argument|s
argument_list|,
argument|struct labdata*
argument_list|,
argument|labnow->sublabels
argument_list|)
block|{
name|create_zones
argument_list|(
name|data
argument_list|,
name|dep
argument_list|,
name|zlist
argument_list|,
name|s
argument_list|,
name|depnow
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** sort rrlists */
specifier|static
name|void
name|harvest_sort
parameter_list|(
name|struct
name|labdata
modifier|*
name|lab
parameter_list|)
block|{
name|struct
name|labdata
modifier|*
name|s
decl_stmt|;
comment|/* prettier output if sorted here */
name|ldns_rr_list_sort
argument_list|(
name|lab
operator|->
name|rrlist
argument_list|)
expr_stmt|;
comment|/* and recurse */
name|LDNS_RBTREE_FOR
argument_list|(
argument|s
argument_list|,
argument|struct labdata*
argument_list|,
argument|lab->sublabels
argument_list|)
block|{
name|harvest_sort
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** output harvested results */
specifier|static
name|void
name|harvest_output
parameter_list|(
name|struct
name|harvest_data
modifier|*
name|data
parameter_list|)
block|{
name|int
name|d
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|FILE
modifier|*
name|zlist
decl_stmt|;
name|int
name|lastzones
decl_stmt|;
name|hv_mkdir
argument_list|(
name|data
operator|->
name|resultdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|data
operator|->
name|resultdir
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|data
operator|->
name|resultdir
argument_list|)
expr_stmt|;
name|error_exit
argument_list|(
literal|"cannot chdir"
argument_list|)
expr_stmt|;
block|}
name|harvest_sort
argument_list|(
name|data
operator|->
name|root
argument_list|)
expr_stmt|;
comment|/* create zones */
for|for
control|(
name|d
operator|=
literal|0
init|;
name|d
operator|<
name|data
operator|->
name|maxlabels
condition|;
name|d
operator|++
control|)
block|{
name|lastzones
operator|=
name|data
operator|->
name|num_zones
expr_stmt|;
name|printf
argument_list|(
literal|"creating zones %d\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"l%d"
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|hv_mkdir
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"l%d.zones"
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|zlist
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zlist
condition|)
block|{
name|perror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|error_exit
argument_list|(
literal|"cannot write zonelist file"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|zlist
argument_list|,
literal|"# partial zones at depth %d\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|create_zones
argument_list|(
name|data
argument_list|,
name|d
argument_list|,
name|zlist
argument_list|,
name|data
operator|->
name|root
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|zlist
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"creating zones %d - %d zones written\n"
argument_list|,
name|d
argument_list|,
name|data
operator|->
name|num_zones
operator|-
name|lastzones
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** getopt global, in case header files fail to declare it. */
specifier|extern
name|int
name|optind
decl_stmt|;
comment|/** getopt global, in case header files fail to declare it. */
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
comment|/** main program for harvest */
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|struct
name|harvest_data
name|data
decl_stmt|;
name|char
modifier|*
name|nm
init|=
name|argv
index|[
literal|0
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* defaults */
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|ctx
operator|=
name|ub_ctx_create
argument_list|()
expr_stmt|;
name|data
operator|.
name|resultdir
operator|=
name|strdup
argument_list|(
literal|"harvested_zones"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|.
name|resultdir
condition|)
name|error_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|data
operator|.
name|maxdepth
operator|=
literal|2
expr_stmt|;
comment|/* parse the options */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"hf:vC:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'C'
case|:
if|if
condition|(
name|ub_ctx_config
argument_list|(
name|data
operator|.
name|ctx
argument_list|,
name|optarg
argument_list|)
operator|!=
literal|0
condition|)
name|error_exit
argument_list|(
literal|"config read failed"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|qlist_read_file
argument_list|(
operator|&
name|data
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|hverb
operator|++
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
case|case
literal|'h'
case|:
default|default:
name|usage
argument_list|(
name|nm
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
name|usage
argument_list|(
name|nm
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|orig_list
operator|==
name|NULL
condition|)
name|error_exit
argument_list|(
literal|"No queries to make, use -f (help with -h)."
argument_list|)
expr_stmt|;
name|data
operator|.
name|root
operator|=
name|lab_create
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
operator|.
name|root
condition|)
name|error_exit
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
comment|/* harvest the data */
name|harvest_main
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
name|harvest_output
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
comment|/* no cleanup except the context (to close open sockets) */
name|ub_ctx_delete
argument_list|(
name|data
operator|.
name|ctx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

